This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: app
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
app/.eslintignore
app/.eslintrc.js
app/.gitignore
app/.prettierrc
app/android/app/src/main/res/xml/network_security_config.xml
app/app.config.js
app/App.tsx
app/babel.config.js
app/docs/guides/BUILD_LOCAL_GUIDE.md
app/docs/guides/BUILD_QUICKSTART.md
app/docs/guides/EAS_PROJECT_SETUP_GUIDE.md
app/docs/guides/FIRST_UPLOAD_GUIDE.md
app/docs/guides/PLAY_STORE_PUBLISHING.md
app/eas.json
app/index.ts
app/ios/.gitignore
app/ios/.xcode.env
app/ios/pizza.xcodeproj/project.pbxproj
app/ios/pizza.xcodeproj/xcshareddata/xcschemes/pizza.xcscheme
app/ios/pizza/AppDelegate.swift
app/ios/pizza/Images.xcassets/AppIcon.appiconset/Contents.json
app/ios/pizza/Images.xcassets/Contents.json
app/ios/pizza/Images.xcassets/SplashScreenBackground.colorset/Contents.json
app/ios/pizza/Info.plist
app/ios/pizza/pizza-Bridging-Header.h
app/ios/pizza/pizza.entitlements
app/ios/pizza/SplashScreen.storyboard
app/ios/pizza/Supporting/Expo.plist
app/ios/Podfile
app/ios/Podfile.properties.json
app/metro.config.js
app/package.json
app/plugins/withCustomIcons.js
app/scripts/check-new-arch-compatibility.js
app/scripts/dev/reset-project.sh
app/scripts/install-android-sdk.sh
app/scripts/install-java.sh
app/scripts/release-to-playstore.sh
app/scripts/verify-android-setup.sh
app/src/app/components/common/AdaptiveModal.tsx
app/src/app/components/common/AnimatedLabelInput.tsx
app/src/app/components/common/AnimatedLabelSelector.tsx
app/src/app/components/common/AutoImage.tsx
app/src/app/components/common/ConfirmationModal.tsx
app/src/app/components/common/CustomImagePicker.tsx
app/src/app/components/common/EmptyState.tsx
app/src/app/components/common/GlobalSnackbar.tsx
app/src/app/components/common/PhoneNumberInput.tsx
app/src/app/components/common/SpeechRecognitionInput.tsx
app/src/app/components/ConnectionErrorModal.tsx
app/src/app/components/ConnectionIndicator.tsx
app/src/app/components/crud/GenericDetailModal.tsx
app/src/app/components/crud/GenericFormModal.tsx
app/src/app/components/crud/GenericList.tsx
app/src/app/components/DateTimePickerSafe.tsx
app/src/app/components/OrientationTransition.tsx
app/src/app/components/responsive/index.ts
app/src/app/components/responsive/ResponsiveGrid.tsx
app/src/app/components/responsive/ResponsiveImage.tsx
app/src/app/components/responsive/ResponsiveModal.tsx
app/src/app/components/responsive/ResponsiveView.tsx
app/src/app/components/ServerConfigModal.tsx
app/src/app/components/ShiftIndicator.tsx
app/src/app/constants/apiErrorCodes.ts
app/src/app/constants/apiPaths.ts
app/src/app/constants/navigationPaths.ts
app/src/app/constants/network.ts
app/src/app/constants/rolePermissions.ts
app/src/app/constants/storageKeys.ts
app/src/app/docs/DateTimePickerUsage.md
app/src/app/docs/RESPONSIVE_GUIDE.md
app/src/app/hooks/useCrudScreenLogic.ts
app/src/app/hooks/useGlobalShift.ts
app/src/app/hooks/useInitializeAuth.ts
app/src/app/hooks/useListState.ts
app/src/app/hooks/useNativeDriver.ts
app/src/app/hooks/useRefreshOnFocus.ts
app/src/app/hooks/useResponsive.ts
app/src/app/hooks/useServerConnection.ts
app/src/app/lib/apiHelpers.ts
app/src/app/lib/apiResponseHelper.ts
app/src/app/lib/errorMapping.ts
app/src/app/lib/errors.ts
app/src/app/lib/formatters.ts
app/src/app/lib/IMAGE_CACHE_GUIDE.md
app/src/app/lib/imageCache.ts
app/src/app/lib/imageUploadService.ts
app/src/app/lib/imageUtils.ts
app/src/app/lib/zodResolver.ts
app/src/app/navigation/AppDrawerNavigator.tsx
app/src/app/navigation/AppNavigator.tsx
app/src/app/navigation/AuthStack.tsx
app/src/app/navigation/components/CustomDrawerContent.tsx
app/src/app/navigation/components/WebDrawer.tsx
app/src/app/navigation/components/WebDrawerContent.tsx
app/src/app/navigation/ConditionalAppNavigator.tsx
app/src/app/navigation/helpers/navigationHelpers.ts
app/src/app/navigation/KitchenOnlyNavigator.tsx
app/src/app/navigation/KitchenWebNavigator.tsx
app/src/app/navigation/options.ts
app/src/app/navigation/OrdersStackNavigator.tsx
app/src/app/navigation/types.ts
app/src/app/schemas/domain/adjustment.schema.ts
app/src/app/schemas/domain/area.schema.ts
app/src/app/schemas/domain/category.schema.ts
app/src/app/schemas/domain/delivery-info.schema.ts
app/src/app/schemas/domain/modifier-group.schema.ts
app/src/app/schemas/domain/modifier.schema.ts
app/src/app/schemas/domain/order.schema.ts
app/src/app/schemas/domain/photo.schema.ts
app/src/app/schemas/domain/preparation-screen.schema.ts
app/src/app/schemas/domain/product-variant.schema.ts
app/src/app/schemas/domain/product.schema.ts
app/src/app/schemas/domain/subcategory.schema.ts
app/src/app/schemas/domain/table.schema.ts
app/src/app/services/apiClient.ts
app/src/app/services/apiClientWrapper.ts
app/src/app/services/certificateValidator.ts
app/src/app/services/discoveryService.ts
app/src/app/services/secureStorageService.ts
app/src/app/store/authStore.ts
app/src/app/store/snackbarStore.ts
app/src/app/store/themeStore.ts
app/src/app/styles/colors.ts
app/src/app/styles/responsive.ts
app/src/app/styles/theme.ts
app/src/app/styles/typography.ts
app/src/app/types/api.types.ts
app/src/app/types/query.types.ts
app/src/app/types/theme.types.ts
app/src/app/utils/__tests__/dateTimeHelpers.test.ts
app/src/app/utils/dateTimeHelpers.ts
app/src/app/utils/networkDiagnostics.ts
app/src/app/utils/orderFormatters.ts
app/src/app/utils/roleUtils.ts
app/src/app/utils/shadowStyles.ts
app/src/app/utils/tokenVerification.ts
app/src/components/AudioOrderModal.tsx
app/src/components/AudioRecorderWidget.tsx
app/src/components/index.ts
app/src/hooks/useAudioRecorder.ts
app/src/hooks/useGoogleMapsConfig.ts
app/src/hooks/useOrientation.ts
app/src/hooks/useResponsiveFontScale.ts
app/src/hooks/useSnackbar.ts
app/src/modules/areasTables/components/AreaFormModal.tsx
app/src/modules/areasTables/components/TableFormModal.tsx
app/src/modules/areasTables/hooks/useAreasQueries.ts
app/src/modules/areasTables/hooks/useTablesQueries.ts
app/src/modules/areasTables/navigation/AreasTablesStackNavigator.tsx
app/src/modules/areasTables/navigation/types.ts
app/src/modules/areasTables/schema/area.schema.ts
app/src/modules/areasTables/schema/table.schema.ts
app/src/modules/areasTables/screens/AreasScreen.tsx
app/src/modules/areasTables/screens/TablesScreen.tsx
app/src/modules/areasTables/services/areaService.ts
app/src/modules/areasTables/services/tableService.ts
app/src/modules/areasTables/types/areasTables.types.ts
app/src/modules/auth/components/LoginForm.tsx
app/src/modules/auth/components/RegisterForm.tsx
app/src/modules/auth/schema/auth.schema.ts
app/src/modules/auth/screens/LoginScreen.tsx
app/src/modules/auth/services/authService.ts
app/src/modules/auth/types/auth.types.ts
app/src/modules/availability/components/AvailabilityListItem.tsx
app/src/modules/availability/components/CategoryAvailabilityItem.tsx
app/src/modules/availability/components/ModifierGroupAvailabilityItem.tsx
app/src/modules/availability/components/PizzaCustomizationAvailabilityItem.tsx
app/src/modules/availability/hooks/useAvailabilityQueries.ts
app/src/modules/availability/hooks/useOptimisticAvailability.ts
app/src/modules/availability/hooks/usePizzaCustomizationsAvailability.ts
app/src/modules/availability/navigation/AvailabilityStackNavigator.tsx
app/src/modules/availability/navigation/types.ts
app/src/modules/availability/screens/AvailabilityScreen.tsx
app/src/modules/availability/services/availabilityService.ts
app/src/modules/availability/types/availability.types.ts
app/src/modules/customers/components/AddressFormModal.tsx
app/src/modules/customers/components/CustomerFormModal.tsx
app/src/modules/customers/components/LocationPicker.tsx
app/src/modules/customers/constants/maps.config.ts
app/src/modules/customers/hooks/useCustomersQueries.ts
app/src/modules/customers/navigation/CustomersStackNavigator.tsx
app/src/modules/customers/schema/customer.schema.ts
app/src/modules/customers/screens/CustomersScreen.tsx
app/src/modules/customers/services/addressesService.ts
app/src/modules/customers/services/customersService.ts
app/src/modules/customers/types/customer.types.ts
app/src/modules/kitchen/components/KitchenFilterButton.tsx
app/src/modules/kitchen/components/OrderCard.tsx
app/src/modules/kitchen/components/OrderItemRow.tsx
app/src/modules/kitchen/components/RefreshButton.tsx
app/src/modules/kitchen/context/KitchenContext.tsx
app/src/modules/kitchen/hooks/useKitchenOrders.ts
app/src/modules/kitchen/hooks/useKitchenSnackbar.ts
app/src/modules/kitchen/navigation/KitchenNavigator.tsx
app/src/modules/kitchen/screens/KitchenOrdersScreen.tsx
app/src/modules/kitchen/services/kitchenService.ts
app/src/modules/kitchen/store/kitchenStore.ts
app/src/modules/kitchen/types/kitchen.types.ts
app/src/modules/menu/components/ProductFormModal.tsx
app/src/modules/menu/components/VariantFormModal.tsx
app/src/modules/menu/hooks/useProductsQueries.ts
app/src/modules/menu/hooks/useSubcategoriesQueries.ts
app/src/modules/menu/navigation/MenuStackNavigator.tsx
app/src/modules/menu/navigation/types.ts
app/src/modules/menu/schema/category.schema.ts
app/src/modules/menu/schema/products.schema.ts
app/src/modules/menu/schema/subcategories.schema.ts
app/src/modules/menu/screens/CategoriesScreen.tsx
app/src/modules/menu/screens/ProductsScreen.tsx
app/src/modules/menu/screens/SubcategoriesScreen.tsx
app/src/modules/menu/services/categoryService.ts
app/src/modules/menu/services/fileService.ts
app/src/modules/menu/services/productsService.ts
app/src/modules/menu/services/subcategoriesService.ts
app/src/modules/menu/types/category.types.ts
app/src/modules/menu/types/subcategories.types.ts
app/src/modules/modifiers/components/ModifierFormModal.tsx
app/src/modules/modifiers/components/ModifierGroupFormModal.tsx
app/src/modules/modifiers/hooks/useModifierGroupsQuery.ts
app/src/modules/modifiers/navigation/ModifiersStackNavigator.tsx
app/src/modules/modifiers/schema/modifier.schema.ts
app/src/modules/modifiers/schema/modifierGroup.schema.ts
app/src/modules/modifiers/screens/ModifierGroupsScreen.tsx
app/src/modules/modifiers/screens/ModifiersScreen.tsx
app/src/modules/modifiers/services/modifierGroupService.ts
app/src/modules/modifiers/services/modifierService.ts
app/src/modules/modifiers/types/modifier.types.ts
app/src/modules/orderFinalization/components/OrderCard.tsx
app/src/modules/orderFinalization/components/OrderDetailsModal.tsx
app/src/modules/orderFinalization/hooks/useOrderFinalizationQueries.ts
app/src/modules/orderFinalization/navigation/OrderFinalizationStackNavigator.tsx
app/src/modules/orderFinalization/navigation/types.ts
app/src/modules/orderFinalization/screens/OrderFinalizationScreen.tsx
app/src/modules/orderFinalization/services/orderFinalizationService.ts
app/src/modules/orderFinalization/types/orderFinalization.types.ts
app/src/modules/orders/components/AdjustmentFormModal.tsx
app/src/modules/orders/components/CartButton.tsx
app/src/modules/orders/components/ChangeCalculatorModal.tsx
app/src/modules/orders/components/CloseShiftModal.tsx
app/src/modules/orders/components/MenuItemCard.tsx
app/src/modules/orders/components/OpenShiftModal.tsx
app/src/modules/orders/components/OrderCartDetail.tsx
app/src/modules/orders/components/OrderDetailModal.tsx
app/src/modules/orders/components/OrderHeader.tsx
app/src/modules/orders/components/PaymentModal.tsx
app/src/modules/orders/components/PizzaCustomizationSection.tsx
app/src/modules/orders/components/PrinterSelectionModal.tsx
app/src/modules/orders/components/ProductCustomizationModal.tsx
app/src/modules/orders/components/ShiftStatusBanner.tsx
app/src/modules/orders/components/ShiftStatusModal.tsx
app/src/modules/orders/components/SimpleProductDescriptionModal.tsx
app/src/modules/orders/hooks/useAdjustmentQueries.ts
app/src/modules/orders/hooks/useMenuQueries.ts
app/src/modules/orders/hooks/useOrdersQueries.ts
app/src/modules/orders/hooks/usePaymentQueries.ts
app/src/modules/orders/screens/AddProductsToOrderScreen.tsx
app/src/modules/orders/screens/CreateOrderScreen.tsx
app/src/modules/orders/screens/OpenOrdersScreen.tsx
app/src/modules/orders/screens/OrdersScreen.tsx
app/src/modules/orders/services/adjustmentService.ts
app/src/modules/orders/services/orderPrintService.ts
app/src/modules/orders/services/orderService.ts
app/src/modules/orders/services/paymentService.ts
app/src/modules/orders/stores/useCartStore.ts
app/src/modules/orders/stores/useOrderFormStore.ts
app/src/modules/orders/types/adjustments.types.ts
app/src/modules/orders/types/orders.types.ts
app/src/modules/orders/types/payment.types.ts
app/src/modules/orders/types/update-order.types.ts
app/src/modules/payments/services/prepaymentService.ts
app/src/modules/pizzaCustomizations/components/AssociatePizzaToppingsModal.tsx
app/src/modules/pizzaCustomizations/components/index.ts
app/src/modules/pizzaCustomizations/components/PizzaConfigurationModal.tsx
app/src/modules/pizzaCustomizations/components/PizzaCustomizationCard.tsx
app/src/modules/pizzaCustomizations/components/PizzaCustomizationDetailModal.tsx
app/src/modules/pizzaCustomizations/components/PizzaCustomizationFormModal.tsx
app/src/modules/pizzaCustomizations/components/PizzaCustomizationsTab.tsx
app/src/modules/pizzaCustomizations/components/PizzaProductsTab.tsx
app/src/modules/pizzaCustomizations/hooks/usePizzaCustomizationsQueries.ts
app/src/modules/pizzaCustomizations/navigation/PizzaCustomizationsStackNavigator.tsx
app/src/modules/pizzaCustomizations/navigation/types.ts
app/src/modules/pizzaCustomizations/schema/pizzaConfiguration.schema.ts
app/src/modules/pizzaCustomizations/schema/pizzaCustomization.schema.ts
app/src/modules/pizzaCustomizations/screens/PizzaManagementScreen.tsx
app/src/modules/pizzaCustomizations/services/pizzaConfigurationsService.ts
app/src/modules/pizzaCustomizations/services/pizzaCustomizationsService.ts
app/src/modules/pizzaCustomizations/types/pizzaConfiguration.types.ts
app/src/modules/pizzaCustomizations/types/pizzaCustomization.types.ts
app/src/modules/preparationScreens/components/PreparationScreenDetailModalSimple.tsx
app/src/modules/preparationScreens/components/PreparationScreenFormModal.tsx
app/src/modules/preparationScreens/components/PreparationScreenListItem.tsx
app/src/modules/preparationScreens/components/ProductSelectionModal.tsx
app/src/modules/preparationScreens/hooks/usePreparationScreensQueries.ts
app/src/modules/preparationScreens/navigation/PreparationScreensStackNavigator.tsx
app/src/modules/preparationScreens/navigation/types.ts
app/src/modules/preparationScreens/schema/preparationScreen.schema.ts
app/src/modules/preparationScreens/screens/PreparationScreensScreen.tsx
app/src/modules/preparationScreens/services/preparationScreenService.ts
app/src/modules/printers/components/NumericField.tsx
app/src/modules/printers/components/PrinterAdvancedConfig.tsx
app/src/modules/printers/components/PrinterDetailModal.tsx
app/src/modules/printers/components/PrinterDiscoveryModal.tsx
app/src/modules/printers/components/PrinterFormModal.tsx
app/src/modules/printers/components/PrinterListItem.tsx
app/src/modules/printers/hooks/usePrintersQueries.ts
app/src/modules/printers/navigation/PrintersStackNavigator.tsx
app/src/modules/printers/navigation/types.ts
app/src/modules/printers/schema/printer.schema.ts
app/src/modules/printers/screens/PrintersScreen.tsx
app/src/modules/printers/services/printerService.ts
app/src/modules/printers/types/printer.types.ts
app/src/modules/receipts/components/ReceiptDetailsModal.tsx
app/src/modules/receipts/hooks/useReceiptsQueries.ts
app/src/modules/receipts/navigation/ReceiptsStackNavigator.tsx
app/src/modules/receipts/navigation/types.ts
app/src/modules/receipts/screens/ReceiptsScreen.tsx
app/src/modules/receipts/services/receiptService.ts
app/src/modules/receipts/types/receipt.types.ts
app/src/modules/restaurantConfig/components/BusinessHoursForm.tsx
app/src/modules/restaurantConfig/components/TimeZoneSelector.tsx
app/src/modules/restaurantConfig/components/WebViewDeliveryCoverageMap.tsx
app/src/modules/restaurantConfig/hooks/useRestaurantConfigQueries.ts
app/src/modules/restaurantConfig/navigation/RestaurantConfigStackNavigator.tsx
app/src/modules/restaurantConfig/navigation/types.ts
app/src/modules/restaurantConfig/screens/RestaurantConfigScreen.tsx
app/src/modules/restaurantConfig/services/restaurantConfigService.ts
app/src/modules/restaurantConfig/types/restaurantConfig.types.ts
app/src/modules/settings/navigation/SettingsStackNavigator.tsx
app/src/modules/settings/navigation/types.ts
app/src/modules/settings/screens/ServerSettingsScreen.tsx
app/src/modules/shared/components/OrderHistoryModal.tsx
app/src/modules/shared/components/OrderSummaryCard.tsx
app/src/modules/shared/components/PrintTicketModal.tsx
app/src/modules/shiftAudit/components/index.ts
app/src/modules/shiftAudit/components/OrderDetailsView.tsx
app/src/modules/shiftAudit/components/OrderHistoryView.tsx
app/src/modules/shiftAudit/components/ShiftOrdersModal.tsx
app/src/modules/shiftAudit/components/ShiftSalesSummaryView.tsx
app/src/modules/shiftAudit/hooks/useShiftOrders.ts
app/src/modules/shiftAudit/hooks/useShifts.ts
app/src/modules/shiftAudit/hooks/useShiftSalesSummary.ts
app/src/modules/shiftAudit/navigation/ShiftAuditStackNavigator.tsx
app/src/modules/shiftAudit/navigation/types.ts
app/src/modules/shiftAudit/screens/index.ts
app/src/modules/shiftAudit/screens/ShiftsListScreen.tsx
app/src/modules/shiftAudit/types/index.ts
app/src/modules/sync/navigation/SyncStackNavigator.tsx
app/src/modules/sync/screens/SyncStatusScreen.tsx
app/src/modules/sync/services/syncService.ts
app/src/modules/sync/types/sync.types.ts
app/src/modules/users/components/index.ts
app/src/modules/users/components/UserDetailModal.tsx
app/src/modules/users/components/UserFormModal.tsx
app/src/modules/users/hooks/index.ts
app/src/modules/users/hooks/useUsers.tsx
app/src/modules/users/navigation/UsersStackNavigator.tsx
app/src/modules/users/screens/index.ts
app/src/modules/users/screens/UsersListScreen.tsx
app/src/modules/users/services/index.ts
app/src/modules/users/services/usersApi.service.ts
app/src/modules/users/types/index.ts
app/src/modules/users/types/user.types.ts
app/src/services/appConfig.ts
app/src/services/audioOrderService.ts
app/src/services/audioServiceHealth.ts
app/src/services/autoReconnectService.ts
app/src/services/healthMonitoringService.ts
app/src/services/reconnectionSnackbarService.ts
app/src/services/serverConnectionService.ts
app/src/services/shifts.ts
app/src/utils/logging.ts
app/tsconfig.json

================================================================
Files
================================================================

================
File: app/.eslintignore
================
node_modules/
android/
ios/
.expo/
dist/
build/
coverage/
*.config.js
*.config.ts
babel.config.js
metro.config.js
.eslintrc.js
fix-*.js
fix-*.sh
scripts/

================
File: app/.gitignore
================
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files


# Node
node_modules/

# Prebuild
# android/

# ios/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

# Archivos espec√≠ficos
roo-code-messages.log
repomix-output.txt
bundles.json

# Ignorar carpeta .repomix y su archivo bundles.json
.repomix/
.repomix/bundles.json

# @generated expo-cli sync-8d4afeec25ea8a192358fae2f8e2fc766bdce4ec
# The following patterns were generated by expo-cli

# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

# @end expo-cli

*.apk

# Build files
build-*.apk
build-*.aab
build-*.ipa

# Google Play Service Account
google-play-service-account.json

# Temporary files
tmp/
temp/

================
File: app/.prettierrc
================
{
  "semi": true,
  "trailingComma": "all",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2,
  "endOfLine": "lf"
}

================
File: app/docs/guides/BUILD_LOCAL_GUIDE.md
================
# Gu√≠a para Builds Locales con EAS

## Instalaci√≥n R√°pida (Scripts Automatizados)

Esta app incluye scripts automatizados para configurar todo el entorno necesario:

### 1. **Configuraci√≥n Completa de Java y Expo**
```bash
cd app
./scripts/install-java.sh
source ~/.bashrc
```

### 2. **Instalaci√≥n de Android SDK**
```bash
./scripts/install-android-sdk.sh
source ~/.bashrc
```

### 3. **Verificar el Entorno (Opcional)**
```bash
./scripts/verify-android-setup.sh  # Verifica la configuraci√≥n
```

## Requisitos Previos (Instalaci√≥n Manual)

### Para Android:

1. **Java Development Kit (JDK)**
   ```bash
   # Instalar OpenJDK 17 (recomendado para React Native)
   sudo apt update
   sudo apt install openjdk-17-jdk
   ```

2. **Android SDK**
   - Opci√≥n 1: Usar el script automatizado `./scripts/install-android-sdk.sh`
   - Opci√≥n 2: Instalar manualmente:
   ```bash
   # Crear directorio para Android SDK
   mkdir -p ~/Android/Sdk
   cd ~/Android/Sdk
   
   # Descargar herramientas de l√≠nea de comandos
   wget https://dl.google.com/android/repository/commandlinetools-linux-11076708_latest.zip
   unzip commandlinetools-linux-11076708_latest.zip
   mkdir -p cmdline-tools/latest
   mv cmdline-tools/* cmdline-tools/latest/
   ```

3. **Configurar variables de entorno**
   Agrega esto a tu `~/.bashrc` o `~/.zshrc`:
   ```bash
   export JAVA_HOME=/usr/lib/jvm/java-17-openjdk-amd64
   export ANDROID_HOME=$HOME/Android/Sdk
   export ANDROID_SDK_ROOT=$HOME/Android/Sdk
   export PATH=$PATH:$JAVA_HOME/bin
   export PATH=$PATH:$ANDROID_HOME/emulator
   export PATH=$PATH:$ANDROID_HOME/platform-tools
   export PATH=$PATH:$ANDROID_HOME/cmdline-tools/latest/bin
   export PATH=$PATH:$ANDROID_HOME/tools
   export PATH=$PATH:$ANDROID_HOME/tools/bin
   ```

4. **Instalar componentes de Android SDK**
   ```bash
   # Despu√©s de configurar las variables de entorno
   source ~/.bashrc  # o ~/.zshrc
   
   # Instalar componentes necesarios
   sdkmanager "platform-tools" "platforms;android-34" "build-tools;34.0.0"
   sdkmanager "ndk;25.1.8937393"  # NDK necesario para React Native
   ```

5. **Configurar local.properties**
   ```bash
   echo "sdk.dir=$HOME/Android/Sdk" > android/local.properties
   ```

### Para iOS (solo en macOS):

1. **Xcode**
   - Instala desde App Store
   - Instala las herramientas de l√≠nea de comandos:
   ```bash
   xcode-select --install
   ```

2. **CocoaPods**
   ```bash
   sudo gem install cocoapods
   ```

## Construcci√≥n de Builds Locales

### Android

#### APK de Desarrollo (para pruebas):
```bash
cd app
npm run build:android:sim
```

#### APK para Dispositivo:
```bash
npm run build:android:dev
```

#### APK/AAB de Producci√≥n:
```bash
npm run build:android:prod
```

### iOS (solo en macOS)

#### Build para Simulador:
```bash
npm run build:ios:sim
```

#### Build para Dispositivo:
```bash
npm run build:ios:dev
```

#### Build de Producci√≥n:
```bash
npm run build:ios:prod
```

## Proceso de Build

1. **Primera vez**: EAS te pedir√° autenticarte
   ```bash
   npx eas login
   ```

2. **Durante el build local**:
   - EAS descargar√° las herramientas necesarias
   - Compilar√° tu aplicaci√≥n localmente
   - El archivo generado estar√° en la carpeta del proyecto

3. **Ubicaci√≥n de los archivos generados**:
   - Android: `build-*.apk` o `build-*.aab`
   - iOS: `build-*.tar.gz` (contiene el .app o .ipa)

## Instalaci√≥n en Dispositivos

### Android:

#### Instalar en Dispositivo F√≠sico:
```bash
# 1. Habilita el modo desarrollador en tu dispositivo Android
# 2. Habilita la depuraci√≥n USB
# 3. Conecta el dispositivo por USB
# 4. Verifica que el dispositivo est√© conectado:
adb devices

# 5. Instalar el APK generado:
adb install build-*.apk
# o espec√≠ficamente:
adb install build-1748967974325.apk
```

#### Instalar en Emulador:
```bash
# 1. Abrir emulador (si tienes Android Studio):
emulator -avd Pixel_6_API_34  # Reemplaza con el nombre de tu AVD

# 2. Instalar APK:
adb install build-*.apk
```

#### Ejecutar la App con Expo Dev Client:
```bash
# Una vez instalada la build de desarrollo, puedes ejecutar:
npm start

# Esto abrir√° el servidor de desarrollo de Expo
# Escanea el c√≥digo QR con la app instalada o presiona 'a' para Android
```

### iOS:
- Para simulador: Arrastra el .app al simulador
- Para dispositivo: Usa Xcode o herramientas como ios-deploy

## Soluci√≥n de Problemas

### Error: "ANDROID_HOME not set"
Aseg√∫rate de haber configurado las variables de entorno correctamente.

### Error: "SDK location not found"
Crea el archivo `local.properties` en `android/`:
```
sdk.dir=/home/tu-usuario/Android/Sdk
```

### Error de memoria durante el build
Aumenta la memoria de Gradle en `android/gradle.properties`:
```
org.gradle.jvmargs=-Xmx4096m -XX:MaxPermSize=1024m
```

## Notas Importantes

- Las builds locales requieren m√°s recursos que las builds en la nube
- El primer build descargar√° muchas dependencias (puede tomar tiempo)
- Aseg√∫rate de tener al menos 10GB de espacio libre
- Para producci√≥n, considera usar certificados y keystore apropiados

================
File: app/docs/guides/BUILD_QUICKSTART.md
================
# üöÄ Gu√≠a R√°pida - Builds Locales

## Primera vez (Configuraci√≥n)

```bash
# 1. Ejecutar scripts de instalaci√≥n
cd app
./scripts/install-java.sh
./scripts/install-android-sdk.sh
source ~/.bashrc

# 2. Instalar EAS CLI y login
npm install -g eas-cli
eas login
```

## Crear Build Local

```bash
# Build de desarrollo para dispositivo Android
npm run build:android:sim

# El APK se generar√° como: build-[timestamp].apk
```

## Instalar en Dispositivo

```bash
# Ver dispositivos conectados
adb devices

# Instalar APK
adb install build-*.apk
```

## Ejecutar la App

```bash
# Para Expo Go
npx expo start

# Para Development Build (APK instalado)
npx expo start --dev-client

# Si tienes problemas de conexi√≥n de red, usa modo tunnel
npx expo start --tunnel          # Para Expo Go
npx expo start --dev-client --tunnel  # Para Development Build
```

**Nota:** El modo tunnel es m√°s confiable para problemas de red aunque ligeramente m√°s lento.

## Scripts Disponibles

| Script | Descripci√≥n |
|--------|-------------|
| `scripts/install-java.sh` | Instala Java 17 |
| `scripts/install-android-sdk.sh` | Instala Android SDK y configura el entorno |
| `scripts/verify-android-setup.sh` | Verifica la configuraci√≥n del entorno |
| `scripts/fix-expo-packages.sh` | Actualiza y corrige versiones de paquetes Expo |

## Comandos de Build

| Comando | Descripci√≥n |
|---------|-------------|
| `npm run build:android:sim` | Build para emulador Android |
| `npm run build:android:dev` | Build para dispositivo Android (desarrollo) |
| `npm run build:android:prod` | Build de producci√≥n Android |

## Requisitos del Sistema

- Ubuntu/Debian
- Node.js >=18.18.0
- Java JDK 17
- Android SDK con API 34
- ~10GB de espacio libre

## Notas Importantes

- Las variables de entorno de Android SDK pueden no persistir entre sesiones
- Si encuentras errores de SDK, ejecuta `source ~/.bashrc` o crea el archivo `android/local.properties`
- Los builds locales con EAS pueden fallar si no se aceptan todas las licencias del Android SDK

## Troubleshooting

### Error: Cannot determine which native SDK version (expo module not installed)
```bash
# Este error ocurre cuando el m√≥dulo expo no est√° instalado
# Soluci√≥n:
npm install expo
npx expo install --fix
```

### Error: could not determine executable to run (npx eas)
```bash
# Este error ocurre cuando EAS CLI no est√° instalado
# Soluci√≥n:
npm install -g eas-cli
eas login  # En lugar de npx eas login
```

### Java no encontrado
```bash
./scripts/install-java.sh
source ~/.bashrc
```

### Android SDK no encontrado (Build local con EAS)
```bash
# 1. Instalar Android SDK
./scripts/install-android-sdk.sh
source ~/.bashrc

# 2. Si el error persiste, configurar variables en la sesi√≥n actual:
export ANDROID_HOME=$HOME/android-sdk
export ANDROID_SDK_ROOT=$HOME/android-sdk
export PATH=$PATH:$ANDROID_HOME/cmdline-tools/latest/bin:$ANDROID_HOME/platform-tools

# 3. Crear local.properties
echo "sdk.dir=$HOME/android-sdk" > android/local.properties

# 4. Alternativa: Usar una shell con las variables cargadas
bash -c "source ~/.bashrc && npm run build:android:sim"

# 5. Si nada funciona, considerar usar build en la nube:
eas build --platform android --profile development  # Sin --local
```

### Dispositivo no detectado
```bash
# Verificar modo desarrollador y depuraci√≥n USB
adb devices
adb kill-server
adb start-server
```

### Error: expo doctor failed
```bash
# Este error puede ignorarse si el resto del build funciona
# Es causado por tener carpetas android/ios en un proyecto Expo
# Si necesitas solucionarlo, a√±ade a .gitignore:
/android
/ios
```

## Build Exitosa

Cuando la build sea exitosa ver√°s:
```
Build successful
You can find the build artifacts in app/build-1748967974325.apk
```

================
File: app/docs/guides/EAS_PROJECT_SETUP_GUIDE.md
================
# Gu√≠a para Crear un Nuevo Proyecto EAS

Esta gu√≠a te ayudar√° a desvincular el proyecto actual de EAS y crear uno nuevo con el slug "bite-restaurant".

## Prerrequisitos

- Tener instalado EAS CLI: `npm install -g eas-cli`
- Estar logueado en tu cuenta de Expo: `eas login`
- Tener el proyecto React Native/Expo funcionando localmente

## Paso 1: Verificar el Estado Actual del Proyecto

```bash
cd app
eas project:info
```

Esto mostrar√° informaci√≥n sobre el proyecto actual vinculado a EAS (si existe).

## Paso 2: Desvincular el Proyecto Actual

### Opci√≥n A: Limpiar completamente la configuraci√≥n (recomendado)

1. Eliminar el ID del proyecto del archivo `app.json`:
   ```json
   {
     "expo": {
       // Eliminar esta l√≠nea si existe:
       "extra": {
         "eas": {
           "projectId": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
         }
       }
     }
   }
   ```

2. Eliminar la carpeta .expo si existe:
   ```bash
   rm -rf .expo
   ```

3. Verificar que no hay archivos de configuraci√≥n EAS locales:
   ```bash
   # Estos archivos normalmente no existen, pero verificar por si acaso
   ls -la .easignore .eas.json 2>/dev/null
   ```

## Paso 3: Actualizar app.json con el Nuevo Slug

Editar `app/app.json` y asegurarse de que tenga la configuraci√≥n correcta:

```json
{
  "expo": {
    "name": "Bite Restaurant",
    "slug": "bite-restaurant",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "light",
    "splash": {
      "image": "./assets/splash-icon.png",
      "resizeMode": "contain",
      "backgroundColor": "#FF6B6B"
    },
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.biterestaurant.app"
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#FF6B6B"
      },
      "package": "com.biterestaurant.app"
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "plugins": [
      "expo-router",
      [
        "expo-splash-screen",
        {
          "backgroundColor": "#FF6B6B",
          "image": "./assets/splash-icon.png",
          "imageWidth": 200
        }
      ]
    ],
    "experiments": {
      "typedRoutes": true
    },
    "scheme": "bite-restaurant"
  }
}
```

## Paso 4: Crear el Nuevo Proyecto en EAS

```bash
# Inicializar EAS con el nuevo proyecto
eas init

# Si ya tienes un proyecto vinculado, usa:
eas project:init
```

Durante este proceso:
1. EAS detectar√° el slug "bite-restaurant"
2. Te preguntar√° si quieres crear un nuevo proyecto
3. Selecciona "Yes" para crear el nuevo proyecto
4. EAS generar√° un nuevo project ID y lo agregar√° a tu app.json

## Paso 5: Verificar la Configuraci√≥n de EAS

Aseg√∫rate de que `app/eas.json` est√© configurado correctamente:

```json
{
  "cli": {
    "version": ">= 5.2.0"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal",
      "android": {
        "gradleCommand": ":app:assembleDebug"
      },
      "ios": {
        "buildConfiguration": "Debug"
      }
    },
    "preview": {
      "distribution": "internal",
      "android": {
        "buildType": "apk"
      }
    },
    "production": {
      "autoIncrement": true
    }
  },
  "submit": {
    "production": {}
  }
}
```

## Paso 6: Verificar el Nuevo Proyecto

```bash
# Verificar que el proyecto est√© correctamente vinculado
eas project:info

# Deber√≠a mostrar:
# Project: bite-restaurant
# ID: [nuevo-project-id]
# Owner: [tu-usuario]
```

## Paso 7: Configurar los Secretos del Proyecto (Opcional)

Si tu proyecto necesita variables de entorno secretas:

```bash
# Configurar secretos para el nuevo proyecto
eas secret:create --name API_URL --value "https://tu-api.com"
eas secret:create --name OTRO_SECRETO --value "valor-secreto"

# Listar secretos configurados
eas secret:list
```

## Paso 8: Realizar una Build de Prueba

Para verificar que todo est√© funcionando correctamente:

```bash
# Build de desarrollo para Android
eas build --platform android --profile development

# Build de desarrollo para iOS
eas build --platform ios --profile development
```

## Troubleshooting

### Error: "Project already exists"
Si EAS dice que el proyecto ya existe con ese slug:
1. Intenta con un slug diferente (ej: "bite-restaurant-app")
2. O contacta al soporte de Expo para liberar el slug si es tuyo

### Error: "Invalid project ID"
Si hay problemas con el project ID:
1. Elimina completamente la secci√≥n `extra.eas` de app.json
2. Ejecuta `eas init` nuevamente

### Error: "Authentication required"
Si tienes problemas de autenticaci√≥n:
```bash
eas logout
eas login
```

## Notas Importantes

1. **Backup**: Antes de desvincular, aseg√∫rate de tener un backup de cualquier configuraci√≥n importante
2. **Builds anteriores**: Las builds del proyecto anterior seguir√°n disponibles en tu cuenta de Expo
3. **Colaboradores**: Si tienes colaboradores, deber√°n actualizar su configuraci√≥n local despu√©s del cambio
4. **CI/CD**: Si usas CI/CD, actualiza las variables de entorno con el nuevo project ID

## Comandos √ötiles

```bash
# Ver todos tus proyectos en EAS
eas project:list

# Ver informaci√≥n detallada del proyecto actual
eas project:info

# Ver el estado de las builds
eas build:list

# Cancelar una build en progreso
eas build:cancel [build-id]
```

## Siguiente Paso

Una vez completada la configuraci√≥n, puedes continuar con el desarrollo normal:

```bash
# Desarrollo local
npm start

# Crear builds
npm run build:android:dev
npm run build:ios:dev
```

================
File: app/docs/guides/FIRST_UPLOAD_GUIDE.md
================
# Gu√≠a para la Primera Subida a Play Store

## Generar y subir tu primer AAB (Android App Bundle)

### 1. Generar el AAB de producci√≥n

```bash
cd app

# Aseg√∫rate de estar logueado en EAS
eas login

# Generar el AAB de producci√≥n
eas build --platform android --profile production
```

### 2. Descargar el AAB

Una vez que el build termine (aproximadamente 15-20 minutos):

1. Ve a https://expo.dev y busca tu build
2. Descarga el archivo `.aab` 
3. O usa el comando: `eas build:download --platform android`

### 3. Subir a Play Store

En la pantalla que est√°s viendo:

1. Haz clic en "Subir" (el bot√≥n junto a "Suelta los paquetes de aplicaciones aqu√≠ para subirlos")
2. Selecciona el archivo `.aab` que descargaste
3. Espera a que se procese

### 4. Completar informaci√≥n de la versi√≥n

Despu√©s de subir el AAB:

1. **Nombre de la versi√≥n**: Se llenar√° autom√°ticamente (ej: "1.0.0")
2. **Notas de la versi√≥n**: Escribe algo como:
   ```
   - Versi√≥n inicial de Bite
   - Sistema de gesti√≥n de restaurante
   - Gesti√≥n de pedidos y mesas
   - Impresi√≥n t√©rmica
   ```

3. Haz clic en "Guardar"

### 5. Configurar el lanzamiento

1. Ve a "Pruebas" ‚Üí "Prueba interna"
2. Crea un nuevo lanzamiento
3. Agrega el AAB que subiste
4. Completa las notas de la versi√≥n
5. Revisa y lanza

## Importante

- Esta primera subida DEBE hacerse manualmente
- Despu√©s de esta primera subida, podr√°s usar la automatizaci√≥n con EAS Submit
- El AAB debe estar firmado (EAS lo hace autom√°ticamente)
- Google Play procesar√° el AAB y generar√° APKs optimizados para cada dispositivo

## Pr√≥ximos pasos

Una vez que hayas subido el primer AAB:

1. Completa todas las secciones requeridas en Play Console:
   - Descripci√≥n de la app
   - Capturas de pantalla
   - Categorizaci√≥n
   - Clasificaci√≥n de contenido
   - Pol√≠tica de privacidad

2. Configura el Service Account para automatizaci√≥n futura
3. Usa `npm run release:playstore` para publicaciones futuras

================
File: app/docs/guides/PLAY_STORE_PUBLISHING.md
================
# Gu√≠a de Publicaci√≥n en Google Play Store

Esta gu√≠a te ayudar√° a publicar tu app Bite en Google Play Store de forma automatizada usando EAS (Expo Application Services).

## Requisitos Previos

1. **Cuenta de Google Play Console** ($25 √∫nico pago)
   - Crear cuenta en: https://play.google.com/console
   - Crear tu primera aplicaci√≥n en la consola

2. **Configuraci√≥n inicial en Play Console**:
   - Crear aplicaci√≥n nueva
   - Completar todas las secciones requeridas:
     - Detalles de la app
     - Clasificaci√≥n de contenido
     - Pol√≠tica de privacidad
     - Informaci√≥n de contacto
   - Subir al menos un APK/AAB manualmente la primera vez

3. **Service Account para automatizaci√≥n**:
   - Ve a Play Console ‚Üí Configuraci√≥n ‚Üí Acceso a API
   - Crear proyecto en Google Cloud Console
   - Habilitar Google Play Android Developer API
   - Crear Service Account con permisos de "Release Manager"
   - Descargar el archivo JSON de credenciales

## Configuraci√≥n del Proyecto

### 1. Preparar app.json para producci√≥n

```json
{
  "expo": {
    "name": "Bite",
    "slug": "bite-restaurant",
    "version": "1.0.0",
    "android": {
      "package": "com.tuempresa.bite",
      "versionCode": 1,
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "permissions": []
    }
  }
}
```

### 2. Configurar eas.json para Play Store

```json
{
  "build": {
    "production": {
      "android": {
        "buildType": "app-bundle",
        "env": {
          "API_URL": "https://tu-api-produccion.com"
        }
      }
    }
  },
  "submit": {
    "production": {
      "android": {
        "serviceAccountKeyPath": "./google-play-service-account.json",
        "track": "internal",
        "releaseStatus": "draft",
        "changesNotSentForReview": false
      }
    }
  }
}
```

### 3. Variables de entorno para producci√≥n

Crear archivo `.env.production`:
```
API_URL=https://tu-api-produccion.com
```

## Proceso de Publicaci√≥n Automatizado

### M√©todo 1: Script NPM (Recomendado)

Agregar estos scripts a tu `package.json`:

```json
{
  "scripts": {
    "build:prod": "eas build --platform android --profile production",
    "submit:prod": "eas submit --platform android --profile production",
    "release:prod": "npm run build:prod && npm run submit:prod",
    "release:prod:auto": "eas build --platform android --profile production --auto-submit"
  }
}
```

### M√©todo 2: GitHub Actions (CI/CD)

Crear `.github/workflows/release.yml`:

```yaml
name: Release to Play Store

on:
  push:
    tags:
      - 'v*'

jobs:
  build-and-submit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: 18
          
      - name: Setup Expo
        uses: expo/expo-github-action@v8
        with:
          expo-version: latest
          eas-version: latest
          token: ${{ secrets.EXPO_TOKEN }}
          
      - name: Install dependencies
        run: npm ci
        
      - name: Build and Submit
        run: eas build --platform android --profile production --auto-submit --non-interactive
```

## Pasos para Publicar

### Primera vez (configuraci√≥n):

```bash
# 1. Login en EAS
eas login

# 2. Configurar el proyecto
eas build:configure

# 3. Guardar el service account JSON
cp ~/Downloads/tu-service-account.json ./google-play-service-account.json

# 4. Agregar a .gitignore
echo "google-play-service-account.json" >> .gitignore
```

### Publicaci√≥n regular:

```bash
# Opci√≥n 1: Build y submit por separado
npm run build:prod
# Esperar a que termine el build
npm run submit:prod

# Opci√≥n 2: Todo automatizado
npm run release:prod:auto

# Opci√≥n 3: Con versi√≥n espec√≠fica
eas build --platform android --profile production --auto-submit --message "Version 1.0.1: Bug fixes"
```

## Configuraci√≥n de Tracks en Play Store

- **internal**: Testing interno (recomendado para empezar)
- **alpha**: Testing cerrado
- **beta**: Testing abierto
- **production**: Producci√≥n

Modificar en `eas.json`:
```json
"track": "internal"  // cambiar seg√∫n necesites
```

## Automatizaci√≥n Completa con Script

Crear `scripts/release-to-playstore.sh`:

```bash
#!/bin/bash

# Colores para output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

echo -e "${YELLOW}üöÄ Iniciando release a Play Store...${NC}"

# 1. Verificar que estamos en main
BRANCH=$(git rev-parse --abbrev-ref HEAD)
if [ "$BRANCH" != "main" ]; then
    echo "‚ùå Debes estar en la rama main para hacer release"
    exit 1
fi

# 2. Actualizar version en app.json
echo -e "${YELLOW}üìù Ingresa la nueva versi√≥n (actual: $(node -p "require('./app.json').expo.version")):${NC}"
read VERSION

# 3. Actualizar versionCode
CURRENT_VERSION_CODE=$(node -p "require('./app.json').expo.android.versionCode")
NEW_VERSION_CODE=$((CURRENT_VERSION_CODE + 1))

# 4. Actualizar app.json
node -e "
const fs = require('fs');
const appJson = require('./app.json');
appJson.expo.version = '$VERSION';
appJson.expo.android.versionCode = $NEW_VERSION_CODE;
fs.writeFileSync('./app.json', JSON.stringify(appJson, null, 2));
"

echo -e "${GREEN}‚úÖ Versi√≥n actualizada a $VERSION (versionCode: $NEW_VERSION_CODE)${NC}"

# 5. Commit cambios
git add app.json
git commit -m "Release v$VERSION"
git tag "v$VERSION"

# 6. Build y submit
echo -e "${YELLOW}üèóÔ∏è  Iniciando build y submit...${NC}"
eas build --platform android --profile production --auto-submit --non-interactive

# 7. Push cambios
git push origin main --tags

echo -e "${GREEN}‚úÖ Release completado!${NC}"
```

Hacer ejecutable:
```bash
chmod +x scripts/release-to-playstore.sh
```

## Tips y Mejores Pr√°cticas

1. **Versionado**: Siempre incrementa `versionCode` para cada build
2. **Testing**: Usa track "internal" primero antes de producci√≥n
3. **Changelogs**: Mant√©n un CHANGELOG.md actualizado
4. **Assets**: Prepara todos los assets requeridos:
   - Screenshots (m√≠nimo 2)
   - Feature graphic (1024x500)
   - Icono alta resoluci√≥n (512x512)
5. **Monitoreo**: Configura Sentry o similar para crashes en producci√≥n

## Troubleshooting

- **Error de permisos**: Verifica que el Service Account tenga rol "Release Manager"
- **Build fallido**: Revisa los logs en https://expo.dev
- **Versi√≥n rechazada**: Incrementa `versionCode` e intenta de nuevo

================
File: app/index.ts
================
import { registerRootComponent } from 'expo';
import App from './App';

registerRootComponent(App);

================
File: app/ios/.gitignore
================
# OSX
#
.DS_Store

# Xcode
#
build/
*.pbxuser
!default.pbxuser
*.mode1v3
!default.mode1v3
*.mode2v3
!default.mode2v3
*.perspectivev3
!default.perspectivev3
xcuserdata
*.xccheckout
*.moved-aside
DerivedData
*.hmap
*.ipa
*.xcuserstate
project.xcworkspace
.xcode.env.local

# Bundle artifacts
*.jsbundle

# CocoaPods
/Pods/

================
File: app/ios/.xcode.env
================
# This `.xcode.env` file is versioned and is used to source the environment
# used when running script phases inside Xcode.
# To customize your local environment, you can create an `.xcode.env.local`
# file that is not versioned.

# NODE_BINARY variable contains the PATH to the node executable.
#
# Customize the NODE_BINARY variable here.
# For example, to use nvm with brew, add the following line
# . "$(brew --prefix nvm)/nvm.sh" --no-use
export NODE_BINARY=$(command -v node)

================
File: app/ios/pizza.xcodeproj/project.pbxproj
================
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 54;
	objects = {

/* Begin PBXBuildFile section */
		13B07FBF1A68108700A75B9A /* Images.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 13B07FB51A68108700A75B9A /* Images.xcassets */; };
		3E461D99554A48A4959DE609 /* SplashScreen.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = AA286B85B6C04FC6940260E9 /* SplashScreen.storyboard */; };
		BB2F792D24A3F905000567C9 /* Expo.plist in Resources */ = {isa = PBXBuildFile; fileRef = BB2F792C24A3F905000567C9 /* Expo.plist */; };
		F11748422D0307B40044C1D9 /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = F11748412D0307B40044C1D9 /* AppDelegate.swift */; };
/* End PBXBuildFile section */

/* Begin PBXFileReference section */
		13B07F961A680F5B00A75B9A /* pizza.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = pizza.app; sourceTree = BUILT_PRODUCTS_DIR; };
		13B07FB51A68108700A75B9A /* Images.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; name = Images.xcassets; path = pizza/Images.xcassets; sourceTree = "<group>"; };
		13B07FB61A68108700A75B9A /* Info.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; name = Info.plist; path = pizza/Info.plist; sourceTree = "<group>"; };
		AA286B85B6C04FC6940260E9 /* SplashScreen.storyboard */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = file.storyboard; name = SplashScreen.storyboard; path = pizza/SplashScreen.storyboard; sourceTree = "<group>"; };
		BB2F792C24A3F905000567C9 /* Expo.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; path = Expo.plist; sourceTree = "<group>"; };
		ED297162215061F000B7C4FE /* JavaScriptCore.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = JavaScriptCore.framework; path = System/Library/Frameworks/JavaScriptCore.framework; sourceTree = SDKROOT; };
		F11748412D0307B40044C1D9 /* AppDelegate.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; name = AppDelegate.swift; path = pizza/AppDelegate.swift; sourceTree = "<group>"; };
		F11748442D0722820044C1D9 /* pizza-Bridging-Header.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = "pizza-Bridging-Header.h"; path = "pizza/pizza-Bridging-Header.h"; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		13B07F8C1A680F5B00A75B9A /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		13B07FAE1A68108700A75B9A /* pizza */ = {
			isa = PBXGroup;
			children = (
				F11748412D0307B40044C1D9 /* AppDelegate.swift */,
				F11748442D0722820044C1D9 /* pizza-Bridging-Header.h */,
				BB2F792B24A3F905000567C9 /* Supporting */,
				13B07FB51A68108700A75B9A /* Images.xcassets */,
				13B07FB61A68108700A75B9A /* Info.plist */,
				AA286B85B6C04FC6940260E9 /* SplashScreen.storyboard */,
			);
			name = pizza;
			sourceTree = "<group>";
		};
		2D16E6871FA4F8E400B85C8A /* Frameworks */ = {
			isa = PBXGroup;
			children = (
				ED297162215061F000B7C4FE /* JavaScriptCore.framework */,
			);
			name = Frameworks;
			sourceTree = "<group>";
		};
		832341AE1AAA6A7D00B99B32 /* Libraries */ = {
			isa = PBXGroup;
			children = (
			);
			name = Libraries;
			sourceTree = "<group>";
		};
		83CBB9F61A601CBA00E9B192 = {
			isa = PBXGroup;
			children = (
				13B07FAE1A68108700A75B9A /* pizza */,
				832341AE1AAA6A7D00B99B32 /* Libraries */,
				83CBBA001A601CBA00E9B192 /* Products */,
				2D16E6871FA4F8E400B85C8A /* Frameworks */,
			);
			indentWidth = 2;
			sourceTree = "<group>";
			tabWidth = 2;
			usesTabs = 0;
		};
		83CBBA001A601CBA00E9B192 /* Products */ = {
			isa = PBXGroup;
			children = (
				13B07F961A680F5B00A75B9A /* pizza.app */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		BB2F792B24A3F905000567C9 /* Supporting */ = {
			isa = PBXGroup;
			children = (
				BB2F792C24A3F905000567C9 /* Expo.plist */,
			);
			name = Supporting;
			path = pizza/Supporting;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		13B07F861A680F5B00A75B9A /* pizza */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 13B07F931A680F5B00A75B9A /* Build configuration list for PBXNativeTarget "pizza" */;
			buildPhases = (
				08A4A3CD28434E44B6B9DE2E /* [CP] Check Pods Manifest.lock */,
				13B07F871A680F5B00A75B9A /* Sources */,
				13B07F8C1A680F5B00A75B9A /* Frameworks */,
				13B07F8E1A680F5B00A75B9A /* Resources */,
				00DD1BFF1BD5951E006B06BC /* Bundle React Native code and images */,
				800E24972A6A228C8D4807E9 /* [CP] Copy Pods Resources */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = pizza;
			productName = pizza;
			productReference = 13B07F961A680F5B00A75B9A /* pizza.app */;
			productType = "com.apple.product-type.application";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		83CBB9F71A601CBA00E9B192 /* Project object */ = {
			isa = PBXProject;
			attributes = {
				LastUpgradeCheck = 1130;
				TargetAttributes = {
					13B07F861A680F5B00A75B9A = {
						LastSwiftMigration = 1250;
					};
				};
			};
			buildConfigurationList = 83CBB9FA1A601CBA00E9B192 /* Build configuration list for PBXProject "pizza" */;
			compatibilityVersion = "Xcode 3.2";
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = 83CBB9F61A601CBA00E9B192;
			productRefGroup = 83CBBA001A601CBA00E9B192 /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				13B07F861A680F5B00A75B9A /* pizza */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		13B07F8E1A680F5B00A75B9A /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				BB2F792D24A3F905000567C9 /* Expo.plist in Resources */,
				13B07FBF1A68108700A75B9A /* Images.xcassets in Resources */,
				3E461D99554A48A4959DE609 /* SplashScreen.storyboard in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXShellScriptBuildPhase section */
		00DD1BFF1BD5951E006B06BC /* Bundle React Native code and images */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputPaths = (
			);
			name = "Bundle React Native code and images";
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "if [[ -f \"$PODS_ROOT/../.xcode.env\" ]]; then\n  source \"$PODS_ROOT/../.xcode.env\"\nfi\nif [[ -f \"$PODS_ROOT/../.xcode.env.local\" ]]; then\n  source \"$PODS_ROOT/../.xcode.env.local\"\nfi\n\n# The project root by default is one level up from the ios directory\nexport PROJECT_ROOT=\"$PROJECT_DIR\"/..\n\nif [[ \"$CONFIGURATION\" = *Debug* ]]; then\n  export SKIP_BUNDLING=1\nfi\nif [[ -z \"$ENTRY_FILE\" ]]; then\n  # Set the entry JS file using the bundler's entry resolution.\n  export ENTRY_FILE=\"$(\"$NODE_BINARY\" -e \"require('expo/scripts/resolveAppEntry')\" \"$PROJECT_ROOT\" ios absolute | tail -n 1)\"\nfi\n\nif [[ -z \"$CLI_PATH\" ]]; then\n  # Use Expo CLI\n  export CLI_PATH=\"$(\"$NODE_BINARY\" --print \"require.resolve('@expo/cli', { paths: [require.resolve('expo/package.json')] })\")\"\nfi\nif [[ -z \"$BUNDLE_COMMAND\" ]]; then\n  # Default Expo CLI command for bundling\n  export BUNDLE_COMMAND=\"export:embed\"\nfi\n\n# Source .xcode.env.updates if it exists to allow\n# SKIP_BUNDLING to be unset if needed\nif [[ -f \"$PODS_ROOT/../.xcode.env.updates\" ]]; then\n  source \"$PODS_ROOT/../.xcode.env.updates\"\nfi\n# Source local changes to allow overrides\n# if needed\nif [[ -f \"$PODS_ROOT/../.xcode.env.local\" ]]; then\n  source \"$PODS_ROOT/../.xcode.env.local\"\nfi\n\n`\"$NODE_BINARY\" --print \"require('path').dirname(require.resolve('react-native/package.json')) + '/scripts/react-native-xcode.sh'\"`\n\n";
		};
		08A4A3CD28434E44B6B9DE2E /* [CP] Check Pods Manifest.lock */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
				"${PODS_PODFILE_DIR_PATH}/Podfile.lock",
				"${PODS_ROOT}/Manifest.lock",
			);
			name = "[CP] Check Pods Manifest.lock";
			outputFileListPaths = (
			);
			outputPaths = (
				"$(DERIVED_FILE_DIR)/Pods-pizza-checkManifestLockResult.txt",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "diff \"${PODS_PODFILE_DIR_PATH}/Podfile.lock\" \"${PODS_ROOT}/Manifest.lock\" > /dev/null\nif [ $? != 0 ] ; then\n    # print error to STDERR\n    echo \"error: The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation.\" >&2\n    exit 1\nfi\n# This output is used by Xcode 'outputs' to avoid re-running this script phase.\necho \"SUCCESS\" > \"${SCRIPT_OUTPUT_FILE_0}\"\n";
			showEnvVarsInLog = 0;
		};
		800E24972A6A228C8D4807E9 /* [CP] Copy Pods Resources */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputPaths = (
				"${PODS_ROOT}/Target Support Files/Pods-pizza/Pods-pizza-resources.sh",
				"${PODS_CONFIGURATION_BUILD_DIR}/EXConstants/EXConstants.bundle",
				"${PODS_CONFIGURATION_BUILD_DIR}/EXUpdates/EXUpdates.bundle",
				"${PODS_CONFIGURATION_BUILD_DIR}/React-Core/RCTI18nStrings.bundle",
			);
			name = "[CP] Copy Pods Resources";
			outputPaths = (
				"${TARGET_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/EXConstants.bundle",
				"${TARGET_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/EXUpdates.bundle",
				"${TARGET_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/RCTI18nStrings.bundle",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "\"${PODS_ROOT}/Target Support Files/Pods-pizza/Pods-pizza-resources.sh\"\n";
			showEnvVarsInLog = 0;
		};
/* End PBXShellScriptBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		13B07F871A680F5B00A75B9A /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				F11748422D0307B40044C1D9 /* AppDelegate.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin XCBuildConfiguration section */
		13B07F941A680F5B00A75B9A /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = 1;
				ENABLE_BITCODE = NO;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"$(inherited)",
					"FB_SONARKIT_ENABLED=1",
				);
				INFOPLIST_FILE = pizza/Info.plist;
				IPHONEOS_DEPLOYMENT_TARGET = 15.1;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				OTHER_LDFLAGS = (
					"$(inherited)",
					"-ObjC",
					"-lc++",
				);
				PRODUCT_BUNDLE_IDENTIFIER = "com.viefmoon.pizza";
				PRODUCT_NAME = "pizza";
				SWIFT_OBJC_BRIDGING_HEADER = "pizza/pizza-Bridging-Header.h";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
				TARGETED_DEVICE_FAMILY = "1";
				CODE_SIGN_ENTITLEMENTS = pizza/pizza.entitlements;
			};
			name = Debug;
		};
		13B07F951A680F5B00A75B9A /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = 1;
				INFOPLIST_FILE = pizza/Info.plist;
				IPHONEOS_DEPLOYMENT_TARGET = 15.1;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				OTHER_LDFLAGS = (
					"$(inherited)",
					"-ObjC",
					"-lc++",
				);
				PRODUCT_BUNDLE_IDENTIFIER = "com.viefmoon.pizza";
				PRODUCT_NAME = "pizza";
				SWIFT_OBJC_BRIDGING_HEADER = "pizza/pizza-Bridging-Header.h";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
				TARGETED_DEVICE_FAMILY = "1";
				CODE_SIGN_ENTITLEMENTS = pizza/pizza.entitlements;
			};
			name = Release;
		};
		83CBBA201A601CBA00E9B192 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CLANG_ANALYZER_LOCALIZABILITY_NONLOCALIZED = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "c++20";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_SYMBOLS_PRIVATE_EXTERN = NO;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 15.1;
				LD_RUNPATH_SEARCH_PATHS = (
					/usr/lib/swift,
					"$(inherited)",
				);
				LIBRARY_SEARCH_PATHS = "\"$(inherited)\"";
				MTL_ENABLE_DEBUG_INFO = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = iphoneos;
			};
			name = Debug;
		};
		83CBBA211A601CBA00E9B192 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CLANG_ANALYZER_LOCALIZABILITY_NONLOCALIZED = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "c++20";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = YES;
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 15.1;
				LD_RUNPATH_SEARCH_PATHS = (
					/usr/lib/swift,
					"$(inherited)",
				);
				LIBRARY_SEARCH_PATHS = "\"$(inherited)\"";
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = iphoneos;
				VALIDATE_PRODUCT = YES;
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		13B07F931A680F5B00A75B9A /* Build configuration list for PBXNativeTarget "pizza" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				13B07F941A680F5B00A75B9A /* Debug */,
				13B07F951A680F5B00A75B9A /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		83CBB9FA1A601CBA00E9B192 /* Build configuration list for PBXProject "pizza" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				83CBBA201A601CBA00E9B192 /* Debug */,
				83CBBA211A601CBA00E9B192 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = 83CBB9F71A601CBA00E9B192 /* Project object */;
}

================
File: app/ios/pizza.xcodeproj/xcshareddata/xcschemes/pizza.xcscheme
================
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "1130"
   version = "1.3">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "13B07F861A680F5B00A75B9A"
               BuildableName = "pizza.app"
               BlueprintName = "pizza"
               ReferencedContainer = "container:pizza.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES">
      <Testables>
         <TestableReference
            skipped = "NO">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "00E356ED1AD99517003FC87E"
               BuildableName = "pizzaTests.xctest"
               BlueprintName = "pizzaTests"
               ReferencedContainer = "container:pizza.xcodeproj">
            </BuildableReference>
         </TestableReference>
      </Testables>
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "13B07F861A680F5B00A75B9A"
            BuildableName = "pizza.app"
            BlueprintName = "pizza"
            ReferencedContainer = "container:pizza.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Release"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "13B07F861A680F5B00A75B9A"
            BuildableName = "pizza.app"
            BlueprintName = "pizza"
            ReferencedContainer = "container:pizza.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>

================
File: app/ios/pizza/AppDelegate.swift
================
import Expo
import React
import ReactAppDependencyProvider

@UIApplicationMain
public class AppDelegate: ExpoAppDelegate {
  var window: UIWindow?

  var reactNativeDelegate: ExpoReactNativeFactoryDelegate?
  var reactNativeFactory: RCTReactNativeFactory?

  public override func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? = nil
  ) -> Bool {
    let delegate = ReactNativeDelegate()
    let factory = ExpoReactNativeFactory(delegate: delegate)
    delegate.dependencyProvider = RCTAppDependencyProvider()

    reactNativeDelegate = delegate
    reactNativeFactory = factory
    bindReactNativeFactory(factory)

#if os(iOS) || os(tvOS)
    window = UIWindow(frame: UIScreen.main.bounds)
    factory.startReactNative(
      withModuleName: "main",
      in: window,
      launchOptions: launchOptions)
#endif

    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }

  // Linking API
  public override func application(
    _ app: UIApplication,
    open url: URL,
    options: [UIApplication.OpenURLOptionsKey: Any] = [:]
  ) -> Bool {
    return super.application(app, open: url, options: options) || RCTLinkingManager.application(app, open: url, options: options)
  }

  // Universal Links
  public override func application(
    _ application: UIApplication,
    continue userActivity: NSUserActivity,
    restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void
  ) -> Bool {
    let result = RCTLinkingManager.application(application, continue: userActivity, restorationHandler: restorationHandler)
    return super.application(application, continue: userActivity, restorationHandler: restorationHandler) || result
  }
}

class ReactNativeDelegate: ExpoReactNativeFactoryDelegate {
  // Extension point for config-plugins

  override func sourceURL(for bridge: RCTBridge) -> URL? {
    // needed to return the correct URL for expo-dev-client.
    bridge.bundleURL ?? bundleURL()
  }

  override func bundleURL() -> URL? {
#if DEBUG
    return RCTBundleURLProvider.sharedSettings().jsBundleURL(forBundleRoot: ".expo/.virtual-metro-entry")
#else
    return Bundle.main.url(forResource: "main", withExtension: "jsbundle")
#endif
  }
}

================
File: app/ios/pizza/Images.xcassets/AppIcon.appiconset/Contents.json
================
{
  "images": [
    {
      "filename": "App-Icon-1024x1024@1x.png",
      "idiom": "universal",
      "platform": "ios",
      "size": "1024x1024"
    }
  ],
  "info": {
    "version": 1,
    "author": "expo"
  }
}

================
File: app/ios/pizza/Images.xcassets/Contents.json
================
{
  "info" : {
    "version" : 1,
    "author" : "expo"
  }
}

================
File: app/ios/pizza/Images.xcassets/SplashScreenBackground.colorset/Contents.json
================
{
  "colors": [
    {
      "color": {
        "components": {
          "alpha": "1.000",
          "blue": "1.00000000000000",
          "green": "1.00000000000000",
          "red": "1.00000000000000"
        },
        "color-space": "srgb"
      },
      "idiom": "universal"
    }
  ],
  "info": {
    "version": 1,
    "author": "expo"
  }
}

================
File: app/ios/pizza/Info.plist
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
  <dict>
    <key>CADisableMinimumFrameDurationOnPhone</key>
    <true/>
    <key>CFBundleDevelopmentRegion</key>
    <string>$(DEVELOPMENT_LANGUAGE)</string>
    <key>CFBundleDisplayName</key>
    <string>CloudBite</string>
    <key>CFBundleExecutable</key>
    <string>$(EXECUTABLE_NAME)</string>
    <key>CFBundleIdentifier</key>
    <string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
    <key>CFBundleInfoDictionaryVersion</key>
    <string>6.0</string>
    <key>CFBundleName</key>
    <string>$(PRODUCT_NAME)</string>
    <key>CFBundlePackageType</key>
    <string>$(PRODUCT_BUNDLE_PACKAGE_TYPE)</string>
    <key>CFBundleShortVersionString</key>
    <string>1.0.0</string>
    <key>CFBundleSignature</key>
    <string>????</string>
    <key>CFBundleURLTypes</key>
    <array>
      <dict>
        <key>CFBundleURLSchemes</key>
        <array>
          <string>com.viefmoon.cloudbite</string>
        </array>
      </dict>
      <dict>
        <key>CFBundleURLSchemes</key>
        <array>
          <string>exp+cloudbite</string>
        </array>
      </dict>
    </array>
    <key>CFBundleVersion</key>
    <string>1</string>
    <key>LSMinimumSystemVersion</key>
    <string>12.0</string>
    <key>LSRequiresIPhoneOS</key>
    <true/>
    <key>NSAppTransportSecurity</key>
    <dict>
      <key>NSAllowsArbitraryLoads</key>
      <false/>
      <key>NSAllowsLocalNetworking</key>
      <true/>
    </dict>
    <key>NSCameraUsageDescription</key>
    <string>Allow $(PRODUCT_NAME) to access your camera</string>
    <key>NSMicrophoneUsageDescription</key>
    <string>Allow $(PRODUCT_NAME) to use the microphone.</string>
    <key>NSPhotoLibraryUsageDescription</key>
    <string>Allow $(PRODUCT_NAME) to access your photos</string>
    <key>NSSpeechRecognitionUsageDescription</key>
    <string>Allow $(PRODUCT_NAME) to use speech recognition.</string>
    <key>UILaunchStoryboardName</key>
    <string>SplashScreen</string>
    <key>UIRequiredDeviceCapabilities</key>
    <array>
      <string>arm64</string>
    </array>
    <key>UIRequiresFullScreen</key>
    <false/>
    <key>UIStatusBarStyle</key>
    <string>UIStatusBarStyleDefault</string>
    <key>UISupportedInterfaceOrientations</key>
    <array>
      <string>UIInterfaceOrientationPortrait</string>
      <string>UIInterfaceOrientationPortraitUpsideDown</string>
      <string>UIInterfaceOrientationLandscapeLeft</string>
      <string>UIInterfaceOrientationLandscapeRight</string>
    </array>
    <key>UIUserInterfaceStyle</key>
    <string>Light</string>
    <key>UIViewControllerBasedStatusBarAppearance</key>
    <false/>
  </dict>
</plist>

================
File: app/ios/pizza/pizza-Bridging-Header.h
================
//
// Use this file to import your target's public headers that you would like to expose to Swift.
//

================
File: app/ios/pizza/pizza.entitlements
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
  <dict/>
</plist>

================
File: app/ios/pizza/SplashScreen.storyboard
================
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="32700.99.1234" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" useTraitCollections="YES" useSafeAreas="YES" colorMatched="YES" initialViewController="EXPO-VIEWCONTROLLER-1">
    <device id="retina6_12" orientation="portrait" appearance="light"/>
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="22685"/>
        <capability name="Named colors" minToolsVersion="9.0"/>
        <capability name="Safe area layout guides" minToolsVersion="9.0"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <scenes>
        <scene sceneID="EXPO-SCENE-1">
            <objects>
                <viewController storyboardIdentifier="SplashScreenViewController" id="EXPO-VIEWCONTROLLER-1" sceneMemberID="viewController">
                    <view key="view" userInteractionEnabled="NO" contentMode="scaleToFill" insetsLayoutMarginsFromSafeArea="NO" id="EXPO-ContainerView" userLabel="ContainerView">
                        <rect key="frame" x="0.0" y="0.0" width="393" height="852"/>
                        <autoresizingMask key="autoresizingMask" flexibleMaxX="YES" flexibleMaxY="YES"/>
                        <subviews/>
                        <viewLayoutGuide key="safeArea" id="Rmq-lb-GrQ"/>
                        <constraints>
                            <constraint firstItem="EXPO-SplashScreen" firstAttribute="centerY" secondItem="EXPO-ContainerView" secondAttribute="centerY" id="0VC-Wk-OaO"/>
                            <constraint firstItem="EXPO-SplashScreen" firstAttribute="centerX" secondItem="EXPO-ContainerView" secondAttribute="centerX" id="zR4-NK-mVN"/>
                        </constraints>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="EXPO-PLACEHOLDER-1" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="0.0" y="0.0"/>
        </scene>
    </scenes>
    <resources>
        <image name="SplashScreenLogo" width="100" height="90.333335876464844"/>
    </resources>
</document>

================
File: app/ios/pizza/Supporting/Expo.plist
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
  <dict>
    <key>EXUpdatesCheckOnLaunch</key>
    <string>ALWAYS</string>
    <key>EXUpdatesEnabled</key>
    <false/>
    <key>EXUpdatesLaunchWaitMs</key>
    <integer>0</integer>
  </dict>
</plist>

================
File: app/ios/Podfile
================
require File.join(File.dirname(`node --print "require.resolve('expo/package.json')"`), "scripts/autolinking")
require File.join(File.dirname(`node --print "require.resolve('react-native/package.json')"`), "scripts/react_native_pods")

require 'json'
podfile_properties = JSON.parse(File.read(File.join(__dir__, 'Podfile.properties.json'))) rescue {}

ENV['RCT_NEW_ARCH_ENABLED'] = '0' if podfile_properties['newArchEnabled'] == 'false'
ENV['EX_DEV_CLIENT_NETWORK_INSPECTOR'] = podfile_properties['EX_DEV_CLIENT_NETWORK_INSPECTOR']

platform :ios, podfile_properties['ios.deploymentTarget'] || '15.1'
install! 'cocoapods',
  :deterministic_uuids => false

prepare_react_native_project!

target 'pizza' do
  use_expo_modules!

  if ENV['EXPO_USE_COMMUNITY_AUTOLINKING'] == '1'
    config_command = ['node', '-e', "process.argv=['', '', 'config'];require('@react-native-community/cli').run()"];
  else
    config_command = [
      'npx',
      'expo-modules-autolinking',
      'react-native-config',
      '--json',
      '--platform',
      'ios'
    ]
  end

  config = use_native_modules!(config_command)

  use_frameworks! :linkage => podfile_properties['ios.useFrameworks'].to_sym if podfile_properties['ios.useFrameworks']
  use_frameworks! :linkage => ENV['USE_FRAMEWORKS'].to_sym if ENV['USE_FRAMEWORKS']

  use_react_native!(
    :path => config[:reactNativePath],
    :hermes_enabled => podfile_properties['expo.jsEngine'] == nil || podfile_properties['expo.jsEngine'] == 'hermes',
    # An absolute path to your application root.
    :app_path => "#{Pod::Config.instance.installation_root}/..",
    :privacy_file_aggregation_enabled => podfile_properties['apple.privacyManifestAggregationEnabled'] != 'false',
  )

  post_install do |installer|
    react_native_post_install(
      installer,
      config[:reactNativePath],
      :mac_catalyst_enabled => false,
      :ccache_enabled => podfile_properties['apple.ccacheEnabled'] == 'true',
    )

    # This is necessary for Xcode 14, because it signs resource bundles by default
    # when building for devices.
    installer.target_installation_results.pod_target_installation_results
      .each do |pod_name, target_installation_result|
      target_installation_result.resource_bundle_targets.each do |resource_bundle_target|
        resource_bundle_target.build_configurations.each do |config|
          config.build_settings['CODE_SIGNING_ALLOWED'] = 'NO'
        end
      end
    end
  end
end

================
File: app/ios/Podfile.properties.json
================
{
  "expo.jsEngine": "hermes",
  "EX_DEV_CLIENT_NETWORK_INSPECTOR": "true"
}

================
File: app/scripts/dev/reset-project.sh
================
#!/bin/bash

echo "üßπ Limpiando proyecto React Native..."

# Detener Metro bundler
echo "Deteniendo Metro bundler..."
pkill -f "react-native.*metro" || true

# Limpiar watchman
echo "Limpiando watchman..."
watchman watch-del-all 2>/dev/null || true

# Limpiar caches de React Native
echo "Limpiando caches..."
rm -rf $TMPDIR/react-* 2>/dev/null || true
rm -rf $TMPDIR/metro-* 2>/dev/null || true
rm -rf $TMPDIR/haste-* 2>/dev/null || true

# Limpiar node_modules y lock files
echo "Eliminando node_modules..."
rm -rf node_modules
rm -rf package-lock.json

# Limpiar caches de npm
echo "Limpiando cache de npm..."
npm cache clean --force

# Reinstalar dependencias
echo "Reinstalando dependencias..."
npm install

# Limpiar cache de Expo
echo "Limpiando cache de Expo..."
npx expo start --clear

echo "‚úÖ Limpieza completa!"

================
File: app/scripts/install-android-sdk.sh
================
#!/bin/bash

echo "=== Instalaci√≥n de Android SDK para builds locales ==="
echo ""

# Crear directorio para Android SDK
ANDROID_SDK_ROOT="$HOME/Android/Sdk"
mkdir -p "$ANDROID_SDK_ROOT"

# Instalar unzip si no est√° instalado
if ! command -v unzip &> /dev/null; then
    echo "üì¶ Instalando unzip..."
    sudo apt install -y unzip
fi

# Descargar Android command line tools
if [ ! -d "$ANDROID_SDK_ROOT/cmdline-tools" ]; then
    echo "üì¶ Descargando Android Command Line Tools..."
    cd "$ANDROID_SDK_ROOT"
    
    # URL de las herramientas m√°s recientes
    TOOLS_URL="https://dl.google.com/android/repository/commandlinetools-linux-11076708_latest.zip"
    
    echo "Descargando desde: $TOOLS_URL"
    wget -q --show-progress "$TOOLS_URL" -O cmdline-tools.zip
    
    echo "Extrayendo herramientas..."
    unzip -q cmdline-tools.zip
    
    # Reorganizar la estructura de directorios correctamente
    mkdir -p cmdline-tools/latest
    mv cmdline-tools/* cmdline-tools/latest/ 2>/dev/null || true
    
    # Limpiar
    rm -f cmdline-tools.zip
    
    echo "‚úÖ Android Command Line Tools instaladas"
else
    echo "‚úÖ Android Command Line Tools ya existen"
fi

# Configurar variables de entorno
echo ""
echo "üîß Configurando variables de entorno..."

# Detectar shell
SHELL_CONFIG="$HOME/.bashrc"
if [ -n "$ZSH_VERSION" ]; then
    SHELL_CONFIG="$HOME/.zshrc"
fi

# Agregar ANDROID_HOME si no existe
if ! grep -q "ANDROID_HOME" "$SHELL_CONFIG"; then
    echo "" >> "$SHELL_CONFIG"
    echo "# Android SDK" >> "$SHELL_CONFIG"
    echo "export ANDROID_HOME=$ANDROID_SDK_ROOT" >> "$SHELL_CONFIG"
    echo "export ANDROID_SDK_ROOT=$ANDROID_SDK_ROOT" >> "$SHELL_CONFIG"
    echo "export PATH=\$PATH:\$ANDROID_HOME/emulator" >> "$SHELL_CONFIG"
    echo "export PATH=\$PATH:\$ANDROID_HOME/platform-tools" >> "$SHELL_CONFIG"
    echo "export PATH=\$PATH:\$ANDROID_HOME/cmdline-tools/latest/bin" >> "$SHELL_CONFIG"
    echo "export PATH=\$PATH:\$ANDROID_HOME/tools" >> "$SHELL_CONFIG"
    echo "export PATH=\$PATH:\$ANDROID_HOME/tools/bin" >> "$SHELL_CONFIG"
fi

# Exportar para la sesi√≥n actual
export ANDROID_HOME=$ANDROID_SDK_ROOT
export ANDROID_SDK_ROOT=$ANDROID_SDK_ROOT
export PATH=$PATH:$ANDROID_HOME/emulator
export PATH=$PATH:$ANDROID_HOME/platform-tools
export PATH=$PATH:$ANDROID_HOME/cmdline-tools/latest/bin
export PATH=$PATH:$ANDROID_HOME/tools
export PATH=$PATH:$ANDROID_HOME/tools/bin

# Verificar que sdkmanager est√© disponible
if ! command -v sdkmanager &> /dev/null; then
    echo "‚ùå Error: sdkmanager no se encuentra. Verificando instalaci√≥n..."
    ls -la "$ANDROID_HOME/cmdline-tools/latest/bin/"
    exit 1
fi

echo ""
echo "üì¶ Instalando componentes de Android SDK..."
echo "Esto puede tomar varios minutos..."

# Aceptar licencias
yes | sdkmanager --licenses 2>/dev/null || true

# Instalar componentes esenciales
sdkmanager "platform-tools"
sdkmanager "platforms;android-34"
sdkmanager "build-tools;34.0.0"
sdkmanager "ndk;25.1.8937393"

# Crear/actualizar local.properties
echo ""
echo "üìù Actualizando local.properties..."
echo "sdk.dir=$ANDROID_SDK_ROOT" > "$HOME/bite/app/android/local.properties"

echo ""
echo "‚úÖ ¬°Android SDK instalado y configurado!"
echo ""
echo "üìã Resumen de la configuraci√≥n:"
echo "   ANDROID_HOME=$ANDROID_HOME"
echo "   JAVA_HOME=$JAVA_HOME"
echo ""
echo "‚ö†Ô∏è  IMPORTANTE: Ejecuta este comando para cargar las variables:"
echo "    source $SHELL_CONFIG"
echo ""
echo "üöÄ Luego puedes ejecutar tu build con:"
echo "    npm run build:android:dev"

================
File: app/scripts/install-java.sh
================
#!/bin/bash

# Install Java JDK 17 and configure environment for Android builds

echo "Installing OpenJDK 17..."
sudo apt update
sudo apt install -y openjdk-17-jdk

# Verify installation
echo -e "\nVerifying Java installation..."
java -version
javac -version

# Find Java installation path
JAVA_PATH=$(update-alternatives --list java | grep java-17)
if [ -z "$JAVA_PATH" ]; then
    echo "Error: Java 17 installation not found"
    exit 1
fi

# Extract JAVA_HOME from the path (remove /bin/java from the end)
JAVA_HOME_PATH=$(dirname $(dirname $JAVA_PATH))

echo -e "\nJava installed at: $JAVA_HOME_PATH"

# Add JAVA_HOME and PATH to .bashrc
echo -e "\nConfiguring environment variables..."

# Check if JAVA_HOME is already in .bashrc
if ! grep -q "export JAVA_HOME=" ~/.bashrc; then
    echo "" >> ~/.bashrc
    echo "# Java configuration" >> ~/.bashrc
    echo "export JAVA_HOME=$JAVA_HOME_PATH" >> ~/.bashrc
    echo 'export PATH=$JAVA_HOME/bin:$PATH' >> ~/.bashrc
    echo "Environment variables added to ~/.bashrc"
else
    echo "JAVA_HOME already exists in ~/.bashrc, updating..."
    sed -i "s|export JAVA_HOME=.*|export JAVA_HOME=$JAVA_HOME_PATH|" ~/.bashrc
fi

# Also add to .profile for non-interactive shells
if ! grep -q "export JAVA_HOME=" ~/.profile; then
    echo "" >> ~/.profile
    echo "# Java configuration" >> ~/.profile
    echo "export JAVA_HOME=$JAVA_HOME_PATH" >> ~/.profile
    echo 'export PATH=$JAVA_HOME/bin:$PATH' >> ~/.profile
fi

# Export for current session
export JAVA_HOME=$JAVA_HOME_PATH
export PATH=$JAVA_HOME/bin:$PATH

echo -e "\nJava installation complete!"
echo "JAVA_HOME set to: $JAVA_HOME"
echo -e "\nPlease run: source ~/.bashrc"
echo "Or restart your terminal for changes to take effect."

================
File: app/scripts/release-to-playstore.sh
================
#!/bin/bash

# Colores para output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

echo -e "${YELLOW}üöÄ Iniciando release a Play Store...${NC}"

# 1. Verificar que estamos en main
BRANCH=$(git rev-parse --abbrev-ref HEAD)
if [ "$BRANCH" != "main" ]; then
    echo -e "${RED}‚ùå Debes estar en la rama main para hacer release${NC}"
    exit 1
fi

# 2. Verificar que no hay cambios sin commitear
if ! git diff-index --quiet HEAD --; then
    echo -e "${RED}‚ùå Hay cambios sin commitear. Por favor commitea o stashea los cambios primero.${NC}"
    exit 1
fi

# 3. Obtener versi√≥n actual
CURRENT_VERSION=$(node -p "require('./app.json').expo.version")
echo -e "${GREEN}Versi√≥n actual: $CURRENT_VERSION${NC}"

# 4. Solicitar nueva versi√≥n
echo -e "${YELLOW}üìù Ingresa la nueva versi√≥n (formato: X.Y.Z):${NC}"
read VERSION

# Validar formato de versi√≥n
if ! [[ $VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    echo -e "${RED}‚ùå Formato de versi√≥n inv√°lido. Usa X.Y.Z (ej: 1.0.1)${NC}"
    exit 1
fi

# 5. Actualizar versionCode
CURRENT_VERSION_CODE=$(node -p "require('./app.json').expo.android.versionCode")
NEW_VERSION_CODE=$((CURRENT_VERSION_CODE + 1))

# 6. Actualizar app.json
node -e "
const fs = require('fs');
const appJson = require('./app.json');
appJson.expo.version = '$VERSION';
appJson.expo.android.versionCode = $NEW_VERSION_CODE;
fs.writeFileSync('./app.json', JSON.stringify(appJson, null, 2));
"

echo -e "${GREEN}‚úÖ Versi√≥n actualizada a $VERSION (versionCode: $NEW_VERSION_CODE)${NC}"

# 7. Solicitar mensaje de release
echo -e "${YELLOW}üìù Ingresa una descripci√≥n breve de los cambios:${NC}"
read RELEASE_MESSAGE

# 8. Commit cambios
git add app.json
git commit -m "Release v$VERSION: $RELEASE_MESSAGE"
git tag "v$VERSION"

# 9. Verificar credenciales de Google Play
if [ ! -f "./google-play-service-account.json" ]; then
    echo -e "${RED}‚ùå No se encontr√≥ google-play-service-account.json${NC}"
    echo -e "${YELLOW}Por favor, descarga el archivo de credenciales de Google Play Console y gu√°rdalo como google-play-service-account.json${NC}"
    exit 1
fi

# 10. Confirmar build
echo -e "${YELLOW}¬øDeseas continuar con el build y publicaci√≥n? (s/n)${NC}"
read CONFIRM

if [ "$CONFIRM" != "s" ]; then
    echo -e "${RED}‚ùå Release cancelado${NC}"
    # Revertir cambios
    git reset --hard HEAD~1
    git tag -d "v$VERSION"
    exit 1
fi

# 11. Build y submit
echo -e "${YELLOW}üèóÔ∏è  Iniciando build y submit a Play Store...${NC}"
eas build --platform android --profile production --auto-submit --non-interactive --message "v$VERSION: $RELEASE_MESSAGE"

# 12. Push cambios si el build fue exitoso
if [ $? -eq 0 ]; then
    echo -e "${YELLOW}üì§ Subiendo cambios a repositorio...${NC}"
    git push origin main --tags
    echo -e "${GREEN}‚úÖ Release v$VERSION completado exitosamente!${NC}"
    echo -e "${GREEN}üì± Tu app ser√° revisada y publicada en el track 'internal' de Play Store${NC}"
else
    echo -e "${RED}‚ùå Error en el build. Los cambios locales no se han subido.${NC}"
    echo -e "${YELLOW}Para revertir los cambios locales, ejecuta:${NC}"
    echo "git reset --hard HEAD~1 && git tag -d v$VERSION"
fi

================
File: app/scripts/verify-android-setup.sh
================
#!/bin/bash

# Verify Android development environment setup

echo "=== Android Development Environment Verification ==="
echo

# Check Java
echo "1. Java Installation:"
if command -v java &> /dev/null; then
    java -version
    echo "‚úì Java is installed"
else
    echo "‚úó Java is not installed or not in PATH"
fi
echo

# Check JAVA_HOME
echo "2. JAVA_HOME Environment Variable:"
if [ -n "$JAVA_HOME" ]; then
    echo "JAVA_HOME is set to: $JAVA_HOME"
    if [ -d "$JAVA_HOME" ]; then
        echo "‚úì JAVA_HOME directory exists"
    else
        echo "‚úó JAVA_HOME directory does not exist"
    fi
else
    echo "‚úó JAVA_HOME is not set"
fi
echo

# Check Android SDK (if exists)
echo "3. Android SDK:"
if [ -n "$ANDROID_HOME" ] || [ -n "$ANDROID_SDK_ROOT" ]; then
    if [ -n "$ANDROID_HOME" ]; then
        echo "ANDROID_HOME is set to: $ANDROID_HOME"
    fi
    if [ -n "$ANDROID_SDK_ROOT" ]; then
        echo "ANDROID_SDK_ROOT is set to: $ANDROID_SDK_ROOT"
    fi
    echo "‚úì Android SDK environment variables are set"
else
    echo "‚úó Android SDK environment variables not set (this is OK if using EAS Build)"
fi
echo

# Check Node.js
echo "4. Node.js:"
if command -v node &> /dev/null; then
    echo "Node version: $(node --version)"
    echo "‚úì Node.js is installed"
else
    echo "‚úó Node.js is not installed"
fi
echo

# Check npm
echo "5. npm:"
if command -v npm &> /dev/null; then
    echo "npm version: $(npm --version)"
    echo "‚úì npm is installed"
else
    echo "‚úó npm is not installed"
fi
echo

# Check EAS CLI
echo "6. EAS CLI:"
if command -v eas &> /dev/null; then
    echo "EAS CLI version: $(eas --version)"
    echo "‚úì EAS CLI is installed"
else
    echo "‚úó EAS CLI is not installed"
    echo "  Install with: npm install -g eas-cli"
fi
echo

# Check Expo CLI
echo "7. Expo CLI:"
if npx expo --version &> /dev/null 2>&1; then
    echo "Expo CLI version: $(npx expo --version)"
    echo "‚úì Expo CLI is available"
else
    echo "‚úó Expo CLI is not available"
fi
echo

echo "=== Summary ==="
echo "Run the following commands to complete setup:"
echo "1. ./scripts/install-java.sh          # Install Java JDK 17"
echo "2. source ~/.bashrc                  # Reload environment variables"
echo "3. ./scripts/fix-expo-packages.sh     # Fix Expo package versions"
echo "4. npm install -g eas-cli            # Install EAS CLI if needed"

================
File: app/src/app/components/common/CustomImagePicker.tsx
================
import React, { useState, useEffect } from 'react';
import {
  View,
  StyleSheet,
  Alert,
  TouchableOpacity,
  StyleProp,
  ViewStyle,
} from 'react-native';
import {
  ActivityIndicator,
  Avatar,
  IconButton,
  Surface,
  Text,
  useTheme,
} from 'react-native-paper';
import * as ImagePicker from 'expo-image-picker';
import { Image } from 'expo-image';
import { AppTheme } from '../../styles/theme';
import { useResponsive } from '../../hooks/useResponsive';

export interface FileObject {
  uri: string;
  name: string;
  type: string;
}

interface CustomImagePickerProps {
  value?: string | null;
  onImageSelected?: (imageUri: string, file: FileObject) => void;
  onImageRemoved?: () => void;
  style?: StyleProp<ViewStyle>;
  size?: number;
  placeholderIcon?: string;
  placeholderText?: string;
  isLoading?: boolean;
  disabled?: boolean;
}

export const CustomImagePicker: React.FC<CustomImagePickerProps> = ({
  value,
  onImageSelected,
  onImageRemoved,
  style,
  size = 150,
  placeholderIcon = 'camera-plus-outline',
  placeholderText = 'A√±adir imagen',
  isLoading = false,
  disabled = false,
}) => {
  const theme = useTheme<AppTheme>();
  const responsive = useResponsive();
  const [imageUri, setImageUri] = useState<string | null | undefined>(value);
  const [hasPermission, setHasPermission] = useState<boolean | null>(null);
  const [imageLoadError, setImageLoadError] = useState(false);

  useEffect(() => {
    let isMounted = true;

    (async () => {
      try {
        const { status } = await ImagePicker.getMediaLibraryPermissionsAsync();
        if (isMounted) {
          setHasPermission(status === 'granted');
        }
      } catch {
        if (isMounted) {
          setHasPermission(false);
        }
      }
    })();

    return () => {
      isMounted = false;
    };
  }, []);

  useEffect(() => {
    setImageUri(value);
    setImageLoadError(false);
  }, [value]);

  const requestPermission = async (): Promise<boolean> => {
    if (hasPermission) return true;
    try {
      const { status } =
        await ImagePicker.requestMediaLibraryPermissionsAsync();
      if (status === 'granted') {
        setHasPermission(true);
        return true;
      } else {
        Alert.alert(
          'Permiso requerido',
          'Se necesita acceso a la galer√≠a para seleccionar im√°genes.',
        );
        setHasPermission(false);
        return false;
      }
    } catch (e) {
      Alert.alert(
        'Error',
        'No se pudieron solicitar los permisos de la galer√≠a.',
      );
      setHasPermission(false);
      return false;
    }
  };

  const handlePickImage = async () => {
    if (isLoading || disabled) return;

    const permissionGranted = await requestPermission();
    if (!permissionGranted) return;

    try {
      const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: 'images',
        allowsEditing: true,
        aspect: [1, 1],
        quality: 0.8,
      });

      if (!result.canceled && result.assets && result.assets.length > 0) {
        const selectedAsset = result.assets[0];
        const selectedUri = selectedAsset.uri;
        const fileName = selectedUri.split('/').pop() || 'image.jpg';
        const fileType =
          selectedAsset.mimeType ||
          (fileName.toLowerCase().endsWith('.png')
            ? 'image/png'
            : 'image/jpeg');

        const fileObject: FileObject = {
          uri: selectedUri,
          name: fileName,
          type: fileType,
        };
        setImageUri(selectedUri);
        onImageSelected?.(selectedUri, fileObject);
      }
    } catch (error) {
      Alert.alert(
        'Error',
        `No se pudo abrir la galer√≠a: ${error instanceof Error ? error.message : 'Int√©ntalo de nuevo.'}`,
      );
    }
  };

  const handleRemoveImage = () => {
    if (isLoading || disabled) return;
    setImageUri(null);
    onImageRemoved?.();
  };

  // Calcular tama√±o responsive
  const responsiveSize = responsive.getResponsiveDimension(size, size * 1.2);

  const styles = StyleSheet.create({
    container: {
      width: responsiveSize,
      height: responsiveSize,
      borderRadius: theme.roundness * 1.5,
      justifyContent: 'center',
      alignItems: 'center',
      overflow: 'hidden',
      position: 'relative',
      backgroundColor: theme.colors.surfaceVariant,
    },
    touchable: {
      width: '100%',
      height: '100%',
      justifyContent: 'center',
      alignItems: 'center',
    },
    image: {
      width: '100%',
      height: '100%',
    },
    placeholderContainer: {
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.spacing.s,
    },
    placeholderText: {
      marginTop: responsive.spacing.xs,
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
      fontSize: responsive.fontSize.s,
    },
    loadingOverlay: {
      ...StyleSheet.absoluteFillObject,
      backgroundColor: 'rgba(0,0,0,0.4)',
      justifyContent: 'center',
      alignItems: 'center',
      borderRadius: theme.roundness * 1.5,
    },
    removeButton: {
      position: 'absolute',
      top: responsive.spacing.xs,
      right: responsive.spacing.xs,
      backgroundColor: 'rgba(0, 0, 0, 0.6)',
    },
  });

  return (
    <Surface style={[styles.container, style]} elevation={1}>
      <TouchableOpacity
        style={styles.touchable}
        onPress={handlePickImage}
        disabled={isLoading || disabled}
      >
        {imageUri && !imageLoadError ? (
          <Image
            source={{ uri: imageUri }}
            style={styles.image}
            contentFit="cover"
            onError={() => setImageLoadError(true)}
          />
        ) : (
          <View style={styles.placeholderContainer}>
            <Avatar.Icon
              size={responsiveSize * 0.4}
              icon={placeholderIcon}
              style={{ backgroundColor: 'transparent' }}
              color={theme.colors.onSurfaceVariant}
            />
            <Text style={styles.placeholderText} variant="bodySmall">
              {placeholderText}
            </Text>
          </View>
        )}

        {isLoading && (
          <View style={styles.loadingOverlay}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
          </View>
        )}

        {imageUri && !imageLoadError && !isLoading && !disabled && (
          <IconButton
            icon="close-circle"
            size={responsive.dimensions.iconSize.medium}
            iconColor={theme.colors.onErrorContainer}
            style={styles.removeButton}
            onPress={handleRemoveImage}
            rippleColor="rgba(255, 255, 255, 0.32)"
          />
        )}
      </TouchableOpacity>
    </Surface>
  );
};

export default CustomImagePicker;

================
File: app/src/app/components/common/SpeechRecognitionInput.tsx
================
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { View, StyleSheet, Animated } from 'react-native';
import { IconButton } from 'react-native-paper';
import {
  ExpoSpeechRecognitionModule,
  useSpeechRecognitionEvent,
} from 'expo-speech-recognition';
import AnimatedLabelInput from './AnimatedLabelInput';
import { useAppTheme } from '../../styles/theme';

// Clase para manejar instancias de reconocimiento de forma aislada
class RecognitionInstance {
  private static instances = new Map<string, RecognitionInstance>();
  private static activeInstanceId: string | null = null;

  private id: string;
  private isActive: boolean = false;
  private onResultCallback: ((text: string) => void) | null = null;
  private onErrorCallback: ((error: string) => void) | null = null;
  private onStartCallback: (() => void) | null = null;
  private onEndCallback: (() => void) | null = null;

  constructor(id: string) {
    this.id = id;
    RecognitionInstance.instances.set(id, this);
  }

  static getInstance(id: string): RecognitionInstance {
    if (!RecognitionInstance.instances.has(id)) {
      new RecognitionInstance(id);
    }
    return RecognitionInstance.instances.get(id)!;
  }

  static removeInstance(id: string) {
    const instance = RecognitionInstance.instances.get(id);
    if (instance && instance.isActive) {
      instance.stop();
    }
    RecognitionInstance.instances.delete(id);
  }

  static getActiveInstance(): RecognitionInstance | null {
    if (RecognitionInstance.activeInstanceId) {
      return (
        RecognitionInstance.instances.get(
          RecognitionInstance.activeInstanceId,
        ) || null
      );
    }
    return null;
  }

  setCallbacks(callbacks: {
    onResult?: (text: string) => void;
    onError?: (error: string) => void;
    onStart?: () => void;
    onEnd?: () => void;
  }) {
    this.onResultCallback = callbacks.onResult || null;
    this.onErrorCallback = callbacks.onError || null;
    this.onStartCallback = callbacks.onStart || null;
    this.onEndCallback = callbacks.onEnd || null;
  }

  async start(lang: string) {
    // Si hay otra instancia activa, detenerla primero
    const activeInstance = RecognitionInstance.getActiveInstance();
    if (activeInstance && activeInstance.id !== this.id) {
      await activeInstance.stop();
    }

    try {
      const permissions =
        await ExpoSpeechRecognitionModule.requestPermissionsAsync();
      if (!permissions.granted) {
        this.onErrorCallback?.('Permiso de micr√≥fono denegado');
        return;
      }

      RecognitionInstance.activeInstanceId = this.id;
      this.isActive = true;

      await ExpoSpeechRecognitionModule.start({
        lang,
        interimResults: false,
        continuous: false,
      });

      this.onStartCallback?.();
    } catch (error: any) {
      this.isActive = false;
      RecognitionInstance.activeInstanceId = null;
      this.onErrorCallback?.(
        error.message || 'Error al iniciar reconocimiento',
      );
    }
  }

  async stop() {
    if (this.isActive) {
      try {
        await ExpoSpeechRecognitionModule.stop();
      } catch (error) {
        // Ignorar errores al detener
      } finally {
        this.isActive = false;
        if (RecognitionInstance.activeInstanceId === this.id) {
          RecognitionInstance.activeInstanceId = null;
        }
        this.onEndCallback?.();
      }
    }
  }

  handleResult(transcript: string) {
    if (this.isActive && RecognitionInstance.activeInstanceId === this.id) {
      this.onResultCallback?.(transcript);
    }
  }

  handleError(error: string) {
    if (this.isActive && RecognitionInstance.activeInstanceId === this.id) {
      this.isActive = false;
      RecognitionInstance.activeInstanceId = null;
      this.onErrorCallback?.(error);
    }
  }

  handleEnd() {
    if (this.isActive && RecognitionInstance.activeInstanceId === this.id) {
      this.isActive = false;
      RecognitionInstance.activeInstanceId = null;
      this.onEndCallback?.();
    }
  }
}

interface SpeechRecognitionInputProps
  extends Omit<
    React.ComponentProps<typeof AnimatedLabelInput>,
    'value' | 'onChangeText'
  > {
  value: string;
  onChangeText: (text: string) => void;
  label: string;
  speechLang?: string;
  clearOnStart?: boolean;
  replaceContent?: boolean;
  onError?: (error: string) => void;
}

const SpeechRecognitionInput: React.FC<SpeechRecognitionInputProps> = ({
  value,
  onChangeText,
  label,
  speechLang = 'es-MX',
  clearOnStart = false,
  replaceContent = true,
  onError,
  error,
  errorColor,
  activeBorderColor,
  containerStyle,
  inputStyle,
  labelStyle,
  style,
  ...rest
}) => {
  const theme = useAppTheme();
  const [isRecognizingSpeech, setIsRecognizingSpeech] = useState(false);
  const [localValue, setLocalValue] = useState(value);
  const instanceId = useRef(
    `speech-${Date.now()}-${Math.floor(Math.random() * 10000)}`,
  ).current;
  const recognitionInstance = useRef<RecognitionInstance | null>(null);
  const scaleAnim = useRef(new Animated.Value(1)).current;
  const lastProcessedValue = useRef(value);
  const isUpdatingFromSpeech = useRef(false);

  // Sincronizar valor externo con valor local solo cuando cambia externamente
  useEffect(() => {
    if (!isUpdatingFromSpeech.current && value !== lastProcessedValue.current) {
      setLocalValue(value);
      lastProcessedValue.current = value;
    }
  }, [value]);

  // Configurar la instancia de reconocimiento
  useEffect(() => {
    recognitionInstance.current = RecognitionInstance.getInstance(instanceId);

    recognitionInstance.current.setCallbacks({
      onStart: () => {
        setIsRecognizingSpeech(true);
        if (clearOnStart) {
          setLocalValue('');
          lastProcessedValue.current = '';
          onChangeText('');
        }
      },
      onEnd: () => {
        setIsRecognizingSpeech(false);
      },
      onResult: (transcript: string) => {
        let newValue: string;

        if (replaceContent) {
          if (rest.keyboardType === 'phone-pad') {
            newValue = transcript.replace(/\D/g, '');
          } else {
            newValue = transcript;
          }
        } else {
          // Usar el valor local m√°s actualizado
          newValue = localValue ? localValue + ' ' + transcript : transcript;
        }

        isUpdatingFromSpeech.current = true;
        setLocalValue(newValue);
        lastProcessedValue.current = newValue;
        onChangeText(newValue);

        // Resetear flag despu√©s de un breve delay
        setTimeout(() => {
          isUpdatingFromSpeech.current = false;
        }, 100);
      },
      onError: (errorMsg: string) => {
        setIsRecognizingSpeech(false);
        onError?.(errorMsg);
      },
    });

    return () => {
      RecognitionInstance.removeInstance(instanceId);
    };
  }, [
    instanceId,
    clearOnStart,
    onChangeText,
    replaceContent,
    rest.keyboardType,
    onError,
    localValue,
  ]);

  // Animaci√≥n del bot√≥n
  useEffect(() => {
    Animated.spring(scaleAnim, {
      toValue: isRecognizingSpeech ? 1.2 : 1,
      friction: 3,
      useNativeDriver: true,
    }).start();
  }, [isRecognizingSpeech, scaleAnim]);

  // Event listeners globales - solo procesan si la instancia activa coincide
  useSpeechRecognitionEvent('start', () => {
    // El evento start ya se maneja en el m√©todo start() de RecognitionInstance
  });

  useSpeechRecognitionEvent('end', () => {
    const activeInstance = RecognitionInstance.getActiveInstance();
    if (activeInstance?.id === instanceId) {
      activeInstance.handleEnd();
    }
  });

  useSpeechRecognitionEvent('result', (event) => {
    const activeInstance = RecognitionInstance.getActiveInstance();
    if (activeInstance?.id === instanceId && event.results?.[0]) {
      activeInstance.handleResult(event.results[0].transcript);
    }
  });

  useSpeechRecognitionEvent('error', (event) => {
    const activeInstance = RecognitionInstance.getActiveInstance();
    if (activeInstance?.id === instanceId) {
      activeInstance.handleError(
        event.message || event.error || 'Error desconocido',
      );
    }
  });

  const toggleRecognition = async () => {
    if (!recognitionInstance.current) return;

    if (isRecognizingSpeech) {
      await recognitionInstance.current.stop();
    } else {
      await recognitionInstance.current.start(speechLang);
    }
  };

  const micIconColor = isRecognizingSpeech
    ? theme.colors.error
    : theme.colors.primary;

  // Manejar cambios de texto desde el teclado
  const handleTextChange = useCallback(
    (text: string) => {
      // Actualizar estado local inmediatamente
      setLocalValue(text);
      lastProcessedValue.current = text;

      // Notificar al padre
      onChangeText(text);
    },
    [onChangeText],
  );

  return (
    <View style={styles.wrapper}>
      <AnimatedLabelInput
        label={label}
        value={localValue}
        onChangeText={handleTextChange}
        error={error}
        errorColor={errorColor}
        activeBorderColor={activeBorderColor}
        containerStyle={[containerStyle, { flex: 1 }]}
        inputStyle={inputStyle}
        labelStyle={labelStyle}
        style={style}
        {...rest}
      />
      <Animated.View style={{ transform: [{ scale: scaleAnim }] }}>
        <IconButton
          key={isRecognizingSpeech ? 'mic-active' : 'mic-inactive'}
          icon={isRecognizingSpeech ? 'microphone-off' : 'microphone'}
          size={24}
          iconColor={micIconColor}
          onPress={toggleRecognition}
          style={styles.iconButton}
        />
      </Animated.View>
    </View>
  );
};

const styles = StyleSheet.create({
  wrapper: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  iconButton: {
    marginLeft: 8,
    marginVertical: 0,
    padding: 0,
  },
});

export default SpeechRecognitionInput;

================
File: app/src/app/components/responsive/index.ts
================
// Exportar todos los componentes responsive desde un √∫nico punto
export {
  ResponsiveView,
  ResponsiveRow,
  ResponsiveColumn,
} from './ResponsiveView';
export { ResponsiveGrid, ResponsiveFlexGrid, GridItem } from './ResponsiveGrid';
export {
  ResponsiveImage,
  ResponsiveAvatar,
  ResponsiveThumbnail,
} from './ResponsiveImage';
export { ResponsiveModal, ResponsiveConfirmModal } from './ResponsiveModal';

// Re-exportar tipos si es necesario
// export type { ResponsiveViewProps } from './ResponsiveView';
// export type { ResponsiveGridProps } from './ResponsiveGrid';
// export type { ResponsiveImageProps } from './ResponsiveImage';
// export type { ResponsiveModalProps } from './ResponsiveModal';

================
File: app/src/app/components/responsive/ResponsiveView.tsx
================
import React, { ReactNode, useMemo } from 'react';
import {
  View,
  ViewStyle,
  StyleProp,
  ViewProps,
  DimensionValue,
} from 'react-native';
import { useResponsive } from '@/app/hooks/useResponsive';

interface ResponsiveViewProps extends ViewProps {
  children?: ReactNode;
  style?: StyleProp<ViewStyle>;

  // Estilos responsivos por breakpoint
  xsStyle?: ViewStyle;
  smStyle?: ViewStyle;
  mdStyle?: ViewStyle;
  lgStyle?: ViewStyle;
  xlStyle?: ViewStyle;
  xxlStyle?: ViewStyle;

  // Estilos por tipo de dispositivo
  mobileStyle?: ViewStyle;
  tabletStyle?: ViewStyle;

  // Estilos por orientaci√≥n
  portraitStyle?: ViewStyle;
  landscapeStyle?: ViewStyle;

  // Props de layout responsive
  direction?: 'row' | 'column' | 'row-reverse' | 'column-reverse';
  directionTablet?: 'row' | 'column' | 'row-reverse' | 'column-reverse';

  // Padding responsive
  padding?: number | 'auto';
  paddingHorizontal?: number | 'auto';
  paddingVertical?: number | 'auto';

  // Margin responsive
  margin?: number | 'auto';
  marginHorizontal?: number | 'auto';
  marginVertical?: number | 'auto';

  // Gap responsive (para flex)
  gap?: number | 'auto';
  gapTablet?: number;

  // Alignment responsive
  align?: 'flex-start' | 'center' | 'flex-end' | 'stretch';
  alignTablet?: 'flex-start' | 'center' | 'flex-end' | 'stretch';
  justify?:
    | 'flex-start'
    | 'center'
    | 'flex-end'
    | 'space-between'
    | 'space-around'
    | 'space-evenly';
  justifyTablet?:
    | 'flex-start'
    | 'center'
    | 'flex-end'
    | 'space-between'
    | 'space-around'
    | 'space-evenly';

  // Flex responsive
  flex?: number;
  flexTablet?: number;
  wrap?: boolean;
  wrapTablet?: boolean;

  // Dimensiones responsive
  width?: number | string | 'auto';
  widthTablet?: number | string | 'auto';
  height?: number | string | 'auto';
  heightTablet?: number | string | 'auto';

  // Max/Min dimensiones
  maxWidth?: number | string;
  maxWidthTablet?: number | string;
  maxHeight?: number | string;
  maxHeightTablet?: number | string;
  minWidth?: number | string;
  minWidthTablet?: number | string;
  minHeight?: number | string;
  minHeightTablet?: number | string;

  // Mostrar/Ocultar seg√∫n dispositivo
  hideOnMobile?: boolean;
  hideOnTablet?: boolean;
  hideOnPortrait?: boolean;
  hideOnLandscape?: boolean;
}

export const ResponsiveView: React.FC<ResponsiveViewProps> = ({
  children,
  style,

  // Estilos por breakpoint
  xsStyle,
  smStyle,
  mdStyle,
  lgStyle,
  xlStyle,
  xxlStyle,

  // Estilos por dispositivo
  mobileStyle,
  tabletStyle,

  // Estilos por orientaci√≥n
  portraitStyle,
  landscapeStyle,

  // Props de layout
  direction = 'column',
  directionTablet,

  // Padding
  padding,
  paddingHorizontal,
  paddingVertical,

  // Margin
  margin,
  marginHorizontal,
  marginVertical,

  // Gap
  gap,
  gapTablet,

  // Alignment
  align,
  alignTablet,
  justify,
  justifyTablet,

  // Flex
  flex,
  flexTablet,
  wrap = false,
  wrapTablet,

  // Dimensiones
  width,
  widthTablet,
  height,
  heightTablet,

  // Max/Min
  maxWidth,
  maxWidthTablet,
  maxHeight,
  maxHeightTablet,
  minWidth,
  minWidthTablet,
  minHeight,
  minHeightTablet,

  // Visibility
  hideOnMobile = false,
  hideOnTablet = false,
  hideOnPortrait = false,
  hideOnLandscape = false,

  ...restProps
}) => {
  const responsive = useResponsive();

  // Calcular estilos responsivos
  const responsiveStyles = useMemo(() => {
    // Ocultar seg√∫n condiciones
    if (
      (hideOnMobile && responsive.isMobile) ||
      (hideOnTablet && responsive.isTablet) ||
      (hideOnPortrait && responsive.isPortrait) ||
      (hideOnLandscape && responsive.isLandscape)
    ) {
      return { display: 'none' } as ViewStyle;
    }

    // Base styles
    const baseStyle: ViewStyle = {
      // Direcci√≥n
      flexDirection:
        responsive.isTablet && directionTablet ? directionTablet : direction,

      // Flex
      flex: responsive.isTablet && flexTablet !== undefined ? flexTablet : flex,
      flexWrap:
        responsive.isTablet && wrapTablet !== undefined
          ? wrapTablet
            ? 'wrap'
            : 'nowrap'
          : wrap
            ? 'wrap'
            : 'nowrap',

      // Alignment
      alignItems: responsive.isTablet && alignTablet ? alignTablet : align,
      justifyContent:
        responsive.isTablet && justifyTablet ? justifyTablet : justify,

      // Dimensiones
      width: (responsive.isTablet && widthTablet !== undefined
        ? widthTablet
        : width) as any,
      height: (responsive.isTablet && heightTablet !== undefined
        ? heightTablet
        : height) as DimensionValue,

      // Max/Min
      maxWidth: (responsive.isTablet && maxWidthTablet !== undefined
        ? maxWidthTablet
        : maxWidth) as DimensionValue,
      maxHeight: (responsive.isTablet && maxHeightTablet !== undefined
        ? maxHeightTablet
        : maxHeight) as DimensionValue,
      minWidth: (responsive.isTablet && minWidthTablet !== undefined
        ? minWidthTablet
        : minWidth) as DimensionValue,
      minHeight: (responsive.isTablet && minHeightTablet !== undefined
        ? minHeightTablet
        : minHeight) as DimensionValue,
    };

    // Padding responsive
    if (padding !== undefined) {
      const paddingValue =
        padding === 'auto'
          ? responsive.spacing.m
          : responsive.scaleWidth(padding);
      baseStyle.padding = paddingValue;
    }
    if (paddingHorizontal !== undefined) {
      const paddingValue =
        paddingHorizontal === 'auto'
          ? responsive.spacing.m
          : responsive.scaleWidth(paddingHorizontal);
      baseStyle.paddingHorizontal = paddingValue;
    }
    if (paddingVertical !== undefined) {
      const paddingValue =
        paddingVertical === 'auto'
          ? responsive.spacing.m
          : responsive.scaleHeight(paddingVertical);
      baseStyle.paddingVertical = paddingValue;
    }

    // Margin responsive
    if (margin !== undefined) {
      const marginValue =
        margin === 'auto'
          ? responsive.spacing.m
          : responsive.scaleWidth(margin);
      baseStyle.margin = marginValue;
    }
    if (marginHorizontal !== undefined) {
      const marginValue =
        marginHorizontal === 'auto'
          ? responsive.spacing.m
          : responsive.scaleWidth(marginHorizontal);
      baseStyle.marginHorizontal = marginValue;
    }
    if (marginVertical !== undefined) {
      const marginValue =
        marginVertical === 'auto'
          ? responsive.spacing.m
          : responsive.scaleHeight(marginVertical);
      baseStyle.marginVertical = marginValue;
    }

    // Gap responsive
    if (gap !== undefined || gapTablet !== undefined) {
      const gapValue =
        responsive.isTablet && gapTablet !== undefined
          ? gapTablet
          : gap === 'auto'
            ? responsive.spacing.m
            : gap;
      baseStyle.gap = responsive.scaleWidth(gapValue as number);
    }

    // Aplicar estilos por breakpoint
    const breakpointStyle = responsive.applyResponsiveStyle({
      xs: xsStyle,
      sm: smStyle,
      md: mdStyle,
      lg: lgStyle,
      xl: xlStyle,
      xxl: xxlStyle,
    });

    // Aplicar estilos por dispositivo
    const deviceStyle = responsive.isTablet ? tabletStyle : mobileStyle;

    // Aplicar estilos por orientaci√≥n
    const orientationStyle = responsive.isPortrait
      ? portraitStyle
      : landscapeStyle;

    // Combinar todos los estilos
    return [
      baseStyle,
      breakpointStyle,
      deviceStyle,
      orientationStyle,
      style,
    ].filter(Boolean);
  }, [
    responsive,
    style,
    xsStyle,
    smStyle,
    mdStyle,
    lgStyle,
    xlStyle,
    xxlStyle,
    mobileStyle,
    tabletStyle,
    portraitStyle,
    landscapeStyle,
    direction,
    directionTablet,
    padding,
    paddingHorizontal,
    paddingVertical,
    margin,
    marginHorizontal,
    marginVertical,
    gap,
    gapTablet,
    align,
    alignTablet,
    justify,
    justifyTablet,
    flex,
    flexTablet,
    wrap,
    wrapTablet,
    width,
    widthTablet,
    height,
    heightTablet,
    maxWidth,
    maxWidthTablet,
    maxHeight,
    maxHeightTablet,
    minWidth,
    minWidthTablet,
    minHeight,
    minHeightTablet,
    hideOnMobile,
    hideOnTablet,
    hideOnPortrait,
    hideOnLandscape,
  ]);

  return (
    <View style={responsiveStyles} {...restProps}>
      {children}
    </View>
  );
};

// Exportar tambi√©n un componente Row para facilitar layouts horizontales
export const ResponsiveRow: React.FC<ResponsiveViewProps> = (props) => {
  return <ResponsiveView direction="row" {...props} />;
};

// Exportar un componente Column para mantener consistencia
export const ResponsiveColumn: React.FC<ResponsiveViewProps> = (props) => {
  return <ResponsiveView direction="column" {...props} />;
};

================
File: app/src/app/constants/apiErrorCodes.ts
================
export const ERROR_CODES = {
  AUTH_INVALID_CREDENTIALS: 'AUTH_INVALID_CREDENTIALS',
  AUTH_INCORRECT_PASSWORD: 'AUTH_INCORRECT_PASSWORD',
  AUTH_DUPLICATE_EMAIL: 'AUTH_DUPLICATE_EMAIL',
  AUTH_DUPLICATE_USERNAME: 'AUTH_DUPLICATE_USERNAME',
  AUTH_UNAUTHORIZED: 'AUTH_UNAUTHORIZED',
  AUTH_FORBIDDEN: 'AUTH_FORBIDDEN',
  REFRESH_FAILED: 'REFRESH_FAILED',

  VALIDATION_ERROR: 'VALIDATION_ERROR',

  RESOURCE_NOT_FOUND: 'RESOURCE_NOT_FOUND',

  CONFLICT_ERROR: 'CONFLICT_ERROR',
  PRODUCT_NAME_EXISTS: 'PRODUCT_NAME_EXISTS',

  NETWORK_ERROR: 'NETWORK_ERROR',
  API_CLIENT_ERROR: 'API_CLIENT_ERROR',
  INTERNAL_SERVER_ERROR: 'INTERNAL_SERVER_ERROR',
  UNKNOWN_API_ERROR: 'UNKNOWN_API_ERROR',
  UNKNOWN_ERROR: 'UNKNOWN_ERROR',

  UPLOAD_FAILED: 'UPLOAD_FAILED',
  FILE_TOO_LARGE: 'FILE_TOO_LARGE',
} as const;

export type ApiErrorCode = (typeof ERROR_CODES)[keyof typeof ERROR_CODES];

================
File: app/src/app/constants/storageKeys.ts
================
/**
 * Constantes para las claves utilizadas en el almacenamiento seguro (EncryptedStorage).
 */
export const STORAGE_KEYS = {
  /** Clave para almacenar las credenciales del usuario (email/username y password) en formato JSON string. */
  REMEMBERED_CREDENTIALS: 'user_credentials',

  /** Clave para almacenar la preferencia del usuario sobre si desea ser recordado ('true' o 'false'). */
  REMEMBER_ME_ENABLED: 'remember_me_preference',

  /** Clave existente para el token de autenticaci√≥n. */
  AUTH_TOKEN: 'auth_token',
} as const;

================
File: app/src/app/docs/DateTimePickerUsage.md
================
# Uso del DateTimePickerSafe

## Problema Original

El error "Loss of precision during arithmetic conversion" ocurre cuando React Native con Hermes intenta hacer conversiones aritm√©ticas con objetos Date, especialmente al usar librer√≠as como `@react-native-community/datetimepicker` o `react-native-modal-datetime-picker`.

## Soluci√≥n

Hemos creado dos utilidades para manejar fechas/horas de forma segura:

1. **DateTimePickerSafe**: Un componente selector de fecha/hora que evita conversiones problem√°ticas
2. **dateTimeHelpers**: Funciones helper para conversiones seguras

## Ejemplo de Uso

### 1. Reemplazar TimePickerModal actual

```tsx
// Antes (problem√°tico)
import DateTimePicker from '@react-native-community/datetimepicker';

// Despu√©s (seguro)
import DateTimePickerSafe from '@/app/components/DateTimePickerSafe';

// En tu componente:
const [showPicker, setShowPicker] = useState(false);
const [selectedDateTime, setSelectedDateTime] = useState<Date | null>(null);

return (
  <>
    <Button onPress={() => setShowPicker(true)}>
      Seleccionar Fecha/Hora
    </Button>
    
    <DateTimePickerSafe
      visible={showPicker}
      onDismiss={() => setShowPicker(false)}
      onConfirm={(date) => {
        setSelectedDateTime(date);
        setShowPicker(false);
      }}
      mode="datetime" // o "date" o "time"
      initialDate={selectedDateTime || undefined}
      title="Seleccionar hora de entrega"
    />
  </>
);
```

### 2. Usar los helpers seguros

```tsx
import {
  safeTimeStringToDate,
  safeDateToTimeString,
  getNextAvailableTime,
  parseDateFromBackend
} from '@/app/utils/dateTimeHelpers';

// Convertir string de hora a Date
const date = safeTimeStringToDate("14:30"); // Hoy a las 14:30

// Convertir Date a string de hora
const timeStr = safeDateToTimeString(new Date()); // "14:30"

// Obtener pr√≥xima hora disponible (redondeada a 5 min)
const nextTime = getNextAvailableTime(30); // 30 min en el futuro

// Parsear fecha del backend de forma segura
const backendDate = parseDateFromBackend(orderData.scheduledAt);
if (backendDate) {
  const timeString = safeDateToTimeString(backendDate);
}
```

### 3. Integraci√≥n en OrderCartDetail

```tsx
// Para hora programada de pedidos
const handleScheduleTime = () => {
  setShowDateTimePicker(true);
};

const handleConfirmScheduledTime = (date: Date) => {
  const timeString = safeDateToTimeString(date);
  setScheduledTime(timeString);
  setShowDateTimePicker(false);
};

// En el render:
<DateTimePickerSafe
  visible={showDateTimePicker}
  onDismiss={() => setShowDateTimePicker(false)}
  onConfirm={handleConfirmScheduledTime}
  mode="time"
  title="Hora de entrega"
  initialDate={scheduledTime ? safeTimeStringToDate(scheduledTime) : undefined}
/>
```

## Ventajas

1. **Sin p√©rdida de precisi√≥n**: Evita conversiones aritm√©ticas problem√°ticas
2. **Compatible con Hermes**: Usa operaciones seguras y date-fns
3. **UX mejorada**: Interfaz nativa de selecci√≥n sin dependencias problem√°ticas
4. **Validaci√≥n incluida**: Maneja errores y casos edge autom√°ticamente
5. **Localizaci√≥n**: Soporta espa√±ol por defecto con date-fns/locale

## Migraci√≥n

Para migrar del componente actual:

1. Reemplaza `TimePickerModal` por `DateTimePickerSafe` con `mode="time"`
2. Reemplaza `convertTimeStringToDate` por `safeTimeStringToDate`
3. Reemplaza `format(new Date(date), 'HH:mm')` por `safeDateToTimeString(parseDateFromBackend(date))`
4. Usa `getDateTimeForBackend(date)` al enviar fechas al backend

================
File: app/src/app/docs/RESPONSIVE_GUIDE.md
================
# Gu√≠a del Sistema Responsive

## Introducci√≥n

Este documento describe c√≥mo utilizar el sistema responsive implementado en la aplicaci√≥n para garantizar una experiencia √≥ptima en diferentes tama√±os de pantalla y dispositivos.

## Conceptos Clave

### Breakpoints
```typescript
xs: 0     // Extra peque√±o (m√≥viles peque√±os)
sm: 360   // Peque√±o (m√≥viles est√°ndar)
md: 600   // Mediano (m√≥viles grandes y tablets peque√±as)
lg: 900   // Grande (tablets)
xl: 1200  // Extra grande (tablets grandes)
xxl: 1536 // Doble extra grande (tablets pro)
```

### Hook useResponsive

El hook principal que proporciona toda la informaci√≥n responsive:

```typescript
const responsive = useResponsive();

// Propiedades disponibles:
responsive.window          // Dimensiones de la ventana
responsive.isTablet        // true si es tablet
responsive.spacing         // Espaciado responsive
responsive.fontSize        // Tama√±os de fuente responsive
responsive.dimensions      // Dimensiones comunes responsive
responsive.getResponsiveDimension(mobile, tablet) // Dimensi√≥n adaptativa
responsive.getGridColumns(minWidth, gap, padding) // Columnas din√°micas
responsive.scaleFont(size) // Escalar fuente seg√∫n DPI
responsive.scaleSize(size) // Escalar tama√±o seg√∫n DPI
```

## Componentes Responsive

### ResponsiveView
Componente base para layouts responsive:

```tsx
<ResponsiveView
  breakpoints={{
    xs: { padding: 16 },
    md: { padding: 24 },
    lg: { padding: 32 }
  }}
  mobileProps={{ flexDirection: 'column' }}
  tabletProps={{ flexDirection: 'row' }}
>
  {/* Contenido */}
</ResponsiveView>
```

### ResponsiveGrid
Grid con columnas din√°micas:

```tsx
<ResponsiveGrid
  columns={3}
  columnsTablet={4}
  gap={responsive.spacing.m}
  minItemWidth={150}
>
  {/* Items del grid */}
</ResponsiveGrid>
```

### ResponsiveImage
Im√°genes con escalado autom√°tico:

```tsx
<ResponsiveImage
  source={require('./image.png')}
  baseWidth={200}
  baseHeight={150}
  maxScale={1.5}
/>
```

### ResponsiveModal
Modales con tama√±o adaptativo:

```tsx
<ResponsiveModal
  visible={visible}
  onDismiss={onDismiss}
  size="medium" // small, medium, large, fullscreen
>
  {/* Contenido del modal */}
</ResponsiveModal>
```

## Mejores Pr√°cticas

### 1. Siempre usa valores responsive

‚ùå **Evitar:**
```tsx
style={{ padding: 16, fontSize: 14 }}
```

‚úÖ **Preferir:**
```tsx
style={{ 
  padding: responsive.spacing.m,
  fontSize: responsive.fontSize.m 
}}
```

### 2. Dise√±a mobile-first

Comienza con el dise√±o m√≥vil y a√±ade mejoras para tablets:

```tsx
const styles = StyleSheet.create({
  container: {
    // Base m√≥vil
    flexDirection: 'column',
    padding: responsive.spacing.m,
    
    // Mejoras para tablet
    ...(responsive.isTablet && {
      flexDirection: 'row',
      padding: responsive.spacing.xl,
    }),
  },
});
```

### 3. Usa grids din√°micos

Para listas de items, usa ResponsiveGrid o calcula columnas din√°micamente:

```tsx
const numColumns = useMemo(() => {
  return responsive.getGridColumns(150, responsive.spacing.m, responsive.spacing.m);
}, [responsive]);

<FlatList
  numColumns={numColumns}
  key={numColumns} // Importante para re-render
  // ...
/>
```

### 4. Considera la orientaci√≥n

Para pantallas espec√≠ficas como cocina:

```tsx
useEffect(() => {
  // Forzar orientaci√≥n horizontal
  ScreenOrientation.lockAsync(ScreenOrientation.OrientationLock.LANDSCAPE);
  
  return () => {
    ScreenOrientation.unlockAsync();
  };
}, []);
```

### 5. Optimiza im√°genes

Usa dimensiones responsive para im√°genes:

```tsx
<AutoImage
  source={imageUrl}
  maxWidth={responsive.getResponsiveDimension(300, 500)}
  maxHeight={responsive.getResponsiveDimension(200, 350)}
/>
```

### 6. Tipograf√≠a responsive

Usa la escala de fuentes predefinida:

```tsx
responsive.fontSize.xs  // 10
responsive.fontSize.s   // 12
responsive.fontSize.m   // 14
responsive.fontSize.l   // 16
responsive.fontSize.xl  // 20
responsive.fontSize.xxl // 24
responsive.fontSize.xxxl // 32
```

### 7. Espaciado consistente

Usa la escala de espaciado:

```tsx
responsive.spacing.xs  // 4
responsive.spacing.s   // 8
responsive.spacing.m   // 16
responsive.spacing.l   // 24
responsive.spacing.xl  // 32
responsive.spacing.xxl // 48
```

## Patrones Comunes

### Layout Lado a Lado en Tablets

```tsx
if (responsive.isTablet && responsive.window.width > responsive.window.height) {
  return (
    <View style={{ flexDirection: 'row' }}>
      <View style={{ flex: 1 }}>{/* Panel izquierdo */}</View>
      <View style={{ flex: 1 }}>{/* Panel derecho */}</View>
    </View>
  );
}
```

### Modal Adaptativo

```tsx
const modalWidth = responsive.isTablet 
  ? Math.min(600, responsive.window.width * 0.8)
  : responsive.window.width * 0.9;
```

### Grid con M√≠nimo de Items

```tsx
const columns = Math.max(2, responsive.getGridColumns(100));
```

## Pruebas Recomendadas

1. **Dispositivos m√≥viles:** 
   - iPhone SE (375x667)
   - iPhone 14 (390x844)
   - Pixel 5 (393x851)

2. **Tablets:**
   - iPad Mini (768x1024)
   - iPad Pro 11" (834x1194)
   - iPad Pro 12.9" (1024x1366)

3. **Orientaciones:**
   - Portrait y Landscape
   - Cambios din√°micos de orientaci√≥n

4. **Densidades de p√≠xeles:**
   - @1x, @2x, @3x
   - Verificar escalado de fuentes e iconos

================
File: app/src/app/hooks/useCrudScreenLogic.ts
================
import { useState, useCallback } from 'react';
import { useMutation, useQueryClient, QueryKey } from '@tanstack/react-query';
import { Alert } from 'react-native';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { getApiErrorMessage } from '@/app/lib/errorMapping';

interface CrudLogicParams {
  entityName: string;
  queryKey: QueryKey;
  deleteMutationFn: (id: string) => Promise<void>;
}

export function useCrudScreenLogic<TItem extends { id: string }>({
  entityName,
  queryKey,
  deleteMutationFn,
}: CrudLogicParams) {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((s) => s.showSnackbar);
  const [isFormModalVisible, setIsFormModalVisible] = useState(false);
  const [isDetailModalVisible, setIsDetailModalVisible] = useState(false);
  const [editingItem, setEditingItem] = useState<TItem | null>(null);
  const [selectedItem, setSelectedItem] = useState<TItem | null>(null);

  const deleteMutation = useMutation({
    mutationFn: deleteMutationFn,
    onSuccess: (_, _deletedId) => {
      queryClient.invalidateQueries({ queryKey });
      showSnackbar({
        message: `${entityName} eliminado con √©xito`,
        type: 'success',
      });
      handleCloseModals();
    },
    onError: (error) => {
      showSnackbar({
        message: `Error al eliminar ${entityName}: ${getApiErrorMessage(error)}`,
        type: 'error',
      });
    },
  });

  const handleOpenCreateModal = useCallback(() => {
    setEditingItem(null);
    setSelectedItem(null);
    setIsFormModalVisible(true);
    setIsDetailModalVisible(false);
  }, []);

  const handleOpenEditModal = useCallback((item: TItem) => {
    setEditingItem(item);
    setSelectedItem(null);
    setIsFormModalVisible(true);
    setIsDetailModalVisible(false);
  }, []);

  const handleOpenDetailModal = useCallback((item: TItem) => {
    setSelectedItem(item);
    setEditingItem(null);
    setIsDetailModalVisible(true);
    setIsFormModalVisible(false);
  }, []);

  const handleCloseModals = useCallback(() => {
    setIsFormModalVisible(false);
    setIsDetailModalVisible(false);
    setEditingItem(null);
    setSelectedItem(null);
  }, []);

  const handleDeleteItem = useCallback(
    (id: string) => {
      Alert.alert(
        `Confirmar Eliminaci√≥n`,
        `¬øEst√°s seguro de que deseas eliminar este ${entityName.toLowerCase()}?`,
        [
          { text: 'Cancelar', style: 'cancel' },
          {
            text: 'Eliminar',
            style: 'destructive',
            onPress: () => deleteMutation.mutate(id),
          },
        ],
      );
    },
    [deleteMutation, entityName],
  );

  // Alternative deletion methods for use with ConfirmationModal
  const [deleteConfirmationState, setDeleteConfirmationState] = useState<{
    visible: boolean;
    itemId: string | null;
  }>({
    visible: false,
    itemId: null,
  });

  const showDeleteConfirmation = useCallback((id: string) => {
    setDeleteConfirmationState({ visible: true, itemId: id });
  }, []);

  const hideDeleteConfirmation = useCallback(() => {
    setDeleteConfirmationState({ visible: false, itemId: null });
  }, []);

  const confirmDelete = useCallback(() => {
    if (deleteConfirmationState.itemId) {
      deleteMutation.mutate(deleteConfirmationState.itemId);
      hideDeleteConfirmation();
    }
  }, [deleteConfirmationState.itemId, deleteMutation, hideDeleteConfirmation]);

  return {
    isFormModalVisible,
    isDetailModalVisible,
    editingItem,
    selectedItem,
    isDeleting: deleteMutation.isPending,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
    handleDeleteItem,
    // New properties for ConfirmationModal integration
    deleteConfirmation: {
      visible: deleteConfirmationState.visible,
      title: 'Confirmar Eliminaci√≥n',
      message: `¬øEst√°s seguro de que deseas eliminar este ${entityName.toLowerCase()}?`,
      onConfirm: confirmDelete,
      onCancel: hideDeleteConfirmation,
      show: showDeleteConfirmation,
    },
  };
}

================
File: app/src/app/hooks/useListState.ts
================
import React, { useMemo } from 'react';
import EmptyState from '../components/common/EmptyState';

interface UseListStateProps {
  isLoading: boolean;
  isError: boolean;
  data: any[] | undefined;
  emptyConfig: {
    title: string;
    message?: string;
    actionLabel?: string;
    onAction?: () => void;
    icon?: string;
  };
  errorConfig?: {
    title?: string;
    message?: string;
    actionLabel?: string;
    onAction?: () => void;
    icon?: string;
  };
}

export const useListState = ({
  isLoading,
  isError,
  data,
  emptyConfig,
  errorConfig,
}: UseListStateProps) => {
  const isEmpty = useMemo(() => {
    return !isLoading && !isError && data && data.length === 0;
  }, [isLoading, isError, data]);

  const ListEmptyComponent = useMemo(() => {
    // Return a function component instead of JSX directly
    return () => {
      if (isLoading) return null;

      if (isError) {
        return React.createElement(EmptyState, {
          icon: errorConfig?.icon || 'alert-circle',
          title: errorConfig?.title || 'Error al cargar los datos',
          message:
            errorConfig?.message ||
            'Ocurri√≥ un error al cargar la informaci√≥n. Por favor, intenta de nuevo.',
          actionLabel: errorConfig?.actionLabel || 'Reintentar',
          onAction: errorConfig?.onAction || emptyConfig.onAction,
        });
      }

      if (isEmpty) {
        return React.createElement(EmptyState, {
          icon: emptyConfig.icon || 'folder-open',
          title: emptyConfig.title,
          message: emptyConfig.message,
          actionLabel: emptyConfig.actionLabel,
          onAction: emptyConfig.onAction,
        });
      }

      return null;
    };
  }, [isLoading, isError, isEmpty, emptyConfig, errorConfig]);

  return {
    isEmpty,
    ListEmptyComponent,
  };
};

================
File: app/src/app/lib/apiHelpers.ts
================
import { ApiResponse } from 'apisauce';
import { ApiError } from './errors';

/**
 * Helper function to handle API responses consistently.
 * If the response is not ok, it extracts the error from the response.
 *
 * @param response - The API response from apisauce
 * @returns The response data if successful
 * @throws ApiError if the response is not ok
 */
export function handleApiResponse<T>(response: ApiResponse<T>): T {
  // Caso especial: si data es un array vac√≠o, es una respuesta v√°lida
  if (
    response.ok &&
    Array.isArray(response.data) &&
    response.data.length === 0
  ) {
    return response.data;
  }

  if (!response.ok || !response.data) {
    // Check if the originalError is already an ApiError (from interceptor)
    if (response.originalError && response.originalError instanceof ApiError) {
      throw response.originalError;
    }

    // Otherwise, create a new ApiError from the response
    throw ApiError.fromApiResponse(response.data, response.status);
  }

  return response.data;
}

/**
 * Helper function to handle API responses that don't return data.
 *
 * @param response - The API response from apisauce
 * @throws ApiError if the response is not ok
 */
export function handleApiResponseVoid(response: ApiResponse<any>): void {
  if (!response.ok) {
    // Check if the originalError is already an ApiError (from interceptor)
    if (response.originalError && response.originalError instanceof ApiError) {
      throw response.originalError;
    }

    // Otherwise, create a new ApiError from the response
    throw ApiError.fromApiResponse(response.data, response.status);
  }
}

================
File: app/src/app/lib/errors.ts
================
import { ERROR_CODES, ApiErrorCode } from '../constants/apiErrorCodes';
import { BackendErrorResponse } from '../types/api.types';
import { AxiosError } from 'axios'; // Import AxiosError type

export class ApiError extends Error {
  public readonly code: ApiErrorCode | string;
  public readonly status: number;
  public readonly details?: any;
  public readonly originalMessage: string;

  constructor(
    code: ApiErrorCode | string = ERROR_CODES.UNKNOWN_API_ERROR,
    backendMessage: string = 'Ocurri√≥ un error en la API',
    status: number = 500,
    details?: any,
  ) {
    super(backendMessage);
    this.code = code;
    this.status = status;
    this.details = details;
    this.originalMessage = backendMessage;
    this.name = 'ApiError';
    // Mantener compatibilidad con entornos Node/V8
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ApiError);
    }
  }

  /**
   * Creates an ApiError instance from an apisauce ApiResponse (legacy or direct use).
   * Kept for potential compatibility, but prefer fromAxiosError.
   */
  static fromApiResponse(
    responseData: BackendErrorResponse | any,
    responseStatus?: number,
  ): ApiError {
    const status = responseStatus ?? responseData?.statusCode ?? 500;
    const code = responseData?.code ?? ERROR_CODES.UNKNOWN_API_ERROR;
    const message = responseData?.message ?? 'Error desconocido de la API.';
    const details = responseData?.details;
    // Uses the main constructor signature: code, message, status, details
    return new ApiError(code, message, status, details);
  }

  /**
   * Creates an ApiError instance from an AxiosError.
   * Extracts relevant information from the Axios error response.
   */
  static fromAxiosError(error: any): ApiError {
    if (error instanceof ApiError) {
      // If it's already an ApiError (e.g., from refresh failure), return it directly
      return error;
    }

    // Use type assertion for better property access
    const axiosError = error as AxiosError;
    const responseData = axiosError.response?.data as
      | BackendErrorResponse
      | any;
    const status = axiosError.response?.status ?? 500;

    // Manejar errores de red espec√≠ficamente
    if (axiosError.code === 'ERR_NETWORK' || !axiosError.response) {
      return new ApiError(
        ERROR_CODES.NETWORK_ERROR,
        'Error de conexi√≥n. Verifica tu conexi√≥n a internet e intenta nuevamente.',
        0,
        { originalError: axiosError.message },
      );
    }

    // Manejar timeout
    if (
      axiosError.code === 'ECONNABORTED' ||
      axiosError.message.includes('timeout')
    ) {
      return new ApiError(
        ERROR_CODES.NETWORK_ERROR,
        'La solicitud tard√≥ demasiado tiempo. Intenta nuevamente con una conexi√≥n m√°s estable.',
        0,
        { originalError: axiosError.message },
      );
    }

    // Extract error code - check multiple possible locations
    const code =
      responseData?.code ||
      responseData?.error?.code ||
      responseData?.errors?.[0]?.code ||
      ERROR_CODES.UNKNOWN_API_ERROR;

    // Extract error message - check multiple possible locations
    const message =
      responseData?.message ||
      responseData?.error?.message ||
      responseData?.errors?.[0]?.message ||
      axiosError.message ||
      'Error desconocido de la API.';

    // Include full response data as details if no specific 'details' property exists
    const details = responseData?.details ?? responseData;

    // Uses the main constructor signature: code, message, status, details
    return new ApiError(code, message, status, details);
  }

  /**
   * Creates a specific ApiError for refresh token failures.
   */
  static fromRefreshError(error: any): ApiError {
    // Note: Logout logic should primarily reside in the refreshToken function itself

    // Uses the main constructor signature: code, message, status, details
    return new ApiError(
      ERROR_CODES.REFRESH_FAILED, // Specific code for refresh failure - Ensure this exists in ERROR_CODES
      error?.message || 'La sesi√≥n ha expirado o no se pudo renovar.', // Message
      401, // Status (force 401)
      error, // Details (original error)
    );
  }
} // End of ApiError class definition

================
File: app/src/app/lib/IMAGE_CACHE_GUIDE.md
================
# üñºÔ∏è Sistema de Cache de Im√°genes Optimizado

## üìã Resumen de Optimizaciones Implementadas

### ‚úÖ **Correcciones Cr√≠ticas**
1. **Eliminaci√≥n de doble resoluci√≥n de URLs**
   - Componentes ahora pasan `path` directamente a `AutoImage`
   - `AutoImage` maneja internamente la resoluci√≥n con `getImageUrl()`
   - Eliminado uso innecesario de `await getImageUrl()` en componentes

2. **Archivos corregidos:**
   - `GenericDetailModal.tsx`: Usa `imageSource` en lugar de `imageUrl`
   - `CategoriesScreen.tsx`: Pasa `photo.path` directamente al formulario
   - `ProductFormModal.tsx`: Pasa `photo.path` directamente al formulario
   - `SubcategoriesScreen.tsx`: Pasa `photo.path` directamente al formulario

### üîß **Optimizaciones Implementadas**

#### 1. **Logging Optimizado (Solo Errores)**
```typescript
// Logs reducidos a lo esencial:
- CACHE_MISS_FAILED: Fallo en descarga
- CACHE_CLEANED: Limpieza exitosa (con detalles)
- CACHE_CLEAN_ERROR: Error en limpieza
- CACHE_ITEM_REMOVE_FAILED: Error al remover item
- CACHE_CLEAR_FAILED: Error al limpiar cache
- PREFETCH_FAILED: Fallos en prefetch
```

#### 2. **Retry Logic con Backoff Exponencial**
```typescript
// Configuraci√≥n:
- MAX_RETRIES: 3 intentos
- BASE_RETRY_DELAY: 1000ms
- Backoff: 1s, 2s, 4s, 8s...
- L√≠mite de cache: 500MB (aumentado desde 100MB)
```

#### 3. **Prefetching Inteligente**
```typescript
// Funciones disponibles:
- prefetchImages(): Prefetch gen√©rico
- prefetchMenuImages(): Espec√≠fico para men√∫s
- Integraci√≥n autom√°tica en useGetFullMenu()
```

#### 4. **Limpieza de Cache Optimizada**
```typescript
// Estrategia mejorada:
- Fase 1: Eliminaci√≥n por edad (m√°s eficiente)
- Fase 2: Eliminaci√≥n por tama√±o (LRU)
- Margen del 10% para evitar limpiezas frecuentes
- Logging detallado con m√©tricas
```

### üìä **Impacto en Rendimiento**

#### **Antes:**
- ‚ùå Doble resoluci√≥n de URLs (componente + AutoImage)
- ‚ùå Sin retry en descargas fallidas
- ‚ùå Sin prefetch autom√°tico
- ‚ùå Limpieza b√°sica de cache
- ‚ùå Logs excesivos para cada operaci√≥n

#### **Despu√©s:**
- ‚úÖ Resoluci√≥n √∫nica de URLs (solo AutoImage)
- ‚úÖ Retry autom√°tico con backoff exponencial
- ‚úÖ Prefetch autom√°tico en background
- ‚úÖ Limpieza inteligente con m√©tricas
- ‚úÖ Logging optimizado (solo errores y operaciones cr√≠ticas)

### üéØ **Beneficios Esperados**
- **30-50% reducci√≥n** en tiempo de carga de im√°genes
- **60-80% reducci√≥n** en uso de ancho de banda
- **Mejor experiencia** en men√∫s largos
- **Mayor confiabilidad** en conexiones inestables
- **Performance mejorada** sin logs innecesarios
- **L√≠mite de cache aumentado** a 500MB para casos extremos

### üí° **Uso Recomendado**

#### Para Desarrolladores:
```typescript
// ‚úÖ Correcto - Usar AutoImage con path
<AutoImage source={item.photo?.path} />

// ‚ùå Incorrecto - No resolver URL manualmente
const imageUrl = await getImageUrl(item.photo.path);
<AutoImage source={imageUrl} />
```

#### Para Prefetch Manual:
```typescript
// Prefetch espec√≠fico para men√∫s
await prefetchMenuImages(menuData, {
  maxConcurrent: 3,
  onProgress: (completed, total) => console.log(`${completed}/${total}`)
});
```

### üìù **Logs de Ejemplo (Solo Errores)**
```
[ImageCache] CACHE_MISS_FAILED: {
  url: "https://api.example.com/image.jpg",
  filename: "abc123.jpg",
  error: "Download failed after all retries"
}

[ImageCache] CACHE_CLEANED: {
  filesDeleted: 45,
  sizeCleaned: "123.45MB",
  totalFilesRemaining: 155,
  totalSizeRemaining: "376.55MB",
  originalSize: "500.00MB",
  spaceFreed: "123.45MB",
  cacheUtilization: "75.3%"
}

[ImageCache] PREFETCH_FAILED: {
  totalImages: 25,
  failed: 2,
  successRate: "92.0%"
}
```

## üîç **Monitoreo**

Para monitorear el rendimiento del cache, busca en los logs:
- Fallos en `CACHE_MISS_FAILED` 
- Limpiezas en `CACHE_CLEANED` para verificar uso de espacio
- Tasas de error en `PREFETCH_FAILED`
- Errores de sistema en `CACHE_*_ERROR`

## üöÄ **Activaci√≥n**

El sistema est√° **completamente activado** y funcionando autom√°ticamente:
- Cache se inicializa al arrancar la app
- Prefetch se ejecuta autom√°ticamente al cargar men√∫s
- Retry funciona autom√°ticamente en descargas fallidas
- Limpieza se ejecuta autom√°ticamente en segundo plano

================
File: app/src/app/navigation/OrdersStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import OrdersScreen from '../../modules/orders/screens/OrdersScreen';
import CreateOrderScreen from '../../modules/orders/screens/CreateOrderScreen';
import OpenOrdersScreen from '../../modules/orders/screens/OpenOrdersScreen';
import AddProductsToOrderScreen from '../../modules/orders/screens/AddProductsToOrderScreen';

import type { OrdersStackParamList } from './types';
import { useAppTheme } from '../styles/theme';
import { getStackHeaderOptions } from './options';

const Stack = createNativeStackNavigator<OrdersStackParamList>();

function OrdersStackNavigator() {
  const theme = useAppTheme();

  return (
    <Stack.Navigator
      initialRouteName="Orders"
      screenOptions={{
        ...getStackHeaderOptions(theme),
      }}
    >
      <Stack.Screen
        name="Orders"
        component={OrdersScreen}
        options={{ title: '√ìrdenes' }}
      />
      <Stack.Screen
        name="CreateOrder"
        component={CreateOrderScreen}
        options={{ title: 'Crear Nueva Orden', headerShown: false }}
      />
      <Stack.Screen
        name="OpenOrders"
        component={OpenOrdersScreen}
        options={{ title: '√ìrdenes Abiertas' }}
      />
      <Stack.Screen
        name="AddProductsToOrder"
        component={AddProductsToOrderScreen}
        options={{ title: 'A√±adir Productos', headerShown: false }}
      />
    </Stack.Navigator>
  );
}

export default OrdersStackNavigator;

================
File: app/src/app/schemas/domain/adjustment.schema.ts
================
import { z } from 'zod';

export const adjustmentSchema = z.object({
  id: z.string(),
  orderId: z.string().nullable().optional(),
  orderItemId: z.string().nullable().optional(),
  name: z.string(),
  isPercentage: z.boolean(),
  value: z.number(), // Porcentaje si isPercentage es true (0-100)
  amount: z.number(), // Monto calculado o fijo
  appliedById: z.string(),
  appliedAt: z.string(),
  createdAt: z.string(),
  updatedAt: z.string(),
  deletedAt: z.string().nullable().optional(),

  // Relaciones opcionales
  order: z.any().optional(),
  orderItem: z.any().optional(),
  appliedBy: z.any().optional(),
});

export type Adjustment = z.infer<typeof adjustmentSchema>;

// Schema base para crear un ajuste (sin validaciones)
const createAdjustmentBaseSchema = z.object({
  orderId: z.string().uuid().optional(),
  orderItemId: z.string().uuid().optional(),
  name: z.string().max(100),
  isPercentage: z.boolean(),
  value: z.number().min(0).max(100).optional(), // Solo requerido si isPercentage es true
  amount: z.number().optional(), // Solo requerido si isPercentage es false
});

// Schema para crear un ajuste con validaciones
export const createAdjustmentSchema = createAdjustmentBaseSchema
  .refine(
    (data) => {
      // Debe tener orderId O orderItemId, pero no ambos
      return (
        (data.orderId && !data.orderItemId) ||
        (!data.orderId && data.orderItemId)
      );
    },
    {
      message:
        'El ajuste debe aplicarse a una orden o a un item de orden, pero no a ambos',
    },
  )
  .refine(
    (data) => {
      // Si es porcentaje, debe tener value. Si no, debe tener amount
      if (data.isPercentage) {
        return data.value !== undefined;
      } else {
        return data.amount !== undefined;
      }
    },
    {
      message:
        "Si es porcentaje debe incluir 'value', si no debe incluir 'amount'",
    },
  );

export type CreateAdjustment = z.infer<typeof createAdjustmentSchema>;

// Schema para actualizar un ajuste (usando el schema base sin validaciones)
export const updateAdjustmentSchema = createAdjustmentBaseSchema.partial();
export type UpdateAdjustment = z.infer<typeof updateAdjustmentSchema>;

================
File: app/src/app/schemas/domain/area.schema.ts
================
import { z } from 'zod';

// √önica fuente de verdad para la entidad Area
export const areaSchema = z.object({
  id: z.string().uuid(),
  name: z.string(),
  description: z.string().nullable().optional(),
  isActive: z.boolean(),
  createdAt: z.string().datetime().optional(), // O z.date() si se prefiere
  updatedAt: z.string().datetime().optional(), // O z.date() si se prefiere
});

// Tipo TypeScript inferido y exportado centralmente
export type Area = z.infer<typeof areaSchema>;

================
File: app/src/app/schemas/domain/category.schema.ts
================
import { z } from 'zod';

/**
 * Esquema Zod para validar la estructura de una foto de categor√≠a.
 * Fuente de verdad centralizada.
 */
export const categoryPhotoSchema = z.object({
  id: z.string(), // Asumiendo que el ID puede no ser UUID aqu√≠, ajustar si es necesario
  path: z.string(), // Podr√≠a ser z.string().url() si siempre es URL
});

/**
 * Esquema Zod para validar un objeto Category completo.
 * Fuente de verdad centralizada.
 */
export const categorySchema = z.object({
  id: z.string(),
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().nullable().optional(),
  isActive: z.boolean(),
  sortOrder: z.number(),
  photo: categoryPhotoSchema.nullable().optional(),
});

// Tipos TypeScript inferidos y exportados centralmente
export type CategoryPhoto = z.infer<typeof categoryPhotoSchema>;
export type Category = z.infer<typeof categorySchema>;

================
File: app/src/app/schemas/domain/delivery-info.schema.ts
================
import { z } from 'zod';

export const DeliveryInfoSchema = z.object({
  id: z.string().optional(),
  orderId: z.string().optional(),
  fullAddress: z.string().optional(),
  street: z.string().optional(),
  number: z.string().optional(),
  interiorNumber: z.string().optional(),
  neighborhood: z.string().optional(),
  city: z.string().optional(),
  state: z.string().optional(),
  zipCode: z.string().optional(),
  country: z.string().optional(),
  recipientName: z.string().optional(),
  recipientPhone: z.string().optional(),
  deliveryInstructions: z.string().optional(),
  latitude: z.number().optional(),
  longitude: z.number().optional(),
  createdAt: z.string().datetime().optional(),
  updatedAt: z.string().datetime().optional(),
});

export type DeliveryInfo = z.infer<typeof DeliveryInfoSchema>;

================
File: app/src/app/schemas/domain/modifier-group.schema.ts
================
import { z } from 'zod';
// Importar Modifier si se incluye en el schema de dominio
// import { modifierSchema } from './modifier.schema';

/**
 * Esquema Zod para validar un objeto ModifierGroup completo.
 * Fuente de verdad centralizada.
 */
export const modifierGroupSchema = z.object({
  id: z.string(),
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().nullable().optional(),
  minSelections: z.number().int().min(0).optional(),
  maxSelections: z.number().int().min(1).optional(),
  isRequired: z.boolean().optional(),
  allowMultipleSelections: z.boolean().optional(),
  isActive: z.boolean().optional(), // Mantener opcional si la API puede no devolverlo siempre
  sortOrder: z.number(),
  // Opcional: Incluir schema de modificadores si es parte del dominio central
  // modifiers: z.array(modifierSchema).optional(),
});

// Tipo TypeScript inferido y exportado centralmente
export type ModifierGroup = z.infer<typeof modifierGroupSchema>;

================
File: app/src/app/schemas/domain/modifier.schema.ts
================
import { z } from 'zod';

/**
 * Esquema Zod para validar un objeto Modifier completo.
 * Fuente de verdad centralizada.
 */
export const modifierSchema = z.object({
  id: z.string(),
  modifierGroupId: z.string().min(1, 'El ID del grupo no es v√°lido'),
  name: z.string().min(1, 'El nombre es requerido').max(100),
  description: z.string().max(255).nullable().optional(),
  price: z.coerce.number().nullable().optional(),
  sortOrder: z.number().int().default(0),
  isDefault: z.boolean().default(false),
  isActive: z.boolean().default(true),
});

// Tipo TypeScript inferido y exportado centralmente
export type Modifier = z.infer<typeof modifierSchema>;

================
File: app/src/app/schemas/domain/photo.schema.ts
================
import { z } from 'zod';

/**
 * Esquema Zod para validar la estructura de una foto en el dominio.
 * Fuente de verdad centralizada.
 */
export const photoSchema = z.object({
  id: z.string().uuid(), // ID puede ser custom format
  path: z.string().url(), // Usar url() como en products/subcategories
});

// Tipo TypeScript inferido y exportado centralmente
export type Photo = z.infer<typeof photoSchema>;

================
File: app/src/app/schemas/domain/product-variant.schema.ts
================
import { z } from 'zod';

/**
 * Esquema Zod para validar un objeto ProductVariant completo.
 * Fuente de verdad centralizada.
 */
export const productVariantSchema = z.object({
  id: z.string(), // ID es requerido en el dominio
  name: z.string().min(1, 'El nombre es requerido'),
  price: z.coerce.number({
    // Usar coerce para asegurar que sea n√∫mero
    invalid_type_error: 'El precio debe ser un n√∫mero',
    required_error: 'El precio es requerido',
  }), // No necesita ser positivo aqu√≠, puede ser 0
  isActive: z.boolean(),
  sortOrder: z.number(),
});

// Tipo TypeScript inferido y exportado centralmente
export type ProductVariant = z.infer<typeof productVariantSchema>;

// Schema opcional para Input (definido manualmente, sin ID)
export const productVariantInputSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  price: z.coerce.number({
    invalid_type_error: 'El precio debe ser un n√∫mero',
    required_error: 'El precio es requerido',
  }),
  isActive: z.boolean(),
  sortOrder: z.number(),
});
export type ProductVariantInput = z.infer<typeof productVariantInputSchema>;

================
File: app/src/app/schemas/domain/product.schema.ts
================
import { z } from 'zod';
import { photoSchema } from './photo.schema';
import { productVariantSchema } from './product-variant.schema';
import { modifierGroupSchema } from './modifier-group.schema';
import { preparationScreenSchema } from './preparation-screen.schema';

/**
 * Esquema Zod para validar un objeto Product completo.
 * Fuente de verdad centralizada.
 */
export const productSchema = z.object({
  id: z.string(), // ID es requerido en el dominio
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().nullable().optional(), // Campo descripci√≥n agregado
  price: z
    .number()
    .positive('El precio debe ser positivo')
    .refine((val) => /^\d+(\.\d{1,2})?$/.test(String(val)), {
      message: 'El precio debe tener como m√°ximo dos decimales',
    })
    .optional()
    .nullable(),
  hasVariants: z.boolean(),
  isActive: z.boolean(),
  isPizza: z.boolean(),
  subcategoryId: z.string().min(1, 'La subcategor√≠a es requerida'),
  sortOrder: z.number(),
  photo: photoSchema.optional().nullable(),
  estimatedPrepTime: z
    .number()
    .min(1, 'El tiempo debe ser al menos 1 minuto')
    .optional(),
  preparationScreenId: z.string().optional().nullable(),
  preparationScreen: preparationScreenSchema.optional().nullable(),
  variants: z.array(productVariantSchema).optional(),
  modifierGroups: z.array(modifierGroupSchema).optional(),
  pizzaCustomizations: z.array(z.any()).optional(),
  pizzaConfiguration: z.any().optional(),
  createdAt: z.union([z.string().datetime(), z.date()]).optional(),
  updatedAt: z.union([z.string().datetime(), z.date()]).optional(),
});

export type Product = z.infer<typeof productSchema> & {
  pizzaCustomizations?: any[];
  pizzaConfiguration?: any;
};

================
File: app/src/app/schemas/domain/subcategory.schema.ts
================
import { z } from 'zod';
import { photoSchema } from './photo.schema'; // Importar schema de Photo centralizado
// import { productSchema } from './product.schema'; // Opcional: Importar si se incluyen productos

/**
 * Esquema Zod para validar un objeto SubCategory completo.
 * Fuente de verdad centralizada.
 */
export const subCategorySchema = z.object({
  id: z.string(),
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().nullable().optional(),
  isActive: z.boolean(),
  categoryId: z.string().min(1, 'El ID de categor√≠a no es v√°lido'),
  sortOrder: z.number(),
  photo: photoSchema.nullable().optional(), // Usar photoSchema centralizado
  // Opcional: Incluir productos si es relevante en el dominio general
  // products: z.array(productSchema).optional(),
  createdAt: z.union([z.string().datetime(), z.date()]).optional(), // Incluido desde la interfaz original
  updatedAt: z.union([z.string().datetime(), z.date()]).optional(), // Incluido desde la interfaz original
});

// Tipo TypeScript inferido y exportado centralmente
export type SubCategory = z.infer<typeof subCategorySchema>;

================
File: app/src/app/store/snackbarStore.ts
================
import { create } from 'zustand';

export type SnackbarType = 'info' | 'success' | 'error' | 'warning';

export interface SnackbarState {
  visible: boolean;
  message: string;
  type: SnackbarType;
  duration?: number;
  showSnackbar: (params: {
    message: string;
    type?: SnackbarType;
    duration?: number;
  }) => void;
  hideSnackbar: () => void;
}

export const useSnackbarStore = create<SnackbarState>((set) => ({
  visible: false,
  message: '',
  type: 'info',
  duration: 2000,
  showSnackbar: ({ message, type = 'info', duration = 2000 }) =>
    set({ visible: true, message, type, duration }),
  hideSnackbar: () => set({ visible: false }),
}));

================
File: app/src/app/styles/colors.ts
================
export const lightColors = {
  primary: '#1976D2',
  primaryContainer: '#BBDEFB',
  onPrimary: '#FFFFFF',
  onPrimaryContainer: '#004C8B',

  secondary: '#FF9800',
  secondaryContainer: '#FFE0B2',
  onSecondary: '#FFFFFF',
  onSecondaryContainer: '#562800',

  tertiary: '#43A047',
  tertiaryContainer: '#C8E6C9',
  onTertiary: '#FFFFFF',
  onTertiaryContainer: '#002411',

  background: '#F8F9FA',
  onBackground: '#202124',
  surface: '#FFFFFF',
  onSurface: '#202124',
  surfaceVariant: '#E4E6EB',
  onSurfaceVariant: '#44464F',

  error: '#B00020',
  errorContainer: '#FFDAD6',
  onError: '#FFFFFF',
  onErrorContainer: '#410002',

  outline: '#74777F',
  outlineVariant: '#C4C7C5',
  inverseSurface: '#2E3133',
  inverseOnSurface: '#F2F2F2',
  inversePrimary: '#80CBC4',

  success: '#2E7D32',
  successContainer: '#C8E6C9',
  onSuccessContainer: '#0D3912',
  warning: '#F57C00',
  warningContainer: '#FFE0B2',
  onWarningContainer: '#662D00',
  info: '#1976D2',
  infoContainer: '#BBDEFB',
  onInfoContainer: '#00325B',
};

export const darkColors = {
  primary: '#FF7043',
  primaryContainer: '#662E1A',
  onPrimary: '#FFFFFF',
  onPrimaryContainer: '#FFDACF',

  secondary: '#FFB74D',
  secondaryContainer: '#774B1F',
  onSecondary: '#000000',
  onSecondaryContainer: '#FFE0B2',

  tertiary: '#FFD54F',
  tertiaryContainer: '#775B25',
  onTertiary: '#000000',
  onTertiaryContainer: '#FFF3C4',

  background: '#121212',
  onBackground: '#FFFFFF',
  surface: '#1E1E1E',
  onSurface: '#FFFFFF',
  surfaceVariant: '#2C2C2C',
  onSurfaceVariant: '#9E9E9E',

  error: '#FF6B6B',
  errorContainer: '#4D2626',
  onError: '#FFFFFF',
  onErrorContainer: '#FFE5E5',

  outline: '#4F4F4F',
  outlineVariant: '#3D3D3D',
  inverseSurface: '#FFFFFF',
  inverseOnSurface: '#121212',
  inversePrimary: '#FF5722',

  success: '#69F0AE',
  successContainer: '#1B5E20',
  onSuccessContainer: '#B3FFD1',
  warning: '#FFC107',
  warningContainer: '#795548',
  onWarningContainer: '#FFE0B2',
  info: '#64B5F6',
  infoContainer: '#1565C0',
  onInfoContainer: '#B3E5FC',
};

================
File: app/src/app/styles/theme.ts
================
import { MD3LightTheme, MD3DarkTheme, useTheme } from 'react-native-paper';
import type { MD3Typescale } from 'react-native-paper/lib/typescript/types';
import { lightColors, darkColors } from './colors';
import { typography } from './typography';
import { BREAKPOINTS, DEVICE_TYPES, RESPONSIVE_DIMENSIONS } from './responsive';

declare global {
  namespace ReactNativePaper {
    interface MD3Colors {
      success: string;
      successContainer: string;
      onSuccessContainer: string;
      warning: string;
      warningContainer: string;
      onWarningContainer: string;
      info: string;
      infoContainer: string;
      onInfoContainer: string;
    }
  }
}

const spacing = {
  xs: 4,
  s: 8,
  m: 16,
  l: 24,
  xl: 32,
  xxl: 40,
};

// Sistema responsive integrado con el tema
const responsive = {
  breakpoints: BREAKPOINTS,
  deviceTypes: DEVICE_TYPES,
  dimensions: RESPONSIVE_DIMENSIONS,
};

const typescale: MD3Typescale = {
  default: {
    fontFamily: typography.bodyMedium.fontFamily,
    fontWeight: 'normal',
    letterSpacing: typography.bodyMedium.letterSpacing,
  },
  displayLarge: { ...typography.displayLarge, fontWeight: 'normal' },
  displayMedium: { ...typography.displayMedium, fontWeight: 'normal' },
  displaySmall: { ...typography.displaySmall, fontWeight: 'normal' },
  headlineLarge: { ...typography.headlineLarge, fontWeight: 'normal' },
  headlineMedium: { ...typography.headlineMedium, fontWeight: 'normal' },
  headlineSmall: { ...typography.headlineSmall, fontWeight: 'normal' },
  titleLarge: { ...typography.titleLarge, fontWeight: 'normal' },
  titleMedium: { ...typography.titleMedium, fontWeight: '500' },
  titleSmall: { ...typography.titleSmall, fontWeight: '500' },
  bodyLarge: { ...typography.bodyLarge, fontWeight: 'normal' },
  bodyMedium: { ...typography.bodyMedium, fontWeight: 'normal' },
  bodySmall: { ...typography.bodySmall, fontWeight: 'normal' },
  labelLarge: { ...typography.labelLarge, fontWeight: '500' },
  labelMedium: { ...typography.labelMedium, fontWeight: '500' },
  labelSmall: { ...typography.labelSmall, fontWeight: '500' },
};

export const lightTheme = {
  ...MD3LightTheme,
  colors: {
    ...MD3LightTheme.colors,
    ...lightColors,
  },
  fonts: typescale,
  spacing,
  responsive,
  roundness: 8,
};

export const darkTheme = {
  ...MD3DarkTheme,
  colors: {
    ...MD3DarkTheme.colors,
    ...darkColors,
  },
  fonts: typescale,
  spacing,
  responsive,
  roundness: 8,
};

export type AppTheme = typeof lightTheme;

export const useAppTheme = () => {
  try {
    const theme = useTheme();
    // Verificar que el tema sea un objeto v√°lido
    if (!theme || typeof theme !== 'object') {
      return lightTheme;
    }
    return theme as AppTheme;
  } catch (error) {
    return lightTheme;
  }
};

================
File: app/src/app/styles/typography.ts
================
import { Platform } from 'react-native';

export const typography = {
  fonts: {
    regular: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto',
      default: 'System',
    }),
    medium: Platform.select({
      ios: 'SF Pro Text-Medium',
      android: 'Roboto-Medium',
      default: 'System-Medium',
    }),
    light: Platform.select({
      ios: 'SF Pro Text-Light',
      android: 'Roboto-Light',
      default: 'System-Light',
    }),
    thin: Platform.select({
      ios: 'SF Pro Text-Thin',
      android: 'Roboto-Thin',
      default: 'System-Thin',
    }),
  },

  displayLarge: {
    fontFamily: Platform.select({
      ios: 'SF Pro Display',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 57,
    lineHeight: 64,
    letterSpacing: -0.25,
  },
  displayMedium: {
    fontFamily: Platform.select({
      ios: 'SF Pro Display',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 45,
    lineHeight: 52,
    letterSpacing: 0,
  },
  displaySmall: {
    fontFamily: Platform.select({
      ios: 'SF Pro Display',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 36,
    lineHeight: 44,
    letterSpacing: 0,
  },
  headlineLarge: {
    fontFamily: Platform.select({
      ios: 'SF Pro Display',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 32,
    lineHeight: 40,
    letterSpacing: 0,
  },
  headlineMedium: {
    fontFamily: Platform.select({
      ios: 'SF Pro Display',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 28,
    lineHeight: 36,
    letterSpacing: 0,
  },
  headlineSmall: {
    fontFamily: Platform.select({
      ios: 'SF Pro Display',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 24,
    lineHeight: 32,
    letterSpacing: 0,
  },
  titleLarge: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 22,
    lineHeight: 28,
    letterSpacing: 0,
  },
  titleMedium: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto-Medium',
      default: 'System-Medium',
    }),
    fontSize: 16,
    lineHeight: 24,
    letterSpacing: 0.15,
  },
  titleSmall: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto-Medium',
      default: 'System-Medium',
    }),
    fontSize: 14,
    lineHeight: 20,
    letterSpacing: 0.1,
  },
  labelLarge: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto-Medium',
      default: 'System-Medium',
    }),
    fontSize: 14,
    lineHeight: 20,
    letterSpacing: 0.1,
  },
  labelMedium: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto-Medium',
      default: 'System-Medium',
    }),
    fontSize: 12,
    lineHeight: 16,
    letterSpacing: 0.5,
  },
  labelSmall: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto-Medium',
      default: 'System-Medium',
    }),
    fontSize: 11,
    lineHeight: 16,
    letterSpacing: 0.5,
  },
  bodyLarge: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 16,
    lineHeight: 24,
    letterSpacing: 0.5,
  },
  bodyMedium: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 14,
    lineHeight: 20,
    letterSpacing: 0.25,
  },
  bodySmall: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 12,
    lineHeight: 16,
    letterSpacing: 0.4,
  },
};

export const iosFontFamily = {
  regular: 'System',
  medium: 'System',
  light: 'System',
  thin: 'System',
};

export const androidFontFamily = {
  regular: 'sans-serif',
  medium: 'sans-serif-medium',
  light: 'sans-serif-light',
  thin: 'sans-serif-thin',
};

================
File: app/src/app/types/api.types.ts
================
import { z } from 'zod';

export interface BackendErrorResponse {
  statusCode: number;
  code: string;
  message: string;
  details?: any;
  timestamp?: string;
  path?: string;
}

export const baseListQuerySchema = z.object({
  page: z.coerce.number().int().positive().optional().default(1),
  limit: z.coerce.number().int().positive().optional().default(10),
});

export type BaseListQueryDto = {
  page?: number;
  limit?: number;
};

export interface PaginatedResponse<T> {
  data: T[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

================
File: app/src/app/types/query.types.ts
================
import { z } from 'zod';

export const baseListQuerySchema = z.object({
  page: z.number().int().positive().optional().default(1),
  limit: z.number().int().positive().optional().default(10),
  search: z.string().optional(),
});

export type BaseListQuery = z.infer<typeof baseListQuerySchema>;

================
File: app/src/app/utils/dateTimeHelpers.ts
================
import { format, parse, setHours, setMinutes, isValid } from 'date-fns';
import { es } from 'date-fns/locale';

/**
 * Helpers seguros para manejo de fechas/horas en React Native con Hermes
 * Evita conversiones aritm√©ticas que causan p√©rdida de precisi√≥n
 */

/**
 * Convierte un string de hora (HH:mm) a un objeto Date seguro
 * @param timeString - String en formato HH:mm
 * @param baseDate - Fecha base opcional (por defecto hoy)
 * @returns Date con la hora configurada
 */
export const safeTimeStringToDate = (
  timeString: string,
  baseDate?: Date,
): Date => {
  // Validar formato
  if (!timeString || !timeString.match(/^\d{2}:\d{2}$/)) {
    throw new Error('Formato de hora inv√°lido. Use HH:mm');
  }

  const [hourStr, minuteStr] = timeString.split(':');
  const hour = parseInt(hourStr, 10);
  const minute = parseInt(minuteStr, 10);

  // Validar rangos
  if (hour < 0 || hour > 23 || minute < 0 || minute > 59) {
    throw new Error('Hora o minutos fuera de rango');
  }

  // Usar date-fns para operaciones seguras
  let date = baseDate ? new Date(baseDate) : new Date();
  date = setHours(date, hour);
  date = setMinutes(date, minute);
  date.setSeconds(0);
  date.setMilliseconds(0);

  return date;
};

/**
 * Convierte un Date a string de hora (HH:mm) de forma segura
 * @param date - Objeto Date
 * @returns String en formato HH:mm
 */
export const safeDateToTimeString = (date: Date): string => {
  if (!date || !isValid(date)) {
    throw new Error('Fecha inv√°lida');
  }

  return format(date, 'HH:mm');
};

/**
 * Crea una fecha programada combinando fecha y hora de forma segura
 * @param dateStr - String de fecha (yyyy-MM-dd) o Date
 * @param timeStr - String de hora (HH:mm)
 * @returns Date con fecha y hora combinadas
 */
export const createScheduledDateTime = (
  dateStr: string | Date,
  timeStr: string,
): Date => {
  let baseDate: Date;

  if (typeof dateStr === 'string') {
    // Parsear fecha string de forma segura
    baseDate = parse(dateStr, 'yyyy-MM-dd', new Date());
    if (!isValid(baseDate)) {
      throw new Error('Fecha inv√°lida');
    }
  } else {
    baseDate = new Date(dateStr);
  }

  return safeTimeStringToDate(timeStr, baseDate);
};

/**
 * Formatea una fecha para mostrar de forma amigable
 * @param date - Fecha a formatear
 * @param includeTime - Si incluir la hora
 * @returns String formateado
 */
export const formatDateTimeDisplay = (
  date: Date,
  includeTime: boolean = true,
): string => {
  if (!date || !isValid(date)) {
    return '';
  }

  if (includeTime) {
    return format(date, "d 'de' MMMM 'a las' HH:mm", { locale: es });
  }

  return format(date, "d 'de' MMMM 'de' yyyy", { locale: es });
};

/**
 * Obtiene el timestamp de una fecha de forma segura para enviar al backend
 * @param date - Fecha a convertir
 * @returns ISO string seguro
 */
export const getDateTimeForBackend = (date: Date): string => {
  if (!date || !isValid(date)) {
    throw new Error('Fecha inv√°lida para backend');
  }

  // Usar toISOString() que es seguro en Hermes
  return date.toISOString();
};

/**
 * Parsea una fecha del backend de forma segura
 * @param dateStr - String de fecha del backend
 * @returns Date parseado o null si es inv√°lido
 */
export const parseDateFromBackend = (
  dateStr: string | null | undefined,
): Date | null => {
  if (!dateStr) {
    return null;
  }

  try {
    const date = new Date(dateStr);
    return isValid(date) ? date : null;
  } catch {
    return null;
  }
};

/**
 * Redondea minutos al m√∫ltiplo de 5 m√°s cercano
 * @param minutes - Minutos a redondear
 * @returns Minutos redondeados
 */
export const roundMinutesToFive = (minutes: number): number => {
  // Evitar operaciones aritm√©ticas directas
  const quotient = Math.floor(minutes / 5);
  const remainder = minutes - quotient * 5;

  if (remainder >= 3) {
    return (quotient + 1) * 5;
  }

  return quotient * 5;
};

/**
 * Valida si una fecha/hora est√° en el futuro
 * @param date - Fecha a validar
 * @returns true si est√° en el futuro
 */
export const isFutureDateTime = (date: Date): boolean => {
  if (!date || !isValid(date)) {
    return false;
  }

  const now = new Date();
  return date.getTime() > now.getTime();
};

/**
 * Obtiene la pr√≥xima hora disponible para programaci√≥n (redondeada a 5 minutos)
 * @param minimumMinutesAhead - Minutos m√≠nimos en el futuro (default: 30)
 * @returns Date con la pr√≥xima hora disponible
 */
export const getNextAvailableTime = (
  minimumMinutesAhead: number = 30,
): Date => {
  const now = new Date();

  // A√±adir minutos m√≠nimos
  const futureTime = new Date(now.getTime() + minimumMinutesAhead * 60 * 1000);

  // Redondear minutos
  const roundedMinutes = roundMinutesToFive(futureTime.getMinutes());

  let result = setMinutes(futureTime, roundedMinutes);
  result.setSeconds(0);
  result.setMilliseconds(0);

  // Si el redondeo nos llev√≥ al pasado, a√±adir 5 minutos m√°s
  if (result.getTime() <= now.getTime()) {
    result = new Date(result.getTime() + 5 * 60 * 1000);
  }

  return result;
};

================
File: app/src/components/index.ts
================
export { AudioRecorderWidget } from './AudioRecorderWidget';
export { AudioOrderModal } from './AudioOrderModal';

================
File: app/src/hooks/useOrientation.ts
================
import { useState, useEffect } from 'react';
import { Dimensions } from 'react-native';

export function useOrientation() {
  const [isLandscape, setIsLandscape] = useState(
    Dimensions.get('window').width > Dimensions.get('window').height,
  );

  useEffect(() => {
    const updateOrientation = () => {
      const { width, height } = Dimensions.get('window');
      setIsLandscape(width > height);
    };

    const subscription = Dimensions.addEventListener(
      'change',
      updateOrientation,
    );
    return () => subscription?.remove();
  }, []);

  return isLandscape;
}

================
File: app/src/hooks/useSnackbar.ts
================
import { useSnackbarStore, SnackbarType } from '@/app/store/snackbarStore';

export function useSnackbar() {
  const { showSnackbar: show, hideSnackbar } = useSnackbarStore();

  const showSnackbar = (
    message: string,
    type: SnackbarType = 'info',
    duration?: number,
  ) => {
    show({ message, type, duration });
  };

  return {
    showSnackbar,
    hideSnackbar,
  };
}

================
File: app/src/modules/areasTables/components/AreaFormModal.tsx
================
import React from 'react';
import GenericFormModal, {
  FormFieldConfig,
} from '../../../app/components/crud/GenericFormModal';
import {
  Area,
  CreateAreaDto,
  UpdateAreaDto,
  CreateAreaSchema,
  UpdateAreaSchema,
} from '../schema/area.schema';
import { z } from 'zod';

const areaFormFields: FormFieldConfig<CreateAreaDto | UpdateAreaDto>[] = [
  {
    name: 'name',
    label: 'Nombre del √Årea',
    type: 'text',
    placeholder: 'Ej: Terraza, Sal√≥n Principal',
    required: true,
  },
  {
    name: 'description',
    label: 'Descripci√≥n (Opcional)',
    type: 'textarea',
    placeholder: 'Ej: √Årea al aire libre con vista',
    numberOfLines: 3,
  },
  {
    name: 'isActive',
    label: '¬øEst√° activa?',
    type: 'switch',
    switchLabel: 'Activa',
    defaultValue: true,
  },
];

interface AreaFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSubmit: (
    data: CreateAreaDto | UpdateAreaDto,
    photoId: string | null | undefined,
  ) => Promise<void>;
  editingItem: Area | null;
  isSubmitting: boolean;
}

const AreaFormModal: React.FC<AreaFormModalProps> = ({
  visible,
  onDismiss,
  onSubmit,
  editingItem,
  isSubmitting,
}) => {
  const isEditing = !!editingItem;

  const formSchema = isEditing ? UpdateAreaSchema : CreateAreaSchema;
  const initialValues = isEditing
    ? {
        name: editingItem?.name,
        description: editingItem?.description ?? undefined,
        isActive: editingItem?.isActive,
      }
    : {
        name: '',
        description: undefined,
        isActive: true,
      };

  return (
    <GenericFormModal<CreateAreaDto | UpdateAreaDto, Area>
      visible={visible}
      onDismiss={onDismiss}
      onSubmit={onSubmit}
      formSchema={formSchema as z.ZodSchema<CreateAreaDto | UpdateAreaDto>}
      formFields={areaFormFields}
      initialValues={initialValues}
      editingItem={editingItem}
      isSubmitting={isSubmitting}
      modalTitle={(isEditing) =>
        isEditing ? 'Editar √Årea' : 'Crear Nueva √Årea'
      }
    />
  );
};

export default AreaFormModal;

================
File: app/src/modules/areasTables/components/TableFormModal.tsx
================
import React from 'react';
import GenericFormModal, {
  FormFieldConfig,
} from '../../../app/components/crud/GenericFormModal';
import {
  Table,
  CreateTableDto,
  UpdateTableDto,
  CreateTableSchema,
  UpdateTableSchema,
} from '../schema/table.schema';
import { z } from 'zod';

const tableFormFields: FormFieldConfig<CreateTableDto | UpdateTableDto>[] = [
  {
    name: 'name',
    label: 'Nombre de la Mesa',
    type: 'text',
    placeholder: 'Ej: Mesa 1, Barra 2',
    required: true,
  },
  {
    name: 'capacity',
    label: 'Capacidad (Opcional)',
    type: 'number',
    placeholder: 'Ej: 4',
    inputProps: { keyboardType: 'numeric' },
  },
  {
    name: 'isActive',
    label: '¬øEst√° activa?',
    type: 'switch',
    switchLabel: 'Activa',
    defaultValue: true,
  },
];

interface TableFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSubmit: (
    data: CreateTableDto | UpdateTableDto,
    photoId: string | null | undefined,
  ) => Promise<void>;
  editingItem: Table | null;
  isSubmitting: boolean;
}

const TableFormModal: React.FC<TableFormModalProps> = ({
  visible,
  onDismiss,
  onSubmit,
  editingItem,
  isSubmitting,
}) => {
  const isEditing = !!editingItem;

  const formSchema = isEditing ? UpdateTableSchema : CreateTableSchema;
  const initialValues = isEditing
    ? {
        name: editingItem?.name,
        capacity: editingItem?.capacity ?? undefined,
        isActive: editingItem?.isActive,
      }
    : {
        name: '',
        capacity: undefined,
        isActive: true,
      };

  return (
    <GenericFormModal<CreateTableDto | UpdateTableDto, Table>
      visible={visible}
      onDismiss={onDismiss}
      onSubmit={onSubmit}
      formSchema={formSchema as z.ZodSchema<CreateTableDto | UpdateTableDto>}
      formFields={tableFormFields}
      initialValues={initialValues}
      editingItem={editingItem}
      isSubmitting={isSubmitting}
      modalTitle={(isEditing) =>
        isEditing ? 'Editar Mesa' : 'Crear Nueva Mesa'
      }
    />
  );
};

export default TableFormModal;

================
File: app/src/modules/areasTables/navigation/AreasTablesStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { AreasTablesStackParamList } from './types';
import AreasScreen from '../screens/AreasScreen';
import TablesScreen from '../screens/TablesScreen';
import { useAppTheme } from '../../../app/styles/theme';
import { getStackHeaderOptions } from '../../../app/navigation/options';

const Stack = createNativeStackNavigator<AreasTablesStackParamList>();

const AreasTablesStackNavigator = () => {
  const theme = useAppTheme();

  return (
    <Stack.Navigator
      initialRouteName="AreasList"
      screenOptions={{
        ...getStackHeaderOptions(theme),
      }}
    >
      <Stack.Screen
        name="AreasList"
        component={AreasScreen}
        options={{
          title: '√Åreas',
        }}
      />
      <Stack.Screen
        name="TablesList"
        component={TablesScreen}
        options={({ route }) => ({
          title: `Mesas de ${route.params.areaName || '√Årea'}`,
        })}
      />
    </Stack.Navigator>
  );
};

export default AreasTablesStackNavigator;

================
File: app/src/modules/areasTables/navigation/types.ts
================
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import type { DrawerScreenProps } from '@react-navigation/drawer';
import { AppDrawerParamList } from '../../../app/navigation/types';

export type AreasTablesStackParamList = {
  AreasList: undefined;
  TablesList: { areaId: string; areaName: string };
};

export type AreasListScreenProps = NativeStackScreenProps<
  AreasTablesStackParamList,
  'AreasList'
>;
export type TablesListScreenProps = NativeStackScreenProps<
  AreasTablesStackParamList,
  'TablesList'
>;

export type AreasTablesDrawerScreenProps = DrawerScreenProps<
  AppDrawerParamList,
  'AreasTablesStack'
>;

================
File: app/src/modules/areasTables/schema/area.schema.ts
================
import { z } from 'zod';
// Importar el tipo central
import type { Area } from '../../../app/schemas/domain/area.schema';

// Schemas espec√≠ficos para DTOs (Create, Update, FindAll) permanecen aqu√≠
export const CreateAreaSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().optional(),
  isActive: z.boolean().optional().default(true),
});

export const UpdateAreaSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido').optional(),
  description: z.string().optional(),
  isActive: z.boolean().optional(),
});

export type CreateAreaDto = z.infer<typeof CreateAreaSchema>;
export type UpdateAreaDto = z.infer<typeof UpdateAreaSchema>;

export const FindAllAreasSchema = z.object({
  name: z.string().optional(),
  isActive: z.boolean().optional(),
});
export type FindAllAreasDto = z.infer<typeof FindAllAreasSchema>;

// Re-exportar el tipo de dominio si es conveniente para el m√≥dulo
export type { Area };

================
File: app/src/modules/areasTables/schema/table.schema.ts
================
import { z } from 'zod';
// Importar el tipo de dominio centralizado
import type { Table } from '../../../app/schemas/domain/table.schema';

// Schemas espec√≠ficos para DTOs (Create, Update, FindAll) permanecen aqu√≠
export const CreateTableSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  capacity: z.preprocess(
    (val) => (val === '' || val === null ? undefined : val),
    z.coerce
      .number()
      .int()
      .positive('La capacidad debe ser un n√∫mero positivo')
      .nullable()
      .optional(),
  ),
  isActive: z.boolean().optional().default(true),
  // areaId se a√±adir√° en el servicio al crear, no viene del formulario directamente
});

export const UpdateTableSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido').optional(),
  capacity: z.preprocess(
    (val) => (val === '' || val === null ? undefined : val),
    z.coerce
      .number()
      .int()
      .positive('La capacidad debe ser un n√∫mero positivo')
      .nullable()
      .optional(),
  ),
  isActive: z.boolean().optional(),
  // areaId no se suele actualizar, pero si fuera necesario, se a√±adir√≠a aqu√≠
});

export type CreateTableDto = z.infer<typeof CreateTableSchema>;
export type UpdateTableDto = z.infer<typeof UpdateTableSchema>;

const transformBoolean = (val: unknown) => {
  if (val === 'true') return true;
  if (val === 'false') return false;
  return val;
};

export const FindAllTablesSchema = z.object({
  name: z.string().optional(),
  areaId: z.string().uuid().optional(),
  capacity: z.coerce.number().int().optional(),
  isActive: z.preprocess(transformBoolean, z.boolean().optional()),
  isAvailable: z.preprocess(transformBoolean, z.boolean().optional()),
  isTemporary: z.preprocess(transformBoolean, z.boolean().optional()),
});
export type FindAllTablesDto = z.infer<typeof FindAllTablesSchema>;

// Re-exportar el tipo de dominio para conveniencia del m√≥dulo
export type { Table };

================
File: app/src/modules/areasTables/types/areasTables.types.ts
================
import type { Area } from '../schema/area.schema'; // Corregida ruta de importaci√≥n
import type { Table } from '../schema/table.schema'; // Corregida ruta de importaci√≥n

export type { Area, Table };

================
File: app/src/modules/auth/schema/auth.schema.ts
================
import { z } from 'zod';

// Schemas moved from auth.types.ts
export const loginSchema = z.object({
  emailOrUsername: z
    .string()
    .min(1, 'El correo o nombre de usuario es requerido'),
  password: z.string().min(6, 'La contrase√±a debe tener al menos 6 caracteres'),
});

export type LoginFormInputs = z.infer<typeof loginSchema>;

export const authResponseSchema = z.object({
  token: z.string(),
  user: z.object({
    id: z.string(),
    email: z.string().email(),
    username: z.string(),
    role: z.enum(['admin', 'staff']),
    firstName: z.string().optional(),
    lastName: z.string().optional(),
    avatar: z.string().url().optional(),
  }),
});

export type AuthResponse = z.infer<typeof authResponseSchema>;

export const authEmailLoginDtoSchema = z.object({
  email: z.string().email().optional(),
  username: z.string().optional(),
  password: z.string(),
});
export type AuthEmailLoginDto = z.infer<typeof authEmailLoginDtoSchema>;

export const userSchema = z.object({
  id: z.string().uuid('El ID de usuario debe ser un UUID v√°lido'), // Cambiado a string().uuid()
  email: z.string().email().nullable(),
  username: z.string().nullable(),
  firstName: z.string().nullable(),
  lastName: z.string().nullable(),
  role: z
    .object({
      id: z.number(),
      name: z.string(),
    })
    .optional(),
  isActive: z.boolean().optional(),
  preparationScreen: z
    .object({
      id: z.string(),
      name: z.string(),
      description: z.string().nullable(),
      isActive: z.boolean(),
    })
    .nullable()
    .optional(),
});
export type User = z.infer<typeof userSchema>;

export const loginResponseDtoSchema = z.object({
  token: z.string(),
  refreshToken: z.string(),
  tokenExpires: z.number(),
  user: userSchema,
});
export type LoginResponseDto = z.infer<typeof loginResponseDtoSchema>;

export const registerSchema = z.object({
  email: z.string().email('Correo electr√≥nico inv√°lido'),
  username: z
    .string()
    .min(3, 'El nombre de usuario debe tener al menos 3 caracteres')
    .regex(
      /^[a-zA-Z0-9_]+$/,
      'Solo se permiten letras, n√∫meros y guiones bajos',
    ),
  password: z.string().min(8, 'La contrase√±a debe tener al menos 8 caracteres'),
  firstName: z.string().min(1, 'El nombre es requerido'),
  lastName: z.string().min(1, 'El apellido es requerido'),
});

export type RegisterFormInputs = z.infer<typeof registerSchema>;

================
File: app/src/modules/auth/types/auth.types.ts
================
import type { AuthResponse, LoginFormInputs } from '../schema/auth.schema';

// Pure TypeScript interfaces/types remain here
export interface AuthState {
  token: string | null;
  user: AuthResponse['user'] | null;
  isLoading: boolean;
  error: string | null;
  login: (credentials: LoginFormInputs) => Promise<void>;
  logout: () => void;
  clearError: () => void;
}

export interface RegisterResponseDto {
  message: string;
}

// Zod schemas (loginSchema, authResponseSchema, etc.)
// are defined in ../schema/auth.schema.ts

================
File: app/src/modules/availability/hooks/useAvailabilityQueries.ts
================
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { availabilityService } from '../services/availabilityService';
import { useSnackbarStore } from '@/app/store/snackbarStore';

export const useMenuAvailability = () => {
  return useQuery({
    queryKey: ['availability', 'menu'],
    queryFn: availabilityService.getMenuAvailability,
  });
};

export const useModifierGroupsAvailability = () => {
  return useQuery({
    queryKey: ['availability', 'modifierGroups'],
    queryFn: availabilityService.getModifierGroupsAvailability,
  });
};

export const useUpdateAvailability = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: availabilityService.updateAvailability,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['availability'] });
      showSnackbar({ message: 'Disponibilidad actualizada', type: 'success' });
    },
    onError: () => {
      showSnackbar({
        message: 'Error al actualizar disponibilidad',
        type: 'error',
      });
    },
  });
};

export const useBulkUpdateAvailability = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: availabilityService.bulkUpdateAvailability,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['availability'] });
      showSnackbar({ message: 'Disponibilidad actualizada', type: 'success' });
    },
    onError: () => {
      showSnackbar({
        message: 'Error al actualizar disponibilidad',
        type: 'error',
      });
    },
  });
};

================
File: app/src/modules/availability/hooks/usePizzaCustomizationsAvailability.ts
================
import { useQuery } from '@tanstack/react-query';
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import { PizzaCustomizationGroupAvailability } from '../types/availability.types';

export function usePizzaCustomizationsAvailability(search?: string) {
  return useQuery({
    queryKey: ['availability', 'pizzaCustomizations', search],
    queryFn: async () => {
      const response = await apiClient.get<
        PizzaCustomizationGroupAvailability[]
      >(API_PATHS.AVAILABILITY_PIZZA_CUSTOMIZATIONS);

      if (!response.ok || !response.data) {
        throw new Error('Failed to fetch pizza customizations availability');
      }

      let data = response.data;

      if (search) {
        const searchLower = search.toLowerCase();
        data = data
          .map((group) => ({
            ...group,
            items: group.items.filter((item) =>
              item.name.toLowerCase().includes(searchLower),
            ),
          }))
          .filter((group) => group.items.length > 0);
      }

      return data;
    },
  });
}

================
File: app/src/modules/availability/navigation/AvailabilityStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { AvailabilityScreen } from '../screens/AvailabilityScreen';
import { AvailabilityStackParamList } from './types';
import { getStackHeaderOptions } from '@/app/navigation/options';
import { useAppTheme } from '@/app/styles/theme';

const Stack = createNativeStackNavigator<AvailabilityStackParamList>();

export const AvailabilityStackNavigator = () => {
  const theme = useAppTheme();

  return (
    <Stack.Navigator screenOptions={getStackHeaderOptions(theme)}>
      <Stack.Screen
        name="AvailabilityScreen"
        component={AvailabilityScreen}
        options={{ headerShown: false }}
      />
    </Stack.Navigator>
  );
};

================
File: app/src/modules/availability/navigation/types.ts
================
import { NativeStackScreenProps } from '@react-navigation/native-stack';

export type AvailabilityStackParamList = {
  AvailabilityScreen: undefined;
};

export type AvailabilityScreenProps = NativeStackScreenProps<
  AvailabilityStackParamList,
  'AvailabilityScreen'
>;

================
File: app/src/modules/availability/services/availabilityService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import {
  AvailabilityUpdatePayload,
  CategoryAvailability,
  ModifierGroupAvailability,
} from '../types/availability.types';

export const availabilityService = {
  // Obtener la disponibilidad del men√∫ completo
  async getMenuAvailability(): Promise<CategoryAvailability[]> {
    const response = await apiClient.get<CategoryAvailability[]>(
      API_PATHS.AVAILABILITY_MENU,
    );
    return response.data || [];
  },

  // Obtener la disponibilidad de grupos de modificadores
  async getModifierGroupsAvailability(): Promise<ModifierGroupAvailability[]> {
    const response = await apiClient.get<ModifierGroupAvailability[]>(
      API_PATHS.AVAILABILITY_MODIFIER_GROUPS,
    );
    return response.data || [];
  },

  // Actualizar disponibilidad (con opci√≥n de cascada)
  async updateAvailability(payload: AvailabilityUpdatePayload): Promise<void> {
    await apiClient.patch(API_PATHS.AVAILABILITY_UPDATE, payload);
  },

  // Actualizaci√≥n masiva de disponibilidad
  async bulkUpdateAvailability(
    updates: AvailabilityUpdatePayload[],
  ): Promise<void> {
    await apiClient.patch(API_PATHS.AVAILABILITY_BULK_UPDATE, { updates });
  },
};

================
File: app/src/modules/availability/types/availability.types.ts
================
export interface CategoryAvailability {
  id: string;
  name: string;
  isActive: boolean;
  subcategories: SubcategoryAvailability[];
}

export interface SubcategoryAvailability {
  id: string;
  name: string;
  isActive: boolean;
  categoryId: string;
  products: ProductAvailability[];
}

export interface ProductAvailability {
  id: string;
  name: string;
  isActive: boolean;
  subcategoryId: string;
  modifierGroups?: ModifierGroupAvailability[];
}

export interface ModifierGroupAvailability {
  id: string;
  name: string;
  isActive: boolean;
  modifiers: ModifierAvailability[];
}

export interface ModifierAvailability {
  id: string;
  name: string;
  isActive: boolean;
  modifierGroupId: string;
}

export interface PizzaCustomizationAvailability {
  id: string;
  name: string;
  type: 'FLAVOR' | 'INGREDIENT';
  isActive: boolean;
  sortOrder: number;
}

export interface PizzaCustomizationGroupAvailability {
  type: string;
  items: PizzaCustomizationAvailability[];
}

export interface AvailabilityUpdatePayload {
  type:
    | 'category'
    | 'subcategory'
    | 'product'
    | 'modifierGroup'
    | 'modifier'
    | 'pizzaCustomization';
  id: string;
  isActive: boolean;
  cascade?: boolean;
}

export interface AvailabilityFilter {
  search?: string;
  showOnlyUnavailable?: boolean;
  categoryId?: string;
  subcategoryId?: string;
}

================
File: app/src/modules/customers/navigation/CustomersStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import CustomersScreen from '../screens/CustomersScreen';

export type CustomersStackParamList = {
  Customers: undefined;
  CustomerDetail?: { customerId: string };
  CustomerAddresses?: { customerId: string };
  CustomerChatHistory?: { customerId: string };
};

const Stack = createNativeStackNavigator<CustomersStackParamList>();

export function CustomersStackNavigator() {
  return (
    <Stack.Navigator
      screenOptions={{
        headerShown: false,
      }}
    >
      <Stack.Screen
        name="Customers"
        component={CustomersScreen}
        options={{
          title: 'Clientes',
        }}
      />
      {/* Aqu√≠ se pueden agregar m√°s pantallas como:
          - CustomerDetail
          - CustomerAddresses
          - CustomerChatHistory
      */}
    </Stack.Navigator>
  );
}

================
File: app/src/modules/kitchen/components/KitchenFilterButton.tsx
================
import React, { useState } from 'react';
import {
  View,
  StyleSheet,
  Dimensions,
  TouchableOpacity,
  Animated,
  ScrollView,
} from 'react-native';
import { Portal, Modal, Surface, Text, Switch } from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { useKitchenStore } from '../store/kitchenStore';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';
import { OrderType } from '../types/kitchen.types';

const { width: screenWidth, height: screenHeight } = Dimensions.get('window');

export const KitchenFilterButton: React.FC = () => {
  const theme = useAppTheme();
  const [visible, setVisible] = useState(false);
  const { filters, setFilters } = useKitchenStore();
  const scaleAnim = React.useRef(new Animated.Value(1)).current;

  const activeFiltersCount = [
    filters.showPrepared,
    filters.showAllProducts,
    filters.ungroupProducts,
    filters.orderType !== undefined,
  ].filter(Boolean).length;

  const handleToggleFilter = (filterName: keyof typeof filters) => {
    setFilters({
      ...filters,
      [filterName]: !filters[filterName],
    });
  };

  const handlePressIn = () => {
    Animated.spring(scaleAnim, {
      toValue: 0.9,
      useNativeDriver: true,
    }).start();
  };

  const handlePressOut = () => {
    Animated.spring(scaleAnim, {
      toValue: 1,
      useNativeDriver: true,
    }).start();
  };

  return (
    <>
      <TouchableOpacity
        onPress={() => setVisible(true)}
        onPressIn={handlePressIn}
        onPressOut={handlePressOut}
        activeOpacity={0.8}
        style={styles.buttonContainer}
      >
        <Animated.View
          style={[
            styles.filterButton,
            {
              backgroundColor:
                activeFiltersCount > 0
                  ? theme.colors.primaryContainer
                  : 'rgba(255,255,255,0.2)',
              transform: [{ scale: scaleAnim }],
            },
          ]}
        >
          <Icon
            name="tune-variant"
            size={24}
            color={
              activeFiltersCount > 0
                ? theme.colors.onPrimaryContainer
                : theme.colors.onPrimary
            }
          />
          {activeFiltersCount > 0 && (
            <View
              style={[
                styles.badge,
                {
                  backgroundColor: theme.colors.error,
                },
              ]}
            >
              <Text style={[styles.badgeText, { color: theme.colors.onError }]}>
                {activeFiltersCount}
              </Text>
            </View>
          )}
        </Animated.View>
      </TouchableOpacity>

      <Portal>
        <Modal
          visible={visible}
          onDismiss={() => setVisible(false)}
          contentContainerStyle={[
            styles.modalContent,
            {
              backgroundColor: theme.colors.surface,
            },
          ]}
        >
          <ScrollView
            style={{
              maxHeight: screenHeight < 400 ? screenHeight - 80 : undefined,
            }}
            showsVerticalScrollIndicator={false}
          >
            <Surface
              style={[
                styles.modalSurface,
                { backgroundColor: theme.colors.surface },
              ]}
              elevation={3}
            >
              <View
                style={[
                  styles.modalHeader,
                  { backgroundColor: theme.colors.primaryContainer },
                ]}
              >
                <View style={styles.headerContent}>
                  <Icon
                    name="tune-variant"
                    size={24}
                    color={theme.colors.onPrimaryContainer}
                  />
                  <View style={styles.headerTextContainer}>
                    <Text
                      variant="titleMedium"
                      style={[
                        styles.modalTitle,
                        { color: theme.colors.onPrimaryContainer },
                      ]}
                    >
                      Filtros de visualizaci√≥n
                    </Text>
                  </View>
                </View>
                <TouchableOpacity
                  onPress={() => setVisible(false)}
                  style={styles.closeButton}
                >
                  <Icon
                    name="close"
                    size={22}
                    color={theme.colors.onPrimaryContainer}
                  />
                </TouchableOpacity>
              </View>

              <View style={styles.filtersList}>
                {/* Tipo de orden */}
                <View style={styles.sectionHeader}>
                  <Text
                    variant="titleMedium"
                    style={{ color: theme.colors.onSurface, fontWeight: '600' }}
                  >
                    Tipo de orden
                  </Text>
                </View>
                <View style={styles.orderTypeContainer}>
                  {[
                    { value: undefined, label: 'Todos', icon: 'check-all' },
                    {
                      value: OrderType.DINE_IN,
                      label: 'Mesa',
                      icon: 'table-chair',
                    },
                    {
                      value: OrderType.TAKE_AWAY,
                      label: 'Llevar',
                      icon: 'bag-checked',
                    },
                    {
                      value: OrderType.DELIVERY,
                      label: 'Domicilio',
                      icon: 'moped',
                    },
                  ].map((option) => {
                    const isSelected = filters.orderType === option.value;
                    return (
                      <TouchableOpacity
                        key={option.label}
                        style={[
                          styles.orderTypeButton,
                          isSelected && {
                            backgroundColor: theme.colors.primaryContainer,
                            borderColor: theme.colors.primary,
                          },
                          !isSelected && {
                            backgroundColor: theme.colors.surfaceVariant,
                            borderColor: 'transparent',
                          },
                        ]}
                        onPress={() =>
                          setFilters({ ...filters, orderType: option.value })
                        }
                        activeOpacity={0.8}
                      >
                        <Icon
                          name={option.icon}
                          size={20}
                          color={
                            isSelected
                              ? theme.colors.onPrimaryContainer
                              : theme.colors.onSurfaceVariant
                          }
                        />
                        <Text
                          variant="labelMedium"
                          style={{
                            color: isSelected
                              ? theme.colors.onPrimaryContainer
                              : theme.colors.onSurfaceVariant,
                            fontWeight: isSelected ? '700' : '500',
                            marginTop: 4,
                          }}
                        >
                          {option.label}
                        </Text>
                      </TouchableOpacity>
                    );
                  })}
                </View>

                <View
                  style={[
                    styles.divider,
                    { backgroundColor: theme.colors.outlineVariant },
                  ]}
                />

                {/* Otros filtros */}
                <View style={styles.sectionHeader}>
                  <Text
                    variant="titleMedium"
                    style={{ color: theme.colors.onSurface, fontWeight: '600' }}
                  >
                    Opciones de visualizaci√≥n
                  </Text>
                </View>
                <TouchableOpacity
                  onPress={() => handleToggleFilter('showPrepared')}
                  activeOpacity={0.7}
                >
                  <Surface
                    style={[
                      styles.filterItem,
                      filters.showPrepared && {
                        backgroundColor: theme.colors.primaryContainer,
                        borderColor: theme.colors.primary,
                      },
                    ]}
                    elevation={1}
                  >
                    <View style={styles.filterItemContent}>
                      <View
                        style={[
                          styles.iconContainer,
                          {
                            backgroundColor: filters.showPrepared
                              ? theme.colors.primary
                              : theme.colors.surfaceVariant,
                          },
                        ]}
                      >
                        <Icon
                          name="check-circle-outline"
                          size={22}
                          color={
                            filters.showPrepared
                              ? theme.colors.onPrimary
                              : theme.colors.onSurfaceVariant
                          }
                        />
                      </View>
                      <View style={styles.filterTextContent}>
                        <Text
                          variant="titleSmall"
                          style={{
                            color: theme.colors.onSurface,
                            fontWeight: '600',
                          }}
                        >
                          Mostrar listas
                        </Text>
                        <Text
                          variant="bodySmall"
                          style={{ color: theme.colors.onSurfaceVariant }}
                        >
                          Muestra solo las √≥rdenes listas
                        </Text>
                      </View>
                      <Switch
                        value={filters.showPrepared}
                        onValueChange={() => handleToggleFilter('showPrepared')}
                        color={theme.colors.primary}
                      />
                    </View>
                  </Surface>
                </TouchableOpacity>

                <TouchableOpacity
                  onPress={() => handleToggleFilter('showAllProducts')}
                  activeOpacity={0.7}
                >
                  <Surface
                    style={[
                      styles.filterItem,
                      filters.showAllProducts && {
                        backgroundColor: theme.colors.primaryContainer,
                        borderColor: theme.colors.primary,
                      },
                    ]}
                    elevation={1}
                  >
                    <View style={styles.filterItemContent}>
                      <View
                        style={[
                          styles.iconContainer,
                          {
                            backgroundColor: filters.showAllProducts
                              ? theme.colors.primary
                              : theme.colors.surfaceVariant,
                          },
                        ]}
                      >
                        <Icon
                          name="eye-outline"
                          size={22}
                          color={
                            filters.showAllProducts
                              ? theme.colors.onPrimary
                              : theme.colors.onSurfaceVariant
                          }
                        />
                      </View>
                      <View style={styles.filterTextContent}>
                        <Text
                          variant="titleSmall"
                          style={{
                            color: theme.colors.onSurface,
                            fontWeight: '600',
                          }}
                        >
                          Ver todos los productos
                        </Text>
                        <Text
                          variant="bodySmall"
                          style={{ color: theme.colors.onSurfaceVariant }}
                        >
                          Muestra productos de todas las √≥rdenes
                        </Text>
                      </View>
                      <Switch
                        value={filters.showAllProducts}
                        onValueChange={() =>
                          handleToggleFilter('showAllProducts')
                        }
                        color={theme.colors.primary}
                      />
                    </View>
                  </Surface>
                </TouchableOpacity>

                <TouchableOpacity
                  onPress={() => handleToggleFilter('ungroupProducts')}
                  activeOpacity={0.7}
                >
                  <Surface
                    style={[
                      styles.filterItem,
                      filters.ungroupProducts && {
                        backgroundColor: theme.colors.primaryContainer,
                        borderColor: theme.colors.primary,
                      },
                    ]}
                    elevation={1}
                  >
                    <View style={styles.filterItemContent}>
                      <View
                        style={[
                          styles.iconContainer,
                          {
                            backgroundColor: filters.ungroupProducts
                              ? theme.colors.primary
                              : theme.colors.surfaceVariant,
                          },
                        ]}
                      >
                        <Icon
                          name="ungroup"
                          size={22}
                          color={
                            filters.ungroupProducts
                              ? theme.colors.onPrimary
                              : theme.colors.onSurfaceVariant
                          }
                        />
                      </View>
                      <View style={styles.filterTextContent}>
                        <Text
                          variant="titleSmall"
                          style={{
                            color: theme.colors.onSurface,
                            fontWeight: '600',
                          }}
                        >
                          Desagrupar productos
                        </Text>
                        <Text
                          variant="bodySmall"
                          style={{ color: theme.colors.onSurfaceVariant }}
                        >
                          Muestra cada producto individualmente
                        </Text>
                      </View>
                      <Switch
                        value={filters.ungroupProducts}
                        onValueChange={() =>
                          handleToggleFilter('ungroupProducts')
                        }
                        color={theme.colors.primary}
                      />
                    </View>
                  </Surface>
                </TouchableOpacity>
              </View>
            </Surface>
          </ScrollView>
        </Modal>
      </Portal>
    </>
  );
};

const styles = StyleSheet.create({
  buttonContainer: {
    marginRight: 12,
  },
  filterButton: {
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
    elevation: 3,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
  },
  badge: {
    position: 'absolute',
    top: -4,
    right: -4,
    width: 20,
    height: 20,
    borderRadius: 10,
    justifyContent: 'center',
    alignItems: 'center',
    elevation: 4,
  },
  badgeText: {
    fontSize: 11,
    fontWeight: 'bold',
  },
  modalContent: {
    margin: screenHeight < 400 ? 10 : 20,
    maxWidth: screenHeight < 400 ? screenWidth - 40 : 380,
    maxHeight: screenHeight < 400 ? screenHeight - 60 : undefined,
    alignSelf: 'center',
    width: Math.min(screenWidth - (screenHeight < 400 ? 40 : 60), 380),
    borderRadius: 20,
    overflow: 'hidden',
  },
  modalSurface: {
    borderRadius: 20,
    overflow: 'hidden',
    maxHeight: screenHeight < 400 ? screenHeight - 60 : undefined,
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: screenHeight < 400 ? 12 : 16,
    paddingBottom: screenHeight < 400 ? 8 : 12,
    marginBottom: 4,
  },
  headerContent: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  headerTextContainer: {
    marginLeft: 10,
    flex: 1,
  },
  modalTitle: {
    fontWeight: '700',
  },
  closeButton: {
    width: 36,
    height: 36,
    borderRadius: 18,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 8,
  },
  filtersList: {
    padding: screenHeight < 400 ? 8 : 12,
    paddingTop: screenHeight < 400 ? 4 : 8,
    gap: screenHeight < 400 ? 6 : 10,
  },
  filterItem: {
    borderRadius: 12,
    borderWidth: 1,
    borderColor: 'transparent',
    overflow: 'hidden',
  },
  filterItemContent: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: screenHeight < 400 ? 8 : 12,
    gap: screenHeight < 400 ? 8 : 10,
  },
  iconContainer: {
    width: screenHeight < 400 ? 32 : 40,
    height: screenHeight < 400 ? 32 : 40,
    borderRadius: screenHeight < 400 ? 16 : 20,
    justifyContent: 'center',
    alignItems: 'center',
  },
  filterTextContent: {
    flex: 1,
    gap: 2,
  },
  sectionHeader: {
    marginBottom: screenHeight < 400 ? 8 : 12,
    paddingHorizontal: 4,
  },
  orderTypeContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 16,
    gap: 8,
  },
  orderTypeButton: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: screenHeight < 400 ? 8 : 12,
    paddingHorizontal: screenHeight < 400 ? 4 : 8,
    borderRadius: 12,
    borderWidth: 1.5,
  },
  divider: {
    height: 1,
    marginVertical: screenHeight < 400 ? 8 : 16,
    marginHorizontal: screenHeight < 400 ? -8 : -12,
  },
});

================
File: app/src/modules/kitchen/components/RefreshButton.tsx
================
import React, { useState } from 'react';
import { View, TouchableOpacity, Animated, StyleSheet } from 'react-native';
import { ActivityIndicator } from 'react-native-paper';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';
import { useKitchenContext } from '../context/KitchenContext';

export const RefreshButton: React.FC = () => {
  const { refetchRef } = useKitchenContext();
  const [isRefreshing, setIsRefreshing] = useState(false);
  const scaleAnim = new Animated.Value(1);

  const handleRefresh = async () => {
    if (refetchRef.current && !isRefreshing) {
      // Animaci√≥n de presi√≥n
      Animated.sequence([
        Animated.timing(scaleAnim, {
          toValue: 0.9,
          duration: 100,
          useNativeDriver: true,
        }),
        Animated.timing(scaleAnim, {
          toValue: 1,
          duration: 100,
          useNativeDriver: true,
        }),
      ]).start();

      setIsRefreshing(true);
      try {
        await refetchRef.current();
      } finally {
        setTimeout(() => setIsRefreshing(false), 500);
      }
    }
  };

  return (
    <Animated.View
      style={[styles.container, { transform: [{ scale: scaleAnim }] }]}
    >
      <TouchableOpacity
        style={[styles.button, isRefreshing && styles.buttonRefreshing]}
        onPress={handleRefresh}
        disabled={isRefreshing}
        activeOpacity={0.8}
      >
        <View style={styles.iconContainer}>
          {isRefreshing ? (
            <ActivityIndicator size={26} color="white" />
          ) : (
            <Icon name="refresh" size={26} color="white" />
          )}
        </View>
      </TouchableOpacity>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    marginHorizontal: 8,
  },
  button: {
    backgroundColor: 'rgba(255, 255, 255, 0.25)',
    borderRadius: 22,
    width: 44,
    height: 44,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1.5,
    borderColor: 'rgba(255, 255, 255, 0.4)',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  },
  buttonRefreshing: {
    backgroundColor: 'rgba(255, 255, 255, 0.15)',
    borderColor: 'rgba(255, 255, 255, 0.3)',
  },
  iconContainer: {
    width: 26,
    height: 26,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

================
File: app/src/modules/kitchen/context/KitchenContext.tsx
================
import React, {
  createContext,
  useContext,
  useRef,
  MutableRefObject,
} from 'react';

interface KitchenContextType {
  refetchRef: MutableRefObject<(() => void) | null>;
}

const KitchenContext = createContext<KitchenContextType | undefined>(undefined);

export const KitchenProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  const refetchRef = useRef<(() => void) | null>(null);

  return (
    <KitchenContext.Provider value={{ refetchRef }}>
      {children}
    </KitchenContext.Provider>
  );
};

export const useKitchenContext = () => {
  const context = useContext(KitchenContext);
  if (!context) {
    throw new Error('useKitchenContext must be used within a KitchenProvider');
  }
  return context;
};

================
File: app/src/modules/kitchen/navigation/KitchenNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import KitchenOrdersScreen from '../screens/KitchenOrdersScreen';

export type KitchenStackParamList = {
  KitchenOrders: undefined;
};

const Stack = createNativeStackNavigator<KitchenStackParamList>();

export default function KitchenNavigator() {
  return (
    <Stack.Navigator
      screenOptions={{
        headerShown: false,
      }}
    >
      <Stack.Screen name="KitchenOrders" component={KitchenOrdersScreen} />
    </Stack.Navigator>
  );
}

================
File: app/src/modules/menu/navigation/MenuStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { useAppTheme } from '../../../app/styles/theme';
import { getStackHeaderOptions } from '../../../app/navigation/options';
import type { MenuStackParamList } from './types.ts';

import CategoriesScreen from '../screens/CategoriesScreen';
import SubcategoriesScreen from '../screens/SubcategoriesScreen';
import ProductsScreen from '../screens/ProductsScreen';

const Stack = createNativeStackNavigator<MenuStackParamList>();

export const MenuStackNavigator: React.FC = () => {
  const theme = useAppTheme();

  return (
    <Stack.Navigator
      screenOptions={{
        ...getStackHeaderOptions(theme),
        headerShown: true,
      }}
    >
      <Stack.Screen
        name="CategoriesScreen"
        component={CategoriesScreen}
        options={{
          title: 'Categor√≠as',
        }}
      />
      <Stack.Screen
        name="SubcategoriesScreen"
        component={SubcategoriesScreen}
        options={({ route }) => ({
          title: route.params?.categoryName
            ? `Subcategor√≠as de ${route.params.categoryName}`
            : 'Subcategor√≠as',
        })}
      />
      <Stack.Screen
        name="Products"
        component={ProductsScreen}
        options={({ route }) => ({
          title: route.params?.subCategoryName
            ? `Productos de ${route.params.subCategoryName}`
            : 'Productos',
        })}
      />
    </Stack.Navigator>
  );
};

================
File: app/src/modules/menu/navigation/types.ts
================
export type MenuStackParamList = {
  CategoriesScreen: undefined;
  SubcategoriesScreen: { categoryId: string; categoryName: string };
  Products: { subcategoryId: string; subCategoryName: string };
};

================
File: app/src/modules/menu/schema/category.schema.ts
================
import { z } from 'zod';
import type { Category } from '../../../app/schemas/domain/category.schema';
import { type Photo } from '../../../app/schemas/domain/photo.schema'; // Eliminado photoSchema no usado

export const createCategoryDtoSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().nullable().optional(),
  isActive: z.boolean().optional().default(true),
  photoId: z.union([z.string().uuid(), z.null(), z.undefined()]).optional(),
  sortOrder: z.number().optional().default(0),
});

export const updateCategoryDtoSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido').optional(),
  description: z.string().optional().nullable(),
  isActive: z.boolean().optional(),
  photoId: z.union([z.string().uuid(), z.null(), z.undefined()]).optional(),
  sortOrder: z.number().optional(),
});

export const categoryFormSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().nullable().optional(),
  isActive: z.boolean(),
  sortOrder: z.number().optional().default(0),
  imageUri: z
    .union([
      z.string().url(),
      z.string().startsWith('file://'),
      z.string().startsWith('http://'),
      z.string().startsWith('https://'),
      z.null(),
    ])
    .optional(),
});

export type CreateCategoryDto = z.infer<typeof createCategoryDtoSchema>;
export type UpdateCategoryDto = z.infer<typeof updateCategoryDtoSchema>;
export type CategoryFormData = z.infer<typeof categoryFormSchema>;

export type { Category, Photo };

================
File: app/src/modules/menu/schema/subcategories.schema.ts
================
import { z } from 'zod';
import { baseListQuerySchema } from '../../../app/types/api.types';
import { type Photo } from '../../../app/schemas/domain/photo.schema'; // Eliminado photoSchema no usado
import type { SubCategory } from '../../../app/schemas/domain/subcategory.schema';

export const createSubCategoryDtoSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().optional().nullable(),
  isActive: z.boolean().optional().default(true),
  categoryId: z.string().min(1, 'Debe seleccionar una categor√≠a v√°lida'),
  photoId: z.union([z.string().uuid(), z.null(), z.undefined()]).optional(),
  imageUri: z
    .union([
      z.string().url(),
      z.string().startsWith('file://'),
      z.string().startsWith('http://'),
      z.string().startsWith('https://'),
      z.null(),
    ])
    .optional(),
  sortOrder: z.number().optional().default(0),
});
export type CreateSubCategoryDto = z.infer<typeof createSubCategoryDtoSchema>;

export const updateSubCategoryDtoSchema = createSubCategoryDtoSchema.partial();
export type UpdateSubCategoryDto = z.infer<typeof updateSubCategoryDtoSchema>;

export const findAllSubcategoriesDtoSchema = baseListQuerySchema.extend({
  categoryId: z.string().optional(),
  isActive: z.boolean().optional(),
});

export type SubCategoryFormInputs = CreateSubCategoryDto;
export type UpdateSubCategoryFormInputs = UpdateSubCategoryDto;

export type { Photo, SubCategory };

================
File: app/src/modules/menu/types/category.types.ts
================
// Tipos de dominio centralizados en src/app/types/domain/
// import type { Category, CategoryPhoto } from '../../../app/types/domain/category.types';

/**
 * Estructura gen√©rica para respuestas paginadas de la API.
 * TODO: Mover a un archivo de tipos comunes de API si se usa en m√°s m√≥dulos.
 */
export interface PaginatedResponse<T> {
  data: T[];
  meta: {
    total: number;
    page: number;
    limit: number;
    totalPages: number;
  };
}

export type ActiveFilter = 'all' | 'active' | 'inactive';

// Los tipos inferidos de Zod (CreateCategoryDto, UpdateCategoryDto, CategoryFormData)
// se definen y exportan directamente desde ../schema/category.schema.ts
// y se usan donde se necesiten los tipos espec√≠ficos del schema/formulario.

================
File: app/src/modules/menu/types/subcategories.types.ts
================
// Import base types if needed
import type { BaseListQueryDto } from '../../../app/types/api.types';

export type FindAllSubcategoriesDto = BaseListQueryDto & {
  categoryId?: string;
  isActive?: boolean;
};

================
File: app/src/modules/modifiers/navigation/ModifiersStackNavigator.tsx
================
import React from 'react';
import {
  createNativeStackNavigator,
  NativeStackNavigationOptions,
} from '@react-navigation/native-stack';
import { ModifiersStackParamList } from '@/app/navigation/types';
import ModifierGroupsScreen from '../screens/ModifierGroupsScreen';
import ModifiersScreen from '../screens/ModifiersScreen';
import { useAppTheme } from '@/app/styles/theme';
import { getStackHeaderOptions } from '@/app/navigation/options';

const Stack = createNativeStackNavigator<ModifiersStackParamList>();

const ModifiersStackNavigator = () => {
  const theme = useAppTheme();

  return (
    <Stack.Navigator
      screenOptions={{
        ...getStackHeaderOptions(theme),
      }}
    >
      <Stack.Screen
        name="ModifierGroupsScreen"
        component={ModifierGroupsScreen}
        options={(): NativeStackNavigationOptions => ({
          title: 'Grupos de Modificadores',
        })}
      />
      <Stack.Screen
        name="ModifiersScreen"
        component={ModifiersScreen}
        options={{ title: 'Modificadores' }}
      />
    </Stack.Navigator>
  );
};

export default ModifiersStackNavigator;

================
File: app/src/modules/modifiers/schema/modifier.schema.ts
================
import { z } from 'zod';
import { modifierSchema as domainModifierSchema } from '../../../app/schemas/domain/modifier.schema';
import type { Modifier } from '../../../app/schemas/domain/modifier.schema';

// Schema para DTO de creaci√≥n (definido manualmente, sin id)
export const createModifierSchema = z.object({
  modifierGroupId: z.string().min(1, 'El ID del grupo no es v√°lido'),
  name: z.string().min(1, 'El nombre es requerido').max(100),
  description: z.string().max(255).nullable().optional(),
  price: z.coerce.number().nullable().optional(),
  sortOrder: z.number().int().default(0),
  isDefault: z.boolean().default(false),
  isActive: z.boolean().default(true),
});
export type CreateModifierInput = z.infer<typeof createModifierSchema>;

// Schema para DTO de actualizaci√≥n (parcial, sin id ni modifierGroupId)
export const updateModifierSchema = z
  .object({
    name: z.string().min(1, 'El nombre es requerido').max(100),
    description: z.string().max(255).nullable().optional(),
    price: z.coerce.number().nullable().optional(),
    sortOrder: z.number().int().default(0),
    isDefault: z.boolean().default(false),
    isActive: z.boolean().default(true),
  })
  .partial();
export type UpdateModifierInput = z.infer<typeof updateModifierSchema>;

// Schema espec√≠fico para validaci√≥n del formulario (puede tener reglas diferentes a los DTOs)
export const modifierFormValidationSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido').max(100),
  description: z.string().max(255).nullable().optional(),
  // Usar z.preprocess para manejar strings vac√≠os o null antes de coercer a n√∫mero
  price: z.preprocess(
    (val) => (val === '' || val === null ? undefined : val),
    z.coerce.number().nullable().optional(),
  ),
  sortOrder: z.preprocess(
    (val) => (val === '' || val === null ? 0 : val),
    z.coerce.number().int().optional().default(0),
  ),
  isDefault: z.boolean().optional().default(false),
  isActive: z.boolean().optional().default(true),
});

// Schema para la respuesta de la API (extiende el schema de dominio)
export const modifierApiSchema = domainModifierSchema.extend({
  createdAt: z.string().datetime().optional(),
  updatedAt: z.string().datetime().optional(),
  deletedAt: z.string().datetime().nullable().optional(),
});

// Re-exportar el tipo de dominio centralizado
export type { Modifier };

================
File: app/src/modules/modifiers/schema/modifierGroup.schema.ts
================
import { z } from 'zod';
// Importar tipo de dominio centralizado
import { modifierGroupSchema as domainModifierGroupSchema } from '../../../app/schemas/domain/modifier-group.schema'; // Importar el schema Zod
import type { ModifierGroup } from '../../../app/schemas/domain/modifier-group.schema'; // Mantener importaci√≥n de tipo

// Schema base local para validaciones y transformaciones de DTO/Form
const modifierGroupBaseSchemaForForm = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().nullable().optional(),
  minSelections: z.number().int().min(0).optional(),
  maxSelections: z.number().int().min(1).optional(),
  isRequired: z.boolean().optional(),
  allowMultipleSelections: z.boolean().optional(),
  isActive: z.boolean().optional(),
  sortOrder: z.number().optional().default(0),
});

// Schema de validaci√≥n para el formulario (usa el schema base local)
export const modifierGroupFormValidationSchema =
  modifierGroupBaseSchemaForForm.superRefine((data, ctx) => {
    if (data.allowMultipleSelections) {
      if (data.maxSelections === undefined || data.maxSelections === null) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          path: ['maxSelections'],
          message:
            'M√°x. selecciones es requerido si se permiten m√∫ltiples selecciones.',
        });
      } else {
        if (data.maxSelections <= 1) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            path: ['maxSelections'],
            message:
              'M√°x. selecciones debe ser mayor que 1 si se permiten m√∫ltiples selecciones.',
          });
        }

        const min = data.minSelections ?? 0;
        if (data.maxSelections > 1 && min > data.maxSelections) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            path: ['minSelections'],
            message:
              'M√≠n. selecciones no puede ser mayor que M√°x. selecciones.',
          });
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            path: ['maxSelections'],
            message:
              'M√°x. selecciones no puede ser menor que M√≠n. selecciones.',
          });
        }
      }
    } else {
      // Si no se permiten m√∫ltiples selecciones, maxSelections debe ser 1
      // y minSelections debe ser 0 o 1 (dependiendo de isRequired)
      // Esta l√≥gica puede ajustarse seg√∫n las reglas de negocio exactas.
      // Por ahora, no a√±adimos validaci√≥n extra aqu√≠ si allowMultipleSelections es false.
    }
  });

// Tipo inferido para el formulario
export type ModifierGroupFormInputs = z.infer<
  typeof modifierGroupFormValidationSchema
>;

// Schema para DTO de creaci√≥n (usa el schema base local y transforma)
export const createModifierGroupSchema =
  modifierGroupBaseSchemaForForm.transform((data) => ({
    ...data,
    minSelections: data.minSelections ?? 0,
    isRequired: data.isRequired ?? false,
    allowMultipleSelections: data.allowMultipleSelections ?? false,
    isActive: data.isActive ?? true,
    sortOrder: data.sortOrder ?? 0,
    maxSelections: data.allowMultipleSelections ? (data.maxSelections ?? 1) : 1,
  }));
// Tipo inferido para DTO de creaci√≥n
export type CreateModifierGroupInput = z.infer<
  typeof createModifierGroupSchema
>;

// Schema para DTO de actualizaci√≥n (usa el schema base local y lo hace parcial)
export const updateModifierGroupSchema =
  modifierGroupBaseSchemaForForm.partial();
// Tipo inferido para DTO de actualizaci√≥n
export type UpdateModifierGroupInput = z.infer<
  typeof updateModifierGroupSchema
>;

// Schema para la respuesta de la API (extiende el schema de dominio)
export const modifierGroupApiSchema = domainModifierGroupSchema.extend({
  // A√±adir campos que vienen de la API pero no est√°n en el schema de dominio base
  id: z.string(), // ID puede ser custom format como "MODG-7"
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
  deletedAt: z.string().datetime().nullable().optional(),
  // Definir schemas placeholder o importar los reales si existen
  productModifiers: z.array(z.any()).optional(), // Usar z.any() o un schema espec√≠fico si existe
  products: z.array(z.any()).optional(), // Usar z.any() o un schema espec√≠fico si existe
});

// Re-exportar el tipo de dominio centralizado
export type { ModifierGroup };

// Mantener exportaciones anteriores si otros archivos dependen de ellas (revisar si es necesario)
export const modifierGroupSchema = modifierGroupFormValidationSchema; // Alias para compatibilidad?
export const modifierGroupBaseSchema = modifierGroupBaseSchemaForForm; // Alias para compatibilidad?

================
File: app/src/modules/modifiers/types/modifier.types.ts
================
// Pure TypeScript types remain here
export type ModifierFormInputs = {
  name: string;
  description?: string | null;
  price?: number | null;
  sortOrder?: number;
  isDefault?: boolean;
  isActive?: boolean;
};

// Zod schemas (Modifier, CreateModifierInput, UpdateModifierInput, etc.)
// are defined in ../schema/modifier.schema.ts

================
File: app/src/modules/orderFinalization/navigation/OrderFinalizationStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { OrderFinalizationScreen } from '../screens/OrderFinalizationScreen';
import { OrderFinalizationStackParamList } from './types';
import { defaultScreenOptions } from '@/app/navigation/options';

const Stack = createNativeStackNavigator<OrderFinalizationStackParamList>();

export const OrderFinalizationStackNavigator = () => {
  return (
    <Stack.Navigator screenOptions={defaultScreenOptions}>
      <Stack.Screen
        name="OrderFinalizationScreen"
        component={OrderFinalizationScreen}
        options={{ headerShown: false }}
      />
    </Stack.Navigator>
  );
};

================
File: app/src/modules/orderFinalization/navigation/types.ts
================
export type OrderFinalizationStackParamList = {
  OrderFinalizationScreen: undefined;
};

================
File: app/src/modules/orders/components/MenuItemCard.tsx
================
import React, { useMemo } from 'react';
import { StyleSheet, View } from 'react-native';
import { Card, Title, Text, IconButton } from 'react-native-paper';
import { AutoImage } from '@/app/components/common/AutoImage';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import type { Product, Category, SubCategory } from '../types/orders.types';

interface MenuItemCardProps {
  item: Category | SubCategory | Product;
  onPress: () => void;
  onLongPress?: () => void;
  onInfoPress?: () => void;
  navigationLevel: 'categories' | 'subcategories' | 'products';
  disabled?: boolean;
  showPrice?: boolean;
}

const MenuItemCard = React.memo<MenuItemCardProps>(
  ({
    item,
    onPress,
    onLongPress,
    onInfoPress,
    navigationLevel,
    disabled = false,
    showPrice = true,
  }) => {
    const theme = useAppTheme();
    const { colors, fonts } = theme;
    const responsive = useResponsive();

    const blurhash =
      '|rF?hV%2WCj[ayj[a|j[az_NaeWBj@ayfRayfQfQM{M|azj[azf6fQfQfQIpWXofj[ayj[j[fQayWCoeoeaya}j[ayfQa{oLj?j[WVj[ayayj[fQoff7azayj[ayj[j[ayofayayayj[fQj[ayayj[ayfjj[j[ayjuayj[';

    const styles = useMemo(
      () =>
        StyleSheet.create({
          cardItem: {
            flex: 1,
            minWidth: 120, // Ancho m√≠nimo para evitar cards muy peque√±os
            overflow: 'hidden',
            borderRadius: theme.roundness,
            elevation: 2,
          },
          cardItemInactive: {
            opacity: 0.5,
          },
          itemImage: {
            width: '100%',
            height: responsive.getResponsiveDimension(120, 160),
          },
          imageInactive: {
            opacity: 0.6,
          },
          cardContent: {
            paddingHorizontal: responsive.spacing.s,
            paddingVertical: responsive.spacing.xs,
          },
          cardTitle: {
            fontSize: responsive.fontSize.m,
            fontWeight: '600',
            lineHeight: responsive.fontSize.m * 1.2,
            marginBottom: responsive.spacing.xs,
          },
          cardHeader: {
            flexDirection: 'row',
            justifyContent: 'space-between',
            alignItems: 'flex-start',
          },
          infoButton: {
            margin: -4,
            marginTop: -6,
            marginRight: -6,
          },
          priceText: {
            color: theme.colors.primary,
            fontWeight: '600',
            fontSize: responsive.fontSize.s,
            marginTop: 2,
          },
          inactiveBadge: {
            position: 'absolute',
            top: 8,
            right: 8,
            backgroundColor: colors.errorContainer,
            paddingHorizontal: 8,
            paddingVertical: 4,
            borderRadius: 4,
          },
          inactiveBadgeText: {
            fontSize: 12,
            color: colors.onErrorContainer,
            fontWeight: '600',
          },
          warningMessage: {
            backgroundColor: colors.warningContainer || colors.errorContainer,
            paddingHorizontal: responsive.spacing.s,
            paddingVertical: responsive.spacing.xs,
            marginTop: responsive.spacing.xs,
          },
          warningMessageText: {
            fontSize: responsive.fontSize.xs,
            color: colors.onWarningContainer || colors.onErrorContainer,
            textAlign: 'center',
            lineHeight: responsive.fontSize.xs * 1.3,
          },
        }),
      [colors, fonts, theme, responsive],
    );

    // Determinar si el item est√° activo
    const isActive = item.isActive !== false;

    // Verificar si es un producto sin pantalla de preparaci√≥n
    const isProductWithoutScreen =
      navigationLevel === 'products' &&
      'preparationScreenId' in item &&
      !item.preparationScreenId;

    // Determinar si el card est√° deshabilitado
    const isDisabled = disabled || !isActive || isProductWithoutScreen;

    // Obtener la URL de la imagen
    const imageSource = item.photo ? item.photo.path : null;

    // Determinar si mostrar el precio
    const shouldShowPrice = () => {
      if (!showPrice) return false;
      if (
        navigationLevel === 'products' &&
        'price' in item &&
        'hasVariants' in item
      ) {
        const productItem = item as Product;
        return (
          !productItem.hasVariants &&
          productItem.price !== null &&
          productItem.price !== undefined
        );
      }
      return false;
    };

    // Determinar si mostrar el bot√≥n de informaci√≥n
    const shouldShowInfoButton = () => {
      return (
        navigationLevel === 'products' &&
        'price' in item &&
        'description' in item &&
        (item as Product).description &&
        (item as Product).description.trim() !== '' &&
        onInfoPress
      );
    };

    // Obtener el texto del badge
    const getBadgeText = () => {
      if (!isActive) return 'INACTIVO';
      if (isProductWithoutScreen) return 'NO DISPONIBLE';
      return null;
    };

    const badgeText = getBadgeText();

    return (
      <Card
        style={[styles.cardItem, isDisabled && styles.cardItemInactive]}
        onPress={isDisabled ? undefined : onPress}
        onLongPress={isDisabled ? undefined : onLongPress}
        disabled={isDisabled}
      >
        <AutoImage
          source={imageSource}
          style={[styles.itemImage, isDisabled && styles.imageInactive]}
          contentFit="cover"
          placeholder={blurhash}
          transition={300}
          placeholderIcon="image-outline"
        />

        {badgeText && (
          <View style={styles.inactiveBadge}>
            <Text style={styles.inactiveBadgeText}>{badgeText}</Text>
          </View>
        )}

        <View style={styles.cardContent}>
          {shouldShowInfoButton() ? (
            <View style={styles.cardHeader}>
              <Title style={[styles.cardTitle, { flex: 1 }]}>{item.name}</Title>
              <IconButton
                icon="information-outline"
                size={20}
                onPress={onInfoPress}
                style={styles.infoButton}
              />
            </View>
          ) : (
            <Title style={styles.cardTitle}>{item.name}</Title>
          )}

          {shouldShowPrice() && (
            <Text style={styles.priceText}>
              ${Number((item as Product).price).toFixed(2)}
            </Text>
          )}

          {isProductWithoutScreen && (
            <View style={styles.warningMessage}>
              <Text style={styles.warningMessageText}>
                Sin pantalla de preparaci√≥n
              </Text>
            </View>
          )}
        </View>
      </Card>
    );
  },
);

MenuItemCard.displayName = 'MenuItemCard';

export default MenuItemCard;

================
File: app/src/modules/orders/components/OrderHeader.tsx
================
import React from 'react';
import { StyleSheet, View } from 'react-native';
import { Text, IconButton } from 'react-native-paper';
import CartButton from './CartButton';
import { useAppTheme } from '@/app/styles/theme';

interface OrderHeaderProps {
  title: string;
  itemCount: number;
  onBackPress?: () => void;
  onCartPress: () => void;
  isCartVisible: boolean;
}

const OrderHeader = ({
  title,
  itemCount,
  onBackPress,
  onCartPress,
  isCartVisible,
}: OrderHeaderProps) => {
  const theme = useAppTheme();

  const styles = StyleSheet.create({
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: 4,
      paddingVertical: 8,
      backgroundColor: theme.colors.elevation.level2,
      elevation: 0,
      shadowOpacity: 0,
    },
    headerTitle: {
      ...theme.fonts.titleMedium,
      color: theme.colors.onSurface,
      fontWeight: 'bold',
      textAlign: 'center',
      flex: 1,
    },
    headerSpacer: {
      width: 48,
    },
  });

  return (
    <View style={styles.header}>
      {onBackPress ? (
        <IconButton
          icon="arrow-left"
          size={24}
          onPress={onBackPress}
          iconColor={theme.colors.onSurface}
        />
      ) : (
        <View style={styles.headerSpacer} />
      )}

      <Text style={styles.headerTitle}>{title}</Text>

      {!isCartVisible ? (
        <CartButton itemCount={itemCount} onPress={onCartPress} />
      ) : (
        <View style={styles.headerSpacer} />
      )}
    </View>
  );
};

export default OrderHeader;

================
File: app/src/modules/orders/components/SimpleProductDescriptionModal.tsx
================
import React from 'react';
import { StyleSheet, ScrollView } from 'react-native';
import { Portal, Modal, Text, Title } from 'react-native-paper';
import type { Product } from '@/app/schemas/domain/product.schema';
import { useAppTheme } from '@/app/styles/theme';

interface SimpleProductDescriptionModalProps {
  visible: boolean;
  product: Product | null;
  onDismiss: () => void;
}

const SimpleProductDescriptionModal: React.FC<
  SimpleProductDescriptionModalProps
> = ({ visible, product, onDismiss }) => {
  const theme = useAppTheme();

  const styles = StyleSheet.create({
    modal: {
      backgroundColor: theme.colors.background,
      margin: 20,
      padding: 20,
      borderRadius: 8,
      maxHeight: '60%',
    },
    title: {
      fontSize: 20,
      fontWeight: 'bold',
      marginBottom: 16,
      color: theme.colors.onBackground,
    },
    description: {
      fontSize: 16,
      lineHeight: 24,
      color: theme.colors.onSurfaceVariant,
    },
  });

  if (!product || !product.description) return null;

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modal}
      >
        <ScrollView>
          <Title style={styles.title}>{product.name}</Title>
          <Text style={styles.description}>{product.description}</Text>
        </ScrollView>
      </Modal>
    </Portal>
  );
};

export default SimpleProductDescriptionModal;

================
File: app/src/modules/orders/hooks/useAdjustmentQueries.ts
================
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { adjustmentService } from '../services/adjustmentService';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import type { OrderAdjustmentDto } from '../types/update-order.types';

export const useCreateBulkAdjustmentsMutation = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: (adjustments: OrderAdjustmentDto[]) =>
      adjustmentService.createBulkAdjustments(adjustments),
    onSuccess: (data, variables) => {
      // Invalidar queries relacionadas
      if (variables.length > 0 && variables[0].orderId) {
        queryClient.invalidateQueries({
          queryKey: ['orders', variables[0].orderId],
        });
        queryClient.invalidateQueries({
          queryKey: ['adjustments', 'order', variables[0].orderId],
        });
      }
      showSnackbar({
        message: 'Ajustes aplicados correctamente',
        type: 'success',
      });
    },
    onError: (error: Error) => {
      showSnackbar({
        message: error.message || 'Error al aplicar ajustes',
        type: 'error',
      });
    },
  });
};

export const useOrderAdjustmentsQuery = (orderId: string, enabled = true) => {
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useQuery({
    queryKey: ['adjustments', 'order', orderId],
    queryFn: () => adjustmentService.getOrderAdjustments(orderId),
    enabled: enabled && !!orderId,
    onError: (error: Error) => {
      showSnackbar({
        message: error.message || 'Error al cargar ajustes',
        type: 'error',
      });
    },
  });
};

export const useDeleteAdjustmentMutation = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: (adjustmentId: string) =>
      adjustmentService.deleteAdjustment(adjustmentId),
    onSuccess: () => {
      // Invalidar todas las queries de ajustes
      queryClient.invalidateQueries({ queryKey: ['adjustments'] });
      queryClient.invalidateQueries({ queryKey: ['orders'] });
      showSnackbar({
        message: 'Ajuste eliminado correctamente',
        type: 'success',
      });
    },
    onError: (error: Error) => {
      showSnackbar({
        message: error.message || 'Error al eliminar ajuste',
        type: 'error',
      });
    },
  });
};

================
File: app/src/modules/orders/hooks/usePaymentQueries.ts
================
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { paymentService } from '../services/paymentService';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import type {
  CreatePaymentDto,
  UpdatePaymentDto,
  PaymentMethod,
  PaymentStatus,
} from '../types/payment.types';

// Query Keys
export const paymentKeys = {
  all: ['payments'] as const,
  lists: () => [...paymentKeys.all, 'list'] as const,
  list: (filters?: {
    orderId?: string;
    paymentMethod?: PaymentMethod;
    paymentStatus?: PaymentStatus;
  }) => [...paymentKeys.lists(), filters] as const,
  details: () => [...paymentKeys.all, 'detail'] as const,
  detail: (id: string) => [...paymentKeys.details(), id] as const,
  byOrder: (orderId: string) => [...paymentKeys.all, 'order', orderId] as const,
};

// Queries
export const useGetPaymentsQuery = (filters?: {
  orderId?: string;
  paymentMethod?: PaymentMethod;
  paymentStatus?: PaymentStatus;
}) => {
  return useQuery({
    queryKey: paymentKeys.list(filters),
    queryFn: () => paymentService.getPayments(filters),
  });
};

export const useGetPaymentByIdQuery = (id: string) => {
  return useQuery({
    queryKey: paymentKeys.detail(id),
    queryFn: () => paymentService.getPaymentById(id),
    enabled: !!id,
  });
};

export const useGetPaymentsByOrderIdQuery = (
  orderId: string,
  options?: { enabled?: boolean },
) => {
  return useQuery({
    queryKey: paymentKeys.byOrder(orderId),
    queryFn: () => paymentService.getPaymentsByOrderId(orderId),
    enabled: options?.enabled !== undefined ? options.enabled : !!orderId,
    initialData: [],
  });
};

// Mutations
export const useCreatePaymentMutation = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: (dto: CreatePaymentDto) => paymentService.createPayment(dto),
    onSuccess: (data) => {
      // Invalidar queries relacionadas
      queryClient.invalidateQueries({ queryKey: paymentKeys.lists() });
      queryClient.invalidateQueries({
        queryKey: paymentKeys.byOrder(data.orderId),
      });
      // Invalidar tambi√©n las queries de √≥rdenes para que se actualice el estado de pago
      queryClient.invalidateQueries({ queryKey: ['orders'] });

      showSnackbar({
        message: 'Pago registrado exitosamente',
        type: 'success',
      });
    },
    onError: (error: any) => {
      showSnackbar({
        message: error.response?.data?.message || 'Error al registrar el pago',
        type: 'error',
      });
    },
  });
};

export const useUpdatePaymentMutation = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: ({ id, dto }: { id: string; dto: UpdatePaymentDto }) =>
      paymentService.updatePayment(id, dto),
    onSuccess: (data) => {
      // Invalidar queries relacionadas
      queryClient.invalidateQueries({ queryKey: paymentKeys.lists() });
      queryClient.invalidateQueries({ queryKey: paymentKeys.detail(data.id) });
      queryClient.invalidateQueries({
        queryKey: paymentKeys.byOrder(data.orderId),
      });
      // Invalidar tambi√©n las queries de √≥rdenes para que se actualice el estado de pago
      queryClient.invalidateQueries({ queryKey: ['orders'] });

      showSnackbar({
        message: 'Pago actualizado exitosamente',
        type: 'success',
      });
    },
    onError: (error: any) => {
      showSnackbar({
        message: error.response?.data?.message || 'Error al actualizar el pago',
        type: 'error',
      });
    },
  });
};

export const useDeletePaymentMutation = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: (id: string) => paymentService.deletePayment(id),
    onSuccess: () => {
      // Invalidar todas las queries de pagos
      queryClient.invalidateQueries({ queryKey: paymentKeys.all });
      // Invalidar tambi√©n las queries de √≥rdenes para que se actualice el estado de pago
      queryClient.invalidateQueries({ queryKey: ['orders'] });

      showSnackbar({
        message: 'Pago eliminado exitosamente',
        type: 'success',
      });
    },
    onError: (error: any) => {
      showSnackbar({
        message: error.response?.data?.message || 'Error al eliminar el pago',
        type: 'error',
      });
    },
  });
};

================
File: app/src/modules/orders/stores/useCartStore.ts
================
import { create } from 'zustand';
import type { Product } from '../types/orders.types';
import type { SelectedPizzaCustomization } from '../../../app/schemas/domain/order.schema';
import { useOrderFormStore } from './useOrderFormStore';

const generateId = () => {
  const timestamp = Date.now().toString();
  const random1 = Math.floor(Math.random() * 1000000).toString();
  const random2 = Math.floor(Math.random() * 1000000).toString();
  return `${timestamp}-${random1}-${random2}`;
};

export interface CartItemModifier {
  id: string;
  modifierGroupId: string;
  name: string;
  price: number;
}

export interface CartItem {
  id: string;
  productId: string;
  productName: string;
  quantity: number;
  unitPrice: number;
  totalPrice: number;
  modifiers: CartItemModifier[];
  variantId?: string;
  variantName?: string;
  preparationNotes?: string;
  notes?: string;
  preparationStatus?:
    | 'NEW'
    | 'PENDING'
    | 'IN_PROGRESS'
    | 'READY'
    | 'DELIVERED'
    | 'CANCELLED';
  selectedPizzaCustomizations?: SelectedPizzaCustomization[];
  pizzaExtraCost?: number;
}

interface CartStore {
  items: CartItem[];
  isCartVisible: boolean;
  
  // Actions
  addItem: (
    product: Product,
    quantity?: number,
    variantId?: string,
    modifiers?: CartItemModifier[],
    preparationNotes?: string,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost?: number,
  ) => void;
  removeItem: (itemId: string) => void;
  updateItemQuantity: (itemId: string, quantity: number) => void;
  updateItem: (
    itemId: string,
    quantity: number,
    modifiers: CartItemModifier[],
    preparationNotes?: string,
    variantId?: string,
    variantName?: string,
    unitPrice?: number,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost?: number,
  ) => void;
  clearCart: () => void;
  setItems: (items: CartItem[]) => void;
  showCart: () => void;
  hideCart: () => void;
}

// Selectores para valores computados
export const useCartSubtotal = () => useCartStore((state) => 
  state.items.reduce((sum, item) => sum + item.totalPrice, 0)
);

export const useCartTotal = () => useCartSubtotal();

export const useCartItemsCount = () => useCartStore((state) => 
  state.items.reduce((sum, item) => sum + item.quantity, 0)
);

export const useIsCartEmpty = () => useCartStore((state) => state.items.length === 0);

// Funci√≥n para limpiar tanto el cart como el formulario
export const useClearAll = () => {
  const clearCart = useCartStore((state) => state.clearCart);
  const clearForm = useOrderFormStore((state) => state.clearForm);
  
  return () => {
    clearCart();
    clearForm();
  };
};

export const useCartStore = create<CartStore>((set, get) => ({
  items: [],
  isCartVisible: false,
  
  // Actions
  addItem: (
    product: Product,
    quantity: number = 1,
    variantId?: string,
    modifiers: CartItemModifier[] = [],
    preparationNotes?: string,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost: number = 0,
  ) => {
    const { items } = get();
    
    const variantToAdd = variantId
      ? product.variants?.find((v) => v.id === variantId)
      : undefined;

    // Validar y sanitizar precios
    const safeParsePrice = (price: any): number => {
      const parsed = Number(price);
      if (isNaN(parsed) || !isFinite(parsed) || parsed < 0) {
        return 0;
      }
      return Math.min(Math.round(parsed * 100) / 100, 999999.99);
    };

    const unitPrice = variantToAdd
      ? safeParsePrice(variantToAdd.price)
      : safeParsePrice(product.price);

    const modifiersPrice = modifiers.reduce(
      (sum, mod) => sum + safeParsePrice(mod.price || 0),
      0,
    );

    // Buscar si existe un item id√©ntico
    const existingItemIndex = items.findIndex((item) => {
      if (item.productId !== product.id) return false;
      if (item.variantId !== variantId) return false;
      if (item.preparationNotes !== preparationNotes) return false;
      if (item.modifiers.length !== modifiers.length) return false;

      // Comparar modifiers
      const sortedExistingModifiers = [...item.modifiers].sort((a, b) =>
        a.id.localeCompare(b.id),
      );
      const sortedNewModifiers = [...modifiers].sort((a, b) =>
        a.id.localeCompare(b.id),
      );

      for (let i = 0; i < sortedExistingModifiers.length; i++) {
        if (
          sortedExistingModifiers[i].id !== sortedNewModifiers[i].id ||
          sortedExistingModifiers[i].name !== sortedNewModifiers[i].name ||
          sortedExistingModifiers[i].price !== sortedNewModifiers[i].price
        ) {
          return false;
        }
      }

      // Comparar pizza customizations
      const existingCustomizations = item.selectedPizzaCustomizations || [];
      const newCustomizations = selectedPizzaCustomizations || [];

      if (existingCustomizations.length !== newCustomizations.length)
        return false;

      const sortedExistingCustomizations = [...existingCustomizations].sort(
        (a, b) =>
          `${a.pizzaCustomizationId}-${a.half}-${a.action}`.localeCompare(
            `${b.pizzaCustomizationId}-${b.half}-${b.action}`,
          ),
      );
      const sortedNewCustomizations = [...newCustomizations].sort((a, b) =>
        `${a.pizzaCustomizationId}-${a.half}-${a.action}`.localeCompare(
          `${b.pizzaCustomizationId}-${b.half}-${b.action}`,
        ),
      );

      for (let i = 0; i < sortedExistingCustomizations.length; i++) {
        if (
          sortedExistingCustomizations[i].pizzaCustomizationId !==
            sortedNewCustomizations[i].pizzaCustomizationId ||
          sortedExistingCustomizations[i].half !==
            sortedNewCustomizations[i].half ||
          sortedExistingCustomizations[i].action !==
            sortedNewCustomizations[i].action
        ) {
          return false;
        }
      }

      return true;
    });

    if (existingItemIndex !== -1) {
      // Si existe un item id√©ntico, actualizar la cantidad
      const updatedItems = [...items];
      const existingItem = updatedItems[existingItemIndex];
      const newQuantity = existingItem.quantity + quantity;
      const newTotalPrice =
        (existingItem.unitPrice + modifiersPrice + pizzaExtraCost) *
        newQuantity;

      updatedItems[existingItemIndex] = {
        ...existingItem,
        quantity: newQuantity,
        totalPrice: newTotalPrice,
        pizzaExtraCost,
      };

      set({ items: updatedItems });
    } else {
      // Si no existe, crear un nuevo item
      const newItem: CartItem = {
        id: generateId(),
        productId: product.id,
        productName: product.name,
        quantity,
        unitPrice: unitPrice as number,
        totalPrice:
          ((unitPrice as number) + modifiersPrice + pizzaExtraCost) *
          quantity,
        modifiers,
        variantId,
        variantName: variantToAdd?.name,
        preparationNotes,
        selectedPizzaCustomizations,
        pizzaExtraCost,
      };

      set({ items: [...items, newItem] });
    }
  },

  removeItem: (itemId: string) => {
    const { items } = get();
    set({ items: items.filter((item) => item.id !== itemId) });
  },

  updateItemQuantity: (itemId: string, quantity: number) => {
    const { items, removeItem } = get();
    
    // Validar y sanitizar cantidad
    const safeQuantity = Math.round(quantity);

    if (safeQuantity <= 0 || isNaN(safeQuantity)) {
      removeItem(itemId);
      return;
    }

    // L√≠mite m√°ximo razonable
    const MAX_QUANTITY = 9999;
    const finalQuantity = Math.min(safeQuantity, MAX_QUANTITY);

    const updatedItems = items.map((item) => {
      if (item.id === itemId) {
        const modifiersPrice = item.modifiers.reduce(
          (sum, mod) => sum + Number(mod.price || 0),
          0,
        );
        const pizzaExtraCost = item.pizzaExtraCost || 0;
        const newTotalPrice =
          (item.unitPrice + modifiersPrice + pizzaExtraCost) *
          finalQuantity;
        return {
          ...item,
          quantity: finalQuantity,
          totalPrice: newTotalPrice,
        };
      }
      return item;
    });

    set({ items: updatedItems });
  },

  updateItem: (
    itemId: string,
    quantity: number,
    modifiers: CartItemModifier[],
    preparationNotes?: string,
    variantId?: string,
    variantName?: string,
    unitPrice?: number,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost: number = 0,
  ) => {
    const { items } = get();
    
    const updatedItems = items.map((item) => {
      if (item.id === itemId) {
        const modifiersPrice = modifiers.reduce(
          (sum, mod) => sum + Number(mod.price || 0),
          0,
        );
        const finalUnitPrice =
          unitPrice !== undefined ? unitPrice : item.unitPrice;
        const newTotalPrice =
          (finalUnitPrice + modifiersPrice + pizzaExtraCost) * quantity;
        return {
          ...item,
          quantity,
          modifiers,
          preparationNotes:
            preparationNotes !== undefined
              ? preparationNotes
              : item.preparationNotes,
          variantId: variantId !== undefined ? variantId : item.variantId,
          variantName:
            variantName !== undefined ? variantName : item.variantName,
          unitPrice: finalUnitPrice,
          totalPrice: newTotalPrice,
          selectedPizzaCustomizations:
            selectedPizzaCustomizations !== undefined
              ? selectedPizzaCustomizations
              : item.selectedPizzaCustomizations,
          pizzaExtraCost,
        };
      }
      return item;
    });

    set({ items: updatedItems });
  },

  clearCart: () => {
    set({ items: [] });
  },

  setItems: (items: CartItem[]) => {
    set({ items });
  },

  showCart: () => {
    set({ isCartVisible: true });
  },

  hideCart: () => {
    set({ isCartVisible: false });
  },
}));

================
File: app/src/modules/orders/stores/useOrderFormStore.ts
================
import { create } from 'zustand';
import { OrderTypeEnum, type OrderType } from '../types/orders.types';
import type { DeliveryInfo } from '../../../app/schemas/domain/delivery-info.schema';

interface OrderFormStore {
  // Estado del formulario de la orden
  orderType: OrderType;
  selectedAreaId: string | null;
  selectedTableId: string | null;
  isTemporaryTable: boolean;
  temporaryTableName: string;
  scheduledTime: Date | null;
  deliveryInfo: DeliveryInfo;
  orderNotes: string;

  // Estado del prepago
  prepaymentId: string | null;
  prepaymentAmount: string;
  prepaymentMethod: 'CASH' | 'CARD' | 'TRANSFER' | null;

  // Actions
  setOrderType: (type: OrderType) => void;
  setSelectedAreaId: (id: string | null) => void;
  setSelectedTableId: (id: string | null) => void;
  setIsTemporaryTable: (isTemp: boolean) => void;
  setTemporaryTableName: (name: string) => void;
  setScheduledTime: (time: Date | null) => void;
  setDeliveryInfo: (info: DeliveryInfo) => void;
  setOrderNotes: (notes: string) => void;
  setPrepaymentId: (id: string | null) => void;
  setPrepaymentAmount: (amount: string) => void;
  setPrepaymentMethod: (method: 'CASH' | 'CARD' | 'TRANSFER' | null) => void;
  clearForm: () => void;
}

export const useOrderFormStore = create<OrderFormStore>((set) => ({
  // Estado inicial del formulario
  orderType: OrderTypeEnum.DINE_IN,
  selectedAreaId: null,
  selectedTableId: null,
  isTemporaryTable: false,
  temporaryTableName: '',
  scheduledTime: null,
  deliveryInfo: {},
  orderNotes: '',

  // Estado inicial del prepago
  prepaymentId: null,
  prepaymentAmount: '',
  prepaymentMethod: null,

  // Actions
  setOrderType: (type: OrderType) => {
    set({ orderType: type });
  },

  setSelectedAreaId: (id: string | null) => {
    set({ selectedAreaId: id });
  },

  setSelectedTableId: (id: string | null) => {
    set({ selectedTableId: id });
  },

  setIsTemporaryTable: (isTemp: boolean) => {
    set({ isTemporaryTable: isTemp });
  },

  setTemporaryTableName: (name: string) => {
    set({ temporaryTableName: name });
  },

  setScheduledTime: (time: Date | null) => {
    set({ scheduledTime: time });
  },

  setDeliveryInfo: (info: DeliveryInfo) => {
    set({ deliveryInfo: info });
  },

  setOrderNotes: (notes: string) => {
    set({ orderNotes: notes });
  },

  setPrepaymentId: (id: string | null) => {
    set({ prepaymentId: id });
  },

  setPrepaymentAmount: (amount: string) => {
    set({ prepaymentAmount: amount });
  },

  setPrepaymentMethod: (method: 'CASH' | 'CARD' | 'TRANSFER' | null) => {
    set({ prepaymentMethod: method });
  },

  clearForm: () => {
    set({
      orderType: OrderTypeEnum.DINE_IN,
      selectedAreaId: null,
      selectedTableId: null,
      isTemporaryTable: false,
      temporaryTableName: '',
      scheduledTime: null,
      deliveryInfo: {},
      orderNotes: '',
      prepaymentId: null,
      prepaymentAmount: '',
      prepaymentMethod: null,
    });
  },
}));

================
File: app/src/modules/orders/types/adjustments.types.ts
================
export interface OrderAdjustment {
  id?: string;
  name: string;
  isPercentage: boolean;
  value?: number; // Porcentaje (0-100) si isPercentage es true
  amount?: number; // Monto fijo si isPercentage es false (puede ser negativo para descuentos)
  // Para UI local
  isNew?: boolean;
  isDeleted?: boolean;
}

export interface AdjustmentFormData {
  name: string;
  isPercentage: boolean;
  value?: number;
  amount?: number;
}

================
File: app/src/modules/orders/types/update-order.types.ts
================
import type { OrderType } from './orders.types';
import type { Order } from '../../../app/schemas/domain/order.schema';
import type { DeliveryInfo } from '../../../app/schemas/domain/delivery-info.schema';

// Interfaz para modificadores de producto
export interface ProductModifierDto {
  modifierId: string;
}

// Interfaz para personalizaciones de pizza seleccionadas
export interface SelectedPizzaCustomizationDto {
  pizzaCustomizationId: string;
  half: 'FULL' | 'HALF_1' | 'HALF_2';
  action: 'ADD' | 'REMOVE';
}

// Interfaz para items en el DTO de actualizaci√≥n
export interface OrderItemDtoForBackend {
  id?: string;
  productId: string;
  productVariantId?: string | null;
  quantity: number; // NOTA: Siempre ser√° 1, el backend ya no maneja cantidades
  basePrice: number;
  finalPrice: number;
  preparationNotes?: string | null;
  productModifiers?: ProductModifierDto[]; // Array de objetos con modifierId
  selectedPizzaCustomizations?: SelectedPizzaCustomizationDto[]; // Personalizaciones de pizza
}

// Interfaz para ajustes en el DTO
export interface OrderAdjustmentDto {
  orderId?: string;
  name: string;
  isPercentage: boolean;
  value?: number;
  amount?: number;
}

// Interfaz para el payload de actualizaci√≥n de orden
export interface UpdateOrderPayload {
  orderType?: OrderType;
  items?: OrderItemDtoForBackend[];
  tableId?: string | null;
  scheduledAt?: Date | null;
  deliveryInfo?: DeliveryInfo;
  notes?: string | null;
  status?: Order['orderStatus'];
  total?: number;
  subtotal?: number;
  adjustments?: OrderAdjustmentDto[];
}

================
File: app/src/modules/pizzaCustomizations/components/index.ts
================
// Componentes principales usados en screens
export { PizzaProductsTab } from './PizzaProductsTab';
export { PizzaCustomizationsTab } from './PizzaCustomizationsTab';
export { PizzaCustomizationFormModal } from './PizzaCustomizationFormModal';

// Los siguientes componentes son internos y no necesitan ser exportados
// PizzaCustomizationCard - usado solo en PizzaCustomizationsTab
// PizzaConfigurationModal - usado solo en PizzaProductsTab
// AssociatePizzaToppingsModal - usado solo en PizzaProductsTab
// PizzaCustomizationDetailModal - usado solo en PizzaCustomizationsTab

================
File: app/src/modules/pizzaCustomizations/components/PizzaProductsTab.tsx
================
import React, { useState, useMemo } from 'react';
import { View, StyleSheet, FlatList, RefreshControl } from 'react-native';
import {
  Surface,
  Text,
  IconButton,
  Chip,
  ActivityIndicator,
  Menu,
  Searchbar,
  Badge,
  Avatar,
} from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { useQuery } from '@tanstack/react-query';
import { productsService } from '@/modules/menu/services/productsService';
import EmptyState from '@/app/components/common/EmptyState';
import { Product } from '@/modules/menu/schema/products.schema';
import { getImageUrl } from '@/app/lib/imageUtils';
import { PizzaConfigurationModal } from './PizzaConfigurationModal';
import { AssociatePizzaToppingsModal } from './AssociatePizzaToppingsModal';

export function PizzaProductsTab() {
  const theme = useAppTheme();
  const [searchQuery, setSearchQuery] = useState('');
  const [filterMenuVisible, setFilterMenuVisible] = useState(false);
  const [filter, setFilter] = useState<'all' | 'configured' | 'not_configured'>(
    'all',
  );
  const [configModalVisible, setConfigModalVisible] = useState(false);
  const [ingredientsModalVisible, setIngredientsModalVisible] = useState(false);
  const [selectedProduct, setSelectedProduct] = useState<Product | null>(null);

  const { data, isLoading, refetch, isRefetching } = useQuery({
    queryKey: ['pizza-products', filter],
    queryFn: async () => {
      const pizzaProducts = await productsService.findAllPizzas();
      return pizzaProducts;
    },
  });

  const filteredProducts = useMemo(() => {
    if (!data) return [];

    let filtered = data.filter((product) =>
      product.name.toLowerCase().includes(searchQuery.toLowerCase()),
    );

    if (filter === 'configured') {
      filtered = filtered.filter((product) => product.pizzaConfiguration);
    } else if (filter === 'not_configured') {
      filtered = filtered.filter((product) => !product.pizzaConfiguration);
    }

    return filtered;
  }, [data, searchQuery, filter]);

  const renderProductItem = ({ item }: { item: Product }) => {
    const isConfigured = !!item.pizzaConfiguration;
    const customizations = item.pizzaCustomizations || [];
    const flavorsCount = customizations.filter(
      (c: any) => c.type === 'FLAVOR',
    ).length;
    const ingredientsCount = customizations.filter(
      (c: any) => c.type === 'INGREDIENT',
    ).length;
    const imageUrl = item.photo?.path ? getImageUrl(item.photo.path) : null;
    const variantsCount = item.variants?.length || 0;

    return (
      <Surface style={styles.productCard} elevation={2}>
        <View style={styles.productHeader}>
          <View style={styles.productTitleRow}>
            {imageUrl ? (
              <Avatar.Image
                size={48}
                source={{ uri: imageUrl }}
                style={styles.productImage}
              />
            ) : (
              <Avatar.Icon
                size={48}
                icon="pizza"
                style={[
                  styles.productImage,
                  { backgroundColor: theme.colors.primaryContainer },
                ]}
              />
            )}

            <View style={styles.productInfo}>
              <Text
                variant="titleMedium"
                style={styles.productName}
                numberOfLines={1}
              >
                {item.name}
              </Text>
              <Text variant="bodySmall" style={styles.variantText}>
                {variantsCount > 0
                  ? `${variantsCount} variantes`
                  : 'Sin variantes'}
              </Text>
            </View>

            <View style={styles.productActions}>
              <IconButton
                icon="cog"
                mode="contained-tonal"
                size={28}
                onPress={() => {
                  setSelectedProduct(item);
                  setConfigModalVisible(true);
                }}
                style={styles.actionButton}
              />
              <IconButton
                icon="cheese"
                mode="contained-tonal"
                size={28}
                onPress={() => {
                  setSelectedProduct(item);
                  setIngredientsModalVisible(true);
                }}
                style={styles.actionButton}
              />
            </View>
          </View>
        </View>

        <View style={styles.productStatus}>
          <Chip
            mode="flat"
            compact
            icon={isConfigured ? 'check-circle' : 'alert-circle'}
            style={[
              styles.statusChip,
              {
                backgroundColor: isConfigured
                  ? theme.colors.primaryContainer
                  : theme.colors.errorContainer,
              },
            ]}
            textStyle={styles.chipText}
          >
            {isConfigured ? 'Configurada' : 'Sin configurar'}
          </Chip>

          <View style={styles.countsContainer}>
            <Text variant="bodySmall" style={styles.countText}>
              {flavorsCount} sabores
            </Text>
            <Text variant="bodySmall" style={styles.countDivider}>
              ‚Ä¢
            </Text>
            <Text variant="bodySmall" style={styles.countText}>
              {ingredientsCount} ingredientes
            </Text>
          </View>
        </View>
      </Surface>
    );
  };

  const hasActiveFilter = filter !== 'all';

  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    header: {
      padding: theme.spacing.m,
      backgroundColor: theme.colors.background,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    searchRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
    },
    searchbar: {
      flex: 1,
      backgroundColor: theme.colors.elevation.level2,
    },
    filterButtonContainer: {
      position: 'relative',
    },
    filterIconButton: {
      margin: 0,
      backgroundColor: theme.colors.elevation.level2,
    },
    filterBadge: {
      position: 'absolute',
      top: 4,
      right: 4,
      backgroundColor: theme.colors.primary,
    },
    menuContent: {
      backgroundColor: theme.colors.elevation.level3,
      marginTop: theme.spacing.xs,
    },
    content: {
      flex: 1,
    },
    listContent: {
      paddingVertical: theme.spacing.m,
    },
    productCard: {
      marginHorizontal: theme.spacing.m,
      marginVertical: theme.spacing.s,
      borderRadius: theme.roundness * 2,
      backgroundColor: theme.colors.surface,
      overflow: 'hidden',
      elevation: 1,
    },
    productHeader: {
      padding: theme.spacing.m,
      paddingBottom: theme.spacing.s,
    },
    productTitleRow: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    productImage: {
      marginRight: theme.spacing.m,
    },
    productInfo: {
      flex: 1,
    },
    productName: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      marginBottom: 2,
    },
    variantText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    productStatus: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: theme.spacing.m,
      paddingBottom: theme.spacing.m,
    },
    statusChip: {
      height: 28,
    },
    chipText: {
      fontSize: 12,
      marginHorizontal: theme.spacing.xs,
      marginVertical: 2,
    },
    ingredientCount: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    countsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
    },
    countText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    countDivider: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginHorizontal: 2,
    },
    productActions: {
      flexDirection: 'row',
      gap: theme.spacing.xs,
      marginLeft: theme.spacing.s,
    },
    actionButton: {
      margin: 0,
      width: 48,
      height: 48,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
  });

  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <View style={styles.searchRow}>
          <Searchbar
            placeholder="Buscar pizzas..."
            onChangeText={setSearchQuery}
            value={searchQuery}
            style={styles.searchbar}
            elevation={0}
            inputStyle={{ color: theme.colors.onSurface }}
            placeholderTextColor={theme.colors.onSurfaceVariant}
            iconColor={theme.colors.onSurfaceVariant}
          />
          <View style={styles.filterButtonContainer}>
            <Menu
              visible={filterMenuVisible}
              onDismiss={() => setFilterMenuVisible(false)}
              anchor={
                <IconButton
                  icon={hasActiveFilter ? 'filter-check' : 'filter-variant'}
                  mode="contained-tonal"
                  size={24}
                  onPress={() => setFilterMenuVisible(true)}
                  style={styles.filterIconButton}
                  iconColor={
                    hasActiveFilter
                      ? theme.colors.primary
                      : theme.colors.onSurfaceVariant
                  }
                />
              }
              anchorPosition="bottom"
              contentStyle={styles.menuContent}
            >
              <Menu.Item
                onPress={() => {
                  setFilter('all');
                  setFilterMenuVisible(false);
                }}
                title="Todas"
                leadingIcon="filter-variant"
                trailingIcon={filter === 'all' ? 'check' : undefined}
                titleStyle={
                  filter === 'all'
                    ? { color: theme.colors.primary, fontWeight: '600' }
                    : undefined
                }
              />
              <Menu.Item
                onPress={() => {
                  setFilter('configured');
                  setFilterMenuVisible(false);
                }}
                title="Configuradas"
                leadingIcon="check-circle"
                trailingIcon={filter === 'configured' ? 'check' : undefined}
                titleStyle={
                  filter === 'configured'
                    ? { color: theme.colors.primary, fontWeight: '600' }
                    : undefined
                }
              />
              <Menu.Item
                onPress={() => {
                  setFilter('not_configured');
                  setFilterMenuVisible(false);
                }}
                title="Sin Configurar"
                leadingIcon="alert-circle"
                trailingIcon={filter === 'not_configured' ? 'check' : undefined}
                titleStyle={
                  filter === 'not_configured'
                    ? { color: theme.colors.primary, fontWeight: '600' }
                    : undefined
                }
              />
            </Menu>
            {hasActiveFilter && <Badge style={styles.filterBadge} size={8} />}
          </View>
        </View>
      </View>

      <FlatList
        data={filteredProducts}
        renderItem={renderProductItem}
        keyExtractor={(item) => item.id}
        contentContainerStyle={styles.listContent}
        refreshControl={
          <RefreshControl
            refreshing={isRefetching}
            onRefresh={refetch}
            colors={[theme.colors.primary]}
          />
        }
        ListEmptyComponent={
          <EmptyState
            title="No hay pizzas"
            message={
              filter === 'not_configured'
                ? 'No hay pizzas sin configurar'
                : filter === 'configured'
                  ? 'No hay pizzas configuradas'
                  : 'No hay productos tipo pizza creados'
            }
            icon="pizza"
          />
        }
      />

      <PizzaConfigurationModal
        visible={configModalVisible}
        onDismiss={() => {
          setConfigModalVisible(false);
          setSelectedProduct(null);
        }}
        product={selectedProduct}
      />

      <AssociatePizzaToppingsModal
        visible={ingredientsModalVisible}
        onDismiss={() => {
          setIngredientsModalVisible(false);
          setSelectedProduct(null);
        }}
        product={selectedProduct}
      />
    </View>
  );
}

================
File: app/src/modules/pizzaCustomizations/hooks/usePizzaCustomizationsQueries.ts
================
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { pizzaCustomizationsService } from '../services/pizzaCustomizationsService';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import type { FindAllPizzaCustomizationsQuery } from '../schema/pizzaCustomization.schema';

const PIZZA_CUSTOMIZATIONS_QUERY_KEYS = {
  all: ['pizzaCustomizations'] as const,
  lists: () => [...PIZZA_CUSTOMIZATIONS_QUERY_KEYS.all, 'list'] as const,
  list: (params?: FindAllPizzaCustomizationsQuery) =>
    [...PIZZA_CUSTOMIZATIONS_QUERY_KEYS.lists(), params] as const,
  details: () => [...PIZZA_CUSTOMIZATIONS_QUERY_KEYS.all, 'detail'] as const,
  detail: (id: string) =>
    [...PIZZA_CUSTOMIZATIONS_QUERY_KEYS.details(), id] as const,
};

export function usePizzaCustomizationsList(
  params?: FindAllPizzaCustomizationsQuery,
) {
  return useQuery({
    queryKey: PIZZA_CUSTOMIZATIONS_QUERY_KEYS.list(params),
    queryFn: () => pizzaCustomizationsService.findAll(params),
  });
}

export function usePizzaCustomization(id: string) {
  return useQuery({
    queryKey: PIZZA_CUSTOMIZATIONS_QUERY_KEYS.detail(id),
    queryFn: () => pizzaCustomizationsService.findOne(id),
    enabled: !!id,
  });
}

export function useCreatePizzaCustomization() {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: pizzaCustomizationsService.create,
    onSuccess: () => {
      queryClient.invalidateQueries({
        queryKey: PIZZA_CUSTOMIZATIONS_QUERY_KEYS.lists(),
      });
      showSnackbar({
        message: 'Personalizaci√≥n creada exitosamente',
        type: 'success',
      });
    },
    onError: (error) => {
      showSnackbar({
        message:
          error instanceof Error
            ? error.message
            : 'Error al crear personalizaci√≥n',
        type: 'error',
      });
    },
  });
}

export function useUpdatePizzaCustomization() {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: ({
      id,
      data,
    }: {
      id: string;
      data: Parameters<typeof pizzaCustomizationsService.update>[1];
    }) => pizzaCustomizationsService.update(id, data),
    onSuccess: (data, variables) => {
      queryClient.invalidateQueries({
        queryKey: PIZZA_CUSTOMIZATIONS_QUERY_KEYS.lists(),
      });
      queryClient.invalidateQueries({
        queryKey: PIZZA_CUSTOMIZATIONS_QUERY_KEYS.detail(variables.id),
      });
      showSnackbar({
        message: 'Personalizaci√≥n actualizada exitosamente',
        type: 'success',
      });
    },
    onError: (error) => {
      showSnackbar({
        message:
          error instanceof Error
            ? error.message
            : 'Error al actualizar personalizaci√≥n',
        type: 'error',
      });
    },
  });
}

export function useDeletePizzaCustomization() {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: pizzaCustomizationsService.remove,
    onSuccess: () => {
      queryClient.invalidateQueries({
        queryKey: PIZZA_CUSTOMIZATIONS_QUERY_KEYS.lists(),
      });
      showSnackbar({
        message: 'Personalizaci√≥n eliminada exitosamente',
        type: 'success',
      });
    },
    onError: (error) => {
      showSnackbar({
        message:
          error instanceof Error
            ? error.message
            : 'Error al eliminar personalizaci√≥n',
        type: 'error',
      });
    },
  });
}

================
File: app/src/modules/pizzaCustomizations/navigation/PizzaCustomizationsStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { PizzaManagementScreen } from '../screens/PizzaManagementScreen';
import type { PizzaCustomizationsStackParamList } from './types';

const Stack = createNativeStackNavigator<PizzaCustomizationsStackParamList>();

export function PizzaCustomizationsStackNavigator() {
  return (
    <Stack.Navigator
      screenOptions={{
        headerShown: false,
      }}
    >
      <Stack.Screen
        name="PizzaCustomizationsList"
        component={PizzaManagementScreen}
      />
    </Stack.Navigator>
  );
}

================
File: app/src/modules/pizzaCustomizations/navigation/types.ts
================
export type PizzaCustomizationsStackParamList = {
  PizzaCustomizationsList: undefined;
};

================
File: app/src/modules/pizzaCustomizations/schema/pizzaConfiguration.schema.ts
================
import { z } from 'zod';

export const pizzaConfigurationFormSchema = z.object({
  productId: z.string().min(1, 'El producto es requerido'),
  includedToppings: z
    .number()
    .min(0, 'Los toppings incluidos deben ser mayor o igual a 0')
    .default(4),
  extraToppingCost: z
    .number()
    .min(0, 'El costo extra debe ser mayor o igual a 0')
    .default(20),
});

export type PizzaConfigurationFormInputs = z.infer<
  typeof pizzaConfigurationFormSchema
>;

export const updatePizzaConfigurationSchema = z.object({
  includedToppings: z.number().min(0).optional(),
  extraToppingCost: z.number().min(0).optional(),
});

export type UpdatePizzaConfigurationInputs = z.infer<
  typeof updatePizzaConfigurationSchema
>;

================
File: app/src/modules/pizzaCustomizations/schema/pizzaCustomization.schema.ts
================
import { z } from 'zod';
import { CustomizationType } from '../types/pizzaCustomization.types';

export const pizzaCustomizationFormSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  type: z.nativeEnum(CustomizationType),
  ingredients: z.string().optional().nullable(),
  toppingValue: z
    .number()
    .min(0, 'El valor debe ser mayor o igual a 0')
    .default(1),
  isActive: z.boolean().default(true),
  sortOrder: z.number().default(0),
});

export type PizzaCustomizationFormInputs = z.infer<
  typeof pizzaCustomizationFormSchema
>;

export const findAllPizzaCustomizationsQuerySchema = z.object({
  page: z.number().optional(),
  limit: z.number().optional(),
  search: z.string().optional(),
  type: z.nativeEnum(CustomizationType).optional(),
  isActive: z.boolean().optional(),
});

export type FindAllPizzaCustomizationsQuery = z.infer<
  typeof findAllPizzaCustomizationsQuerySchema
>;

================
File: app/src/modules/pizzaCustomizations/types/pizzaConfiguration.types.ts
================
export interface PizzaConfiguration {
  id: string;
  productId: string;
  includedToppings: number;
  extraToppingCost: number;
  createdAt: string;
  updatedAt: string;
}

export interface CreatePizzaConfigurationInput {
  productId: string;
  includedToppings: number;
  extraToppingCost: number;
}

export interface UpdatePizzaConfigurationInput {
  includedToppings?: number;
  extraToppingCost?: number;
}

================
File: app/src/modules/pizzaCustomizations/types/pizzaCustomization.types.ts
================
export enum CustomizationType {
  FLAVOR = 'FLAVOR',
  INGREDIENT = 'INGREDIENT',
}

export enum PizzaHalf {
  FULL = 'FULL',
  HALF_1 = 'HALF_1',
  HALF_2 = 'HALF_2',
}

export enum CustomizationAction {
  ADD = 'ADD',
  REMOVE = 'REMOVE',
}

export interface PizzaCustomization {
  id: string;
  name: string;
  type: CustomizationType;
  ingredients?: string | null;
  toppingValue: number;
  isActive: boolean;
  sortOrder: number;
  productIds?: string[];
  products?: { id: string; name: string }[];
  createdAt: string;
  updatedAt: string;
}

export interface SelectedPizzaCustomization {
  id: string;
  orderItemId: string;
  pizzaCustomizationId: string;
  pizzaCustomization?: PizzaCustomization;
  half: PizzaHalf;
  action: CustomizationAction;
  createdAt: string;
  updatedAt: string;
}

================
File: app/src/modules/preparationScreens/navigation/PreparationScreensStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { PreparationScreensStackParamList } from './types';
import PreparationScreensScreen from '../screens/PreparationScreensScreen';
import { useAppTheme } from '../../../app/styles/theme';
import { getStackHeaderOptions } from '../../../app/navigation/options';

const Stack = createNativeStackNavigator<PreparationScreensStackParamList>();

const PreparationScreensStackNavigator = () => {
  const theme = useAppTheme();

  return (
    <Stack.Navigator
      initialRouteName="PreparationScreensList"
      screenOptions={{
        ...getStackHeaderOptions(theme),
      }}
    >
      <Stack.Screen
        name="PreparationScreensList"
        component={PreparationScreensScreen}
        options={{
          title: 'Pantallas de Preparaci√≥n',
          headerShown: false,
        }}
      />
    </Stack.Navigator>
  );
};

export default PreparationScreensStackNavigator;

================
File: app/src/modules/preparationScreens/navigation/types.ts
================
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import type { DrawerScreenProps } from '@react-navigation/drawer';
import { AppDrawerParamList } from '../../../app/navigation/types';

// Definir los par√°metros para cada pantalla dentro de este Stack Navigator
export type PreparationScreensStackParamList = {
  PreparationScreensList: undefined; // La pantalla de lista no recibe par√°metros
};

// Tipos espec√≠ficos para las props de cada pantalla del Stack
export type PreparationScreensListScreenProps = NativeStackScreenProps<
  PreparationScreensStackParamList,
  'PreparationScreensList'
>;

// Tipo para las props de este Stack cuando se usa dentro del Drawer principal
export type PreparationScreensDrawerScreenProps = DrawerScreenProps<
  AppDrawerParamList,
  'PreparationScreensStack'
>;

================
File: app/src/modules/printers/navigation/PrintersStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { PrintersStackParamList } from './types';
import PrintersScreen from '../screens/PrintersScreen'; // Importar la pantalla creada
import { useAppTheme } from '@/app/styles/theme';
import { getStackHeaderOptions } from '@/app/navigation/options';

const Stack = createNativeStackNavigator<PrintersStackParamList>();

const PrintersStackNavigator = () => {
  const theme = useAppTheme();

  return (
    <Stack.Navigator
      initialRouteName="PrintersList"
      screenOptions={{
        ...getStackHeaderOptions(theme),
      }}
    >
      <Stack.Screen
        name="PrintersList"
        component={PrintersScreen}
        options={{
          title: 'Impresoras', // T√≠tulo para la pantalla de lista
        }}
      />
    </Stack.Navigator>
  );
};

export default PrintersStackNavigator;

================
File: app/src/modules/printers/navigation/types.ts
================
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import type { DrawerScreenProps } from '@react-navigation/drawer';
import { AppDrawerParamList } from '@/app/navigation/types'; // Importar tipos del Drawer principal

export type PrintersStackParamList = {
  PrintersList: undefined; // La pantalla de lista no recibe par√°metros
};

export type PrintersListScreenProps = NativeStackScreenProps<
  PrintersStackParamList,
  'PrintersList'
>;

export type PrintersDrawerScreenProps = DrawerScreenProps<
  AppDrawerParamList,
  'PrintersStack' // El nombre que le daremos en el Drawer Navigator
>;

================
File: app/src/modules/printers/types/printer.types.ts
================
import { z } from 'zod'; // Importar z para inferir tipos si es necesario
// Importar tipos y esquemas Zod desde el nuevo archivo
import {
  thermalPrinterSchema,
  createThermalPrinterDtoSchema,
  updateThermalPrinterDtoSchema,
  findAllThermalPrintersFilterSchema,
  discoveredPrinterSchema,
  PrinterConnectionTypeSchema,
} from '../schema/printer.schema';
import type { BaseListQueryDto } from '../../../app/types/api.types';

// Exportar tipos inferidos de Zod
export type ThermalPrinter = z.infer<typeof thermalPrinterSchema>;
export type CreateThermalPrinterDto = z.infer<
  typeof createThermalPrinterDtoSchema
>;
export type UpdateThermalPrinterDto = z.infer<
  typeof updateThermalPrinterDtoSchema
>;
export type FindAllThermalPrintersDto = z.infer<
  typeof findAllThermalPrintersFilterSchema
> &
  BaseListQueryDto; // Combinar con paginaci√≥n base
export type DiscoveredPrinter = z.infer<typeof discoveredPrinterSchema>;
export type PrinterConnectionType = z.infer<typeof PrinterConnectionTypeSchema>;

// Las interfaces originales se comentan o eliminan ya que los tipos Zod son la fuente de verdad
// export interface DiscoveredPrinter { ... }
// export interface ThermalPrinter { ... }

================
File: app/src/modules/receipts/navigation/ReceiptsStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { ReceiptsScreen } from '../screens/ReceiptsScreen';
import { getStackHeaderOptions } from '@/app/navigation/options';
import { useAppTheme } from '@/app/styles/theme';

export type ReceiptsStackParamList = {
  ReceiptsList: undefined;
};

const Stack = createNativeStackNavigator<ReceiptsStackParamList>();

export const ReceiptsStackNavigator = () => {
  const theme = useAppTheme();

  return (
    <Stack.Navigator screenOptions={getStackHeaderOptions(theme)}>
      <Stack.Screen
        name="ReceiptsList"
        component={ReceiptsScreen}
        options={{
          title: 'Recibos',
          headerShown: false,
        }}
      />
    </Stack.Navigator>
  );
};

================
File: app/src/modules/receipts/navigation/types.ts
================
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { RouteProp } from '@react-navigation/native';

export type ReceiptsStackParamList = {
  ReceiptsList: undefined;
};

export type ReceiptsListScreenNavigationProp = NativeStackNavigationProp<
  ReceiptsStackParamList,
  'ReceiptsList'
>;

export type ReceiptsListScreenRouteProp = RouteProp<
  ReceiptsStackParamList,
  'ReceiptsList'
>;

================
File: app/src/modules/restaurantConfig/hooks/useRestaurantConfigQueries.ts
================
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { restaurantConfigService } from '../services/restaurantConfigService';
import { UpdateRestaurantConfigDto } from '../types/restaurantConfig.types';
import { useSnackbarStore } from '@/app/store/snackbarStore';

const QUERY_KEYS = {
  config: ['restaurantConfig'],
};

export const useRestaurantConfigQueries = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const useGetConfig = () => {
    return useQuery({
      queryKey: QUERY_KEYS.config,
      queryFn: restaurantConfigService.getConfig,
    });
  };

  const useUpdateConfig = (options?: { successMessage?: string }) => {
    return useMutation({
      mutationFn: (data: UpdateRestaurantConfigDto) =>
        restaurantConfigService.updateConfig(data),
      onSuccess: () => {
        queryClient.invalidateQueries({ queryKey: QUERY_KEYS.config });
        showSnackbar({
          message:
            options?.successMessage || 'Configuraci√≥n actualizada exitosamente',
          type: 'success',
        });
      },
      onError: (error: any) => {
        showSnackbar({
          message:
            error.response?.data?.message ||
            'Error al actualizar la configuraci√≥n',
          type: 'error',
        });
      },
    });
  };

  return {
    useGetConfig,
    useUpdateConfig,
  };
};

================
File: app/src/modules/restaurantConfig/navigation/RestaurantConfigStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { useAppTheme } from '@/app/styles/theme';
import { getStackHeaderOptions } from '@/app/navigation/options';
import RestaurantConfigScreen from '../screens/RestaurantConfigScreen';
import { RestaurantConfigStackParamList } from './types';

const Stack = createNativeStackNavigator<RestaurantConfigStackParamList>();

export const RestaurantConfigStackNavigator = () => {
  const theme = useAppTheme();

  return (
    <Stack.Navigator screenOptions={getStackHeaderOptions(theme)}>
      <Stack.Screen
        name="RestaurantConfig"
        component={RestaurantConfigScreen}
        options={{
          headerShown: false,
        }}
      />
    </Stack.Navigator>
  );
};

================
File: app/src/modules/restaurantConfig/navigation/types.ts
================
export type RestaurantConfigStackParamList = {
  RestaurantConfig: undefined;
};

================
File: app/src/modules/restaurantConfig/services/restaurantConfigService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import {
  RestaurantConfig,
  UpdateRestaurantConfigDto,
} from '../types/restaurantConfig.types';

export const restaurantConfigService = {
  getConfig: async (): Promise<RestaurantConfig> => {
    const response = await apiClient.get<RestaurantConfig>(
      API_PATHS.RESTAURANT_CONFIG,
    );
    if (!response.data) {
      throw new Error('No se pudo obtener la configuraci√≥n del restaurante');
    }
    return response.data;
  },

  updateConfig: async (
    data: UpdateRestaurantConfigDto,
  ): Promise<RestaurantConfig> => {
    const response = await apiClient.put<RestaurantConfig>(
      API_PATHS.RESTAURANT_CONFIG,
      data,
    );
    if (!response.data) {
      throw new Error('No se pudo actualizar la configuraci√≥n del restaurante');
    }
    return response.data;
  },
};

================
File: app/src/modules/users/components/index.ts
================
export * from './UserFormModal';
export * from './UserDetailModal';

================
File: app/src/modules/users/hooks/index.ts
================
export * from './useUsers';

================
File: app/src/modules/users/hooks/useUsers.tsx
================
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { usersApiService } from '../services';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import type { CreateUserDto, UpdateUserDto, UsersQuery } from '../types';

const USERS_QUERY_KEY = 'users';

export function useGetUsers(params?: UsersQuery) {
  return useQuery({
    queryKey: [USERS_QUERY_KEY, params],
    queryFn: () => usersApiService.findAll(params),
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
}

export function useGetUser(id?: string) {
  return useQuery({
    queryKey: [USERS_QUERY_KEY, id],
    queryFn: () => (id ? usersApiService.findOne(id) : Promise.resolve(null)),
    enabled: !!id,
    staleTime: 5 * 60 * 1000,
  });
}

export function useCreateUser() {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: (data: CreateUserDto) => usersApiService.create(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [USERS_QUERY_KEY] });
      showSnackbar({
        message: 'Usuario creado exitosamente',
        type: 'success',
      });
    },
    onError: (error: any) => {
      showSnackbar({
        message: error.response?.data?.message || 'Error al crear usuario',
        type: 'error',
      });
    },
  });
}

export function useUpdateUser() {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: UpdateUserDto }) =>
      usersApiService.update(id, data),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: [USERS_QUERY_KEY] });
      queryClient.invalidateQueries({
        queryKey: [USERS_QUERY_KEY, variables.id],
      });
      showSnackbar({
        message: 'Usuario actualizado exitosamente',
        type: 'success',
      });
    },
    onError: (error: any) => {
      showSnackbar({
        message: error.response?.data?.message || 'Error al actualizar usuario',
        type: 'error',
      });
    },
  });
}

export function useDeleteUser() {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: async (id: string) => {
      await usersApiService.remove(id);
      return id;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [USERS_QUERY_KEY] });
      showSnackbar({
        message: 'Usuario eliminado exitosamente',
        type: 'success',
      });
    },
    onError: (error: any) => {
      showSnackbar({
        message: error.response?.data?.message || 'Error al eliminar usuario',
        type: 'error',
      });
    },
  });
}

export function useResetPassword() {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: ({ id, password }: { id: string; password: string }) =>
      usersApiService.resetPassword(id, password),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({
        queryKey: [USERS_QUERY_KEY, variables.id],
      });
      showSnackbar({
        message: 'Contrase√±a actualizada exitosamente',
        type: 'success',
      });
    },
    onError: (error: any) => {
      showSnackbar({
        message: error.response?.data?.message || 'Error al cambiar contrase√±a',
        type: 'error',
      });
    },
  });
}

export function useToggleUserActive() {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: ({ id, isActive }: { id: string; isActive: boolean }) =>
      usersApiService.toggleActive(id, isActive),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: [USERS_QUERY_KEY] });
      queryClient.invalidateQueries({
        queryKey: [USERS_QUERY_KEY, variables.id],
      });
      showSnackbar({
        message: `Usuario ${variables.isActive ? 'activado' : 'desactivado'} exitosamente`,
        type: 'success',
      });
    },
    onError: (error: any) => {
      showSnackbar({
        message:
          error.response?.data?.message ||
          'Error al cambiar estado del usuario',
        type: 'error',
      });
    },
  });
}

================
File: app/src/modules/users/navigation/UsersStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { UsersListScreen } from '../screens';

export type UsersStackParamList = {
  UsersList: undefined;
};

const Stack = createNativeStackNavigator<UsersStackParamList>();

export function UsersStackNavigator() {
  return (
    <Stack.Navigator
      screenOptions={{
        headerShown: false,
      }}
    >
      <Stack.Screen
        name="UsersList"
        component={UsersListScreen}
        options={{
          title: 'Usuarios',
        }}
      />
    </Stack.Navigator>
  );
}

================
File: app/src/modules/users/screens/index.ts
================
export * from './UsersListScreen';

================
File: app/src/modules/users/services/index.ts
================
export * from './usersApi.service';

================
File: app/src/modules/users/types/index.ts
================
export * from './user.types';

================
File: app/src/modules/users/types/user.types.ts
================
export enum GenderEnum {
  MALE = 'male',
  FEMALE = 'female',
  OTHER = 'other',
}

export interface User {
  id: string;
  email?: string | null;
  username: string;
  firstName?: string | null;
  lastName?: string | null;
  birthDate?: string | null;
  gender?: GenderEnum | null;
  phoneNumber?: string | null;
  address?: string | null;
  city?: string | null;
  state?: string | null;
  country?: string | null;
  zipCode?: string | null;
  emergencyContact?: {
    name?: string;
    phone?: string;
    relationship?: string;
  } | null;
  isActive: boolean;
  role?: Role;
  preparationScreen?: {
    id: string;
    name: string;
    description?: string | null;
  } | null;
  createdAt: string;
  updatedAt: string;
}

export interface Role {
  id: number;
  name: string;
}

export enum RoleEnum {
  ADMIN = 1,
  MANAGER = 2,
  CASHIER = 3,
  WAITER = 4,
  KITCHEN = 5,
  DELIVERY = 6,
}

export interface CreateUserDto {
  email?: string;
  username: string;
  password: string;
  firstName: string;
  lastName: string;
  birthDate?: string;
  gender?: GenderEnum;
  phoneNumber?: string;
  address?: string;
  city?: string;
  state?: string;
  country?: string;
  zipCode?: string;
  emergencyContact?: {
    name?: string;
    phone?: string;
    relationship?: string;
  };
  role: {
    id: number;
  };
}

export interface UpdateUserDto {
  email?: string;
  username?: string;
  password?: string;
  firstName?: string;
  lastName?: string;
  birthDate?: string;
  gender?: GenderEnum;
  phoneNumber?: string;
  address?: string;
  city?: string;
  state?: string;
  country?: string;
  zipCode?: string;
  emergencyContact?: {
    name?: string;
    phone?: string;
    relationship?: string;
  };
  isActive?: boolean;
  role?: {
    id: number;
  };
}

export interface UsersQuery {
  page?: number;
  limit?: number;
  filters?: {
    isActive?: boolean;
    roles?: { id: number }[];
  };
  search?: string;
  sortBy?: string;
  sortOrder?: 'ASC' | 'DESC';
}

export interface UsersResponse {
  data: User[];
  hasNextPage: boolean;
}

================
File: app/src/services/reconnectionSnackbarService.ts
================
import { autoReconnectService } from './autoReconnectService';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { useAuthStore } from '@/app/store/authStore';

class ReconnectionSnackbarService {
  private unsubscribe: (() => void) | null = null;
  private lastLogCount = 0;
  private lastStatus: string | null = null;
  private snackbarTimeouts: Map<string, NodeJS.Timeout> = new Map();

  start() {
    // Detener si ya est√° corriendo
    this.stop();

    // Suscribirse a los cambios del servicio de reconexi√≥n
    this.unsubscribe = autoReconnectService.subscribe((state) => {
      // Solo mostrar snackbars si el usuario est√° logueado
      const isLoggedIn = !!useAuthStore.getState().user;
      if (!isLoggedIn) return;

      // Si no est√° reconectando, limpiar y salir
      if (!state.isReconnecting && state.status !== 'connected') {
        this.clearAllSnackbars();
        return;
      }

      // Detectar cambios de estado importantes
      if (state.status !== this.lastStatus) {
        this.lastStatus = state.status;
        this.showStatusSnackbar(state.status, state.attempts);
      }

      // Mostrar nuevos logs importantes
      if (state.logs.length > this.lastLogCount) {
        const newLogs = state.logs.slice(
          0,
          state.logs.length - this.lastLogCount,
        );
        this.processNewLogs(newLogs);
      }

      this.lastLogCount = state.logs.length;
    });
  }

  stop() {
    if (this.unsubscribe) {
      this.unsubscribe();
      this.unsubscribe = null;
    }
    this.clearAllSnackbars();
    this.lastLogCount = 0;
    this.lastStatus = null;
  }

  private showStatusSnackbar(status: string, attempts: number) {
    const { showSnackbar } = useSnackbarStore.getState();

    // Limpiar snackbar anterior del mismo tipo
    this.clearSnackbar('status');

    let message = '';
    let type: 'info' | 'error' | 'success' | 'warning' = 'info';
    let duration = 3000;

    switch (status) {
      case 'checking-network':
        message = 'üì° Verificando conexi√≥n WiFi...';
        type = 'info';
        break;
      case 'checking-health':
        message = `üè• Verificando servidor (intento #${attempts})`;
        type = 'info';
        break;
      case 'running-discovery':
        message = 'üîç Buscando servidor en la red...';
        type = 'warning';
        duration = 5000;
        break;
      case 'no-wifi':
        message = 'üì° Sin conexi√≥n WiFi';
        type = 'error';
        duration = 5000;
        break;
      case 'failed':
        message = `‚ùå Reconexi√≥n fallida (intento #${attempts})`;
        type = 'error';
        break;
      case 'connected':
        message = '‚úÖ ¬°Conexi√≥n restablecida!';
        type = 'success';
        duration = 4000;
        break;
    }

    if (message) {
      showSnackbar({ message, type, duration });

      // Programar limpieza
      const timeout = setTimeout(() => {
        this.snackbarTimeouts.delete('status');
      }, duration);

      this.snackbarTimeouts.set('status', timeout);
    }
  }

  private processNewLogs(logs: string[]) {
    const { showSnackbar } = useSnackbarStore.getState();

    // Solo procesar los logs m√°s importantes
    logs.forEach((log) => {
      // Filtrar logs que ya se muestran en el estado
      if (
        log.includes('CICLO DE RECONEXI√ìN') ||
        log.includes('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê') ||
        log.includes('PASO 1:') ||
        log.includes('PASO 2:') ||
        log.includes('PASO 3:')
      ) {
        return;
      }

      // Mostrar logs de error importantes
      if (
        log.includes('ERROR:') &&
        (log.includes('Health check fall√≥') ||
          log.includes('No se encontr√≥ servidor') ||
          log.includes('Ciclo fallido'))
      ) {
        showSnackbar({
          message: this.cleanLogMessage(log),
          type: 'error',
          duration: 4000,
        });
      }

      // Mostrar logs de √©xito
      else if (
        log.includes('SUCCESS:') &&
        (log.includes('WiFi conectado') ||
          log.includes('Health check exitoso') ||
          log.includes('Servidor encontrado') ||
          log.includes('RECONEXI√ìN EXITOSA'))
      ) {
        showSnackbar({
          message: this.cleanLogMessage(log),
          type: 'success',
          duration: 3000,
        });
      }
    });
  }

  private cleanLogMessage(log: string): string {
    // Remover timestamp y tipo de log
    return log
      .replace(/\[[^\]]+\]\s*(INFO|ERROR|SUCCESS):\s*/, '')
      .replace(/\s*‚Üí\s*/, ' ')
      .trim();
  }

  private clearSnackbar(key: string) {
    const timeout = this.snackbarTimeouts.get(key);
    if (timeout) {
      clearTimeout(timeout);
      this.snackbarTimeouts.delete(key);
    }
  }

  private clearAllSnackbars() {
    this.snackbarTimeouts.forEach((timeout) => clearTimeout(timeout));
    this.snackbarTimeouts.clear();
  }
}

// Singleton
export const reconnectionSnackbarService = new ReconnectionSnackbarService();

================
File: app/tsconfig.json
================
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "noUnusedLocals": true, // Report errors on unused local variables
    "noUnusedParameters": true, // Report errors on unused parameters
    "moduleResolution": "bundler", // A√±adido para resolver tipos de navegaci√≥n
    "baseUrl": ".", // O "./" - Directorio base para los paths
    "paths": {
      "@/*": ["src/*"] // Define el alias @/ para apuntar a src/
    }
  }
}

================
File: app/.eslintrc.js
================
module.exports = {
  root: true,
  parser: '@typescript-eslint/parser',
  parserOptions: {
    ecmaVersion: 2021,
    sourceType: 'module',
    ecmaFeatures: {
      jsx: true,
    },
    project: './tsconfig.json',
  },
  plugins: [
    '@typescript-eslint',
    'react',
    'react-hooks',
    'react-native',
    'prettier',
  ],
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:react/recommended',
    'plugin:react-hooks/recommended',
    'plugin:react-native/all',
    'prettier',
  ],
  env: {
    'react-native/react-native': true,
    node: true,
    es2021: true,
  },
  settings: {
    react: {
      version: 'detect',
    },
  },
  rules: {
    // TypeScript
    '@typescript-eslint/no-unused-vars': ['error', { 
      argsIgnorePattern: '^_',
      varsIgnorePattern: '^_',
      ignoreRestSiblings: true
    }],
    '@typescript-eslint/no-explicit-any': 'off', // Too many to fix now
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-namespace': 'off',

    // React
    'react/react-in-jsx-scope': 'off', // Not needed with React 17+
    'react/prop-types': 'off', // Using TypeScript
    'react/display-name': 'off',

    // React Native
    'react-native/no-inline-styles': 'error', // Refactored to use StyleSheet
    'react-native/no-color-literals': 'off',
    'react-native/no-raw-text': 'off',
    'react-native/sort-styles': 'off',
    'react-native/no-unused-styles': 'off', // Disabled - too many false positives

    // React Hooks
    'react-hooks/exhaustive-deps': 'warn',
    'react-hooks/rules-of-hooks': 'error',

    // General
    'no-console': ['warn', { allow: ['warn', 'error', 'info'] }],
    'prettier/prettier': 'error',
    'no-empty': ['error', { allowEmptyCatch: true }],
    'no-prototype-builtins': 'off',
  },
  ignorePatterns: [
    'node_modules/',
    'android/',
    'ios/',
    '.expo/',
    'babel.config.js',
    'metro.config.js',
    '*.config.js',
    '.eslintrc.js',
  ],
};

================
File: app/App.tsx
================
import React from 'react';
import { ActivityIndicator, View } from 'react-native';
import { Provider as PaperProvider } from 'react-native-paper';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import {
  useThemeStore,
  useSystemThemeDetector,
} from './src/app/store/themeStore';
import { AppNavigator } from './src/app/navigation/AppNavigator';
import GlobalSnackbar from './src/app/components/common/GlobalSnackbar';
import { useInitializeAuth } from './src/app/hooks/useInitializeAuth';
import { useServerConnection } from './src/app/hooks/useServerConnection';
import { es, registerTranslation } from 'react-native-paper-dates';

registerTranslation('es', es);

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000,
      gcTime: 10 * 60 * 1000,
      refetchOnMount: false,
      refetchOnWindowFocus: false,
      refetchOnReconnect: 'always',
      retry: 0,
      refetchInterval: false,
    },
    mutations: {
      retry: 0,
    },
  },
});

function AppContent() {
  const isInitializingAuth = useInitializeAuth();
  useServerConnection();
  const activeTheme = useThemeStore((state) => state.activeTheme);

  if (isInitializingAuth) {
    return (
      <View
        style={{
          flex: 1,
          justifyContent: 'center',
          alignItems: 'center',
          backgroundColor: activeTheme.colors.background,
        }}
      >
        <ActivityIndicator size="large" color={activeTheme.colors.primary} />
      </View>
    );
  }

  return (
    <>
      <AppNavigator />
      <GlobalSnackbar />
    </>
  );
}

export default function App() {
  useSystemThemeDetector();
  const activeTheme = useThemeStore((state) => state.activeTheme);

  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
      <SafeAreaProvider>
        <QueryClientProvider client={queryClient}>
          <PaperProvider theme={activeTheme}>
            <AppContent />
          </PaperProvider>
        </QueryClientProvider>
      </SafeAreaProvider>
    </GestureHandlerRootView>
  );
}

================
File: app/babel.config.js
================
module.exports = function (api) {
  api.cache(true);
  
  const isWeb = process.env.WEBPACK_DEV_SERVER === 'true' || process.env.PLATFORM === 'web';
  
  const plugins = [
    [
      "module-resolver",
      {
        root: ["./"],
        alias: {
          "@": "./src",
        },
      },
    ],
    'react-native-reanimated/plugin',
  ];

  if (isWeb) {
    plugins.push([
      function() {
        return {
          visitor: {
            MetaProperty(path) {
              if (path.node.meta.name === 'import' && path.node.property.name === 'meta') {
                path.replaceWith(
                  require('@babel/types').objectExpression([
                    require('@babel/types').objectProperty(
                      require('@babel/types').identifier('url'),
                      require('@babel/types').stringLiteral('')
                    )
                  ])
                );
              }
            }
          }
        };
      }
    ]);
  }

  return {
    presets: ["babel-preset-expo"],
    plugins,
  };
};

================
File: app/eas.json
================
{
  "cli": {
    "version": ">= 16.3.0",
    "appVersionSource": "remote"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal",
      "android": {
        "buildType": "apk"
      }
    },
    "preview": {
      "distribution": "internal",
      "android": {
        "buildType": "apk"
      },
      "env": {
        "NODE_ENV": "production"
      }
    },
    "production": {
      "autoIncrement": true,
      "android": {
        "buildType": "app-bundle"
      },
      "env": {
        "NODE_ENV": "production"
      }
    },
    "release": {
      "android": {
        "buildType": "apk"
      }
    },
    "production-apk": {
      "autoIncrement": true,
      "android": {
        "buildType": "apk"
      },
      "env": {
        "NODE_ENV": "production"
      }
    }
  },
  "submit": {
    "production": {
      "android": {
        "serviceAccountKeyPath": "./google-play-service-account.json",
        "track": "internal",
        "releaseStatus": "draft",
        "changesNotSentForReview": false
      }
    }
  }
}

================
File: app/scripts/check-new-arch-compatibility.js
================
const fs = require('fs');
const path = require('path');

const checkCompatibility = (packageName) => {
  const packagePath = path.join(__dirname, '../node_modules', packageName);
  
  if (!fs.existsSync(packagePath)) {
    return { status: 'not-found', packageName };
  }

  // Buscar indicadores de Nueva Arquitectura
  const indicators = {
    turboModules: false,
    fabric: false,
    codegen: false,
    reactNativeConfig: false
  };

  // Verificar package.json
  const packageJsonPath = path.join(packagePath, 'package.json');
  if (fs.existsSync(packageJsonPath)) {
    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
    
    // Buscar configuraci√≥n de codegen
    if (packageJson.codegenConfig) {
      indicators.codegen = true;
    }
  }

  // Verificar react-native.config.js
  const rnConfigPath = path.join(packagePath, 'react-native.config.js');
  if (fs.existsSync(rnConfigPath)) {
    indicators.reactNativeConfig = true;
  }

  // Buscar archivos indicadores (limitado para evitar b√∫squedas muy largas)
  const searchFiles = (dir, depth = 0) => {
    if (!fs.existsSync(dir) || depth > 3) return;
    
    try {
      const files = fs.readdirSync(dir);
      for (const file of files) {
        const filePath = path.join(dir, file);
        const stat = fs.statSync(filePath);
        
        if (stat.isDirectory() && !file.includes('node_modules') && !file.startsWith('.')) {
          searchFiles(filePath, depth + 1);
        } else if ((file.endsWith('.js') || file.endsWith('.ts') || file.endsWith('.tsx')) && stat.size < 100000) {
          try {
            const content = fs.readFileSync(filePath, 'utf8');
            if (content.includes('TurboModule')) indicators.turboModules = true;
            if (content.includes('codegenNativeComponent')) indicators.fabric = true;
          } catch (e) {
            // Ignorar errores de lectura
          }
        }
      }
    } catch (e) {
      // Ignorar errores de directorio
    }
  };

  searchFiles(packagePath);

  const isCompatible = indicators.turboModules || indicators.fabric || indicators.codegen;
  
  return {
    packageName,
    status: isCompatible ? 'compatible' : 'unknown',
    indicators
  };
};

// Leer todas las dependencias del package.json
const packageJson = JSON.parse(fs.readFileSync(path.join(__dirname, '../package.json'), 'utf8'));
const allDependencies = {
  ...packageJson.dependencies,
  ...packageJson.devDependencies
};

// Filtrar solo las que empiezan con react-native o expo
const nativeDependencies = Object.keys(allDependencies).filter(dep => 
  dep.startsWith('react-native') || 
  dep.startsWith('expo') || 
  dep.startsWith('@react-native') ||
  dep.includes('react-native') ||
  dep === '@shopify/flash-list'
);

console.log('üîç Verificando compatibilidad con Nueva Arquitectura...\n');
console.log(`üì¶ Total de dependencias nativas encontradas: ${nativeDependencies.length}\n`);

const results = {
  compatible: [],
  unknown: [],
  notFound: []
};

nativeDependencies.forEach(dep => {
  const result = checkCompatibility(dep);
  const emoji = result.status === 'compatible' ? '‚úÖ' : '‚ö†Ô∏è';
  
  if (result.status === 'compatible') {
    results.compatible.push(dep);
    console.log(`${emoji} ${result.packageName}: Compatible`);
    const indicators = Object.entries(result.indicators)
      .filter(([_, value]) => value)
      .map(([key]) => key);
    if (indicators.length > 0) {
      console.log(`   Indicadores encontrados: ${indicators.join(', ')}`);
    }
  } else if (result.status === 'unknown') {
    results.unknown.push(dep);
    console.log(`${emoji} ${result.packageName}: Compatibilidad desconocida`);
  } else {
    results.notFound.push(dep);
    console.log(`‚ùå ${result.packageName}: No encontrado`);
  }
});

console.log('\nüìä Resumen:');
console.log(`‚úÖ Compatibles: ${results.compatible.length}`);
console.log(`‚ö†Ô∏è  Desconocidas: ${results.unknown.length}`);
console.log(`‚ùå No encontradas: ${results.notFound.length}`);

console.log('\nüí° Recomendaciones:');
if (results.unknown.length > 0) {
  console.log('- Las bibliotecas con compatibilidad desconocida pueden funcionar con el Interop Layer');
  console.log('- Verifica la documentaci√≥n oficial de cada biblioteca');
  console.log('- Considera buscar alternativas para bibliotecas cr√≠ticas sin soporte');
}

console.log('\nüìö Para m√°s informaci√≥n, consulta NEW_ARCHITECTURE_COMPATIBILITY.md');

================
File: app/src/app/components/ConnectionIndicator.tsx
================
import React, { useMemo, useState, useEffect } from 'react';
import { View } from 'react-native';
import { IconButton, Surface, Badge } from 'react-native-paper';
import { useAppTheme } from '../styles/theme';
import { useServerConnection } from '../hooks/useServerConnection';
import { useSnackbarStore } from '../store/snackbarStore';
import { healthMonitoringService } from '@/services/healthMonitoringService';
import { autoReconnectService } from '@/services/autoReconnectService';

export function ConnectionIndicator() {
  const theme = useAppTheme();
  const { hasWifi, isConnected, isSearching, isHealthy, error } =
    useServerConnection();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const [isChecking, setIsChecking] = useState(false);
  const [isReconnecting, setIsReconnecting] = useState(false);

  useEffect(() => {
    const unsubscribe = autoReconnectService.subscribe((state) => {
      setIsReconnecting(state.isReconnecting && state.attempts > 0);
    });

    return () => {
      unsubscribe();
    };
  }, []);

  const getConnectionStatus = () => {
    if (!hasWifi) {
      return {
        icon: 'wifi-off',
        color: theme.colors.error,
        backgroundColor: theme.colors.errorContainer,
        message: 'Sin conexi√≥n WiFi',
      };
    }

    if (isSearching || isChecking) {
      return {
        icon: 'wifi-sync',
        color: theme.colors.warning || theme.colors.tertiary,
        backgroundColor:
          theme.colors.warningContainer || theme.colors.tertiaryContainer,
        message: isChecking
          ? 'Verificando conexi√≥n...'
          : 'Buscando servidor...',
      };
    }

    if (!isConnected) {
      return {
        icon: 'wifi-alert',
        color: theme.colors.error,
        backgroundColor: theme.colors.errorContainer,
        message: error || 'Sin conexi√≥n al servidor',
      };
    }

    if (!isHealthy) {
      return {
        icon: 'wifi-strength-2-alert',
        color: theme.colors.warning || theme.colors.tertiary,
        backgroundColor:
          theme.colors.warningContainer || theme.colors.tertiaryContainer,
        message: error || 'Servidor no responde',
      };
    }

    return {
      icon: 'wifi',
      color: theme.colors.onSurfaceVariant,
      backgroundColor: 'transparent',
      message: 'Conectado',
    };
  };

  const status = getConnectionStatus();

  const handlePress = async () => {
    const iconExplanation = getIconExplanation();
    showSnackbar({
      message: iconExplanation,
      type:
        !hasWifi || !isConnected ? 'error' : !isHealthy ? 'warning' : 'info',
      duration: 4000,
    });

    if (isReconnecting) {
      const reconnectState = autoReconnectService.getState();
      setTimeout(() => {
        showSnackbar({
          message: `Reconexi√≥n en progreso - Intento #${reconnectState.attempts}`,
          type: 'info',
          duration: 3000,
        });
      }, 500);
    }

    if (isConnected && !isChecking && !isReconnecting) {
      setIsChecking(true);

      setTimeout(async () => {
        try {
          const isHealthyNow = await healthMonitoringService.forceCheck();

          showSnackbar({
            message: isHealthyNow
              ? 'Servidor funcionando correctamente ‚úì'
              : 'El servidor no responde ‚úó',
            type: isHealthyNow ? 'success' : 'error',
            duration: 3000,
          });
        } catch (error) {
          showSnackbar({
            message: 'Error al verificar el servidor',
            type: 'error',
            duration: 3000,
          });
        } finally {
          setIsChecking(false);
        }
      }, 1000);
    }

    if (!isConnected && !isReconnecting && hasWifi) {
      showSnackbar({
        message: 'Iniciando proceso de reconexi√≥n...',
        type: 'info',
        duration: 2000,
      });

      setTimeout(() => {
        autoReconnectService.startAutoReconnect();
      }, 500);
    }
  };

  const getIconExplanation = () => {
    const reconnectInfo = isReconnecting
      ? '\nüîÑ Reconectando autom√°ticamente...'
      : '';

    switch (status.icon) {
      case 'wifi-off':
        return (
          'üì° Sin WiFi - Activa el WiFi y con√©ctate a la red' + reconnectInfo
        );
      case 'wifi-sync':
        return 'üîÑ Buscando servidor en la red...' + reconnectInfo;
      case 'wifi-alert':
        return '‚ö†Ô∏è Sin conexi√≥n al servidor' + reconnectInfo;
      case 'wifi-strength-2-alert':
        return '‚ö†Ô∏è Servidor no responde' + reconnectInfo;
      case 'wifi':
        return '‚úÖ Conectado al servidor';
      default:
        return status.message + reconnectInfo;
    }
  };

  const containerStyle = useMemo(
    () => ({
      marginRight: 8,
      borderRadius: 20,
      overflow: 'hidden',
    }),
    [],
  );

  const surfaceStyle = useMemo(
    () => ({
      borderRadius: 20,
      backgroundColor: status.backgroundColor,
    }),
    [status.backgroundColor],
  );

  const iconButtonStyle = useMemo(
    () => ({
      margin: 0,
    }),
    [],
  );

  const showBackground =
    !hasWifi || !isConnected || isSearching || !isHealthy || isChecking;

  if (showBackground) {
    return (
      <View style={containerStyle}>
        <Surface style={surfaceStyle} elevation={0}>
          <IconButton
            icon={status.icon}
            iconColor={status.color}
            size={24}
            animated={isSearching || isChecking}
            onPress={handlePress}
            style={iconButtonStyle}
          />
        </Surface>
        {isReconnecting && !isSearching && (
          <Badge
            size={8}
            style={{
              position: 'absolute',
              top: 4,
              right: 4,
              backgroundColor: theme.colors.warning || theme.colors.tertiary,
            }}
          />
        )}
      </View>
    );
  }

  return (
    <View style={{ marginRight: 8, position: 'relative' }}>
      <IconButton
        icon={status.icon}
        iconColor={theme.colors.onPrimary}
        size={24}
        onPress={handlePress}
      />
      {isReconnecting && (
        <Badge
          size={8}
          style={{
            position: 'absolute',
            top: 8,
            right: 8,
            backgroundColor: theme.colors.warning || theme.colors.tertiary,
          }}
        />
      )}
    </View>
  );
}

================
File: app/src/app/components/DateTimePickerSafe.tsx
================
import React, { useState, useEffect } from 'react';
import { View, StyleSheet, Platform } from 'react-native';
import { Modal, Portal, Text, Button, Surface } from 'react-native-paper';
import DateTimePicker from '@react-native-community/datetimepicker';

interface DateTimePickerSafeProps {
  visible: boolean;
  mode: 'date' | 'time' | 'datetime';
  value: Date | null;
  onConfirm: (date: Date) => void;
  onCancel: () => void;
  minimumDate?: Date;
  maximumDate?: Date;
  minuteInterval?: number;
  title?: string;
  allowManualInput?: boolean;
}

export const DateTimePickerSafe: React.FC<DateTimePickerSafeProps> = ({
  visible,
  mode,
  value,
  onConfirm,
  onCancel,
  minimumDate,
  maximumDate,
  minuteInterval = 1,
  title,
  allowManualInput = false,
}) => {
  const [tempDate, setTempDate] = useState<Date>(() => {
    if (value) return new Date(value);
    const now = new Date();
    if (mode === 'time' && minuteInterval && minuteInterval > 1) {
      const minutes = now.getMinutes();
      const roundedMinutes =
        Math.round(minutes / minuteInterval) * minuteInterval;
      const roundedDate = new Date(now);
      roundedDate.setMinutes(roundedMinutes, 0, 0);
      return roundedDate;
    }
    return now;
  });

  useEffect(() => {
    if (visible && value) {
      setTempDate(new Date(value));
    }
  }, [visible, value]);

  const handleChange = (_event: any, selectedDate?: Date) => {
    if (selectedDate) {
      setTempDate(new Date(selectedDate));
    }
  };

  const handleConfirm = () => {
    onConfirm(new Date(tempDate));
  };

  const getTitle = () => {
    if (title) return title;
    switch (mode) {
      case 'date':
        return 'Seleccionar Fecha';
      case 'time':
        return 'Seleccionar Hora';
      case 'datetime':
        return 'Seleccionar Fecha y Hora';
      default:
        return '';
    }
  };

  if (Platform.OS === 'ios') {
    return (
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onCancel}
          contentContainerStyle={styles.modalIOS}
        >
          <Surface style={styles.containerIOS}>
            <View style={styles.header}>
              <Button mode="text" onPress={onCancel}>
                Cancelar
              </Button>
              <Text variant="titleMedium">{getTitle()}</Text>
              <Button mode="text" onPress={handleConfirm}>
                Confirmar
              </Button>
            </View>
            <DateTimePicker
              testID="dateTimePicker"
              value={tempDate}
              mode={mode}
              is24Hour={false}
              display="spinner"
              onChange={handleChange}
              minimumDate={minimumDate}
              maximumDate={maximumDate}
              minuteInterval={minuteInterval as any}
              locale="es_ES"
            />
          </Surface>
        </Modal>
      </Portal>
    );
  }

  return (
    <>
      {visible && (
        <DateTimePicker
          testID="dateTimePicker"
          value={tempDate}
          mode={mode}
          is24Hour={false}
          display="default"
          onChange={(event, selectedDate) => {
            onCancel();
            if (event.type === 'set' && selectedDate) {
              onConfirm(new Date(selectedDate));
            }
          }}
          minimumDate={minimumDate}
          maximumDate={maximumDate}
          minuteInterval={minuteInterval as any}
          {...(allowManualInput && Platform.OS === 'android' && mode === 'time'
            ? {
                display: 'clock' as any,
              }
            : {})}
        />
      )}
    </>
  );
};

const styles = StyleSheet.create({
  modalIOS: {
    justifyContent: 'flex-end',
    margin: 0,
  },
  containerIOS: {
    backgroundColor: 'white',
    paddingBottom: 20,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 10,
    paddingVertical: 10,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
});

export default DateTimePickerSafe;

================
File: app/src/app/components/responsive/ResponsiveGrid.tsx
================
import React, { ReactNode, useMemo, Children } from 'react';
import { View, ViewStyle, StyleProp, DimensionValue } from 'react-native';
import { useResponsive } from '@/app/hooks/useResponsive';

interface ResponsiveGridProps {
  children: ReactNode;
  style?: StyleProp<ViewStyle>;

  // Configuraci√≥n de columnas
  columns?: number;
  columnsTablet?: number;
  columnsLandscape?: number;
  minItemWidth?: number;

  // Configuraci√≥n de filas
  rows?: number;
  minItemHeight?: number;

  // Espaciado
  gap?: number;
  gapTablet?: number;
  rowGap?: number;
  columnGap?: number;
  padding?: number;

  // Alineaci√≥n
  alignItems?: 'flex-start' | 'center' | 'flex-end' | 'stretch';
  justifyContent?:
    | 'flex-start'
    | 'center'
    | 'flex-end'
    | 'space-between'
    | 'space-around'
    | 'space-evenly';

  // Comportamiento
  fillLastRow?: boolean;
  equalHeight?: boolean;

  // Estilos de items
  itemStyle?: StyleProp<ViewStyle>;
  itemPadding?: number;
}

interface GridItemProps {
  children: ReactNode;
  style?: StyleProp<ViewStyle>;
  span?: number;
  spanTablet?: number;
}

// Componente para items del grid
export const GridItem: React.FC<GridItemProps> = ({
  children,
  style,
  span = 1,
  spanTablet,
}) => {
  const responsive = useResponsive();
  const actualSpan = responsive.isTablet && spanTablet ? spanTablet : span;

  return <View style={[{ flex: actualSpan }, style]}>{children}</View>;
};

export const ResponsiveGrid: React.FC<ResponsiveGridProps> = ({
  children,
  style,

  // Columnas
  columns = 1,
  columnsTablet,
  columnsLandscape,
  minItemWidth,

  // Filas
  rows,
  minItemHeight,

  // Espaciado
  gap = 16,
  gapTablet,
  rowGap,
  columnGap,
  padding = 0,

  // Alineaci√≥n
  alignItems = 'stretch',
  justifyContent = 'flex-start',

  // Comportamiento
  fillLastRow = false,
  equalHeight = false,

  // Estilos
  itemStyle,
  itemPadding = 0,
}) => {
  const responsive = useResponsive();

  // Calcular n√∫mero de columnas
  const calculateColumns = useMemo(() => {
    // Si hay un ancho m√≠nimo definido, calcular columnas din√°micamente
    if (minItemWidth) {
      return responsive.getGridColumns(minItemWidth, gap, padding);
    }

    // Si estamos en landscape y hay columnas espec√≠ficas para landscape
    if (responsive.isLandscape && columnsLandscape) {
      return columnsLandscape;
    }

    // Si es tablet y hay columnas espec√≠ficas para tablet
    if (responsive.isTablet && columnsTablet) {
      return columnsTablet;
    }

    // Columnas por defecto
    return columns;
  }, [
    columns,
    columnsTablet,
    columnsLandscape,
    minItemWidth,
    gap,
    padding,
    responsive,
  ]);

  // Calcular gap responsive
  const actualGap =
    responsive.isTablet && gapTablet !== undefined ? gapTablet : gap;
  const scaledGap = responsive.scaleWidth(actualGap);
  const actualRowGap =
    rowGap !== undefined ? responsive.scaleHeight(rowGap) : scaledGap;
  const actualColumnGap =
    columnGap !== undefined ? responsive.scaleWidth(columnGap) : scaledGap;

  // Procesar children en filas
  const processedChildren = useMemo(() => {
    const childArray = Children.toArray(children);
    const gridRows: ReactNode[][] = [];

    // Agrupar children en filas
    for (let i = 0; i < childArray.length; i += calculateColumns) {
      const row = childArray.slice(i, i + calculateColumns);

      // Si fillLastRow est√° activo y es la √∫ltima fila incompleta
      if (
        fillLastRow &&
        row.length < calculateColumns &&
        i + calculateColumns >= childArray.length
      ) {
        // Agregar elementos vac√≠os para completar la fila
        while (row.length < calculateColumns) {
          row.push(
            <View key={`empty-${i}-${row.length}`} style={{ flex: 1 }} />,
          );
        }
      }

      gridRows.push(row);
    }

    return gridRows;
  }, [children, calculateColumns, fillLastRow]);

  // Estilos del contenedor
  const containerStyle = useMemo(() => {
    const baseStyle: ViewStyle = {
      padding: responsive.scaleWidth(padding),
    };

    // Si se especifica un n√∫mero de filas, establecer altura
    if (rows && minItemHeight) {
      baseStyle.height =
        rows * (minItemHeight + actualRowGap) - actualRowGap + padding * 2;
    }

    return [baseStyle, style];
  }, [padding, rows, minItemHeight, actualRowGap, responsive, style]);

  // Estilos de fila
  const rowStyle = useMemo(() => {
    const style: ViewStyle = {
      flexDirection: 'row',
      justifyContent,
      alignItems,
    };

    if (equalHeight) {
      style.alignItems = 'stretch';
    }

    return style;
  }, [justifyContent, alignItems, equalHeight]);

  // Estilos de item
  const gridItemStyle = useMemo(() => {
    const style: ViewStyle = {
      flex: 1,
      padding: responsive.scaleWidth(itemPadding),
    };

    if (minItemHeight) {
      style.minHeight = responsive.scaleHeight(minItemHeight);
    }

    return [style, itemStyle];
  }, [itemPadding, minItemHeight, responsive, itemStyle]);

  return (
    <View style={containerStyle}>
      {processedChildren.map((row, rowIndex) => (
        <View
          key={`row-${rowIndex}`}
          style={[
            rowStyle,
            rowIndex < processedChildren.length - 1 && {
              marginBottom: actualRowGap,
            },
          ]}
        >
          {row.map((child, colIndex) => (
            <View
              key={`item-${rowIndex}-${colIndex}`}
              style={[
                gridItemStyle,
                colIndex < row.length - 1 && { marginRight: actualColumnGap },
              ]}
            >
              {child}
            </View>
          ))}
        </View>
      ))}
    </View>
  );
};

// Componente alternativo usando flexWrap para grids m√°s simples
export const ResponsiveFlexGrid: React.FC<ResponsiveGridProps> = ({
  children,
  style,
  columns = 2,
  columnsTablet,
  minItemWidth,
  gap = 16,
  gapTablet,
  padding = 0,
  alignItems = 'stretch',
  justifyContent = 'flex-start',
  itemStyle,
}) => {
  const responsive = useResponsive();

  // Calcular columnas
  const calculateColumns = minItemWidth
    ? responsive.getGridColumns(minItemWidth, gap, padding)
    : responsive.isTablet && columnsTablet
      ? columnsTablet
      : columns;

  // Calcular ancho de cada item
  const itemWidth = `${100 / calculateColumns - (gap * (calculateColumns - 1)) / calculateColumns}%`;
  const actualGap =
    responsive.isTablet && gapTablet !== undefined ? gapTablet : gap;

  const containerStyle: ViewStyle = {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent,
    alignItems,
    padding: responsive.scaleWidth(padding),
    gap: responsive.scaleWidth(actualGap),
  };

  const flexItemStyle: ViewStyle = {
    width: itemWidth as DimensionValue,
    minWidth: minItemWidth || 0,
  };

  return (
    <View style={[containerStyle, style]}>
      {Children.map(children, (child, index) => (
        <View key={index} style={[flexItemStyle, itemStyle]}>
          {child}
        </View>
      ))}
    </View>
  );
};

================
File: app/src/app/lib/imageUploadService.ts
================
import {
  uploadFile,
  FileUploadResponse,
} from '../../modules/menu/services/fileService';
import { ApiError } from './errors';
import { getImageUrl } from './imageUtils';

export interface ImageUploadResult {
  success: boolean;
  photoId?: string;
  error?: string;
}

export interface FileObject {
  uri: string;
  name: string;
  type: string;
}

export interface EntityWithOptionalPhoto {
  photo?: {
    id: string;
    path: string;
  } | null;
}

export class ImageUploadService {
  /**
   * Sube una imagen usando el fileService.
   * @param imageFile El objeto FileObject con uri, name, type.
   * @returns Un objeto ImageUploadResult indicando √©xito/fallo y el ID de la foto.
   */
  static async uploadImage(imageFile: FileObject): Promise<ImageUploadResult> {
    if (!imageFile || !imageFile.uri) {
      // Intento de subir imagen inv√°lida
      return {
        success: false,
        error: 'No se proporcion√≥ ninguna imagen v√°lida',
      };
    }

    try {
      const uploadResult: FileUploadResponse = await uploadFile(imageFile);

      if (!uploadResult || !uploadResult.file || !uploadResult.file.id) {
        // Respuesta inv√°lida del fileService
        return {
          success: false,
          error: 'Respuesta inv√°lida del servidor al subir imagen.',
        };
      }

      return {
        success: true,
        photoId: uploadResult.file.id,
      };
    } catch (error) {
      // Error en ImageUploadService.uploadImage
      let errorMessage = 'Error desconocido al subir la imagen.';
      if (error instanceof ApiError) {
        errorMessage = `Error al subir: ${error.originalMessage || error.code}`;
      } else if (error instanceof Error) {
        errorMessage = error.message;
      }
      return {
        success: false,
        error: errorMessage,
      };
    }
  }

  /**
   * Determina el valor de photoId a enviar al backend basado en el estado actual del formulario y la entidad existente.
   * @param formImageUri La URI de la imagen actual en el formulario (puede ser 'file://...', una URL remota, o null).
   * @param existingEntity La entidad actual (ej. Category) que podr√≠a tener una propiedad 'photo' con 'id' y 'path'.
   * @returns
   *   - `undefined`: No hay cambios en la foto O se va a subir una nueva. El DTO NO debe incluir `photoId`.
   *   - `null`: Se debe eliminar la foto existente en el backend. El DTO DEBE incluir `photoId: null`.
   */
  static async determinePhotoId(
    formImageUri: string | null | undefined,
    existingEntity?: EntityWithOptionalPhoto,
  ): Promise<undefined | null> {
    const existingPhotoPath = existingEntity?.photo?.path;
    const existingPhotoFullUrl = existingPhotoPath
      ? await getImageUrl(existingPhotoPath)
      : null;

    if (formImageUri && formImageUri.startsWith('file://')) {
      return undefined;
    } else if (
      (formImageUri === null || formImageUri === undefined) &&
      existingEntity?.photo
    ) {
      return null;
    } else if (
      formImageUri &&
      !formImageUri.startsWith('file://') &&
      formImageUri === existingPhotoFullUrl
    ) {
      return undefined;
    } else if (
      formImageUri &&
      !formImageUri.startsWith('file://') &&
      formImageUri !== existingPhotoFullUrl
    ) {
      return undefined;
    } else if (
      (formImageUri === null || formImageUri === undefined) &&
      !existingEntity?.photo
    ) {
      return undefined;
    }

    return undefined;
  }
}

================
File: app/src/app/navigation/AuthStack.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { useAppTheme } from '../styles/theme';

import LoginScreen from '../../modules/auth/screens/LoginScreen';
import type { AuthStackParamList } from './types';

const Stack = createNativeStackNavigator<AuthStackParamList>();

export function AuthStack() {
  const theme = useAppTheme();

  return (
    <Stack.Navigator
      screenOptions={{
        headerStyle: {
          backgroundColor: theme.colors.primary,
        },
        headerTintColor: theme.colors.onPrimary,
        headerTitleStyle: {
          ...theme.fonts.titleLarge,
        },
      }}
    >
      <Stack.Screen
        name="Login"
        component={LoginScreen}
        options={{
          title: 'Iniciar Sesi√≥n',
          headerShown: false,
        }}
      />
    </Stack.Navigator>
  );
}

================
File: app/src/app/navigation/ConditionalAppNavigator.tsx
================
import React, { useEffect, useState, useCallback } from 'react';
import { View, ActivityIndicator } from 'react-native';
import { Portal, Dialog, Button, Text } from 'react-native-paper';
import { useAuthStore } from '../store/authStore';
import { AppDrawerNavigator } from './AppDrawerNavigator';
import { KitchenOnlyNavigator } from './KitchenOnlyNavigator';
import { useAppTheme } from '../styles/theme';

export function ConditionalAppNavigator() {
  const theme = useAppTheme();
  const user = useAuthStore((state) => state.user);
  const logout = useAuthStore((state) => state.logout);
  const [loading, setLoading] = useState(true);
  const [showNoScreenAlert, setShowNoScreenAlert] = useState(false);
  const [isKitchenUser, setIsKitchenUser] = useState(false);

  const checkUserAccess = useCallback(async () => {
    if (!user) {
      setLoading(false);
      return;
    }

    try {
      // Obtener el ID del rol
      const roleId = typeof user.role === 'object' ? user.role?.id : null;

      // Solo verificar pantalla para usuarios con rol kitchen (ID 5)
      if (roleId === 5) {
        setIsKitchenUser(true);
        // La informaci√≥n de la pantalla ya viene en el objeto user
        const hasScreen = !!user.preparationScreen;

        if (!hasScreen) {
          // Usuario de cocina sin pantalla asignada
          setShowNoScreenAlert(true);
        }
      } else {
        setIsKitchenUser(false);
      }
    } catch (error) {
      setIsKitchenUser(false);
    } finally {
      setLoading(false);
    }
  }, [user]);

  useEffect(() => {
    checkUserAccess();
  }, [checkUserAccess]);

  if (loading) {
    return (
      <View
        style={{
          flex: 1,
          justifyContent: 'center',
          alignItems: 'center',
          backgroundColor: theme.colors.background,
        }}
      >
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </View>
    );
  }

  // Usuarios de cocina usan un navegador especial, otros usan el drawer normal
  return (
    <>
      {isKitchenUser ? <KitchenOnlyNavigator /> : <AppDrawerNavigator />}
      <Portal>
        <Dialog
          visible={showNoScreenAlert}
          onDismiss={() => setShowNoScreenAlert(false)}
          style={{ backgroundColor: theme.colors.surface }}
        >
          <Dialog.Icon
            icon="alert-circle"
            size={64}
            color={theme.colors.error}
          />
          <Dialog.Title style={{ textAlign: 'center' }}>
            Sin Pantalla Asignada
          </Dialog.Title>
          <Dialog.Content>
            <Text variant="bodyLarge" style={{ textAlign: 'center' }}>
              Tu usuario de cocina no tiene una pantalla de preparaci√≥n
              asignada.
            </Text>
            <Text
              variant="bodyMedium"
              style={{ textAlign: 'center', marginTop: 8 }}
            >
              Por favor, contacta a tu administrador para que te asigne una
              pantalla de preparaci√≥n.
            </Text>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setShowNoScreenAlert(false)}>
              Entendido
            </Button>
            <Button
              mode="contained"
              onPress={async () => {
                setShowNoScreenAlert(false);
                await logout();
              }}
            >
              Cerrar Sesi√≥n
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </>
  );
}

================
File: app/src/app/navigation/helpers/navigationHelpers.ts
================
import { CommonActions } from '@react-navigation/native';
import { DrawerSection, hasPermission } from '@/app/constants/rolePermissions';

// Todas las rutas disponibles en el drawer en orden
export const ALL_DRAWER_ROUTES: DrawerSection[] = [
  'OrdersStack',
  'ReceiptsStack',
  'OrderFinalizationStack',
  'MenuStack',
  'AvailabilityStack',
  'ModifiersStack',
  'PizzaCustomizationsStack',
  'PreparationScreensStack',
  'AreasTablesStack',
  'PrintersStack',
  'RestaurantConfigStack',
  'CustomersStack',
  'SyncStack',
  'UsersStack',
  'ShiftAuditStack',
  'KitchenStack',
];

// Mapa de rutas a sus pantallas iniciales
export const ROUTE_INITIAL_SCREENS: Record<DrawerSection, string> = {
  OrdersStack: 'Orders',
  ReceiptsStack: 'ReceiptsList',
  OrderFinalizationStack: 'OrderFinalizationScreen',
  MenuStack: 'CategoriesScreen',
  AvailabilityStack: 'AvailabilityScreen',
  ModifiersStack: 'ModifierGroupsScreen',
  PizzaCustomizationsStack: 'PizzaCustomizationsList',
  PreparationScreensStack: 'PreparationScreensList',
  AreasTablesStack: 'AreasList',
  PrintersStack: 'PrintersList',
  RestaurantConfigStack: 'RestaurantConfig',
  CustomersStack: 'Customers',
  SyncStack: 'SyncStatus',
  UsersStack: 'UsersList',
  ShiftAuditStack: 'ShiftsList',
  KitchenStack: 'KitchenOrders',
};

// Helper para generar la acci√≥n de navegaci√≥n
export const generateNavigationAction = (
  targetRoute: DrawerSection,
  userRoleId: number | undefined,
) => {
  // Filtrar rutas bas√°ndose en permisos
  const allowedRoutes = ALL_DRAWER_ROUTES.filter((route) =>
    hasPermission(userRoleId, route),
  );

  // Encontrar el √≠ndice de la ruta objetivo
  const targetIndex = allowedRoutes.indexOf(targetRoute);

  if (targetIndex === -1) {
    return null;
  }

  // Construir las rutas con sus estados iniciales
  const routes = allowedRoutes.map((route, index) => {
    const baseRoute = { name: route };

    // Solo agregar state a la ruta activa
    if (index === targetIndex) {
      return {
        ...baseRoute,
        state: {
          routes: [{ name: ROUTE_INITIAL_SCREENS[route] }],
        },
      };
    }

    return baseRoute;
  });

  return CommonActions.reset({
    index: targetIndex,
    routes,
  });
};

================
File: app/src/app/navigation/options.ts
================
import { NativeStackNavigationOptions } from '@react-navigation/native-stack';
import { DrawerNavigationOptions } from '@react-navigation/drawer';
import { AppTheme } from '../styles/theme';
import { ResponsiveInfo } from '../hooks/useResponsive';

export const getDrawerHeaderOptions = (
  theme: AppTheme,
  responsive?: ResponsiveInfo,
): DrawerNavigationOptions => ({
  headerStyle: {
    backgroundColor: theme.colors.primary,
    height: responsive?.dimensions.headerHeight,
  },
  headerTintColor: theme.colors.onPrimary,
  headerTitleStyle: {
    ...theme.fonts.titleLarge,
    color: theme.colors.onPrimary,
    fontWeight: 'bold',
    fontSize: responsive?.fontSize.xl,
  },
  headerShadowVisible: false,
});

export const getStackHeaderOptions = (
  theme: AppTheme,
  responsive?: ResponsiveInfo,
): NativeStackNavigationOptions => ({
  headerStyle: {
    backgroundColor: theme.colors.elevation.level2,
    height: responsive?.dimensions.headerHeight,
  },
  headerTintColor: theme.colors.onSurface,
  headerTitleStyle: {
    ...theme.fonts.titleMedium,
    color: theme.colors.onSurface,
    fontWeight: 'bold',
    fontSize: responsive?.fontSize.l,
  },
  headerTitleAlign: 'center',
  headerShadowVisible: false,
});

================
File: app/src/app/schemas/domain/preparation-screen.schema.ts
================
import { z } from 'zod';

/**
 * Esquema Zod para PreparationScreen simplificado para el dominio.
 * Solo incluye los campos necesarios para la referencia en productos.
 */
export const preparationScreenSchema = z.object({
  id: z.string(),
  name: z.string(),
  description: z.string().nullable().optional(),
  isActive: z.boolean(),
});

export type PreparationScreen = z.infer<typeof preparationScreenSchema>;

================
File: app/src/app/types/theme.types.ts
================
import { z } from 'zod';
import { MD3Theme } from 'react-native-paper';

export const themePreferenceSchema = z.enum(['light', 'dark', 'system']);
export type ThemePreference = z.infer<typeof themePreferenceSchema>;

export const THEME_PREFERENCE_STORAGE_KEY = 'app_theme_preference';

export const THEME_MODE = {
  LIGHT: 'light',
  DARK: 'dark',
  SYSTEM: 'system',
} as const;

export interface AppTheme extends MD3Theme {}

export interface ThemeState {
  preference: ThemePreference;
  setPreference: (preference: ThemePreference) => void;
}

================
File: app/src/app/utils/__tests__/dateTimeHelpers.test.ts
================
import {
  safeTimeStringToDate,
  safeDateToTimeString,
  createScheduledDateTime as _createScheduledDateTime,
  roundMinutesToFive,
  parseDateFromBackend,
  getNextAvailableTime,
} from '../dateTimeHelpers';

describe('dateTimeHelpers', () => {
  describe('safeTimeStringToDate', () => {
    it('debe convertir string de hora a Date correctamente', () => {
      const result = safeTimeStringToDate('14:30');
      expect(result.getHours()).toBe(14);
      expect(result.getMinutes()).toBe(30);
      expect(result.getSeconds()).toBe(0);
      expect(result.getMilliseconds()).toBe(0);
    });

    it('debe lanzar error con formato inv√°lido', () => {
      expect(() => safeTimeStringToDate('14:30:00')).toThrow();
      expect(() => safeTimeStringToDate('25:00')).toThrow();
      expect(() => safeTimeStringToDate('14:60')).toThrow();
    });

    it('debe usar fecha base si se proporciona', () => {
      const baseDate = new Date('2024-01-15');
      const result = safeTimeStringToDate('10:00', baseDate);
      expect(result.getFullYear()).toBe(2024);
      expect(result.getMonth()).toBe(0); // Enero
      expect(result.getDate()).toBe(15);
    });
  });

  describe('safeDateToTimeString', () => {
    it('debe convertir Date a string HH:mm', () => {
      const date = new Date();
      date.setHours(9, 5);
      expect(safeDateToTimeString(date)).toBe('09:05');

      date.setHours(23, 59);
      expect(safeDateToTimeString(date)).toBe('23:59');
    });

    it('debe lanzar error con fecha inv√°lida', () => {
      expect(() => safeDateToTimeString(new Date('invalid'))).toThrow();
    });
  });

  describe('roundMinutesToFive', () => {
    it('debe redondear minutos correctamente', () => {
      expect(roundMinutesToFive(0)).toBe(0);
      expect(roundMinutesToFive(2)).toBe(0);
      expect(roundMinutesToFive(3)).toBe(5);
      expect(roundMinutesToFive(7)).toBe(5);
      expect(roundMinutesToFive(8)).toBe(10);
      expect(roundMinutesToFive(12)).toBe(10);
      expect(roundMinutesToFive(13)).toBe(15);
      expect(roundMinutesToFive(57)).toBe(55);
      expect(roundMinutesToFive(58)).toBe(60);
    });
  });

  describe('parseDateFromBackend', () => {
    it('debe parsear fechas ISO correctamente', () => {
      const isoString = '2024-01-15T14:30:00.000Z';
      const result = parseDateFromBackend(isoString);
      expect(result).toBeInstanceOf(Date);
      expect(result?.toISOString()).toBe(isoString);
    });

    it('debe retornar null para valores inv√°lidos', () => {
      expect(parseDateFromBackend(null)).toBeNull();
      expect(parseDateFromBackend(undefined)).toBeNull();
      expect(parseDateFromBackend('')).toBeNull();
      expect(parseDateFromBackend('invalid-date')).toBeNull();
    });
  });

  describe('getNextAvailableTime', () => {
    it('debe obtener siguiente hora disponible redondeada', () => {
      const mockNow = new Date('2024-01-15T14:22:00');
      jest.spyOn(global, 'Date').mockImplementation(() => mockNow);

      const result = getNextAvailableTime(30);

      // Debe ser al menos 30 minutos en el futuro
      expect(result.getTime()).toBeGreaterThan(mockNow.getTime());

      // Los minutos deben estar redondeados a m√∫ltiplo de 5
      expect(result.getMinutes() % 5).toBe(0);

      // No debe tener segundos ni milisegundos
      expect(result.getSeconds()).toBe(0);
      expect(result.getMilliseconds()).toBe(0);

      (global.Date as any).mockRestore();
    });
  });
});

================
File: app/src/hooks/useResponsiveFontScale.ts
================
import { useWindowDimensions, PixelRatio } from 'react-native';

interface ResponsiveFontConfig {
  baseSize?: number;
  minScale?: number;
  maxScale?: number;
}

/**
 * Hook para obtener un tama√±o de fuente responsive basado en las dimensiones
 * de la pantalla y la densidad de p√≠xeles del dispositivo.
 */
export const useResponsiveFontScale = (config: ResponsiveFontConfig = {}) => {
  const { width, height } = useWindowDimensions();
  const { minScale = 0.8, maxScale = 1.2 } = config;

  // Obtener la densidad de p√≠xeles del dispositivo
  const pixelRatio = PixelRatio.get();
  const fontScale = PixelRatio.getFontScale();

  // Calcular el tama√±o base de la pantalla
  const screenSize = Math.min(width, height);

  // Referencia: 360 es un ancho t√≠pico de m√≥vil
  const baseScreenSize = 360;

  // Calcular el factor de escala basado en el tama√±o de pantalla
  let scale = screenSize / baseScreenSize;

  // Limitar el factor de escala
  scale = Math.max(minScale, Math.min(maxScale, scale));

  // Ajustar por la configuraci√≥n de fuente del sistema
  scale = scale * fontScale;

  // En tablets, reducir ligeramente el escala para evitar fuentes muy grandes
  const isTablet = screenSize > 600;
  if (isTablet) {
    scale = scale * 0.85;
  }

  return {
    scale,
    fontSize: (size: number) => Math.round(size * scale),
    isTablet,
    screenSize,
    pixelRatio,
    fontScale,
  };
};

/**
 * Utilidad para obtener un tama√±o de fuente responsive
 * Nota: Esta funci√≥n no puede usar hooks, usar useResponsiveFontScale en su lugar
 */
export const getResponsiveFontSize = (
  baseSize: number,
  screenWidth?: number,
): number => {
  const fontScale = PixelRatio.getFontScale();

  // Si no se proporciona screenWidth, usar un valor por defecto
  const width = screenWidth || 360;

  // Referencia: 360 es un ancho t√≠pico de m√≥vil
  const baseScreenWidth = 360;
  const scale = Math.min(1.2, Math.max(0.8, width / baseScreenWidth));

  return Math.round(baseSize * scale * fontScale);
};

================
File: app/src/modules/areasTables/hooks/useAreasQueries.ts
================
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import * as areaService from '../services/areaService';
import {
  Area,
  CreateAreaDto,
  UpdateAreaDto,
  FindAllAreasDto,
} from '../schema/area.schema'; // Corregida ruta de importaci√≥n
import { BaseListQuery } from '../../../app/types/query.types';
import { useSnackbarStore } from '../../../app/store/snackbarStore';
import { getApiErrorMessage } from '../../../app/lib/errorMapping';

const areasQueryKeys = {
  all: ['areas'] as const,
  lists: () => [...areasQueryKeys.all, 'list'] as const,
  list: (filters: FindAllAreasDto & BaseListQuery) =>
    [...areasQueryKeys.lists(), filters] as const,
  details: () => [...areasQueryKeys.all, 'detail'] as const,
  detail: (id: string) => [...areasQueryKeys.details(), id] as const,
};

export const useGetAreas = (
  filters: FindAllAreasDto = {},
  pagination: BaseListQuery = { page: 1, limit: 10 },
) => {
  const queryKey = areasQueryKeys.list({ ...filters, ...pagination });
  return useQuery<Area[], Error>({
    queryKey,
    queryFn: () => areaService.getAreas(filters, pagination),
  });
};

export const useGetAreaById = (
  id: string | null,
  options?: { enabled?: boolean },
) => {
  const queryKey = areasQueryKeys.detail(id!); // Use non-null assertion as it's enabled conditionally
  return useQuery<Area, Error>({
    queryKey,
    queryFn: () => areaService.getAreaById(id!),
    enabled: !!id && (options?.enabled ?? true),
  });
};

export const useCreateArea = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<Area, Error, CreateAreaDto>({
    mutationFn: areaService.createArea,
    onSuccess: (_newArea) => {
      // Prefijado par√°metro no usado
      queryClient.invalidateQueries({ queryKey: areasQueryKeys.lists() });
      showSnackbar({ message: '√Årea creada con √©xito', type: 'success' });
    },
    onError: (error) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
      // Error al crear √°rea
    },
  });
};

export const useUpdateArea = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  type UpdateAreaContext = { previousAreas?: Area[]; previousDetail?: Area };

  return useMutation<
    Area,
    Error,
    { id: string; data: UpdateAreaDto },
    UpdateAreaContext
  >({
    mutationFn: ({ id, data }) => areaService.updateArea(id, data),

    onMutate: async (variables) => {
      const { id, data } = variables;
      const listQueryKey = areasQueryKeys.lists();
      const detailQueryKey = areasQueryKeys.detail(id);

      await queryClient.cancelQueries({ queryKey: listQueryKey });
      await queryClient.cancelQueries({ queryKey: detailQueryKey });

      const previousAreas = queryClient.getQueryData<Area[]>(listQueryKey);
      const previousDetail = queryClient.getQueryData<Area>(detailQueryKey);

      if (previousAreas) {
        queryClient.setQueryData<Area[]>(
          listQueryKey,
          (old) =>
            old?.map((area) =>
              area.id === id ? { ...area, ...data } : area,
            ) ?? [],
        );
      }

      if (previousDetail) {
        queryClient.setQueryData<Area>(
          detailQueryKey,
          (
            old: Area | undefined, // A√±adido tipo expl√≠cito
          ) => (old ? { ...old, ...data } : undefined),
        );
      }

      return { previousAreas, previousDetail };
    },

    onError: (error, variables, context) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
      // Error al actualizar √°rea

      if (context?.previousAreas) {
        queryClient.setQueryData(areasQueryKeys.lists(), context.previousAreas);
      }
      if (context?.previousDetail) {
        queryClient.setQueryData(
          areasQueryKeys.detail(variables.id),
          context.previousDetail,
        );
      }
    },

    onSettled: (data, error, variables, _context) => {
      // Prefijado par√°metro no usado
      queryClient.invalidateQueries({ queryKey: areasQueryKeys.lists() });
      queryClient.invalidateQueries({
        queryKey: areasQueryKeys.detail(variables.id),
      });

      if (!error && data) {
        showSnackbar({
          message: '√Årea actualizada con √©xito',
          type: 'success',
        });
      }
    },
  });
};

export const useDeleteArea = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  type DeleteAreaContext = { previousDetail?: Area };

  return useMutation<void, Error, string, DeleteAreaContext>({
    mutationFn: areaService.deleteArea,

    onMutate: async (deletedId) => {
      const detailQueryKey = areasQueryKeys.detail(deletedId);

      await queryClient.cancelQueries({ queryKey: detailQueryKey });

      const previousDetail = queryClient.getQueryData<Area>(detailQueryKey);

      queryClient.removeQueries({ queryKey: detailQueryKey });

      return { previousDetail };
    },

    onError: (error, deletedId, context) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
      // Error al eliminar √°rea

      if (context?.previousDetail) {
        queryClient.setQueryData(
          areasQueryKeys.detail(deletedId),
          context.previousDetail,
        );
      }
    },

    onSettled: (_data, error, deletedId) => {
      // Prefijado par√°metro no usado
      queryClient.invalidateQueries({ queryKey: areasQueryKeys.lists() });
      if (!error) {
        queryClient.removeQueries({
          queryKey: areasQueryKeys.detail(deletedId),
        });
        showSnackbar({ message: '√Årea eliminada con √©xito', type: 'success' });
      }
    },
  });
};

================
File: app/src/modules/areasTables/hooks/useTablesQueries.ts
================
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import * as tableService from '../services/tableService';
import {
  Table,
  CreateTableDto,
  UpdateTableDto,
  FindAllTablesDto,
} from '../schema/table.schema'; // Corregida ruta de importaci√≥n
import { BaseListQuery } from '../../../app/types/query.types';
import { useSnackbarStore } from '../../../app/store/snackbarStore';
import { getApiErrorMessage } from '../../../app/lib/errorMapping';

const tablesQueryKeys = {
  all: ['tables'] as const,
  lists: () => [...tablesQueryKeys.all, 'list'] as const,
  list: (filters: FindAllTablesDto & BaseListQuery) =>
    [...tablesQueryKeys.lists(), filters] as const,
  listsByArea: (areaId: string) =>
    [...tablesQueryKeys.lists(), { areaId }] as const,
  details: () => [...tablesQueryKeys.all, 'detail'] as const,
  detail: (id: string) => [...tablesQueryKeys.details(), id] as const,
};

export const useGetTables = (
  filters: FindAllTablesDto = {},
  pagination: BaseListQuery = { page: 1, limit: 10 },
) => {
  const queryKey = tablesQueryKeys.list({ ...filters, ...pagination });
  return useQuery<Table[], Error>({
    queryKey,
    queryFn: () => tableService.getTables(filters, pagination),
  });
};

export const useGetTablesByAreaId = (
  areaId: string | null,
  options?: { enabled?: boolean },
) => {
  const queryKey = tablesQueryKeys.listsByArea(areaId!);
  return useQuery<Table[], Error>({
    queryKey,
    queryFn: () => tableService.getTablesByAreaId(areaId!),
    enabled: !!areaId && (options?.enabled ?? true),
  });
};

export const useGetTableById = (
  id: string | null,
  options?: { enabled?: boolean },
) => {
  const queryKey = tablesQueryKeys.detail(id!);
  return useQuery<Table, Error>({
    queryKey,
    queryFn: () => tableService.getTableById(id!),
    enabled: !!id && (options?.enabled ?? true),
  });
};

export const useCreateTable = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<Table, Error, CreateTableDto>({
    mutationFn: tableService.createTable,
    onSuccess: (_newTable) => {
      // Prefijado par√°metro no usado
      queryClient.invalidateQueries({ queryKey: tablesQueryKeys.lists() });
      showSnackbar({ message: 'Mesa creada con √©xito', type: 'success' });
    },
    onError: (error) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
      // Error al crear mesa
    },
  });
};

export const useUpdateTable = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  type UpdateTableContext = { previousDetail?: Table };

  return useMutation<
    Table,
    Error,
    { id: string; data: UpdateTableDto },
    UpdateTableContext
  >({
    mutationFn: ({ id, data }) => tableService.updateTable(id, data),

    onMutate: async (variables) => {
      const { id, data } = variables;
      const detailQueryKey = tablesQueryKeys.detail(id);

      await queryClient.cancelQueries({ queryKey: detailQueryKey });

      const previousDetail = queryClient.getQueryData<Table>(detailQueryKey);

      if (previousDetail) {
        queryClient.setQueryData<Table>(
          detailQueryKey,
          (
            old: Table | undefined, // A√±adido tipo expl√≠cito
          ) => (old ? { ...old, ...data } : undefined),
        );
      }

      return { previousDetail };
    },

    onError: (error, variables, context) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
      // Error al actualizar mesa

      if (context?.previousDetail) {
        queryClient.setQueryData(
          tablesQueryKeys.detail(variables.id),
          context.previousDetail,
        );
      }
    },

    onSettled: (data, error, variables) => {
      queryClient.invalidateQueries({ queryKey: tablesQueryKeys.lists() });
      // Considerar invalidar listsByArea si areaId cambia
      queryClient.invalidateQueries({
        queryKey: tablesQueryKeys.detail(variables.id),
      });

      if (!error && data) {
        showSnackbar({
          message: 'Mesa actualizada con √©xito',
          type: 'success',
        });
      }
    },
  });
};

export const useDeleteTable = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  type DeleteTableContext = { previousDetail?: Table };

  return useMutation<void, Error, string, DeleteTableContext>({
    mutationFn: tableService.deleteTable,

    onMutate: async (deletedId) => {
      const detailQueryKey = tablesQueryKeys.detail(deletedId);

      await queryClient.cancelQueries({ queryKey: detailQueryKey });

      const previousDetail = queryClient.getQueryData<Table>(detailQueryKey);

      queryClient.removeQueries({ queryKey: detailQueryKey });

      return { previousDetail };
    },

    onError: (error, deletedId, context) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
      // Error al eliminar mesa

      if (context?.previousDetail) {
        queryClient.setQueryData(
          tablesQueryKeys.detail(deletedId),
          context.previousDetail,
        );
      }
    },

    onSettled: (_data, error, deletedId, context) => {
      // Prefijado par√°metro no usado
      queryClient.invalidateQueries({ queryKey: tablesQueryKeys.lists() });
      if (context?.previousDetail?.areaId) {
        queryClient.invalidateQueries({
          queryKey: tablesQueryKeys.listsByArea(context.previousDetail.areaId),
        });
      }

      if (!error) {
        queryClient.removeQueries({
          queryKey: tablesQueryKeys.detail(deletedId),
        });
        showSnackbar({ message: 'Mesa eliminada con √©xito', type: 'success' });
      }
    },
  });
};

================
File: app/src/modules/availability/components/AvailabilityListItem.tsx
================
import React from 'react';
import { View, StyleSheet, TouchableOpacity } from 'react-native';
import { Surface, Text, IconButton, Switch } from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';

interface AvailabilityListItemProps {
  title: string;
  subtitle: string;
  icon: string;
  isActive: boolean;
  onToggle: (value: boolean) => void;
  isExpanded?: boolean;
  onToggleExpand?: () => void;
  children?: React.ReactNode;
}

export const AvailabilityListItem: React.FC<AvailabilityListItemProps> = ({
  title,
  subtitle,
  icon,
  isActive,
  onToggle,
  isExpanded = false,
  onToggleExpand,
  children,
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );

  return (
    <Surface
      style={[styles.container, { backgroundColor: theme.colors.surface }]}
      elevation={1}
    >
      {/* Header */}
      <TouchableOpacity
        style={[
          styles.header,
          {
            backgroundColor: theme.colors.elevation.level2,
            opacity: isActive ? 1 : 0.7,
          },
        ]}
        onPress={onToggleExpand}
        activeOpacity={0.7}
        disabled={!onToggleExpand}
      >
        <View style={styles.left}>
          <View
            style={[
              styles.iconContainer,
              {
                backgroundColor: isActive
                  ? theme.colors.primaryContainer
                  : theme.colors.surfaceVariant,
              },
            ]}
          >
            <IconButton
              icon={icon}
              size={20}
              iconColor={isActive ? theme.colors.primary : theme.colors.outline}
              style={{ margin: 0 }}
            />
          </View>
          <View style={styles.info}>
            <Text
              style={[styles.title, { color: theme.colors.onSurface }]}
              numberOfLines={1}
            >
              {title}
            </Text>
            <Text
              style={[
                styles.subtitle,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              {subtitle}
            </Text>
          </View>
        </View>

        <View style={styles.right}>
          <Switch
            value={isActive}
            onValueChange={onToggle}
            color={theme.colors.primary}
            style={styles.switch}
          />
          {onToggleExpand && (
            <IconButton
              icon={isExpanded ? 'chevron-up' : 'chevron-down'}
              size={20}
              iconColor={theme.colors.onSurfaceVariant}
              style={{ margin: 0 }}
            />
          )}
        </View>
      </TouchableOpacity>

      {/* Contenido expandible */}
      {isExpanded && children && (
        <View
          style={[
            styles.expandedContent,
            { backgroundColor: theme.colors.elevation.level1 },
          ]}
        >
          {children}
        </View>
      )}
    </Surface>
  );
};

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      marginHorizontal: responsive.spacing(theme.spacing.m),
      borderRadius: 16,
      overflow: 'hidden',
    },
    header: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      padding: responsive.spacing(theme.spacing.m),
    },
    left: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
    },
    iconContainer: {
      width: responsive.isTablet ? 32 : 40,
      height: responsive.isTablet ? 32 : 40,
      borderRadius: responsive.isTablet ? 16 : 20,
      justifyContent: 'center',
      alignItems: 'center',
      marginRight: responsive.spacing(theme.spacing.m),
    },
    info: {
      flex: 1,
    },
    title: {
      fontSize: responsive.fontSize(16),
      fontWeight: '600',
      marginBottom: 2,
    },
    subtitle: {
      fontSize: responsive.fontSize(12),
      opacity: 0.8,
    },
    right: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    switch: {
      marginHorizontal: responsive.spacing(theme.spacing.s),
    },
    expandedContent: {
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingBottom: responsive.spacing(theme.spacing.m),
    },
  });

================
File: app/src/modules/availability/hooks/useOptimisticAvailability.ts
================
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { availabilityService } from '../services/availabilityService';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import {
  CategoryAvailability,
  SubcategoryAvailability as _SubcategoryAvailability,
  ProductAvailability as _ProductAvailability,
  ModifierGroupAvailability,
  ModifierAvailability as _ModifierAvailability,
  PizzaCustomizationGroupAvailability,
  AvailabilityUpdatePayload,
} from '../types/availability.types';

export const useOptimisticAvailability = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const updateOptimistically = (
    type: string,
    id: string,
    isActive: boolean,
    cascade?: boolean,
  ) => {
    const menuQueryKey = ['availability', 'menu'];
    const modifierQueryKey = ['availability', 'modifierGroups'];
    const pizzaQueryKey = ['availability', 'pizzaCustomizations'];

    // Funci√≥n para actualizar categor√≠as optimisticamente
    const updateMenuOptimistically = (oldData: CategoryAvailability[]) => {
      if (!oldData) return oldData;

      return oldData.map((category) => {
        if (type === 'category' && category.id === id) {
          const updated = { ...category, isActive };
          if (cascade) {
            return {
              ...updated,
              subcategories: updated.subcategories.map((sub) => ({
                ...sub,
                isActive,
                products: sub.products.map((prod) => ({ ...prod, isActive })),
              })),
            };
          }
          return updated;
        }

        if (type === 'subcategory') {
          const updatedSubcategories = category.subcategories.map((sub) => {
            if (sub.id === id) {
              const updated = { ...sub, isActive };
              if (cascade) {
                return {
                  ...updated,
                  products: updated.products.map((prod) => ({
                    ...prod,
                    isActive,
                  })),
                };
              }
              return updated;
            }
            return sub;
          });

          return { ...category, subcategories: updatedSubcategories };
        }

        if (type === 'product') {
          const updatedSubcategories = category.subcategories.map((sub) => ({
            ...sub,
            products: sub.products.map((prod) =>
              prod.id === id ? { ...prod, isActive } : prod,
            ),
          }));

          return { ...category, subcategories: updatedSubcategories };
        }

        return category;
      });
    };

    // Funci√≥n para actualizar grupos de modificadores optimisticamente
    const updateModifierGroupsOptimistically = (
      oldData: ModifierGroupAvailability[],
    ) => {
      if (!oldData) return oldData;

      return oldData.map((group) => {
        if (type === 'modifierGroup' && group.id === id) {
          const updated = { ...group, isActive };
          if (cascade) {
            return {
              ...updated,
              modifiers: updated.modifiers.map((mod) => ({ ...mod, isActive })),
            };
          }
          return updated;
        }

        if (type === 'modifier') {
          const updatedModifiers = group.modifiers.map((mod) =>
            mod.id === id ? { ...mod, isActive } : mod,
          );
          return { ...group, modifiers: updatedModifiers };
        }

        return group;
      });
    };

    // Funci√≥n para actualizar pizza customizations optimisticamente
    const updatePizzaCustomizationsOptimistically = (
      oldData: PizzaCustomizationGroupAvailability[],
    ) => {
      if (!oldData) return oldData;

      return oldData.map((group) => ({
        ...group,
        items: group.items.map((item) =>
          item.id === id ? { ...item, isActive } : item,
        ),
      }));
    };

    // Actualizar el cache optimisticamente
    if (type === 'category' || type === 'subcategory' || type === 'product') {
      queryClient.setQueryData(menuQueryKey, updateMenuOptimistically);
    } else if (type === 'modifierGroup' || type === 'modifier') {
      queryClient.setQueryData(
        modifierQueryKey,
        updateModifierGroupsOptimistically,
      );
    } else if (type === 'pizzaCustomization') {
      queryClient.setQueryData(
        pizzaQueryKey,
        updatePizzaCustomizationsOptimistically,
      );
    }
  };

  const mutation = useMutation({
    mutationFn: availabilityService.updateAvailability,
    onMutate: async (variables: AvailabilityUpdatePayload) => {
      // Cancelar cualquier refetch pendiente
      await queryClient.cancelQueries({ queryKey: ['availability'] });

      // Guardar estado previo para rollback
      const previousMenuData = queryClient.getQueryData([
        'availability',
        'menu',
      ]);
      const previousModifierData = queryClient.getQueryData([
        'availability',
        'modifierGroups',
      ]);
      const previousPizzaData = queryClient.getQueryData([
        'availability',
        'pizzaCustomizations',
      ]);

      // Actualizar optimisticamente
      updateOptimistically(
        variables.type,
        variables.id,
        variables.isActive,
        variables.cascade,
      );

      // Retornar contexto para rollback
      return {
        previousMenuData,
        previousModifierData,
        previousPizzaData,
        variables,
      };
    },
    onSuccess: () => {
      showSnackbar({ message: 'Disponibilidad actualizada', type: 'success' });
    },
    onError: (error, variables, context) => {
      // Revertir cambios optimistas
      if (context?.previousMenuData) {
        queryClient.setQueryData(
          ['availability', 'menu'],
          context.previousMenuData,
        );
      }
      if (context?.previousModifierData) {
        queryClient.setQueryData(
          ['availability', 'modifierGroups'],
          context.previousModifierData,
        );
      }
      if (context?.previousPizzaData) {
        queryClient.setQueryData(
          ['availability', 'pizzaCustomizations'],
          context.previousPizzaData,
        );
      }

      showSnackbar({
        message: 'Error al actualizar disponibilidad',
        type: 'error',
      });
    },
    onSettled: () => {
      // Invalidar y refetch para asegurar sincronizaci√≥n
      queryClient.invalidateQueries({ queryKey: ['availability'] });
    },
  });

  return mutation;
};

================
File: app/src/modules/customers/components/LocationPicker.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, Alert } from 'react-native';
import { Text, Button, TextInput, Chip, HelperText } from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { ResponsiveModal } from '@/app/components/responsive/ResponsiveModal';

interface LocationPickerProps {
  visible: boolean;
  onDismiss: () => void;
  onConfirm: (location: {
    latitude: number;
    longitude: number;
    geocodedAddress?: string;
  }) => void;
  initialLocation?: {
    latitude: number;
    longitude: number;
  };
  address?: string;
}

export default function LocationPicker({
  visible,
  onDismiss,
  onConfirm,
  initialLocation,
  address,
}: LocationPickerProps) {
  const theme = useAppTheme();
  const styles = getStyles(theme);

  const [latitude, setLatitude] = useState(
    initialLocation?.latitude?.toString() || '',
  );
  const [longitude, setLongitude] = useState(
    initialLocation?.longitude?.toString() || '',
  );
  const [geocodedAddress, setGeocodedAddress] = useState(address || '');
  const [latitudeError, setLatitudeError] = useState('');
  const [longitudeError, setLongitudeError] = useState('');

  const validateCoordinates = () => {
    let isValid = true;
    setLatitudeError('');
    setLongitudeError('');

    const lat = parseFloat(latitude);
    const lng = parseFloat(longitude);

    if (!latitude || isNaN(lat)) {
      setLatitudeError('Latitud inv√°lida');
      isValid = false;
    } else if (lat < -90 || lat > 90) {
      setLatitudeError('La latitud debe estar entre -90 y 90');
      isValid = false;
    }

    if (!longitude || isNaN(lng)) {
      setLongitudeError('Longitud inv√°lida');
      isValid = false;
    } else if (lng < -180 || lng > 180) {
      setLongitudeError('La longitud debe estar entre -180 y 180');
      isValid = false;
    }

    return isValid;
  };

  const handleConfirm = () => {
    if (validateCoordinates()) {
      onConfirm({
        latitude: parseFloat(latitude),
        longitude: parseFloat(longitude),
        geocodedAddress: geocodedAddress || undefined,
      });
    }
  };

  const handleUseCurrentLocation = () => {
    Alert.alert(
      'Funci√≥n no disponible',
      'La funci√≥n de mapas est√° temporalmente deshabilitada. Por favor, ingrese las coordenadas manualmente.',
      [{ text: 'OK' }],
    );
  };

  const footerActions = (
    <View style={styles.actions}>
      <Button mode="text" onPress={onDismiss} style={styles.button}>
        Cancelar
      </Button>
      <Button
        mode="contained"
        onPress={handleConfirm}
        disabled={!latitude || !longitude}
        style={styles.button}
      >
        Confirmar
      </Button>
    </View>
  );

  return (
    <ResponsiveModal
      visible={visible}
      onDismiss={onDismiss}
      title="Ubicaci√≥n"
      maxWidthTablet={400}
      scrollable={false}
      footer={footerActions}
    >
      <View style={styles.content}>
        <Text variant="bodyMedium" style={styles.helperText}>
          Ingrese las coordenadas de la ubicaci√≥n o use el bot√≥n para obtener su
          ubicaci√≥n actual.
        </Text>

        <View style={styles.coordinatesRow}>
          <View style={styles.coordinateInput}>
            <TextInput
              mode="outlined"
              label="Latitud"
              value={latitude}
              onChangeText={setLatitude}
              keyboardType="numeric"
              placeholder="19.4326"
              error={!!latitudeError}
            />
            {latitudeError ? (
              <HelperText type="error" visible={!!latitudeError}>
                {latitudeError}
              </HelperText>
            ) : null}
          </View>

          <View style={styles.coordinateInput}>
            <TextInput
              mode="outlined"
              label="Longitud"
              value={longitude}
              onChangeText={setLongitude}
              keyboardType="numeric"
              placeholder="-99.1332"
              error={!!longitudeError}
            />
            {longitudeError ? (
              <HelperText type="error" visible={!!longitudeError}>
                {longitudeError}
              </HelperText>
            ) : null}
          </View>
        </View>

        <Button
          mode="outlined"
          onPress={handleUseCurrentLocation}
          icon="crosshairs-gps"
          style={styles.locationButton}
        >
          Usar mi ubicaci√≥n actual
        </Button>

        <TextInput
          mode="outlined"
          label="Direcci√≥n (opcional)"
          value={geocodedAddress}
          onChangeText={setGeocodedAddress}
          multiline
          numberOfLines={2}
          placeholder="Calle, n√∫mero, colonia, ciudad..."
          style={styles.addressInput}
        />

        {latitude && longitude && !latitudeError && !longitudeError && (
          <View style={styles.previewContainer}>
            <Text variant="labelMedium" style={styles.previewLabel}>
              Vista previa de coordenadas:
            </Text>
            <View style={styles.chipsContainer}>
              <Chip icon="map-marker" compact mode="flat">
                {parseFloat(latitude).toFixed(6)},{' '}
                {parseFloat(longitude).toFixed(6)}
              </Chip>
            </View>
          </View>
        )}
      </View>
    </ResponsiveModal>
  );
}

const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    content: {
      // ResponsiveModal maneja el padding
    },
    helperText: {
      color: theme.colors.onSurfaceVariant,
      marginBottom: theme.spacing.m,
    },
    coordinatesRow: {
      flexDirection: 'row',
      gap: theme.spacing.m,
      marginBottom: theme.spacing.m,
    },
    coordinateInput: {
      flex: 1,
    },
    locationButton: {
      marginBottom: theme.spacing.m,
    },
    addressInput: {
      marginBottom: theme.spacing.m,
    },
    previewContainer: {
      marginTop: theme.spacing.s,
    },
    previewLabel: {
      color: theme.colors.onSurfaceVariant,
      marginBottom: theme.spacing.s,
    },
    chipsContainer: {
      flexDirection: 'row',
      flexWrap: 'wrap',
      gap: theme.spacing.s,
    },
    actions: {
      flexDirection: 'row',
      justifyContent: 'flex-end',
      gap: theme.spacing.s,
      // ResponsiveModal maneja padding, border
    },
    button: {
      minWidth: 100,
    },
  });

================
File: app/src/modules/customers/schema/customer.schema.ts
================
import { z } from 'zod';

// Schema para direcci√≥n
export const addressSchema = z.object({
  name: z.string().min(1, 'El nombre de la direcci√≥n es requerido').max(100),
  street: z.string().min(1, 'La calle es requerida'),
  number: z.string().min(1, 'El n√∫mero es requerido'),
  interiorNumber: z.string().optional(),
  neighborhood: z.string().min(1, 'La colonia es requerida'),
  city: z.string().min(1, 'La ciudad es requerida'),
  state: z.string().min(1, 'El estado es requerido'),
  zipCode: z.string().regex(/^\d{5}$/, 'El c√≥digo postal debe tener 5 d√≠gitos'),
  country: z.string().min(1, 'El pa√≠s es requerido').default('M√©xico'),
  deliveryInstructions: z.string().optional(),
  latitude: z.number().min(-90).max(90).optional(),
  longitude: z.number().min(-180).max(180).optional(),
  isDefault: z.boolean().optional(),
});

// Schema para crear cliente
export const createCustomerSchema = z.object({
  firstName: z.string().min(1, 'El nombre es requerido').max(100),
  lastName: z.string().min(1, 'El apellido es requerido').max(100),
  whatsappPhoneNumber: z.string().min(1, 'El n√∫mero de WhatsApp es requerido'),
  email: z
    .string()
    .email('El correo electr√≥nico no es v√°lido')
    .optional()
    .or(z.literal('')),
  birthDate: z
    .string()
    .regex(/^\d{4}-\d{2}-\d{2}$/, 'La fecha debe tener el formato YYYY-MM-DD')
    .optional()
    .or(z.literal('')),
  isActive: z.boolean().optional(),
  isBanned: z.boolean().optional(),
  addresses: z.array(addressSchema).optional(),
});

// Schema para actualizar cliente
export const updateCustomerSchema = createCustomerSchema.partial();

// Schema para formularios
export const customerFormSchema = z.object({
  firstName: z.string().min(1, 'El nombre es requerido').max(100),
  lastName: z.string().min(1, 'El apellido es requerido').max(100),
  whatsappPhoneNumber: z.string().min(1, 'El n√∫mero de WhatsApp es requerido'),
  email: z
    .string()
    .email('El correo electr√≥nico no es v√°lido')
    .optional()
    .or(z.literal('')),
  birthDate: z
    .string()
    .regex(/^\d{4}-\d{2}-\d{2}$/, 'La fecha debe tener el formato YYYY-MM-DD')
    .optional()
    .or(z.literal('')),
  isActive: z.boolean(),
  isBanned: z.boolean(),
  banReason: z.string().optional().or(z.literal('')),
});

// Types derivados de los schemas
export type AddressFormInputs = z.infer<typeof addressSchema>;
export type CustomerFormInputs = z.infer<typeof customerFormSchema>;
export type CreateCustomerInput = z.infer<typeof createCustomerSchema>;
export type UpdateCustomerInput = z.infer<typeof updateCustomerSchema>;

================
File: app/src/modules/customers/services/addressesService.ts
================
import apiClient from '@/app/services/apiClient';
import { ApiError } from '@/app/lib/errors';
import { API_PATHS } from '@/app/constants/apiPaths';
import {
  Address,
  CreateAddressDto,
  UpdateAddressDto,
} from '../types/customer.types';

async function create(
  customerId: string,
  data: CreateAddressDto,
): Promise<Address> {
  const response = await apiClient.post<Address>(
    API_PATHS.ADDRESSES_BY_CUSTOMER.replace(':customerId', customerId),
    data,
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}

async function update(
  addressId: string,
  data: UpdateAddressDto,
): Promise<Address> {
  const response = await apiClient.patch<Address>(
    API_PATHS.ADDRESSES_BY_ID.replace(':id', addressId),
    data,
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}

async function remove(addressId: string): Promise<void> {
  const response = await apiClient.delete(
    API_PATHS.ADDRESSES_BY_ID.replace(':id', addressId),
  );
  if (!response.ok) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
}

export const addressesService = {
  create,
  update,
  remove,
};

================
File: app/src/modules/customers/types/customer.types.ts
================
export interface ChatMessage {
  role: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: Date;
}

export interface Address {
  id: string;
  name: string;
  street: string;
  number: string;
  interiorNumber?: string;
  neighborhood: string;
  city: string;
  state: string;
  zipCode: string;
  country: string;
  deliveryInstructions?: string;
  latitude?: number;
  longitude?: number;
  isDefault: boolean;
  customerId: string;
  createdAt: Date;
  updatedAt: Date;
  deletedAt?: Date | null;
}

export interface Customer {
  id: string;
  firstName: string;
  lastName: string;
  whatsappPhoneNumber: string;
  stripeCustomerId?: string | null;
  email?: string | null;
  birthDate?: Date | null;
  fullChatHistory?: ChatMessage[] | null;
  relevantChatHistory?: ChatMessage[] | null;
  lastInteraction?: Date | null;
  totalOrders: number;
  totalSpent: number;
  isActive: boolean;
  isBanned: boolean;
  bannedAt?: Date | null;
  banReason?: string | null;
  whatsappMessageCount: number;
  lastWhatsappMessageTime?: Date | null;
  addresses: Address[];
  createdAt: Date;
  updatedAt: Date;
  deletedAt?: Date | null;
}

export interface CreateCustomerDto {
  firstName: string;
  lastName: string;
  whatsappPhoneNumber: string;
  email?: string;
  birthDate?: string;
  isActive?: boolean;
  isBanned?: boolean;
  whatsappMessageCount?: number;
  lastWhatsappMessageTime?: string;
  addresses?: CreateAddressDto[];
}

export interface UpdateCustomerDto {
  firstName?: string;
  lastName?: string;
  whatsappPhoneNumber?: string;
  email?: string | null;
  birthDate?: string | null;
  isActive?: boolean;
  isBanned?: boolean;
  bannedAt?: string;
  banReason?: string | null;
  whatsappMessageCount?: number;
  lastWhatsappMessageTime?: string;
  fullChatHistory?: ChatMessage[];
  relevantChatHistory?: ChatMessage[];
  lastInteraction?: string;
}

export interface CreateAddressDto {
  name: string;
  street: string;
  number: string;
  interiorNumber?: string;
  neighborhood: string;
  city: string;
  state: string;
  zipCode: string;
  country: string;
  deliveryInstructions?: string;
  latitude?: number;
  longitude?: number;
  isDefault?: boolean;
}

export interface UpdateAddressDto {
  name?: string;
  street?: string;
  number?: string;
  interiorNumber?: string;
  neighborhood?: string;
  city?: string;
  state?: string;
  zipCode?: string;
  country?: string;
  deliveryInstructions?: string;
  latitude?: number;
  longitude?: number;
  isDefault?: boolean;
}

export interface FindAllCustomersQuery {
  firstName?: string;
  lastName?: string;
  email?: string;
  whatsappPhoneNumber?: string;
  isActive?: boolean;
  isBanned?: boolean;
  lastInteractionAfter?: Date;
  page?: number;
  limit?: number;
}

================
File: app/src/modules/menu/hooks/useProductsQueries.ts
================
import {
  useQuery,
  useMutation,
  useQueryClient,
  UseQueryResult,
  UseMutationResult,
} from '@tanstack/react-query';
import { productsService } from '../services/productsService';
import {
  Product,
  ProductFormInputs,
  FindAllProductsQuery,
  AssignModifierGroupsInput,
} from '../schema/products.schema';
import { PaginatedResponse } from '@/app/types/api.types';
import { ApiError } from '@/app/lib/errors';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { getApiErrorMessage } from '@/app/lib/errorMapping';

const productKeys = {
  all: ['products'] as const,
  lists: (filters: FindAllProductsQuery) =>
    [...productKeys.all, 'list', filters] as const,
  details: (id: string) => [...productKeys.all, 'detail', id] as const,
  detailModifierGroups: (id: string) =>
    [...productKeys.details(id), 'modifier-groups'] as const,
};

export function useProductsQuery(
  filters: FindAllProductsQuery,
  options?: { enabled?: boolean },
): UseQueryResult<PaginatedResponse<Product>, ApiError> {
  return useQuery<PaginatedResponse<Product>, ApiError>({
    queryKey: productKeys.lists(filters),
    queryFn: () => productsService.findAll(filters),
    enabled: options?.enabled ?? true,
  });
}

export function useProductQuery(
  productId: string,
  options?: { enabled?: boolean },
): UseQueryResult<Product, ApiError> {
  return useQuery<Product, ApiError>({
    queryKey: productKeys.details(productId),
    queryFn: () => productsService.findOne(productId),
    enabled: !!productId && (options?.enabled ?? true),
  });
}

export function useCreateProductMutation(): UseMutationResult<
  Product,
  ApiError,
  ProductFormInputs
> {
  const queryClient = useQueryClient();
  return useMutation<Product, ApiError, ProductFormInputs>({
    mutationFn: (newProduct) => {
      return productsService.create(newProduct);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: productKeys.all });
    },
    onError: () => {},
  });
}

export function useUpdateProductMutation(): UseMutationResult<
  Product,
  ApiError,
  { id: string; data: Partial<ProductFormInputs> },
  { previousProducts?: PaginatedResponse<Product>; previousDetail?: Product }
> {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  type UpdateProductContext = { previousDetail?: Product };

  return useMutation<
    Product,
    ApiError,
    { id: string; data: Partial<ProductFormInputs> },
    UpdateProductContext
  >({
    mutationFn: ({ id, data }) => productsService.update(id, data),

    onMutate: async (variables) => {
      const { id, data } = variables;
      const detailQueryKey = productKeys.details(id);

      await queryClient.cancelQueries({ queryKey: detailQueryKey });

      const previousDetail = queryClient.getQueryData<Product>(detailQueryKey);

      if (previousDetail) {
        queryClient.setQueryData<Product>(
          detailQueryKey,
          (old: Product | undefined) => {
            // A√±adido tipo expl√≠cito
            if (!old) return undefined;
            const { variants, modifierGroupIds, ...restOfData } = data;
            return { ...old, ...restOfData };
          },
        );
      }

      return { previousDetail };
    },

    onError: (error, variables, context) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });

      if (context?.previousDetail) {
        queryClient.setQueryData(
          productKeys.details(variables.id),
          context.previousDetail,
        );
      }
    },

    onSettled: (data, error, _variables) => {
      queryClient.invalidateQueries({ queryKey: productKeys.all });

      if (!error && data) {
        showSnackbar({
          message: 'Producto actualizado con √©xito',
          type: 'success',
        });
      }
    },
  });
}

export function useDeleteProductMutation(): UseMutationResult<
  void,
  ApiError,
  string,
  { previousDetail?: Product }
> {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar); // A√±adir Snackbar

  type DeleteProductContext = { previousDetail?: Product };

  return useMutation<void, ApiError, string, DeleteProductContext>({
    mutationFn: (productId) => productsService.remove(productId),

    onMutate: async (deletedId) => {
      const detailQueryKey = productKeys.details(deletedId);

      await queryClient.cancelQueries({ queryKey: detailQueryKey });

      const previousDetail = queryClient.getQueryData<Product>(detailQueryKey);

      queryClient.removeQueries({ queryKey: detailQueryKey });

      return { previousDetail };
    },

    onError: (error, deletedId, context) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });

      if (context?.previousDetail) {
        queryClient.setQueryData(
          productKeys.details(deletedId),
          context.previousDetail,
        );
      }
    },

    onSettled: (_data, error, deletedId) => {
      queryClient.invalidateQueries({ queryKey: productKeys.all });

      if (!error) {
        queryClient.removeQueries({ queryKey: productKeys.details(deletedId) });
        showSnackbar({
          message: 'Producto eliminado con √©xito',
          type: 'success',
        });
      }
    },
  });
}

export function useAssignModifierGroupsMutation(): UseMutationResult<
  Product,
  ApiError,
  { productId: string; data: AssignModifierGroupsInput }
> {
  const queryClient = useQueryClient();
  return useMutation<
    Product,
    ApiError,
    { productId: string; data: AssignModifierGroupsInput }
  >({
    mutationFn: ({ productId, data }) =>
      productsService.assignModifierGroups(productId, data),
    onSuccess: (updatedProduct) => {
      queryClient.invalidateQueries({
        queryKey: productKeys.details(updatedProduct.id),
      });
      queryClient.invalidateQueries({
        queryKey: productKeys.detailModifierGroups(updatedProduct.id),
      });
    },
  });
}

export function useProductModifierGroupsQuery(
  productId: string,
  options?: { enabled?: boolean },
): UseQueryResult<Product, ApiError> {
  return useQuery<Product, ApiError>({
    queryKey: productKeys.detailModifierGroups(productId),
    queryFn: () => productsService.getModifierGroups(productId),
    enabled: !!productId && (options?.enabled ?? true),
  });
}

export function useRemoveModifierGroupsMutation(): UseMutationResult<
  Product,
  ApiError,
  { productId: string; data: AssignModifierGroupsInput }
> {
  const queryClient = useQueryClient();
  return useMutation<
    Product,
    ApiError,
    { productId: string; data: AssignModifierGroupsInput }
  >({
    mutationFn: ({ productId, data }) =>
      productsService.removeModifierGroups(productId, data),
    onSuccess: (updatedProduct) => {
      queryClient.invalidateQueries({
        queryKey: productKeys.details(updatedProduct.id),
      });
      queryClient.invalidateQueries({
        queryKey: productKeys.detailModifierGroups(updatedProduct.id),
      });
    },
  });
}

================
File: app/src/modules/menu/hooks/useSubcategoriesQueries.ts
================
import {
  useQuery,
  useMutation,
  useQueryClient,
  type UseQueryResult,
  type UseMutationResult,
} from '@tanstack/react-query';
import * as subcategoriesService from '../services/subcategoriesService';
import {
  SubCategory,
  CreateSubCategoryDto,
  UpdateSubCategoryDto,
  findAllSubcategoriesDtoSchema,
} from '../schema/subcategories.schema';
import { z } from 'zod';
import { PaginatedResponse } from '../../../app/types/api.types';
import { ApiError } from '../../../app/lib/errors';
import {
  useSnackbarStore,
  type SnackbarState,
} from '../../../app/store/snackbarStore';
import { getApiErrorMessage } from '../../../app/lib/errorMapping';

type FindAllSubcategoriesDto = z.infer<typeof findAllSubcategoriesDtoSchema>;

const subcategoryKeys = {
  all: ['subcategories'] as const,
  lists: () => [...subcategoryKeys.all, 'list'] as const,
  list: (filters: FindAllSubcategoriesDto) =>
    [...subcategoryKeys.lists(), filters] as const,
  details: () => [...subcategoryKeys.all, 'detail'] as const,
  detail: (id: string) => [...subcategoryKeys.details(), id] as const,
};

export const useFindAllSubcategories = (
  params: FindAllSubcategoriesDto = { page: 1, limit: 10 },
  enabled: boolean = true,
): UseQueryResult<PaginatedResponse<SubCategory>, ApiError> => {
  const queryKey = subcategoryKeys.list(params);
  return useQuery<PaginatedResponse<SubCategory>, ApiError>({
    queryKey: queryKey,
    queryFn: () => subcategoriesService.findAllSubcategories(params),
    enabled: enabled,
  });
};

export const useFindOneSubcategory = (
  id: string | undefined,
  enabled: boolean = true,
): UseQueryResult<SubCategory, ApiError> => {
  const queryKey = subcategoryKeys.detail(id!);
  return useQuery<SubCategory, ApiError>({
    queryKey: queryKey,
    queryFn: () => subcategoriesService.findOneSubcategory(id!),
    enabled: enabled && !!id,
  });
};

type UpdateSubcategoryContext = {
  previousDetail?: SubCategory;
};

export const useCreateSubcategory = (): UseMutationResult<
  SubCategory,
  ApiError,
  CreateSubCategoryDto
> => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore(
    (state: SnackbarState) => state.showSnackbar,
  );

  return useMutation<SubCategory, ApiError, CreateSubCategoryDto>({
    mutationFn: subcategoriesService.createSubcategory,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: subcategoryKeys.lists() });
      showSnackbar({
        message: 'Subcategor√≠a creada con √©xito',
        type: 'success',
      });
    },
    onError: (error) => {
      const message = getApiErrorMessage(error);
      showSnackbar({ message, type: 'error' });
    },
  });
};

export const useUpdateSubcategory = (): UseMutationResult<
  SubCategory,
  ApiError,
  { id: string; data: UpdateSubCategoryDto },
  UpdateSubcategoryContext
> => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore(
    (state: SnackbarState) => state.showSnackbar,
  );

  return useMutation<
    SubCategory,
    ApiError,
    { id: string; data: UpdateSubCategoryDto },
    UpdateSubcategoryContext
  >({
    mutationFn: ({ id, data }) =>
      subcategoriesService.updateSubcategory(id, data),

    onMutate: async (variables) => {
      const { id, data } = variables;
      const detailQueryKey = subcategoryKeys.detail(id);

      await queryClient.cancelQueries({ queryKey: detailQueryKey });

      const previousDetail =
        queryClient.getQueryData<SubCategory>(detailQueryKey);

      if (previousDetail) {
        queryClient.setQueryData<SubCategory>(
          detailQueryKey,
          (
            old: SubCategory | undefined, // A√±adido tipo expl√≠cito
          ) => (old ? { ...old, ...data } : undefined),
        );
      }

      return { previousDetail };
    },

    onError: (error, variables, context) => {
      const message = getApiErrorMessage(error);
      showSnackbar({ message, type: 'error' });

      if (context?.previousDetail) {
        queryClient.setQueryData(
          subcategoryKeys.detail(variables.id),
          context.previousDetail,
        );
      }
    },

    onSettled: (data, error, variables) => {
      queryClient.invalidateQueries({ queryKey: subcategoryKeys.lists() });
      queryClient.invalidateQueries({
        queryKey: subcategoryKeys.detail(variables.id),
      });

      if (!error && data) {
        showSnackbar({
          message: 'Subcategor√≠a actualizada con √©xito',
          type: 'success',
        });
      }
    },
  });
};

export const useRemoveSubcategory = (): UseMutationResult<
  void,
  ApiError,
  string,
  { previousDetail?: SubCategory }
> => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore(
    (state: SnackbarState) => state.showSnackbar,
  );

  type DeleteSubcategoryContext = { previousDetail?: SubCategory };

  return useMutation<void, ApiError, string, DeleteSubcategoryContext>({
    mutationFn: subcategoriesService.removeSubcategory,

    onMutate: async (deletedId) => {
      const detailQueryKey = subcategoryKeys.detail(deletedId);

      await queryClient.cancelQueries({ queryKey: detailQueryKey });

      const previousDetail =
        queryClient.getQueryData<SubCategory>(detailQueryKey);

      queryClient.removeQueries({ queryKey: detailQueryKey });

      return { previousDetail };
    },

    onError: (error, deletedId, context) => {
      const message = getApiErrorMessage(error);
      showSnackbar({ message, type: 'error' });

      if (context?.previousDetail) {
        queryClient.setQueryData(
          subcategoryKeys.detail(deletedId),
          context.previousDetail,
        );
      }
    },

    onSettled: (_data, error, deletedId) => {
      queryClient.invalidateQueries({ queryKey: subcategoryKeys.lists() });

      if (!error) {
        queryClient.removeQueries({
          queryKey: subcategoryKeys.detail(deletedId),
        });
        showSnackbar({
          message: 'Subcategor√≠a eliminada con √©xito',
          type: 'success',
        });
      }
    },
  });
};

================
File: app/src/modules/menu/services/subcategoriesService.ts
================
import ApiClientWrapper from '../../../app/services/apiClientWrapper';
import { ApiError } from '../../../app/lib/errors';
import { API_PATHS } from '../../../app/constants/apiPaths';
import {
  SubCategory,
  CreateSubCategoryDto,
  UpdateSubCategoryDto,
  findAllSubcategoriesDtoSchema,
} from '../schema/subcategories.schema';
import { z } from 'zod';
import { PaginatedResponse } from '../../../app/types/api.types';

type FindAllSubcategoriesDto = z.infer<typeof findAllSubcategoriesDtoSchema>;

export const createSubcategory = async (
  data: CreateSubCategoryDto,
): Promise<SubCategory> => {
  const response = await ApiClientWrapper.post<SubCategory>(
    API_PATHS.SUBCATEGORIES,
    data,
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
};

export const findAllSubcategories = async (
  params: FindAllSubcategoriesDto,
): Promise<PaginatedResponse<SubCategory>> => {
  const queryParams = Object.entries(params).reduce(
    (acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = value;
      }
      return acc;
    },
    {} as Record<string, any>,
  );

  const response = await ApiClientWrapper.get<{
    items: SubCategory[];
    total: number;
    page: number;
    limit: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  }>(API_PATHS.SUBCATEGORIES, queryParams);

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }

  // Transforma la respuesta del backend a PaginatedResponse
  return {
    data: response.data.items,
    total: response.data.total,
    page: response.data.page,
    limit: response.data.limit,
    totalPages: Math.ceil(response.data.total / response.data.limit),
  };
};

export const findOneSubcategory = async (id: string): Promise<SubCategory> => {
  const response = await ApiClientWrapper.get<SubCategory>(
    API_PATHS.SUBCATEGORIES_BY_ID.replace(':id', id),
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
};

export const updateSubcategory = async (
  id: string,
  data: UpdateSubCategoryDto,
): Promise<SubCategory> => {
  const response = await ApiClientWrapper.patch<SubCategory>(
    API_PATHS.SUBCATEGORIES_BY_ID.replace(':id', id),
    data,
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
};

export const removeSubcategory = async (id: string): Promise<void> => {
  const response = await ApiClientWrapper.delete(
    API_PATHS.SUBCATEGORIES_BY_ID.replace(':id', id),
  );
  if (!response.ok) {
    if (response.data) {
      // Hay un cuerpo de error definido por el backend
      throw ApiError.fromApiResponse(response.data, response.status);
    } else if (response.status !== 404) {
      // No hay cuerpo de error, pero no es un 404 esperado
      throw new Error(
        `Error deleting subcategory ${id}: Status ${response.status}`,
      );
    }
    // Si es 404, no se lanza error.
  }
  // No se devuelve nada en caso de √©xito (204) o 404.
};

================
File: app/src/modules/modifiers/components/ModifierFormModal.tsx
================
import React, { useMemo, useCallback } from 'react';
import { z } from 'zod';
import { useMutation, useQueryClient } from '@tanstack/react-query';

import { useSnackbarStore } from '@/app/store/snackbarStore';
import { getApiErrorMessage } from '@/app/lib/errorMapping';
import GenericFormModal, {
  FormFieldConfig,
} from '@/app/components/crud/GenericFormModal';
import { modifierService } from '../services/modifierService';
import { ModifierFormInputs } from '../types/modifier.types';
import {
  Modifier,
  modifierFormValidationSchema, // Cambiado de modifierSchema
  CreateModifierInput,
  UpdateModifierInput,
} from '../schema/modifier.schema';

interface Props {
  visible: boolean;
  onDismiss: () => void;
  onSaveSuccess: () => void;
  initialData?: Modifier | null;
  groupId: string;
}

const formFields: FormFieldConfig<ModifierFormInputs>[] = [
  { name: 'name', label: 'Nombre *', type: 'text', required: true },
  {
    name: 'description',
    label: 'Descripci√≥n (Opcional)',
    type: 'textarea',
    numberOfLines: 3,
  },
  {
    name: 'price',
    label: 'Precio Adicional (Opcional)',
    type: 'number',
    inputProps: { keyboardType: 'numeric' },
  },
  {
    name: 'sortOrder',
    label: 'Orden de Visualizaci√≥n',
    type: 'number',
    defaultValue: 0,
    inputProps: { keyboardType: 'numeric' },
  },
  {
    name: 'isDefault',
    label: 'Seleccionado por Defecto',
    type: 'switch',
    defaultValue: false,
  },
  { name: 'isActive', label: 'Activo', type: 'switch', defaultValue: true },
];

const formSchema = modifierFormValidationSchema;

const ModifierFormModal: React.FC<Props> = ({
  visible,
  onDismiss,
  onSaveSuccess,
  initialData,
  groupId,
}) => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const isEditing = !!initialData;
  const QUERY_KEY_TO_INVALIDATE = ['modifiers', groupId];

  const mutation = useMutation<
    Modifier,
    Error,
    CreateModifierInput | UpdateModifierInput
  >({
    mutationFn: (data) => {
      if (isEditing && initialData) {
        return modifierService.update(
          initialData.id,
          data as UpdateModifierInput,
        );
      } else {
        return modifierService.create(data as CreateModifierInput);
      }
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: QUERY_KEY_TO_INVALIDATE });
      showSnackbar({
        message: `Modificador "${data.name}" ${isEditing ? 'actualizado' : 'creado'} correctamente`,
        type: 'success',
      });
      onSaveSuccess();
    },
    onError: (error) => {
      const message = getApiErrorMessage(error);
      showSnackbar({ message, type: 'error' });
      // Error al guardar modificador
    },
  });

  const handleFormSubmit = useCallback(
    async (formData: ModifierFormInputs) => {
      const dataToSend: CreateModifierInput | UpdateModifierInput = {
        ...formData,
        price:
          formData.price === undefined || isNaN(Number(formData.price))
            ? null
            : Number(formData.price),
        description:
          formData.description === undefined ? null : formData.description,
        sortOrder: formData.sortOrder ?? 0,
        isDefault: formData.isDefault ?? false,
        isActive: formData.isActive ?? true,
        modifierGroupId: groupId,
      };

      try {
        await mutation.mutateAsync(dataToSend);
      } catch (error) {
        // Fallo en la mutaci√≥n al enviar el formulario
      }
    },
    [
      mutation,
      groupId,
      isEditing,
      initialData?.id,
      onSaveSuccess,
      queryClient,
      showSnackbar,
    ],
  );

  return (
    <GenericFormModal<ModifierFormInputs, Modifier>
      visible={visible}
      onDismiss={onDismiss}
      onSubmit={handleFormSubmit}
      formSchema={formSchema as z.ZodSchema<ModifierFormInputs>}
      formFields={formFields}
      editingItem={initialData ?? null}
      isSubmitting={mutation.isPending}
      modalTitle={(isEditing) =>
        isEditing ? 'Editar Modificador' : 'Crear Nuevo Modificador'
      }
      initialValues={useMemo(
        () =>
          initialData
            ? {
                name: initialData.name,
                description: initialData.description,
                price: initialData.price,
                sortOrder: initialData.sortOrder,
                isDefault: initialData.isDefault,
                isActive: initialData.isActive,
              }
            : {
                name: '',
                description: null,
                price: null,
                sortOrder: 0,
                isDefault: false,
                isActive: true,
              },
        [initialData],
      )}
    />
  );
};

export default ModifierFormModal;

================
File: app/src/modules/orders/hooks/useMenuQueries.ts
================
import { useQuery } from '@tanstack/react-query';
import { useEffect } from 'react';
// Importar desde el servicio de categor√≠as
import { getOrderMenu } from '@/modules/menu/services/categoryService';
// Importar el tipo de men√∫ completo con relaciones anidadas
import type { FullMenuCategory } from '@/modules/orders/types/orders.types';
import { ApiError } from '@/app/lib/errors';
import { prefetchMenuImages } from '@/app/lib/imageCache';

// Define clave √∫nica para la query
const orderMenuQueryKey = ['orderMenu'];

/**
 * Hook para obtener el men√∫ en pantallas de creaci√≥n y edici√≥n de √≥rdenes.
 * Devuelve solo los campos necesarios para mejorar el rendimiento.
 */
export function useGetOrderMenu() {
  const query = useQuery<FullMenuCategory[], ApiError>({
    queryKey: orderMenuQueryKey,
    queryFn: getOrderMenu,
    refetchInterval: 10000, // Actualizar cada 10 segundos
    refetchIntervalInBackground: false, // No actualizar cuando la app est√° en background
    refetchOnWindowFocus: true,
    refetchOnMount: true,
    staleTime: 5000, // Los datos se consideran frescos por 5 segundos
    // IMPORTANTE: Mantener datos previos durante refetch para evitar parpadeos
    keepPreviousData: true,
    // No mostrar loading en refetch para mantener la UI estable
    notifyOnChangeProps: ['data', 'error'],
  });

  // Prefetch de im√°genes cuando se cargan los datos del men√∫
  useEffect(() => {
    if (query.data && query.data.length > 0) {
      // Prefetch en background sin bloquear la UI
      prefetchMenuImages(query.data, {
        maxConcurrent: 3, // Limitar concurrencia para no saturar la red
      }).catch(() => {
        // Silenciar errores de prefetch para no afectar la UX
      });
    }
  }, [query.data]);

  return query;
}

================
File: app/src/modules/orders/services/adjustmentService.ts
================
import apiClient from '@/app/services/apiClient';
import { handleApiResponse } from '@/app/lib/apiHelpers';
import { API_PATHS } from '@/app/constants/apiPaths';
import type { Adjustment } from '@/app/schemas/domain/adjustment.schema';
import type { OrderAdjustmentDto } from '../types/update-order.types';

export const adjustmentService = {
  /**
   * Crea m√∫ltiples ajustes para una orden
   */
  createBulkAdjustments: async (
    adjustments: OrderAdjustmentDto[],
  ): Promise<Adjustment[]> => {
    const response = await apiClient.post<Adjustment[]>(
      API_PATHS.ADJUSTMENTS + '/bulk',
      adjustments,
    );
    return handleApiResponse(response);
  },

  /**
   * Obtiene los ajustes de una orden
   */
  getOrderAdjustments: async (orderId: string): Promise<Adjustment[]> => {
    const response = await apiClient.get<Adjustment[]>(
      API_PATHS.ADJUSTMENTS + '/order/' + orderId,
    );
    return handleApiResponse(response);
  },

  /**
   * Elimina un ajuste (solo admin)
   */
  deleteAdjustment: async (adjustmentId: string): Promise<void> => {
    const response = await apiClient.delete<void>(
      API_PATHS.ADJUSTMENTS_BY_ID.replace(':id', adjustmentId),
    );
    return handleApiResponse(response);
  },

  /**
   * Obtiene el total de ajustes de una orden
   */
  getOrderAdjustmentsTotal: async (
    orderId: string,
  ): Promise<{ total: number }> => {
    const response = await apiClient.get<{ total: number }>(
      API_PATHS.ADJUSTMENTS + '/order/' + orderId + '/total',
    );
    return handleApiResponse(response);
  },
};

================
File: app/src/modules/orders/types/payment.types.ts
================
export enum PaymentMethodEnum {
  CASH = 'CASH',
  CARD = 'CARD', // Fusionado cr√©dito y d√©bito
  TRANSFER = 'TRANSFER',
}

export enum PaymentStatusEnum {
  PENDING = 'PENDING',
  COMPLETED = 'COMPLETED',
  FAILED = 'FAILED',
  REFUNDED = 'REFUNDED',
  CANCELLED = 'CANCELLED',
}

export type PaymentMethod = keyof typeof PaymentMethodEnum;
export type PaymentStatus = keyof typeof PaymentStatusEnum;

export interface Payment {
  id: string;
  orderId: string;
  paymentMethod: PaymentMethod;
  amount: number;
  paymentStatus: PaymentStatus;
  createdAt: string;
  updatedAt: string;
  order?: {
    id: string;
    shiftOrderNumber: number;
    total: number;
  };
}

export interface CreatePaymentDto {
  orderId: string;
  paymentMethod: PaymentMethod;
  amount: number;
}

export interface UpdatePaymentDto {
  paymentMethod?: PaymentMethod;
  amount?: number;
  paymentStatus?: PaymentStatus;
}

================
File: app/src/modules/pizzaCustomizations/components/AssociatePizzaToppingsModal.tsx
================
import React, { useState, useEffect, useMemo } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Portal,
  Modal,
  Text,
  Checkbox,
  Button,
  IconButton,
  Chip,
  Divider,
  ActivityIndicator,
} from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { productsService } from '@/modules/menu/services/productsService';
import { pizzaCustomizationsService } from '../services/pizzaCustomizationsService';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { CustomizationType } from '../types/pizzaCustomization.types';
import type { Product } from '@/modules/menu/schema/products.schema';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';

interface AssociatePizzaToppingsModalProps {
  visible: boolean;
  onDismiss: () => void;
  product: Product | null;
}

export function AssociatePizzaToppingsModal({
  visible,
  onDismiss,
  product,
}: AssociatePizzaToppingsModalProps) {
  const theme = useAppTheme();
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const [selectedToppings, setSelectedToppings] = useState<Set<string>>(
    new Set(),
  );
  const [hasChanges, setHasChanges] = useState(false);
  const [filterType, setFilterType] = useState<
    'all' | 'flavors' | 'ingredients'
  >('all');
  const [showConfirmation, setShowConfirmation] = useState(false);

  // Query para obtener todos los toppings (sabores e ingredientes)
  const { data: allToppings, isLoading: isLoadingToppings } = useQuery({
    queryKey: ['pizza-toppings-modal'],
    queryFn: async () => {
      const response = await pizzaCustomizationsService.findAll({
        page: 1,
        limit: 100,
        isActive: true,
      });
      return response.data || [];
    },
    enabled: visible,
  });

  // Query para obtener los toppings asociados al producto
  const { data: associatedToppings, isLoading: isLoadingAssociated } = useQuery(
    {
      queryKey: ['product-pizza-toppings', product?.id],
      queryFn: async () => {
        if (!product?.id) return [];
        const result = await productsService.getPizzaCustomizations(product.id);
        return result || [];
      },
      enabled: !!product?.id && visible,
    },
  );

  // Inicializar selecciones cuando se cargan los datos
  useEffect(() => {
    if (associatedToppings && visible && product) {
      const associatedIds = new Set(associatedToppings.map((t) => t.id));
      setSelectedToppings(associatedIds);
      setHasChanges(false);
    }
  }, [associatedToppings, visible, product]);

  // Mutation para actualizar asociaciones
  const updateMutation = useMutation({
    mutationFn: async () => {
      if (!product) throw new Error('No hay producto seleccionado');

      await productsService.updatePizzaCustomizations(
        product.id,
        Array.from(selectedToppings),
      );
    },
    onSuccess: () => {
      showSnackbar({
        message: 'Sabores e ingredientes actualizados exitosamente',
        type: 'success',
      });
      queryClient.invalidateQueries({
        queryKey: ['product-pizza-toppings', product?.id],
      });
      queryClient.invalidateQueries({ queryKey: ['pizza-products'] });
      queryClient.invalidateQueries({ queryKey: ['pizza-configurations'] });
      setHasChanges(false);
      onDismiss();
    },
    onError: (error) => {
      showSnackbar({
        message: error instanceof Error ? error.message : 'Error al actualizar',
        type: 'error',
      });
    },
  });

  const toggleTopping = (toppingId: string) => {
    setSelectedToppings((prev) => {
      const newSet = new Set(prev);
      if (newSet.has(toppingId)) {
        newSet.delete(toppingId);
      } else {
        newSet.add(toppingId);
      }
      return newSet;
    });
    setHasChanges(true);
  };

  const toggleAll = () => {
    if (!allToppings) return;

    if (selectedToppings.size === allToppings.length) {
      setSelectedToppings(new Set());
    } else {
      setSelectedToppings(new Set(allToppings.map((t) => t.id)));
    }
    setHasChanges(true);
  };

  const filteredToppings = useMemo(() => {
    if (!allToppings || !Array.isArray(allToppings)) {
      return {
        flavors: [],
        ingredients: [],
        displayFlavors: [],
        displayIngredients: [],
      };
    }

    const flavors = allToppings.filter(
      (t) => t.type === CustomizationType.FLAVOR,
    );
    const ingredients = allToppings.filter(
      (t) => t.type === CustomizationType.INGREDIENT,
    );

    return {
      flavors,
      ingredients,
      displayFlavors: filterType === 'ingredients' ? [] : flavors,
      displayIngredients: filterType === 'flavors' ? [] : ingredients,
    };
  }, [allToppings, filterType]);

  const isLoading = isLoadingToppings || isLoadingAssociated;

  const styles = StyleSheet.create({
    modal: {
      backgroundColor: theme.colors.background,
      margin: theme.spacing.m,
      marginTop: theme.spacing.xl * 2,
      borderRadius: theme.roundness * 2,
      height: '90%',
      maxHeight: '90%',
    },
    header: {
      backgroundColor: theme.colors.elevation.level1,
      borderTopLeftRadius: theme.roundness * 2,
      borderTopRightRadius: theme.roundness * 2,
      paddingHorizontal: theme.spacing.m,
      paddingTop: theme.spacing.m,
      paddingBottom: theme.spacing.s,
    },
    headerContent: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
    },
    titleContainer: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    titleIcon: {
      margin: 0,
      marginRight: theme.spacing.xs,
    },
    title: {
      fontSize: 20,
      fontWeight: '700',
      color: theme.colors.onSurface,
    },
    subtitle: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
      marginTop: theme.spacing.xs,
      marginLeft: theme.spacing.xl + theme.spacing.m,
    },
    closeButton: {
      margin: 0,
    },
    filterContainer: {
      backgroundColor: theme.colors.background,
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.m,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    filterButtons: {
      flexDirection: 'row',
      gap: theme.spacing.xs,
      justifyContent: 'space-between',
    },
    filterChip: {
      flex: 1,
      backgroundColor: theme.colors.surface,
      borderColor: theme.colors.outlineVariant,
      height: 32,
    },
    filterChipActive: {
      backgroundColor: theme.colors.primaryContainer,
      borderColor: theme.colors.primary,
    },
    filterChipText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    filterChipTextActive: {
      color: theme.colors.primary,
      fontWeight: '600',
    },
    content: {
      flex: 1,
      minHeight: 200,
    },
    scrollContent: {
      padding: theme.spacing.m,
      paddingBottom: theme.spacing.xl * 2,
    },
    selectAllContainer: {
      marginBottom: theme.spacing.l,
      paddingTop: theme.spacing.s,
    },
    selectAllButton: {
      borderRadius: theme.roundness,
      marginBottom: theme.spacing.xs,
    },
    selectAllContent: {
      paddingVertical: theme.spacing.xs,
    },
    selectionCount: {
      fontSize: 13,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      textAlign: 'center',
      marginTop: theme.spacing.xs,
    },
    section: {
      marginBottom: theme.spacing.l,
    },
    sectionTitle: {
      fontSize: 14,
      fontWeight: '700',
      color: theme.colors.onSurface,
      marginBottom: theme.spacing.m,
      marginTop: theme.spacing.m,
      textTransform: 'uppercase',
      letterSpacing: 1,
    },
    toppingItem: {
      marginBottom: theme.spacing.xs,
    },
    checkbox: {
      paddingVertical: theme.spacing.s,
      paddingHorizontal: 0,
      marginHorizontal: 0,
    },
    checkboxLabel: {
      textAlign: 'left',
      marginLeft: theme.spacing.xs,
    },
    ingredientsText: {
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      marginLeft: theme.spacing.xl * 2,
      marginTop: -theme.spacing.xs,
      marginBottom: theme.spacing.s,
      fontSize: 12,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      minHeight: 200,
    },
    emptyState: {
      padding: theme.spacing.xl,
      alignItems: 'center',
    },
    emptyText: {
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
    },
    actions: {
      flexDirection: 'row',
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.m,
      gap: theme.spacing.m,
    },
    actionButton: {
      flex: 1,
      borderWidth: 1,
      borderColor: theme.colors.outline,
    },
    cancelButton: {
      borderColor: theme.colors.outlineVariant,
    },
    saveButton: {
      borderWidth: 0,
    },
  });

  if (!product) return null;

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={() => {
          if (hasChanges) {
            setShowConfirmation(true);
          } else {
            onDismiss();
          }
        }}
        contentContainerStyle={styles.modal}
        dismissable={true}
      >
        <View style={styles.header}>
          <View style={styles.headerContent}>
            <View style={styles.titleContainer}>
              <IconButton
                icon="food-variant"
                size={20}
                iconColor={theme.colors.primary}
                style={styles.titleIcon}
              />
              <Text style={styles.title}>Personalizar Producto</Text>
            </View>
            <IconButton
              icon="close"
              size={24}
              onPress={() => {
                if (hasChanges) {
                  setShowConfirmation(true);
                } else {
                  onDismiss();
                }
              }}
              style={styles.closeButton}
            />
          </View>
          <Text style={styles.subtitle}>{product.name}</Text>
        </View>

        <View style={styles.filterContainer}>
          <View style={styles.filterButtons}>
            <Chip
              mode={filterType === 'all' ? 'flat' : 'outlined'}
              onPress={() => setFilterType('all')}
              style={[
                styles.filterChip,
                filterType === 'all' && styles.filterChipActive,
              ]}
              textStyle={[
                styles.filterChipText,
                filterType === 'all' && styles.filterChipTextActive,
              ]}
              icon="format-list-bulleted"
              compact
            >
              Todos
            </Chip>
            <Chip
              mode={filterType === 'flavors' ? 'flat' : 'outlined'}
              onPress={() => setFilterType('flavors')}
              style={[
                styles.filterChip,
                filterType === 'flavors' && styles.filterChipActive,
              ]}
              textStyle={[
                styles.filterChipText,
                filterType === 'flavors' && styles.filterChipTextActive,
              ]}
              icon="pizza"
              compact
            >
              Sabores
            </Chip>
            <Chip
              mode={filterType === 'ingredients' ? 'flat' : 'outlined'}
              onPress={() => setFilterType('ingredients')}
              style={[
                styles.filterChip,
                filterType === 'ingredients' && styles.filterChipActive,
              ]}
              textStyle={[
                styles.filterChipText,
                filterType === 'ingredients' && styles.filterChipTextActive,
              ]}
              icon="food-variant"
              compact
            >
              Ingredientes
            </Chip>
          </View>
        </View>

        <View style={styles.content}>
          {isLoading ? (
            <View style={styles.loadingContainer}>
              <ActivityIndicator size="large" color={theme.colors.primary} />
            </View>
          ) : (
            <ScrollView
              contentContainerStyle={styles.scrollContent}
              showsVerticalScrollIndicator={true}
            >
              <View style={styles.selectAllContainer}>
                <Button
                  mode="contained-tonal"
                  onPress={toggleAll}
                  style={styles.selectAllButton}
                  icon={
                    selectedToppings.size === allToppings?.length
                      ? 'checkbox-marked'
                      : 'checkbox-blank-outline'
                  }
                  contentStyle={styles.selectAllContent}
                >
                  {selectedToppings.size === allToppings?.length
                    ? 'Quitar selecci√≥n'
                    : 'Seleccionar todo'}
                </Button>
                <Text style={styles.selectionCount}>
                  {selectedToppings.size} de {allToppings?.length || 0}{' '}
                  seleccionados
                </Text>
              </View>

              {filteredToppings.displayFlavors.length > 0 && (
                <View style={styles.section}>
                  <Text style={styles.sectionTitle}>
                    Sabores ({filteredToppings.displayFlavors.length})
                  </Text>
                  {filteredToppings.displayFlavors.map((flavor) => (
                    <View key={flavor.id} style={styles.toppingItem}>
                      <Checkbox.Item
                        label={flavor.name}
                        status={
                          selectedToppings.has(flavor.id)
                            ? 'checked'
                            : 'unchecked'
                        }
                        onPress={() => toggleTopping(flavor.id)}
                        labelStyle={styles.checkboxLabel}
                        style={styles.checkbox}
                        position="leading"
                      />
                      {flavor.ingredients && (
                        <Text style={styles.ingredientsText}>
                          {flavor.ingredients}
                        </Text>
                      )}
                    </View>
                  ))}
                </View>
              )}

              {filteredToppings.displayIngredients.length > 0 && (
                <View style={styles.section}>
                  <Text style={styles.sectionTitle}>
                    Ingredientes ({filteredToppings.displayIngredients.length})
                  </Text>
                  {filteredToppings.displayIngredients.map((ingredient) => (
                    <View key={ingredient.id} style={styles.toppingItem}>
                      <Checkbox.Item
                        label={ingredient.name}
                        status={
                          selectedToppings.has(ingredient.id)
                            ? 'checked'
                            : 'unchecked'
                        }
                        onPress={() => toggleTopping(ingredient.id)}
                        labelStyle={styles.checkboxLabel}
                        style={styles.checkbox}
                        position="leading"
                      />
                    </View>
                  ))}
                </View>
              )}

              {filteredToppings.displayFlavors.length === 0 &&
                filteredToppings.displayIngredients.length === 0 && (
                  <View style={styles.emptyState}>
                    <Text style={styles.emptyText}>
                      No hay sabores ni ingredientes disponibles
                    </Text>
                  </View>
                )}
            </ScrollView>
          )}
        </View>

        <Divider />

        <View>
          <View style={styles.actions}>
            <Button
              mode="outlined"
              onPress={() => {
                if (hasChanges) {
                  setShowConfirmation(true);
                } else {
                  onDismiss();
                }
              }}
              style={[styles.actionButton, styles.cancelButton]}
              contentStyle={{ paddingVertical: 6 }}
            >
              Cancelar
            </Button>
            <Button
              mode="contained"
              onPress={() => updateMutation.mutate()}
              loading={updateMutation.isPending}
              disabled={!hasChanges}
              style={[styles.actionButton, styles.saveButton]}
              contentStyle={{ paddingVertical: 6 }}
            >
              Guardar
            </Button>
          </View>
        </View>
      </Modal>

      <ConfirmationModal
        visible={showConfirmation}
        title="¬øSalir sin guardar?"
        message="Los cambios se perder√°n"
        confirmText="Salir"
        cancelText="Cancelar"
        confirmButtonColor={theme.colors.error}
        onConfirm={() => {
          setShowConfirmation(false);
          setHasChanges(false);
          onDismiss();
        }}
        onCancel={() => setShowConfirmation(false)}
        onDismiss={() => setShowConfirmation(false)}
      />
    </Portal>
  );
}

================
File: app/src/modules/pizzaCustomizations/components/PizzaCustomizationCard.tsx
================
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Card, Text, Chip } from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import {
  CustomizationType,
  type PizzaCustomization,
} from '../types/pizzaCustomization.types';

interface PizzaCustomizationCardProps {
  customization: PizzaCustomization;
  onPress: () => void;
}

export function PizzaCustomizationCard({
  customization,
  onPress,
}: PizzaCustomizationCardProps) {
  const theme = useAppTheme();

  const styles = StyleSheet.create({
    card: {
      marginBottom: theme.spacing.s,
    },
    content: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingVertical: -4,
    },
    info: {
      flex: 1,
    },
    name: {
      ...theme.fonts.titleMedium,
      color: theme.colors.onSurface,
      marginBottom: 2,
    },
    ingredients: {
      ...theme.fonts.bodySmall,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      lineHeight: 16,
    },
    chip: {
      marginRight: theme.spacing.xs,
      height: 24,
    },
    rightSection: {
      alignItems: 'flex-end',
      marginLeft: theme.spacing.s,
    },
    toppingValue: {
      ...theme.fonts.titleLarge,
      color: theme.colors.primary,
      fontWeight: 'bold',
    },
    toppingLabel: {
      ...theme.fonts.labelSmall,
      color: theme.colors.onSurfaceVariant,
      marginTop: -2,
    },
  });

  const getTypeLabel = (type: CustomizationType) => {
    return type === CustomizationType.FLAVOR ? 'Sabor' : 'Ingrediente';
  };

  const getTypeIcon = (type: CustomizationType) => {
    return type === CustomizationType.FLAVOR ? 'pizza' : 'food-variant';
  };

  return (
    <Card style={styles.card} onPress={onPress} mode="contained">
      <Card.Content style={{ paddingVertical: 12, paddingHorizontal: 16 }}>
        <View style={styles.content}>
          <View style={styles.info}>
            <View
              style={{
                flexDirection: 'row',
                alignItems: 'center',
                marginBottom: 4,
              }}
            >
              <Text style={styles.name}>{customization.name}</Text>
              <Chip
                icon={getTypeIcon(customization.type)}
                style={[styles.chip, { marginLeft: theme.spacing.s }]}
                compact
                textStyle={{ fontSize: 11 }}
              >
                {getTypeLabel(customization.type)}
              </Chip>
              {!customization.isActive && (
                <Chip
                  icon="eye-off"
                  style={[styles.chip, { marginLeft: theme.spacing.xs }]}
                  compact
                  mode="outlined"
                  textStyle={{ fontSize: 11 }}
                >
                  Inactivo
                </Chip>
              )}
            </View>

            {customization.ingredients && (
              <Text style={styles.ingredients} numberOfLines={1}>
                {customization.ingredients}
              </Text>
            )}
          </View>

          <View style={styles.rightSection}>
            <Text style={styles.toppingValue}>
              {customization.toppingValue}
            </Text>
            <Text style={styles.toppingLabel}>
              topping{customization.toppingValue !== 1 ? 's' : ''}
            </Text>
          </View>
        </View>
      </Card.Content>
    </Card>
  );
}

================
File: app/src/modules/pizzaCustomizations/screens/PizzaManagementScreen.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, Pressable } from 'react-native';
import { FAB, Text, Icon } from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useAppTheme } from '@/app/styles/theme';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';

// Importar las tabs
import {
  PizzaProductsTab,
  PizzaCustomizationsTab,
  PizzaCustomizationFormModal,
} from '../components';

export function PizzaManagementScreen() {
  const theme = useAppTheme();
  const [selectedTab, setSelectedTab] = useState('products');
  const [formModalVisible, setFormModalVisible] = useState(false);

  // Refrescar datos de pizzas cuando la pantalla recibe foco
  useRefreshModuleOnFocus('pizza-products');
  useRefreshModuleOnFocus('pizza-customizations');

  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    header: {
      backgroundColor: theme.colors.elevation.level2,
      elevation: 0,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    tabsContainer: {
      flexDirection: 'row',
      height: 48,
    },
    tab: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      paddingHorizontal: theme.spacing.m,
      gap: theme.spacing.xs,
    },
    tabActive: {
      borderBottomWidth: 2,
      borderBottomColor: theme.colors.primary,
    },
    tabText: {
      fontSize: 14,
      fontWeight: '500',
      color: theme.colors.onSurfaceVariant,
    },
    tabTextActive: {
      color: theme.colors.primary,
      fontWeight: '600',
    },
    tabIcon: {
      marginRight: 4,
    },
    content: {
      flex: 1,
    },
    fab: {
      position: 'absolute',
      margin: 16,
      right: 0,
      bottom: 0,
      backgroundColor: theme.colors.primary,
    },
  });

  // Renderizar contenido seg√∫n tab seleccionada
  const renderContent = () => {
    switch (selectedTab) {
      case 'products':
        return <PizzaProductsTab />;
      case 'customizations':
        return <PizzaCustomizationsTab />;
      default:
        return null;
    }
  };

  return (
    <SafeAreaView style={styles.container} edges={['bottom']}>
      <View style={styles.header}>
        <View style={styles.tabsContainer}>
          <Pressable
            style={[styles.tab, selectedTab === 'products' && styles.tabActive]}
            onPress={() => setSelectedTab('products')}
          >
            <Icon
              source="pizza"
              size={20}
              color={
                selectedTab === 'products'
                  ? theme.colors.primary
                  : theme.colors.onSurfaceVariant
              }
            />
            <Text
              style={[
                styles.tabText,
                selectedTab === 'products' && styles.tabTextActive,
              ]}
            >
              Productos
            </Text>
          </Pressable>

          <Pressable
            style={[
              styles.tab,
              selectedTab === 'customizations' && styles.tabActive,
            ]}
            onPress={() => setSelectedTab('customizations')}
          >
            <Icon
              source="cheese"
              size={20}
              color={
                selectedTab === 'customizations'
                  ? theme.colors.primary
                  : theme.colors.onSurfaceVariant
              }
            />
            <Text
              style={[
                styles.tabText,
                selectedTab === 'customizations' && styles.tabTextActive,
              ]}
            >
              Ingredientes
            </Text>
          </Pressable>
        </View>
      </View>

      <View style={styles.content}>{renderContent()}</View>

      {selectedTab === 'customizations' && (
        <FAB
          icon="plus"
          style={styles.fab}
          onPress={() => setFormModalVisible(true)}
          color={theme.colors.onPrimary}
        />
      )}

      <PizzaCustomizationFormModal
        visible={formModalVisible}
        onDismiss={() => setFormModalVisible(false)}
        onSuccess={() => {
          // La tab se actualizar√° autom√°ticamente cuando reciba el foco
        }}
      />
    </SafeAreaView>
  );
}

================
File: app/src/modules/pizzaCustomizations/services/pizzaConfigurationsService.ts
================
import apiClient from '@/app/services/apiClient';
import { ApiError } from '@/app/lib/errors';
import { API_PATHS } from '@/app/constants/apiPaths';
import type { PizzaConfiguration } from '../types/pizzaConfiguration.types';
import type {
  PizzaConfigurationFormInputs,
  UpdatePizzaConfigurationInputs,
} from '../schema/pizzaConfiguration.schema';

async function findByProductId(
  productId: string,
): Promise<PizzaConfiguration | null> {
  const response = await apiClient.get<PizzaConfiguration>(
    API_PATHS.PIZZA_CONFIGURATIONS + '/product/' + productId,
  );

  if (response.status === 404) {
    return null;
  }

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }

  return response.data;
}

async function create(
  data: PizzaConfigurationFormInputs,
): Promise<PizzaConfiguration> {
  const response = await apiClient.post<PizzaConfiguration>(
    API_PATHS.PIZZA_CONFIGURATIONS,
    data,
  );

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }

  return response.data;
}

async function update(
  id: string,
  data: UpdatePizzaConfigurationInputs,
): Promise<PizzaConfiguration> {
  const response = await apiClient.patch<PizzaConfiguration>(
    API_PATHS.PIZZA_CONFIGURATIONS_BY_ID.replace(':id', id),
    data,
  );

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }

  return response.data;
}

async function remove(id: string): Promise<void> {
  const response = await apiClient.delete(
    API_PATHS.PIZZA_CONFIGURATIONS_BY_ID.replace(':id', id),
  );

  if (!response.ok) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
}

export const pizzaConfigurationsService = {
  findByProductId,
  create,
  update,
  remove,
};

================
File: app/src/modules/pizzaCustomizations/services/pizzaCustomizationsService.ts
================
import apiClient from '@/app/services/apiClient';
import { ApiError } from '@/app/lib/errors';
import { API_PATHS } from '@/app/constants/apiPaths';
import type { PaginatedResponse } from '@/app/types/api.types';
import type { PizzaCustomization } from '../types/pizzaCustomization.types';
import type {
  PizzaCustomizationFormInputs,
  FindAllPizzaCustomizationsQuery,
} from '../schema/pizzaCustomization.schema';

async function findAll(
  params?: FindAllPizzaCustomizationsQuery,
): Promise<PaginatedResponse<PizzaCustomization>> {
  const response = await apiClient.get<{
    items: PizzaCustomization[];
    total: number;
    page: number;
    limit: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  }>(API_PATHS.PIZZA_CUSTOMIZATIONS, params);

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }

  return {
    data: response.data.items,
    total: response.data.total,
    page: response.data.page,
    limit: response.data.limit,
    totalPages: Math.ceil(response.data.total / response.data.limit),
  };
}

async function findOne(id: string): Promise<PizzaCustomization> {
  const response = await apiClient.get<PizzaCustomization>(
    API_PATHS.PIZZA_CUSTOMIZATIONS_BY_ID.replace(':id', id),
  );

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }

  return response.data;
}

async function create(
  data: PizzaCustomizationFormInputs,
): Promise<PizzaCustomization> {
  const response = await apiClient.post<PizzaCustomization>(
    API_PATHS.PIZZA_CUSTOMIZATIONS,
    data,
  );

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }

  return response.data;
}

async function update(
  id: string,
  data: Partial<PizzaCustomizationFormInputs>,
): Promise<PizzaCustomization> {
  const response = await apiClient.patch<PizzaCustomization>(
    API_PATHS.PIZZA_CUSTOMIZATIONS_BY_ID.replace(':id', id),
    data,
  );

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }

  return response.data;
}

async function remove(id: string): Promise<void> {
  const response = await apiClient.delete(
    API_PATHS.PIZZA_CUSTOMIZATIONS_BY_ID.replace(':id', id),
  );

  if (!response.ok) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
}

async function updateSortOrder(
  updates: { id: string; sortOrder: number }[],
): Promise<void> {
  const response = await apiClient.patch(
    API_PATHS.PIZZA_CUSTOMIZATIONS_SORT_ORDER,
    { updates },
  );

  if (!response.ok) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
}

export const pizzaCustomizationsService = {
  findAll,
  findOne,
  create,
  update,
  remove,
  updateSortOrder,
};

================
File: app/src/modules/preparationScreens/components/PreparationScreenDetailModalSimple.tsx
================
import React, { useMemo } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Text,
  Button,
  Chip,
  ActivityIndicator,
  IconButton,
  Divider,
} from 'react-native-paper';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { PreparationScreen } from '../schema/preparationScreen.schema';
import { ResponsiveModal } from '@/app/components/responsive/ResponsiveModal';

interface PreparationScreenDetailModalProps {
  visible: boolean;
  onDismiss: () => void;
  item: PreparationScreen | null;
  onEdit?: (item: PreparationScreen) => void;
  onDelete?: (id: string) => void;
  onManageProducts?: (item: PreparationScreen) => void;
  isDeleting?: boolean;
}

const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    descriptionContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: theme.spacing.m,
      paddingBottom: theme.spacing.m,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    iconContainer: {
      width: 48,
      height: 48,
      borderRadius: 24,
      justifyContent: 'center',
      alignItems: 'center',
      marginRight: theme.spacing.m,
    },
    description: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
      flex: 1,
      marginLeft: theme.spacing.m,
    },
    statusChip: {
      marginLeft: theme.spacing.s,
    },
    section: {
      padding: theme.spacing.m,
    },
    sectionTitle: {
      fontSize: 16,
      fontWeight: '600',
      marginBottom: theme.spacing.m,
      color: theme.colors.onSurface,
    },
    infoRow: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingVertical: theme.spacing.s,
    },
    infoIcon: {
      marginRight: theme.spacing.m,
    },
    infoText: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
      flex: 1,
    },
    userChip: {
      marginRight: theme.spacing.xs,
      marginBottom: theme.spacing.xs,
    },
    userChipsContainer: {
      flexDirection: 'row',
      flexWrap: 'wrap',
      marginTop: theme.spacing.s,
    },
    productCard: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      padding: theme.spacing.m,
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: theme.roundness,
      marginTop: theme.spacing.s,
    },
    productInfo: {
      flex: 1,
    },
    productCount: {
      fontSize: 24,
      fontWeight: 'bold',
      color: theme.colors.primary,
    },
    productLabel: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    emptyState: {
      alignItems: 'center',
      paddingVertical: theme.spacing.l,
    },
    emptyText: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 14,
      marginTop: theme.spacing.s,
    },
    actionContainer: {
      // ResponsiveModal maneja padding y background
    },
    actionButtons: {
      flexDirection: 'row',
      gap: theme.spacing.m,
    },
    actionButton: {
      flex: 1,
      borderRadius: theme.roundness,
    },
    loadingContainer: {
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.xl * 2,
    },
  });

const PreparationScreenDetailModal: React.FC<
  PreparationScreenDetailModalProps
> = ({
  visible,
  onDismiss,
  item,
  onEdit,
  onDelete,
  onManageProducts,
  isDeleting = false,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => getStyles(theme), [theme]);

  const handleEdit = () => {
    if (onEdit && item) {
      onEdit(item);
    }
  };

  const handleDelete = () => {
    if (onDelete && item) {
      onDelete(item.id);
    }
  };

  // Get color based on screen name
  const getColor = () => {
    if (!item) return theme.colors.primary;
    const name = item.name.toLowerCase();
    if (name.includes('pizza')) return '#FF6B6B';
    if (name.includes('hamburguesa')) return '#4ECDC4';
    if (name.includes('bar')) return '#667EEA';
    return theme.colors.primary;
  };

  // Get icon based on screen name
  const getIcon = () => {
    if (!item) return 'monitor-dashboard';
    const name = item.name.toLowerCase();
    if (name.includes('pizza')) return 'pizza';
    if (name.includes('hamburguesa')) return 'hamburger';
    if (name.includes('bar')) return 'glass-cocktail';
    return 'monitor-dashboard';
  };

  const renderContent = () => {
    if (!item) {
      return (
        <View style={styles.loadingContainer}>
          <ActivityIndicator
            animating={true}
            size="large"
            color={theme.colors.primary}
          />
        </View>
      );
    }

    const userCount = item.users?.length || 0;
    const productCount = item.products?.length || 0;
    const color = getColor();

    return (
      <>
        {/* Informaci√≥n adicional del header */}
        {item.description && (
          <View style={styles.descriptionContainer}>
            <View
              style={[styles.iconContainer, { backgroundColor: `${color}20` }]}
            >
              <Icon name={getIcon()} size={24} color={color} />
            </View>
            <Text style={styles.description} numberOfLines={2}>
              {item.description}
            </Text>
          </View>
        )}

        {/* Secci√≥n de usuarios */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>
            <Icon name="account-group" size={16} /> Usuarios Asignados (
            {userCount})
          </Text>

          {userCount > 0 ? (
            <View style={styles.userChipsContainer}>
              {item.users?.map((user: any) => (
                <Chip
                  key={user.id}
                  style={styles.userChip}
                  icon="account"
                  compact
                  mode="outlined"
                >
                  {`${user.firstName || ''} ${user.lastName || ''}`.trim() ||
                    user.username}
                </Chip>
              ))}
            </View>
          ) : (
            <View style={styles.emptyState}>
              <Icon
                name="account-off-outline"
                size={32}
                color={theme.colors.onSurfaceVariant}
              />
              <Text style={styles.emptyText}>Sin usuarios asignados</Text>
            </View>
          )}
        </View>

        <Divider />

        {/* Secci√≥n de productos */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>
            <Icon name="food" size={16} /> Productos Asociados
          </Text>

          <View style={styles.productCard}>
            <View style={styles.productInfo}>
              <Text style={styles.productCount}>{productCount}</Text>
              <Text style={styles.productLabel}>
                {productCount === 1 ? 'Producto' : 'Productos'}
              </Text>
            </View>

            {onManageProducts && (
              <Button
                mode="contained-tonal"
                onPress={() => onManageProducts(item)}
                icon="link-variant"
                compact
              >
                Gestionar
              </Button>
            )}
          </View>
        </View>
      </>
    );
  };

  const headerActions = item && (
    <View style={{ flexDirection: 'row', alignItems: 'center' }}>
      <Chip
        mode="flat"
        compact
        style={styles.statusChip}
        textStyle={{ fontSize: 12 }}
        selected={item.isActive}
      >
        {item.isActive ? 'Activa' : 'Inactiva'}
      </Chip>
    </View>
  );

  const footerActions = item && (
    <View style={styles.actionContainer}>
      <View style={styles.actionButtons}>
        {onEdit && (
          <Button
            icon="pencil"
            mode="contained"
            onPress={() => onEdit(item)}
            disabled={isDeleting}
            style={styles.actionButton}
            buttonColor={theme.colors.primary}
          >
            Editar
          </Button>
        )}
        {onDelete && (
          <Button
            icon="delete"
            mode="contained-tonal"
            onPress={() => onDelete(item.id)}
            loading={isDeleting}
            disabled={isDeleting}
            style={styles.actionButton}
            buttonColor={theme.colors.errorContainer}
            textColor={theme.colors.error}
          >
            Eliminar
          </Button>
        )}
      </View>
    </View>
  );

  return (
    <ResponsiveModal
      visible={visible}
      onDismiss={onDismiss}
      title={item?.name}
      headerActions={headerActions}
      hideCloseButton={isDeleting}
      dismissable={!isDeleting}
      maxHeightTablet="90%"
      scrollable={true}
      footer={footerActions}
    >
      {renderContent()}
    </ResponsiveModal>
  );
};

export default PreparationScreenDetailModal;

================
File: app/src/modules/preparationScreens/components/PreparationScreenListItem.tsx
================
import React from 'react';
import { View, StyleSheet, Pressable } from 'react-native';
import { Text, Chip, IconButton, Surface } from 'react-native-paper';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { PreparationScreen } from '../schema/preparationScreen.schema';

interface PreparationScreenListItemProps {
  item: PreparationScreen;
  onPress: (item: PreparationScreen) => void;
  onManageProducts?: (item: PreparationScreen) => void;
}

const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      marginHorizontal: theme.spacing.m,
      marginVertical: theme.spacing.s,
      borderRadius: theme.roundness * 2,
      overflow: 'hidden',
      elevation: 2,
      backgroundColor: theme.colors.surface,
    },
    pressable: {
      borderRadius: theme.roundness * 2,
    },
    colorBar: {
      position: 'absolute',
      left: 0,
      right: 0,
      top: 0,
      height: 6,
    },
    content: {
      padding: theme.spacing.m,
    },
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      marginBottom: theme.spacing.s,
    },
    titleContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
    },
    iconContainer: {
      width: 48,
      height: 48,
      borderRadius: 24,
      justifyContent: 'center',
      alignItems: 'center',
      marginRight: theme.spacing.m,
    },
    title: {
      fontSize: 18,
      fontWeight: '600',
      color: theme.colors.onSurface,
      flex: 1,
    },
    statusChip: {
      paddingHorizontal: theme.spacing.s,
    },
    description: {
      color: theme.colors.onSurfaceVariant,
      marginBottom: theme.spacing.m,
      lineHeight: 20,
    },
    footer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingTop: theme.spacing.m,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
    },
    statsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.l,
    },
    stat: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
    },
    statIcon: {
      opacity: 0.7,
    },
    statText: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    actionButton: {
      margin: -8,
    },
  });

const PreparationScreenListItem: React.FC<PreparationScreenListItemProps> = ({
  item,
  onPress,
  onManageProducts,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => getStyles(theme), [theme]);

  const userCount = item.users?.length || 0;
  const productCount = item.products?.length || 0;
  const isActive = item.isActive ?? true;

  // Get gradient colors based on screen name
  const getGradientColors = () => {
    const name = item.name.toLowerCase();
    if (name.includes('pizza')) {
      return ['#FF6B6B', '#FF8E53'];
    } else if (name.includes('hamburguesa')) {
      return ['#4ECDC4', '#44A08D'];
    } else if (name.includes('bar')) {
      return ['#667EEA', '#764BA2'];
    }
    return [theme.colors.primary, theme.colors.secondary];
  };

  // Get icon based on screen name
  const getIcon = () => {
    const name = item.name.toLowerCase();
    if (name.includes('pizza')) return 'pizza';
    if (name.includes('hamburguesa')) return 'hamburger';
    if (name.includes('bar')) return 'glass-cocktail';
    return 'monitor-dashboard';
  };

  const gradientColors = getGradientColors();

  return (
    <Surface style={styles.container}>
      <Pressable
        style={styles.pressable}
        onPress={() => onPress(item)}
        android_ripple={{ borderless: false }}
      >
        <View
          style={[styles.colorBar, { backgroundColor: gradientColors[0] }]}
        />

        <View style={styles.content}>
          <View style={styles.header}>
            <View style={styles.titleContainer}>
              <View
                style={[
                  styles.iconContainer,
                  { backgroundColor: `${gradientColors[0]}20` },
                ]}
              >
                <Icon name={getIcon()} size={24} color={gradientColors[0]} />
              </View>
              <Text style={styles.title} numberOfLines={1}>
                {item.name}
              </Text>
            </View>

            <Chip
              mode="flat"
              compact
              style={[
                styles.statusChip,
                {
                  backgroundColor: isActive
                    ? theme.colors.successContainer
                    : theme.colors.surfaceVariant,
                },
              ]}
              textStyle={{
                color: isActive
                  ? theme.colors.onSuccessContainer
                  : theme.colors.onSurfaceVariant,
                fontSize: 12,
              }}
            >
              {isActive ? 'Activa' : 'Inactiva'}
            </Chip>
          </View>

          {item.description && (
            <Text style={styles.description} numberOfLines={2}>
              {item.description}
            </Text>
          )}

          <View style={styles.footer}>
            <View style={styles.statsContainer}>
              <View style={styles.stat}>
                <Icon
                  name="account-group"
                  size={16}
                  color={theme.colors.onSurfaceVariant}
                  style={styles.statIcon}
                />
                <Text style={styles.statText}>
                  {userCount} {userCount === 1 ? 'usuario' : 'usuarios'}
                </Text>
              </View>

              <View style={styles.stat}>
                <Icon
                  name="food"
                  size={16}
                  color={theme.colors.onSurfaceVariant}
                  style={styles.statIcon}
                />
                <Text style={styles.statText}>
                  {productCount} {productCount === 1 ? 'producto' : 'productos'}
                </Text>
              </View>
            </View>

            {onManageProducts && (
              <IconButton
                icon="link-variant"
                size={20}
                onPress={() => onManageProducts(item)}
                style={styles.actionButton}
              />
            )}
          </View>
        </View>
      </Pressable>
    </Surface>
  );
};

export default PreparationScreenListItem;

================
File: app/src/modules/printers/components/PrinterDiscoveryModal.tsx
================
import React, { useEffect, useMemo } from 'react';
import { View, StyleSheet } from 'react-native'; // FlatList eliminado
import { FlashList, ListRenderItemInfo } from '@shopify/flash-list'; // Importar FlashList y tipo
import {
  Modal,
  Portal,
  Text,
  ActivityIndicator,
  List,
  Icon, // A√±adir Icon a la importaci√≥n
  Divider,
  IconButton,
  Appbar, // Importar Appbar
} from 'react-native-paper';
import {
  useDiscoverPrinters,
  useTestPrintDiscoveredPrinter,
} from '../hooks/usePrintersQueries';
import { DiscoveredPrinter } from '../types/printer.types';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { getApiErrorMessage } from '@/app/lib/errorMapping';

interface PrinterDiscoveryModalProps {
  visible: boolean;
  onDismiss: () => void;
  onPrinterSelect: (printer: DiscoveredPrinter) => void; // Callback cuando se selecciona una impresora
}

const PrinterDiscoveryModal: React.FC<PrinterDiscoveryModalProps> = ({
  visible,
  onDismiss,
  onPrinterSelect,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const discoverMutation = useDiscoverPrinters();
  const testPrintMutation = useTestPrintDiscoveredPrinter();

  useEffect(() => {
    if (visible) {
      discoverMutation.mutate(undefined, {
        // undefined para usar la duraci√≥n por defecto
        onError: (error) => {
          showSnackbar({
            message: `Error descubriendo impresoras: ${getApiErrorMessage(error)}`,
            type: 'error',
          });
        },
      });
    }
  }, [visible, discoverMutation, showSnackbar]); // Ejecutar solo cuando 'visible' cambia

  const handleRescan = () => {
    discoverMutation.mutate(undefined); // Volver a escanear con duraci√≥n por defecto
  };

  const handleTestPrint = (printer: DiscoveredPrinter) => {
    testPrintMutation.mutate(printer);
  };

  const renderPrinterItem = (
    { item }: ListRenderItemInfo<DiscoveredPrinter>, // A√±adir tipo
  ) => (
    <List.Item
      title={item.name || item.ip} // Mostrar nombre o IP si no hay nombre
      description={`IP: ${item.ip}:${item.port}${item.mac ? ` | MAC: ${item.mac}` : ''}${item.model ? ` (${item.model})` : ''}`}
      left={(props) => <List.Icon {...props} icon="printer" />}
      right={(props) => (
        <View style={styles.itemActions}>
          <IconButton
            {...props}
            icon="printer-check"
            size={24}
            onPress={() => handleTestPrint(item)}
            disabled={testPrintMutation.isPending}
            loading={
              testPrintMutation.isPending &&
              testPrintMutation.variables?.ip === item.ip
            }
            tooltip="Imprimir prueba"
          />
          <IconButton
            {...props}
            icon="plus"
            size={24}
            onPress={() => onPrinterSelect(item)}
            disabled={testPrintMutation.isPending}
            tooltip="Agregar impresora"
          />
        </View>
      )}
      style={styles.listItem}
      titleStyle={styles.itemTitle}
      descriptionStyle={styles.itemDescription}
    />
  );

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalContent}
        dismissable={
          !discoverMutation.isPending && !testPrintMutation.isPending
        } // No permitir cerrar mientras busca o imprime
      >
        <Appbar.Header style={styles.appBar} elevated>
          <Appbar.BackAction
            onPress={onDismiss}
            disabled={discoverMutation.isPending || testPrintMutation.isPending}
          />
          <Appbar.Content
            title="Descubrir Impresoras"
            titleStyle={styles.appBarTitle}
          />
          {/* Bot√≥n de Refrescar/Re-escanear */}
          <Appbar.Action
            icon="refresh"
            size={32} // <-- Aumentar tama√±o del icono
            onPress={handleRescan}
            disabled={discoverMutation.isPending || testPrintMutation.isPending}
            color={theme.colors.primary} // Color distintivo
          />
        </Appbar.Header>

        <View style={styles.contentContainer}>
          {discoverMutation.isPending && (
            <View style={styles.centeredView}>
              <ActivityIndicator animating={true} size="large" />
              <Text style={styles.statusText}>
                Buscando impresoras en la red...
              </Text>
              <Text style={styles.statusSubText}>
                (Esto puede tardar unos segundos)
              </Text>
            </View>
          )}

          {discoverMutation.isError && !discoverMutation.isPending && (
            <View style={styles.centeredView}>
              <Icon
                source="alert-circle-outline"
                color={theme.colors.error}
                size={48}
              />
              <Text style={styles.errorText}>
                Error al buscar impresoras:{' '}
                {getApiErrorMessage(discoverMutation.error)}
              </Text>
              {/* Bot√≥n eliminado, se usa el icono en Appbar */}
            </View>
          )}

          {discoverMutation.isSuccess && !discoverMutation.isPending && (
            <>
              {discoverMutation.data.length === 0 ? (
                <View style={styles.centeredView}>
                  <Icon
                    source="printer-off"
                    color={theme.colors.onSurfaceVariant}
                    size={48}
                  />
                  <Text style={styles.statusText}>
                    No se encontraron impresoras.
                  </Text>
                  <Text style={styles.statusSubText}>
                    Aseg√∫rate de que est√©n encendidas y en la misma red.
                  </Text>
                  {/* Bot√≥n eliminado, se usa el icono en Appbar */}
                </View>
              ) : (
                <>
                  {/* Texto estilizado */}
                  <Text style={styles.foundText}>Impresoras encontradas:</Text>
                  <FlashList
                    data={discoverMutation.data}
                    renderItem={renderPrinterItem}
                    keyExtractor={(item: DiscoveredPrinter) =>
                      `${item.ip}:${item.port}`
                    } // A√±adir tipo y clave √∫nica
                    estimatedItemSize={70} // A√±adir tama√±o estimado
                    ItemSeparatorComponent={() => (
                      <Divider style={styles.divider} />
                    )}
                  />
                  {/* Bot√≥n eliminado, se usa el icono en Appbar */}
                </>
              )}
            </>
          )}
        </View>

        {/* Footer eliminado, se usa Appbar.BackAction */}
      </Modal>
    </Portal>
  );
};

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    modalContent: {
      backgroundColor: theme.colors.background,

      width: '100%',
      height: '100%',
      margin: 0,

      justifyContent: 'flex-start', // Alinear contenido arriba
    },
    appBar: {
      backgroundColor: theme.colors.elevation.level2,
    },
    appBarTitle: {
      ...theme.fonts.titleMedium,
      color: theme.colors.onSurface,
      fontWeight: 'bold',
      textAlign: 'center', // Centrar t√≠tulo
    },
    contentContainer: {
      flex: 1, // Ocupar espacio restante
      padding: theme.spacing.m,
    },
    centeredView: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.l,
    },
    statusText: {
      marginTop: theme.spacing.m,
      fontSize: 16,
      textAlign: 'center',
      color: theme.colors.onSurface,
    },
    statusSubText: {
      marginTop: theme.spacing.xs,
      fontSize: 14,
      textAlign: 'center',
      color: theme.colors.onSurfaceVariant,
    },
    errorText: {
      marginTop: theme.spacing.m,
      color: theme.colors.error,
      textAlign: 'center',
      marginBottom: theme.spacing.m,
    },
    foundText: {
      fontSize: 16,
      fontWeight: 'bold',
      marginBottom: theme.spacing.m,
      color: theme.colors.primary, // Color primario para destacar
    },
    list: {
      flex: 1, // Permitir que la lista ocupe espacio
      marginBottom: theme.spacing.m, // Espacio antes del bot√≥n de re-escanear
    },
    listItem: {
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness,
      marginBottom: theme.spacing.xs,
    },
    itemTitle: {
      fontWeight: '500',
    },
    itemDescription: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    itemActions: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    divider: {
      height: 0, // Ocultar divider si no se desea
    },
    button: {
      marginTop: theme.spacing.m,
      minWidth: 150, // Ancho m√≠nimo para botones
    },
    // Estilo footer eliminado
  });

export default PrinterDiscoveryModal;

================
File: app/src/modules/printers/components/PrinterListItem.tsx
================
import React from 'react';
import { View, StyleSheet, Pressable } from 'react-native';
import { Text, Surface, Icon, Chip } from 'react-native-paper';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { ThermalPrinter } from '../types/printer.types';

interface PrinterListItemProps {
  printer: ThermalPrinter;
  onPress: () => void;
  renderActions?: React.ReactNode;
}

const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      marginHorizontal: theme.spacing.m,
      marginVertical: theme.spacing.xs,
      borderRadius: theme.roundness * 2,
      overflow: 'hidden',
      elevation: 2,
    },
    pressable: {
      padding: theme.spacing.m,
    },
    content: {
      gap: theme.spacing.s,
    },
    header: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    titleRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
      flex: 1,
      marginRight: 60, // Espacio reservado para el bot√≥n de ping (52px + margen)
    },
    printerIcon: {
      backgroundColor: theme.colors.primaryContainer,
      borderRadius: theme.roundness,
      padding: theme.spacing.xs,
    },
    titleContainer: {
      flex: 1,
    },
    title: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    connectionInfo: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
    },
    statusBadge: {
      backgroundColor: theme.colors.surface,
      borderWidth: 1,
    },
    activeBadge: {
      borderColor: theme.colors.primary,
    },
    inactiveBadge: {
      borderColor: theme.colors.error,
    },
    detailsContainer: {
      flexDirection: 'row',
      flexWrap: 'wrap',
      gap: theme.spacing.xs,
      marginTop: theme.spacing.xs,
      marginRight: 60, // Espacio reservado para el bot√≥n de ping
    },
    detailChip: {
      height: 24,
      backgroundColor: theme.colors.surfaceVariant,
    },
    detailChipLabel: {
      fontSize: 11,
      marginHorizontal: 8,
      marginVertical: 0,
    },
    featuresRow: {
      flexDirection: 'row',
      gap: theme.spacing.xs,
      marginTop: theme.spacing.xs,
      marginRight: 60, // Espacio reservado para el bot√≥n de ping
    },
    featureChip: {
      height: 28,
      backgroundColor: theme.colors.secondaryContainer,
    },
    featureChipLabel: {
      fontSize: 12,
      marginHorizontal: 10,
      marginVertical: 0,
      color: theme.colors.onSecondaryContainer,
    },
    actionsContainer: {
      position: 'absolute',
      right: theme.spacing.m,
      top: theme.spacing.m,
    },
  });

const PrinterListItem: React.FC<PrinterListItemProps> = ({
  printer,
  onPress,
  renderActions,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => getStyles(theme), [theme]);

  const getConnectionDisplay = () => {
    if (printer.connectionType === 'NETWORK' && printer.ipAddress) {
      return `${printer.ipAddress}:${printer.port || 9100}`;
    }
    return printer.connectionType;
  };

  const hasAutoPrintFeatures =
    printer.autoDeliveryPrint || printer.autoPickupPrint;

  return (
    <Surface style={styles.container}>
      <Pressable
        style={styles.pressable}
        onPress={onPress}
        android_ripple={{ color: theme.colors.primary + '20' }}
      >
        <View style={styles.content}>
          <View style={styles.header}>
            <View style={styles.titleRow}>
              <View style={styles.printerIcon}>
                <Icon
                  source="printer"
                  size={20}
                  color={theme.colors.onPrimaryContainer}
                />
              </View>
              <View style={styles.titleContainer}>
                <Text style={styles.title}>{printer.name}</Text>
                <Text style={styles.connectionInfo}>
                  {getConnectionDisplay()}
                </Text>
              </View>
            </View>
            {renderActions && (
              <View style={styles.actionsContainer}>{renderActions}</View>
            )}
          </View>

          <View style={styles.detailsContainer}>
            <Chip
              mode="flat"
              style={[
                styles.statusBadge,
                printer.isActive ? styles.activeBadge : styles.inactiveBadge,
              ]}
              textStyle={[
                styles.detailChipLabel,
                {
                  color: printer.isActive
                    ? theme.colors.primary
                    : theme.colors.error,
                },
              ]}
            >
              {printer.isActive ? 'Activa' : 'Inactiva'}
            </Chip>

            {printer.isDefaultPrinter && (
              <Chip
                mode="flat"
                style={styles.detailChip}
                textStyle={styles.detailChipLabel}
                icon="star"
              >
                Predeterminada
              </Chip>
            )}

            <Chip
              mode="flat"
              style={styles.detailChip}
              textStyle={styles.detailChipLabel}
              icon="file-document-outline"
            >
              {printer.paperWidth}mm
            </Chip>
          </View>

          {hasAutoPrintFeatures && (
            <View style={styles.featuresRow}>
              {printer.autoDeliveryPrint && (
                <Chip
                  mode="flat"
                  style={styles.featureChip}
                  textStyle={styles.featureChipLabel}
                  icon="home-export-outline"
                >
                  Auto Domicilio
                </Chip>
              )}
              {printer.autoPickupPrint && (
                <Chip
                  mode="flat"
                  style={styles.featureChip}
                  textStyle={styles.featureChipLabel}
                  icon="bag-checked"
                >
                  Auto Para Llevar
                </Chip>
              )}
            </View>
          )}
        </View>
      </Pressable>
    </Surface>
  );
};

export default PrinterListItem;

================
File: app/src/modules/shared/components/OrderHistoryModal.tsx
================
import React, { useCallback, useMemo, useState, useEffect } from 'react';
import {
  View,
  StyleSheet,
  FlatList,
  ActivityIndicator,
  TouchableOpacity,
  Platform,
} from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Divider,
  Chip,
  Button,
  Avatar,
  Surface,
} from 'react-native-paper';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import { useAppTheme } from '@/app/styles/theme';
import { useQuery } from '@tanstack/react-query';
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';

interface HistoryItem {
  id: string | number;
  orderId: string;
  orderItemId?: string;
  operation: 'INSERT' | 'UPDATE' | 'DELETE' | 'BATCH';
  changedBy: string;
  changedAt: string;
  diff?: Record<string, any> | null;
  snapshot?: Record<string, any>;
  productId?: string;
  preparationStatus?: string;
  changedByUser?: {
    id?: string;
    firstName: string;
    lastName: string;
  };
  user?: {
    firstName: string;
    lastName: string;
  };
  itemDescription?: string;
  formattedChanges?: Record<string, any>;
  batchOperations?: any[];
  type: 'order' | 'item';
}

interface OrderHistoryModalProps {
  visible: boolean;
  onDismiss: () => void;
  orderId: string | null;
  orderNumber?: number;
}

// Helper para obtener el icono de la operaci√≥n
const getOperationIcon = (
  operation: string,
  type: 'order' | 'item' = 'item',
) => {
  if (type === 'order') {
    return 'receipt';
  }
  switch (operation) {
    case 'INSERT':
      return 'plus-circle';
    case 'UPDATE':
      return 'pencil';
    case 'DELETE':
      return 'delete';
    case 'BATCH':
      return 'folder-multiple';
    default:
      return 'information';
  }
};

// Helper para obtener el label de la operaci√≥n
const getOperationLabel = (
  operation: string,
  type: 'order' | 'item' = 'item',
) => {
  if (type === 'order') {
    const orderOperationMap: Record<string, string> = {
      INSERT: 'Orden creada',
      UPDATE: 'Orden modificada',
      DELETE: 'Orden eliminada',
    };
    return orderOperationMap[operation] || operation;
  }

  const operationMap: Record<string, string> = {
    INSERT: 'Item agregado',
    UPDATE: 'Item modificado',
    DELETE: 'Item eliminado',
    BATCH: 'Cambios m√∫ltiples',
  };
  return operationMap[operation] || operation;
};

// Helper para obtener el color del status
const getStatusColor = (status: string, theme: any) => {
  switch (status) {
    case 'PENDING':
      return theme.colors.error;
    case 'IN_PROGRESS':
    case 'IN_PREPARATION':
      return theme.colors.warning;
    case 'READY':
    case 'DELIVERED':
    case 'COMPLETED':
      return theme.colors.success;
    case 'CANCELLED':
      return theme.colors.onSurfaceVariant;
    default:
      return theme.colors.onSurface;
  }
};

// Helper para formatear nombres de campos
const formatFieldName = (field: string): string => {
  const fieldMap: Record<string, string> = {
    orderStatus: 'Estado de la orden',
    orderType: 'Tipo de orden',
    tableId: 'Mesa',
    table: 'Mesa',
    notes: 'Notas',
    deliveryInfo: 'Informaci√≥n de entrega',
    scheduledAt: 'Programado para',
    customerId: 'Cliente',
    isFromWhatsApp: 'Orden de WhatsApp',
    // Campos dentro de deliveryInfo
    recipientName: 'Destinatario',
    recipientPhone: 'Tel√©fono',
    fullAddress: 'Direcci√≥n completa',
    deliveryInstructions: 'Instrucciones de entrega',
    street: 'Calle',
    number: 'N√∫mero',
    neighborhood: 'Colonia',
    city: 'Ciudad',
    state: 'Estado',
    zipCode: 'C√≥digo postal',
  };
  return fieldMap[field] || field;
};

// Helper para formatear valores
const formatValue = (field: string, value: any): string => {
  if (value === null || value === undefined) return 'Sin valor';

  if (field === 'orderStatus' || field === 'preparationStatus') {
    const statusMap: Record<string, string> = {
      PENDING: 'Pendiente',
      IN_PROGRESS: 'En Progreso',
      IN_PREPARATION: 'En Preparaci√≥n',
      READY: 'Lista',
      DELIVERED: 'Entregada',
      COMPLETED: 'Completada',
      CANCELLED: 'Cancelada',
    };
    return statusMap[value] || value;
  }

  if (field === 'orderType') {
    const typeMap: Record<string, string> = {
      DINE_IN: 'Para Comer Aqu√≠',
      TAKE_AWAY: 'Para Llevar',
      DELIVERY: 'Domicilio',
    };
    return typeMap[value] || value;
  }

  if (field === 'table' || field === 'tableId') {
    if (typeof value === 'object' && value !== null) {
      return value.name || 'Sin mesa';
    }
    return value || 'Sin mesa';
  }

  // Para datos de entrega
  if (field === 'recipientName') {
    return value || 'Sin nombre';
  }

  if (field === 'recipientPhone') {
    return value || 'Sin tel√©fono';
  }

  if (field === 'fullAddress') {
    return value || 'Sin direcci√≥n';
  }

  if (field === 'isFromWhatsApp') {
    return value ? 'S√≠' : 'No';
  }

  if (field === 'customerId') {
    return value || 'Sin cliente registrado';
  }

  if (field === 'scheduledAt') {
    return value
      ? format(new Date(value), 'dd/MM/yyyy HH:mm', { locale: es })
      : 'No programado';
  }

  return String(value);
};

// Componente para cada item del historial
const HistoryItemComponent: React.FC<{
  item: HistoryItem;
  theme: ReturnType<typeof useAppTheme>;
}> = ({ item, theme }) => {
  const [expanded, setExpanded] = useState(false);
  const styles = useMemo(() => createStyles(theme), [theme]);

  const renderChangeDetail = (change: any, fieldName?: string) => {
    if (
      change &&
      typeof change === 'object' &&
      change.anterior !== undefined &&
      change.nuevo !== undefined
    ) {
      // Para descripci√≥n del item, mostrar en formato vertical si es muy largo
      if (
        (fieldName === 'Descripci√≥n del Item' || fieldName === 'Descripci√≥n') &&
        (String(change.anterior).length > 30 ||
          String(change.nuevo).length > 30)
      ) {
        return (
          <View style={{ marginTop: 4 }}>
            <View
              style={{
                backgroundColor: theme.colors.errorContainer,
                padding: 8,
                borderRadius: 6,
                marginBottom: 8,
              }}
            >
              <Text
                variant="labelSmall"
                style={{
                  color: theme.colors.onErrorContainer,
                  fontWeight: '600',
                  marginBottom: 4,
                }}
              >
                Antes:
              </Text>
              <Text
                variant="bodySmall"
                style={{ color: theme.colors.onErrorContainer }}
              >
                {String(change.anterior)}
              </Text>
            </View>
            <View
              style={{
                backgroundColor: theme.colors.primaryContainer,
                padding: 8,
                borderRadius: 6,
              }}
            >
              <Text
                variant="labelSmall"
                style={{
                  color: theme.colors.onPrimaryContainer,
                  fontWeight: '600',
                  marginBottom: 4,
                }}
              >
                Despu√©s:
              </Text>
              <Text
                variant="bodySmall"
                style={{ color: theme.colors.onPrimaryContainer }}
              >
                {String(change.nuevo)}
              </Text>
            </View>
          </View>
        );
      }

      // Formato horizontal para cambios cortos
      return (
        <View style={styles.changeDetail}>
          <View
            style={{
              backgroundColor: theme.colors.errorContainer,
              paddingHorizontal: 6,
              paddingVertical: 2,
              borderRadius: 4,
              marginRight: 6,
            }}
          >
            <Text
              variant="labelSmall"
              style={{
                color: theme.colors.onErrorContainer,
                fontWeight: '500',
              }}
            >
              {String(change.anterior)}
            </Text>
          </View>
          <Icon
            name="arrow-right"
            size={16}
            color={theme.colors.onSurfaceVariant}
            style={{ marginHorizontal: 4 }}
          />
          <View
            style={{
              backgroundColor: theme.colors.primaryContainer,
              paddingHorizontal: 6,
              paddingVertical: 2,
              borderRadius: 4,
            }}
          >
            <Text
              variant="labelSmall"
              style={{
                color: theme.colors.onPrimaryContainer,
                fontWeight: '500',
              }}
            >
              {String(change.nuevo)}
            </Text>
          </View>
        </View>
      );
    } else if (Array.isArray(change) && change.length === 2) {
      // Para el formato de array [antes, despu√©s] - usado en cambios de orden
      const oldVal = formatValue(fieldName || '', change[0]);
      const newVal = formatValue(fieldName || '', change[1]);

      // Para campos largos o especiales, usar formato vertical
      if (
        fieldName &&
        ['notes', 'deliveryInfo', 'customerName', 'deliveryAddress'].includes(
          fieldName,
        )
      ) {
        return (
          <View style={{ marginTop: 4 }}>
            <View
              style={{
                backgroundColor: theme.colors.errorContainer,
                padding: 8,
                borderRadius: 6,
                marginBottom: 8,
              }}
            >
              <Text
                variant="labelSmall"
                style={{
                  color: theme.colors.onErrorContainer,
                  fontWeight: '600',
                  marginBottom: 4,
                }}
              >
                Antes:
              </Text>
              <Text
                variant="bodySmall"
                style={{ color: theme.colors.onErrorContainer }}
              >
                {oldVal}
              </Text>
            </View>
            <View
              style={{
                backgroundColor: theme.colors.primaryContainer,
                padding: 8,
                borderRadius: 6,
              }}
            >
              <Text
                variant="labelSmall"
                style={{
                  color: theme.colors.onPrimaryContainer,
                  fontWeight: '600',
                  marginBottom: 4,
                }}
              >
                Despu√©s:
              </Text>
              <Text
                variant="bodySmall"
                style={{ color: theme.colors.onPrimaryContainer }}
              >
                {newVal}
              </Text>
            </View>
          </View>
        );
      }

      // Formato horizontal para cambios cortos
      return (
        <View style={styles.changeDetail}>
          <View
            style={{
              backgroundColor: theme.colors.errorContainer,
              paddingHorizontal: 8,
              paddingVertical: 4,
              borderRadius: 4,
              marginRight: 6,
            }}
          >
            <Text
              variant="labelSmall"
              style={{
                color: theme.colors.onErrorContainer,
                fontWeight: '500',
              }}
            >
              {oldVal}
            </Text>
          </View>
          <Icon
            name="arrow-right"
            size={16}
            color={theme.colors.onSurfaceVariant}
            style={{ marginHorizontal: 4 }}
          />
          <View
            style={{
              backgroundColor: theme.colors.primaryContainer,
              paddingHorizontal: 8,
              paddingVertical: 4,
              borderRadius: 4,
            }}
          >
            <Text
              variant="labelSmall"
              style={{
                color: theme.colors.onPrimaryContainer,
                fontWeight: '500',
              }}
            >
              {newVal}
            </Text>
          </View>
        </View>
      );
    }
    return null;
  };

  return (
    <Surface
      style={[
        styles.historyItem,
        { backgroundColor: theme.colors.surfaceVariant },
      ]}
      elevation={1}
    >
      <TouchableOpacity
        onPress={() => setExpanded(!expanded)}
        activeOpacity={0.7}
      >
        <View style={styles.historyHeader}>
          <View style={{ flex: 1, marginRight: 12 }}>
            <View
              style={{
                flexDirection: 'row',
                alignItems: 'center',
                marginBottom: 4,
              }}
            >
              <Avatar.Icon
                size={24}
                icon={getOperationIcon(item.operation, item.type)}
                style={{
                  backgroundColor:
                    item.type === 'order'
                      ? theme.colors.primary
                      : theme.colors.secondary,
                  marginRight: 6,
                }}
              />
              <Text
                variant="bodySmall"
                style={{ fontWeight: '600', flex: 1 }}
                numberOfLines={1}
              >
                {item.changedByUser
                  ? `${item.changedByUser.firstName} ${item.changedByUser.lastName}`
                  : item.user
                    ? `${item.user.firstName} ${item.user.lastName}`
                    : 'Sistema'}
              </Text>
              <View
                style={{
                  width: 32,
                  height: 32,
                  borderRadius: 16,
                  backgroundColor: theme.colors.surfaceVariant,
                  alignItems: 'center',
                  justifyContent: 'center',
                }}
              >
                <Icon
                  name={expanded ? 'chevron-up' : 'chevron-down'}
                  size={20}
                  color={theme.colors.onSurfaceVariant}
                />
              </View>
            </View>

            <View
              style={{
                flexDirection: 'row',
                alignItems: 'center',
                flexWrap: 'wrap',
                gap: 4,
              }}
            >
              <View
                style={{
                  flexDirection: 'row',
                  alignItems: 'center',
                  backgroundColor:
                    (item.type === 'order'
                      ? theme.colors.primary
                      : theme.colors.secondary) + '15',
                  paddingHorizontal: 5,
                  paddingVertical: 1,
                  borderRadius: 10,
                }}
              >
                <Icon
                  name={getOperationIcon(item.operation, item.type)}
                  size={10}
                  color={
                    item.type === 'order'
                      ? theme.colors.primary
                      : theme.colors.secondary
                  }
                  style={{ marginRight: 3 }}
                />
                <Text
                  style={{
                    color:
                      item.type === 'order'
                        ? theme.colors.primary
                        : theme.colors.secondary,
                    fontSize: 9,
                    fontWeight: '600',
                  }}
                >
                  {getOperationLabel(item.operation, item.type)}
                </Text>
              </View>

              {item.preparationStatus && (
                <Chip
                  mode="flat"
                  textStyle={{ fontSize: 9 }}
                  style={{
                    backgroundColor:
                      getStatusColor(item.preparationStatus, theme) + '20',
                    transform: [{ scale: 0.8 }],
                    height: 20,
                  }}
                  compact
                >
                  {formatValue('preparationStatus', item.preparationStatus)}
                </Chip>
              )}

              <Text variant="labelSmall" style={{ opacity: 0.6, fontSize: 10 }}>
                {format(new Date(item.changedAt), 'dd/MM/yyyy HH:mm', {
                  locale: es,
                })}
              </Text>
            </View>
          </View>
        </View>
      </TouchableOpacity>

      {expanded && (
        <View style={styles.expandedContent}>
          <Divider style={{ marginBottom: 8 }} />

          {/* Contenido para √≥rdenes */}
          {item.type === 'order' && (
            <View style={styles.changesContainer}>
              {item.operation === 'INSERT' && (
                <>
                  {/* Si hay diff consolidado para INSERT, usarlo */}
                  {item.diff && (item.diff.order || item.diff.items) ? (
                    <>
                      {item.diff.summary && (
                        <Text
                          variant="bodySmall"
                          style={{
                            color: theme.colors.primary,
                            fontWeight: '600',
                            marginBottom: 8,
                            fontStyle: 'italic',
                          }}
                        >
                          {item.diff.summary}
                        </Text>
                      )}

                      {/* Informaci√≥n de la orden */}
                      {item.diff.order && (
                        <View
                          style={{
                            backgroundColor: theme.colors.surface,
                            padding: 8,
                            borderRadius: 6,
                            marginBottom: 8,
                          }}
                        >
                          <Text
                            variant="labelSmall"
                            style={{
                              color: theme.colors.primary,
                              fontWeight: '600',
                              marginBottom: 6,
                            }}
                          >
                            Detalles de la orden:
                          </Text>

                          {item.diff.order.fields?.orderType && (
                            <Text
                              variant="bodySmall"
                              style={{ marginBottom: 4 }}
                            >
                              <Text style={{ fontWeight: '600' }}>Tipo:</Text>{' '}
                              {formatValue(
                                'orderType',
                                item.diff.order.fields.orderType[1],
                              )}
                            </Text>
                          )}
                          {item.diff.order.fields?.tableId && (
                            <Text
                              variant="bodySmall"
                              style={{ marginBottom: 4 }}
                            >
                              <Text style={{ fontWeight: '600' }}>Mesa:</Text>{' '}
                              {item.snapshot?.table?.name ||
                                `Mesa ${item.diff.order.fields.tableId[1]}`}
                            </Text>
                          )}
                          {item.diff.order.fields?.notes && (
                            <Text
                              variant="bodySmall"
                              style={{ marginBottom: 4 }}
                            >
                              <Text style={{ fontWeight: '600' }}>Notas:</Text>{' '}
                              {item.diff.order.fields.notes[1]}
                            </Text>
                          )}

                          {/* Informaci√≥n de entrega */}
                          {item.diff.order.deliveryInfo && (
                            <>
                              {item.diff.order.deliveryInfo.recipientName && (
                                <Text
                                  variant="bodySmall"
                                  style={{ marginBottom: 4 }}
                                >
                                  <Text style={{ fontWeight: '600' }}>
                                    Cliente:
                                  </Text>{' '}
                                  {
                                    item.diff.order.deliveryInfo
                                      .recipientName[1]
                                  }
                                </Text>
                              )}
                              {item.diff.order.deliveryInfo.recipientPhone && (
                                <Text
                                  variant="bodySmall"
                                  style={{ marginBottom: 4 }}
                                >
                                  <Text style={{ fontWeight: '600' }}>
                                    Tel√©fono:
                                  </Text>{' '}
                                  {
                                    item.diff.order.deliveryInfo
                                      .recipientPhone[1]
                                  }
                                </Text>
                              )}
                              {item.diff.order.deliveryInfo.fullAddress && (
                                <Text
                                  variant="bodySmall"
                                  style={{ marginBottom: 4 }}
                                >
                                  <Text style={{ fontWeight: '600' }}>
                                    Direcci√≥n:
                                  </Text>{' '}
                                  {item.diff.order.deliveryInfo.fullAddress[1]}
                                </Text>
                              )}
                            </>
                          )}
                        </View>
                      )}

                      {/* Productos agregados */}
                      {item.diff.items?.added &&
                        item.diff.items.added.length > 0 && (
                          <>
                            <Text
                              variant="labelSmall"
                              style={{
                                color: theme.colors.primary,
                                fontWeight: '600',
                                marginBottom: 8,
                                marginTop: 8,
                              }}
                            >
                              Productos incluidos en la orden:
                            </Text>
                            {item.diff.items.added.map(
                              (addedItem: any, idx: number) => (
                                <View
                                  key={`added-${idx}`}
                                  style={{
                                    marginBottom: 8,
                                    paddingLeft: 8,
                                    borderLeftWidth: 2,
                                    borderLeftColor:
                                      theme.colors.primary + '50',
                                    backgroundColor: theme.colors.surface,
                                    padding: 8,
                                    marginLeft: 4,
                                    borderRadius: 4,
                                  }}
                                >
                                  <Text
                                    variant="bodySmall"
                                    style={{ fontWeight: '600' }}
                                  >
                                    {addedItem.productName}
                                    {addedItem.variantName
                                      ? ` - ${addedItem.variantName}`
                                      : ''}
                                  </Text>
                                  {addedItem.modifiers?.length > 0 && (
                                    <Text
                                      variant="labelSmall"
                                      style={{
                                        marginTop: 2,
                                        color: theme.colors.onSurfaceVariant,
                                      }}
                                    >
                                      Modificadores:{' '}
                                      {addedItem.modifiers.join(', ')}
                                    </Text>
                                  )}
                                  {addedItem.customizations?.length > 0 && (
                                    <Text
                                      variant="labelSmall"
                                      style={{
                                        marginTop: 2,
                                        color: theme.colors.onSurfaceVariant,
                                      }}
                                    >
                                      Personalizaciones:{' '}
                                      {addedItem.customizations.join(', ')}
                                    </Text>
                                  )}
                                  {addedItem.notes && (
                                    <Text
                                      variant="labelSmall"
                                      style={{
                                        marginTop: 2,
                                        fontStyle: 'italic',
                                      }}
                                    >
                                      Notas: {addedItem.notes}
                                    </Text>
                                  )}
                                  <Text
                                    variant="labelSmall"
                                    style={{
                                      marginTop: 2,
                                      fontWeight: '600',
                                      color: theme.colors.primary,
                                    }}
                                  >
                                    Precio: ${addedItem.price}
                                  </Text>
                                </View>
                              ),
                            )}
                          </>
                        )}
                    </>
                  ) : (
                    // Fallback al formato anterior si no hay diff
                    <>
                      <Text
                        variant="bodySmall"
                        style={{
                          color: theme.colors.primary,
                          fontWeight: '600',
                          marginBottom: 8,
                        }}
                      >
                        Nueva orden creada
                      </Text>
                      {item.snapshot && (
                        <View
                          style={{
                            backgroundColor: theme.colors.surface,
                            padding: 8,
                            borderRadius: 6,
                          }}
                        >
                          {item.snapshot.orderType && (
                            <Text
                              variant="bodySmall"
                              style={{ marginBottom: 4 }}
                            >
                              <Text style={{ fontWeight: '600' }}>Tipo:</Text>{' '}
                              {formatValue(
                                'orderType',
                                item.snapshot.orderType,
                              )}
                            </Text>
                          )}
                          {item.snapshot.tableId && (
                            <Text
                              variant="bodySmall"
                              style={{ marginBottom: 4 }}
                            >
                              <Text style={{ fontWeight: '600' }}>Mesa:</Text>{' '}
                              {item.snapshot.table?.name ||
                                'Mesa ' + item.snapshot.tableId}
                            </Text>
                          )}
                          {item.snapshot.notes && (
                            <Text variant="bodySmall">
                              <Text style={{ fontWeight: '600' }}>Notas:</Text>{' '}
                              {item.snapshot.notes}
                            </Text>
                          )}
                        </View>
                      )}
                    </>
                  )}
                </>
              )}

              {item.operation === 'UPDATE' &&
                item.diff &&
                (() => {
                  const relevantChanges = Object.entries(item.diff)
                    .filter(([field]) => {
                      // Solo mostrar campos que rastreamos en el backend
                      const allowedFields = [
                        'orderStatus',
                        'orderType',
                        'notes',
                        'tableId',
                        'customerId',
                        'scheduledAt',
                        'deliveryInfo',
                        'isFromWhatsApp',
                      ];
                      return allowedFields.includes(field);
                    })
                    .flatMap(([field, change]) => {
                      // Si es deliveryInfo y es un objeto, expandir sus propiedades
                      if (
                        field === 'deliveryInfo' &&
                        change &&
                        typeof change === 'object' &&
                        !Array.isArray(change)
                      ) {
                        return Object.entries(change).map(
                          ([subField, subChange]) => ({
                            field: subField,
                            change: subChange,
                          }),
                        );
                      }
                      return [{ field, change }];
                    });

                  if (relevantChanges.length === 0) {
                    return (
                      <Text
                        variant="bodySmall"
                        style={{ color: theme.colors.onSurfaceVariant }}
                      >
                        Actualizaci√≥n de productos de la orden
                      </Text>
                    );
                  }

                  return (
                    <>
                      <Text
                        variant="bodySmall"
                        style={{
                          color: theme.colors.primary,
                          fontWeight: '600',
                          marginBottom: 8,
                        }}
                      >
                        Cambios en la orden:
                      </Text>
                      {relevantChanges.map(({ field, change }) => (
                        <View key={field} style={{ marginBottom: 8 }}>
                          <Text
                            variant="labelSmall"
                            style={{
                              color: theme.colors.onSurfaceVariant,
                              fontWeight: '600',
                              marginBottom: 4,
                              textTransform: 'capitalize',
                            }}
                          >
                            {formatFieldName(field)}:
                          </Text>
                          {renderChangeDetail(change, field)}
                        </View>
                      ))}
                    </>
                  );
                })()}

              {item.operation === 'DELETE' && (
                <Text variant="bodySmall" style={{ color: theme.colors.error }}>
                  La orden fue eliminada
                </Text>
              )}
            </View>
          )}

          {/* Contenido consolidado nuevo formato */}
          {item.diff &&
            (item.diff.order || item.diff.items || item.diff.summary) && (
              <View style={styles.changesContainer}>
                {/* Resumen de cambios */}
                {item.diff.summary && (
                  <Text
                    variant="bodySmall"
                    style={{
                      color: theme.colors.primary,
                      fontWeight: '600',
                      marginBottom: 8,
                      fontStyle: 'italic',
                    }}
                  >
                    {item.diff.summary}
                  </Text>
                )}

                {/* Cambios en la orden */}
                {item.diff.order?.fields && (
                  <>
                    <Text
                      variant="bodySmall"
                      style={{
                        color: theme.colors.primary,
                        fontWeight: '600',
                        marginBottom: 8,
                      }}
                    >
                      Cambios en la orden:
                    </Text>
                    {Object.entries(item.diff.order.fields).map(
                      ([field, change]) => (
                        <View key={field} style={{ marginBottom: 8 }}>
                          <Text
                            variant="labelSmall"
                            style={{
                              color: theme.colors.onSurfaceVariant,
                              fontWeight: '600',
                              marginBottom: 4,
                              textTransform: 'capitalize',
                            }}
                          >
                            {formatFieldName(field)}:
                          </Text>
                          {renderChangeDetail(change, field)}
                        </View>
                      ),
                    )}
                  </>
                )}

                {/* Cambios en informaci√≥n de entrega */}
                {item.diff.order?.deliveryInfo && (
                  <>
                    <Text
                      variant="bodySmall"
                      style={{
                        color: theme.colors.primary,
                        fontWeight: '600',
                        marginBottom: 8,
                      }}
                    >
                      Cambios en informaci√≥n de entrega:
                    </Text>
                    {Object.entries(item.diff.order.deliveryInfo).map(
                      ([field, change]) => (
                        <View key={field} style={{ marginBottom: 8 }}>
                          <Text
                            variant="labelSmall"
                            style={{
                              color: theme.colors.onSurfaceVariant,
                              fontWeight: '600',
                              marginBottom: 4,
                              textTransform: 'capitalize',
                            }}
                          >
                            {formatFieldName(field)}:
                          </Text>
                          {renderChangeDetail(change, field)}
                        </View>
                      ),
                    )}
                  </>
                )}

                {/* Usar formattedChanges si est√° disponible para mostrar cambios simplificados */}
                {item.formattedChanges &&
                  item.formattedChanges['Cambios en productos'] && (
                    <>
                      <Text
                        variant="bodySmall"
                        style={{
                          color: theme.colors.primary,
                          fontWeight: '600',
                          marginBottom: 8,
                        }}
                      >
                        Cambios en productos:
                      </Text>

                      {/* Productos modificados - dise√±o mejorado */}
                      {item.formattedChanges['Cambios en productos'][
                        'Productos modificados'
                      ] && (
                        <View style={{ marginTop: 8 }}>
                          {item.formattedChanges['Cambios en productos'][
                            'Productos modificados'
                          ].map((modItem: any, idx: number) => (
                            <View
                              key={`mod-${idx}`}
                              style={{
                                marginBottom: 12,
                                backgroundColor: theme.colors.surfaceVariant,
                                borderRadius: theme.roundness * 2,
                                overflow: 'hidden',
                              }}
                            >
                              {/* Header del cambio */}
                              <View
                                style={{
                                  flexDirection: 'row',
                                  alignItems: 'center',
                                  backgroundColor: theme.colors.warning + '20',
                                  paddingHorizontal: 12,
                                  paddingVertical: 8,
                                  borderBottomWidth: 1,
                                  borderBottomColor:
                                    theme.colors.warning + '30',
                                }}
                              >
                                <Icon
                                  name="pencil"
                                  size={16}
                                  color={theme.colors.warning}
                                  style={{ marginRight: 8 }}
                                />
                                <Text
                                  variant="labelMedium"
                                  style={{
                                    color: theme.colors.warning,
                                    fontWeight: '600',
                                    flex: 1,
                                  }}
                                >
                                  Producto modificado
                                </Text>
                              </View>

                              {/* Contenido del cambio */}
                              <View style={{ padding: 12 }}>
                                <View
                                  style={{
                                    flexDirection: 'row',
                                    alignItems: 'center',
                                    backgroundColor: theme.colors.surface,
                                    borderRadius: theme.roundness,
                                    padding: 10,
                                  }}
                                >
                                  {/* Antes */}
                                  <View
                                    style={{
                                      flex: 1,
                                      paddingRight: 8,
                                    }}
                                  >
                                    <Text
                                      variant="labelSmall"
                                      style={{
                                        color: theme.colors.error,
                                        marginBottom: 4,
                                        opacity: 0.8,
                                      }}
                                    >
                                      Antes
                                    </Text>
                                    <Text
                                      variant="bodySmall"
                                      style={{
                                        color: theme.colors.onSurfaceVariant,
                                        textDecorationLine: 'line-through',
                                        opacity: 0.7,
                                      }}
                                    >
                                      {modItem.antes}
                                    </Text>
                                  </View>

                                  {/* Flecha */}
                                  <View
                                    style={{
                                      paddingHorizontal: 8,
                                    }}
                                  >
                                    <Icon
                                      name="arrow-right-thick"
                                      size={24}
                                      color={theme.colors.primary}
                                    />
                                  </View>

                                  {/* Despu√©s */}
                                  <View
                                    style={{
                                      flex: 1,
                                      paddingLeft: 8,
                                    }}
                                  >
                                    <Text
                                      variant="labelSmall"
                                      style={{
                                        color: theme.colors.primary,
                                        marginBottom: 4,
                                      }}
                                    >
                                      Despu√©s
                                    </Text>
                                    <Text
                                      variant="bodySmall"
                                      style={{
                                        color: theme.colors.primary,
                                        fontWeight: '600',
                                      }}
                                    >
                                      {modItem.despu√©s}
                                    </Text>
                                  </View>
                                </View>
                              </View>
                            </View>
                          ))}
                        </View>
                      )}

                      {/* Productos agregados - formato simplificado */}
                      {item.formattedChanges['Cambios en productos'][
                        'Productos agregados'
                      ] && (
                        <>
                          {item.formattedChanges['Cambios en productos'][
                            'Productos agregados'
                          ].map((product: string, idx: number) => (
                            <View
                              key={`added-${idx}`}
                              style={{
                                marginBottom: 8,
                                paddingLeft: 8,
                                borderLeftWidth: 2,
                                borderLeftColor: theme.colors.success + '50',
                              }}
                            >
                              <View
                                style={{
                                  flexDirection: 'row',
                                  alignItems: 'flex-start',
                                }}
                              >
                                <Icon
                                  name="plus-circle"
                                  size={14}
                                  color={theme.colors.success}
                                  style={{ marginRight: 6, marginTop: 2 }}
                                />
                                <View style={{ flex: 1 }}>
                                  <Text
                                    variant="labelSmall"
                                    style={{
                                      color: theme.colors.success,
                                      fontWeight: '600',
                                    }}
                                  >
                                    Producto agregado
                                  </Text>
                                  <Text
                                    variant="bodySmall"
                                    style={{ marginTop: 2 }}
                                  >
                                    {product}
                                  </Text>
                                </View>
                              </View>
                            </View>
                          ))}
                        </>
                      )}

                      {/* Productos eliminados - formato simplificado */}
                      {item.formattedChanges['Cambios en productos'][
                        'Productos eliminados'
                      ] && (
                        <>
                          {item.formattedChanges['Cambios en productos'][
                            'Productos eliminados'
                          ].map((product: string, idx: number) => (
                            <View
                              key={`removed-${idx}`}
                              style={{
                                marginBottom: 8,
                                paddingLeft: 8,
                                borderLeftWidth: 2,
                                borderLeftColor: theme.colors.error + '50',
                              }}
                            >
                              <View
                                style={{
                                  flexDirection: 'row',
                                  alignItems: 'flex-start',
                                }}
                              >
                                <Icon
                                  name="delete"
                                  size={14}
                                  color={theme.colors.error}
                                  style={{ marginRight: 6, marginTop: 2 }}
                                />
                                <View style={{ flex: 1 }}>
                                  <Text
                                    variant="labelSmall"
                                    style={{
                                      color: theme.colors.error,
                                      fontWeight: '600',
                                    }}
                                  >
                                    Producto eliminado
                                  </Text>
                                  <Text
                                    variant="bodySmall"
                                    style={{ marginTop: 2 }}
                                  >
                                    {product}
                                  </Text>
                                </View>
                              </View>
                            </View>
                          ))}
                        </>
                      )}
                    </>
                  )}

                {/* Cambios en items - formato JSON crudo (fallback si no hay formattedChanges) */}
                {item.diff.items &&
                  !item.formattedChanges?.['Cambios en productos'] && (
                    <>
                      <Text
                        variant="bodySmall"
                        style={{
                          color: theme.colors.primary,
                          fontWeight: '600',
                          marginBottom: 8,
                        }}
                      >
                        Cambios en productos:
                      </Text>

                      {/* Items agregados */}
                      {item.diff.items.added?.map(
                        (addedItem: any, idx: number) => (
                          <View
                            key={`added-${idx}`}
                            style={{
                              marginBottom: 8,
                              paddingLeft: 8,
                              borderLeftWidth: 2,
                              borderLeftColor: theme.colors.success + '50',
                            }}
                          >
                            <View
                              style={{
                                flexDirection: 'row',
                                alignItems: 'flex-start',
                              }}
                            >
                              <Icon
                                name="plus-circle"
                                size={14}
                                color={theme.colors.success}
                                style={{ marginRight: 6, marginTop: 2 }}
                              />
                              <View style={{ flex: 1 }}>
                                <Text
                                  variant="labelSmall"
                                  style={{
                                    color: theme.colors.success,
                                    fontWeight: '600',
                                  }}
                                >
                                  Producto agregado
                                </Text>
                                <Text
                                  variant="bodySmall"
                                  style={{ marginTop: 2 }}
                                >
                                  {addedItem.productName}
                                  {addedItem.variantName
                                    ? ` - ${addedItem.variantName}`
                                    : ''}
                                </Text>
                                {addedItem.modifiers?.length > 0 && (
                                  <Text
                                    variant="labelSmall"
                                    style={{
                                      marginTop: 2,
                                      color: theme.colors.onSurfaceVariant,
                                    }}
                                  >
                                    Modificadores:{' '}
                                    {addedItem.modifiers.join(', ')}
                                  </Text>
                                )}
                                {addedItem.price && (
                                  <Text
                                    variant="labelSmall"
                                    style={{ marginTop: 2, fontWeight: '600' }}
                                  >
                                    Precio: ${addedItem.price}
                                  </Text>
                                )}
                              </View>
                            </View>
                          </View>
                        ),
                      )}

                      {/* Items modificados - Solo mostrar antes y despu√©s */}
                      {item.diff.items.modified?.map(
                        (modItem: any, idx: number) => (
                          <View
                            key={`mod-${idx}`}
                            style={{
                              marginBottom: 8,
                              paddingLeft: 8,
                              borderLeftWidth: 2,
                              borderLeftColor: theme.colors.warning + '50',
                            }}
                          >
                            <View
                              style={{
                                flexDirection: 'row',
                                alignItems: 'flex-start',
                              }}
                            >
                              <Icon
                                name="pencil"
                                size={14}
                                color={theme.colors.warning}
                                style={{ marginRight: 6, marginTop: 2 }}
                              />
                              <View style={{ flex: 1 }}>
                                <Text
                                  variant="labelSmall"
                                  style={{
                                    color: theme.colors.warning,
                                    fontWeight: '600',
                                  }}
                                >
                                  Producto modificado
                                </Text>
                                <View
                                  style={{
                                    flexDirection: 'row',
                                    alignItems: 'center',
                                    flexWrap: 'wrap',
                                    marginTop: 4,
                                  }}
                                >
                                  <View
                                    style={{
                                      backgroundColor:
                                        theme.colors.errorContainer,
                                      paddingHorizontal: 8,
                                      paddingVertical: 4,
                                      borderRadius: 4,
                                      marginRight: 6,
                                      marginTop: 4,
                                    }}
                                  >
                                    <Text
                                      variant="bodySmall"
                                      style={{
                                        color: theme.colors.onErrorContainer,
                                      }}
                                    >
                                      {modItem.before.productName}
                                      {modItem.before.variantName
                                        ? ` - ${modItem.before.variantName}`
                                        : ''}
                                    </Text>
                                  </View>
                                  <Icon
                                    name="arrow-right"
                                    size={16}
                                    color={theme.colors.onSurfaceVariant}
                                    style={{
                                      marginHorizontal: 4,
                                      marginTop: 4,
                                    }}
                                  />
                                  <View
                                    style={{
                                      backgroundColor:
                                        theme.colors.primaryContainer,
                                      paddingHorizontal: 8,
                                      paddingVertical: 4,
                                      borderRadius: 4,
                                      marginTop: 4,
                                    }}
                                  >
                                    <Text
                                      variant="bodySmall"
                                      style={{
                                        color: theme.colors.onPrimaryContainer,
                                      }}
                                    >
                                      {modItem.after.productName}
                                      {modItem.after.variantName
                                        ? ` - ${modItem.after.variantName}`
                                        : ''}
                                    </Text>
                                  </View>
                                </View>
                              </View>
                            </View>
                          </View>
                        ),
                      )}

                      {/* Items eliminados */}
                      {item.diff.items.removed?.map(
                        (removedItem: any, idx: number) => (
                          <View
                            key={`removed-${idx}`}
                            style={{
                              marginBottom: 8,
                              paddingLeft: 8,
                              borderLeftWidth: 2,
                              borderLeftColor: theme.colors.error + '50',
                            }}
                          >
                            <View
                              style={{
                                flexDirection: 'row',
                                alignItems: 'flex-start',
                              }}
                            >
                              <Icon
                                name="delete"
                                size={14}
                                color={theme.colors.error}
                                style={{ marginRight: 6, marginTop: 2 }}
                              />
                              <View style={{ flex: 1 }}>
                                <Text
                                  variant="labelSmall"
                                  style={{
                                    color: theme.colors.error,
                                    fontWeight: '600',
                                  }}
                                >
                                  Producto eliminado
                                </Text>
                                <Text
                                  variant="bodySmall"
                                  style={{ marginTop: 2 }}
                                >
                                  {removedItem.productName}
                                  {removedItem.variantName
                                    ? ` - ${removedItem.variantName}`
                                    : ''}
                                </Text>
                                {removedItem.price && (
                                  <Text
                                    variant="labelSmall"
                                    style={{ marginTop: 2, fontWeight: '600' }}
                                  >
                                    Precio: ${removedItem.price}
                                  </Text>
                                )}
                              </View>
                            </View>
                          </View>
                        ),
                      )}
                    </>
                  )}
              </View>
            )}

          {/* Contenido para items individuales (legacy) */}
          {item.type === 'item' && item.operation !== 'BATCH' && (
            <View style={styles.changesContainer}>
              {item.operation === 'INSERT' && (
                <Text
                  variant="bodySmall"
                  style={{
                    color: theme.colors.primary,
                    fontWeight: '600',
                    marginBottom: 8,
                  }}
                >
                  Nuevo item agregado:
                </Text>
              )}
              {item.operation === 'UPDATE' && item.formattedChanges && (
                <>
                  <Text
                    variant="bodySmall"
                    style={{
                      color: theme.colors.primary,
                      fontWeight: '600',
                      marginBottom: 8,
                    }}
                  >
                    Item modificado:
                  </Text>
                  {Object.entries(item.formattedChanges)
                    .filter(([fieldName]) => {
                      // Solo mostrar campos relevantes (no precios)
                      const allowedFields = [
                        'Descripci√≥n del Item',
                        'Estado',
                        'Notas de preparaci√≥n',
                        'Producto',
                        'Variante',
                        'Modificadores',
                      ];
                      return allowedFields.includes(fieldName);
                    })
                    .map(([fieldName, change]) => (
                      <View key={fieldName} style={{ marginBottom: 8 }}>
                        <Text
                          variant="labelSmall"
                          style={{
                            color: theme.colors.onSurfaceVariant,
                            fontWeight: '600',
                            marginBottom: 4,
                          }}
                        >
                          {fieldName}:
                        </Text>
                        {renderChangeDetail(change, fieldName)}
                      </View>
                    ))}
                </>
              )}
              {item.operation === 'DELETE' && (
                <Text
                  variant="bodySmall"
                  style={{ color: theme.colors.error, marginBottom: 8 }}
                >
                  Item eliminado:
                </Text>
              )}
              {/* Mostrar la descripci√≥n del item para INSERT y DELETE */}
              {(item.operation === 'INSERT' || item.operation === 'DELETE') &&
                item.itemDescription && (
                  <Text
                    variant="bodySmall"
                    style={{
                      color: theme.colors.onSurface,
                      backgroundColor: theme.colors.surface,
                      padding: 8,
                      borderRadius: 6,
                    }}
                  >
                    {item.itemDescription}
                  </Text>
                )}
            </View>
          )}

          {/* Contenido para batch de items */}
          {item.operation === 'BATCH' && item.batchOperations && (
            <View style={styles.changesContainer}>
              <Text
                variant="bodySmall"
                style={{
                  color: theme.colors.primary,
                  fontWeight: '600',
                  marginBottom: 8,
                }}
              >
                Cambios realizados en una sola edici√≥n:
              </Text>
              {item.batchOperations.map((op: any, idx: number) => (
                <View
                  key={idx}
                  style={{
                    marginBottom:
                      idx < item.batchOperations!.length - 1 ? 12 : 0,
                    paddingLeft: 8,
                    borderLeftWidth: 2,
                    borderLeftColor: theme.colors.primary + '30',
                    marginLeft: 4,
                  }}
                >
                  <View
                    style={{
                      flexDirection: 'row',
                      alignItems: 'flex-start',
                      marginBottom: 4,
                    }}
                  >
                    <Icon
                      name={getOperationIcon(op.operation)}
                      size={14}
                      color={theme.colors.primary}
                      style={{ marginRight: 6, marginTop: 2 }}
                    />
                    <View style={{ flex: 1 }}>
                      <Text
                        variant="labelSmall"
                        style={{
                          color: theme.colors.primary,
                          fontWeight: '500',
                          marginBottom: 4,
                        }}
                      >
                        {getOperationLabel(op.operation)}
                      </Text>

                      {/* Mostrar descripci√≥n del item */}
                      {(op.itemDescription || op.snapshot?.itemDescription) && (
                        <Text
                          variant="bodySmall"
                          style={{
                            color: theme.colors.onSurface,
                            backgroundColor: theme.colors.surface,
                            padding: 6,
                            borderRadius: 4,
                          }}
                        >
                          {op.itemDescription || op.snapshot?.itemDescription}
                        </Text>
                      )}

                      {/* Para UPDATE, mostrar el cambio */}
                      {op.operation === 'UPDATE' && op.formattedChanges && (
                        <View style={{ marginTop: 4 }}>
                          {Object.entries(op.formattedChanges)
                            .filter(([fieldName]) => {
                              // Solo mostrar campos relevantes (no precios)
                              const allowedFields = [
                                'Descripci√≥n del Item',
                                'Descripci√≥n',
                                'Estado',
                                'Notas de preparaci√≥n',
                                'Producto',
                                'Variante',
                                'Modificadores',
                                'Estado de preparaci√≥n',
                              ];
                              return allowedFields.includes(fieldName);
                            })
                            .map(([fieldName, change]) => (
                              <View key={fieldName} style={{ marginBottom: 4 }}>
                                <Text
                                  variant="labelSmall"
                                  style={{
                                    color: theme.colors.onSurfaceVariant,
                                    fontWeight: '500',
                                    fontSize: 11,
                                  }}
                                >
                                  {fieldName}:
                                </Text>
                                {renderChangeDetail(change, fieldName)}
                              </View>
                            ))}
                        </View>
                      )}
                    </View>
                  </View>
                </View>
              ))}
            </View>
          )}
        </View>
      )}
    </Surface>
  );
};

export const OrderHistoryModal: React.FC<OrderHistoryModalProps> = ({
  visible,
  onDismiss,
  orderId,
  orderNumber,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);

  // Query combinado para obtener ambos historiales
  const {
    data: historyData,
    isError,
    refetch,
    isLoading,
  } = useQuery({
    queryKey: ['combinedHistory', orderId],
    queryFn: async () => {
      if (!orderId) throw new Error('No order ID');

      // Obtener historial consolidado de la orden
      const orderHistoryResponse = await apiClient.get(
        API_PATHS.ORDERS_HISTORY.replace(':orderId', orderId),
        {
          page: 1,
          limit: 100,
        },
      );

      const orderHistory =
        orderHistoryResponse.ok && orderHistoryResponse.data?.data
          ? orderHistoryResponse.data.data.map((item: any) => ({
              ...item,
              type: 'order' as const,
            }))
          : [];

      // Ya no necesitamos consultar el historial de items por separado
      // Todo est√° consolidado en el historial de la orden

      // No es necesario agrupar ya que cada registro ya contiene cambios consolidados
      return orderHistory;
    },
    enabled: visible && !!orderId,
    staleTime: 30000,
  });

  // Refrescar cuando se abre el modal
  useEffect(() => {
    if (visible && orderId) {
      refetch();
    }
  }, [visible, orderId, refetch]);

  const renderHistoryItem = useCallback(
    ({ item }: { item: HistoryItem }) => {
      return <HistoryItemComponent item={item} theme={theme} />;
    },
    [theme],
  );

  const renderEmpty = () => (
    <View style={styles.emptyContainer}>
      <Icon
        name="history"
        size={48}
        color={theme.colors.onSurfaceVariant}
        style={{ opacity: 0.5 }}
      />
      <Text
        variant="bodyLarge"
        style={{
          color: theme.colors.onSurfaceVariant,
          marginTop: theme.spacing.m,
        }}
      >
        No hay historial disponible
      </Text>
    </View>
  );

  return (
    <Modal
      visible={visible}
      onDismiss={onDismiss}
      contentContainerStyle={styles.modalContainer}
      dismissable={true}
      dismissableBackButton={false}
    >
      <View style={styles.header}>
        <View style={{ flex: 1 }}>
          <Text
            variant="titleMedium"
            style={{
              color: theme.colors.onSurface,
              fontSize: 18,
              fontWeight: '600',
            }}
            numberOfLines={1}
          >
            Historial de Orden #{orderNumber || ''}
          </Text>
          <Text
            variant="bodySmall"
            style={{
              color: theme.colors.onSurfaceVariant,
              marginTop: 2,
            }}
          >
            {historyData?.length || 0} cambios registrados
          </Text>
        </View>
        <TouchableOpacity
          onPress={onDismiss}
          style={{
            width: 44,
            height: 44,
            borderRadius: 22,
            backgroundColor: theme.colors.errorContainer,
            alignItems: 'center',
            justifyContent: 'center',
            elevation: 2,
            shadowColor: '#000',
            shadowOffset: { width: 0, height: 2 },
            shadowOpacity: 0.1,
            shadowRadius: 4,
          }}
          activeOpacity={0.8}
        >
          <Icon name="close" size={24} color={theme.colors.onErrorContainer} />
        </TouchableOpacity>
      </View>

      <Divider />

      <View style={{ flex: 1 }}>
        {isError ? (
          <View style={styles.emptyContainer}>
            <Icon
              name="alert-circle"
              size={48}
              color={theme.colors.error}
              style={{ opacity: 0.7 }}
            />
            <Text
              variant="bodyLarge"
              style={{
                color: theme.colors.error,
                marginTop: theme.spacing.m,
                textAlign: 'center',
              }}
            >
              Error al cargar el historial
            </Text>
            <Button
              onPress={() => refetch()}
              mode="text"
              style={{ marginTop: 16 }}
            >
              Reintentar
            </Button>
          </View>
        ) : isLoading ? (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
            <Text style={styles.loadingText}>Cargando historial...</Text>
          </View>
        ) : (
          <FlatList
            data={historyData || []}
            renderItem={renderHistoryItem}
            keyExtractor={(item) => item.id.toString()}
            contentContainerStyle={styles.listContent}
            ListEmptyComponent={renderEmpty}
            showsVerticalScrollIndicator={false}
          />
        )}
      </View>
    </Modal>
  );
};

const createStyles = (theme: ReturnType<typeof useAppTheme>) => {
  return StyleSheet.create({
    modalContainer: {
      backgroundColor: theme.colors.surface,
      margin: 20,
      marginVertical: Platform.OS === 'ios' ? 60 : 40,
      borderRadius: theme.roundness * 3,
      height: '80%',
      maxHeight: 600,
      width: '90%',
      maxWidth: 500,
      alignSelf: 'center',
      elevation: 24,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 12 },
      shadowOpacity: 0.58,
      shadowRadius: 16.0,
      overflow: 'hidden',
    },
    header: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingHorizontal: theme.spacing.l,
      paddingVertical: theme.spacing.m,
      backgroundColor: theme.colors.elevation.level2,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
      minHeight: 64,
    },
    scrollView: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    listContent: {
      padding: theme.spacing.m,
      paddingBottom: theme.spacing.xl * 2, // M√°s espacio al final para evitar superposici√≥n
    },
    loadingContainer: {
      flex: 1,
      padding: theme.spacing.xl,
      alignItems: 'center',
      justifyContent: 'center',
    },
    loadingText: {
      marginTop: theme.spacing.m,
      color: theme.colors.onSurfaceVariant,
    },
    historyItem: {
      padding: theme.spacing.s,
      marginBottom: theme.spacing.s,
      marginHorizontal: theme.spacing.xs,
      borderRadius: theme.roundness * 2,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 1 },
      shadowOpacity: 0.05,
      shadowRadius: 2,
      elevation: 2,
    },
    historyHeader: {
      // Cambio a estructura vertical para evitar encimamiento
    },
    userInfo: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
      minWidth: 0,
    },
    userDetails: {
      marginLeft: theme.spacing.s,
      flex: 1,
      minWidth: 0,
    },
    expandedContent: {
      marginTop: theme.spacing.m,
      backgroundColor: theme.colors.background,
      marginHorizontal: -theme.spacing.s,
      padding: theme.spacing.m,
      borderBottomLeftRadius: theme.roundness,
      borderBottomRightRadius: theme.roundness,
    },
    changesContainer: {
      paddingTop: theme.spacing.xs,
    },
    changeDetail: {
      flexDirection: 'row',
      alignItems: 'center',
      flexWrap: 'wrap',
      marginBottom: 4,
    },
    emptyContainer: {
      flex: 1,
      padding: theme.spacing.xl,
      alignItems: 'center',
      justifyContent: 'center',
    },
  });
};

export default OrderHistoryModal;

================
File: app/src/modules/shared/components/OrderSummaryCard.tsx
================
import React from 'react';
import { View, StyleSheet, TouchableOpacity } from 'react-native';
import { Text, Chip, Card, Icon } from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { getPaymentStatus } from '@/app/utils/orderFormatters';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import { OrderTypeEnum } from '@/modules/orders/types/orders.types';
import { formatOrderTypeShort } from '@/app/utils/orderFormatters';

interface OrderSummaryCardProps {
  item: any; // Union type for ReceiptList | Order
  onPress: () => void;
  renderActions?: (item: any) => React.ReactNode;
  getStatusColor?: (status: string) => string;
  getStatusLabel?: (status: string) => string;
}

const OrderSummaryCard: React.FC<OrderSummaryCardProps> = ({
  item,
  onPress,
  renderActions,
  getStatusColor,
  getStatusLabel,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);

  // Construir el t√≠tulo seg√∫n el tipo de orden
  let orderTitle = `#${item.shiftOrderNumber || item.orderNumber} ‚Ä¢ ${formatOrderTypeShort(item.orderType)}`;

  if (item.orderType === OrderTypeEnum.DINE_IN && item.table) {
    // Para mesas temporales, mostrar solo el nombre sin prefijo "Mesa"
    const tableDisplay = item.table.isTemporary
      ? item.table.name
      : `Mesa ${item.table.name || item.table.number || 'N/A'}`;
    orderTitle += ` ‚Ä¢ ${item.table.area?.name || item.area?.name || 'Sin √°rea'} ‚Ä¢ ${tableDisplay}`;
  } else if (item.orderType === OrderTypeEnum.TAKE_AWAY) {
    if (item.deliveryInfo?.recipientName || item.deliveryInfo?.customerName) {
      orderTitle += ` ‚Ä¢ ${item.deliveryInfo.recipientName || item.deliveryInfo.customerName}`;
    }
    if (item.deliveryInfo?.recipientPhone || item.deliveryInfo?.customerPhone) {
      orderTitle += ` ‚Ä¢ ${item.deliveryInfo.recipientPhone || item.deliveryInfo.customerPhone}`;
    }
  } else if (item.orderType === OrderTypeEnum.DELIVERY) {
    if (item.deliveryInfo?.fullAddress || item.deliveryInfo?.address) {
      orderTitle += ` ‚Ä¢ ${item.deliveryInfo.fullAddress || item.deliveryInfo.address}`;
    }
    if (item.deliveryInfo?.recipientPhone || item.deliveryInfo?.customerPhone) {
      orderTitle += ` ‚Ä¢ ${item.deliveryInfo.recipientPhone || item.deliveryInfo.customerPhone}`;
    }
  }

  const totalAmount =
    typeof item.total === 'string' ? parseFloat(item.total) : item.total;
  const totalPaid =
    item.paymentsSummary?.totalPaid ||
    item.payments?.reduce((sum: number, p: any) => sum + (p.amount || 0), 0) ||
    0;
  const pendingAmount = totalAmount - totalPaid;

  // Determinar colores y √≠conos de estado de pago
  const paymentStatus = getPaymentStatus(item as any);
  const paymentColor =
    paymentStatus === 'paid'
      ? '#10B981'
      : paymentStatus === 'partial'
        ? '#F59E0B'
        : '#EF4444';
  const paymentIcon =
    paymentStatus === 'paid' ? '‚úì' : paymentStatus === 'partial' ? '¬Ω' : '‚Ä¢';

  // Colores de estado por defecto si no se proporcionan
  const defaultGetStatusColor = (status: string) => {
    switch (status) {
      case 'COMPLETED':
        return '#4CAF50';
      case 'CANCELLED':
        return '#F44336';
      case 'IN_PROGRESS':
        return '#FF9800';
      default:
        return theme.colors.surfaceVariant;
    }
  };

  const defaultGetStatusLabel = (status: string) => {
    switch (status) {
      case 'COMPLETED':
        return 'Completada';
      case 'CANCELLED':
        return 'Cancelada';
      case 'IN_PROGRESS':
        return 'En proceso';
      default:
        return status;
    }
  };

  const statusColor = getStatusColor
    ? getStatusColor(item.orderStatus)
    : defaultGetStatusColor(item.orderStatus);
  const statusLabel = getStatusLabel
    ? getStatusLabel(item.orderStatus)
    : defaultGetStatusLabel(item.orderStatus);

  return (
    <TouchableOpacity activeOpacity={0.95} onPress={onPress}>
      <Card
        style={[
          styles.orderCard,
          {
            backgroundColor: theme.colors.surface,
          },
        ]}
        mode="elevated"
      >
        <Card.Content style={styles.cardContent}>
          <View style={styles.mainContainer}>
            <View style={styles.leftContainer}>
              <Text
                style={[styles.orderNumber, { color: theme.colors.onSurface }]}
              >
                {orderTitle}
                <Text
                  style={[
                    styles.orderPrice,
                    {
                      color: pendingAmount > 0 ? theme.colors.error : '#10B981',
                    },
                  ]}
                >
                  {' ‚Ä¢ '}
                  {pendingAmount > 0
                    ? `Por pagar: $${pendingAmount.toFixed(2)}`
                    : `Pagado: $${totalAmount.toFixed(2)}`}
                </Text>
                {item.notes && (
                  <Text
                    style={[
                      styles.notesInline,
                      { color: theme.colors.onSurfaceVariant },
                    ]}
                    numberOfLines={1}
                  >
                    {' ‚Ä¢ '}
                    {item.notes}
                  </Text>
                )}
              </Text>
              <View style={styles.timeAndPaymentRow}>
                <Text
                  style={[styles.orderTime, { color: theme.colors.primary }]}
                >
                  {format(new Date(item.createdAt), 'p', { locale: es })}
                </Text>

                {/* Badge de estado de pago */}
                <View
                  style={[
                    styles.miniPaymentBadge,
                    { backgroundColor: paymentColor },
                  ]}
                >
                  <Text style={styles.miniPaymentText}>{paymentIcon}</Text>
                </View>

                {/* Badge de WhatsApp */}
                {item.isFromWhatsApp && (
                  <View
                    style={[
                      styles.inlinePreparationBadge,
                      {
                        backgroundColor: '#25D366',
                        borderColor: '#25D366',
                      },
                    ]}
                  >
                    <Icon source="whatsapp" size={12} color="#FFFFFF" />
                  </View>
                )}

                {/* Badges de pantallas de preparaci√≥n */}
                {item.preparationScreenStatuses &&
                  item.preparationScreenStatuses.length > 0 && (
                    <>
                      {item.preparationScreenStatuses.map(
                        (screen: any, index: number) => {
                          const backgroundColor =
                            screen.status === 'READY'
                              ? '#4CAF50'
                              : screen.status === 'IN_PROGRESS'
                                ? '#FFA000'
                                : theme.colors.surfaceVariant;

                          const textColor =
                            screen.status === 'READY' ||
                            screen.status === 'IN_PROGRESS'
                              ? '#FFFFFF'
                              : theme.colors.onSurfaceVariant;

                          return (
                            <View
                              key={`${item.id}-screen-${index}`}
                              style={[
                                styles.inlinePreparationBadge,
                                {
                                  backgroundColor,
                                  borderColor:
                                    backgroundColor ===
                                    theme.colors.surfaceVariant
                                      ? theme.colors.outline
                                      : backgroundColor,
                                },
                              ]}
                            >
                              <Text
                                style={[
                                  styles.inlinePreparationText,
                                  { color: textColor },
                                ]}
                              >
                                {screen.status === 'READY'
                                  ? '‚úì '
                                  : screen.status === 'IN_PROGRESS'
                                    ? '‚è≥'
                                    : ''}
                                üç≥ {screen.name}
                              </Text>
                            </View>
                          );
                        },
                      )}
                    </>
                  )}
              </View>
            </View>

            <View style={styles.rightContainer}>
              {item.createdBy && (
                <Text style={styles.createdByText} numberOfLines={1}>
                  {item.createdBy.firstName && item.createdBy.lastName
                    ? `${item.createdBy.firstName} ${item.createdBy.lastName}`
                    : item.createdBy.username}
                </Text>
              )}
              <Chip
                mode="flat"
                compact
                style={[
                  styles.statusChip,
                  {
                    backgroundColor: statusColor,
                  },
                ]}
                textStyle={styles.statusChipText}
              >
                {statusLabel}
              </Chip>

              {/* Contenedor de acciones personalizables */}
              {renderActions && (
                <View style={styles.actionsContainer}>
                  {renderActions(item)}
                </View>
              )}
            </View>
          </View>
        </Card.Content>
      </Card>
    </TouchableOpacity>
  );
};

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    orderCard: {
      marginBottom: 8,
    },
    cardContent: {
      paddingBottom: 8,
    },
    mainContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
    },
    leftContainer: {
      flex: 1,
      marginRight: 12,
    },
    rightContainer: {
      alignItems: 'flex-end',
      justifyContent: 'space-between',
      minHeight: 60,
    },
    orderNumber: {
      fontSize: 16,
      fontWeight: '600',
      lineHeight: 22,
      marginBottom: 4,
    },
    orderPrice: {
      fontSize: 14,
      fontWeight: '500',
    },
    notesInline: {
      fontSize: 13,
      fontStyle: 'italic',
    },
    timeAndPaymentRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 6,
      flexWrap: 'wrap',
    },
    orderTime: {
      fontSize: 13,
      fontWeight: '500',
    },
    miniPaymentBadge: {
      width: 16,
      height: 16,
      borderRadius: 8,
      justifyContent: 'center',
      alignItems: 'center',
    },
    miniPaymentText: {
      color: '#FFFFFF',
      fontSize: 10,
      fontWeight: 'bold',
    },
    inlinePreparationBadge: {
      paddingHorizontal: 6,
      paddingVertical: 2,
      borderRadius: 10,
      borderWidth: 1,
    },
    inlinePreparationText: {
      fontSize: 10,
      fontWeight: '500',
    },
    createdByText: {
      fontSize: 12,
      color: '#666',
      marginBottom: 4,
      maxWidth: 120,
    },
    statusChip: {
      marginBottom: 8,
    },
    statusChipText: {
      fontSize: 11,
      fontWeight: '600',
      color: '#FFFFFF',
    },
    actionsContainer: {
      alignItems: 'center',
    },
  });

export default OrderSummaryCard;

================
File: app/src/modules/sync/navigation/SyncStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { SyncStatusScreen } from '../screens/SyncStatusScreen';

export type SyncStackParamList = {
  SyncStatus: undefined;
};

const Stack = createNativeStackNavigator<SyncStackParamList>();

export const SyncStackNavigator: React.FC = () => {
  return (
    <Stack.Navigator
      screenOptions={{
        headerShown: false,
      }}
    >
      <Stack.Screen
        name="SyncStatus"
        component={SyncStatusScreen}
        options={{ title: 'Estado de Sincronizaci√≥n' }}
      />
    </Stack.Navigator>
  );
};

================
File: app/metro.config.js
================
const { getDefaultConfig } = require('expo/metro-config');

const config = getDefaultConfig(__dirname);

// Configuraci√≥n para asegurar que las peticiones HTTP funcionen en producci√≥n
config.resolver.resolverMainFields = ['react-native', 'browser', 'main'];

// Configuraci√≥n adicional para web
config.resolver.sourceExts = [...config.resolver.sourceExts, 'mjs'];

module.exports = config;

================
File: app/src/app/components/common/AnimatedLabelSelector.tsx
================
import React, { useRef, useEffect } from 'react';
import {
  View,
  TouchableOpacity,
  Animated,
  StyleSheet,
  Text,
  StyleProp,
  ViewStyle,
  TextStyle,
  ActivityIndicator,
} from 'react-native';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { Icon, IconButton } from 'react-native-paper';

interface AnimatedLabelSelectorProps {
  label: string;
  value: string | null | undefined;
  onPress: () => void;
  onClear?: () => void;
  containerStyle?: StyleProp<ViewStyle>;
  valueStyle?: StyleProp<TextStyle>;
  labelStyle?: StyleProp<TextStyle>;
  activeLabelColor?: string;
  inactiveLabelColor?: string;
  borderColor?: string;
  activeBorderColor?: string;
  disabled?: boolean;
  isLoading?: boolean;
  error?: boolean;
  errorColor?: string;
}

const AnimatedLabelSelector: React.FC<AnimatedLabelSelectorProps> = ({
  label,
  value,
  onPress,
  onClear,
  containerStyle,
  valueStyle,
  labelStyle,
  activeLabelColor,
  inactiveLabelColor,
  borderColor: defaultBorderColor,
  activeBorderColor: focusedBorderColor,
  disabled = false,
  isLoading = false,
  error = false,
  errorColor: customErrorColor,
  ...rest
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();

  const isActive = value != null && value !== '';
  const animation = useRef(new Animated.Value(isActive ? 1 : 0)).current;

  const finalActiveLabelColor = activeLabelColor || theme.colors.primary;
  const finalInactiveLabelColor =
    inactiveLabelColor || theme.colors.onSurfaceVariant;
  const finalBorderColor = defaultBorderColor || theme.colors.outline;
  const finalActiveBorderColor = focusedBorderColor || theme.colors.primary;
  const finalErrorColor = customErrorColor || theme.colors.error;

  const currentBorderColor = disabled
    ? theme.colors.surfaceVariant
    : error
      ? finalErrorColor
      : isActive
        ? finalActiveBorderColor
        : finalBorderColor;

  useEffect(() => {
    Animated.timing(animation, {
      toValue: isActive ? 1 : 0,
      duration: 200,
      useNativeDriver: false,
    }).start();
  }, [isActive, animation]);

  const labelTranslateY = animation.interpolate({
    inputRange: [0, 1],
    outputRange: [0, -26],
  });

  const labelScale = animation.interpolate({
    inputRange: [0, 1],
    outputRange: [1, 0.8],
  });

  const labelColor = animation.interpolate({
    inputRange: [0, 1],
    outputRange: [finalInactiveLabelColor, finalActiveLabelColor],
  });

  const styles = React.useMemo(
    () =>
      createStyles(theme, responsive, {
        disabled,
        finalInactiveLabelColor,
      }),
    [theme, responsive, disabled, finalInactiveLabelColor],
  );

  const animatedLabelStyle = {
    transform: [{ translateY: labelTranslateY }, { scale: labelScale }],
    color: labelColor,
    backgroundColor: animation.interpolate({
      inputRange: [0, 1],
      outputRange: ['transparent', theme.colors.background],
    }),
  };

  // Estilos est√°ticos que no deben ser animados
  const staticLabelStyle = {
    paddingHorizontal: isActive ? 4 : 0,
    zIndex: isActive ? 2 : 0,
  };

  return (
    <View style={styles.outerContainer}>
      <TouchableOpacity
        onPress={onPress}
        disabled={disabled || isLoading}
        style={[
          styles.container,
          { borderColor: currentBorderColor },
          containerStyle,
        ]}
        activeOpacity={0.7}
        {...rest}
      >
        <Animated.Text
          style={[
            styles.label,
            staticLabelStyle,
            labelStyle,
            animatedLabelStyle,
          ]}
          numberOfLines={1}
        >
          {label}
        </Animated.Text>
        <View style={styles.valueContainer}>
          <Text style={[styles.valueText, valueStyle]} numberOfLines={1}>
            {!isLoading ? value || ' ' : ' '}
          </Text>
          <View style={styles.iconsContainer}>
            {isLoading ? (
              <ActivityIndicator
                size="small"
                color={theme.colors.primary}
                style={styles.loader}
              />
            ) : (
              <Icon
                source="chevron-down"
                size={20}
                color={
                  disabled
                    ? theme.colors.onSurfaceDisabled
                    : theme.colors.onSurfaceVariant
                }
              />
            )}
          </View>
        </View>

        {disabled && <View style={styles.disabledOverlay} />}
      </TouchableOpacity>

      {isActive && !disabled && !isLoading && onClear && (
        <View style={styles.clearButtonContainer}>
          <IconButton
            icon="close-circle"
            size={24}
            onPress={onClear}
            iconColor={theme.colors.onSurfaceVariant}
            style={styles.clearButton}
            rippleColor="rgba(0, 0, 0, .1)"
          />
        </View>
      )}
    </View>
  );
};

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
  props: {
    disabled: boolean;
    finalInactiveLabelColor: string;
  },
) =>
  StyleSheet.create({
    container: {
      borderWidth: 1,
      borderRadius: theme.roundness,
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.isTablet ? 16 : 18,
      paddingBottom: responsive.isTablet ? 4 : 6,
      position: 'relative',
      backgroundColor: theme.colors.background,
      minHeight: responsive.isTablet ? 52 : 58,
      justifyContent: 'center',
      flex: 1,
    },
    outerContainer: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    label: {
      position: 'absolute',
      left: responsive.spacing(theme.spacing.m),
      top: responsive.isTablet ? 16 : 18,
      fontSize: responsive.fontSize(16),
      color: props.finalInactiveLabelColor,
      zIndex: 1,
    },
    valueContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      minHeight: responsive.isTablet ? 20 : 24,
    },
    valueText: {
      fontSize: responsive.fontSize(16),
      color: props.disabled
        ? theme.colors.onSurfaceDisabled
        : theme.colors.onSurface,
      flex: 1,
      marginRight: responsive.spacing(theme.spacing.xs),
    },
    loader: {},
    iconsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    clearButtonContainer: {
      marginLeft: responsive.spacing(theme.spacing.s),
      height: responsive.isTablet ? 52 : 58,
      justifyContent: 'center',
    },
    clearButton: {
      margin: 0,
    },
    icon: {},
    disabledOverlay: {
      ...StyleSheet.absoluteFillObject,
      backgroundColor: theme.dark
        ? 'rgba(0, 0, 0, 0.2)'
        : 'rgba(0, 0, 0, 0.05)',
      zIndex: 3,
      borderRadius: theme.roundness,
    },
  });

export default AnimatedLabelSelector;

================
File: app/src/app/components/common/AutoImage.tsx
================
import React, { useState, useEffect, useMemo } from 'react';
import {
  StyleSheet,
  Platform,
  View,
  ActivityIndicator,
  StyleProp,
  ViewStyle,
  DimensionValue,
} from 'react-native';
import { Image, ImageProps as ExpoImageProps } from 'expo-image';
import { Icon } from 'react-native-paper';
import { getCachedImageUri } from '../../lib/imageCache';
import { getImageUrl } from '../../lib/imageUtils';
import { useAppTheme, AppTheme } from '../../styles/theme';
import { useResponsive } from '../../hooks/useResponsive';

export interface AutoImageProps
  extends Omit<ExpoImageProps, 'source' | 'style'> {
  source: string | null | undefined;
  maxWidth?: number;
  maxHeight?: number;
  useCache?: boolean;
  placeholder?: ExpoImageProps['placeholder'];
  placeholderIcon?: string;
  contentFit?: ExpoImageProps['contentFit'];
  transition?: ExpoImageProps['transition'];
  style?: StyleProp<ViewStyle>;
}

function useAutoImageSize(
  maxWidth?: number,
  maxHeight?: number,
): { width?: number | string; height?: number | string } {
  return {
    width: maxWidth ?? '100%',
    height: maxHeight ?? '100%',
  };
}

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      overflow: 'hidden',
      justifyContent: 'center',
      alignItems: 'center',
      backgroundColor: theme.colors.surfaceVariant,
    },
    loadingIndicator: {
      position: 'absolute',
    },
    image: {
      width: '100%',
      height: '100%',
    },
  });

export const AutoImage: React.FC<AutoImageProps> = ({
  source: originalSourceProp,
  maxWidth,
  maxHeight,
  useCache = true,
  style,
  placeholder,
  placeholderIcon = 'image-off-outline',
  contentFit = 'cover',
  transition = 300,
  ...restExpoImageProps
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const [processedUri, setProcessedUri] = useState<string | null>(null);
  const [isLoadingUri, setIsLoadingUri] = useState(true);

  const { width, height } = useAutoImageSize(maxWidth, maxHeight); // Eliminado argumento uri no usado

  useEffect(() => {
    let isMounted = true;
    setIsLoadingUri(true);
    setProcessedUri(null);

    if (!originalSourceProp) {
      if (isMounted) {
        setIsLoadingUri(false);
      }
      return;
    }

    const processSource = async () => {
      const fullRemoteUrl = await getImageUrl(originalSourceProp);

      if (!fullRemoteUrl) {
        if (isMounted) setIsLoadingUri(false);
        return;
      }

      // Si NO se usa cach√©, o es web, o es una URI local, usar la URL construida directamente
      if (
        !useCache ||
        Platform.OS === 'web' ||
        fullRemoteUrl.startsWith('file://')
      ) {
        if (isMounted) {
          setProcessedUri(fullRemoteUrl);
          setIsLoadingUri(false);
        }
        return;
      }

      try {
        const cachedUri = await getCachedImageUri(fullRemoteUrl);
        if (isMounted) {
          setProcessedUri(cachedUri ?? fullRemoteUrl);
          setIsLoadingUri(false);
        }
      } catch (error) {
        if (isMounted) {
          setProcessedUri(fullRemoteUrl);
          setIsLoadingUri(false);
        }
      }
    };

    processSource();

    return () => {
      isMounted = false;
    };
  }, [originalSourceProp, useCache]);

  const styles = useMemo(() => createStyles(theme), [theme]);

  const containerStyle: StyleProp<ViewStyle> = useMemo(
    () => [
      styles.container,
      { width: width as DimensionValue, height: height as DimensionValue },
      style,
    ],
    [styles, width, height, style],
  );

  const iconSize = useMemo(() => {
    if (typeof width === 'number' && typeof height === 'number') {
      return Math.min(width, height) * 0.4;
    }
    return responsive.dimensions.iconSize.large;
  }, [width, height, responsive.dimensions.iconSize.large]);

  return (
    <View style={containerStyle}>
      {processedUri ? (
        <>
          <Image
            source={{ uri: processedUri }}
            style={styles.image}
            placeholder={placeholder}
            contentFit={contentFit}
            transition={transition}
            cachePolicy="memory-disk"
            {...restExpoImageProps}
          />
          {isLoadingUri && originalSourceProp && (
            <ActivityIndicator
              style={styles.loadingIndicator}
              animating={true}
              color={theme.colors.primary}
              size="small"
            />
          )}
        </>
      ) : (
        !isLoadingUri && (
          <Icon
            source={placeholderIcon}
            size={iconSize}
            color={theme.colors.onSurfaceVariant}
          />
        )
      )}
    </View>
  );
};

export default AutoImage;

================
File: app/src/app/components/common/EmptyState.tsx
================
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, Button, Icon } from 'react-native-paper';
import { useAppTheme, AppTheme } from '../../styles/theme';
import { useResponsive } from '../../hooks/useResponsive';

interface EmptyStateProps {
  icon?: string;
  title: string;
  message?: string;
  actionLabel?: string;
  onAction?: () => void;
}

const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.isTablet ? responsive.spacing.l : theme.spacing.xl,
    },
    iconContainer: {
      marginBottom: responsive.isTablet
        ? responsive.spacing.m
        : theme.spacing.l,
    },
    title: {
      textAlign: 'center',
      marginBottom: theme.spacing.s,
      color: theme.colors.onSurface,
    },
    message: {
      textAlign: 'center',
      marginBottom: responsive.isTablet
        ? responsive.spacing.m
        : theme.spacing.l,
      color: theme.colors.onSurfaceVariant,
      paddingHorizontal: responsive.isTablet
        ? responsive.spacing.l
        : theme.spacing.xl,
      fontSize: responsive.isTablet ? 14 : 16,
      lineHeight: responsive.isTablet ? 20 : 24,
    },
    button: {
      marginTop: responsive.isTablet ? responsive.spacing.s : theme.spacing.m,
    },
  });

const EmptyState: React.FC<EmptyStateProps> = ({
  icon = 'folder-open',
  title,
  message,
  actionLabel,
  onAction,
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = getStyles(theme, responsive);

  return (
    <View style={styles.container}>
      <View style={styles.iconContainer}>
        <Icon
          source={icon}
          size={responsive.isTablet ? 56 : 64}
          color={theme.colors.onSurfaceVariant}
        />
      </View>
      <Text variant="headlineSmall" style={styles.title}>
        {title}
      </Text>
      {message && (
        <Text variant="bodyLarge" style={styles.message}>
          {message}
        </Text>
      )}
      {actionLabel && onAction && (
        <Button mode="contained" onPress={onAction} style={styles.button}>
          {actionLabel}
        </Button>
      )}
    </View>
  );
};

export default EmptyState;

================
File: app/src/app/components/OrientationTransition.tsx
================
import React, { useEffect, useState, useCallback } from 'react';
import { View, ActivityIndicator, StyleSheet, Platform } from 'react-native';
import { Text } from 'react-native-paper';
import * as ScreenOrientation from 'expo-screen-orientation';
import { useAppTheme } from '../styles/theme';

interface OrientationTransitionProps {
  children: React.ReactNode;
  targetOrientation?: ScreenOrientation.OrientationLock;
}

const TRANSITION_DELAYS = {
  UNLOCK: 100,
  LOCK: 300,
} as const;

export const OrientationTransition: React.FC<OrientationTransitionProps> = ({
  children,
  targetOrientation = ScreenOrientation.OrientationLock.PORTRAIT_UP,
}) => {
  const theme = useAppTheme();
  const [isTransitioning, setIsTransitioning] = useState(Platform.OS !== 'web');

  const handleOrientationChange = useCallback(async () => {
    if (Platform.OS === 'web') {
      return;
    }

    setIsTransitioning(true);

    try {
      await ScreenOrientation.unlockAsync();
      await new Promise((resolve) =>
        setTimeout(resolve, TRANSITION_DELAYS.UNLOCK),
      );
      await ScreenOrientation.lockAsync(targetOrientation);
      await new Promise((resolve) =>
        setTimeout(resolve, TRANSITION_DELAYS.LOCK),
      );
    } catch (error) {
    } finally {
      setIsTransitioning(false);
    }
  }, [targetOrientation]);

  useEffect(() => {
    handleOrientationChange();
  }, [handleOrientationChange]);

  if (isTransitioning && Platform.OS !== 'web') {
    return (
      <View
        style={[styles.container, { backgroundColor: theme.colors.background }]}
      >
        <ActivityIndicator size="large" color={theme.colors.primary} />
        <Text style={[styles.text, { color: theme.colors.onBackground }]}>
          Ajustando pantalla...
        </Text>
      </View>
    );
  }

  return <>{children}</>;
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    marginTop: 16,
    fontSize: 16,
  },
});

================
File: app/src/app/components/responsive/ResponsiveImage.tsx
================
import React, { useMemo } from 'react';
import { Image } from 'expo-image';
import { ImageProps } from 'expo-image';
import { StyleProp, ImageStyle } from 'react-native';
import { useResponsive } from '@/app/hooks/useResponsive';

interface ResponsiveImageProps
  extends Omit<ImageProps, 'style' | 'width' | 'height'> {
  style?: StyleProp<ImageStyle>;

  // Dimensiones base
  width?: number;
  height?: number;

  // Dimensiones responsive
  widthMobile?: number;
  widthTablet?: number;
  heightMobile?: number;
  heightTablet?: number;

  // Dimensiones por orientaci√≥n
  widthPortrait?: number;
  widthLandscape?: number;
  heightPortrait?: number;
  heightLandscape?: number;

  // Escalado autom√°tico
  autoScale?: boolean;
  minScale?: number;
  maxScale?: number;

  // Aspect ratio
  aspectRatio?: number;
  maintainAspectRatio?: boolean;

  // Tama√±os predefinidos
  size?: 'small' | 'medium' | 'large' | 'xlarge';
  sizeTablet?: 'small' | 'medium' | 'large' | 'xlarge';

  // Comportamiento responsive
  fillContainer?: boolean;
  maxWidth?: number | string;
  maxHeight?: number | string;
  minWidth?: number | string;
  minHeight?: number | string;

  // Optimizaci√≥n
  enableDPIScaling?: boolean;

  // Estilos condicionales
  mobileStyle?: StyleProp<ImageStyle>;
  tabletStyle?: StyleProp<ImageStyle>;
  portraitStyle?: StyleProp<ImageStyle>;
  landscapeStyle?: StyleProp<ImageStyle>;
}

// Tama√±os predefinidos
const PREDEFINED_SIZES = {
  small: { mobile: 40, tablet: 48 },
  medium: { mobile: 80, tablet: 96 },
  large: { mobile: 120, tablet: 160 },
  xlarge: { mobile: 200, tablet: 280 },
};

export const ResponsiveImage: React.FC<ResponsiveImageProps> = ({
  style,

  // Dimensiones
  width,
  height,
  widthMobile,
  widthTablet,
  heightMobile,
  heightTablet,
  widthPortrait,
  widthLandscape,
  heightPortrait,
  heightLandscape,

  // Escalado
  autoScale = true,
  minScale = 0.8,
  maxScale = 1.5,

  // Aspect ratio
  aspectRatio,
  maintainAspectRatio = true,

  // Tama√±os predefinidos
  size,
  sizeTablet,

  // Comportamiento
  fillContainer = false,
  maxWidth,
  maxHeight,
  minWidth,
  minHeight,

  // Optimizaci√≥n
  enableDPIScaling = true,

  // Estilos condicionales
  mobileStyle,
  tabletStyle,
  portraitStyle,
  landscapeStyle,

  ...imageProps
}) => {
  const responsive = useResponsive();

  // Calcular dimensiones responsive
  const { responsiveWidth, responsiveHeight } = useMemo(() => {
    let finalWidth: number | undefined;
    let finalHeight: number | undefined;

    // Si se usa un tama√±o predefinido
    if (size || sizeTablet) {
      const currentSize = responsive.isTablet && sizeTablet ? sizeTablet : size;
      if (currentSize) {
        const sizeValue = PREDEFINED_SIZES[currentSize];
        finalWidth = responsive.isTablet ? sizeValue.tablet : sizeValue.mobile;
        finalHeight = finalWidth; // Por defecto, las im√°genes predefinidas son cuadradas
      }
    }

    // Dimensiones espec√≠ficas por dispositivo
    if (responsive.isTablet) {
      finalWidth = widthTablet || width || finalWidth;
      finalHeight = heightTablet || height || finalHeight;
    } else {
      finalWidth = widthMobile || width || finalWidth;
      finalHeight = heightMobile || height || finalHeight;
    }

    // Dimensiones por orientaci√≥n (tienen prioridad)
    if (responsive.isPortrait) {
      finalWidth = widthPortrait || finalWidth;
      finalHeight = heightPortrait || finalHeight;
    } else if (responsive.isLandscape) {
      finalWidth = widthLandscape || finalWidth;
      finalHeight = heightLandscape || finalHeight;
    }

    // Aplicar escalado autom√°tico si est√° habilitado
    if (autoScale && finalWidth) {
      finalWidth = responsive.scaleWithLimits(finalWidth, minScale, maxScale);
    }
    if (autoScale && finalHeight) {
      finalHeight = responsive.scaleWithLimits(finalHeight, minScale, maxScale);
    }

    // Mantener aspect ratio si es necesario
    if (maintainAspectRatio && aspectRatio && finalWidth && !finalHeight) {
      finalHeight = finalWidth / aspectRatio;
    } else if (
      maintainAspectRatio &&
      aspectRatio &&
      finalHeight &&
      !finalWidth
    ) {
      finalWidth = finalHeight * aspectRatio;
    }

    // Aplicar DPI scaling si est√° habilitado
    if (enableDPIScaling) {
      if (finalWidth) finalWidth = responsive.normalizeDPI(finalWidth);
      if (finalHeight) finalHeight = responsive.normalizeDPI(finalHeight);
    }

    return {
      responsiveWidth: finalWidth,
      responsiveHeight: finalHeight,
    };
  }, [
    width,
    height,
    widthMobile,
    widthTablet,
    heightMobile,
    heightTablet,
    widthPortrait,
    widthLandscape,
    heightPortrait,
    heightLandscape,
    size,
    sizeTablet,
    autoScale,
    minScale,
    maxScale,
    aspectRatio,
    maintainAspectRatio,
    enableDPIScaling,
    responsive,
  ]);

  // Calcular estilos responsive
  const responsiveStyles = useMemo(() => {
    const baseStyle: ImageStyle = {};

    // Aplicar dimensiones calculadas
    if (responsiveWidth) baseStyle.width = responsiveWidth;
    if (responsiveHeight) baseStyle.height = responsiveHeight;

    // Si fillContainer est√° activo
    if (fillContainer) {
      baseStyle.width = '100%';
      baseStyle.height = '100%';
    }

    // Aplicar l√≠mites
    if (maxWidth) baseStyle.maxWidth = maxWidth as any;
    if (maxHeight) baseStyle.maxHeight = maxHeight as any;
    if (minWidth) baseStyle.minWidth = minWidth as any;
    if (minHeight) baseStyle.minHeight = minHeight as any;

    // Aplicar aspect ratio si no hay altura definida
    if (aspectRatio && !responsiveHeight && !fillContainer) {
      baseStyle.aspectRatio = aspectRatio;
    }

    // Estilos condicionales por dispositivo
    const deviceStyle = responsive.isTablet ? tabletStyle : mobileStyle;

    // Estilos condicionales por orientaci√≥n
    const orientationStyle = responsive.isPortrait
      ? portraitStyle
      : landscapeStyle;

    // Combinar todos los estilos
    return [baseStyle, deviceStyle, orientationStyle, style].filter(Boolean);
  }, [
    responsiveWidth,
    responsiveHeight,
    fillContainer,
    maxWidth,
    maxHeight,
    minWidth,
    minHeight,
    aspectRatio,
    mobileStyle,
    tabletStyle,
    portraitStyle,
    landscapeStyle,
    style,
    responsive,
  ]);

  // Props optimizadas para Image
  const optimizedImageProps = useMemo(() => {
    const props: Partial<ImageProps> = {
      ...imageProps,
      style: responsiveStyles,
      cachePolicy: 'memory-disk',
      priority: responsive.isTablet ? 'normal' : 'high',
      contentFit: imageProps.contentFit || 'cover',
    };

    // Solo aplicar quality si la fuente es una URI
    if (
      imageProps.source &&
      typeof imageProps.source === 'object' &&
      'uri' in imageProps.source
    ) {
      props.source = {
        ...imageProps.source,
        // La API de expo-image no soporta quality directamente,
        // pero podemos usar esto para futuras optimizaciones
      };
    }

    return props;
  }, [imageProps, responsiveStyles, responsive.isTablet]);

  return <Image {...optimizedImageProps} />;
};

// Componente helper para avatares responsive
export const ResponsiveAvatar: React.FC<
  ResponsiveImageProps & { rounded?: boolean }
> = ({ rounded = true, ...props }) => {
  const style: ImageStyle = rounded ? { borderRadius: 9999 } : {};

  return (
    <ResponsiveImage
      {...props}
      style={[style, props.style]}
      contentFit="cover"
      maintainAspectRatio={true}
      aspectRatio={1}
    />
  );
};

// Componente helper para thumbnails responsive
export const ResponsiveThumbnail: React.FC<ResponsiveImageProps> = (props) => {
  return (
    <ResponsiveImage
      size="medium"
      sizeTablet="large"
      contentFit="cover"
      enableDPIScaling={true}
      {...props}
    />
  );
};

================
File: app/src/app/components/responsive/ResponsiveModal.tsx
================
import React, { ReactNode, useMemo } from 'react';
import { Modal, Portal, Text, IconButton } from 'react-native-paper';
import {
  ScrollView,
  ViewStyle,
  StyleProp,
  View,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useAppTheme } from '@/app/styles/theme';

interface ResponsiveModalProps {
  visible: boolean;
  onDismiss: () => void;
  children: ReactNode;

  // Header configuration
  title?: string;
  hideCloseButton?: boolean;
  headerActions?: ReactNode;
  headerStyle?: StyleProp<ViewStyle>;

  // Estilo
  contentContainerStyle?: StyleProp<ViewStyle>;
  style?: StyleProp<ViewStyle>;

  // Dimensiones responsive
  width?: number | string;
  widthMobile?: number | string;
  widthTablet?: number | string;

  maxWidth?: number | string;
  maxWidthMobile?: number | string;
  maxWidthTablet?: number | string;

  height?: number | string;
  heightMobile?: number | string;
  heightTablet?: number | string;

  maxHeight?: number | string;
  maxHeightMobile?: number | string;
  maxHeightTablet?: number | string;

  // Padding responsive
  padding?: number;
  paddingMobile?: number;
  paddingTablet?: number;

  // Comportamiento
  dismissable?: boolean;
  dismissableBackButton?: boolean;
  scrollable?: boolean;
  keyboardAvoiding?: boolean;
  fullScreen?: boolean;
  fullScreenMobile?: boolean;

  // Posici√≥n
  position?: 'center' | 'bottom' | 'top';
  positionMobile?: 'center' | 'bottom' | 'top';
  positionTablet?: 'center' | 'bottom' | 'top';

  // Animaci√≥n
  animationType?: 'fade' | 'slide' | 'none';

  // Footer opcional
  footer?: ReactNode;
  footerStyle?: StyleProp<ViewStyle>;
  stickyFooter?: boolean;
}

export const ResponsiveModal: React.FC<ResponsiveModalProps> = ({
  visible,
  onDismiss,
  children,

  // Header
  title,
  hideCloseButton = false,
  headerActions,
  headerStyle,

  // Estilo
  contentContainerStyle,
  style,

  // Dimensiones
  width,
  widthMobile,
  widthTablet,
  maxWidth,
  maxWidthMobile,
  maxWidthTablet,
  height,
  heightMobile,
  heightTablet,
  maxHeight,
  maxHeightMobile,
  maxHeightTablet,

  // Padding
  padding,
  paddingMobile,
  paddingTablet,

  // Comportamiento
  dismissable = true,
  dismissableBackButton = true,
  scrollable = true,
  keyboardAvoiding = true,
  fullScreen = false,
  fullScreenMobile = false,

  // Posici√≥n
  position = 'center',
  positionMobile,
  positionTablet,

  // Footer
  footer,
  footerStyle,
  stickyFooter = true,
}) => {
  const responsive = useResponsive();
  const theme = useAppTheme();
  const insets = useSafeAreaInsets();

  // Determinar si debe ser fullscreen
  const isFullScreen =
    responsive.isMobile && fullScreenMobile ? true : fullScreen;

  // Calcular posici√≥n responsive
  const modalPosition = responsive.isTablet
    ? positionTablet || position
    : positionMobile || position;

  // Calcular dimensiones responsive
  const modalDimensions = useMemo(() => {
    const dims: ViewStyle = {};

    // Width
    if (responsive.isTablet) {
      dims.width = (widthTablet ||
        width ||
        responsive.dimensions.modalWidth) as any;
      dims.maxWidth = (maxWidthTablet || maxWidth || '90%') as any;
    } else {
      dims.width = (widthMobile ||
        width ||
        (isFullScreen ? '100%' : '95%')) as any;
      dims.maxWidth = (maxWidthMobile || maxWidth || '100%') as any;
    }

    // Height
    if (height || heightMobile || heightTablet) {
      dims.height = (
        responsive.isTablet ? heightTablet || height : heightMobile || height
      ) as any;
    }

    if (maxHeight || maxHeightMobile || maxHeightTablet) {
      dims.maxHeight = (
        responsive.isTablet
          ? maxHeightTablet || maxHeight || '95%'
          : maxHeightMobile || maxHeight || '92%'
      ) as any;
    } else {
      // Default max height
      dims.maxHeight = responsive.isTablet ? '95%' : '92%';
    }

    // Si es fullscreen, ajustar dimensiones
    if (isFullScreen) {
      dims.width = '100%';
      dims.height = '100%';
      dims.maxWidth = '100%';
      dims.maxHeight = '100%';
    }

    return dims;
  }, [
    responsive,
    width,
    widthMobile,
    widthTablet,
    maxWidth,
    maxWidthMobile,
    maxWidthTablet,
    height,
    heightMobile,
    heightTablet,
    maxHeight,
    maxHeightMobile,
    maxHeightTablet,
    isFullScreen,
  ]);

  // Calcular padding responsive
  const modalPadding = useMemo(() => {
    if (isFullScreen) return 0;

    if (responsive.isTablet) {
      return paddingTablet || padding || responsive.spacing.l;
    } else {
      return paddingMobile || padding || responsive.spacing.m;
    }
  }, [responsive, padding, paddingMobile, paddingTablet, isFullScreen]);

  // Estilos del modal seg√∫n posici√≥n
  const positionStyles = useMemo(() => {
    const styles: ViewStyle = {};

    switch (modalPosition) {
      case 'bottom':
        styles.justifyContent = 'flex-end';
        break;
      case 'top':
        styles.justifyContent = 'flex-start';
        break;
      case 'center':
      default:
        styles.justifyContent = 'center';
        styles.alignItems = 'center';
        break;
    }

    return styles;
  }, [modalPosition]);

  // Estilos del contenedor
  const containerStyles = useMemo(() => {
    const baseStyles: ViewStyle = {
      backgroundColor: theme.colors.surface,
      borderRadius: isFullScreen ? 0 : theme.roundness * 2,
      overflow: 'hidden',
      ...modalDimensions,
    };

    // Ajustes seg√∫n posici√≥n
    if (modalPosition === 'bottom' && !isFullScreen) {
      baseStyles.borderBottomLeftRadius = 0;
      baseStyles.borderBottomRightRadius = 0;
      baseStyles.width = '100%';
      baseStyles.maxWidth = '100%';
    }

    if (modalPosition === 'top' && !isFullScreen) {
      baseStyles.borderTopLeftRadius = 0;
      baseStyles.borderTopRightRadius = 0;
      baseStyles.width = '100%';
      baseStyles.maxWidth = '100%';
    }

    // Safe area para fullscreen
    if (isFullScreen) {
      baseStyles.paddingTop = insets.top;
      baseStyles.paddingBottom = insets.bottom;
    }

    return [baseStyles, contentContainerStyle];
  }, [
    theme,
    modalDimensions,
    modalPosition,
    isFullScreen,
    insets,
    contentContainerStyle,
  ]);

  // Estilos del header
  const headerStyles = useMemo(
    () => ({
      flexDirection: 'row' as const,
      alignItems: 'center' as const,
      justifyContent: 'space-between' as const,
      paddingHorizontal: modalPadding,
      paddingVertical: modalPadding * 0.75,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
    }),
    [theme, modalPadding],
  );

  // Header del modal
  const modalHeader = (title || headerActions || !hideCloseButton) && (
    <View style={[headerStyles, headerStyle]}>
      {title && (
        <Text
          variant="titleLarge"
          style={{
            color: theme.colors.onSurface,
            fontWeight: '600',
            flex: 1,
          }}
          numberOfLines={1}
        >
          {title}
        </Text>
      )}
      <View
        style={{
          flexDirection: 'row',
          alignItems: 'center',
          gap: responsive.spacing.s,
        }}
      >
        {headerActions}
        {!hideCloseButton && (
          <IconButton
            icon="close"
            size={24}
            onPress={onDismiss}
            style={{ marginRight: -responsive.spacing.s }}
          />
        )}
      </View>
    </View>
  );

  // Contenido del modal
  const modalContent = (
    <View
      style={{
        flex: scrollable ? 1 : undefined,
        padding: title ? 0 : modalPadding,
      }}
    >
      {title && modalHeader}
      <View
        style={{
          flex: scrollable ? 1 : undefined,
          padding: title ? modalPadding : 0,
        }}
      >
        {scrollable ? (
          <ScrollView
            showsVerticalScrollIndicator={false}
            contentContainerStyle={{ flexGrow: 1 }}
            keyboardShouldPersistTaps="handled"
          >
            {children}
          </ScrollView>
        ) : (
          children
        )}
      </View>
    </View>
  );

  // Footer handling
  const modalFooter = footer && (
    <View
      style={[
        {
          padding: modalPadding,
          paddingTop: modalPadding / 2,
          backgroundColor: theme.colors.surface,
          borderTopWidth: 1,
          borderTopColor: theme.colors.surfaceVariant,
        },
        footerStyle,
      ]}
    >
      {footer}
    </View>
  );

  return (
    <>
      {visible && (
        <Portal>
          <Modal
            visible={visible}
            onDismiss={onDismiss}
            dismissable={dismissable}
            dismissableBackButton={dismissableBackButton}
            contentContainerStyle={[positionStyles, style]}
            style={{ margin: isFullScreen ? 0 : undefined }}
          >
            {keyboardAvoiding && Platform.OS === 'ios' ? (
              <KeyboardAvoidingView
                behavior="padding"
                style={containerStyles}
                keyboardVerticalOffset={isFullScreen ? 0 : 100}
              >
                {modalContent}
                {stickyFooter && modalFooter}
              </KeyboardAvoidingView>
            ) : (
              <View style={containerStyles}>
                {modalContent}
                {stickyFooter && modalFooter}
              </View>
            )}
          </Modal>
        </Portal>
      )}
    </>
  );
};

// Componente helper para modales de confirmaci√≥n
interface ResponsiveConfirmModalProps
  extends Omit<ResponsiveModalProps, 'children'> {
  title: string;
  message: string;
  confirmText?: string;
  cancelText?: string;
  onConfirm: () => void;
  onCancel?: () => void;
  destructive?: boolean;
}

export const ResponsiveConfirmModal: React.FC<ResponsiveConfirmModalProps> = ({
  title,
  message,
  confirmText = 'Confirmar',
  cancelText = 'Cancelar',
  onConfirm,
  onCancel,
  destructive = false,
  ...modalProps
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();

  const handleCancel = () => {
    onCancel?.();
    modalProps.onDismiss();
  };

  const handleConfirm = () => {
    onConfirm();
    modalProps.onDismiss();
  };

  return (
    <ResponsiveModal
      {...modalProps}
      scrollable={false}
      maxWidthTablet={400}
      position="center"
    >
      <View style={{ paddingVertical: responsive.spacing.m }}>
        <Text
          style={[
            theme.fonts.headlineSmall,
            {
              color: theme.colors.onSurface,
              marginBottom: responsive.spacing.m,
            },
          ]}
        >
          {title}
        </Text>
        <Text
          style={[
            theme.fonts.bodyMedium,
            { color: theme.colors.onSurfaceVariant },
          ]}
        >
          {message}
        </Text>
      </View>
      <View
        style={{
          flexDirection: 'row',
          justifyContent: 'flex-end',
          gap: responsive.spacing.s,
          marginTop: responsive.spacing.l,
        }}
      >
        <Button mode="text" onPress={handleCancel} style={{ minWidth: 80 }}>
          {cancelText}
        </Button>
        <Button
          mode="contained"
          onPress={handleConfirm}
          buttonColor={destructive ? theme.colors.error : undefined}
          style={{ minWidth: 80 }}
        >
          {confirmText}
        </Button>
      </View>
    </ResponsiveModal>
  );
};

// Imports necesarios para los componentes de React Native Paper
import { Button } from 'react-native-paper';

================
File: app/src/app/components/ServerConfigModal.tsx
================
import React, { useEffect, useState } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  ActivityIndicator,
  Platform,
} from 'react-native';
import {
  Text,
  Modal,
  Portal,
  Surface,
  RadioButton,
  TextInput,
  Button,
  HelperText,
  Chip,
  IconButton,
  useTheme,
} from 'react-native-paper';
import { useSnackbar } from '@/hooks/useSnackbar';
import {
  serverConnectionService,
  ConnectionMode,
} from '@/services/serverConnectionService';
import { discoveryService } from '@/app/services/discoveryService';
import EncryptedStorage from '@/app/services/secureStorageService';
import axios from 'axios';

const STORAGE_KEYS = {
  CONNECTION_MODE: 'connection_mode',
  MANUAL_URL: 'manual_server_url',
};

interface ServerConfigModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSuccess?: () => void;
}

export function ServerConfigModal({
  visible,
  onDismiss,
  onSuccess,
}: ServerConfigModalProps) {
  const theme = useTheme();
  const { showSnackbar } = useSnackbar();

  const [mode, setMode] = useState<ConnectionMode>('auto');
  const [manualUrl, setManualUrl] = useState('');
  const [currentUrl, setCurrentUrl] = useState<string | null>(null);
  const [testing, setTesting] = useState(false);
  const [loading, setLoading] = useState(true);
  const [remoteUrlAvailable, setRemoteUrlAvailable] = useState<string | null>(
    null,
  );

  useEffect(() => {
    if (visible) {
      loadSettings();
    }
  }, [visible]);

  const loadSettings = async () => {
    try {
      setLoading(true);
      const savedMode = (await EncryptedStorage.getItem(
        STORAGE_KEYS.CONNECTION_MODE,
      )) as ConnectionMode;
      const savedUrl = await EncryptedStorage.getItem(STORAGE_KEYS.MANUAL_URL);
      const currentApiUrl = await discoveryService.getApiUrl();

      if (savedMode) setMode(savedMode);
      if (savedUrl) setManualUrl(savedUrl);
      if (currentApiUrl) setCurrentUrl(currentApiUrl);

      if (currentApiUrl) {
        try {
          const response = await axios.get(`${currentApiUrl}/api/v1/discovery`);
          if (response.data.remoteUrl) {
            setRemoteUrlAvailable(response.data.remoteUrl);
          }
        } catch (error) {
        }
      }
    } catch (error) {
      console.error('Error loading settings:', error);
    } finally {
      setLoading(false);
    }
  };

  const normalizeUrl = (url: string): string => {
    if (!url.startsWith('http://') && !url.startsWith('https://')) {
      url = 'http://' + url;
    }

    try {
      const parsed = new URL(url);
      if (
        !parsed.port &&
        (parsed.hostname.startsWith('192.168.') ||
          parsed.hostname.startsWith('10.') ||
          parsed.hostname.startsWith('172.') ||
          parsed.hostname === 'localhost' ||
          /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(parsed.hostname))
      ) {
        parsed.port = '3737';
      }
      return `${parsed.protocol}//${parsed.host}`;
    } catch {
      return url;
    }
  };

  const validateUrl = (url: string): boolean => {
    try {
      const normalized = normalizeUrl(url);
      const parsed = new URL(normalized);
      return ['http:', 'https:'].includes(parsed.protocol);
    } catch {
      return false;
    }
  };

  const testConnection = async () => {
    if (mode === 'manual' && !validateUrl(manualUrl)) {
      showSnackbar('Por favor ingresa una URL v√°lida', 'error');
      return;
    }

    setTesting(true);
    try {
      let urlToTest = '';

      if (mode === 'auto') {
        // Probar auto-descubrimiento
        const discovered = await discoveryService.discoverServer();
        if (!discovered) {
          throw new Error('No se pudo encontrar el servidor en la red local');
        }
        urlToTest = discovered;
      } else if (mode === 'remote' && remoteUrlAvailable) {
        urlToTest = remoteUrlAvailable;
      } else {
        urlToTest = normalizeUrl(manualUrl);
      }

      // Verificar conexi√≥n
      const response = await axios.get(`${urlToTest}/api/v1/discovery`, {
        timeout: 5000,
      });

      if (response.data.type !== 'cloudbite-api') {
        throw new Error('El servidor no es compatible');
      }

      showSnackbar('Conexi√≥n exitosa', 'success');
      setCurrentUrl(urlToTest);
    } catch (error: any) {
      showSnackbar(
        error.message || 'Error al conectar con el servidor',
        'error',
      );
    } finally {
      setTesting(false);
    }
  };

  const saveSettings = async () => {
    try {
      // Guardar modo de conexi√≥n
      await EncryptedStorage.setItem(STORAGE_KEYS.CONNECTION_MODE, mode);

      // Guardar URL manual si aplica
      if (mode === 'manual') {
        if (!validateUrl(manualUrl)) {
          showSnackbar('Por favor ingresa una URL v√°lida', 'error');
          return;
        }
        const normalizedUrl = normalizeUrl(manualUrl);
        await EncryptedStorage.setItem(STORAGE_KEYS.MANUAL_URL, normalizedUrl);
        await discoveryService.setServerUrl(normalizedUrl, true);

        // En web, verificar la conexi√≥n inmediatamente
        if (Platform.OS === 'web') {
          try {
            const response = await axios.get(
              `${normalizedUrl}/api/v1/discovery`,
              {
                timeout: 5000,
              },
            );
            if (response.data.type === 'cloudbite-api') {
              // El servicio detectar√° autom√°ticamente el cambio de URL
            }
          } catch (error) {
            console.error(
              'Error verificando conexi√≥n despu√©s de guardar:',
              error,
            );
          }
        }
      } else if (mode === 'remote' && remoteUrlAvailable) {
        await discoveryService.setServerUrl(remoteUrlAvailable, true);
      } else {
        // Modo autom√°tico - limpiar URL manual
        await discoveryService.setServerUrl(null, true);
      }

      // La reconexi√≥n se manejar√° en el onSuccess callback

      showSnackbar('Configuraci√≥n guardada', 'success');
      onSuccess?.();
      onDismiss();
    } catch (error: any) {
      showSnackbar(
        error.message || 'Error al guardar la configuraci√≥n',
        'error',
      );
    }
  };

  const styles = StyleSheet.create({
    modal: {
      justifyContent: 'center',
      alignItems: 'center',
      margin: 20,
    },
    container: {
      width: '100%',
      maxWidth: 500,
      maxHeight: '90%',
      backgroundColor: theme.colors.surface,
      borderRadius: 16,
      overflow: 'hidden',
    },
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: 16,
      paddingVertical: 12,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    title: {
      fontSize: 20,
      fontWeight: 'bold',
      color: theme.colors.onSurface,
    },
    content: {
      padding: 16,
    },
    loadingContainer: {
      padding: 40,
      alignItems: 'center',
    },
    statusContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 8,
      marginBottom: 16,
    },
    successChip: {
      backgroundColor: theme.colors.primaryContainer,
    },
    errorChip: {
      backgroundColor: theme.colors.errorContainer,
    },
    urlText: {
      flex: 1,
      marginLeft: 8,
      color: theme.colors.onSurfaceVariant,
      fontSize: 12,
    },
    section: {
      marginBottom: 16,
    },
    sectionTitle: {
      fontSize: 16,
      fontWeight: '600',
      marginBottom: 8,
      color: theme.colors.onSurface,
    },
    manualConfig: {
      marginTop: 8,
      marginLeft: 32,
    },
    actions: {
      flexDirection: 'row',
      justifyContent: 'flex-end',
      gap: 8,
      padding: 16,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
    },
  });

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modal}
        dismissable={!testing}
      >
        <Surface style={styles.container}>
          <View style={styles.header}>
            <Text style={styles.title}>Configuraci√≥n del Servidor</Text>
            <IconButton
              icon="close"
              size={24}
              onPress={onDismiss}
              disabled={testing}
            />
          </View>

          <ScrollView style={styles.content}>
            {loading ? (
              <View style={styles.loadingContainer}>
                <ActivityIndicator size="large" />
              </View>
            ) : (
              <>
                {/* Estado actual */}
                <View style={styles.section}>
                  <Text style={styles.sectionTitle}>Estado de Conexi√≥n</Text>
                  {currentUrl ? (
                    <View style={styles.statusContainer}>
                      <Chip
                        icon="check-circle"
                        mode="flat"
                        style={styles.successChip}
                      >
                        Conectado
                      </Chip>
                      <Text
                        variant="bodySmall"
                        style={styles.urlText}
                        numberOfLines={1}
                      >
                        {currentUrl}
                      </Text>
                    </View>
                  ) : (
                    <View style={styles.statusContainer}>
                      <Chip
                        icon="alert-circle"
                        mode="flat"
                        style={styles.errorChip}
                      >
                        Sin conexi√≥n
                      </Chip>
                    </View>
                  )}
                </View>

                {/* Modo de conexi√≥n */}
                <View style={styles.section}>
                  <Text style={styles.sectionTitle}>Modo de Conexi√≥n</Text>
                  <RadioButton.Group
                    onValueChange={(value) => setMode(value as ConnectionMode)}
                    value={mode}
                  >
                    <RadioButton.Item
                      label="Autom√°tico (Red Local)"
                      value="auto"
                      status={mode === 'auto' ? 'checked' : 'unchecked'}
                    />
                    <HelperText type="info" visible={mode === 'auto'}>
                      Busca autom√°ticamente el servidor en tu red local
                    </HelperText>

                    {remoteUrlAvailable && (
                      <>
                        <RadioButton.Item
                          label="Remoto (Internet)"
                          value="remote"
                          status={mode === 'remote' ? 'checked' : 'unchecked'}
                        />
                        <HelperText type="info" visible={mode === 'remote'}>
                          Usa el servidor remoto: {remoteUrlAvailable}
                        </HelperText>
                      </>
                    )}

                    <RadioButton.Item
                      label="Manual"
                      value="manual"
                      status={mode === 'manual' ? 'checked' : 'unchecked'}
                    />

                    {mode === 'manual' && (
                      <View style={styles.manualConfig}>
                        <TextInput
                          label="URL del Servidor"
                          value={manualUrl}
                          onChangeText={setManualUrl}
                          placeholder="192.168.1.230 o http://192.168.1.230:3737"
                          mode="outlined"
                          autoCapitalize="none"
                          autoCorrect={false}
                          keyboardType="url"
                          error={manualUrl !== '' && !validateUrl(manualUrl)}
                        />
                        <HelperText
                          type="info"
                          visible={mode === 'manual' && manualUrl === ''}
                        >
                          Puedes ingresar solo la IP. El puerto 3737 se agregar√°
                          autom√°ticamente.
                        </HelperText>
                        <HelperText
                          type="error"
                          visible={manualUrl !== '' && !validateUrl(manualUrl)}
                        >
                          URL inv√°lida
                        </HelperText>
                      </View>
                    )}
                  </RadioButton.Group>
                </View>
              </>
            )}
          </ScrollView>

          <View style={styles.actions}>
            <Button mode="text" onPress={onDismiss} disabled={testing}>
              Cancelar
            </Button>
            <Button
              mode="outlined"
              onPress={testConnection}
              loading={testing}
              disabled={testing || loading}
              icon="connection"
            >
              Probar
            </Button>
            <Button
              mode="contained"
              onPress={saveSettings}
              disabled={testing || loading}
              icon="content-save"
            >
              Guardar
            </Button>
          </View>
        </Surface>
      </Modal>
    </Portal>
  );
}

================
File: app/src/app/constants/navigationPaths.ts
================
export const NAVIGATION_PATHS = {
  LOGIN: 'Login',

  MAIN_DRAWER: 'MainDrawer',

  ORDERS_STACK: 'OrdersStack',
  ORDERS: 'Orders',
  CREATE_ORDER: 'CreateOrder',
  OPEN_ORDERS: 'OpenOrders',
  ADD_PRODUCTS_TO_ORDER: 'AddProductsToOrder',

  MENU_STACK: 'MenuStack',
  CATEGORIES: 'CategoriesScreen',
  SUBCATEGORIES: 'SubcategoriesScreen',
  PRODUCTS: 'Products',

  AREAS_TABLES_STACK: 'AreasTablesStack',
  AREAS_LIST: 'AreasList',
  TABLES_LIST: 'TablesList',

  MODIFIERS_STACK: 'ModifiersStack',
  MODIFIER_GROUPS: 'ModifierGroupsScreen',
  MODIFIERS: 'ModifiersScreen',

  KITCHEN_STACK: 'KitchenStack',
  KITCHEN_ORDERS: 'KitchenOrders',
  KITCHEN: 'Kitchen',

  RECEIPTS_STACK: 'ReceiptsStack',
  RECEIPTS_LIST: 'ReceiptsList',

  ORDER_FINALIZATION_STACK: 'OrderFinalizationStack',
  ORDER_FINALIZATION: 'OrderFinalizationScreen',

  AVAILABILITY_STACK: 'AvailabilityStack',
  AVAILABILITY: 'AvailabilityScreen',

  RESTAURANT_CONFIG_STACK: 'RestaurantConfigStack',
  RESTAURANT_CONFIG: 'RestaurantConfig',

  CUSTOMERS_STACK: 'CustomersStack',
  CUSTOMERS: 'Customers',

  PIZZA_CUSTOMIZATIONS_STACK: 'PizzaCustomizationsStack',
  PIZZA_CUSTOMIZATIONS_LIST: 'PizzaCustomizationsList',

  SYNC_STACK: 'SyncStack',
  SYNC_STATUS: 'SyncStatus',

  USERS_STACK: 'UsersStack',
  USERS_LIST: 'UsersList',

  SHIFT_AUDIT_STACK: 'ShiftAuditStack',
  SHIFTS_LIST: 'ShiftsList',

  PRINTERS_STACK: 'PrintersStack',
  PRINTERS_LIST: 'PrintersList',

  PREPARATION_SCREENS_STACK: 'PreparationScreensStack',
  PREPARATION_SCREENS_LIST: 'PreparationScreensList',
} as const;

export type RootStackParamList = {
  [NAVIGATION_PATHS.LOGIN]: undefined;
  [NAVIGATION_PATHS.MAIN_DRAWER]: undefined;
};

export type OrdersStackParamList = {
  [NAVIGATION_PATHS.ORDERS]: undefined;
  [NAVIGATION_PATHS.CREATE_ORDER]: undefined;
  [NAVIGATION_PATHS.OPEN_ORDERS]: undefined;
  [NAVIGATION_PATHS.ADD_PRODUCTS_TO_ORDER]: {
    orderId: number;
    orderNumber: string;
    existingOrderItemsCount: number;
    existingTempProducts?: any[];
    onProductsAdded?: () => void;
  };
};

export type MenuStackParamList = {
  [NAVIGATION_PATHS.CATEGORIES]: undefined;
  [NAVIGATION_PATHS.SUBCATEGORIES]: {
    categoryId: number;
    categoryName: string;
  };
  [NAVIGATION_PATHS.PRODUCTS]: {
    subcategoryId: number;
    subCategoryName: string;
  };
};

export type AreasTablesStackParamList = {
  [NAVIGATION_PATHS.AREAS_LIST]: undefined;
  [NAVIGATION_PATHS.TABLES_LIST]: {
    areaId: number;
    areaName: string;
  };
};

export type ModifiersStackParamList = {
  [NAVIGATION_PATHS.MODIFIER_GROUPS]: undefined;
  [NAVIGATION_PATHS.MODIFIERS]: {
    groupId: number;
    groupName: string;
  };
};

export type KitchenStackParamList = {
  [NAVIGATION_PATHS.KITCHEN_ORDERS]: undefined;
};

================
File: app/src/app/constants/network.ts
================
export const NETWORK_CONFIG = {
  DISCOVERY_PORT: 3737,

  DISCOVERY_TIMEOUT: 1000,
  HEALTH_CHECK_TIMEOUT: 3000,
  API_TIMEOUT: 5000,

  HEALTH_CHECK_INTERVAL: 30000,
  HEALTH_RETRY_INTERVALS: [5000, 10000, 20000, 30000],

  MIN_DISCOVERY_INTERVAL: 10000,
  RECONNECT_CYCLE_DELAY: 10000,
  HEALTH_CHECK_ATTEMPTS: 3,

  MAX_CONCURRENT_REQUESTS: 50,

  COMMON_SUBNETS: ['192.168.1', '192.168.0', '10.0.0'],
} as const;

================
File: app/src/app/constants/rolePermissions.ts
================
import { RoleEnum } from '@/modules/users/types/user.types';

export type DrawerSection =
  | 'OrdersStack'
  | 'ReceiptsStack'
  | 'OrderFinalizationStack'
  | 'MenuStack'
  | 'AvailabilityStack'
  | 'ModifiersStack'
  | 'PizzaCustomizationsStack'
  | 'PreparationScreensStack'
  | 'AreasTablesStack'
  | 'PrintersStack'
  | 'RestaurantConfigStack'
  | 'CustomersStack'
  | 'SyncStack'
  | 'UsersStack'
  | 'KitchenStack'
  | 'ShiftAuditStack';

// Definir permisos por rol
export const ROLE_PERMISSIONS: Record<RoleEnum, DrawerSection[]> = {
  // Admin - Acceso completo
  [RoleEnum.ADMIN]: [
    'OrdersStack',
    'OrderFinalizationStack',
    'ReceiptsStack',
    'MenuStack',
    'AvailabilityStack',
    'ModifiersStack',
    'PizzaCustomizationsStack',
    'PreparationScreensStack',
    'AreasTablesStack',
    'PrintersStack',
    'RestaurantConfigStack',
    'CustomersStack',
    'SyncStack',
    'UsersStack',
    'ShiftAuditStack',
  ],

  // Manager - Acceso completo excepto usuarios
  [RoleEnum.MANAGER]: [
    'OrdersStack',
    'OrderFinalizationStack',
    'ReceiptsStack',
    'MenuStack',
    'AvailabilityStack',
    'ModifiersStack',
    'PizzaCustomizationsStack',
    'PreparationScreensStack',
    'AreasTablesStack',
    'PrintersStack',
    'RestaurantConfigStack',
    'CustomersStack',
    'SyncStack',
    'ShiftAuditStack',
  ],

  // Cashier - Ventas, clientes y configuraci√≥n b√°sica
  [RoleEnum.CASHIER]: [
    'OrdersStack',
    'OrderFinalizationStack',
    'ReceiptsStack',
    'MenuStack',
    'AvailabilityStack',
    'AreasTablesStack',
    'CustomersStack',
  ],

  // Waiter - √ìrdenes, mesas y disponibilidad
  [RoleEnum.WAITER]: [
    'OrdersStack',
    'MenuStack',
    'AvailabilityStack',
    'AreasTablesStack',
    'CustomersStack',
  ],

  // Kitchen - Solo acceso a pantalla de preparaci√≥n
  // Los usuarios con pantalla asignada van directo a KitchenStack
  [RoleEnum.KITCHEN]: ['KitchenStack'],

  // Delivery - √ìrdenes, clientes y √°reas
  [RoleEnum.DELIVERY]: [
    'OrdersStack',
    'OrderFinalizationStack',
    'CustomersStack',
    'AreasTablesStack',
  ],
};

// Helper para verificar si un rol tiene permiso para una secci√≥n
export const hasPermission = (
  roleId: number | undefined,
  section: DrawerSection,
): boolean => {
  if (!roleId) return false;

  const permissions = ROLE_PERMISSIONS[roleId as RoleEnum];
  return permissions ? permissions.includes(section) : false;
};

// Agrupar secciones por categor√≠a para facilitar el renderizado
export const DRAWER_SECTIONS = {
  sales: {
    title: 'Ventas',
    items: [
      {
        route: 'OrdersStack',
        label: '√ìrdenes',
        icon: 'clipboard-list-outline',
      },
      {
        route: 'OrderFinalizationStack',
        label: 'Finalizaci√≥n',
        icon: 'clipboard-check-outline',
      },
      { route: 'ReceiptsStack', label: 'Recibos', icon: 'receipt' },
    ],
  },
  configuration: {
    title: 'Configuraci√≥n',
    items: [
      { route: 'MenuStack', label: 'Men√∫', icon: 'menu' },
      {
        route: 'AvailabilityStack',
        label: 'Disponibilidad',
        icon: 'eye-off-outline',
      },
      { route: 'ModifiersStack', label: 'Modificadores', icon: 'tune' },
      {
        route: 'PizzaCustomizationsStack',
        label: 'Personalizaci√≥n Pizzas',
        icon: 'pizza',
      },
      {
        route: 'PreparationScreensStack',
        label: 'Pantallas Preparaci√≥n',
        icon: 'monitor-dashboard',
      },
      {
        route: 'AreasTablesStack',
        label: '√Åreas y Mesas',
        icon: 'map-marker-radius-outline',
      },
      { route: 'PrintersStack', label: 'Impresoras', icon: 'printer' },
      {
        route: 'RestaurantConfigStack',
        label: 'Configuraci√≥n',
        icon: 'cog-outline',
      },
      {
        route: 'CustomersStack',
        label: 'Clientes',
        icon: 'account-group-outline',
      },
      { route: 'SyncStack', label: 'Sincronizaci√≥n', icon: 'sync' },
    ],
  },
  administration: {
    title: 'Administraci√≥n',
    items: [
      { route: 'UsersStack', label: 'Usuarios', icon: 'account-multiple' },
      {
        route: 'ShiftAuditStack',
        label: 'Historial de Turnos',
        icon: 'history',
      },
    ],
  },
} as const;

================
File: app/src/app/hooks/useInitializeAuth.ts
================
import { useEffect, useState } from 'react';
import { initializeAuthStore } from '../store/authStore';
import { verifyStoredToken } from '../utils/tokenVerification';

export function useInitializeAuth() {
  const [isInitializing, setIsInitializing] = useState(true);

  useEffect(() => {
    const initialize = async () => {
      try {
        await initializeAuthStore();
        // Verificar el token despu√©s de inicializar el store
        await verifyStoredToken();
      } catch (error) {
        // Error al inicializar auth store
      } finally {
        setIsInitializing(false);
      }
    };

    initialize();
  }, []);

  return isInitializing;
}

================
File: app/src/app/hooks/useNativeDriver.ts
================
import { Platform } from 'react-native';

/**
 * Hook para determinar si usar el driver nativo para animaciones
 * En web, siempre devuelve false para evitar advertencias
 */
export function useNativeDriver(): boolean {
  return Platform.OS !== 'web';
}

================
File: app/src/app/lib/apiResponseHelper.ts
================
import { ApiResponse } from 'apisauce';
import { ApiError } from './errors';
import { BackendErrorResponse } from '../types/api.types';

/**
 * Helper function to handle API error responses consistently
 * If the interceptor already created an ApiError, use it directly
 * Otherwise, create a new one from the response data
 */
export function handleApiError(response: ApiResponse<any>): never {
  // Si hay un apiError ya procesado por el interceptor, usarlo directamente
  if ((response as any).apiError instanceof ApiError) {
    throw (response as any).apiError;
  }

  // Si no, crear uno nuevo (fallback)
  throw ApiError.fromApiResponse(
    response.data as BackendErrorResponse | undefined,
    response.status,
  );
}

================
File: app/src/app/lib/errorMapping.ts
================
import { ApiError } from './errors';
import { ERROR_CODES, ApiErrorCode } from '../constants/apiErrorCodes';
import { AxiosError } from 'axios';

const errorCodeMessages: { [key in ApiErrorCode | string]?: string } = {
  // Errores de autenticaci√≥n
  [ERROR_CODES.AUTH_INVALID_CREDENTIALS]:
    'El correo/usuario o la contrase√±a son incorrectos.',
  [ERROR_CODES.AUTH_INCORRECT_PASSWORD]: 'La contrase√±a es incorrecta.',
  [ERROR_CODES.AUTH_DUPLICATE_EMAIL]:
    'Este correo electr√≥nico ya est√° registrado. Intenta iniciar sesi√≥n.',
  [ERROR_CODES.AUTH_DUPLICATE_USERNAME]:
    'Este nombre de usuario ya est√° en uso. Elige otro.',
  [ERROR_CODES.AUTH_UNAUTHORIZED]:
    'No autorizado. Por favor, inicia sesi√≥n de nuevo.',
  [ERROR_CODES.AUTH_FORBIDDEN]: 'No tienes permiso para realizar esta acci√≥n.',
  [ERROR_CODES.REFRESH_FAILED]:
    'Tu sesi√≥n ha expirado. Por favor, inicia sesi√≥n nuevamente.',

  // Errores de validaci√≥n
  [ERROR_CODES.VALIDATION_ERROR]: 'Por favor, revisa la informaci√≥n ingresada.',

  // Errores de recursos
  [ERROR_CODES.RESOURCE_NOT_FOUND]: 'El recurso solicitado no se encontr√≥.',
  [ERROR_CODES.CONFLICT_ERROR]: 'Hubo un conflicto al procesar tu solicitud.',
  [ERROR_CODES.PRODUCT_NAME_EXISTS]:
    'Ya existe un producto con ese nombre. Por favor, elige otro nombre.',

  // Errores de red y servidor
  [ERROR_CODES.NETWORK_ERROR]:
    'Error de red. Verifica tu conexi√≥n e int√©ntalo de nuevo.',
  [ERROR_CODES.API_CLIENT_ERROR]: 'Error al comunicar con el servidor.',
  [ERROR_CODES.INTERNAL_SERVER_ERROR]:
    'Ocurri√≥ un error en el servidor. Int√©ntalo de nuevo m√°s tarde.',
  [ERROR_CODES.UNKNOWN_API_ERROR]:
    'Ocurri√≥ un error inesperado al procesar tu solicitud.',
  [ERROR_CODES.UNKNOWN_ERROR]: 'Ocurri√≥ un error desconocido.',

  // Mensajes por c√≥digo de estado HTTP
  [`status_400`]: 'La solicitud contiene datos inv√°lidos.',
  [`status_401`]: 'No autorizado. Por favor, inicia sesi√≥n de nuevo.',
  [`status_403`]: 'No tienes permiso para realizar esta acci√≥n.',
  [`status_404`]: 'El recurso solicitado no se encontr√≥.',
  [`status_409`]: 'Existe un conflicto con el estado actual del recurso.',
  [`status_422`]: 'Los datos enviados son inv√°lidos o incompletos.',
  [`status_500`]: 'Error interno del servidor. Por favor, intenta m√°s tarde.',
  [`status_502`]: 'Error de conexi√≥n con el servidor.',
  [`status_503`]: 'El servicio no est√° disponible temporalmente.',

  // C√≥digos espec√≠ficos del backend - Autenticaci√≥n
  AUTH_USER_NOT_FOUND: 'Usuario no encontrado.',
  AUTH_EMAIL_NOT_CONFIRMED:
    'Por favor, confirma tu correo electr√≥nico antes de iniciar sesi√≥n.',
  AUTH_ACCOUNT_LOCKED:
    'Tu cuenta ha sido bloqueada. Contacta al administrador.',
  AUTH_SESSION_EXPIRED:
    'Tu sesi√≥n ha expirado. Por favor, inicia sesi√≥n nuevamente.',

  // C√≥digos espec√≠ficos del backend - Validaci√≥n
  VALIDATION_FAILED: 'Error de validaci√≥n. Revisa los datos ingresados.',
  DUPLICATE_ENTRY: 'Ya existe un registro con estos datos.',
  INVALID_INPUT: 'Los datos ingresados no son v√°lidos.',
  MISSING_REQUIRED_FIELD: 'Faltan campos obligatorios.',

  // C√≥digos espec√≠ficos del backend - Permisos
  INSUFFICIENT_PERMISSIONS:
    'No tienes permisos suficientes para realizar esta acci√≥n.',
  RATE_LIMIT_EXCEEDED:
    'Has realizado demasiadas solicitudes. Intenta m√°s tarde.',

  // C√≥digos espec√≠ficos del backend - √ìrdenes
  ORDER_NOT_FOUND: 'La orden no fue encontrada.',
  ORDER_ALREADY_COMPLETED: 'Esta orden ya fue completada.',
  ORDER_CANNOT_BE_MODIFIED:
    'Esta orden no puede ser modificada en su estado actual.',
  TABLE_ALREADY_OCCUPIED: 'La mesa seleccionada ya est√° ocupada.',
  INVALID_ORDER_TYPE: 'Tipo de orden inv√°lido.',
  NO_ITEMS_IN_ORDER: 'La orden debe contener al menos un producto.',

  // C√≥digos espec√≠ficos del backend - Productos
  PRODUCT_NOT_FOUND: 'El producto no fue encontrado.',
  PRODUCT_NOT_AVAILABLE: 'El producto no est√° disponible en este momento.',
  PRODUCT_OUT_OF_STOCK: 'El producto est√° agotado.',
  INVALID_PRODUCT_VARIANT: 'La variante del producto no es v√°lida.',
  INVALID_MODIFIER: 'El modificador seleccionado no es v√°lido.',

  // C√≥digos espec√≠ficos del backend - Mesas y √Åreas
  TABLE_NOT_FOUND: 'La mesa no fue encontrada.',
  AREA_NOT_FOUND: 'El √°rea no fue encontrada.',
  TABLE_IN_USE: 'La mesa est√° siendo utilizada en otra orden.',

  // C√≥digos espec√≠ficos del backend - Impresoras
  PRINTER_NOT_FOUND: 'La impresora no fue encontrada.',
  PRINTER_OFFLINE: 'La impresora no est√° disponible.',
  PRINT_FAILED: 'Error al imprimir. Verifica la conexi√≥n de la impresora.',
  THERMAL_PRINTER_DUPLICATE_FIELD: 'Ya existe una impresora con ese nombre.',

  // C√≥digos espec√≠ficos del backend - Categor√≠as
  CATEGORY_NOT_FOUND: 'La categor√≠a no fue encontrada.',
  SUBCATEGORY_NOT_FOUND: 'La subcategor√≠a no fue encontrada.',
  CATEGORY_HAS_PRODUCTS:
    'No se puede eliminar la categor√≠a porque tiene productos asociados.',

  // Errores de archivos
  [ERROR_CODES.UPLOAD_FAILED]:
    'Error al subir el archivo. Por favor, intenta nuevamente.',
  [ERROR_CODES.FILE_TOO_LARGE]:
    'El archivo es demasiado grande. El tama√±o m√°ximo permitido es 10MB.',
  cantUploadFileType:
    'El tipo de archivo no est√° permitido. Solo se permiten im√°genes (JPG, JPEG, PNG, GIF).',
};

export function getApiErrorMessage(error: unknown): string {
  const defaultMessage = 'Ocurri√≥ un error inesperado.';

  if (error instanceof ApiError) {
    // Si tenemos un mensaje espec√≠fico del backend y no es un mensaje gen√©rico,
    // usarlo siempre, independientemente del c√≥digo
    if (
      error.originalMessage &&
      error.originalMessage !== 'Error desconocido de la API.' &&
      error.originalMessage !== 'Not Found' &&
      error.originalMessage !== 'Internal Server Error' &&
      error.originalMessage !==
        'Ocurri√≥ un error inesperado al procesar tu solicitud.' &&
      !error.originalMessage.includes('<!DOCTYPE') // Evitar HTML de errores
    ) {
      return error.originalMessage;
    }

    // Si no, intentamos con el c√≥digo espec√≠fico
    let message = errorCodeMessages[error.code];

    // Si no hay mensaje para el c√≥digo, intentamos con el c√≥digo de estado
    if (!message) {
      message = errorCodeMessages[`status_${error.status}`];
    }

    // Si encontramos un mensaje gen√©rico pero tenemos detalles espec√≠ficos, usar los detalles
    if (message === errorCodeMessages[`status_409`] && error.details?.message) {
      return error.details.message;
    }

    return message || defaultMessage;
  } else if (error instanceof AxiosError) {
    if (error.message === 'Network Error' || !error.response) {
      return errorCodeMessages[ERROR_CODES.NETWORK_ERROR] || 'Error de red.';
    }
    if (error.response?.status) {
      const statusMessage =
        errorCodeMessages[`status_${error.response.status}`];
      if (statusMessage) return statusMessage;
    }
    return errorCodeMessages[ERROR_CODES.UNKNOWN_API_ERROR] || defaultMessage;
  } else if (error instanceof Error) {
    if (
      error.message.toLowerCase().includes('network request failed') ||
      error.message.toLowerCase().includes('failed to fetch')
    ) {
      return errorCodeMessages[ERROR_CODES.NETWORK_ERROR] || 'Error de red.';
    }
    return error.message && !error.message.toLowerCase().includes('undefined')
      ? error.message
      : defaultMessage;
  } else {
    return defaultMessage;
  }
}

================
File: app/src/app/lib/formatters.ts
================
/**
 * Formatea un n√∫mero como moneda
 * @param amount - Cantidad a formatear
 * @param currency - C√≥digo de moneda (por defecto MXN)
 * @returns String formateado como moneda
 */
export function formatCurrency(
  amount: number | null | undefined,
  currency = 'MXN',
): string {
  // Si el valor es null, undefined o NaN, devolver $0.00
  if (amount === null || amount === undefined || isNaN(amount)) {
    return new Intl.NumberFormat('es-MX', {
      style: 'currency',
      currency,
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
    }).format(0);
  }

  return new Intl.NumberFormat('es-MX', {
    style: 'currency',
    currency,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  }).format(amount);
}

/**
 * Formatea un n√∫mero de tel√©fono
 * @param phoneNumber - N√∫mero de tel√©fono
 * @returns String formateado
 */
export function formatPhoneNumber(phoneNumber: string): string {
  // Remover todo excepto n√∫meros
  const cleaned = phoneNumber.replace(/\D/g, '');

  // Formato mexicano: +52 55 1234 5678
  if (cleaned.length === 10) {
    return `${cleaned.slice(0, 2)} ${cleaned.slice(2, 6)} ${cleaned.slice(6)}`;
  } else if (cleaned.length === 12 && cleaned.startsWith('52')) {
    return `+${cleaned.slice(0, 2)} ${cleaned.slice(2, 4)} ${cleaned.slice(4, 8)} ${cleaned.slice(8)}`;
  }

  return phoneNumber;
}

================
File: app/src/app/lib/imageUtils.ts
================
import { serverConnectionService } from '@/services/serverConnectionService';

/**
 * Construye la URL completa de una imagen a partir de su ruta relativa o absoluta.
 * Si la ruta ya es una URL completa (http/https) o URI local (file://), la devuelve tal cual.
 * Si es una ruta relativa, la prefija con la URL del API obtenida din√°micamente.
 * @param imagePath - La ruta relativa (ej. 'uploads/imagen.jpg') o URL completa de la imagen.
 * @returns Promise con la URL completa y lista para usar, o null si la entrada es inv√°lida.
 */
export const getImageUrl = async (
  imagePath: string | null | undefined,
): Promise<string | null> => {
  if (!imagePath || typeof imagePath !== 'string') {
    return null;
  }

  try {
    // Obtener la URL del servicio de conexi√≥n sin provocar discovery
    const connectionState = serverConnectionService.getState();
    if (!connectionState.serverUrl || !connectionState.isConnected) {
      return null;
    }

    const apiUrl = connectionState.serverUrl;
    const normalizedApiUrl = apiUrl.endsWith('/')
      ? apiUrl.slice(0, -1)
      : apiUrl;
    const normalizedPath = imagePath.replace(/\\/g, '/');

    if (normalizedPath.startsWith('http')) {
      const urlObj = new URL(normalizedPath);
      const pathPart = urlObj.pathname;

      return `${normalizedApiUrl}${pathPart}`;
    }
    const formattedPath = normalizedPath.startsWith('/')
      ? normalizedPath
      : `/${normalizedPath}`;

    return `${normalizedApiUrl}${formattedPath}`;
  } catch (error) {
    return null;
  }
};

/**
 * Versi√≥n s√≠ncrona que usa una URL base proporcionada.
 * √ötil cuando ya tienes la URL del API disponible.
 * @param imagePath - La ruta relativa o URL completa de la imagen.
 * @param apiUrl - La URL base del API.
 * @returns La URL completa y lista para usar, o null si la entrada es inv√°lida.
 */
export const getImageUrlSync = (
  imagePath: string | null | undefined,
  apiUrl: string,
): string | null => {
  if (!imagePath || typeof imagePath !== 'string') {
    return null;
  }

  const normalizedApiUrl = apiUrl.endsWith('/') ? apiUrl.slice(0, -1) : apiUrl;
  const normalizedPath = imagePath.replace(/\\/g, '/');

  if (normalizedPath.startsWith('http')) {
    const urlObj = new URL(normalizedPath);
    const pathPart = urlObj.pathname;

    return `${normalizedApiUrl}${pathPart}`;
  }
  const formattedPath = normalizedPath.startsWith('/')
    ? normalizedPath
    : `/${normalizedPath}`;

  return `${normalizedApiUrl}${formattedPath}`;
};

/**
 * Limpia el cache de la URL del API.
 * √ötil cuando se necesita forzar una nueva b√∫squeda del servidor.
 */
export const clearApiUrlCache = () => {
  cachedApiUrl = null;
  cacheTimestamp = 0;
};

================
File: app/src/app/lib/zodResolver.ts
================
import type { FieldErrors, FieldValues, ResolverResult } from 'react-hook-form';
import type { ZodSchema, ZodError } from 'zod';

export function zodResolver<T extends FieldValues>(schema: ZodSchema<T>) {
  return async (data: T): Promise<ResolverResult<T>> => {
    try {
      const validatedData = await schema.parseAsync(data);
      return {
        values: validatedData,
        errors: {},
      };
    } catch (error) {
      if (error instanceof Error && 'errors' in error) {
        const zodError = error as ZodError;
        const fieldErrors: FieldErrors<T> = {};

        zodError.errors.forEach((err) => {
          const path = err.path.join('.');
          if (path) {
            fieldErrors[path as keyof T] = {
              type: err.code,
              message: err.message,
            };
          }
        });

        return {
          values: {} as T,
          errors: fieldErrors,
        };
      }
      throw error;
    }
  };
}

================
File: app/src/app/navigation/components/WebDrawer.tsx
================
import React, { useEffect } from 'react';
import {
  View,
  StyleSheet,
  Pressable,
  Animated,
  Platform,
  ScrollView,
} from 'react-native';
import { Portal } from 'react-native-paper';
import { useAppTheme } from '../../styles/theme';

interface WebDrawerProps {
  open: boolean;
  onClose: () => void;
  children: React.ReactNode;
  drawerContent: React.ReactNode;
  drawerWidth?: number;
}

export function WebDrawer({
  open,
  onClose,
  children,
  drawerContent,
  drawerWidth = 320,
}: WebDrawerProps) {
  const theme = useAppTheme();
  const slideAnim = React.useRef(new Animated.Value(-drawerWidth)).current;
  const fadeAnim = React.useRef(new Animated.Value(0)).current;

  useEffect(() => {
    if (open) {
      // Abrir drawer
      Animated.parallel([
        Animated.timing(slideAnim, {
          toValue: 0,
          duration: 250,
          useNativeDriver: true,
        }),
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 250,
          useNativeDriver: true,
        }),
      ]).start();
    } else {
      // Cerrar drawer
      Animated.parallel([
        Animated.timing(slideAnim, {
          toValue: -drawerWidth,
          duration: 200,
          useNativeDriver: true,
        }),
        Animated.timing(fadeAnim, {
          toValue: 0,
          duration: 200,
          useNativeDriver: true,
        }),
      ]).start();
    }
  }, [open, slideAnim, fadeAnim, drawerWidth]);

  // Manejar ESC para cerrar
  useEffect(() => {
    if (Platform.OS === 'web' && open) {
      const handleKeyDown = (e: KeyboardEvent) => {
        if (e.key === 'Escape') {
          onClose();
        }
      };
      window.addEventListener('keydown', handleKeyDown);
      return () => window.removeEventListener('keydown', handleKeyDown);
    }
  }, [open, onClose]);

  const styles = StyleSheet.create({
    container: {
      flex: 1,
    },
    overlay: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: 'rgba(0, 0, 0, 0.5)',
      zIndex: 998,
    },
    drawer: {
      position: 'absolute',
      top: 0,
      left: 0,
      bottom: 0,
      width: drawerWidth,
      backgroundColor: theme.colors.surface,
      elevation: 16,
      shadowColor: '#000',
      shadowOffset: { width: 2, height: 0 },
      shadowOpacity: 0.25,
      shadowRadius: 10,
      zIndex: 999,
      borderRightWidth: 1,
      borderRightColor: theme.colors.outlineVariant,
    },
  });

  // Solo mostrar el drawer personalizado en web
  if (Platform.OS !== 'web') {
    return <>{children}</>;
  }

  return (
    <View style={styles.container}>
      {children}
      {open && (
        <Portal>
          <Animated.View
            style={[
              styles.overlay,
              {
                opacity: fadeAnim,
              },
            ]}
          >
            <Pressable style={StyleSheet.absoluteFill} onPress={onClose} />
          </Animated.View>
          <Animated.View
            style={[
              styles.drawer,
              {
                transform: [{ translateX: slideAnim }],
              },
            ]}
          >
            <ScrollView
              contentContainerStyle={{ flexGrow: 1 }}
              showsVerticalScrollIndicator={false}
            >
              {drawerContent}
            </ScrollView>
          </Animated.View>
        </Portal>
      )}
    </View>
  );
}

================
File: app/src/app/navigation/components/WebDrawerContent.tsx
================
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { ScrollView } from 'react-native';
import {
  Drawer as PaperDrawer,
  Text,
  Divider,
  Switch,
  TouchableRipple,
  Icon,
  Surface,
  Portal,
  Dialog,
  Button,
} from 'react-native-paper';
import { useThemeStore } from '../../store/themeStore';
import { THEME_MODE } from '../../types/theme.types';
import { useAuthStore } from '../../store/authStore';
import { useAppTheme, AppTheme } from '../../styles/theme';
import { useResponsive } from '../../hooks/useResponsive';
import { clearImageCache } from '../../lib/imageCache';
import { useSnackbarStore } from '../../store/snackbarStore';
import { RoleEnum } from '@/modules/users/types/user.types';

interface WebDrawerContentProps {
  onClose: () => void;
}

// Traducciones de roles
const ROLE_TRANSLATIONS: Record<number, string> = {
  [RoleEnum.ADMIN]: 'Administrador',
  [RoleEnum.MANAGER]: 'Gerente',
  [RoleEnum.CASHIER]: 'Cajero',
  [RoleEnum.WAITER]: 'Mesero',
  [RoleEnum.KITCHEN]: 'Cocina',
  [RoleEnum.DELIVERY]: 'Repartidor',
};

const getRoleTranslation = (roleId?: number): string => {
  if (!roleId) return 'Desconocido';
  return ROLE_TRANSLATIONS[roleId] || 'Desconocido';
};

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.surface,
    },
    userInfoSection: {
      padding: responsive.spacing(theme.spacing.m),
    },
    title: {
      ...theme.fonts.titleMedium,
      fontSize: responsive.fontSize(theme.fonts.titleMedium.fontSize),
      color: theme.colors.onSurface,
      marginBottom: responsive.spacing(4),
    },
    caption: {
      ...theme.fonts.bodySmall,
      fontSize: responsive.fontSize(theme.fonts.bodySmall.fontSize),
      color: theme.colors.onSurfaceVariant,
      marginBottom: responsive.spacing(2),
    },
    drawerSection: {
      marginTop: responsive.spacing(theme.spacing.s),
    },
    bottomDrawerSection: {
      marginBottom: responsive.spacing(theme.spacing.m),
      marginTop: 'auto',
      borderTopColor: theme.colors.outlineVariant,
      borderTopWidth: StyleSheet.hairlineWidth,
      paddingTop: responsive.spacing(theme.spacing.s),
    },
    preference: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      paddingVertical: responsive.spacing(theme.spacing.s),
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      alignItems: 'center',
      marginHorizontal: responsive.spacing(theme.spacing.xs),
      borderRadius: theme.roundness * 2,
    },
    drawerItemLabel: {
      ...theme.fonts.labelLarge,
      fontSize: responsive.fontSize(theme.fonts.labelLarge.fontSize),
    },
    drawerItemContainer: {
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingVertical: responsive.spacing(theme.spacing.m),
      flexDirection: 'row',
      alignItems: 'center',
      borderRadius: theme.roundness * 2,
      marginHorizontal: responsive.spacing(theme.spacing.xs),
      marginVertical: responsive.spacing(theme.spacing.xxs),
    },
    drawerItemIconContainer: {
      marginRight: responsive.spacing(theme.spacing.l),
      width: responsive.isTablet ? 20 : theme.spacing.l,
      alignItems: 'center',
    },
    divider: {
      marginVertical: responsive.spacing(theme.spacing.s),
      marginHorizontal: responsive.spacing(theme.spacing.m),
    },
    configSubheader: {
      ...theme.fonts.labelLarge,
      fontSize: responsive.fontSize(theme.fonts.labelLarge.fontSize),
      color: theme.colors.onSurfaceVariant,
      paddingLeft: responsive.spacing(theme.spacing.l),
      paddingRight: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.s),
      paddingBottom: responsive.spacing(theme.spacing.xxs),
    },
  });

export function WebDrawerContent({ onClose }: WebDrawerContentProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const logout = useAuthStore((state) => state.logout);
  const setThemePreference = useThemeStore((state) => state.setThemePreference);
  const user = useAuthStore((state) => state.user);
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const [showServerSettings, setShowServerSettings] = React.useState(false);

  // Efecto para cerrar con ESC
  React.useEffect(() => {
    const handleKeyPress = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        onClose();
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [onClose]);

  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );

  const handleClearCache = async () => {
    try {
      await clearImageCache();
      showSnackbar({
        message: 'Cach√© de im√°genes limpiado exitosamente',
        type: 'success',
      });
    } catch (error) {
      showSnackbar({
        message: 'Error al limpiar el cach√©',
        type: 'error',
      });
    }
  };

  return (
    <Surface style={styles.container} elevation={0}>
      <ScrollView
        contentContainerStyle={{ paddingTop: 0 }}
        showsVerticalScrollIndicator={false}
      >
        <View style={{ flex: 1 }}>
          <Surface style={styles.userInfoSection} elevation={0}>
            {user ? (
              <>
                <Text style={styles.title} numberOfLines={1}>
                  {`${user.firstName ?? ''} ${user.lastName ?? ''}`.trim() ||
                    user.username ||
                    'Usuario'}
                </Text>
                <Text style={styles.caption} numberOfLines={1}>
                  Rol: {getRoleTranslation(user.role?.id)}
                </Text>
                <Text style={styles.caption} numberOfLines={1}>
                  {user.email ?? ''}
                </Text>
                <Text style={styles.caption} numberOfLines={1}>
                  @{user.username ?? 'username'}
                </Text>
              </>
            ) : (
              <Text style={styles.title}>Invitado</Text>
            )}
          </Surface>
          <Divider style={styles.divider} />

          {/* Secci√≥n de Cocina */}
          {user?.role?.id === 5 && (
            <PaperDrawer.Section style={styles.drawerSection}>
              <Text style={styles.configSubheader}>Cocina</Text>
              <TouchableRipple
                onPress={() => {
                  // No need to navigate for kitchen users
                  onClose();
                }}
                style={styles.drawerItemContainer}
                rippleColor={`${theme.colors.primary}20`}
              >
                <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                  <View style={styles.drawerItemIconContainer}>
                    <Icon
                      source="chef-hat"
                      size={responsive.isTablet ? 20 : 24}
                      color={theme.colors.primary}
                    />
                  </View>
                  <Text
                    style={[
                      styles.drawerItemLabel,
                      { color: theme.colors.primary },
                    ]}
                  >
                    Pantalla de Preparaci√≥n
                  </Text>
                </View>
              </TouchableRipple>
            </PaperDrawer.Section>
          )}
        </View>
      </ScrollView>

      <PaperDrawer.Section style={styles.bottomDrawerSection}>
        <TouchableRipple
          onPress={() => {
            const newPreference = theme.dark
              ? THEME_MODE.LIGHT
              : THEME_MODE.DARK;
            setThemePreference(newPreference);
          }}
          style={styles.preference}
        >
          <View
            style={{
              flexDirection: 'row',
              alignItems: 'center',
              justifyContent: 'space-between',
              width: '100%',
            }}
          >
            <View style={{ flexDirection: 'row', alignItems: 'center' }}>
              <View style={styles.drawerItemIconContainer}>
                <Icon
                  source={theme.dark ? 'weather-night' : 'white-balance-sunny'}
                  size={responsive.isTablet ? 20 : 24}
                  color={theme.colors.onSurfaceVariant}
                />
              </View>
              <Text
                style={[
                  styles.drawerItemLabel,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                Modo Oscuro
              </Text>
            </View>
            <View style={{ pointerEvents: 'none' }}>
              <Switch value={theme.dark} color={theme.colors.primary} />
            </View>
          </View>
        </TouchableRipple>

        <TouchableRipple
          onPress={handleClearCache}
          style={styles.drawerItemContainer}
          rippleColor={`${theme.colors.primary}20`}
        >
          <View style={{ flexDirection: 'row', alignItems: 'center' }}>
            <View style={styles.drawerItemIconContainer}>
              <Icon
                source="broom"
                size={responsive.isTablet ? 20 : 24}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <Text
              style={[
                styles.drawerItemLabel,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Limpiar Cach√©
            </Text>
          </View>
        </TouchableRipple>

        <TouchableRipple
          onPress={() => {
            setShowServerSettings(true);
            onClose();
          }}
          style={styles.drawerItemContainer}
          rippleColor={`${theme.colors.primary}20`}
        >
          <View style={{ flexDirection: 'row', alignItems: 'center' }}>
            <View style={styles.drawerItemIconContainer}>
              <Icon
                source="server-network"
                size={responsive.isTablet ? 20 : 24}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <Text
              style={[
                styles.drawerItemLabel,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Configuraci√≥n del Servidor
            </Text>
          </View>
        </TouchableRipple>

        <TouchableRipple
          onPress={() => {
            logout();
          }}
          style={styles.drawerItemContainer}
          rippleColor={`${theme.colors.error}20`}
        >
          <View style={{ flexDirection: 'row', alignItems: 'center' }}>
            <View style={styles.drawerItemIconContainer}>
              <Icon
                source="logout"
                size={responsive.isTablet ? 20 : 24}
                color={theme.colors.error}
              />
            </View>
            <Text
              style={[styles.drawerItemLabel, { color: theme.colors.error }]}
            >
              Cerrar Sesi√≥n
            </Text>
          </View>
        </TouchableRipple>
      </PaperDrawer.Section>

      {/* Modal de configuraci√≥n del servidor */}
      {showServerSettings && (
        <Portal>
          <Dialog
            visible={showServerSettings}
            onDismiss={() => setShowServerSettings(false)}
            style={{ maxWidth: 600, alignSelf: 'center' }}
          >
            <Dialog.Title>Configuraci√≥n del Servidor</Dialog.Title>
            <Dialog.ScrollArea style={{ maxHeight: 400 }}>
              <Text style={{ marginBottom: 16 }}>
                Para configurar el servidor en la versi√≥n web, utiliza la
                aplicaci√≥n m√≥vil.
              </Text>
              <Text style={{ marginBottom: 8 }}>
                La configuraci√≥n del servidor incluye:
              </Text>
              <Text style={{ marginLeft: 16 }}>
                ‚Ä¢ Modo de conexi√≥n (Auto/Manual)
              </Text>
              <Text style={{ marginLeft: 16 }}>‚Ä¢ URL del servidor</Text>
              <Text style={{ marginLeft: 16 }}>‚Ä¢ Prueba de conexi√≥n</Text>
            </Dialog.ScrollArea>
            <Dialog.Actions>
              <Button onPress={() => setShowServerSettings(false)}>
                Cerrar
              </Button>
            </Dialog.Actions>
          </Dialog>
        </Portal>
      )}
    </Surface>
  );
}

================
File: app/src/app/navigation/KitchenWebNavigator.tsx
================
import React, { useState } from 'react';
import {
  View,
  StyleSheet,
  TouchableOpacity,
  StatusBar,
  Text,
} from 'react-native';
import { Icon, Surface, Checkbox } from 'react-native-paper';
import { WebDrawer } from './components/WebDrawer';
import { WebDrawerContent } from './components/WebDrawerContent';
import KitchenNavigator from '../../modules/kitchen/navigation/KitchenNavigator';
import { useAppTheme } from '../styles/theme';
import { useResponsive } from '../hooks/useResponsive';
import { ConnectionIndicator } from '../components/ConnectionIndicator';
import { KitchenFilterButton } from '../../modules/kitchen/components/KitchenFilterButton';
import { RefreshButton } from '../../modules/kitchen/components/RefreshButton';
import { useAuthStore } from '../store/authStore';
import { useKitchenStore } from '../../modules/kitchen/store/kitchenStore';
import { OrderType } from '../../modules/kitchen/types/kitchen.types';
import { KitchenProvider } from '../../modules/kitchen/context/KitchenContext';

export function KitchenWebNavigator() {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const user = useAuthStore((state) => state.user);
  const { filters, setFilters } = useKitchenStore();
  const screenName = user?.preparationScreen?.name || 'Pantalla de Preparaci√≥n';
  const [drawerOpen, setDrawerOpen] = useState(false);

  // Obtener el texto del filtro activo
  const getFilterText = () => {
    switch (filters.orderType) {
      case OrderType.DINE_IN:
        return ' ‚Ä¢ Mesa';
      case OrderType.TAKE_AWAY:
        return ' ‚Ä¢ Llevar';
      case OrderType.DELIVERY:
        return ' ‚Ä¢ Domicilio';
      default:
        return '';
    }
  };

  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    header: {
      backgroundColor: theme.colors.primary,
      height: responsive.isWeb ? 80 : responsive.dimensions.headerHeight,
      flexDirection: 'row',
      alignItems: 'center',
      paddingHorizontal: responsive.spacing.m,
      elevation: 2,
    },
    drawerButtonContainer: {
      width: 56,
      height: 56,
      justifyContent: 'center',
      alignItems: 'center',
      marginLeft: 0,
      borderRadius: 28,
    },
    headerContent: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
    },
    titleContainer: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    headerTitle: {
      ...theme.fonts.titleLarge,
      color: theme.colors.onPrimary,
      fontWeight: 'bold',
      fontSize: responsive.isWeb ? 26 : 22,
    },
    filterIndicator: {
      ...theme.fonts.titleMedium,
      fontWeight: '500',
      opacity: 0.9,
      color: theme.colors.onPrimary,
    },
    content: {
      flex: 1,
    },
  });

  return (
    <KitchenProvider>
      <View style={styles.container}>
        <StatusBar
          backgroundColor={theme.colors.primary}
          barStyle={theme.dark ? 'light-content' : 'dark-content'}
        />

        <WebDrawer
          open={drawerOpen}
          onClose={() => setDrawerOpen(false)}
          drawerWidth={
            responsive.isWeb ? 320 : responsive.dimensions.drawerWidth
          }
          drawerContent={
            <WebDrawerContent onClose={() => setDrawerOpen(false)} />
          }
        >
          <View style={styles.container}>
            {/* Header */}
            <View style={styles.header}>
              <TouchableOpacity
                style={styles.drawerButtonContainer}
                onPress={() => setDrawerOpen(true)}
                hitSlop={{ top: 30, bottom: 30, left: 30, right: 30 }}
              >
                <Icon
                  source="menu"
                  size={responsive.isWeb ? 36 : 32}
                  color={theme.colors.onPrimary}
                />
              </TouchableOpacity>

              <View style={styles.headerContent}>
                <Surface
                  elevation={0}
                  style={{
                    backgroundColor: 'transparent',
                  }}
                >
                  <View style={styles.titleContainer}>
                    <Text style={styles.headerTitle}>{screenName}</Text>
                    {filters.orderType && (
                      <Text style={styles.filterIndicator}>
                        {getFilterText()}
                      </Text>
                    )}
                  </View>
                </Surface>

                <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                  {/* Checkbox para mostrar/ocultar ordenes listas */}
                  <TouchableOpacity
                    style={{
                      flexDirection: 'row',
                      alignItems: 'center',
                      paddingHorizontal: 12,
                      paddingVertical: 8,
                      marginRight: 8,
                      backgroundColor: filters.showPrepared
                        ? 'rgba(255,255,255,0.2)'
                        : 'transparent',
                      borderRadius: 20,
                    }}
                    onPress={() =>
                      setFilters({
                        ...filters,
                        showPrepared: !filters.showPrepared,
                      })
                    }
                  >
                    <Checkbox
                      status={filters.showPrepared ? 'checked' : 'unchecked'}
                      onPress={() =>
                        setFilters({
                          ...filters,
                          showPrepared: !filters.showPrepared,
                        })
                      }
                      color={theme.colors.onPrimary}
                      uncheckedColor={theme.colors.onPrimary}
                    />
                    <Text
                      style={{
                        color: theme.colors.onPrimary,
                        fontSize: responsive.isWeb ? 16 : 14,
                        marginLeft: 4,
                        fontWeight: filters.showPrepared ? 'bold' : 'normal',
                      }}
                    >
                      Mostrar Listas
                    </Text>
                  </TouchableOpacity>
                  <KitchenFilterButton />
                  <RefreshButton />
                  <ConnectionIndicator />
                </View>
              </View>
            </View>

            {/* Content */}
            <View style={styles.content}>
              <KitchenNavigator />
            </View>
          </View>
        </WebDrawer>
      </View>
    </KitchenProvider>
  );
}

================
File: app/src/app/schemas/domain/table.schema.ts
================
import { z } from 'zod';

/**
 * Esquema Zod para validar un objeto Table completo.
 * Fuente de verdad centralizada.
 */
export const tableSchema = z.object({
  id: z.string().uuid(),
  name: z.string(),
  areaId: z.string().uuid(),
  capacity: z.number().int().nullable().optional(),
  isActive: z.boolean(),
  isAvailable: z.boolean(), // Incluido desde el schema original
  isTemporary: z.boolean(), // Incluido desde el schema original
  temporaryIdentifier: z.string().nullable().optional(), // Incluido desde el schema original
  area: z
    .object({
      id: z.string().uuid(),
      name: z.string(),
    })
    .optional(), // El √°rea puede venir incluida opcionalmente
  createdAt: z.union([z.string().datetime(), z.date()]).optional(), // Permitir string o Date
  updatedAt: z.union([z.string().datetime(), z.date()]).optional(), // Permitir string o Date
});

// Tipo TypeScript inferido y exportado centralmente
export type Table = z.infer<typeof tableSchema>;

================
File: app/src/app/services/apiClientWrapper.ts
================
import {
  getApiClient,
  reinitializeApiClient,
  getAxiosInstance,
} from './apiClient';
import { ApiResponse } from 'apisauce';
import { AxiosResponse } from 'axios';

/**
 * Wrapper que maneja la inicializaci√≥n as√≠ncrona del cliente API
 * Todos los servicios deben usar este wrapper en lugar de importar apiClient directamente
 */
export class ApiClientWrapper {
  private static async request<T>(
    method: 'get' | 'post' | 'put' | 'patch' | 'delete',
    url: string,
    dataOrParams?: any,
    config?: any,
  ): Promise<ApiResponse<T>> {
    try {
      const axios = await getAxiosInstance();

      const requestConfig =
        method === 'get' || method === 'delete'
          ? { params: dataOrParams, ...config }
          : config;

      const response: AxiosResponse<T> = await axios[method](
        url,
        method === 'get' || method === 'delete' ? requestConfig : dataOrParams,
        method === 'get' || method === 'delete' ? undefined : requestConfig,
      );

      return {
        ok: true,
        problem: null,
        data: response.data,
        status: response.status,
        headers: response.headers,
        config: response.config,
        duration: 0,
      } as ApiResponse<T>;
    } catch (error: any) {
      return {
        ok: false,
        problem:
          error.response?.status === 401 ? 'CLIENT_ERROR' : 'NETWORK_ERROR',
        data: error.response?.data,
        status: error.response?.status,
        headers: error.response?.headers,
        config: error.config,
        duration: 0,
      } as ApiResponse<T>;
    }
  }

  static async get<T>(url: string, params?: any): Promise<ApiResponse<T>> {
    return this.request<T>('get', url, params);
  }

  static async post<T>(
    url: string,
    data?: any,
    config?: any,
  ): Promise<ApiResponse<T>> {
    return this.request<T>('post', url, data, config);
  }

  static async put<T>(
    url: string,
    data?: any,
    config?: any,
  ): Promise<ApiResponse<T>> {
    return this.request<T>('put', url, data, config);
  }

  static async patch<T>(
    url: string,
    data?: any,
    config?: any,
  ): Promise<ApiResponse<T>> {
    return this.request<T>('patch', url, data, config);
  }

  static async delete<T>(
    url: string,
    params?: any,
    config?: any,
  ): Promise<ApiResponse<T>> {
    return this.request<T>('delete', url, params, config);
  }

  static async reinitialize(): Promise<void> {
    await reinitializeApiClient();
  }
}

// Exportar tambi√©n como default para compatibilidad
export default ApiClientWrapper;

================
File: app/src/app/services/certificateValidator.ts
================
import { Platform } from 'react-native';

/**
 * Servicio para validaci√≥n de certificados SSL
 * En producci√≥n, valida que las conexiones HTTPS usen certificados v√°lidos
 */
export class CertificateValidator {
  private static instance: CertificateValidator;
  private isProduction: boolean;

  private constructor() {
    // Determinar si estamos en producci√≥n bas√°ndonos en __DEV__
    this.isProduction = !__DEV__;
  }

  static getInstance(): CertificateValidator {
    if (!CertificateValidator.instance) {
      CertificateValidator.instance = new CertificateValidator();
    }
    return CertificateValidator.instance;
  }

  /**
   * Valida si una URL es segura para conectarse
   * @param url URL a validar
   * @returns true si la URL es segura o estamos en desarrollo
   */
  isSecureUrl(url: string): boolean {
    // En desarrollo, permitir cualquier URL
    if (!this.isProduction) {
      return true;
    }

    try {
      const urlObj = new URL(url);

      // En producci√≥n, solo permitir HTTPS para dominios externos
      if (this.isExternalDomain(urlObj.hostname)) {
        return urlObj.protocol === 'https:';
      }

      // Para IPs locales, permitir HTTP (necesario para discovery)
      return this.isLocalNetwork(urlObj.hostname);
    } catch {
      return false;
    }
  }

  /**
   * Determina si un hostname es una red local
   */
  private isLocalNetwork(hostname: string): boolean {
    // Localhost
    if (hostname === 'localhost' || hostname === '127.0.0.1') {
      return true;
    }

    // Redes privadas IPv4 (RFC 1918)
    const parts = hostname.split('.');
    if (parts.length === 4) {
      const firstOctet = parseInt(parts[0]);
      const secondOctet = parseInt(parts[1]);

      // 10.0.0.0/8
      if (firstOctet === 10) return true;

      // 172.16.0.0/12
      if (firstOctet === 172 && secondOctet >= 16 && secondOctet <= 31)
        return true;

      // 192.168.0.0/16
      if (firstOctet === 192 && secondOctet === 168) return true;
    }

    return false;
  }

  /**
   * Determina si un hostname es un dominio externo
   */
  private isExternalDomain(hostname: string): boolean {
    // Si no es IP local y no es localhost, es externo
    return (
      !this.isLocalNetwork(hostname) &&
      !hostname.includes('.local') &&
      !hostname.includes('.internal')
    );
  }

  /**
   * Obtiene configuraci√≥n de seguridad para axios
   */
  getAxiosSecurityConfig() {
    if (Platform.OS === 'android' && this.isProduction) {
      return {
        // En producci√≥n, validar certificados
        httpsAgent: {
          rejectUnauthorized: true,
        },
      };
    }

    return {};
  }

  /**
   * Valida si se debe permitir una conexi√≥n
   * @throws Error si la conexi√≥n no es segura en producci√≥n
   */
  validateConnection(url: string): void {
    if (!this.isSecureUrl(url)) {
      throw new Error(
        `Conexi√≥n insegura bloqueada: ${url}. ` +
          'En producci√≥n solo se permiten conexiones HTTPS a dominios externos.',
      );
    }
  }
}

export const certificateValidator = CertificateValidator.getInstance();

================
File: app/src/app/store/themeStore.ts
================
import React from 'react';
import { create } from 'zustand';
import { createJSONStorage, persist } from 'zustand/middleware';
import EncryptedStorage from '@/app/services/secureStorageService';
import { useColorScheme, Appearance } from 'react-native';

import {
  ThemePreference,
  THEME_PREFERENCE_STORAGE_KEY,
  THEME_MODE,
} from '../types/theme.types';
import { lightTheme, darkTheme } from '../styles/theme';

interface ThemeState {
  themePreference: ThemePreference;
  activeTheme: typeof lightTheme | typeof darkTheme;
  isSystemDarkMode: boolean | null;
  setThemePreference: (preference: ThemePreference) => void;
  setSystemDarkMode: (isDark: boolean | null) => void;
}

export const useThemeStore = create<ThemeState>()(
  persist(
    (set, get) => ({
      themePreference: THEME_MODE.SYSTEM,
      activeTheme: lightTheme,
      isSystemDarkMode: null,

      setThemePreference: (preference: ThemePreference) => {
        const { isSystemDarkMode } = get();
        set({ themePreference: preference });

        if (preference === THEME_MODE.SYSTEM) {
          if (isSystemDarkMode !== null) {
            set({ activeTheme: isSystemDarkMode ? darkTheme : lightTheme });
          }
        } else {
          set({
            activeTheme:
              preference === THEME_MODE.DARK ? darkTheme : lightTheme,
          });
        }
      },

      setSystemDarkMode: (isDark: boolean | null) => {
        const { themePreference } = get();
        set({ isSystemDarkMode: isDark });

        if (themePreference === THEME_MODE.SYSTEM && isDark !== null) {
          set({ activeTheme: isDark ? darkTheme : lightTheme });
        }
      },
    }),

    {
      name: THEME_PREFERENCE_STORAGE_KEY,
      storage: createJSONStorage(() => EncryptedStorage),
      partialize: (state) => ({ themePreference: state.themePreference }),
      onRehydrateStorage: () => {
        return (state, error) => {
          if (error) {
            // Error rehydrating theme store
            return;
          }
          if (!state) {
            // State not available during theme rehydration callback
            return;
          }

          const preference = state.themePreference;

          if (preference === THEME_MODE.LIGHT) {
            state.activeTheme = lightTheme;
            state.isSystemDarkMode = Appearance.getColorScheme() === 'dark';
          } else if (preference === THEME_MODE.DARK) {
            state.activeTheme = darkTheme;
            state.isSystemDarkMode = Appearance.getColorScheme() === 'dark';
          } else {
            const systemScheme = Appearance.getColorScheme();
            const isSystemDark = systemScheme === 'dark';
            state.isSystemDarkMode = isSystemDark;
            state.activeTheme = isSystemDark ? darkTheme : lightTheme;
          }
        };
      },
    },
  ),
);

export function useSystemThemeDetector() {
  const systemColorScheme = useColorScheme();
  const setSystemDarkMode = useThemeStore((state) => state.setSystemDarkMode);

  React.useEffect(() => {
    const isDarkMode = systemColorScheme === 'dark';
    if (useThemeStore.getState().isSystemDarkMode !== isDarkMode) {
      setSystemDarkMode(isDarkMode);
    }
  }, [systemColorScheme, setSystemDarkMode]);
}

================
File: app/src/app/utils/orderFormatters.ts
================
import type {
  OrderStatus,
  OrderType,
  Order,
} from '@/modules/orders/types/orders.types';
import {
  OrderStatusEnum,
  OrderTypeEnum,
} from '@/modules/orders/types/orders.types';
import type { OrderOpenList } from '@/modules/orders/types/orders.types';
import type { OrderForFinalizationList } from '@/modules/orderFinalization/types/orderFinalization.types';

/**
 * Formatea el tipo de orden con emojis y texto completo
 * @param type - Tipo de orden
 * @returns String formateado con emoji y texto
 */
export const formatOrderType = (type: OrderType): string => {
  switch (type) {
    case OrderTypeEnum.DINE_IN:
      return 'üçΩÔ∏è Para Comer Aqu√≠';
    case OrderTypeEnum.TAKE_AWAY:
      return 'ü•° Para Llevar';
    case OrderTypeEnum.DELIVERY:
      return 'üöö Domicilio';
    default:
      return type;
  }
};

/**
 * Formatea el tipo de orden con versi√≥n corta
 * @param type - Tipo de orden
 * @returns String formateado con emoji y texto corto
 */
export const formatOrderTypeShort = (type: OrderType | string): string => {
  switch (type) {
    case OrderTypeEnum.DINE_IN:
    case 'DINE_IN':
      return 'üçΩÔ∏è Local';
    case OrderTypeEnum.TAKE_AWAY:
    case 'TAKE_AWAY':
    case 'TAKEOUT': // Para compatibilidad
      return 'ü•° Llevar';
    case OrderTypeEnum.DELIVERY:
    case 'DELIVERY':
      return 'üöö Env√≠o';
    default:
      return type;
  }
};

/**
 * Formatea el estado de la orden
 * @param status - Estado de la orden
 * @returns String formateado en espa√±ol
 */
export const formatOrderStatus = (status: OrderStatus | string): string => {
  switch (status) {
    case OrderStatusEnum.PENDING:
    case 'PENDING':
      return 'Pendiente';
    case OrderStatusEnum.IN_PROGRESS:
    case 'IN_PROGRESS':
      return 'En Progreso';
    case OrderStatusEnum.IN_PREPARATION:
    case 'IN_PREPARATION':
      return 'En Preparaci√≥n';
    case OrderStatusEnum.READY:
    case 'READY':
      return 'Lista';
    case OrderStatusEnum.DELIVERED:
    case 'DELIVERED':
      return 'Entregada';
    case OrderStatusEnum.COMPLETED:
    case 'COMPLETED':
      return 'Completada';
    case OrderStatusEnum.CANCELLED:
    case 'CANCELLED':
      return 'Cancelada';
    default:
      return status;
  }
};

/**
 * Formatea el estado de la orden (versi√≥n alternativa para compatibilidad)
 * Esta versi√≥n usa textos ligeramente diferentes
 * @param status - Estado de la orden
 * @returns String formateado en espa√±ol
 */
export const formatOrderStatusAlt = (status: string): string => {
  switch (status) {
    case 'PENDING':
      return 'Pendiente';
    case 'IN_PROGRESS':
      return 'En preparaci√≥n';
    case 'READY':
      return 'Listo';
    case 'DELIVERED':
      return 'Entregado';
    default:
      return status;
  }
};

/**
 * Obtiene el color para el estado de la orden
 * @param status - Estado de la orden
 * @param theme - Tema de la aplicaci√≥n (opcional, para algunos colores)
 * @returns Color hex o referencia al tema
 */
export const getStatusColor = (
  status: OrderStatus | string,
  theme?: any,
): string => {
  switch (status) {
    case OrderStatusEnum.PENDING:
    case 'PENDING':
      return '#FFA000'; // Orange
    case OrderStatusEnum.IN_PROGRESS:
    case 'IN_PROGRESS':
      return theme?.colors?.primary || '#6200EE';
    case OrderStatusEnum.READY:
    case 'READY':
      return '#4CAF50'; // Green
    case OrderStatusEnum.DELIVERED:
    case 'DELIVERED':
      return theme?.colors?.tertiary || '#9C27B0'; // Purple
    default:
      return theme?.colors?.onSurfaceVariant || '#757575';
  }
};

/**
 * Determina el estado de pago de una orden
 * @param order - Orden completa o de lista
 * @returns Estado del pago: 'unpaid' | 'partial' | 'paid'
 */
export const getPaymentStatus = (
  order: Order | OrderOpenList | OrderForFinalizationList,
): 'unpaid' | 'partial' | 'paid' => {
  // Verificar que order existe
  if (!order) {
    return 'unpaid';
  }

  // Si es OrderOpenList o OrderForFinalizationList, usar paymentsSummary
  if ('paymentsSummary' in order) {
    const totalPaid = order.paymentsSummary?.totalPaid || 0;
    const orderTotal =
      typeof order.total === 'string'
        ? parseFloat(order.total)
        : order.total || 0;

    if (totalPaid >= orderTotal) {
      return 'paid';
    } else if (totalPaid > 0) {
      return 'partial';
    } else {
      return 'unpaid';
    }
  }

  // Si es Order completa, usar payments
  if (!order.payments || order.payments.length === 0) {
    return 'unpaid';
  }

  // Sumar todos los pagos completados
  const totalPaid = order.payments
    .filter((payment: any) => payment.paymentStatus === 'COMPLETED')
    .reduce((sum: number, payment: any) => sum + (payment.amount || 0), 0);

  const orderTotal =
    typeof order.total === 'string'
      ? parseFloat(order.total)
      : order.total || 0;

  if (totalPaid === 0) {
    return 'unpaid';
  } else if (totalPaid >= orderTotal) {
    return 'paid';
  } else {
    return 'partial';
  }
};

/**
 * Obtiene el color para el estado de pago
 * @param paymentStatus - Estado del pago
 * @returns Color hex
 */
export const getPaymentStatusColor = (
  paymentStatus: 'unpaid' | 'partial' | 'paid',
): string => {
  switch (paymentStatus) {
    case 'paid':
      return '#10B981'; // Green
    case 'partial':
      return '#F59E0B'; // Amber
    case 'unpaid':
      return '#EF4444'; // Red
    default:
      return '#757575'; // Gray
  }
};

/**
 * Formatea el texto del estado de pago
 * @param paymentStatus - Estado del pago
 * @returns Texto formateado con emoji
 */
export const formatPaymentStatus = (
  paymentStatus: 'unpaid' | 'partial' | 'paid',
): string => {
  switch (paymentStatus) {
    case 'paid':
      return 'üíµ Pagado';
    case 'partial':
      return 'üíµ Parcial';
    case 'unpaid':
      return 'üíµ Pendiente';
    default:
      return 'üíµ Desconocido';
  }
};

================
File: app/src/app/utils/shadowStyles.ts
================
import { Platform, ViewStyle } from 'react-native';

interface ShadowOptions {
  shadowColor?: string;
  shadowOffset?: { width: number; height: number };
  shadowOpacity?: number;
  shadowRadius?: number;
  elevation?: number;
}

/**
 * Genera estilos de sombra compatibles con web y m√≥vil
 * @param options Opciones de sombra para React Native
 * @returns Estilos de sombra apropiados para la plataforma
 */
export function createShadowStyle(options: ShadowOptions): ViewStyle {
  const {
    shadowColor = '#000',
    shadowOffset = { width: 0, height: 2 },
    shadowOpacity = 0.25,
    shadowRadius = 3.84,
    elevation = 5,
  } = options;

  if (Platform.OS === 'web') {
    // Convertir valores de React Native a CSS box-shadow
    const offsetX = shadowOffset.width;
    const offsetY = shadowOffset.height;
    const blur = shadowRadius;

    // Convertir color hex a rgba con opacidad
    const color =
      shadowColor === '#000' || shadowColor === '#000000'
        ? `rgba(0, 0, 0, ${shadowOpacity})`
        : shadowColor.includes('rgba')
          ? shadowColor
          : `${shadowColor}${Math.round(shadowOpacity * 255)
              .toString(16)
              .padStart(2, '0')}`;

    return {
      boxShadow: `${offsetX}px ${offsetY}px ${blur}px ${color}`,
    } as any;
  }

  // Para m√≥vil, devolver las propiedades nativas
  return {
    shadowColor,
    shadowOffset,
    shadowOpacity,
    shadowRadius,
    elevation,
  };
}

/**
 * Estilos de sombra predefinidos
 */
export const shadowPresets = {
  small: createShadowStyle({
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.18,
    shadowRadius: 1.0,
    elevation: 1,
  }),

  medium: createShadowStyle({
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  }),

  large: createShadowStyle({
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 4.65,
    elevation: 8,
  }),

  none: Platform.select({
    web: { boxShadow: 'none' },
    default: {
      shadowColor: 'transparent',
      shadowOffset: { width: 0, height: 0 },
      shadowOpacity: 0,
      shadowRadius: 0,
      elevation: 0,
    },
  }) as ViewStyle,
};

================
File: app/src/app/utils/tokenVerification.ts
================
import { authService } from '@/modules/auth/services/authService';
import { useAuthStore } from '@/app/store/authStore';
import EncryptedStorage from '@/app/services/secureStorageService';

const AUTH_TOKEN_KEY = 'auth_token';
const REFRESH_TOKEN_KEY = 'refresh_token';
const USER_INFO_KEY = 'user_info';

/**
 * Verifica si el token almacenado es v√°lido con el backend
 * Esta funci√≥n est√° separada para evitar ciclos de dependencias
 */
export async function verifyStoredToken(): Promise<boolean> {
  try {
    const { accessToken } = useAuthStore.getState();

    if (!accessToken) {
      return false;
    }

    const isTokenValid = await authService.verifyToken();

    if (!isTokenValid) {
      // Si el token no es v√°lido, limpiamos todo
      await EncryptedStorage.removeItem(AUTH_TOKEN_KEY);
      await EncryptedStorage.removeItem(REFRESH_TOKEN_KEY);
      await EncryptedStorage.removeItem(USER_INFO_KEY);

      useAuthStore.setState({
        accessToken: null,
        refreshToken: null,
        user: null,
        isAuthenticated: false,
      });

      return false;
    }

    return true;
  } catch (error) {
    console.error('Error verificando token:', error);
    return false;
  }
}

================
File: app/src/hooks/useAudioRecorder.ts
================
import { useState, useCallback, useRef, useEffect } from 'react';
import {
  useAudioRecorder as useExpoAudioRecorder,
  AudioModule,
  RecordingPresets,
} from 'expo-audio';
import {
  ExpoSpeechRecognitionModule,
  useSpeechRecognitionEvent,
} from 'expo-speech-recognition';

interface UseAudioRecorderReturn {
  isRecording: boolean;
  isPreparing: boolean;
  isProcessing: boolean;
  audioUri: string | null;
  transcription: string | null;
  startRecording: () => Promise<void>;
  stopRecording: () => Promise<void>;
  resetRecording: () => void;
  error: string | null;
}

export const useAudioRecorder = (): UseAudioRecorderReturn => {
  const [isRecording, setIsRecording] = useState(false);
  const [isPreparing, setIsPreparing] = useState(false);
  const [isProcessing, setIsProcessing] = useState(false);
  const [audioUri, setAudioUri] = useState<string | null>(null);
  const [transcription, setTranscription] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [isInitialized, setIsInitialized] = useState(false);

  // Usar el hook de expo-audio con configuraci√≥n de alta calidad para voz
  const audioRecorder = useExpoAudioRecorder({
    ...RecordingPresets.HIGH_QUALITY,
    android: {
      ...RecordingPresets.HIGH_QUALITY.android,
      extension: '.mp4',
      outputFormat: 'mpeg4',
      audioEncoder: 'aac',
      sampleRate: 16000, // Optimizado para reconocimiento de voz
      numberOfChannels: 1,
      bitRate: 64000,
    },
    ios: {
      ...RecordingPresets.HIGH_QUALITY.ios,
      extension: '.m4a',
      sampleRate: 16000,
      numberOfChannels: 1,
      bitRate: 64000,
    },
  });

  const [currentTranscription, setCurrentTranscription] = useState<string>('');
  const currentTranscriptionRef = useRef<string>('');
  const isTranscribing = useRef(false);
  const isMounted = useRef(true);

  // Verificar que el audio recorder est√© listo
  useEffect(() => {
    if (audioRecorder && typeof audioRecorder.record === 'function') {
      setIsInitialized(true);
    }
  }, [audioRecorder]);

  // Estado interno para rastrear si estamos en proceso de detener
  const isStopping = useRef(false);

  // Eventos de reconocimiento de voz
  useSpeechRecognitionEvent('result', (event) => {
    if (!isMounted.current) return;

    const results = event.results;
    if (results && results.length > 0) {
      const bestResult = results[0];
      if (bestResult && bestResult.transcript) {
        const newTranscript = bestResult.transcript;
        currentTranscriptionRef.current = newTranscript;
        setCurrentTranscription(newTranscript);

        if (event.isFinal || bestResult.isFinal) {
          setTranscription(newTranscript);
        }
      }
    }
  });

  useSpeechRecognitionEvent('end', () => {
    if (!isMounted.current) return;
    isTranscribing.current = false;
  });

  const startRecording = useCallback(async () => {
    if (!isMounted.current) return;
    if (!isInitialized || !audioRecorder) {
      setError('El grabador de audio no est√° listo');
      return;
    }

    try {
      setError(null);
      setIsPreparing(true);
      setCurrentTranscription('');
      currentTranscriptionRef.current = '';
      setTranscription('');

      // Solicitar permisos de audio
      const audioPermission =
        await AudioModule.requestRecordingPermissionsAsync();
      if (!audioPermission.granted) {
        throw new Error('Se requiere permiso para grabar audio');
      }

      // Solicitar permisos de reconocimiento de voz
      const speechPermissions =
        await ExpoSpeechRecognitionModule.requestPermissionsAsync();
      if (!speechPermissions.granted) {
        throw new Error('Se requiere permiso para reconocimiento de voz');
      }

      // Iniciar reconocimiento de voz ANTES de la grabaci√≥n
      isTranscribing.current = true;
      setCurrentTranscription('');

      try {
        await ExpoSpeechRecognitionModule.start({
          lang: 'es-MX',
          interimResults: true,
          continuous: true,
          maxAlternatives: 1,
        });
      } catch (speechError) {
        // Continuar sin reconocimiento si falla
      }

      // Esperar un momento para que se establezca el reconocimiento
      await new Promise((resolve) => setTimeout(resolve, 300));

      // Preparar y comenzar la grabaci√≥n de audio
      await audioRecorder.prepareToRecordAsync();
      await audioRecorder.record();

      if (isMounted.current) {
        setIsRecording(true);
        setIsPreparing(false);
      }
    } catch (err) {
      if (isMounted.current) {
        setIsPreparing(false);
        const errorMessage =
          err instanceof Error ? err.message : 'Error al iniciar grabaci√≥n';
        setError(errorMessage);
      }
    }
  }, [audioRecorder, isInitialized]);

  const stopRecording = useCallback(async () => {
    if (!isMounted.current) return;

    // Prevenir m√∫ltiples llamadas simult√°neas
    if (isStopping.current) {
      return;
    }

    try {
      // Verificar si realmente est√° grabando
      const isCurrentlyRecording = audioRecorder.isRecording;
      if (!isCurrentlyRecording) {
        return;
      }

      isStopping.current = true;

      setIsProcessing(true);
      setIsRecording(false);

      // Primero detener el reconocimiento de voz
      if (isTranscribing.current) {
        try {
          await ExpoSpeechRecognitionModule.stop();
          // Esperar un momento para asegurar que se capture la transcripci√≥n final
          await new Promise((resolve) => setTimeout(resolve, 500));
        } catch (error) {
          // Error al detener reconocimiento de voz
        } finally {
          isTranscribing.current = false;
        }
      }

      // Detener grabaci√≥n de audio
      let uri: string | undefined;
      try {
        await audioRecorder.stop();
        uri = audioRecorder.uri;
      } catch (audioError) {
        // Si el error es "stop failed", intentar obtener el URI de todas formas
        if (audioError?.message?.includes('stop failed')) {
          uri = audioRecorder.uri;
        } else {
          throw audioError;
        }
      }

      if (!uri) {
        throw new Error('No se pudo obtener el archivo de audio');
      }

      if (isMounted.current) {
        // Usar la transcripci√≥n que se captur√≥ durante la grabaci√≥n
        const finalTranscription =
          currentTranscriptionRef.current ||
          currentTranscription ||
          transcription ||
          '';

        if (finalTranscription) {
          setTranscription(finalTranscription);
        } else {
          setTranscription('');
        }

        // Establecer el URI del audio al final
        setAudioUri(uri);
        setIsProcessing(false);
      }
    } catch (err) {
      if (isMounted.current) {
        setIsProcessing(false);
        const errorMessage =
          err instanceof Error ? err.message : 'Error al detener grabaci√≥n';
        setError(errorMessage);
      }
    } finally {
      isStopping.current = false;
    }
  }, [audioRecorder, currentTranscription, transcription]);

  const resetRecording = useCallback(() => {
    if (!isMounted.current) return;

    // Detener reconocimiento si est√° activo
    if (isTranscribing.current) {
      try {
        const stopPromise = ExpoSpeechRecognitionModule.stop();
        if (stopPromise && typeof stopPromise.catch === 'function') {
          stopPromise.catch((_err) => {});
        }
      } catch (_err) {}
      isTranscribing.current = false;
    }

    // Detener grabaci√≥n si est√° activa
    if (audioRecorder && audioRecorder.isRecording) {
      try {
        const stopPromise = audioRecorder.stop();
        if (stopPromise && typeof stopPromise.catch === 'function') {
          stopPromise.catch((_err) => {
            // Ignorar el error "stop failed" ya que es esperado cuando se resetea r√°pidamente
          });
        }
      } catch (err) {
        // Ignorar el error "stop failed"
      }
    }

    // Limpiar estados
    setAudioUri(null);
    setTranscription(null);
    setCurrentTranscription('');
    currentTranscriptionRef.current = '';
    setError(null);
    setIsRecording(false);
    setIsProcessing(false);
    setIsPreparing(false);
    isStopping.current = false;
  }, [audioRecorder]);

  // Limpiar al desmontar
  useEffect(() => {
    isMounted.current = true;

    return () => {
      isMounted.current = false;

      // Limpiar el reconocimiento de voz
      if (isTranscribing.current) {
        isTranscribing.current = false;
        try {
          const stopPromise = ExpoSpeechRecognitionModule.stop();
          if (stopPromise && typeof stopPromise.catch === 'function') {
            stopPromise.catch(() => {});
          }
        } catch (err) {
          // Ignorar errores en cleanup
        }
      }

      // No intentar detener el audio recorder aqu√≠ porque puede causar el error
      // El hook de expo-audio maneja su propia limpieza
    };
  }, []);

  return {
    isRecording,
    isPreparing,
    isProcessing,
    audioUri,
    transcription,
    startRecording,
    stopRecording,
    resetRecording,
    error,
  };
};

================
File: app/src/hooks/useGoogleMapsConfig.ts
================
import { useState, useEffect } from 'react';
import { appConfigService } from '@/services/appConfig';
import { GOOGLE_MAPS_CONFIG } from '@/modules/customers/constants/maps.config';

export interface GoogleMapsConfigWithApiKey {
  apiKey: string;
  defaultCenter: {
    lat: number;
    lng: number;
  };
  defaultZoom: number;
  locationZoom: number;
  mapOptions: {
    disableDefaultUI: boolean;
    zoomControl: boolean;
    mapTypeControl: boolean;
    scaleControl: boolean;
    streetViewControl: boolean;
    rotateControl: boolean;
    fullscreenControl: boolean;
    clickableIcons: boolean;
  };
}

export function useGoogleMapsConfig() {
  const [config, setConfig] = useState<GoogleMapsConfigWithApiKey | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function loadConfig() {
      try {
        const apiKey = await appConfigService.getMapsApiKey();
        setConfig({
          ...GOOGLE_MAPS_CONFIG,
          apiKey,
        });
      } catch (err) {
        setError('No se pudo cargar la configuraci√≥n de mapas');
      } finally {
        setLoading(false);
      }
    }

    loadConfig();
  }, []);

  return { config, loading, error };
}

================
File: app/src/modules/areasTables/services/tableService.ts
================
import { useQuery } from '@tanstack/react-query';
import ApiClientWrapper from '../../../app/services/apiClientWrapper';
import { ApiError } from '../../../app/lib/errors';
import { API_PATHS } from '../../../app/constants/apiPaths';
import { BackendErrorResponse } from '../../../app/types/api.types';
import { BaseListQuery } from '../../../app/types/query.types';
import {
  Table,
  CreateTableDto,
  UpdateTableDto,
  FindAllTablesDto,
} from '../schema/table.schema';

export const getTables = async (
  filterOptions: FindAllTablesDto = {},
  paginationOptions: BaseListQuery = { page: 1, limit: 10 },
): Promise<Table[]> => {
  const response = await ApiClientWrapper.get<{
    items: Table[];
    total: number;
    page: number;
    limit: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  }>(API_PATHS.TABLES, {
    ...filterOptions,
    page: paginationOptions.page,
    limit: paginationOptions.limit,
  });

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
  return response.data.items;
};

export const getTablesByAreaId = async (areaId: string): Promise<Table[]> => {
  const response = await ApiClientWrapper.get<{
    items: Table[];
    total: number;
    page: number;
    limit: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  }>(API_PATHS.TABLES_BY_AREA.replace(':areaId', areaId));

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
  return response.data.items;
};

export const getTableById = async (id: string): Promise<Table> => {
  const response = await ApiClientWrapper.get<Table>(
    API_PATHS.TABLES_BY_ID.replace(':id', id),
  );

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
  return response.data;
};

export const createTable = async (data: CreateTableDto): Promise<Table> => {
  const response = await ApiClientWrapper.post<Table>(API_PATHS.TABLES, data);

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
  return response.data;
};

export const updateTable = async (
  id: string,
  data: UpdateTableDto,
): Promise<Table> => {
  const response = await ApiClientWrapper.patch<Table>(
    API_PATHS.TABLES_BY_ID.replace(':id', id),
    data,
  );

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
  return response.data;
};

export const deleteTable = async (id: string): Promise<void> => {
  const response = await ApiClientWrapper.delete(
    API_PATHS.TABLES_BY_ID.replace(':id', id),
  );

  if (!response.ok) {
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
};

// Claves de Query para tablas relacionadas con √°reas
const tableQueryKeys = {
  base: ['tables'] as const, // Clave base para todas las tablas
  byArea: (areaId: string | null | undefined) =>
    [...tableQueryKeys.base, 'area', areaId] as const,
};

export function useGetTablesByArea(areaId: string | null | undefined) {
  return useQuery<Table[], ApiError>({
    queryKey: tableQueryKeys.byArea(areaId),
    queryFn: () => {
      if (!areaId) {
        return Promise.resolve([]);
      }
      return getTablesByAreaId(areaId);
    },
    enabled: !!areaId,
    // Sin staleTime, se usar√° la configuraci√≥n global (0)
  });
}

================
File: app/src/modules/auth/services/authService.ts
================
import ApiClientWrapper from '../../../app/services/apiClientWrapper';
import {
  handleApiResponse,
  handleApiResponseVoid,
} from '../../../app/lib/apiHelpers';
import { API_PATHS } from '../../../app/constants/apiPaths';
import {
  AuthEmailLoginDto,
  LoginResponseDto,
  LoginFormInputs,
  RegisterFormInputs,
} from '../schema/auth.schema';

class AuthService {
  async login(loginData: LoginFormInputs): Promise<LoginResponseDto> {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    const isEmail = emailRegex.test(loginData.emailOrUsername);
    const sanitizedInput = loginData.emailOrUsername.trim().toLowerCase();

    const payload: AuthEmailLoginDto = {
      password: loginData.password,
      ...(isEmail ? { email: sanitizedInput } : { username: sanitizedInput }),
    };

    const response = await ApiClientWrapper.post<LoginResponseDto>(
      API_PATHS.AUTH_EMAIL_LOGIN,
      payload,
    );

    return handleApiResponse(response);
  }

  async register(data: RegisterFormInputs): Promise<void> {
    const response = await ApiClientWrapper.post<{ message?: string }>(
      API_PATHS.AUTH_EMAIL_REGISTER,
      data,
    );

    handleApiResponseVoid(response);
  }

  async verifyToken(): Promise<boolean> {
    try {
      const response = await ApiClientWrapper.get(API_PATHS.AUTH_ME);
      return response.status === 200;
    } catch (error) {
      return false;
    }
  }
}

export const authService = new AuthService();

================
File: app/src/modules/availability/components/ModifierGroupAvailabilityItem.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, Switch } from 'react-native-paper';
import { ModifierGroupAvailability } from '../types/availability.types';
import { useOptimisticAvailability } from '../hooks/useOptimisticAvailability';
import { useAppTheme } from '@/app/styles/theme';
import { AvailabilityListItem } from './AvailabilityListItem';

interface ModifierGroupAvailabilityItemProps {
  modifierGroup: ModifierGroupAvailability;
  onRefresh?: () => void;
}

export const ModifierGroupAvailabilityItem: React.FC<
  ModifierGroupAvailabilityItemProps
> = ({ modifierGroup, onRefresh: _onRefresh }) => {
  const theme = useAppTheme();
  const [expanded, setExpanded] = useState(false);
  const updateAvailability = useOptimisticAvailability();

  const handleGroupToggle = (value: boolean) => {
    updateAvailability.mutate({
      type: 'modifierGroup',
      id: modifierGroup.id,
      isActive: value,
      cascade: true,
    });
  };

  const handleModifierToggle = (modifierId: string, value: boolean) => {
    updateAvailability.mutate({
      type: 'modifier',
      id: modifierId,
      isActive: value,
    });
  };

  const totalModifiers = modifierGroup.modifiers.length;
  const activeModifiers = modifierGroup.modifiers.filter(
    (m) => m.isActive,
  ).length;

  return (
    <AvailabilityListItem
      title={modifierGroup.name}
      subtitle={`${activeModifiers}/${totalModifiers} modificadores activos`}
      icon="tune-variant"
      isActive={modifierGroup.isActive}
      onToggle={handleGroupToggle}
      isExpanded={expanded}
      onToggleExpand={() => setExpanded(!expanded)}
    >
      <View style={styles.modifiersContainer}>
        {modifierGroup.modifiers.map((modifier) => (
          <View
            key={modifier.id}
            style={[
              styles.modifierItem,
              { opacity: !modifier.isActive ? 0.5 : 1 },
            ]}
          >
            <Text
              style={[
                styles.modifierTitle,
                !modifier.isActive && styles.strikethrough,
                { color: theme.colors.onSurface },
              ]}
            >
              {modifier.name}
            </Text>
            <Switch
              value={modifier.isActive}
              onValueChange={(value) =>
                handleModifierToggle(modifier.id, value)
              }
              disabled={!modifierGroup.isActive}
            />
          </View>
        ))}
      </View>
    </AvailabilityListItem>
  );
};

const styles = StyleSheet.create({
  modifiersContainer: {
    paddingLeft: 16,
  },
  modifierItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 4,
  },
  modifierTitle: {
    fontSize: 13,
  },
  strikethrough: {
    textDecorationLine: 'line-through',
  },
});

================
File: app/src/modules/customers/constants/maps.config.ts
================
// Configuraci√≥n para Google Maps
export const GOOGLE_MAPS_CONFIG = {
  
  // Centro por defecto para M√©xico
  defaultCenter: {
    lat: 23.6345,
    lng: -102.5528,
  },
  
  // Configuraci√≥n de zoom
  defaultZoom: 5,
  locationZoom: 16,
  
  // Opciones del mapa
  mapOptions: {
    disableDefaultUI: false,
    zoomControl: true,
    mapTypeControl: false,
    scaleControl: false,
    streetViewControl: false,
    rotateControl: false,
    fullscreenControl: false,
    clickableIcons: false,
  },
};

================
File: app/src/modules/customers/hooks/useCustomersQueries.ts
================
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { customersService } from '../services/customersService';
import {
  CreateCustomerDto,
  UpdateCustomerDto,
  FindAllCustomersQuery,
  ChatMessage,
  Address,
} from '../types/customer.types';
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';

// Keys para React Query
export const customerKeys = {
  all: ['customers'] as const,
  lists: () => [...customerKeys.all, 'list'] as const,
  list: (filters?: FindAllCustomersQuery) =>
    [...customerKeys.lists(), filters] as const,
  details: () => [...customerKeys.all, 'detail'] as const,
  detail: (id: string) => [...customerKeys.details(), id] as const,
  activeRecent: (daysAgo: number) =>
    [...customerKeys.all, 'active-recent', daysAgo] as const,
  addresses: (customerId: string) =>
    [...customerKeys.all, 'addresses', customerId] as const,
};

// Hook para obtener todos los clientes
export function useCustomers(filters?: FindAllCustomersQuery) {
  return useQuery({
    queryKey: customerKeys.list(filters),
    queryFn: () => customersService.findAll(filters),
  });
}

// Hook para obtener un cliente espec√≠fico
export function useCustomer(id: string, enabled = true) {
  return useQuery({
    queryKey: customerKeys.detail(id),
    queryFn: () => customersService.findOne(id),
    enabled: enabled && !!id,
  });
}

// Hook para crear un cliente
export function useCreateCustomer() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data: CreateCustomerDto) => customersService.create(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: customerKeys.lists() });
    },
  });
}

// Hook para actualizar un cliente
export function useUpdateCustomer() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: UpdateCustomerDto }) =>
      customersService.update(id, data),
    onSuccess: (updatedCustomer) => {
      queryClient.setQueryData(
        customerKeys.detail(updatedCustomer.id),
        updatedCustomer,
      );
      queryClient.invalidateQueries({ queryKey: customerKeys.lists() });
    },
  });
}

// Hook para eliminar un cliente
export function useDeleteCustomer() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id: string) => customersService.remove(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: customerKeys.lists() });
    },
  });
}

// Hook para agregar mensaje al chat
export function useAppendChatMessage() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      customerId,
      message,
    }: {
      customerId: string;
      message: Omit<ChatMessage, 'timestamp'>;
    }) => customersService.appendChatMessage(customerId, message),
    onSuccess: (updatedCustomer) => {
      queryClient.setQueryData(
        customerKeys.detail(updatedCustomer.id),
        updatedCustomer,
      );
    },
  });
}

// Hook para actualizar historial relevante
export function useUpdateRelevantChatHistory() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      customerId,
      relevantHistory,
    }: {
      customerId: string;
      relevantHistory: ChatMessage[];
    }) =>
      customersService.updateRelevantChatHistory(customerId, relevantHistory),
    onSuccess: (updatedCustomer) => {
      queryClient.setQueryData(
        customerKeys.detail(updatedCustomer.id),
        updatedCustomer,
      );
    },
  });
}

// Hook para actualizar estad√≠sticas
export function useUpdateCustomerStats() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      customerId,
      stats,
    }: {
      customerId: string;
      stats: { totalOrders?: number; totalSpent?: number };
    }) => customersService.updateCustomerStats(customerId, stats),
    onSuccess: (updatedCustomer) => {
      queryClient.setQueryData(
        customerKeys.detail(updatedCustomer.id),
        updatedCustomer,
      );
      queryClient.invalidateQueries({ queryKey: customerKeys.lists() });
    },
  });
}

// Hook para obtener clientes activos con interacci√≥n reciente
export function useActiveCustomersWithRecentInteraction(daysAgo = 30) {
  return useQuery({
    queryKey: customerKeys.activeRecent(daysAgo),
    queryFn: () => customersService.getActiveWithRecentInteraction(daysAgo),
  });
}

// Hook para obtener direcciones de un cliente
export function useGetAddressesByCustomer(
  customerId: string,
  options?: { enabled?: boolean },
) {
  return useQuery({
    queryKey: customerKeys.addresses(customerId),
    queryFn: async () => {
      const response = await apiClient.get<Address[]>(
        `${API_PATHS.CUSTOMERS}/${customerId}/addresses`,
      );
      if (!response.ok || !response.data) {
        return [];
      }
      return response.data;
    },
    enabled: options?.enabled ?? true,
  });
}

================
File: app/src/modules/customers/services/customersService.ts
================
import apiClient from '@/app/services/apiClient';
import { ApiError } from '@/app/lib/errors';
import { API_PATHS } from '@/app/constants/apiPaths';
import {
  Customer,
  CreateCustomerDto,
  UpdateCustomerDto,
  FindAllCustomersQuery,
  ChatMessage,
} from '../types/customer.types';

async function findAll(params?: FindAllCustomersQuery): Promise<Customer[]> {
  const response = await apiClient.get<Customer[]>(API_PATHS.CUSTOMERS, params);
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}

async function findOne(id: string): Promise<Customer> {
  const response = await apiClient.get<Customer>(
    API_PATHS.CUSTOMERS_BY_ID.replace(':id', id),
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}

async function create(data: CreateCustomerDto): Promise<Customer> {
  const response = await apiClient.post<Customer>(API_PATHS.CUSTOMERS, data);
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}

async function update(id: string, data: UpdateCustomerDto): Promise<Customer> {
  const response = await apiClient.patch<Customer>(
    API_PATHS.CUSTOMERS_BY_ID.replace(':id', id),
    data,
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}

async function remove(id: string): Promise<void> {
  const response = await apiClient.delete(
    API_PATHS.CUSTOMERS_BY_ID.replace(':id', id),
  );
  if (!response.ok) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
}

// M√©todos espec√≠ficos para chat history
async function appendChatMessage(
  customerId: string,
  message: Omit<ChatMessage, 'timestamp'>,
): Promise<Customer> {
  const response = await apiClient.post<Customer>(
    API_PATHS.CUSTOMERS_CHAT_MESSAGE.replace(':customerId', customerId),
    message,
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}

async function updateRelevantChatHistory(
  customerId: string,
  relevantHistory: ChatMessage[],
): Promise<Customer> {
  const response = await apiClient.patch<Customer>(
    API_PATHS.CUSTOMERS_CHAT_HISTORY.replace(':customerId', customerId),
    { relevantHistory },
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}

async function updateCustomerStats(
  customerId: string,
  stats: { totalOrders?: number; totalSpent?: number },
): Promise<Customer> {
  const response = await apiClient.patch<Customer>(
    API_PATHS.CUSTOMERS_STATS.replace(':customerId', customerId),
    stats,
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}

async function getActiveWithRecentInteraction(
  daysAgo: number = 30,
): Promise<Customer[]> {
  const response = await apiClient.get<Customer[]>(
    API_PATHS.CUSTOMERS_ACTIVE_RECENT,
    { daysAgo },
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}

export const customersService = {
  findAll,
  findOne,
  create,
  update,
  remove,
  appendChatMessage,
  updateRelevantChatHistory,
  updateCustomerStats,
  getActiveWithRecentInteraction,
};

================
File: app/src/modules/kitchen/hooks/useKitchenSnackbar.ts
================
import { useSnackbar } from '@/hooks/useSnackbar';

export function useKitchenSnackbar() {
  const { showSnackbar } = useSnackbar();

  const showError = (message: string) => {
    // Mostrar errores de forma m√°s discreta con duraci√≥n m√°s corta
    showSnackbar(message, 'error', 2000); // 2 segundos en lugar del default
  };

  return {
    showError,
  };
}

================
File: app/src/modules/menu/components/VariantFormModal.tsx
================
import React, { useEffect, useMemo, useState } from 'react';
import { View, StyleSheet } from 'react-native';
import {
  Portal,
  Modal,
  Card,
  TextInput,
  Button,
  Switch,
  Text,
  HelperText,
} from 'react-native-paper';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { ProductVariant } from '../schema/products.schema';
import { z } from 'zod';
import { useAppTheme } from '@/app/styles/theme';

// Schema local para el formulario de variantes
const variantFormSchema = z.object({
  id: z.string().optional(),
  name: z.string().min(1, 'El nombre es requerido'),
  price: z.coerce
    .number({
      invalid_type_error: 'El precio debe ser un n√∫mero',
      required_error: 'El precio es requerido',
    })
    .positive('El precio debe ser mayor a 0'),
  isActive: z.boolean(),
  sortOrder: z.number().optional().default(0),
});

type VariantFormData = z.infer<typeof variantFormSchema>;

interface VariantFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSubmit: (data: ProductVariant) => void;
  initialData?: Partial<ProductVariant>;
}

function VariantFormModal({
  visible,
  onDismiss,
  onSubmit,
  initialData,
}: VariantFormModalProps): React.ReactElement {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);
  const isEditing = !!initialData?.name;
  const [priceInputValue, setPriceInputValue] = useState<string>('');

  const {
    control,
    handleSubmit,
    reset,
    watch,
    formState: { errors, isSubmitting },
  } = useForm<VariantFormData>({
    resolver: zodResolver(variantFormSchema),
    defaultValues: {
      name: initialData?.name ?? '',
      price: initialData?.price ?? 0,
      isActive: initialData?.isActive ?? true,
      sortOrder: initialData?.sortOrder ?? 0,
      id: initialData?.id,
    },
  });

  const priceValue = watch('price');

  useEffect(() => {
    if (visible) {
      reset({
        name: initialData?.name ?? '',
        price: initialData?.price ?? 0,
        isActive: initialData?.isActive ?? true,
        sortOrder: initialData?.sortOrder ?? 0,
        id: initialData?.id,
      });
    }
  }, [visible, initialData, reset]);

  useEffect(() => {
    setPriceInputValue(
      priceValue !== undefined && priceValue !== null ? String(priceValue) : '',
    );
  }, [priceValue]);

  const handleFormSubmit = (data: VariantFormData) => {
    const finalData: ProductVariant = {
      ...data,
      ...(initialData?.id && { id: initialData.id }),
    } as ProductVariant;
    onSubmit(finalData);
  };

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalContainer}
      >
        <Card style={styles.card}>
          <Card.Title
            title={isEditing ? 'Editar Variante' : 'Nueva Variante'}
          />
          <Card.Content style={styles.content}>
            <View style={styles.fieldContainer}>
              <Controller
                control={control}
                name="name"
                render={({ field: { onChange, onBlur, value } }) => (
                  <TextInput
                    label="Nombre Variante *"
                    value={value}
                    onChangeText={onChange}
                    onBlur={onBlur}
                    error={!!errors.name}
                    style={styles.input}
                    autoFocus={!isEditing}
                  />
                )}
              />
              {errors.name && (
                <HelperText type="error" visible={!!errors.name}>
                  {errors.name.message}
                </HelperText>
              )}
            </View>

            <View style={styles.fieldContainer}>
              <Controller
                control={control}
                name="price"
                render={({ field }) => (
                  <TextInput
                    label="Precio *"
                    value={priceInputValue}
                    onChangeText={(text) => {
                      const formattedText = text.replace(/,/g, '.');
                      if (/^(\d*\.?\d*)$/.test(formattedText)) {
                        setPriceInputValue(formattedText);
                        if (formattedText === '') {
                          field.onChange(undefined);
                        } else if (formattedText !== '.') {
                          const numericValue = parseFloat(formattedText);
                          if (!isNaN(numericValue)) {
                            field.onChange(numericValue);
                          }
                        }
                      }
                    }}
                    onBlur={field.onBlur}
                    error={!!errors.price}
                    style={styles.input}
                    keyboardType="decimal-pad"
                  />
                )}
              />
              {errors.price && (
                <HelperText type="error" visible={!!errors.price}>
                  {errors.price.message}
                </HelperText>
              )}
            </View>

            <View style={styles.fieldContainer}>
              <Controller
                control={control}
                name="sortOrder"
                render={({ field }) => (
                  <TextInput
                    mode="outlined"
                    label="Orden de visualizaci√≥n"
                    value={String(field.value || 0)}
                    onChangeText={(text) => {
                      const value = parseInt(text, 10);
                      field.onChange(isNaN(value) ? 0 : value);
                    }}
                    onBlur={field.onBlur}
                    error={!!errors.sortOrder}
                    style={styles.input}
                    keyboardType="numeric"
                  />
                )}
              />
              {errors.sortOrder && (
                <HelperText type="error" visible={!!errors.sortOrder}>
                  {errors.sortOrder.message}
                </HelperText>
              )}
            </View>

            <View style={[styles.fieldContainer, styles.switchContainer]}>
              <Text style={styles.label}>Variante Activa</Text>
              <Controller
                control={control}
                name="isActive"
                render={({ field: { onChange, value } }) => (
                  <Switch value={!!value} onValueChange={onChange} />
                )}
              />
            </View>
          </Card.Content>
          <Card.Actions style={styles.actions}>
            <Button onPress={onDismiss} disabled={isSubmitting}>
              Cancelar
            </Button>
            <Button
              mode="contained"
              onPress={handleSubmit(handleFormSubmit)}
              loading={isSubmitting}
              disabled={isSubmitting}
            >
              Guardar
            </Button>
          </Card.Actions>
        </Card>
      </Modal>
    </Portal>
  );
}

const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    modalContainer: {
      padding: theme.spacing.l, // M√°s padding exterior
    },
    card: {
      backgroundColor: theme.colors.inverseOnSurface,
      borderRadius: theme.roundness * 3, // Un poco m√°s redondeado
    },
    content: {
      paddingHorizontal: theme.spacing.m, // Padding horizontal para el contenido
      paddingBottom: theme.spacing.s, // Peque√±o padding inferior antes de las acciones
    },
    fieldContainer: {
      marginBottom: theme.spacing.m, // Espacio uniforme debajo de cada campo/grupo
    },
    input: {},
    switchContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    label: {
      color: theme.colors.onSurfaceVariant,
    },
    actions: {
      justifyContent: 'flex-end',
      padding: theme.spacing.m, // Padding uniforme para las acciones
    },
  });

export default VariantFormModal;

================
File: app/src/modules/menu/schema/products.schema.ts
================
import { z } from 'zod';
import { baseListQuerySchema } from '../../../app/types/query.types';
// Importar tipos de dominio centralizados
import {
  photoSchema,
  type Photo,
} from '../../../app/schemas/domain/photo.schema';
import {
  productVariantSchema,
  type ProductVariant,
} from '../../../app/schemas/domain/product-variant.schema';
import { modifierGroupSchema } from '../../../app/schemas/domain/modifier-group.schema';
// Importar el schema y tipo Product centralizado del dominio
import {
  productSchema as domainProductSchema,
  type Product,
} from '../../../app/schemas/domain/product.schema';

// --- Schemas Zod ---

// Schema para variantes en el formulario (sin requerir ID) - derivado del dominio
const productVariantFormSchema = productVariantSchema
  .omit({ id: true })
  .extend({
    id: z.string().optional(),
    sortOrder: z.number().optional().default(0),
  });

// Schema base para formularios - compose desde el dominio con campos adicionales espec√≠ficos del formulario
const productFormBaseSchema = domainProductSchema
  .omit({
    id: true,
    photo: true,
    variants: true,
    modifierGroups: true,
    pizzaCustomizations: true,
    pizzaConfiguration: true,
    createdAt: true,
    updatedAt: true,
  })
  .extend({
    id: z.string().optional(), // ID opcional para creaci√≥n/formulario
    photoId: z.union([z.string().uuid(), z.null(), z.undefined()]).optional(), // ID de la foto guardada en backend
    imageUri: z // Campo temporal para el formulario
      .string()
      .url()
      .or(z.string().startsWith('file://'))
      .optional()
      .nullable(),
    variants: z.array(productVariantFormSchema).optional(), // Usa el schema del formulario
    variantsToDelete: z.array(z.string()).optional(), // Para manejar eliminaci√≥n en edici√≥n
    modifierGroupIds: z.array(z.string()).optional(), // IDs para asignar/actualizar
  });

// Esquema para el formulario, con la validaci√≥n condicional
export const productSchema = productFormBaseSchema.superRefine((data, ctx) => {
  if (data.hasVariants) {
    if (!data.variants || data.variants.length === 0) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'Debe a√±adir al menos una variante si marca esta opci√≥n.',
        path: ['variants'],
      });
    }
    if (data.price !== null && data.price !== undefined) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message:
          'El precio principal debe estar vac√≠o si el producto tiene variantes.',
        path: ['price'],
      });
    }
  } else {
    if (data.price === null || data.price === undefined) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'El precio es requerido si el producto no tiene variantes.',
        path: ['price'],
      });
    }
    if (data.variants && data.variants.length > 0) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message:
          'No debe haber variantes si el producto no est√° marcado como "Tiene Variantes".',
        path: ['variants'],
      });
    }
  }
});

// Tipo inferido para los inputs del formulario
export type ProductFormInputs = z.infer<typeof productSchema>;

// Schema para actualizaci√≥n de productos
export const updateProductSchema = productFormBaseSchema
  .partial()
  .superRefine((data, ctx) => {
    if (data.hasVariants !== undefined) {
      if (data.hasVariants) {
        if (data.variants !== undefined && data.variants.length === 0) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message: 'Debe a√±adir al menos una variante si marca esta opci√≥n.',
            path: ['variants'],
          });
        }
        if (data.price !== null && data.price !== undefined) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message:
              'El precio principal debe estar vac√≠o si el producto tiene variantes.',
            path: ['price'],
          });
        }
      } else {
        if (data.price === null || data.price === undefined) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message:
              'El precio es requerido si el producto no tiene variantes.',
            path: ['price'],
          });
        }
        if (data.variants && data.variants.length > 0) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message:
              'No debe haber variantes si el producto no est√° marcado como "Tiene Variantes".',
            path: ['variants'],
          });
        }
      }
    }
  });

export type UpdateProductFormInputs = z.infer<typeof updateProductSchema>;

// Esquema para la respuesta de la API - usa directamente el schema de dominio
// Este schema representa la estructura que devuelve el backend.
export const productResponseSchema = domainProductSchema;
// Si se necesita el tipo espec√≠fico inferido de esta respuesta:
// export type ProductApiResponse = z.infer<typeof productResponseSchema>;

// Esquema para la respuesta de lista paginada (si aplica)
export const productsListResponseSchema = z.tuple([
  z.array(productResponseSchema), // Usa el schema de respuesta definido arriba
  z.number(), // Count
]);
export type ProductsListResponse = z.infer<typeof productsListResponseSchema>;

// Esquema para los par√°metros de query de b√∫squeda
export const findAllProductsQuerySchema = baseListQuerySchema.extend({
  subcategoryId: z.string().optional(),
  hasVariants: z.boolean().optional(),
  isActive: z.boolean().optional(),
  search: z.string().optional(),
});
export type FindAllProductsQuery = z.infer<typeof findAllProductsQuerySchema>;

// Esquema para asignar/desasignar grupos de modificadores
export const assignModifierGroupsSchema = z.object({
  modifierGroupIds: z
    .array(z.string())
    .min(1, 'Se requiere al menos un ID de grupo'),
});
export type AssignModifierGroupsInput = z.infer<
  typeof assignModifierGroupsSchema
>;

// Re-exportar los tipos de dominio centralizados
export type { Photo, ProductVariant, Product }; // A√±adir Product

================
File: app/src/modules/menu/services/categoryService.ts
================
import ApiClientWrapper from '../../../app/services/apiClientWrapper';
import { ApiError } from '../../../app/lib/errors';
import { API_PATHS } from '../../../app/constants/apiPaths';
import type {
  Category,
  CreateCategoryDto,
  UpdateCategoryDto,
} from '../schema/category.schema';
import { PaginatedResponse } from '../../../app/types/api.types';

export const getCategories = async (params?: {
  isActive?: boolean;
  page?: number;
  limit?: number;
}): Promise<PaginatedResponse<Category>> => {
  const response = await ApiClientWrapper.get<{
    items: Category[];
    total: number;
    page: number;
    limit: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  }>(API_PATHS.CATEGORIES, params);

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status ?? 500);
  }

  // Transforma la respuesta del backend a PaginatedResponse
  return {
    data: response.data.items,
    total: response.data.total,
    page: response.data.page,
    limit: response.data.limit,
    totalPages: Math.ceil(response.data.total / response.data.limit),
  };
};

export const getCategory = async (id: string): Promise<Category> => {
  const response = await ApiClientWrapper.get<Category>(
    API_PATHS.CATEGORIES_BY_ID.replace(':id', id),
  );

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status ?? 500);
  }
  return response.data;
};

export const createCategory = async (
  data: CreateCategoryDto,
): Promise<Category> => {
  const response = await ApiClientWrapper.post<Category>(
    API_PATHS.CATEGORIES,
    data,
  );

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status ?? 500);
  }
  return response.data;
};

export const updateCategory = async (
  id: string,
  data: UpdateCategoryDto,
): Promise<Category> => {
  const response = await ApiClientWrapper.patch<Category>(
    API_PATHS.CATEGORIES_BY_ID.replace(':id', id),
    data,
  );

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status ?? 500);
  }

  return response.data;
};

export const deleteCategory = async (id: string): Promise<void> => {
  const response = await ApiClientWrapper.delete(
    API_PATHS.CATEGORIES_BY_ID.replace(':id', id),
  );

  if (!response.ok) {
    throw ApiError.fromApiResponse(response.data, response.status ?? 500);
  }
};

// Men√∫ para pantallas de creaci√≥n de √≥rdenes
export async function getOrderMenu(): Promise<Category[]> {
  const response = await ApiClientWrapper.get<Category[]>(
    API_PATHS.CATEGORIES_ORDER_MENU,
  );

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status ?? 500);
  }

  return response.data;
}

const categoryService = {
  getCategories,
  getCategory,
  createCategory,
  updateCategory,
  deleteCategory,
  getOrderMenu,
};

export default categoryService;

================
File: app/src/modules/menu/services/productsService.ts
================
import apiClient from '@/app/services/apiClient';
import { ApiError } from '@/app/lib/errors';
import { API_PATHS } from '@/app/constants/apiPaths';
import {
  Product,
  ProductFormInputs,
  FindAllProductsQuery,
  AssignModifierGroupsInput,
} from '../schema/products.schema'; // Corregida ruta de importaci√≥n
import { PaginatedResponse } from '@/app/types/api.types';

async function findAll(
  params: FindAllProductsQuery,
): Promise<PaginatedResponse<Product>> {
  const response = await apiClient.get<{
    items: Product[];
    total: number;
    page: number;
    limit: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  }>(API_PATHS.PRODUCTS, params);
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }

  // Transforma la respuesta del backend a PaginatedResponse
  return {
    data: response.data.items,
    total: response.data.total,
    page: response.data.page,
    limit: response.data.limit,
    totalPages: Math.ceil(response.data.total / response.data.limit),
  };
}

async function findOne(id: string): Promise<Product> {
  const response = await apiClient.get<Product>(
    API_PATHS.PRODUCTS_BY_ID.replace(':id', id),
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}

async function create(data: ProductFormInputs): Promise<Product> {
  const response = await apiClient.post<Product>(API_PATHS.PRODUCTS, data);

  if (!response.ok) {
    // Verificar si tenemos un ApiError preservado
    if ((response as any).apiError instanceof ApiError) {
      throw (response as any).apiError;
    }

    // Verificar si el error original del interceptor es un ApiError
    if (response.originalError instanceof ApiError) {
      throw response.originalError;
    }

    // Si no hay originalError, crear uno desde la respuesta
    throw ApiError.fromApiResponse(response.data, response.status);
  }

  return response.data!;
}

async function update(
  id: string,
  data: Partial<ProductFormInputs>,
): Promise<Product> {
  const response = await apiClient.patch<Product>(
    API_PATHS.PRODUCTS_BY_ID.replace(':id', id),
    data,
  );

  if (!response.ok) {
    // Verificar si tenemos un ApiError preservado
    if ((response as any).apiError instanceof ApiError) {
      throw (response as any).apiError;
    }

    // Verificar si el error original del interceptor es un ApiError
    if (response.originalError instanceof ApiError) {
      throw response.originalError;
    }

    // Si no hay originalError, crear uno desde la respuesta
    throw ApiError.fromApiResponse(response.data, response.status);
  }

  return response.data!;
}

async function remove(id: string): Promise<void> {
  const response = await apiClient.delete(
    API_PATHS.PRODUCTS_BY_ID.replace(':id', id),
  );
  if (!response.ok) {
    // No esperamos 'data' en un 204 No Content, pero s√≠ puede haber error
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  // No se retorna nada en caso de √©xito (204 No Content)
}

async function assignModifierGroups(
  productId: string,
  data: AssignModifierGroupsInput,
): Promise<Product> {
  const response = await apiClient.post<Product>(
    API_PATHS.PRODUCTS_MODIFIER_GROUPS.replace(':productId', productId),
    data,
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}

async function getModifierGroups(productId: string): Promise<Product> {
  const response = await apiClient.get<Product>(
    API_PATHS.PRODUCTS_MODIFIER_GROUPS.replace(':productId', productId),
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}

async function removeModifierGroups(
  productId: string,
  data: AssignModifierGroupsInput,
): Promise<Product> {
  const response = await apiClient.delete<Product>(
    API_PATHS.PRODUCTS_MODIFIER_GROUPS.replace(':productId', productId),
    data,
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}

async function findAllPizzas(): Promise<Product[]> {
  const response = await apiClient.get<Product[]>(API_PATHS.PRODUCTS_PIZZAS);
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}

async function getPizzaCustomizations(productId: string): Promise<any[]> {
  const response = await apiClient.get<any[]>(
    API_PATHS.PRODUCTS_PIZZA_CUSTOMIZATIONS.replace(':productId', productId),
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}

async function updatePizzaCustomizations(
  productId: string,
  pizzaCustomizationIds: string[],
): Promise<Product> {
  const response = await apiClient.put<Product>(
    API_PATHS.PRODUCTS_PIZZA_CUSTOMIZATIONS.replace(':productId', productId),
    pizzaCustomizationIds, // Enviar el array directamente
  );
  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
  return response.data;
}

async function bulkUpdatePizzaCustomizations(
  updates: Array<{ productId: string; customizationIds: string[] }>,
): Promise<void> {
  const response = await apiClient.put(
    API_PATHS.PRODUCTS_PIZZAS_CUSTOMIZATIONS_BULK,
    { updates },
  );
  if (!response.ok) {
    throw ApiError.fromApiResponse(response.data, response.status);
  }
}

export const productsService = {
  findAll,
  findOne,
  create,
  update,
  remove,
  assignModifierGroups,
  getModifierGroups,
  removeModifierGroups,
  findAllPizzas,
  // Pizza customizations methods
  getPizzaCustomizations,
  updatePizzaCustomizations,
  bulkUpdatePizzaCustomizations,
};

================
File: app/src/modules/modifiers/components/ModifierGroupFormModal.tsx
================
import React, { useEffect, useMemo } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  TextInput,
  Switch,
  HelperText,
  ActivityIndicator,
} from 'react-native-paper';
import { useForm, Controller, SubmitHandler } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { useMutation, useQueryClient } from '@tanstack/react-query';

import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { getApiErrorMessage } from '@/app/lib/errorMapping';
import { modifierGroupService } from '../services/modifierGroupService';
import {
  ModifierGroup,
  ModifierGroupFormInputs,
  modifierGroupSchema,
  createModifierGroupSchema,
  CreateModifierGroupInput,
  UpdateModifierGroupInput,
} from '../schema/modifierGroup.schema';

interface Props {
  visible: boolean;
  onDismiss: () => void;
  onSaveSuccess: () => void;
  initialData?: ModifierGroup | null;
}

const QUERY_KEY_TO_INVALIDATE = ['modifierGroups'];

const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    modalSurface: {
      padding: 0,
      margin: theme.spacing.l,
      borderRadius: theme.roundness * 2,
      elevation: 4,
      backgroundColor: theme.colors.background,
      maxHeight: '90%',
      overflow: 'hidden',
    },
    modalHeader: {
      backgroundColor: theme.colors.primary,
      paddingVertical: theme.spacing.m,
      paddingHorizontal: theme.spacing.l,
    },
    modalTitle: {
      color: theme.colors.onPrimary,
      fontWeight: '700',
      textAlign: 'center',
      fontSize: 20,
    },
    formContainer: {
      maxHeight: '100%',
    },
    scrollViewContent: {
      padding: theme.spacing.l,
      paddingBottom: theme.spacing.xl,
    },
    input: {
      marginBottom: theme.spacing.m,
      backgroundColor: theme.colors.surfaceVariant,
    },
    row: {
      flexDirection: 'row',
      marginHorizontal: -theme.spacing.xs,
      marginBottom: theme.spacing.m,
    },
    column: {
      flex: 1,
      paddingHorizontal: theme.spacing.xs,
    },
    switchComponentContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      marginBottom: theme.spacing.m,
      paddingVertical: theme.spacing.s,
    },
    switchLabel: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 16,
      flexShrink: 1,
      marginRight: theme.spacing.m,
    },
    modalActions: {
      flexDirection: 'row',
      justifyContent: 'flex-end',
      paddingVertical: theme.spacing.m,
      paddingHorizontal: theme.spacing.l,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
    },
    formButton: {
      borderRadius: theme.roundness,
      paddingHorizontal: theme.spacing.m,
    },
    cancelButton: {
      marginRight: theme.spacing.m,
    },
    loadingOverlay: {
      ...StyleSheet.absoluteFillObject,
      backgroundColor: 'rgba(0, 0, 0, 0.3)',
      justifyContent: 'center',
      alignItems: 'center',
      zIndex: 10,
      borderRadius: theme.roundness * 2,
    },
    helperText: {
      marginTop: -theme.spacing.s,
      marginBottom: theme.spacing.s,
    },
    divider: {
      marginVertical: theme.spacing.m,
      backgroundColor: theme.colors.outlineVariant,
    },
  });

const ModifierGroupFormModal: React.FC<Props> = ({
  visible,
  onDismiss,
  onSaveSuccess,
  initialData,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => getStyles(theme), [theme]);
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const isEditing = !!initialData;

  const {
    control,
    handleSubmit,
    reset,
    watch,
    formState: { errors, isSubmitting },
    // setValue, // No se usa actualmente
  } = useForm<ModifierGroupFormInputs>({
    resolver: zodResolver(modifierGroupSchema),
    defaultValues: {
      name: '',
      description: null,
      minSelections: 0,
      maxSelections: 2,
      isRequired: false,
      allowMultipleSelections: false,
      isActive: true,
      sortOrder: 0,
    },
  });

  const watchedAllowMultipleSelections = watch('allowMultipleSelections');

  useEffect(() => {
    if (visible) {
      if (initialData) {
        reset({
          name: initialData.name,
          description: initialData.description,
          minSelections: initialData.minSelections ?? 0,
          maxSelections: initialData.maxSelections ?? 1,
          isRequired: initialData.isRequired ?? false,
          allowMultipleSelections: initialData.allowMultipleSelections ?? false,
          isActive: initialData.isActive ?? true,
          sortOrder: initialData.sortOrder ?? 0,
        });
      } else {
        reset({
          name: '',
          description: null,
          minSelections: 0,
          maxSelections: 2,
          isRequired: false,
          allowMultipleSelections: false,
          isActive: true,
          sortOrder: 0,
        });
      }
    }
  }, [initialData, visible, reset]);

  const mutation = useMutation<
    ModifierGroup,
    Error,
    CreateModifierGroupInput | UpdateModifierGroupInput
  >({
    mutationFn: (data) => {
      if (isEditing && initialData) {
        return modifierGroupService.update(
          initialData.id,
          data as UpdateModifierGroupInput,
        );
      } else {
        const createData = createModifierGroupSchema.parse(
          data as ModifierGroupFormInputs,
        );
        return modifierGroupService.create(createData);
      }
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: QUERY_KEY_TO_INVALIDATE });
      showSnackbar({
        message: `Grupo "${data.name}" ${
          isEditing ? 'actualizado' : 'creado'
        } correctamente`,
        type: 'success',
      });
      onSaveSuccess();
    },
    onError: (error) => {
      const message = getApiErrorMessage(error);
      showSnackbar({ message, type: 'error' });
      // Error al guardar grupo de modificadores
    },
  });

  const onSubmit: SubmitHandler<ModifierGroupFormInputs> = (formData) => {
    mutation.mutate(formData);
  };

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalSurface}
        dismissable={!isSubmitting}
      >
        <View style={styles.formContainer}>
          <View style={styles.modalHeader}>
            <Text variant="titleLarge" style={styles.modalTitle}>
              {isEditing
                ? 'Editar Grupo de Modificadores'
                : 'Crear Nuevo Grupo'}
            </Text>
          </View>

          <ScrollView contentContainerStyle={styles.scrollViewContent}>
            <Controller
              name="name"
              control={control}
              render={({ field: { onChange, onBlur, value } }) => (
                <TextInput
                  label="Nombre *"
                  value={value}
                  onChangeText={onChange}
                  onBlur={onBlur}
                  error={!!errors.name}
                  style={styles.input}
                  disabled={isSubmitting}
                  mode="outlined"
                />
              )}
            />
            {errors.name && (
              <HelperText
                type="error"
                visible={!!errors.name}
                style={styles.helperText}
              >
                {errors.name.message}
              </HelperText>
            )}

            <Controller
              name="description"
              control={control}
              render={({ field: { onChange, onBlur, value } }) => (
                <TextInput
                  label="Descripci√≥n (Opcional)"
                  value={value ?? ''}
                  onChangeText={onChange}
                  onBlur={onBlur}
                  error={!!errors.description}
                  style={styles.input}
                  multiline
                  numberOfLines={3}
                  disabled={isSubmitting}
                  mode="outlined"
                />
              )}
            />
            {errors.description && (
              <HelperText
                type="error"
                visible={!!errors.description}
                style={styles.helperText}
              >
                {errors.description.message}
              </HelperText>
            )}

            <View style={styles.switchComponentContainer}>
              <Text style={styles.switchLabel}>
                Permitir M√∫ltiples Selecciones
              </Text>
              <Controller
                name="allowMultipleSelections"
                control={control}
                render={({ field: { onChange, value } }) => (
                  <Switch
                    value={value}
                    onValueChange={onChange}
                    disabled={isSubmitting}
                  />
                )}
              />
            </View>
            {errors.allowMultipleSelections && (
              <HelperText
                type="error"
                visible={!!errors.allowMultipleSelections}
                style={styles.helperText}
              >
                {errors.allowMultipleSelections.message}
              </HelperText>
            )}

            <View
              style={[
                styles.row,
                !watchedAllowMultipleSelections ? { opacity: 0.5 } : {},
              ]}
            >
              <View style={styles.column}>
                <Controller
                  name="minSelections"
                  control={control}
                  render={({ field: { onChange, onBlur, value } }) => (
                    <TextInput
                      label="M√≠n. Selecciones"
                      value={String(value ?? 0)}
                      onChangeText={(text) => onChange(parseInt(text, 10) || 0)}
                      onBlur={onBlur}
                      error={!!errors.minSelections}
                      style={styles.input}
                      keyboardType="numeric"
                      disabled={!watchedAllowMultipleSelections || isSubmitting}
                      mode="outlined"
                    />
                  )}
                />
                {errors.minSelections && (
                  <HelperText
                    type="error"
                    visible={!!errors.minSelections}
                    style={styles.helperText}
                  >
                    {errors.minSelections.message}
                  </HelperText>
                )}
              </View>
              <View style={styles.column}>
                <Controller
                  name="maxSelections"
                  control={control}
                  render={({ field: { onChange, onBlur, value } }) => (
                    <TextInput
                      label="M√°x. Selecciones *"
                      value={String(value ?? 1)}
                      onChangeText={(text) => onChange(parseInt(text, 10) || 1)}
                      onBlur={onBlur}
                      error={!!errors.maxSelections}
                      style={styles.input}
                      keyboardType="numeric"
                      disabled={!watchedAllowMultipleSelections || isSubmitting}
                      mode="outlined"
                    />
                  )}
                />
                {errors.maxSelections && (
                  <HelperText
                    type="error"
                    visible={!!errors.maxSelections}
                    style={styles.helperText}
                  >
                    {errors.maxSelections.message}
                  </HelperText>
                )}
              </View>
            </View>

            <View style={styles.switchComponentContainer}>
              <Text style={styles.switchLabel}>Es Requerido</Text>
              <Controller
                name="isRequired"
                control={control}
                render={({ field: { onChange, value } }) => (
                  <Switch
                    value={value}
                    onValueChange={onChange}
                    disabled={isSubmitting}
                  />
                )}
              />
            </View>
            {errors.isRequired && (
              <HelperText
                type="error"
                visible={!!errors.isRequired}
                style={styles.helperText}
              >
                {errors.isRequired.message}
              </HelperText>
            )}

            <Controller
              name="sortOrder"
              control={control}
              render={({ field: { onChange, onBlur, value } }) => (
                <TextInput
                  label="Orden de visualizaci√≥n"
                  value={String(value ?? 0)}
                  onChangeText={(text) => onChange(parseInt(text, 10) || 0)}
                  onBlur={onBlur}
                  error={!!errors.sortOrder}
                  style={styles.input}
                  keyboardType="numeric"
                  disabled={isSubmitting}
                  mode="outlined"
                />
              )}
            />
            {errors.sortOrder && (
              <HelperText
                type="error"
                visible={!!errors.sortOrder}
                style={styles.helperText}
              >
                {errors.sortOrder.message}
              </HelperText>
            )}

            <View style={styles.switchComponentContainer}>
              <Text style={styles.switchLabel}>Est√° Activo</Text>
              <Controller
                name="isActive"
                control={control}
                render={({ field: { onChange, value } }) => (
                  <Switch
                    value={value}
                    onValueChange={onChange}
                    disabled={isSubmitting}
                  />
                )}
              />
            </View>
            {errors.isActive && (
              <HelperText
                type="error"
                visible={!!errors.isActive}
                style={styles.helperText}
              >
                {errors.isActive.message}
              </HelperText>
            )}
          </ScrollView>

          {isSubmitting && (
            <View style={styles.loadingOverlay}>
              <ActivityIndicator
                animating={true}
                size="large"
                color={theme.colors.primary}
              />
            </View>
          )}

          <View style={styles.modalActions}>
            <Button
              mode="outlined"
              onPress={onDismiss}
              style={[styles.formButton, styles.cancelButton]}
              disabled={isSubmitting}
            >
              Cancelar
            </Button>
            <Button
              mode="contained"
              onPress={handleSubmit(onSubmit)}
              style={styles.formButton}
              loading={isSubmitting}
              disabled={isSubmitting}
            >
              {isEditing ? 'Actualizar' : 'Crear'}
            </Button>
          </View>
        </View>
      </Modal>
    </Portal>
  );
};

export default ModifierGroupFormModal;

================
File: app/src/modules/modifiers/hooks/useModifierGroupsQuery.ts
================
import {
  useQuery,
  type UseQueryOptions,
  type UseQueryResult,
} from '@tanstack/react-query';
import { modifierGroupService } from '../services/modifierGroupService';
import { ModifierGroup } from '../schema/modifierGroup.schema';
import { ApiError } from '@/app/lib/errors';
import { PaginatedResponse } from '@/app/types/api.types';

const modifierGroupKeys = {
  all: ['modifierGroups'] as const,
  lists: () => [...modifierGroupKeys.all, 'list'] as const,
  list: (filters: FindAllModifierGroupsQuery) =>
    [...modifierGroupKeys.lists(), filters] as const,
};

interface FindAllModifierGroupsQuery {
  page?: number;
  limit?: number;
  isActive?: boolean;
  search?: string;
}

export const useModifierGroupsQuery = (
  filters: FindAllModifierGroupsQuery = {},
  options?: Omit<
    UseQueryOptions<PaginatedResponse<ModifierGroup>, ApiError>,
    'queryKey' | 'queryFn'
  >,
): UseQueryResult<PaginatedResponse<ModifierGroup>, ApiError> => {
  const queryKey = modifierGroupKeys.list(filters);
  return useQuery<PaginatedResponse<ModifierGroup>, ApiError>({
    queryKey: queryKey,
    queryFn: () => modifierGroupService.findAll(filters),
    ...options,
  });
};

================
File: app/src/modules/orders/components/AdjustmentFormModal.tsx
================
import React, { useState, useEffect } from 'react';
import { View, StyleSheet, Platform } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  TextInput,
  HelperText,
  Chip,
  IconButton,
} from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import type {
  OrderAdjustment,
  AdjustmentFormData,
} from '../types/adjustments.types';

interface AdjustmentFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSave: (adjustment: OrderAdjustment) => void;
  adjustment?: OrderAdjustment | null;
  orderSubtotal: number;
}

export const AdjustmentFormModal: React.FC<AdjustmentFormModalProps> = ({
  visible,
  onDismiss,
  onSave,
  adjustment,
  orderSubtotal,
}) => {
  const theme = useAppTheme();

  // Estado del formulario
  const [formData, setFormData] = useState<AdjustmentFormData>({
    name: '',
    isPercentage: true,
    value: 0,
    amount: 0,
  });

  // Estados separados para los campos de texto
  const [percentageText, setPercentageText] = useState('');
  const [amountText, setAmountText] = useState('');
  const [isDiscount, setIsDiscount] = useState(false);
  const [nameWasEdited, setNameWasEdited] = useState(false);

  const [errors, setErrors] = useState<{
    name?: string;
    value?: string;
    amount?: string;
  }>({});

  // Inicializar formulario cuando se abre o cambia el ajuste
  useEffect(() => {
    if (visible) {
      if (adjustment) {
        setFormData({
          name: adjustment.name,
          isPercentage: adjustment.isPercentage,
          value: adjustment.value || 0,
          amount: adjustment.amount || 0,
        });
        setPercentageText(Math.abs(adjustment.value || 0).toString());
        setAmountText(Math.abs(adjustment.amount || 0).toString());
        setIsDiscount((adjustment.value || adjustment.amount || 0) < 0);
        setNameWasEdited(true); // Si es edici√≥n, asumimos que el nombre fue editado
      } else {
        setFormData({
          name: 'Cargo adicional', // Por defecto cargo
          isPercentage: true,
          value: 0,
          amount: 0,
        });
        setPercentageText('');
        setAmountText('');
        setIsDiscount(false);
        setNameWasEdited(false);
      }
      setErrors({});
    }
  }, [visible, adjustment]);

  // Calcular el monto cuando cambia el valor o tipo
  useEffect(() => {
    if (formData.isPercentage && formData.value !== undefined) {
      const calculatedAmount = (orderSubtotal * formData.value) / 100;
      setFormData((prev) => ({ ...prev, amount: calculatedAmount }));
    }
  }, [formData.isPercentage, formData.value, orderSubtotal]);

  const handleTypeChange = (isPercentage: boolean) => {
    setFormData((prev) => ({
      ...prev,
      isPercentage,
      value: isPercentage ? 0 : undefined,
      amount: isPercentage ? 0 : prev.amount,
    }));
    if (isPercentage) {
      setPercentageText('');
    } else {
      setAmountText('');
    }
  };

  const validateForm = (): boolean => {
    const newErrors: typeof errors = {};

    if (!formData.name.trim()) {
      newErrors.name = 'El nombre es requerido';
    }

    if (formData.isPercentage) {
      if (formData.value === undefined || formData.value === null) {
        newErrors.value = 'El porcentaje es requerido';
      } else if (formData.value === 0) {
        newErrors.value = 'El porcentaje no puede ser 0';
      } else if (formData.value < -100 || formData.value > 100) {
        newErrors.value = 'El porcentaje debe estar entre -100 y 100';
      }
    } else {
      if (formData.amount === undefined || formData.amount === null) {
        newErrors.amount = 'El monto es requerido';
      } else if (formData.amount === 0) {
        newErrors.amount = 'El monto no puede ser 0';
      }
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSave = () => {
    if (!validateForm()) return;

    const adjustmentData: OrderAdjustment = {
      id: adjustment?.id || undefined,
      name: formData.name.trim(),
      isPercentage: formData.isPercentage,
      value: formData.isPercentage ? formData.value : undefined,
      amount: formData.amount,
      isNew: !adjustment?.id,
    };

    onSave(adjustmentData);
    onDismiss();
  };

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={[
          styles.modal,
          { backgroundColor: theme.colors.surface },
        ]}
      >
        {/* Header simplificado */}
        <View
          style={[styles.header, { backgroundColor: theme.colors.primary }]}
        >
          <Text
            variant="titleLarge"
            style={[styles.title, { color: theme.colors.onPrimary }]}
          >
            {adjustment ? 'Editar Ajuste' : 'Nuevo Ajuste'}
          </Text>
          <IconButton
            icon="close"
            size={20}
            onPress={onDismiss}
            style={styles.closeButton}
            iconColor={theme.colors.onPrimary}
          />
        </View>

        {/* Contenido */}
        <View style={styles.content}>
          {/* Nombre del ajuste */}
          <TextInput
            label="Nombre"
            value={formData.name}
            onChangeText={(text) => {
              setFormData((prev) => ({ ...prev, name: text }));
              // Detectar si el usuario edit√≥ manualmente el nombre
              setNameWasEdited(
                text !== 'Descuento' && text !== 'Cargo adicional',
              );
            }}
            mode="outlined"
            error={!!errors.name}
            placeholder="Ej: Descuento especial"
            style={styles.input}
          />
          {errors.name && (
            <HelperText type="error" visible={true}>
              {errors.name}
            </HelperText>
          )}

          {/* Tipo de ajuste con chips */}
          <View style={styles.typeContainer}>
            <Text
              variant="labelLarge"
              style={[styles.label, { color: theme.colors.onSurface }]}
            >
              Tipo de ajuste
            </Text>
            <View style={styles.chipGroup}>
              <Chip
                mode={formData.isPercentage ? 'flat' : 'outlined'}
                onPress={() => handleTypeChange(true)}
                selected={formData.isPercentage}
                style={[
                  styles.chip,
                  formData.isPercentage && {
                    backgroundColor: theme.colors.primaryContainer,
                  },
                ]}
                textStyle={
                  formData.isPercentage && {
                    color: theme.colors.onPrimaryContainer,
                  }
                }
              >
                Porcentaje
              </Chip>
              <Chip
                mode={!formData.isPercentage ? 'flat' : 'outlined'}
                onPress={() => handleTypeChange(false)}
                selected={!formData.isPercentage}
                style={[
                  styles.chip,
                  !formData.isPercentage && {
                    backgroundColor: theme.colors.primaryContainer,
                  },
                ]}
                textStyle={
                  !formData.isPercentage && {
                    color: theme.colors.onPrimaryContainer,
                  }
                }
              >
                Monto fijo
              </Chip>
            </View>
          </View>

          {/* Tipo de operaci√≥n (descuento o cargo) */}
          <View style={styles.operationContainer}>
            <Text
              variant="labelLarge"
              style={[styles.label, { color: theme.colors.onSurface }]}
            >
              Tipo de operaci√≥n
            </Text>
            <View style={styles.operationButtons}>
              <Button
                mode={isDiscount ? 'contained' : 'outlined'}
                onPress={() => {
                  setIsDiscount(true);
                  // Siempre actualizar el nombre si no fue editado manualmente
                  if (!nameWasEdited) {
                    setFormData((prev) => ({ ...prev, name: 'Descuento' }));
                  }
                  if (formData.isPercentage) {
                    const absValue = Math.abs(parseFloat(percentageText) || 0);
                    setFormData((prev) => ({ ...prev, value: -absValue }));
                  } else {
                    const absValue = Math.abs(parseFloat(amountText) || 0);
                    setFormData((prev) => ({ ...prev, amount: -absValue }));
                  }
                }}
                style={[
                  styles.operationButton,
                  isDiscount && {
                    backgroundColor: theme.colors.errorContainer,
                    borderColor: theme.colors.error,
                  },
                ]}
                labelStyle={{
                  color: isDiscount
                    ? theme.colors.onErrorContainer
                    : theme.colors.error,
                }}
                icon="minus"
              >
                Descuento
              </Button>
              <Button
                mode={!isDiscount ? 'contained' : 'outlined'}
                onPress={() => {
                  setIsDiscount(false);
                  // Siempre actualizar el nombre si no fue editado manualmente
                  if (!nameWasEdited) {
                    setFormData((prev) => ({
                      ...prev,
                      name: 'Cargo adicional',
                    }));
                  }
                  if (formData.isPercentage) {
                    const absValue = Math.abs(parseFloat(percentageText) || 0);
                    setFormData((prev) => ({ ...prev, value: absValue }));
                  } else {
                    const absValue = Math.abs(parseFloat(amountText) || 0);
                    setFormData((prev) => ({ ...prev, amount: absValue }));
                  }
                }}
                style={[
                  styles.operationButton,
                  !isDiscount && {
                    backgroundColor: theme.colors.primaryContainer,
                    borderColor: theme.colors.primary,
                  },
                ]}
                labelStyle={{
                  color: !isDiscount
                    ? theme.colors.onPrimaryContainer
                    : theme.colors.primary,
                }}
                icon="plus"
              >
                Cargo
              </Button>
            </View>
          </View>

          {/* Campo de valor */}
          {formData.isPercentage ? (
            <TextInput
              label="Porcentaje"
              value={percentageText}
              onChangeText={(text) => {
                // Solo permitir n√∫meros positivos
                const regex = /^\d*\.?\d*$/;
                if (regex.test(text) || text === '') {
                  setPercentageText(text);
                  const value = parseFloat(text) || 0;
                  setFormData((prev) => ({
                    ...prev,
                    value: isDiscount ? -value : value,
                  }));
                }
              }}
              mode="outlined"
              keyboardType="numeric"
              error={!!errors.value}
              right={<TextInput.Affix text="%" />}
              style={styles.input}
            />
          ) : (
            <TextInput
              label="Monto"
              value={amountText}
              onChangeText={(text) => {
                // Solo permitir n√∫meros positivos
                const regex = /^\d*\.?\d*$/;
                if (regex.test(text) || text === '') {
                  setAmountText(text);
                  const amount = parseFloat(text) || 0;
                  setFormData((prev) => ({
                    ...prev,
                    amount: isDiscount ? -amount : amount,
                  }));
                }
              }}
              mode="outlined"
              keyboardType="numeric"
              error={!!errors.amount}
              left={<TextInput.Affix text="$" />}
              style={styles.input}
            />
          )}
          {(errors.value || errors.amount) && (
            <HelperText type="error" visible={true}>
              {errors.value || errors.amount}
            </HelperText>
          )}
        </View>

        {/* Botones de acci√≥n */}
        <View
          style={[
            styles.actions,
            { borderTopColor: theme.colors.outlineVariant },
          ]}
        >
          <Button
            mode="outlined"
            onPress={onDismiss}
            style={[
              styles.actionButton,
              {
                borderColor: theme.colors.outline,
                backgroundColor: theme.colors.secondaryContainer,
              },
            ]}
            textColor={theme.colors.onSecondaryContainer}
          >
            Cancelar
          </Button>
          <Button
            mode="contained"
            onPress={handleSave}
            style={[styles.actionButton, styles.saveButton]}
            buttonColor={theme.colors.primary}
          >
            {adjustment ? 'Actualizar' : 'Guardar'}
          </Button>
        </View>
      </Modal>
    </Portal>
  );
};

const styles = StyleSheet.create({
  modal: {
    borderRadius: 16,
    margin: 20,
    maxWidth: 400,
    width: '90%',
    maxHeight: '80%',
    alignSelf: 'center',
    elevation: 5,
    ...Platform.select({
      web: {
        boxShadow: '0px 2px 3.84px rgba(0, 0, 0, 0.25)',
      },
      default: {
        shadowColor: '#000',
        shadowOffset: {
          width: 0,
          height: 2,
        },
        shadowOpacity: 0.25,
        shadowRadius: 3.84,
      },
    }),
    overflow: 'hidden',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingVertical: 12,
    minHeight: 48,
  },
  title: {
    flex: 1,
    fontWeight: '500',
  },
  closeButton: {
    margin: -4,
  },
  content: {
    paddingHorizontal: 20,
    paddingTop: 20,
    paddingBottom: 16,
  },
  input: {
    marginBottom: 16,
  },
  typeContainer: {
    marginBottom: 16,
  },
  label: {
    marginBottom: 8,
    fontWeight: '500',
  },
  chipGroup: {
    flexDirection: 'row',
    gap: 12,
  },
  chip: {
    flex: 1,
  },
  operationContainer: {
    marginBottom: 16,
  },
  operationButtons: {
    flexDirection: 'row',
    gap: 12,
    marginTop: 8,
  },
  operationButton: {
    flex: 1,
  },
  actions: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingVertical: 16,
    borderTopWidth: 1,
    gap: 12,
  },
  actionButton: {
    minWidth: 100,
  },
  saveButton: {
    marginLeft: 4,
  },
});

================
File: app/src/modules/orders/components/PizzaCustomizationSection.tsx
================
import React, { useState, useMemo, useCallback, memo } from 'react';
import { View, StyleSheet, TouchableOpacity } from 'react-native';
import {
  Text,
  Checkbox,
  Card,
  ActivityIndicator,
  Surface,
  Switch,
  IconButton,
  TouchableRipple,
  RadioButton,
} from 'react-native-paper';
import type { SelectedPizzaCustomization } from '@/app/schemas/domain/order.schema';
import type {
  PizzaCustomization,
  PizzaConfiguration,
} from '@/modules/pizzaCustomizations/types/pizzaCustomization.types';
import {
  PizzaHalf,
  CustomizationAction,
  CustomizationType,
} from '@/modules/pizzaCustomizations/types/pizzaCustomization.types';
import { useAppTheme } from '@/app/styles/theme';

interface PizzaCustomizationSectionProps {
  pizzaCustomizations: PizzaCustomization[];
  pizzaConfiguration: PizzaConfiguration | null;
  selectedPizzaCustomizations: SelectedPizzaCustomization[];
  onCustomizationChange: (customizations: SelectedPizzaCustomization[]) => void;
  loading?: boolean;
}

interface FlavorItemProps {
  flavor: PizzaCustomization;
  isSelected: boolean;
  isDisabled: boolean;
  onToggle: (flavorId: string) => void;
  styles: any;
  theme: any;
}

const FlavorItem = memo<FlavorItemProps>(
  ({ flavor, isSelected, isDisabled, onToggle, styles, theme }) => (
    <Surface
      style={[
        styles.flavorChip,
        isSelected && styles.flavorChipSelected,
        isDisabled && styles.flavorChipDisabled,
      ]}
      elevation={isSelected ? 2 : 0}
    >
      <TouchableRipple
        onPress={() => !isDisabled && onToggle(flavor.id)}
        disabled={isDisabled}
        style={{
          paddingVertical: 12,
          paddingHorizontal: 16,
          borderRadius: 8,
        }}
      >
        <View style={{ flexDirection: 'row', alignItems: 'center' }}>
          <RadioButton
            value={flavor.id}
            status={isSelected ? 'checked' : 'unchecked'}
            disabled={isDisabled}
            onPress={() => !isDisabled && onToggle(flavor.id)}
          />
          <View style={{ flex: 1, marginLeft: 8 }}>
            <View
              style={{
                flexDirection: 'row',
                alignItems: 'center',
                gap: 8,
              }}
            >
              <Text
                style={[
                  styles.flavorLabel,
                  isDisabled && styles.flavorLabelDisabled,
                ]}
              >
                {flavor.name}
              </Text>
              <Text
                style={[
                  styles.toppingValue,
                  isDisabled && styles.flavorLabelDisabled,
                ]}
              >
                ({flavor.toppingValue})
              </Text>
            </View>
            {flavor.ingredients && (
              <Text
                style={[
                  styles.ingredientsText,
                  isDisabled && styles.flavorLabelDisabled,
                ]}
              >
                {flavor.ingredients}
              </Text>
            )}
          </View>
        </View>
      </TouchableRipple>
    </Surface>
  ),
);

const PizzaCustomizationSection = memo<PizzaCustomizationSectionProps>(
  ({
    pizzaCustomizations,
    pizzaConfiguration,
    selectedPizzaCustomizations,
    onCustomizationChange,
    loading = false,
  }) => {
    const theme = useAppTheme();
    const styles = useMemo(() => createStyles(theme), [theme]);
    const [manualHalvesMode, setManualHalvesMode] = useState(false);
    const [expandedIngredients, setExpandedIngredients] = useState<{
      full: boolean;
      half1: boolean;
      half2: boolean;
    }>({
      full: false,
      half1: false,
      half2: false,
    });
    const [expandedFlavors, setExpandedFlavors] = useState(true);

    // Separar sabores e ingredientes
    const flavors = useMemo(
      () =>
        pizzaCustomizations.filter((c) => c.type === CustomizationType.FLAVOR),
      [pizzaCustomizations],
    );

    const ingredients = useMemo(
      () =>
        pizzaCustomizations.filter(
          (c) => c.type === CustomizationType.INGREDIENT,
        ),
      [pizzaCustomizations],
    );

    // Obtener sabores seleccionados
    const selectedFlavors = useMemo(
      () =>
        selectedPizzaCustomizations.filter(
          (sc) =>
            sc.action === CustomizationAction.ADD &&
            flavors.some((f) => f.id === sc.pizzaCustomizationId),
        ),
      [selectedPizzaCustomizations, flavors],
    );

    // Obtener el nombre del sabor por ID
    const getFlavorName = useCallback(
      (flavorId: string) => {
        const flavor = flavors.find((f) => f.id === flavorId);
        return flavor?.name || '';
      },
      [flavors],
    );

    const handleFlavorToggle = useCallback(
      (flavorId: string) => {
        const isSelected = selectedPizzaCustomizations.some(
          (sc) =>
            sc.pizzaCustomizationId === flavorId &&
            sc.action === CustomizationAction.ADD,
        );

        if (isSelected) {
          // Deseleccionar
          const remainingFlavorSelections = selectedPizzaCustomizations.filter(
            (sc) =>
              !(
                sc.pizzaCustomizationId === flavorId &&
                sc.action === CustomizationAction.ADD
              ),
          );

          // Si queda solo un sabor despu√©s de deseleccionar, cambiar su half a FULL
          const remainingFlavors = remainingFlavorSelections.filter(
            (sc) =>
              sc.action === CustomizationAction.ADD &&
              flavors.some((f) => f.id === sc.pizzaCustomizationId),
          );

          if (remainingFlavors.length === 1) {
            const otherFlavorId = remainingFlavors[0].pizzaCustomizationId;
            const nonFlavorSelections = remainingFlavorSelections.filter(
              (sc) =>
                !flavors.some((f) => f.id === sc.pizzaCustomizationId) ||
                sc.action !== CustomizationAction.ADD,
            );

            onCustomizationChange([
              ...nonFlavorSelections,
              {
                pizzaCustomizationId: otherFlavorId,
                half: PizzaHalf.FULL,
                action: CustomizationAction.ADD,
              },
            ]);
          } else {
            onCustomizationChange(remainingFlavorSelections);
          }
        } else {
          // Seleccionar
          const currentFlavors = selectedPizzaCustomizations.filter(
            (sc) =>
              sc.action === CustomizationAction.ADD &&
              flavors.some((f) => f.id === sc.pizzaCustomizationId),
          );

          if (currentFlavors.length >= 2) {
            return; // No permitir m√°s de 2
          }

          const nonFlavorSelections = selectedPizzaCustomizations.filter(
            (sc) =>
              !flavors.some((f) => f.id === sc.pizzaCustomizationId) ||
              sc.action !== CustomizationAction.ADD,
          );

          if (currentFlavors.length === 0) {
            // Primer sabor - va completo o a mitad 1 si est√° el modo manual
            if (manualHalvesMode) {
              onCustomizationChange([
                ...nonFlavorSelections,
                {
                  pizzaCustomizationId: flavorId,
                  half: PizzaHalf.HALF_1,
                  action: CustomizationAction.ADD,
                },
              ]);
            } else {
              onCustomizationChange([
                ...nonFlavorSelections,
                {
                  pizzaCustomizationId: flavorId,
                  half: PizzaHalf.FULL,
                  action: CustomizationAction.ADD,
                },
              ]);
            }
          } else if (currentFlavors.length === 1) {
            // Segundo sabor - convertir a mitades
            const existingFlavor = currentFlavors[0];

            // Cambiar el sabor existente a mitad 1
            nonFlavorSelections.push({
              pizzaCustomizationId: existingFlavor.pizzaCustomizationId,
              half: PizzaHalf.HALF_1,
              action: CustomizationAction.ADD,
            });

            // Agregar el nuevo sabor a mitad 2
            nonFlavorSelections.push({
              pizzaCustomizationId: flavorId,
              half: PizzaHalf.HALF_2,
              action: CustomizationAction.ADD,
            });

            onCustomizationChange(nonFlavorSelections);
          }
        }
      },
      [
        selectedPizzaCustomizations,
        flavors,
        onCustomizationChange,
        manualHalvesMode,
      ],
    );

    const toggleIngredient = useCallback(
      (ingredientId: string, half: PizzaHalf, action: CustomizationAction) => {
        const existingIndex = selectedPizzaCustomizations.findIndex(
          (sc) =>
            sc.pizzaCustomizationId === ingredientId &&
            sc.half === half &&
            sc.action === action,
        );

        let newSelections: SelectedPizzaCustomization[];

        if (existingIndex >= 0) {
          newSelections = selectedPizzaCustomizations.filter(
            (_, index) => index !== existingIndex,
          );
        } else {
          // Remover cualquier acci√≥n previa del mismo ingrediente en la misma mitad
          newSelections = selectedPizzaCustomizations.filter(
            (sc) =>
              !(sc.pizzaCustomizationId === ingredientId && sc.half === half),
          );

          newSelections.push({
            pizzaCustomizationId: ingredientId,
            half,
            action,
          });
        }

        onCustomizationChange(newSelections);
      },
      [selectedPizzaCustomizations, onCustomizationChange],
    );

    const isIngredientSelected = useCallback(
      (
        ingredientId: string,
        half: PizzaHalf,
        action: CustomizationAction,
      ): boolean => {
        return selectedPizzaCustomizations.some(
          (sc) =>
            sc.pizzaCustomizationId === ingredientId &&
            sc.half === half &&
            sc.action === action,
        );
      },
      [selectedPizzaCustomizations],
    );

    // Determinar si mostrar modo mitades (2 sabores o modo manual activado)
    const showHalvesMode =
      selectedFlavors.length === 2 ||
      (manualHalvesMode && selectedFlavors.length <= 1);

    // Returns condicionales al final, despu√©s de todos los hooks
    if (loading) {
      return (
        <View style={styles.loadingContainer}>
          <ActivityIndicator animating size="large" />
          <Text style={styles.loadingText}>Cargando opciones de pizza...</Text>
        </View>
      );
    }

    if (!pizzaConfiguration || pizzaCustomizations.length === 0) {
      return null;
    }

    // Renderizar secci√≥n de personalizaci√≥n
    const renderCustomizationSection = (
      half: PizzaHalf,
      sectionTitle: string,
      flavorName?: string,
    ) => {
      const sectionKey =
        half === PizzaHalf.FULL
          ? 'full'
          : half === PizzaHalf.HALF_1
            ? 'half1'
            : 'half2';
      const isExpanded = expandedIngredients[sectionKey];

      // Construir el t√≠tulo din√°mico con el formato completo
      const getDynamicTitle = () => {
        const customizationsForHalf = selectedPizzaCustomizations.filter(
          (sc) => sc.half === half,
        );

        const parts: string[] = [];

        // Agregar el sabor si existe
        if (flavorName) {
          parts.push(flavorName);
        } else if (half !== PizzaHalf.FULL) {
          // Para mitades sin sabor
          parts.push('Sin sabor');
        }

        // Filtrar ingredientes
        const addedIngredients: string[] = [];
        const removedIngredients: string[] = [];

        customizationsForHalf.forEach((sc) => {
          const customization = ingredients.find(
            (c) => c.id === sc.pizzaCustomizationId,
          );
          if (customization) {
            if (sc.action === CustomizationAction.ADD) {
              addedIngredients.push(customization.name);
            } else {
              removedIngredients.push(customization.name);
            }
          }
        });

        if (addedIngredients.length > 0) {
          parts.push(`con: ${addedIngredients.join(', ')}`);
        }
        if (removedIngredients.length > 0) {
          parts.push(`sin: ${removedIngredients.join(', ')}`);
        }

        return parts.length > 0
          ? parts.join(' - ')
          : flavorName || 'Sin personalizar';
      };

      return (
        <Card style={styles.optionCard}>
          <Card.Content style={{ paddingVertical: 16, paddingHorizontal: 16 }}>
            <View style={styles.sectionHeader}>
              <Text style={styles.sectionTitle}>
                {sectionTitle}:{' '}
                <Text style={styles.pizzaFormat}>{getDynamicTitle()}</Text>
              </Text>
            </View>

            <Surface style={styles.subsectionSurface} elevation={1}>
              <TouchableRipple
                onPress={() =>
                  setExpandedIngredients((prev) => ({
                    ...prev,
                    [sectionKey]: !prev[sectionKey],
                  }))
                }
                style={{ paddingVertical: 12, paddingHorizontal: 16 }}
              >
                <View style={styles.subsectionHeader}>
                  <Text style={styles.subsectionTitle}>
                    Personalizar Ingredientes
                  </Text>
                  <IconButton
                    icon={isExpanded ? 'chevron-up' : 'chevron-down'}
                    size={20}
                    style={{ margin: -8 }}
                  />
                </View>
              </TouchableRipple>

              {isExpanded && (
                <View style={{ paddingHorizontal: 16, paddingBottom: 12 }}>
                  {ingredients.map((ingredient) => {
                    const isAddSelected = isIngredientSelected(
                      ingredient.id,
                      half,
                      CustomizationAction.ADD,
                    );
                    const isRemoveSelected = isIngredientSelected(
                      ingredient.id,
                      half,
                      CustomizationAction.REMOVE,
                    );
                    const isSelected = isAddSelected || isRemoveSelected;
                    const currentAction = isAddSelected
                      ? CustomizationAction.ADD
                      : CustomizationAction.REMOVE;

                    return (
                      <Surface
                        key={ingredient.id}
                        style={styles.ingredientItem}
                        elevation={0}
                      >
                        <TouchableRipple
                          onPress={() => {
                            if (isSelected) {
                              toggleIngredient(
                                ingredient.id,
                                half,
                                currentAction,
                              );
                            } else {
                              toggleIngredient(
                                ingredient.id,
                                half,
                                CustomizationAction.ADD,
                              );
                            }
                          }}
                          style={{ paddingVertical: 8, paddingHorizontal: 8 }}
                        >
                          <View
                            style={{
                              flexDirection: 'row',
                              alignItems: 'center',
                            }}
                          >
                            <View style={{ flex: 1 }}>
                              <View
                                style={{
                                  flexDirection: 'row',
                                  alignItems: 'center',
                                  gap: 6,
                                }}
                              >
                                <Text style={styles.ingredientLabel}>
                                  {ingredient.name}
                                </Text>
                                <Text style={styles.toppingValueSmall}>
                                  ({ingredient.toppingValue})
                                </Text>
                              </View>
                            </View>
                            {isSelected && (
                              <View style={styles.actionToggle}>
                                <Text
                                  style={[
                                    styles.toggleLabel,
                                    currentAction === CustomizationAction.ADD &&
                                      styles.activeLabel,
                                  ]}
                                >
                                  Agregar
                                </Text>
                                <Switch
                                  value={
                                    currentAction === CustomizationAction.REMOVE
                                  }
                                  onValueChange={(value) => {
                                    const newAction = value
                                      ? CustomizationAction.REMOVE
                                      : CustomizationAction.ADD;
                                    toggleIngredient(
                                      ingredient.id,
                                      half,
                                      newAction,
                                    );
                                  }}
                                  style={styles.switch}
                                />
                                <Text
                                  style={[
                                    styles.toggleLabel,
                                    currentAction ===
                                      CustomizationAction.REMOVE &&
                                      styles.activeLabel,
                                  ]}
                                >
                                  Quitar
                                </Text>
                              </View>
                            )}
                            <RadioButton
                              value={ingredient.id}
                              status={isSelected ? 'checked' : 'unchecked'}
                              onPress={() => {
                                if (isSelected) {
                                  toggleIngredient(
                                    ingredient.id,
                                    half,
                                    currentAction,
                                  );
                                } else {
                                  toggleIngredient(
                                    ingredient.id,
                                    half,
                                    CustomizationAction.ADD,
                                  );
                                }
                              }}
                            />
                          </View>
                        </TouchableRipple>
                      </Surface>
                    );
                  })}
                </View>
              )}
            </Surface>
          </Card.Content>
        </Card>
      );
    };

    return (
      <View style={styles.container}>
        {/* Selecci√≥n de Sabores */}
        <Card style={styles.optionCard}>
          <Card.Content style={{ paddingVertical: 16, paddingHorizontal: 16 }}>
            <TouchableRipple
              onPress={() => setExpandedFlavors(!expandedFlavors)}
              style={{ marginBottom: expandedFlavors ? 12 : 0 }}
            >
              <View style={styles.sectionHeaderWithSwitch}>
                <View style={{ flex: 1 }}>
                  <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                    <Text style={styles.sectionTitle}>
                      Sabores
                      {selectedFlavors.length > 0 && (
                        <Text style={styles.pizzaFormat}>
                          {' - '}
                          {selectedFlavors
                            .map((sf) => {
                              const flavor = flavors.find(
                                (f) => f.id === sf.pizzaCustomizationId,
                              );
                              return flavor?.name || '';
                            })
                            .join(' / ')}
                        </Text>
                      )}
                    </Text>
                    <IconButton
                      icon={expandedFlavors ? 'chevron-up' : 'chevron-down'}
                      size={20}
                      style={{ margin: -8 }}
                    />
                  </View>
                  {expandedFlavors && (
                    <Text style={styles.helperText}>
                      Selecciona hasta 2 sabores
                    </Text>
                  )}
                </View>
                {expandedFlavors && selectedFlavors.length <= 1 && (
                  <View style={styles.halvesSwitch}>
                    <Text style={styles.switchLabel}>Dividir mitades</Text>
                    <Switch
                      value={manualHalvesMode}
                      onValueChange={(value) => {
                        setManualHalvesMode(value);

                        // Si se activa el modo mitades, convertir las personalizaciones de FULL a HALF_1
                        if (value && selectedFlavors.length <= 1) {
                          const updatedCustomizations =
                            selectedPizzaCustomizations.map((sc) => {
                              if (sc.half === PizzaHalf.FULL) {
                                return { ...sc, half: PizzaHalf.HALF_1 };
                              }
                              return sc;
                            });
                          onCustomizationChange(updatedCustomizations);
                        }
                        // Si se desactiva el modo mitades y solo hay un sabor, convertir todo a FULL
                        else if (!value && selectedFlavors.length === 1) {
                          const updatedCustomizations =
                            selectedPizzaCustomizations.map((sc) => {
                              if (
                                sc.half === PizzaHalf.HALF_1 ||
                                sc.half === PizzaHalf.HALF_2
                              ) {
                                return { ...sc, half: PizzaHalf.FULL };
                              }
                              return sc;
                            });
                          onCustomizationChange(updatedCustomizations);
                        }
                      }}
                    />
                  </View>
                )}
              </View>
            </TouchableRipple>
            {expandedFlavors && (
              <View style={styles.flavorsGrid}>
                {flavors.map((flavor) => {
                  const isSelected = selectedFlavors.some(
                    (sf) => sf.pizzaCustomizationId === flavor.id,
                  );
                  const isDisabled = selectedFlavors.length >= 2 && !isSelected;

                  return (
                    <FlavorItem
                      key={flavor.id}
                      flavor={flavor}
                      isSelected={isSelected}
                      isDisabled={isDisabled}
                      onToggle={handleFlavorToggle}
                      styles={styles}
                      theme={theme}
                    />
                  );
                })}
              </View>
            )}
          </Card.Content>
        </Card>

        {/* Secciones de Personalizaci√≥n */}
        {showHalvesMode ? (
          // Modo mitades (2 sabores o modo manual)
          <>
            {renderCustomizationSection(
              PizzaHalf.HALF_1,
              'Mitad 1',
              selectedFlavors[0]
                ? getFlavorName(selectedFlavors[0].pizzaCustomizationId)
                : undefined,
            )}
            {renderCustomizationSection(
              PizzaHalf.HALF_2,
              'Mitad 2',
              selectedFlavors[1]
                ? getFlavorName(selectedFlavors[1].pizzaCustomizationId)
                : undefined,
            )}
          </>
        ) : (
          // Modo completo (sin sabores o 1 sabor)
          renderCustomizationSection(
            PizzaHalf.FULL,
            'Pizza Completa',
            selectedFlavors[0]
              ? getFlavorName(selectedFlavors[0].pizzaCustomizationId)
              : undefined,
          )
        )}
      </View>
    );
  },
);

const createStyles = (theme: any) =>
  StyleSheet.create({
    container: {
      gap: 8,
    },
    loadingContainer: {
      padding: 32,
      alignItems: 'center',
    },
    loadingText: {
      marginTop: 16,
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    optionCard: {
      backgroundColor: theme.colors.surface,
      borderRadius: 12,
      elevation: 1,
    },
    pizzaFormat: {
      fontSize: 16,
      fontWeight: 'normal',
      color: theme.colors.primary,
    },
    sectionHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 12,
    },
    sectionHeaderWithSwitch: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
    },
    halvesSwitch: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 8,
    },
    switchLabel: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    sectionTitle: {
      fontSize: 18,
      fontWeight: 'bold',
      color: theme.colors.onSurface,
    },
    flavorInline: {
      fontSize: 16,
      fontWeight: 'normal',
      color: theme.colors.primary,
    },
    helperText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 12,
    },
    flavorsGrid: {
      gap: 8,
    },
    flavorChip: {
      backgroundColor: theme.colors.surface,
      borderRadius: 8,
      borderWidth: 1,
      borderColor: theme.colors.outline,
      elevation: 0,
      overflow: 'hidden',
    },
    flavorChipSelected: {
      backgroundColor: theme.colors.primaryContainer,
      borderColor: theme.colors.primary,
    },
    flavorChipDisabled: {
      opacity: 0.5,
    },
    flavorLabel: {
      fontSize: 14,
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    flavorLabelDisabled: {
      color: theme.colors.onSurfaceDisabled,
    },
    ingredientsText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
    },
    toppingValue: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      opacity: 0.6,
    },
    toppingValueSmall: {
      fontSize: 11,
      color: theme.colors.onSurfaceVariant,
      opacity: 0.5,
    },
    subsectionSurface: {
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: 8,
      marginTop: 8,
    },
    subsectionHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    subsectionTitle: {
      fontSize: 16,
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    ingredientItem: {
      backgroundColor: 'transparent',
      marginTop: 4,
    },
    ingredientLabel: {
      fontSize: 14,
      color: theme.colors.onSurface,
    },
    actionToggle: {
      flexDirection: 'row',
      alignItems: 'center',
      marginRight: 8,
    },
    toggleLabel: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
      fontWeight: '500',
    },
    activeLabel: {
      color: theme.colors.primary,
      fontWeight: 'bold',
    },
    switch: {
      marginHorizontal: 8,
      transform: [{ scale: 1.2 }],
    },
    priceInfoText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
  });

PizzaCustomizationSection.displayName = 'PizzaCustomizationSection';

export default PizzaCustomizationSection;

================
File: app/src/modules/orders/components/PrinterSelectionModal.tsx
================
import React, { useMemo } from 'react';
import { StyleSheet, FlatList, ListRenderItemInfo } from 'react-native';
import { Modal, Portal, List, Divider, Appbar } from 'react-native-paper';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { usePrintersQuery } from '../../printers/hooks/usePrintersQueries';
import type { ThermalPrinter } from '../../printers/types/printer.types';
import { useListState } from '../../../app/hooks/useListState';

interface PrinterSelectionModalProps {
  visible: boolean;
  onDismiss: () => void;
  onPrinterSelect: (printer: ThermalPrinter) => void;
  title?: string;
}

const PrinterSelectionModal: React.FC<PrinterSelectionModalProps> = ({
  visible,
  onDismiss,
  onPrinterSelect,
  title = 'Seleccionar Impresora',
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);

  const {
    data: printersResponse,
    isLoading,
    isError,
    error: _error,
    refetch: _refetch,
  } = usePrintersQuery(
    { isActive: true, limit: 100, page: 1 },
    { enabled: visible },
  );

  const printers = useMemo(
    () => printersResponse?.data ?? [],
    [printersResponse],
  );

  const renderPrinterItem = ({ item }: ListRenderItemInfo<ThermalPrinter>) => (
    <List.Item
      title={item.name}
      description={`Tipo: ${item.connectionType}${item.ipAddress ? ` - IP: ${item.ipAddress}` : ''}`}
      left={(props) => <List.Icon {...props} icon="printer" />}
      onPress={() => onPrinterSelect(item)}
      style={styles.listItem}
      titleStyle={styles.itemTitle}
      descriptionStyle={styles.itemDescription}
    />
  );

  const { ListEmptyComponent } = useListState({
    isLoading,
    isError,
    data: printers,
    emptyConfig: {
      title: 'No hay impresoras activas',
      message: 'No hay impresoras activas configuradas.',
      icon: 'printer-off',
    },
  });

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalContent}
      >
        <Appbar.Header style={styles.appBar} elevated>
          <Appbar.BackAction
            onPress={onDismiss}
            color={theme.colors.onSurface}
          />
          <Appbar.Content title={title} titleStyle={styles.appBarTitle} />
        </Appbar.Header>

        <FlatList
          data={printers}
          renderItem={renderPrinterItem}
          keyExtractor={(item: ThermalPrinter) => item.id}
          ItemSeparatorComponent={() => <Divider style={styles.divider} />}
          contentContainerStyle={styles.listContentContainer}
          ListEmptyComponent={ListEmptyComponent}
        />
      </Modal>
    </Portal>
  );
};

// --- Estilos ---
const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    modalContent: {
      backgroundColor: theme.colors.background,
      width: '90%',
      maxHeight: '70%',
      alignSelf: 'center',
      borderRadius: theme.roundness * 2,
      elevation: 5,
      overflow: 'hidden',
      display: 'flex',
      flexDirection: 'column',
    },
    appBar: {
      backgroundColor: theme.colors.elevation.level2,
    },
    appBarTitle: {
      ...theme.fonts.titleMedium,
      color: theme.colors.onSurface,
      fontWeight: 'bold',
    },
    listContentContainer: {
      paddingBottom: theme.spacing.m,
    },
    centeredView: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.l,
      minHeight: 150,
    },
    statusText: {
      marginTop: theme.spacing.m,
      fontSize: 16,
      textAlign: 'center',
      color: theme.colors.onSurfaceVariant,
    },
    errorText: {
      marginTop: theme.spacing.m,
      color: theme.colors.error,
      textAlign: 'center',
      marginBottom: theme.spacing.m,
    },
    listItem: {
      backgroundColor: theme.colors.surface,
      paddingHorizontal: theme.spacing.m,
    },
    itemTitle: {
      fontWeight: '500',
    },
    itemDescription: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    divider: {
      height: StyleSheet.hairlineWidth,
      backgroundColor: theme.colors.outlineVariant,
      marginHorizontal: theme.spacing.m,
    },
  });

export default PrinterSelectionModal;

================
File: app/src/modules/orders/components/ProductCustomizationModal.tsx
================
import React, { useState, useEffect, useMemo, useCallback, memo } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  RadioButton,
  Divider,
  Appbar, // Importar Appbar
  TouchableRipple,
  IconButton,
  Card,
  Chip,
  Surface,
} from 'react-native-paper';
import { useForm, Controller, FieldValues } from 'react-hook-form';
import { useAppTheme } from '@/app/styles/theme';
import SpeechRecognitionInput from '@/app/components/common/SpeechRecognitionInput'; // Importar SpeechRecognitionInput
import {
  FullMenuProduct as Product,
  ProductVariant,
  Modifier,
  FullMenuModifierGroup,
} from '../types/orders.types';
import { CartItemModifier, CartItem } from '../stores/useCartStore';
import { AppTheme } from '@/app/styles/theme';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
import type { SelectedPizzaCustomization } from '@/app/schemas/domain/order.schema';
import type {
  PizzaCustomization,
  PizzaConfiguration,
} from '@/modules/pizzaCustomizations/types/pizzaCustomization.types';
import {
  PizzaHalf,
  CustomizationAction,
} from '@/modules/pizzaCustomizations/types/pizzaCustomization.types';
import PizzaCustomizationSection from './PizzaCustomizationSection';

interface ProductCustomizationModalProps {
  visible: boolean;
  onDismiss: () => void;
  product: Product;
  editingItem?: CartItem | null;
  onAddToCart: (
    product: Product,
    quantity: number,
    variantId?: string,
    modifiers?: CartItemModifier[],
    preparationNotes?: string,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost?: number,
  ) => void;
  onUpdateItem?: (
    itemId: string,
    quantity: number,
    modifiers: CartItemModifier[],
    preparationNotes?: string,
    variantId?: string,
    variantName?: string,
    unitPrice?: number,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost?: number,
  ) => void;
}

interface NotesFormData extends FieldValues {
  preparationNotes: string;
}

const ProductCustomizationModal = memo<ProductCustomizationModalProps>(
  ({ visible, onDismiss, product, editingItem, onAddToCart, onUpdateItem }) => {
    const theme = useAppTheme();
    const styles = useMemo(() => createStyles(theme), [theme]);
    const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

    const { control, reset, watch } = useForm<NotesFormData>({
      defaultValues: { preparationNotes: '' },
    });
    const watchedPreparationNotes = watch('preparationNotes');

    const [selectedVariantId, setSelectedVariantId] = useState<
      string | undefined
    >(
      product &&
        product.variants &&
        Array.isArray(product.variants) &&
        product.variants.length > 0
        ? product.variants[0].id
        : undefined,
    );
    const [selectedModifiersByGroup, setSelectedModifiersByGroup] = useState<
      Record<string, CartItemModifier[]>
    >({});

    const selectedModifiers = useMemo(() => {
      return Object.values(selectedModifiersByGroup).flat();
    }, [selectedModifiersByGroup]);

    // Pre-calcular si el producto tiene variantes o modificadores
    const hasVariants = useMemo(
      () =>
        product?.variants &&
        Array.isArray(product.variants) &&
        product.variants.length > 0,
      [product?.variants],
    );

    const [quantity, setQuantity] = useState(1);
    const [showExitConfirmation, setShowExitConfirmation] = useState(false);
    const [hasChanges, setHasChanges] = useState(false);
    const [validationErrors, setValidationErrors] = useState<
      Record<string, string>
    >({});

    // Estados para pizzas
    const [pizzaCustomizations, setPizzaCustomizations] = useState<
      PizzaCustomization[]
    >([]);
    const [pizzaConfiguration, setPizzaConfiguration] =
      useState<PizzaConfiguration | null>(null);
    const [selectedPizzaCustomizations, setSelectedPizzaCustomizations] =
      useState<SelectedPizzaCustomization[]>([]);

    // Funci√≥n para calcular el precio extra de las pizzas
    const calculatePizzaExtraCost = useCallback(() => {
      if (!product.isPizza || !pizzaConfiguration) return 0;

      let totalToppingValue = 0;

      // Solo contar customizaciones con action = ADD
      const addedCustomizations = selectedPizzaCustomizations.filter(
        (c) => c.action === CustomizationAction.ADD,
      );

      for (const selected of addedCustomizations) {
        const customization = pizzaCustomizations.find(
          (c) => c.id === selected.pizzaCustomizationId,
        );
        if (!customization) continue;

        if (selected.half === PizzaHalf.FULL) {
          // Pizza completa suma el toppingValue completo
          totalToppingValue += customization.toppingValue;
        } else {
          // Media pizza suma la mitad del toppingValue
          totalToppingValue += customization.toppingValue / 2;
        }
      }

      // Solo cobrar por toppings que excedan los incluidos
      if (totalToppingValue > pizzaConfiguration.includedToppings) {
        const extraToppings =
          totalToppingValue - pizzaConfiguration.includedToppings;
        return extraToppings * Number(pizzaConfiguration.extraToppingCost);
      }

      return 0;
    }, [
      product.isPizza,
      pizzaConfiguration,
      selectedPizzaCustomizations,
      pizzaCustomizations,
    ]);

    // Funci√≥n para verificar si hay cambios
    const checkForChanges = useCallback(() => {
      if (!editingItem) return false;

      // Comparar cantidad
      if (quantity !== editingItem.quantity) return true;

      // Comparar variante
      if (selectedVariantId !== editingItem.variantId) return true;

      // Comparar notas
      if (watchedPreparationNotes !== (editingItem.preparationNotes || ''))
        return true;

      // Comparar modificadores
      const currentModifierIds = selectedModifiers.map((m) => m.id).sort();
      const originalModifierIds = editingItem.modifiers.map((m) => m.id).sort();

      if (currentModifierIds.length !== originalModifierIds.length) return true;

      for (let i = 0; i < currentModifierIds.length; i++) {
        if (currentModifierIds[i] !== originalModifierIds[i]) return true;
      }

      return false;
    }, [
      editingItem,
      quantity,
      selectedVariantId,
      watchedPreparationNotes,
      selectedModifiers,
    ]);

    useEffect(() => {
      if (!product) return;

      if (editingItem) {
        // Si estamos editando, usar los valores del item
        setSelectedVariantId(editingItem.variantId);
        setQuantity(editingItem.quantity);
        reset({ preparationNotes: editingItem.preparationNotes || '' });

        // Reconstruir los modificadores por grupo
        const modifiersByGroup: Record<string, CartItemModifier[]> = {};
        if (editingItem.modifiers && product.modifierGroups) {
          editingItem.modifiers.forEach((mod) => {
            // Encontrar a qu√© grupo pertenece este modificador
            const group = product.modifierGroups?.find((g) =>
              g.productModifiers?.some((pm) => pm.id === mod.id),
            );
            if (group) {
              if (!modifiersByGroup[group.id]) {
                modifiersByGroup[group.id] = [];
              }
              modifiersByGroup[group.id].push(mod);
            }
          });
        }
        setSelectedModifiersByGroup(modifiersByGroup);
      } else {
        // Si es un nuevo item, valores por defecto
        if (
          product.variants &&
          Array.isArray(product.variants) &&
          product.variants.length > 0
        ) {
          setSelectedVariantId(product.variants[0].id);
        } else {
          setSelectedVariantId(undefined);
        }

        // Aplicar modificadores por defecto
        const defaultModifiersByGroup: Record<string, CartItemModifier[]> = {};

        if (product.modifierGroups) {
          product.modifierGroups.forEach((group) => {
            const defaultModifiers: CartItemModifier[] = [];

            if (group.productModifiers) {
              group.productModifiers.forEach((modifier) => {
                if (modifier.isDefault && modifier.isActive) {
                  defaultModifiers.push({
                    id: modifier.id,
                    modifierGroupId: group.id,
                    name: modifier.name,
                    price: Number(modifier.price) || 0,
                  });
                }
              });
            }

            if (defaultModifiers.length > 0) {
              // Respetar el l√≠mite m√°ximo de selecciones
              const maxSelections =
                group.maxSelections || defaultModifiers.length;
              defaultModifiersByGroup[group.id] = defaultModifiers.slice(
                0,
                maxSelections,
              );
            }
          });
        }

        setSelectedModifiersByGroup(defaultModifiersByGroup);
        setQuantity(1);
        reset({ preparationNotes: '' });
      }
    }, [product, editingItem, reset]);

    // Usar datos de pizza que ya vienen con el producto
    useEffect(() => {
      if (!product || !visible) return;

      // Si es una pizza, usar los datos que ya vienen con el producto
      if (product.isPizza) {
        if (product.pizzaConfiguration) {
          setPizzaConfiguration(product.pizzaConfiguration);
        }
        if (product.pizzaCustomizations) {
          setPizzaCustomizations(product.pizzaCustomizations);
        }

        // Si estamos editando, cargar las personalizaciones seleccionadas
        if (editingItem && editingItem.selectedPizzaCustomizations) {
          setSelectedPizzaCustomizations(
            editingItem.selectedPizzaCustomizations,
          );
        }
      }
    }, [product, visible, editingItem]);

    // Detectar cambios
    useEffect(() => {
      if (editingItem) {
        setHasChanges(checkForChanges());
      }
    }, [editingItem, checkForChanges]);

    // Validar en tiempo real
    useEffect(() => {
      const errors: Record<string, string> = {};

      if (product.modifierGroups) {
        product.modifierGroups.forEach((group) => {
          const selectedInGroup = selectedModifiersByGroup[group.id] || [];
          const selectedCount = selectedInGroup.length;
          const minRequired = Math.max(
            group.minSelections || 0,
            group.isRequired ? 1 : 0,
          );

          if (selectedCount < minRequired) {
            if (group.isRequired && minRequired === 1) {
              errors[group.id] = 'Requerido';
            } else {
              errors[group.id] = `M√≠nimo ${minRequired}`;
            }
          }
        });
      }

      setValidationErrors(errors);
    }, [product, selectedModifiersByGroup]);

    const handleVariantSelect = useCallback((variantId: string) => {
      setSelectedVariantId(variantId);
    }, []);

    const handleModifierToggle = (
      modifier: Modifier,
      group: FullMenuModifierGroup,
    ) => {
      const currentGroupModifiers = selectedModifiersByGroup[group.id] || [];
      const isSelected = currentGroupModifiers.some(
        (mod) => mod.id === modifier.id,
      );

      const updatedModifiersByGroup = { ...selectedModifiersByGroup };

      if (isSelected) {
        // Verificar si al deseleccionar quedar√≠amos por debajo del m√≠nimo
        const newCount = currentGroupModifiers.length - 1;
        const minRequired = Math.max(
          group.minSelections || 0,
          group.isRequired ? 1 : 0,
        );

        if (newCount < minRequired) {
          showSnackbar({
            message: `No puedes deseleccionar. "${group.name}" requiere al menos ${minRequired} ${minRequired === 1 ? 'opci√≥n seleccionada' : 'opciones seleccionadas'}.`,
            type: 'warning',
          });
          return;
        }

        updatedModifiersByGroup[group.id] = currentGroupModifiers.filter(
          (mod) => mod.id !== modifier.id,
        );
      } else {
        const newModifier: CartItemModifier = {
          id: modifier.id,
          modifierGroupId: group.id,
          name: modifier.name,
          price: Number(modifier.price) || 0,
        };

        if (!group.allowMultipleSelections) {
          updatedModifiersByGroup[group.id] = [newModifier];
        } else {
          if (currentGroupModifiers.length < (group.maxSelections || 0)) {
            updatedModifiersByGroup[group.id] = [
              ...currentGroupModifiers,
              newModifier,
            ];
          } else {
            showSnackbar({
              message: `Solo puedes seleccionar hasta ${group.maxSelections || 0} opciones en ${group.name}`,
              type: 'warning',
            });
            return;
          }
        }
      }

      setSelectedModifiersByGroup(updatedModifiersByGroup);
    };

    const handleAddToCart = () => {
      // Validar grupos requeridos y l√≠mites de selecci√≥n
      if (product.modifierGroups) {
        for (const group of product.modifierGroups) {
          const selectedInGroup = selectedModifiersByGroup[group.id] || [];
          const selectedCount = selectedInGroup.length;

          // Validar grupos requeridos y m√≠nimo de selecciones
          if (
            group.isRequired ||
            (group.minSelections && group.minSelections > 0)
          ) {
            const minRequired = Math.max(
              group.minSelections || 0,
              group.isRequired ? 1 : 0,
            );

            if (selectedCount < minRequired) {
              let message = '';
              if (group.isRequired && minRequired === 1) {
                message = `"${group.name}" es requerido. Debes seleccionar al menos una opci√≥n.`;
              } else if (minRequired > 1) {
                message = `Debes seleccionar al menos ${minRequired} ${minRequired === 1 ? 'opci√≥n' : 'opciones'} en "${group.name}"`;
              } else {
                message = `Debes seleccionar al menos una opci√≥n en "${group.name}"`;
              }

              showSnackbar({
                message,
                type: 'error',
              });
              return;
            }
          }

          // Validar m√°ximo de selecciones (esto ya se valida en handleModifierToggle, pero por si acaso)
          if (group.maxSelections && selectedCount > group.maxSelections) {
            showSnackbar({
              message: `No puedes seleccionar m√°s de ${group.maxSelections} ${group.maxSelections === 1 ? 'opci√≥n' : 'opciones'} en "${group.name}"`,
              type: 'error',
            });
            return;
          }
        }
      }

      if (editingItem && onUpdateItem) {
        // Si estamos editando, actualizar el item existente
        const variant = product.variants?.find(
          (v) => v.id === selectedVariantId,
        );
        const unitPrice = variant
          ? Number(variant.price)
          : Number(product.price) || 0;

        onUpdateItem(
          editingItem.id,
          quantity,
          selectedModifiers,
          watchedPreparationNotes,
          selectedVariantId,
          variant?.name,
          unitPrice,
          selectedPizzaCustomizations,
          pizzaExtraCost,
        );
      } else {
        // Si es un nuevo item, agregarlo al carrito
        onAddToCart(
          product,
          quantity,
          selectedVariantId,
          selectedModifiers,
          watchedPreparationNotes,
          selectedPizzaCustomizations,
          pizzaExtraCost,
        );
      }
      onDismiss();
    };

    const increaseQuantity = useCallback(
      () => setQuantity((prev) => prev + 1),
      [],
    );
    const decreaseQuantity = useCallback(
      () => setQuantity((prev) => (prev > 1 ? prev - 1 : 1)),
      [],
    );

    const handleDismiss = useCallback(() => {
      if (editingItem && hasChanges) {
        setShowExitConfirmation(true);
      } else {
        onDismiss();
      }
    }, [editingItem, hasChanges, onDismiss]);

    const handleConfirmExit = useCallback(() => {
      setShowExitConfirmation(false);
      onDismiss();
    }, [onDismiss]);

    const handleCancelExit = useCallback(() => {
      setShowExitConfirmation(false);
    }, []);

    if (!product || !visible) {
      return null;
    }

    const selectedVariant = useMemo(
      () =>
        hasVariants
          ? product.variants.find(
              (variant: ProductVariant) => variant.id === selectedVariantId,
            )
          : undefined,
      [hasVariants, product?.variants, selectedVariantId],
    );

    const basePrice = selectedVariant
      ? Number(selectedVariant.price)
      : Number(product.price) || 0;
    const modifiersPrice = selectedModifiers.reduce(
      (sum, mod) => sum + Number(mod.price || 0),
      0,
    );
    const pizzaExtraCost = calculatePizzaExtraCost();
    const totalPrice = (basePrice + modifiersPrice + pizzaExtraCost) * quantity;

    if (!visible) {
      return null;
    }

    return (
      <>
        <Portal>
          <Modal
            visible={visible}
            onDismiss={handleDismiss}
            contentContainerStyle={styles.modalContent}
          >
            {/* Encabezado Refactorizado con Appbar */}
            <Appbar.Header style={styles.appBar} elevated>
              <Appbar.BackAction
                onPress={handleDismiss}
                color={theme.colors.onSurface}
              />
              <Appbar.Content
                title={product?.name || 'Producto'}
                titleStyle={styles.appBarTitle}
                style={styles.appBarContent}
              />
              {/* Espaciador si no hay acci√≥n a la derecha */}
              <View style={styles.appBarSpacer} />
            </Appbar.Header>

            <ScrollView
              style={styles.scrollView}
              contentContainerStyle={{ paddingBottom: 20 }}
              showsVerticalScrollIndicator={true}
              keyboardShouldPersistTaps="handled"
              nestedScrollEnabled={true}
            >
              {product.hasVariants &&
                product.variants &&
                Array.isArray(product.variants) &&
                product.variants.length > 0 && (
                  <Card style={styles.sectionCard}>
                    <Card.Content>
                      <View style={styles.sectionHeader}>
                        <Text style={styles.sectionTitle}>Variantes</Text>
                        <Chip mode="flat" compact style={styles.requiredChip}>
                          Requerido
                        </Chip>
                      </View>
                      <RadioButton.Group
                        onValueChange={(value) => handleVariantSelect(value)}
                        value={selectedVariantId || ''}
                      >
                        {product.variants.map((variant: ProductVariant) => (
                          <Surface
                            key={variant.id}
                            style={[
                              styles.variantSurface,
                              selectedVariantId === variant.id &&
                                styles.variantSurfaceSelected,
                              !variant.isActive &&
                                styles.inactiveVariantSurface,
                            ]}
                            elevation={
                              selectedVariantId === variant.id &&
                              variant.isActive
                                ? 2
                                : 0
                            }
                          >
                            <TouchableRipple
                              onPress={() =>
                                variant.isActive &&
                                handleVariantSelect(variant.id)
                              }
                              disabled={!variant.isActive}
                              style={styles.variantTouchable}
                            >
                              <View style={styles.variantRow}>
                                <RadioButton
                                  value={variant.id}
                                  status={
                                    selectedVariantId === variant.id
                                      ? 'checked'
                                      : 'unchecked'
                                  }
                                  onPress={() =>
                                    variant.isActive &&
                                    handleVariantSelect(variant.id)
                                  }
                                  disabled={!variant.isActive}
                                />
                                <Text
                                  style={[
                                    styles.variantName,
                                    !variant.isActive && styles.inactiveText,
                                  ]}
                                >
                                  {variant.name}
                                  {!variant.isActive && ' (No disponible)'}
                                </Text>
                                <Text
                                  style={[
                                    styles.variantPrice,
                                    !variant.isActive && styles.inactiveText,
                                  ]}
                                >
                                  ${Number(variant.price).toFixed(2)}
                                </Text>
                              </View>
                            </TouchableRipple>
                          </Surface>
                        ))}
                      </RadioButton.Group>
                    </Card.Content>
                  </Card>
                )}

              {/* Secci√≥n de Personalizaci√≥n de Pizza - Despu√©s de variantes */}
              {product.isPizza && (
                <PizzaCustomizationSection
                  pizzaCustomizations={pizzaCustomizations}
                  pizzaConfiguration={pizzaConfiguration}
                  selectedPizzaCustomizations={selectedPizzaCustomizations}
                  onCustomizationChange={setSelectedPizzaCustomizations}
                  loading={false}
                />
              )}

              {product.modifierGroups &&
                Array.isArray(product.modifierGroups) &&
                product.modifierGroups.length > 0 &&
                product.modifierGroups.map((group: FullMenuModifierGroup) => (
                  <Card key={group.id} style={styles.sectionCard}>
                    <Card.Content>
                      <View style={styles.sectionHeader}>
                        <View style={styles.groupTitleContainer}>
                          <Text style={styles.groupTitle}>{group.name}</Text>
                          <View style={styles.selectionInfo}>
                            {group.minSelections !== undefined &&
                              group.maxSelections !== undefined && (
                                <Text style={styles.selectionRules}>
                                  {(group.minSelections || 0) === 0 &&
                                  group.maxSelections === 1
                                    ? 'Hasta 1 opci√≥n'
                                    : (group.minSelections || 0) ===
                                        group.maxSelections
                                      ? `Elegir ${group.maxSelections}`
                                      : `${group.minSelections || 0}-${group.maxSelections} opciones`}
                                </Text>
                              )}
                            {group.allowMultipleSelections && (
                              <Text style={styles.selectedCount}>
                                (
                                {
                                  (selectedModifiersByGroup[group.id] || [])
                                    .length
                                }{' '}
                                seleccionadas)
                              </Text>
                            )}
                          </View>
                        </View>
                        <View style={styles.chipContainer}>
                          {validationErrors[group.id] && (
                            <Chip
                              mode="flat"
                              compact
                              style={styles.errorChip}
                              icon="alert-circle"
                            >
                              {validationErrors[group.id]}
                            </Chip>
                          )}
                          <Chip
                            mode="flat"
                            compact
                            style={
                              group.isRequired
                                ? styles.requiredChip
                                : styles.optionalChip
                            }
                          >
                            {group.isRequired ? 'Requerido' : 'Opcional'}
                          </Chip>
                        </View>
                      </View>

                      {group.allowMultipleSelections ? (
                        <View style={styles.modifiersContainer}>
                          {Array.isArray(group.productModifiers) &&
                            group.productModifiers.map((modifier: Modifier) => {
                              const groupModifiers =
                                selectedModifiersByGroup[group.id] || [];
                              const isSelected = groupModifiers.some(
                                (mod) => mod.id === modifier.id,
                              );

                              return (
                                <Surface
                                  key={modifier.id}
                                  style={[
                                    styles.modifierSurface,
                                    isSelected &&
                                      styles.modifierSurfaceSelected,
                                    !modifier.isActive &&
                                      styles.inactiveModifierSurface,
                                  ]}
                                  elevation={
                                    isSelected && modifier.isActive ? 1 : 0
                                  }
                                >
                                  <TouchableRipple
                                    onPress={() =>
                                      modifier.isActive &&
                                      handleModifierToggle(modifier, group)
                                    }
                                    disabled={!modifier.isActive}
                                    style={styles.modifierTouchable}
                                  >
                                    <View style={styles.modifierRow}>
                                      <RadioButton
                                        value={modifier.id}
                                        status={
                                          isSelected ? 'checked' : 'unchecked'
                                        }
                                        disabled={!modifier.isActive}
                                        onPress={() =>
                                          modifier.isActive &&
                                          handleModifierToggle(modifier, group)
                                        }
                                      />
                                      <Text
                                        style={[
                                          styles.modifierName,
                                          !modifier.isActive &&
                                            styles.inactiveText,
                                        ]}
                                      >
                                        {modifier.name}
                                        {!modifier.isActive &&
                                          ' (No disponible)'}
                                      </Text>
                                      {Number(modifier.price) > 0 && (
                                        <Text
                                          style={[
                                            styles.modifierPrice,
                                            !modifier.isActive &&
                                              styles.inactiveText,
                                          ]}
                                        >
                                          +${Number(modifier.price).toFixed(2)}
                                        </Text>
                                      )}
                                    </View>
                                  </TouchableRipple>
                                </Surface>
                              );
                            })}
                        </View>
                      ) : (
                        <RadioButton.Group
                          onValueChange={(value) => {
                            const modifier = group.productModifiers?.find(
                              (m: Modifier) => m.id === value,
                            );
                            if (modifier) {
                              handleModifierToggle(modifier, group);
                            }
                          }}
                          value={
                            selectedModifiersByGroup[group.id]?.[0]?.id || ''
                          }
                        >
                          <View style={styles.modifiersContainer}>
                            {Array.isArray(group.productModifiers) &&
                              group.productModifiers.map(
                                (modifier: Modifier) => {
                                  const isSelected =
                                    selectedModifiersByGroup[group.id]?.[0]
                                      ?.id === modifier.id;

                                  return (
                                    <Surface
                                      key={modifier.id}
                                      style={[
                                        styles.modifierSurface,
                                        isSelected &&
                                          styles.modifierSurfaceSelected,
                                        !modifier.isActive &&
                                          styles.inactiveModifierSurface,
                                      ]}
                                      elevation={
                                        isSelected && modifier.isActive ? 1 : 0
                                      }
                                    >
                                      <TouchableRipple
                                        onPress={() =>
                                          modifier.isActive &&
                                          handleModifierToggle(modifier, group)
                                        }
                                        disabled={!modifier.isActive}
                                        style={styles.modifierTouchable}
                                      >
                                        <View style={styles.modifierRow}>
                                          <RadioButton
                                            value={modifier.id}
                                            status={
                                              isSelected
                                                ? 'checked'
                                                : 'unchecked'
                                            }
                                            disabled={!modifier.isActive}
                                            onPress={() =>
                                              modifier.isActive &&
                                              handleModifierToggle(
                                                modifier,
                                                group,
                                              )
                                            }
                                          />
                                          <Text
                                            style={[
                                              styles.modifierName,
                                              !modifier.isActive &&
                                                styles.inactiveText,
                                            ]}
                                          >
                                            {modifier.name}
                                            {!modifier.isActive &&
                                              ' (No disponible)'}
                                          </Text>
                                          {Number(modifier.price) > 0 && (
                                            <Text
                                              style={[
                                                styles.modifierPrice,
                                                !modifier.isActive &&
                                                  styles.inactiveText,
                                              ]}
                                            >
                                              +$
                                              {Number(modifier.price).toFixed(
                                                2,
                                              )}
                                            </Text>
                                          )}
                                        </View>
                                      </TouchableRipple>
                                    </Surface>
                                  );
                                },
                              )}
                          </View>
                        </RadioButton.Group>
                      )}
                    </Card.Content>
                  </Card>
                ))}

              {/* Secci√≥n Cantidad - Mejorada */}
              <Card style={styles.sectionCard}>
                <Card.Content>
                  <Text style={styles.sectionTitle}>Cantidad</Text>
                  <View style={styles.quantityContainer}>
                    <IconButton
                      icon="minus-circle-outline"
                      size={36}
                      onPress={decreaseQuantity}
                      style={[
                        styles.quantityIconButton,
                        quantity <= 1 && styles.quantityIconButtonDisabled,
                      ]}
                      iconColor={
                        quantity <= 1
                          ? theme.colors.onSurfaceDisabled
                          : theme.colors.primary
                      }
                      disabled={quantity <= 1}
                    />
                    <Surface style={styles.quantityBadge} elevation={1}>
                      <Text style={styles.quantityText}>{quantity}</Text>
                    </Surface>
                    <IconButton
                      icon="plus-circle-outline"
                      size={36}
                      onPress={increaseQuantity}
                      style={styles.quantityIconButton}
                      iconColor={theme.colors.primary}
                    />
                  </View>
                </Card.Content>
              </Card>

              {/* Secci√≥n Notas de Preparaci√≥n - Mejorada */}
              <Card style={styles.sectionCard}>
                <Card.Content>
                  <Controller
                    control={control}
                    name="preparationNotes"
                    render={({ field: { onChange, value } }) => (
                      <SpeechRecognitionInput
                        key="preparation-notes-input"
                        label="Notas de Preparaci√≥n"
                        value={value}
                        onChangeText={onChange}
                        multiline
                        numberOfLines={2}
                        style={styles.preparationInput}
                        speechLang="es-MX"
                      />
                    )}
                  />
                </Card.Content>
              </Card>

              {/* Secci√≥n Resumen - Mejorada */}
              <Card style={[styles.sectionCard, styles.summaryCard]}>
                <Card.Content>
                  <Text style={styles.sectionTitle}>Resumen del pedido</Text>
                  <View style={styles.summaryContent}>
                    <View style={styles.summaryRow}>
                      <Text style={styles.summaryLabel}>Precio base:</Text>
                      <Text style={styles.summaryValue}>
                        ${basePrice.toFixed(2)}
                      </Text>
                    </View>
                    {selectedModifiers.length > 0 && (
                      <View style={styles.summaryRow}>
                        <Text style={styles.summaryLabel}>Adicionales:</Text>
                        <Text style={styles.summaryValue}>
                          +${modifiersPrice.toFixed(2)}
                        </Text>
                      </View>
                    )}
                    {pizzaExtraCost > 0 && (
                      <View style={styles.summaryRow}>
                        <Text style={styles.summaryLabel}>Toppings extra:</Text>
                        <Text style={styles.summaryValue}>
                          +${pizzaExtraCost.toFixed(2)}
                        </Text>
                      </View>
                    )}
                    <View style={styles.summaryRow}>
                      <Text style={styles.summaryLabel}>Cantidad:</Text>
                      <Text style={styles.summaryValue}>√ó{quantity}</Text>
                    </View>
                    <Divider style={styles.summaryDivider} />
                    <View style={[styles.summaryRow, styles.totalRow]}>
                      <Text style={styles.totalLabel}>Total:</Text>
                      <Text style={styles.totalValue}>
                        ${totalPrice.toFixed(2)}
                      </Text>
                    </View>
                  </View>
                </Card.Content>
              </Card>
            </ScrollView>

            {/* Footer Button - Estilo OrderCartDetail */}
            <View style={styles.footer}>
              <Button
                mode="contained"
                onPress={handleAddToCart}
                style={styles.confirmButton}
                icon={editingItem ? 'cart-check' : 'cart-plus'}
              >
                {editingItem
                  ? `Actualizar Item - $${totalPrice.toFixed(2)}`
                  : `Agregar al Carrito - $${totalPrice.toFixed(2)}`}
              </Button>
            </View>
          </Modal>
        </Portal>

        {/* ConfirmationModal fuera del Portal principal */}
        <Portal>
          <ConfirmationModal
            visible={showExitConfirmation}
            onDismiss={handleCancelExit}
            onConfirm={handleConfirmExit}
            title="¬øDescartar cambios?"
            message="Tienes cambios sin guardar. ¬øEst√°s seguro de que quieres salir?"
            confirmText="Descartar"
            cancelText="Cancelar"
            confirmButtonColor={theme.colors.error}
          />
        </Portal>
      </>
    );
  },
);

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    modalContent: {
      backgroundColor: theme.colors.background,
      width: '100%',
      height: '100%',
      margin: 0,
      padding: 0,
      position: 'absolute',
      top: 0,
      left: 0,
    },
    // Estilos del Appbar
    appBar: {
      backgroundColor: theme.colors.elevation.level2, // Coincidir con OrderHeader
    },
    appBarTitle: {
      // Estilo para el T√çTULO dentro de Appbar.Content
      ...theme.fonts.titleMedium, // Fuente consistente con OrderHeader
      color: theme.colors.onSurface,
      fontWeight: 'bold', // A√±adir negritas al t√≠tulo
      // textAlign: 'center', // El centrado lo maneja appBarContent
      // flex: 1, // Quitar flex para permitir centrado vertical por appBarContent
    },
    appBarContent: {
      // Contenedor del t√≠tulo
      flex: 1, // Ocupar espacio disponible para centrar
      justifyContent: 'center', // Centrar verticalmente el contenido (t√≠tulo)
      alignItems: 'center', // Centrar horizontalmente el contenido (t√≠tulo)
      // marginLeft: -48, // Compensar el bot√≥n de back si es necesario (ajustar)
    },
    appBarSpacer: {
      // Espaciador para equilibrar el bot√≥n de retroceso
      width: 48, // Ancho est√°ndar de IconButton
    },
    // --- Fin estilos Appbar ---
    modifierGroup: {
      marginBottom: theme.spacing.s,
    },
    modifierGroupHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 2,
    },
    groupTitle: {
      fontSize: 16,
      fontWeight: 'bold',
      color: theme.colors.onSurface,
    },
    groupDescription: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    requiredText: {
      fontSize: 12,
      color: theme.colors.error,
      fontWeight: '500',
    },
    optionalText: {
      fontSize: 12,
      color: theme.colors.primary,
      fontWeight: '500',
    },
    selectionRules: {
      fontSize: 10,
      color: theme.colors.onSurfaceVariant,
      marginBottom: theme.spacing.xs,
      fontStyle: 'italic',
    },
    selectionInfo: {
      marginTop: 2,
    },
    selectedCount: {
      fontSize: 12,
      color: theme.colors.primary,
      fontWeight: '500',
      marginTop: 2,
    },
    productImage: {
      height: 150,
      borderRadius: theme.roundness,
      marginBottom: theme.spacing.m,
    },
    imagePlaceholder: {
      backgroundColor: theme.colors.surfaceVariant,
      justifyContent: 'center',
      alignItems: 'center',
    },
    placeholderText: {
      fontSize: 50,
      color: theme.colors.onSurfaceVariant,
    },
    scrollView: {
      flex: 1,
      padding: theme.spacing.m,
    },
    section: {
      marginBottom: theme.spacing.s,
    },
    sectionTitle: {
      fontSize: 16,
      fontWeight: 'bold',
      marginBottom: theme.spacing.xs,
      color: theme.colors.onSurface,
    },
    // Nuevos estilos para Cards
    sectionCard: {
      marginBottom: theme.spacing.m,
      borderRadius: theme.roundness * 2,
    },
    sectionHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.m,
    },
    groupTitleContainer: {
      flex: 1,
    },
    requiredChip: {
      backgroundColor: theme.colors.errorContainer,
      marginLeft: theme.spacing.s,
    },
    optionalChip: {
      backgroundColor: theme.colors.secondaryContainer,
      marginLeft: theme.spacing.s,
    },
    chipContainer: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    errorChip: {
      backgroundColor: theme.colors.errorContainer,
      marginRight: theme.spacing.xs,
    },
    // Estilos para variantes
    variantSurface: {
      marginBottom: theme.spacing.xs,
      borderRadius: theme.roundness,
      backgroundColor: theme.colors.surface,
      borderWidth: 1,
      borderColor: theme.colors.surfaceVariant,
    },
    variantSurfaceSelected: {
      borderColor: theme.colors.primary,
      backgroundColor: theme.colors.primaryContainer,
    },
    variantTouchable: {
      padding: 0,
    },
    variantRow: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingVertical: theme.spacing.s,
      paddingHorizontal: theme.spacing.xs,
    },
    variantName: {
      flex: 1,
      fontSize: 16,
      marginLeft: theme.spacing.xs,
      color: theme.colors.onSurface,
    },
    // Estilos para modificadores
    modifiersContainer: {
      marginTop: theme.spacing.xs,
    },
    modifierSurface: {
      marginBottom: theme.spacing.xs,
      borderRadius: theme.roundness,
      backgroundColor: theme.colors.surface,
      borderWidth: 1,
      borderColor: theme.colors.surfaceVariant,
    },
    modifierSurfaceSelected: {
      borderColor: theme.colors.primary,
      backgroundColor: theme.colors.primaryContainer,
    },
    modifierTouchable: {
      padding: 0,
    },
    modifierRow: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingVertical: theme.spacing.s,
      paddingHorizontal: theme.spacing.xs,
    },
    modifierName: {
      flex: 1,
      fontSize: 15,
      marginLeft: theme.spacing.xs,
      color: theme.colors.onSurface,
    },
    // Estilos de cantidad mejorados
    quantityBadge: {
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.xs,
      borderRadius: theme.roundness,
      backgroundColor: theme.colors.primaryContainer,
    },
    quantityIconButtonDisabled: {
      opacity: 0.5,
    },
    // Estilos de resumen mejorados
    summaryCard: {
      backgroundColor: theme.dark
        ? theme.colors.elevation.level3
        : theme.colors.secondaryContainer,
      borderWidth: theme.dark ? 1 : 0,
      borderColor: theme.dark ? theme.colors.outlineVariant : undefined,
    },
    summaryContent: {
      marginTop: theme.spacing.xs,
    },
    summaryLabel: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    summaryValue: {
      fontSize: 14,
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    summaryDivider: {
      marginVertical: theme.spacing.xs,
      backgroundColor: theme.colors.onSurfaceVariant,
      opacity: 0.3,
    },
    optionContainer: {
      marginBottom: 2,
    },
    optionTouchable: {
      paddingVertical: 4,
    },
    optionRow: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingHorizontal: 8,
      paddingVertical: 8,
    },
    optionContent: {
      // Contenedor solo para el t√≠tulo del modificador (Checkbox)
      flex: 1, // Ocupa el espacio restante
      justifyContent: 'center', // Centra verticalmente el texto si es necesario
      // Quitar justifyContent: 'space-between'
      // alignItems: "center", // Ya est√° en optionRow
      // paddingRight: 8, // No necesario si el precio est√° fuera
    },
    checkbox: {
      marginRight: 8,
    },
    optionDivider: {
      height: 1,
      backgroundColor: theme.colors.outlineVariant,
    },
    radioItem: {
      flex: 1,
      paddingVertical: 4,
    },
    modifierTitle: {
      fontSize: 16,
      fontWeight: '500',
      color: theme.colors.onSurface, // Color est√°ndar para texto
    },
    variantPrice: {
      // Estilo espec√≠fico para precio de variante
      fontSize: 14,
      fontWeight: 'bold',
      color: theme.colors.onSurfaceVariant, // Color secundario consistente
      marginLeft: 'auto',
      marginRight: 8,
    },
    inactiveVariantSurface: {
      opacity: 0.6,
      backgroundColor: theme.colors.surfaceDisabled,
    },
    inactiveModifierSurface: {
      opacity: 0.6,
      backgroundColor: theme.colors.surfaceDisabled,
    },
    inactiveText: {
      color: theme.colors.onSurfaceDisabled,
      textDecorationLine: 'line-through',
    },
    modifierPrice: {
      // Estilo para precio de modificador (Checkbox y Radio)
      fontSize: 14,
      fontWeight: 'bold',
      color: theme.colors.onSurfaceVariant, // Color secundario consistente
      marginLeft: 'auto', // Empujar a la derecha
      paddingHorizontal: 8, // A√±adir padding similar a variantPrice
    },
    quantityContainer: {
      flexDirection: 'row',
      justifyContent: 'center',
      alignItems: 'center',
      marginVertical: theme.spacing.s,
    },
    quantityIconButton: {
      margin: 0,
      borderRadius: 18,
    },
    quantityText: {
      fontSize: 18,
      fontWeight: 'bold',
      minWidth: 40,
      textAlign: 'center',
      marginHorizontal: theme.spacing.s,
      color: theme.colors.onSurface,
    },
    summaryRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      paddingVertical: theme.spacing.xs,
      paddingHorizontal: theme.spacing.xs, // A√±adir padding horizontal
    },
    totalRow: {
      // Estilo adicional para la fila del total
      marginTop: theme.spacing.s,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      paddingTop: theme.spacing.s,
    },
    totalLabel: {
      // Estilo consistente con OrderCartDetail
      fontWeight: 'bold',
      fontSize: 18,
      color: theme.colors.onSurface,
    },
    totalValue: {
      // Estilo consistente con OrderCartDetail para el TOTAL FINAL
      fontWeight: 'bold',
      fontSize: 18,
      color: theme.colors.primary, // Color primario para el total final
    },
    // Estilos de Footer y Bot√≥n - Consistentes con OrderCartDetail
    footer: {
      padding: theme.spacing.m,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface, // Fondo consistente
    },
    confirmButton: {
      // Reemplaza addButton
      paddingVertical: theme.spacing.s, // Padding consistente
      // width: "100%", // Ya es el comportamiento por defecto del bot√≥n en un View
    },
    // Estilo para SpeechRecognitionInput (una sola l√≠nea)
    preparationInput: {
      // backgroundColor: theme.colors.surfaceVariant, // Opcional: mantener fondo
      marginVertical: theme.spacing.xs,
      textAlignVertical: 'center', // Intentar centrar verticalmente el placeholder/texto
      // minHeight: 80, // Eliminar altura m√≠nima, ya no es multil√≠nea
    },
    // Eliminar estilos no usados
    // sectionTitleContainer: { ... },
    // sectionTitleOptional: { ... },
    divider: {
      // Estilo de Divider si se usa
      marginVertical: theme.spacing.s,
      backgroundColor: theme.colors.outlineVariant,
    },
  });

ProductCustomizationModal.displayName = 'ProductCustomizationModal';

export default ProductCustomizationModal;

================
File: app/src/modules/orders/services/orderPrintService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';

interface PrintTicketPayload {
  printerId: string;
  ticketType: 'GENERAL' | 'BILLING';
}

export const orderPrintService = {
  /**
   * Imprime un ticket para una orden
   */
  printTicket: async (orderId: string, payload: PrintTicketPayload) => {
    const response = await apiClient.post(
      API_PATHS.ORDERS_PRINT_TICKET.replace(':orderId', orderId),
      payload,
    );
    return response.data;
  },
};

================
File: app/src/modules/orders/services/paymentService.ts
================
import ApiClientWrapper from '../../../app/services/apiClientWrapper';
import { API_PATHS } from '../../../app/constants/apiPaths';
import type {
  Payment,
  CreatePaymentDto,
  UpdatePaymentDto,
  PaymentMethod,
  PaymentStatus,
} from '../types/payment.types';

class PaymentService {
  async createPayment(dto: CreatePaymentDto): Promise<Payment> {
    const { data } = await ApiClientWrapper.post<Payment>(
      API_PATHS.PAYMENTS,
      dto,
    );
    return data;
  }

  async getPayments(filters?: {
    orderId?: string;
    paymentMethod?: PaymentMethod;
    paymentStatus?: PaymentStatus;
  }): Promise<Payment[]> {
    const { data } = await ApiClientWrapper.get<Payment[]>(API_PATHS.PAYMENTS, {
      params: filters,
    });
    return data;
  }

  async getPaymentById(id: string): Promise<Payment> {
    const { data } = await ApiClientWrapper.get<Payment>(
      API_PATHS.PAYMENTS_BY_ID.replace(':paymentId', id),
    );
    return data;
  }

  async getPaymentsByOrderId(orderId: string): Promise<Payment[]> {
    const { data } = await ApiClientWrapper.get<Payment[]>(
      API_PATHS.PAYMENTS_BY_ORDER.replace(':orderId', orderId),
    );
    return data;
  }

  async updatePayment(id: string, dto: UpdatePaymentDto): Promise<Payment> {
    const { data } = await ApiClientWrapper.patch<Payment>(
      API_PATHS.PAYMENTS_BY_ID.replace(':paymentId', id),
      dto,
    );
    return data;
  }

  async deletePayment(id: string): Promise<void> {
    await ApiClientWrapper.delete(
      API_PATHS.PAYMENTS_BY_ID.replace(':paymentId', id),
    );
  }
}

export const paymentService = new PaymentService();

================
File: app/src/modules/payments/services/prepaymentService.ts
================
import apiClient from '@/app/services/apiClient';
import { handleApiResponse, handleApiResponseVoid } from '@/app/lib/apiHelpers';
import { API_PATHS } from '@/app/constants/apiPaths';
import type { Payment } from '../types/payment.types';

interface CreatePrepaymentDto {
  paymentMethod: 'CASH' | 'CARD' | 'TRANSFER';
  amount: number;
}

interface UpdatePrepaymentDto {
  paymentMethod?: 'CASH' | 'CARD' | 'TRANSFER';
  amount?: number;
}

export const prepaymentService = {
  /**
   * Crear un pre-pago (pago sin orden asociada)
   */
  createPrepayment: async (data: CreatePrepaymentDto): Promise<Payment> => {
    const response = await apiClient.post<Payment>(
      API_PATHS.PAYMENTS_PREPAYMENT,
      data,
    );
    return handleApiResponse(response);
  },

  /**
   * Actualizar un pre-pago existente
   */
  updatePrepayment: async (
    paymentId: string,
    data: UpdatePrepaymentDto,
  ): Promise<Payment> => {
    const response = await apiClient.patch<Payment>(
      API_PATHS.PAYMENTS_BY_ID.replace(':paymentId', paymentId),
      data,
    );
    return handleApiResponse(response);
  },

  /**
   * Asociar un pre-pago a una orden
   */
  associateToOrder: async (
    paymentId: string,
    orderId: string,
  ): Promise<Payment> => {
    const response = await apiClient.patch<Payment>(
      API_PATHS.PAYMENTS_ASSOCIATE.replace(':paymentId', paymentId).replace(
        ':orderId',
        orderId,
      ),
    );
    return handleApiResponse(response);
  },

  /**
   * Eliminar un pre-pago
   */
  deletePrepayment: async (paymentId: string): Promise<void> => {
    const response = await apiClient.delete(
      API_PATHS.PAYMENTS_BY_ID.replace(':paymentId', paymentId),
    );
    handleApiResponseVoid(response);
  },
};

================
File: app/src/modules/pizzaCustomizations/components/PizzaCustomizationDetailModal.tsx
================
import React from 'react';
import GenericDetailModal from '@/app/components/crud/GenericDetailModal';
import {
  CustomizationType,
  PizzaCustomization,
} from '../types/pizzaCustomization.types';

interface PizzaCustomizationDetailModalProps {
  visible: boolean;
  onDismiss: () => void;
  customization: PizzaCustomization | null;
  onEdit?: (customization: PizzaCustomization) => void;
  onDelete?: (customization: PizzaCustomization) => void;
  isDeleting?: boolean;
}

export function PizzaCustomizationDetailModal({
  visible,
  onDismiss,
  customization,
  onEdit,
  onDelete,
  isDeleting = false,
}: PizzaCustomizationDetailModalProps) {
  if (!customization) return null;

  const handleEdit = () => {
    if (onEdit) {
      onEdit(customization);
    }
  };

  const handleDelete = () => {
    if (onDelete) {
      onDelete(customization);
    }
  };

  // Configurar campos din√°micamente seg√∫n el tipo
  const fieldsToDisplay = [
    {
      field: 'type',
      label: 'Tipo',
      render: (type) =>
        type === CustomizationType.FLAVOR ? 'Sabor' : 'Ingrediente',
    },
    // Solo mostrar ingredientes si es tipo FLAVOR
    ...(customization.type === CustomizationType.FLAVOR
      ? [
          {
            field: 'ingredients',
            label: 'Ingredientes',
            render: (ingredients) => ingredients || 'Sin ingredientes',
          },
        ]
      : []),
    {
      field: 'toppingValue',
      label: 'Valor de topping',
      render: (value) => value?.toString() || '0',
    },
    {
      field: 'sortOrder',
      label: 'Orden de visualizaci√≥n',
      render: (value) => value?.toString() || '0',
    },
    {
      field: 'products',
      label: 'Asociado a productos',
      render: (products) => {
        if (!products || products.length === 0) {
          return 'No asociado a ning√∫n producto';
        }
        const productNames = products.map((p) => p.name).join(', ');
        return `${products.length} producto${products.length > 1 ? 's' : ''}: ${productNames}`;
      },
    },
  ];

  return (
    <GenericDetailModal
      visible={visible}
      onDismiss={onDismiss}
      item={customization}
      titleField="name"
      statusConfig={{
        field: 'isActive',
        activeValue: true,
        activeLabel: 'Activo',
        inactiveLabel: 'Inactivo',
      }}
      fieldsToDisplay={fieldsToDisplay}
      onEdit={onEdit ? handleEdit : undefined}
      onDelete={onDelete ? handleDelete : undefined}
      isDeleting={isDeleting}
    />
  );
}

================
File: app/src/modules/pizzaCustomizations/components/PizzaCustomizationsTab.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, TouchableOpacity } from 'react-native';
import {
  Text,
  Searchbar,
  ActivityIndicator,
  Menu,
  IconButton,
  Badge,
  Chip,
  Surface,
} from 'react-native-paper';
import { FlashList } from '@shopify/flash-list';
import { useAppTheme } from '@/app/styles/theme';
import {
  usePizzaCustomizationsList,
  useDeletePizzaCustomization,
} from '../hooks/usePizzaCustomizationsQueries';
import { PizzaCustomizationDetailModal } from './PizzaCustomizationDetailModal';
import { PizzaCustomizationFormModal } from './PizzaCustomizationFormModal';
import {
  CustomizationType,
  PizzaCustomization,
} from '../types/pizzaCustomization.types';
import EmptyState from '@/app/components/common/EmptyState';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';

export function PizzaCustomizationsTab() {
  const theme = useAppTheme();

  const [searchQuery, setSearchQuery] = useState('');
  const [selectedType, setSelectedType] = useState<CustomizationType | 'all'>(
    'all',
  );
  const [filterMenuVisible, setFilterMenuVisible] = useState(false);
  const [selectedCustomization, setSelectedCustomization] =
    useState<PizzaCustomization | null>(null);
  const [detailModalVisible, setDetailModalVisible] = useState(false);
  const [deleteConfirmVisible, setDeleteConfirmVisible] = useState(false);
  const [customizationToDelete, setCustomizationToDelete] =
    useState<PizzaCustomization | null>(null);
  const [formModalVisible, setFormModalVisible] = useState(false);
  const [editingCustomizationId, setEditingCustomizationId] = useState<
    string | undefined
  >();

  const deleteMutation = useDeletePizzaCustomization();

  const {
    data,
    isLoading,
    isError: _isError,
    refetch,
  } = usePizzaCustomizationsList({
    search: searchQuery || undefined,
    type: selectedType === 'all' ? undefined : selectedType,
    limit: 100, // Aumentar el l√≠mite para obtener todos los registros
  });

  const filteredData = data?.data || [];
  const hasActiveFilter = selectedType !== 'all';

  const handleItemPress = (item: PizzaCustomization) => {
    setSelectedCustomization(item);
    setDetailModalVisible(true);
  };

  const handleEdit = (customization: PizzaCustomization) => {
    setDetailModalVisible(false);
    setEditingCustomizationId(customization.id);
    setFormModalVisible(true);
  };

  const handleDelete = (customization: PizzaCustomization) => {
    setCustomizationToDelete(customization);
    setDetailModalVisible(false);
    setDeleteConfirmVisible(true);
  };

  const confirmDelete = async () => {
    if (customizationToDelete) {
      await deleteMutation.mutateAsync(customizationToDelete.id);
      setDeleteConfirmVisible(false);
      setCustomizationToDelete(null);
    }
  };

  const renderItem = ({ item }: { item: any }) => (
    <TouchableOpacity onPress={() => handleItemPress(item)}>
      <Surface
        style={[
          styles.cardWrapper,
          !item.isActive && styles.cardWrapperInactive,
        ]}
        elevation={1}
      >
        <View style={styles.cardContent}>
          <View style={styles.cardHeader}>
            <View style={styles.titleRow}>
              <View style={styles.titleContainer}>
                <Text
                  variant="titleMedium"
                  style={[
                    styles.cardTitle,
                    !item.isActive && styles.textInactive,
                  ]}
                  numberOfLines={1}
                >
                  {item.name}
                </Text>
                {!item.isActive && (
                  <Badge style={styles.inactiveBadge} size={16}>
                    Inactivo
                  </Badge>
                )}
              </View>
              <Chip
                mode="flat"
                compact
                icon={
                  item.type === CustomizationType.FLAVOR ? 'pizza' : 'cheese'
                }
                style={[
                  styles.typeChip,
                  {
                    backgroundColor:
                      item.type === CustomizationType.FLAVOR
                        ? theme.colors.errorContainer
                        : theme.colors.secondaryContainer,
                  },
                  !item.isActive && styles.chipInactive,
                ]}
                textStyle={styles.chipText}
              >
                {item.type === CustomizationType.FLAVOR
                  ? 'Sabor'
                  : 'Ingrediente'}
              </Chip>
            </View>
            <View style={styles.statsContainer}>
              <View
                style={[
                  styles.statusIndicator,
                  item.isActive ? styles.statusActive : styles.statusInactive,
                ]}
              />
              <Text
                variant="bodySmall"
                style={[styles.statText, !item.isActive && styles.textInactive]}
              >
                Orden: {item.sortOrder || 0}
              </Text>
              <Text
                variant="bodySmall"
                style={[styles.statText, !item.isActive && styles.textInactive]}
              >
                ‚Ä¢ Valor: {item.toppingValue || 0}
              </Text>
              <Text
                variant="bodySmall"
                style={[styles.statText, !item.isActive && styles.textInactive]}
              >
                ‚Ä¢ {item.products?.length || 0} pizzas
              </Text>
            </View>
          </View>

          {item.ingredients && (
            <Text
              variant="bodySmall"
              style={[
                styles.ingredientsText,
                !item.isActive && styles.textInactive,
              ]}
              numberOfLines={1}
            >
              {item.ingredients}
            </Text>
          )}
        </View>
      </Surface>
    </TouchableOpacity>
  );

  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    header: {
      padding: theme.spacing.m,
      backgroundColor: theme.colors.background,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    searchRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
    },
    searchbar: {
      flex: 1,
      backgroundColor: theme.colors.elevation.level2,
    },
    filterButtonContainer: {
      position: 'relative',
    },
    filterIconButton: {
      margin: 0,
      backgroundColor: theme.colors.elevation.level2,
    },
    filterBadge: {
      position: 'absolute',
      top: 4,
      right: 4,
      backgroundColor: theme.colors.primary,
    },
    menuContent: {
      backgroundColor: theme.colors.elevation.level3,
      marginTop: theme.spacing.xs,
    },
    content: {
      flex: 1,
    },
    listContainer: {
      padding: theme.spacing.s,
    },
    cardWrapper: {
      marginHorizontal: theme.spacing.m,
      marginVertical: theme.spacing.xs,
      borderRadius: theme.roundness * 2,
      overflow: 'hidden',
    },
    cardWrapperInactive: {
      opacity: 0.7,
    },
    cardContent: {
      padding: theme.spacing.s,
      paddingHorizontal: theme.spacing.m,
    },
    cardHeader: {
      marginBottom: theme.spacing.xs,
    },
    titleRow: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      gap: theme.spacing.s,
    },
    titleContainer: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
    },
    cardTitle: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: 16,
    },
    textInactive: {
      color: theme.colors.onSurfaceVariant,
    },
    inactiveBadge: {
      backgroundColor: theme.colors.errorContainer,
      color: theme.colors.onErrorContainer,
      fontSize: 10,
      fontWeight: '600',
    },
    typeChip: {
      height: 24,
    },
    chipInactive: {
      opacity: 0.6,
    },
    chipText: {
      fontSize: 11,
      marginHorizontal: theme.spacing.xs,
      marginVertical: 0,
    },
    statsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
      marginTop: theme.spacing.xs,
    },
    statusIndicator: {
      width: 8,
      height: 8,
      borderRadius: 4,
    },
    statusActive: {
      backgroundColor: theme.colors.primary,
    },
    statusInactive: {
      backgroundColor: theme.colors.error,
    },
    statText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    ingredientsText: {
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      fontSize: 12,
      marginTop: theme.spacing.xs,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
  });

  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <View style={styles.searchRow}>
          <Searchbar
            placeholder="Buscar personalizaci√≥n..."
            onChangeText={setSearchQuery}
            value={searchQuery}
            style={styles.searchbar}
            elevation={0}
            inputStyle={{ color: theme.colors.onSurface }}
            placeholderTextColor={theme.colors.onSurfaceVariant}
            iconColor={theme.colors.onSurfaceVariant}
          />
          <View style={styles.filterButtonContainer}>
            <Menu
              visible={filterMenuVisible}
              onDismiss={() => setFilterMenuVisible(false)}
              anchor={
                <IconButton
                  icon={
                    selectedType === 'all'
                      ? 'filter-variant'
                      : selectedType === CustomizationType.FLAVOR
                        ? 'pizza'
                        : 'cheese'
                  }
                  mode="contained-tonal"
                  size={24}
                  onPress={() => setFilterMenuVisible(true)}
                  style={styles.filterIconButton}
                  iconColor={
                    selectedType !== 'all'
                      ? theme.colors.primary
                      : theme.colors.onSurfaceVariant
                  }
                />
              }
              anchorPosition="bottom"
              contentStyle={styles.menuContent}
            >
              <Menu.Item
                onPress={() => {
                  setSelectedType('all');
                  setFilterMenuVisible(false);
                }}
                title="Todas"
                leadingIcon="filter-variant"
                trailingIcon={selectedType === 'all' ? 'check' : undefined}
                titleStyle={
                  selectedType === 'all'
                    ? { color: theme.colors.primary, fontWeight: '600' }
                    : undefined
                }
              />
              <Menu.Item
                onPress={() => {
                  setSelectedType(CustomizationType.FLAVOR);
                  setFilterMenuVisible(false);
                }}
                title="Sabores"
                leadingIcon="pizza"
                trailingIcon={
                  selectedType === CustomizationType.FLAVOR
                    ? 'check'
                    : undefined
                }
                titleStyle={
                  selectedType === CustomizationType.FLAVOR
                    ? { color: theme.colors.primary, fontWeight: '600' }
                    : undefined
                }
              />
              <Menu.Item
                onPress={() => {
                  setSelectedType(CustomizationType.INGREDIENT);
                  setFilterMenuVisible(false);
                }}
                title="Ingredientes"
                leadingIcon="cheese"
                trailingIcon={
                  selectedType === CustomizationType.INGREDIENT
                    ? 'check'
                    : undefined
                }
                titleStyle={
                  selectedType === CustomizationType.INGREDIENT
                    ? { color: theme.colors.primary, fontWeight: '600' }
                    : undefined
                }
              />
            </Menu>
            {hasActiveFilter && <Badge style={styles.filterBadge} size={8} />}
          </View>
        </View>
      </View>

      <View style={styles.content}>
        <FlashList
          data={filteredData}
          renderItem={renderItem}
          estimatedItemSize={120}
          ListEmptyComponent={
            <EmptyState
              title="No hay personalizaciones"
              message={
                selectedType === CustomizationType.FLAVOR
                  ? 'No hay sabores disponibles'
                  : selectedType === CustomizationType.INGREDIENT
                    ? 'No hay ingredientes disponibles'
                    : 'No hay personalizaciones disponibles'
              }
              icon="cheese"
            />
          }
          contentContainerStyle={styles.listContainer}
          keyExtractor={(item) => item.id}
          refreshing={isLoading}
          onRefresh={refetch}
        />
      </View>

      <PizzaCustomizationDetailModal
        visible={detailModalVisible}
        onDismiss={() => {
          setDetailModalVisible(false);
          setSelectedCustomization(null);
        }}
        customization={selectedCustomization}
        onEdit={handleEdit}
        onDelete={handleDelete}
        isDeleting={deleteMutation.isPending}
      />

      <ConfirmationModal
        visible={deleteConfirmVisible}
        title="Eliminar personalizaci√≥n"
        message={`¬øEst√°s seguro de que quieres eliminar "${customizationToDelete?.name}"?`}
        confirmText="Eliminar"
        cancelText="Cancelar"
        confirmButtonColor={theme.colors.error}
        onConfirm={confirmDelete}
        onCancel={() => {
          setDeleteConfirmVisible(false);
          setCustomizationToDelete(null);
        }}
        onDismiss={() => {
          setDeleteConfirmVisible(false);
          setCustomizationToDelete(null);
        }}
      />

      <PizzaCustomizationFormModal
        visible={formModalVisible}
        onDismiss={() => {
          setFormModalVisible(false);
          setEditingCustomizationId(undefined);
        }}
        customizationId={editingCustomizationId}
        onSuccess={() => {
          refetch();
        }}
      />
    </View>
  );
}

================
File: app/src/modules/preparationScreens/schema/preparationScreen.schema.ts
================
import { z } from 'zod';
// Importar el schema y tipo de dominio centralizado
import {
  preparationScreenSchema as domainPreparationScreenSchema,
  type PreparationScreen as DomainPreparationScreen,
} from '../../../app/schemas/domain/preparation-screen.schema';

// Esquema principal extendido desde el dominio para incluir relaciones
export const PreparationScreenSchema = domainPreparationScreenSchema.extend({
  id: z.string().uuid(), // Refinar el ID para ser UUID espec√≠ficamente
  products: z
    .array(
      z.object({
        id: z.string(),
        name: z.string(),
      }),
    )
    .optional(),
  users: z
    .array(
      z.object({
        id: z.string(),
        username: z.string(),
        firstName: z.string().nullable().optional(),
        lastName: z.string().nullable().optional(),
      }),
    )
    .nullable()
    .optional(),
  createdAt: z.string().datetime().optional(),
  updatedAt: z.string().datetime().optional(),
});

// Esquema para crear una nueva pantalla de preparaci√≥n - compuesto desde el dominio
export const CreatePreparationScreenSchema = domainPreparationScreenSchema
  .omit({ id: true })
  .extend({
    name: z
      .string()
      .min(1, 'El nombre es requerido')
      .max(100, 'El nombre no puede exceder los 100 caracteres'),
    description: z
      .string()
      .max(255, 'La descripci√≥n no puede exceder los 255 caracteres')
      .nullable()
      .optional(),
    isActive: z.boolean().optional().default(true),
    productIds: z.array(z.string().uuid()).optional(), // IDs de productos asociados (opcional)
    userId: z
      .string()
      .min(1, 'Debe seleccionar un usuario de cocina')
      .uuid({ message: 'Debe seleccionar un usuario de cocina v√°lido' }), // ID del usuario asignado (requerido)
  });

// Esquema para actualizar una pantalla de preparaci√≥n existente - basado en el de creaci√≥n
export const UpdatePreparationScreenSchema = CreatePreparationScreenSchema.omit(
  { userId: true },
).extend({
  name: z
    .string()
    .min(1, 'El nombre es requerido')
    .max(100, 'El nombre no puede exceder los 100 caracteres')
    .optional(),
  description: z
    .string()
    .max(255, 'La descripci√≥n no puede exceder los 255 caracteres')
    .nullable()
    .optional(),
  isActive: z.boolean().optional(),
  userId: z
    .string()
    .min(1, 'Debe seleccionar un usuario de cocina')
    .uuid({ message: 'Debe seleccionar un usuario de cocina v√°lido' })
    .optional(), // Opcional en actualizaci√≥n
});

// Tipos inferidos de los esquemas Zod
export type PreparationScreen = z.infer<typeof PreparationScreenSchema>;
export type CreatePreparationScreenDto = z.infer<
  typeof CreatePreparationScreenSchema
>;
export type UpdatePreparationScreenDto = z.infer<
  typeof UpdatePreparationScreenSchema
>;

// Re-exportar tipo de dominio para conveniencia
export type { DomainPreparationScreen };

// Esquema para los filtros de b√∫squeda/listado
export const FindAllPreparationScreensSchema = z.object({
  name: z.string().optional(),
  isActive: z.boolean().optional(),
  // A√±adir otros filtros si son necesarios, ej: productId
});

// Tipo inferido para los filtros de b√∫squeda/listado
export type FindAllPreparationScreensDto = z.infer<
  typeof FindAllPreparationScreensSchema
>;

================
File: app/src/modules/preparationScreens/services/preparationScreenService.ts
================
import ApiClientWrapper from '../../../app/services/apiClientWrapper';
import { ApiError } from '../../../app/lib/errors';
import { API_PATHS } from '../../../app/constants/apiPaths';
import {
  BackendErrorResponse,
  PaginatedResponse,
} from '../../../app/types/api.types';
import { BaseListQuery } from '../../../app/types/query.types';
import {
  PreparationScreen,
  CreatePreparationScreenDto,
  UpdatePreparationScreenDto,
  FindAllPreparationScreensDto,
} from '../schema/preparationScreen.schema';

/**
 * Fetches a list of preparation screens based on filter and pagination options.
 * @param filterOptions - Options to filter the results (e.g., by name, isActive).
 * @param paginationOptions - Options for pagination (page number, limit).
 * @returns A promise that resolves to a paginated response of PreparationScreen objects.
 * @throws {ApiError} If the API request fails.
 */
export const getPreparationScreens = async (
  filterOptions: FindAllPreparationScreensDto = {},
  paginationOptions: BaseListQuery = { page: 1, limit: 15 }, // Default limit 15
): Promise<PaginatedResponse<PreparationScreen>> => {
  const response = await ApiClientWrapper.get<
    PaginatedResponse<PreparationScreen>
  >(API_PATHS.PREPARATION_SCREENS, {
    ...filterOptions,
    page: paginationOptions.page,
    limit: paginationOptions.limit,
  });

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }

  // Verificar que la respuesta tenga la estructura esperada del backend paginado
  if (
    typeof response.data === 'object' &&
    'items' in response.data &&
    Array.isArray(response.data.items) &&
    'total' in response.data &&
    'page' in response.data &&
    'limit' in response.data
  ) {
    // Convertir de la estructura del backend a PaginatedResponse
    return {
      data: response.data.items,
      total: response.data.total,
      page: response.data.page,
      limit: response.data.limit,
      totalPages: Math.ceil(response.data.total / response.data.limit),
    };
  } else {
    throw new Error('Invalid response format from API');
  }
};

/**
 * Fetches a single preparation screen by its ID.
 * @param id - The UUID of the preparation screen.
 * @returns A promise that resolves to the PreparationScreen object.
 * @throws {ApiError} If the API request fails or the screen is not found.
 */
export const getPreparationScreenById = async (
  id: string,
): Promise<PreparationScreen> => {
  const response = await ApiClientWrapper.get<PreparationScreen>(
    API_PATHS.PREPARATION_SCREENS_BY_ID.replace(':id', id),
  );

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
  return response.data;
};

/**
 * Creates a new preparation screen.
 * @param data - The data for the new preparation screen (CreatePreparationScreenDto).
 * @returns A promise that resolves to the newly created PreparationScreen object.
 * @throws {ApiError} If the API request fails.
 */
export const createPreparationScreen = async (
  data: CreatePreparationScreenDto,
): Promise<PreparationScreen> => {
  const response = await ApiClientWrapper.post<PreparationScreen>(
    API_PATHS.PREPARATION_SCREENS,
    data,
  );

  if (!response.ok || !response.data) {
    // Si hay un ApiError original del interceptor, usarlo directamente
    if ((response as any).apiError instanceof ApiError) {
      throw (response as any).apiError;
    }

    // Si no, crear uno nuevo desde la respuesta
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
  return response.data;
};

/**
 * Updates an existing preparation screen.
 * @param id - The UUID of the preparation screen to update.
 * @param data - The data to update (UpdatePreparationScreenDto).
 * @returns A promise that resolves to the updated PreparationScreen object.
 * @throws {ApiError} If the API request fails or the screen is not found.
 */
export const updatePreparationScreen = async (
  id: string,
  data: UpdatePreparationScreenDto,
): Promise<PreparationScreen> => {
  const response = await ApiClientWrapper.patch<PreparationScreen>(
    API_PATHS.PREPARATION_SCREENS_BY_ID.replace(':id', id),
    data,
  );

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
  return response.data;
};

/**
 * Deletes a preparation screen by its ID (soft delete likely).
 * @param id - The UUID of the preparation screen to delete.
 * @returns A promise that resolves when the deletion is successful.
 * @throws {ApiError} If the API request fails.
 */
export const deletePreparationScreen = async (id: string): Promise<void> => {
  const response = await ApiClientWrapper.delete(
    API_PATHS.PREPARATION_SCREENS_BY_ID.replace(':id', id),
  );

  if (!response.ok) {
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
};

/**
 * Gets products associated with a preparation screen.
 * @param id - The UUID of the preparation screen.
 * @returns A promise that resolves to an array of products.
 * @throws {ApiError} If the API request fails.
 */
export const getPreparationScreenProducts = async (
  id: string,
): Promise<any[]> => {
  const response = await ApiClientWrapper.get<any[]>(
    API_PATHS.PREPARATION_SCREENS_PRODUCTS.replace(':id', id),
  );

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
  return response.data;
};

/**
 * Gets the complete menu with association information for a preparation screen.
 * @param id - The UUID of the preparation screen.
 * @returns A promise that resolves to the menu data with associations.
 * @throws {ApiError} If the API request fails.
 */
export const getMenuWithAssociations = async (id: string): Promise<any> => {
  const response = await ApiClientWrapper.get<any>(
    API_PATHS.PREPARATION_SCREENS_MENU_WITH_ASSOCIATIONS.replace(':id', id),
  );

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
  return response.data;
};

/**
 * Associates products with a preparation screen.
 * @param id - The UUID of the preparation screen.
 * @param productIds - Array of product IDs to associate.
 * @returns A promise that resolves to the updated preparation screen.
 * @throws {ApiError} If the API request fails.
 */
export const associateProducts = async (
  id: string,
  productIds: string[],
): Promise<PreparationScreen> => {
  const response = await ApiClientWrapper.post<PreparationScreen>(
    API_PATHS.PREPARATION_SCREENS_PRODUCTS.replace(':id', id),
    { productIds },
  );

  if (!response.ok || !response.data) {
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
  return response.data;
};

================
File: app/src/modules/printers/components/NumericField.tsx
================
import React, { useState, useEffect } from 'react';
import AnimatedLabelInput from '../../../app/components/common/AnimatedLabelInput';

interface NumericFieldProps {
  label: string;
  value: number | undefined;
  onChange: (value: number | undefined) => void;
  onBlur: () => void;
  error?: boolean;
  disabled?: boolean;
  defaultValue: number;
}

const NumericField: React.FC<NumericFieldProps> = ({
  label,
  value,
  onChange,
  onBlur,
  error,
  disabled,
  defaultValue,
}) => {
  const [displayValue, setDisplayValue] = useState(() =>
    value !== undefined ? String(value) : '',
  );
  const [isFocused, setIsFocused] = useState(false);

  // Sincronizar valor externo con display solo cuando no est√° enfocado
  useEffect(() => {
    if (!isFocused && value !== undefined) {
      setDisplayValue(String(value));
    }
  }, [value, isFocused]);

  const handleChangeText = (text: string) => {
    // Permitir solo n√∫meros
    const numericText = text.replace(/[^0-9]/g, '');
    setDisplayValue(numericText);

    if (numericText === '') {
      onChange(undefined);
    } else {
      const numValue = parseInt(numericText, 10);
      if (!isNaN(numValue)) {
        onChange(numValue);
      }
    }
  };

  const handleBlur = () => {
    setIsFocused(false);
    // Si no hay valor v√°lido, restaurar valor por defecto
    if (value === undefined || isNaN(Number(value))) {
      onChange(defaultValue);
      setDisplayValue(String(defaultValue));
    }
    onBlur();
  };

  const handleFocus = () => {
    setIsFocused(true);
  };

  return (
    <AnimatedLabelInput
      label={label}
      value={displayValue}
      onChangeText={handleChangeText}
      onBlur={handleBlur}
      onFocus={handleFocus}
      error={error}
      disabled={disabled}
      keyboardType="number-pad"
      containerStyle={{ marginBottom: 12 }}
    />
  );
};

export default NumericField;

================
File: app/src/modules/printers/components/PrinterAdvancedConfig.tsx
================
import React from 'react';
import { View, StyleSheet } from 'react-native';
import {
  Text,
  SegmentedButtons,
  HelperText,
  Switch,
  Card,
  Chip,
} from 'react-native-paper';
import { Controller, Control, FieldErrors } from 'react-hook-form';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { PrinterFormData } from '../schema/printer.schema';
import NumericField from './NumericField';

interface PrinterAdvancedConfigProps {
  control: Control<PrinterFormData>;
  errors: FieldErrors<PrinterFormData>;
  isSubmitting: boolean;
}

const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      marginTop: theme.spacing.m,
    },
    sectionTitle: {
      marginBottom: theme.spacing.m,
      marginTop: theme.spacing.l,
      color: theme.colors.primary,
      fontWeight: '600',
    },
    input: {
      marginBottom: theme.spacing.m,
    },
    switchContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      marginBottom: theme.spacing.m,
      paddingVertical: theme.spacing.s,
    },
    switchLabel: {
      color: theme.colors.onSurfaceVariant,
      marginRight: theme.spacing.m,
      fontSize: 16,
      flexShrink: 1,
    },
    helperText: {
      marginTop: -theme.spacing.s,
      marginBottom: theme.spacing.s,
    },
    segmentedButtons: {
      marginBottom: theme.spacing.m,
    },
    recommendationCard: {
      marginBottom: theme.spacing.m,
      padding: theme.spacing.m,
      backgroundColor: theme.colors.primaryContainer,
    },
    recommendationTitle: {
      fontWeight: '600',
      marginBottom: theme.spacing.xs,
      color: theme.colors.onPrimaryContainer,
    },
    recommendationRow: {
      flexDirection: 'row',
      alignItems: 'center',
      marginVertical: theme.spacing.xs,
    },
    recommendationText: {
      marginLeft: theme.spacing.s,
      color: theme.colors.onPrimaryContainer,
    },
    chip: {
      marginRight: theme.spacing.xs,
    },
  });

const PrinterAdvancedConfig: React.FC<PrinterAdvancedConfigProps> = ({
  control,
  errors,
  isSubmitting,
}) => {
  const theme = useAppTheme();
  const styles = getStyles(theme);

  return (
    <View style={styles.container}>
      <Text variant="titleMedium" style={styles.sectionTitle}>
        Configuraci√≥n del Papel
      </Text>

      {/* Recomendaciones */}
      <Card style={styles.recommendationCard}>
        <Card.Content>
          <Text variant="bodyMedium" style={styles.recommendationTitle}>
            Recomendaciones de configuraci√≥n:
          </Text>
          <View style={styles.recommendationRow}>
            <Chip compact style={styles.chip}>
              80mm
            </Chip>
            <Text variant="bodySmall" style={styles.recommendationText}>
              48 caracteres (normal) ‚Ä¢ 64 (comprimido)
            </Text>
          </View>
          <View style={styles.recommendationRow}>
            <Chip compact style={styles.chip}>
              58mm
            </Chip>
            <Text variant="bodySmall" style={styles.recommendationText}>
              32 caracteres (normal) ‚Ä¢ 42 (comprimido)
            </Text>
          </View>
        </Card.Content>
      </Card>

      {/* Ancho del papel */}
      <Controller
        name="paperWidth"
        control={control}
        render={({ field: { onChange, value } }) => (
          <View>
            <Text variant="bodyMedium" style={{ marginBottom: 8 }}>
              Ancho del papel
            </Text>
            <SegmentedButtons
              value={String(value)}
              onValueChange={(val) => onChange(Number(val))}
              buttons={[
                {
                  value: '58',
                  label: '58mm',
                  disabled: isSubmitting,
                },
                {
                  value: '80',
                  label: '80mm',
                  disabled: isSubmitting,
                },
              ]}
              style={styles.segmentedButtons}
            />
          </View>
        )}
      />

      {/* Caracteres por l√≠nea */}
      <Controller
        name="charactersPerLine"
        control={control}
        render={({ field: { onChange, onBlur, value } }) => (
          <NumericField
            label="Caracteres por l√≠nea"
            value={value}
            onChange={onChange}
            onBlur={onBlur}
            error={!!errors.charactersPerLine}
            disabled={isSubmitting}
            defaultValue={48}
          />
        )}
      />
      {errors.charactersPerLine && (
        <HelperText
          type="error"
          visible={!!errors.charactersPerLine}
          style={styles.helperText}
        >
          {errors.charactersPerLine.message}
        </HelperText>
      )}

      <HelperText type="info" visible={true} style={styles.helperText}>
        Ajusta seg√∫n el ancho real de impresi√≥n de tu impresora
      </HelperText>

      <Text variant="titleMedium" style={styles.sectionTitle}>
        Configuraci√≥n de Corte
      </Text>

      {/* Cortar papel */}
      <View style={styles.switchContainer}>
        <Text variant="bodyLarge" style={styles.switchLabel}>
          Cortar papel autom√°ticamente
        </Text>
        <Controller
          name="cutPaper"
          control={control}
          render={({ field: { onChange, value } }) => (
            <Switch
              value={value}
              onValueChange={onChange}
              disabled={isSubmitting}
            />
          )}
        />
      </View>

      {/* L√≠neas de avance */}
      <Controller
        name="feedLines"
        control={control}
        render={({ field: { onChange, onBlur, value } }) => (
          <NumericField
            label="L√≠neas de avance antes del corte"
            value={value}
            onChange={onChange}
            onBlur={onBlur}
            error={!!errors.feedLines}
            disabled={isSubmitting}
            defaultValue={3}
          />
        )}
      />
      {errors.feedLines && (
        <HelperText
          type="error"
          visible={!!errors.feedLines}
          style={styles.helperText}
        >
          {errors.feedLines.message}
        </HelperText>
      )}

      <HelperText type="info" visible={true} style={styles.helperText}>
        L√≠neas en blanco para que el ticket salga completamente (0-50)
      </HelperText>
    </View>
  );
};

export default PrinterAdvancedConfig;

================
File: app/src/modules/printers/components/PrinterDetailModal.tsx
================
import React from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Surface,
  IconButton,
  Divider,
  Button,
  Chip,
} from 'react-native-paper';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { ThermalPrinter } from '../types/printer.types';

interface PrinterDetailModalProps {
  visible: boolean;
  onDismiss: () => void;
  printer: ThermalPrinter | null;
  onEdit?: () => void;
  onDelete?: () => void;
  onTestPrint?: () => void;
  isDeleting?: boolean;
  isTestPrinting?: boolean;
}

const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    modalContent: {
      backgroundColor: theme.colors.background,
      borderRadius: theme.roundness * 3,
      margin: theme.spacing.l,
      maxHeight: '90%',
      overflow: 'hidden',
    },
    header: {
      backgroundColor: theme.colors.primary,
      padding: theme.spacing.l,
      paddingBottom: theme.spacing.m,
    },
    headerContent: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
    },
    headerTextContainer: {
      flex: 1,
    },
    headerTitle: {
      color: theme.colors.onPrimary,
      fontSize: 20,
      fontWeight: '700',
    },
    headerSubtitle: {
      color: theme.colors.onPrimary,
      opacity: 0.8,
      fontSize: 14,
      marginTop: 4,
    },
    closeButton: {
      margin: -theme.spacing.xs,
    },
    scrollView: {
      maxHeight: 400,
    },
    scrollContent: {
      padding: theme.spacing.l,
    },
    section: {
      marginBottom: theme.spacing.l,
    },
    sectionTitle: {
      fontSize: 14,
      fontWeight: '600',
      color: theme.colors.primary,
      marginBottom: theme.spacing.s,
      textTransform: 'uppercase',
      letterSpacing: 0.5,
    },
    infoRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingVertical: theme.spacing.s,
    },
    infoLabel: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    infoValue: {
      fontSize: 14,
      color: theme.colors.onSurface,
      fontWeight: '500',
      textAlign: 'right',
      flex: 1,
      marginLeft: theme.spacing.m,
    },
    statusContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
      marginBottom: theme.spacing.m,
    },
    statusChip: {
      paddingHorizontal: theme.spacing.xs,
    },
    activeChip: {
      backgroundColor: theme.colors.primaryContainer,
    },
    inactiveChip: {
      backgroundColor: theme.colors.errorContainer,
    },
    featuresGrid: {
      flexDirection: 'row',
      flexWrap: 'wrap',
      gap: theme.spacing.s,
      marginTop: theme.spacing.s,
    },
    featureCard: {
      padding: theme.spacing.m,
      borderRadius: theme.roundness * 2,
      backgroundColor: theme.colors.surfaceVariant,
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
      minWidth: '45%',
      flex: 1,
    },
    featureIcon: {
      backgroundColor: theme.colors.secondaryContainer,
      borderRadius: theme.roundness,
      padding: theme.spacing.xs,
    },
    featureText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      flex: 1,
    },
    divider: {
      marginVertical: theme.spacing.m,
    },
    testPrintButton: {
      marginBottom: theme.spacing.m,
      borderColor: theme.colors.primary,
    },
    footer: {
      padding: theme.spacing.l,
      paddingTop: 0,
      gap: theme.spacing.s,
    },
    footerButtons: {
      flexDirection: 'row',
      gap: theme.spacing.s,
    },
    footerButton: {
      flex: 1,
    },
    deleteButton: {
      borderColor: theme.colors.error,
    },
    emptyState: {
      padding: theme.spacing.xl,
      alignItems: 'center',
    },
    emptyText: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 16,
    },
  });

const PrinterDetailModal: React.FC<PrinterDetailModalProps> = ({
  visible,
  onDismiss,
  printer,
  onEdit,
  onDelete,
  onTestPrint,
  isDeleting = false,
  isTestPrinting = false,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => getStyles(theme), [theme]);

  if (!printer && visible) {
    return (
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onDismiss}
          contentContainerStyle={styles.modalContent}
        >
          <View style={styles.emptyState}>
            <Text style={styles.emptyText}>No se encontr√≥ la impresora</Text>
          </View>
        </Modal>
      </Portal>
    );
  }

  if (!printer) return null;

  const getConnectionInfo = () => {
    if (printer.connectionType === 'NETWORK') {
      return `${printer.ipAddress || 'N/A'}:${printer.port || 9100}`;
    }
    return printer.path || 'N/A';
  };

  const formatDate = (dateString?: string) => {
    if (!dateString) return 'N/A';
    return new Date(dateString).toLocaleDateString('es-ES', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalContent}
      >
        <View>
          <Surface style={styles.header}>
            <View style={styles.headerContent}>
              <View style={styles.headerTextContainer}>
                <Text style={styles.headerTitle}>{printer.name}</Text>
                <Text style={styles.headerSubtitle}>
                  {printer.connectionType} ‚Ä¢ {getConnectionInfo()}
                </Text>
              </View>
              <IconButton
                icon="close"
                size={24}
                iconColor={theme.colors.onPrimary}
                onPress={onDismiss}
                style={styles.closeButton}
              />
            </View>
          </Surface>

          <ScrollView
            style={styles.scrollView}
            contentContainerStyle={styles.scrollContent}
          >
            {/* Estado y caracter√≠sticas principales */}
            <View style={styles.section}>
              <View style={styles.statusContainer}>
                <Chip
                  mode="flat"
                  style={[
                    styles.statusChip,
                    printer.isActive ? styles.activeChip : styles.inactiveChip,
                  ]}
                  textStyle={{
                    color: printer.isActive
                      ? theme.colors.onPrimaryContainer
                      : theme.colors.onErrorContainer,
                  }}
                >
                  {printer.isActive ? 'Activa' : 'Inactiva'}
                </Chip>
                {printer.isDefaultPrinter && (
                  <Chip
                    mode="flat"
                    style={[styles.statusChip, styles.activeChip]}
                    icon="star"
                    textStyle={{ color: theme.colors.onPrimaryContainer }}
                  >
                    Predeterminada
                  </Chip>
                )}
              </View>

              <View style={styles.featuresGrid}>
                {printer.autoDeliveryPrint && (
                  <Surface style={styles.featureCard}>
                    <View style={styles.featureIcon}>
                      <IconButton
                        icon="home-export-outline"
                        size={16}
                        iconColor={theme.colors.onSecondaryContainer}
                        style={{ margin: 0 }}
                      />
                    </View>
                    <Text style={styles.featureText}>
                      Impresi√≥n autom√°tica para domicilio
                    </Text>
                  </Surface>
                )}
                {printer.autoPickupPrint && (
                  <Surface style={styles.featureCard}>
                    <View style={styles.featureIcon}>
                      <IconButton
                        icon="bag-checked"
                        size={16}
                        iconColor={theme.colors.onSecondaryContainer}
                        style={{ margin: 0 }}
                      />
                    </View>
                    <Text style={styles.featureText}>
                      Impresi√≥n autom√°tica para llevar
                    </Text>
                  </Surface>
                )}
              </View>
            </View>

            <Divider style={styles.divider} />

            {/* Informaci√≥n de conexi√≥n */}
            <View style={styles.section}>
              <Text style={styles.sectionTitle}>Informaci√≥n de Conexi√≥n</Text>

              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Tipo de conexi√≥n</Text>
                <Text style={styles.infoValue}>{printer.connectionType}</Text>
              </View>

              {printer.connectionType === 'NETWORK' && (
                <>
                  <View style={styles.infoRow}>
                    <Text style={styles.infoLabel}>Direcci√≥n IP</Text>
                    <Text style={styles.infoValue}>
                      {printer.ipAddress || 'N/A'}
                    </Text>
                  </View>
                  <View style={styles.infoRow}>
                    <Text style={styles.infoLabel}>Puerto</Text>
                    <Text style={styles.infoValue}>
                      {printer.port || 'N/A'}
                    </Text>
                  </View>
                  {printer.macAddress && (
                    <View style={styles.infoRow}>
                      <Text style={styles.infoLabel}>Direcci√≥n MAC</Text>
                      <Text style={styles.infoValue}>{printer.macAddress}</Text>
                    </View>
                  )}
                </>
              )}

              {printer.connectionType !== 'NETWORK' && printer.path && (
                <View style={styles.infoRow}>
                  <Text style={styles.infoLabel}>Ruta/ID</Text>
                  <Text style={styles.infoValue}>{printer.path}</Text>
                </View>
              )}
            </View>

            <Divider style={styles.divider} />

            {/* Configuraci√≥n del papel */}
            <View style={styles.section}>
              <Text style={styles.sectionTitle}>Configuraci√≥n del Papel</Text>

              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Ancho del papel</Text>
                <Text style={styles.infoValue}>{printer.paperWidth}mm</Text>
              </View>
              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Caracteres por l√≠nea</Text>
                <Text style={styles.infoValue}>
                  {printer.charactersPerLine}
                </Text>
              </View>
              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Corte autom√°tico</Text>
                <Text style={styles.infoValue}>
                  {printer.cutPaper ? 'S√≠' : 'No'}
                </Text>
              </View>
              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>L√≠neas de avance</Text>
                <Text style={styles.infoValue}>{printer.feedLines}</Text>
              </View>
            </View>

            <Divider style={styles.divider} />

            {/* Informaci√≥n adicional */}
            <View style={styles.section}>
              <Text style={styles.sectionTitle}>Informaci√≥n Adicional</Text>

              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Creada</Text>
                <Text style={styles.infoValue}>
                  {formatDate(printer.createdAt)}
                </Text>
              </View>
              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>√öltima actualizaci√≥n</Text>
                <Text style={styles.infoValue}>
                  {formatDate(printer.updatedAt)}
                </Text>
              </View>
            </View>
          </ScrollView>

          <View style={styles.footer}>
            {onTestPrint && (
              <Button
                mode="outlined"
                icon="printer-check"
                onPress={onTestPrint}
                loading={isTestPrinting}
                disabled={isTestPrinting || isDeleting}
                style={styles.testPrintButton}
              >
                Imprimir Ticket de Prueba
              </Button>
            )}

            <View style={styles.footerButtons}>
              {onEdit && (
                <Button
                  mode="contained-tonal"
                  onPress={onEdit}
                  disabled={isDeleting || isTestPrinting}
                  style={styles.footerButton}
                >
                  Editar
                </Button>
              )}
              {onDelete && (
                <Button
                  mode="outlined"
                  onPress={onDelete}
                  loading={isDeleting}
                  disabled={isDeleting || isTestPrinting}
                  style={[styles.footerButton, styles.deleteButton]}
                  textColor={theme.colors.error}
                >
                  Eliminar
                </Button>
              )}
            </View>
          </View>
        </View>
      </Modal>
    </Portal>
  );
};

export default PrinterDetailModal;

================
File: app/src/modules/printers/components/PrinterFormModal.tsx
================
import React, { useEffect, useMemo } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  Switch,
  HelperText,
  ActivityIndicator,
  RadioButton,
} from 'react-native-paper';
import { useForm, Controller, SubmitHandler } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';

import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import {
  PrinterFormData,
  printerFormSchema,
  ThermalPrinter,
  CreateThermalPrinterDto,
  UpdateThermalPrinterDto,
} from '../schema/printer.schema';
import {
  useCreatePrinterMutation,
  useUpdatePrinterMutation,
} from '../hooks/usePrintersQueries';
import AnimatedLabelInput from '../../../app/components/common/AnimatedLabelInput';
import PrinterAdvancedConfig from './PrinterAdvancedConfig';

interface PrinterFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  editingItem: ThermalPrinter | null;
  initialDataFromDiscovery?: Partial<PrinterFormData>;
}

const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    modalSurface: {
      padding: 0,
      margin: theme.spacing.l,
      borderRadius: theme.roundness * 2,
      elevation: 4,
      backgroundColor: theme.colors.background,
      maxHeight: '90%',
      overflow: 'hidden',
    },
    modalHeader: {
      backgroundColor: theme.colors.primary,
      paddingVertical: theme.spacing.m,
      paddingHorizontal: theme.spacing.l,
    },
    formContainer: {
      maxHeight: '100%',
    },
    scrollViewContent: {
      padding: theme.spacing.l,
      paddingBottom: theme.spacing.xl,
    },
    modalTitle: {
      color: theme.colors.onPrimary,
      fontWeight: '700',
      textAlign: 'center',
    },
    input: {
      marginBottom: theme.spacing.m,
    },
    switchLabel: {
      color: theme.colors.onSurfaceVariant,
      marginRight: theme.spacing.m,
      fontSize: 16,
      flexShrink: 1,
    },
    switchComponentContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      marginBottom: theme.spacing.m,
      paddingVertical: theme.spacing.s,
    },
    radioGroupContainer: {
      marginBottom: theme.spacing.m,
    },
    radioGroupLabel: {
      marginBottom: theme.spacing.xs,
      color: theme.colors.onSurfaceVariant,
      fontSize: 12,
    },
    radioGroupHorizontal: {
      flexDirection: 'row',
      justifyContent: 'space-around',
      flexWrap: 'wrap',
    },
    radioButtonItem: {
      flexDirection: 'row',
      alignItems: 'center',
      marginRight: theme.spacing.s,
      paddingVertical: 0,
    },
    radioLabel: {
      fontSize: 14,
    },
    modalActions: {
      flexDirection: 'row',
      justifyContent: 'center',
      paddingVertical: theme.spacing.m,
      paddingHorizontal: theme.spacing.l,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
      gap: theme.spacing.m,
    },
    formButton: {
      borderRadius: theme.roundness,
      paddingHorizontal: theme.spacing.xs,
      flex: 1,
      maxWidth: 200,
    },
    cancelButton: {},
    loadingOverlay: {
      ...StyleSheet.absoluteFillObject,
      backgroundColor: 'rgba(0, 0, 0, 0.3)',
      justifyContent: 'center',
      alignItems: 'center',
      borderRadius: theme.roundness * 2,
      zIndex: 10,
    },
    helperText: {
      marginTop: -theme.spacing.s,
      marginBottom: theme.spacing.s,
    },
  });

const PrinterFormModal: React.FC<PrinterFormModalProps> = ({
  visible,
  onDismiss,
  editingItem,
  initialDataFromDiscovery,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => getStyles(theme), [theme]);
  const isEditing = !!editingItem;

  const createMutation = useCreatePrinterMutation();
  const updateMutation = useUpdatePrinterMutation();

  const isSubmitting = createMutation.isPending || updateMutation.isPending;

  const defaultValues = useMemo((): PrinterFormData => {
    const baseDefaults: PrinterFormData = {
      name: '',
      connectionType: 'NETWORK',
      ipAddress: undefined,
      port: undefined,
      path: undefined,
      isActive: true,
      macAddress: undefined,
      isDefaultPrinter: false,
      autoDeliveryPrint: false,
      autoPickupPrint: false,
      paperWidth: 80,
      charactersPerLine: 48,
      cutPaper: true,
      feedLines: 3,
    };
    // Aplicar valores iniciales si se est√° editando
    if (isEditing && editingItem) {
      return {
        name: editingItem.name,
        connectionType: editingItem.connectionType,
        ipAddress: editingItem.ipAddress ?? undefined,
        port: editingItem.port ?? undefined,
        path: editingItem.path ?? undefined,
        isActive: editingItem.isActive,
        macAddress: editingItem.macAddress ?? undefined,
        isDefaultPrinter: editingItem.isDefaultPrinter ?? false,
        autoDeliveryPrint: editingItem.autoDeliveryPrint ?? false,
        autoPickupPrint: editingItem.autoPickupPrint ?? false,
        paperWidth: editingItem.paperWidth ?? 80,
        charactersPerLine: editingItem.charactersPerLine ?? 48,
        cutPaper: editingItem.cutPaper ?? true,
        feedLines: editingItem.feedLines ?? 3,
      };
    }
    // Aplicar valores desde descubrimiento si se est√° creando y existen
    if (!isEditing && initialDataFromDiscovery) {
      return {
        ...baseDefaults,
        name:
          initialDataFromDiscovery.name ||
          `Impresora ${initialDataFromDiscovery.ipAddress}`,
        connectionType: 'NETWORK',
        ipAddress: initialDataFromDiscovery.ipAddress,
        port: initialDataFromDiscovery.port,
        macAddress: initialDataFromDiscovery.macAddress,
      };
    }
    return baseDefaults;
  }, [editingItem, isEditing, initialDataFromDiscovery]);

  const {
    control,
    handleSubmit,
    reset,
    watch,
    formState: { errors },
  } = useForm<PrinterFormData>({
    resolver: zodResolver(printerFormSchema),
    defaultValues: defaultValues,
  });

  const connectionType = watch('connectionType');

  useEffect(() => {
    if (visible) {
      reset(defaultValues);
    }
  }, [visible, editingItem, initialDataFromDiscovery, reset, defaultValues]);

  const onSubmit: SubmitHandler<PrinterFormData> = async (formData) => {
    const dataToSend = { ...formData };
    if (dataToSend.connectionType === 'NETWORK') {
      dataToSend.path = undefined;
    } else {
      dataToSend.ipAddress = undefined;
      dataToSend.port = undefined;
    }
    if (dataToSend.port && typeof dataToSend.port === 'string') {
      dataToSend.port = parseInt(dataToSend.port, 10);
      if (isNaN(dataToSend.port)) {
        dataToSend.port = undefined;
      }
    }

    try {
      if (isEditing && editingItem) {
        await updateMutation.mutateAsync({
          id: editingItem.id,
          data: dataToSend as UpdateThermalPrinterDto,
        });
      } else {
        await createMutation.mutateAsync(dataToSend as CreateThermalPrinterDto);
      }
      onDismiss();
    } catch (error) {}
  };

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalSurface}
        dismissable={!isSubmitting}
      >
        <View style={styles.formContainer}>
          <View style={styles.modalHeader}>
            <Text variant="titleLarge" style={styles.modalTitle}>
              {isEditing ? 'Editar Impresora' : 'Nueva Impresora'}
            </Text>
          </View>

          <ScrollView contentContainerStyle={styles.scrollViewContent}>
            {/* Nombre */}
            <Controller
              name="name"
              control={control}
              render={({ field: { onChange, onBlur, value } }) => (
                <AnimatedLabelInput
                  label="Nombre *"
                  value={value}
                  onChangeText={onChange}
                  onBlur={onBlur}
                  error={!!errors.name}
                  disabled={isSubmitting}
                  containerStyle={styles.input}
                />
              )}
            />
            {errors.name && (
              <HelperText
                type="error"
                visible={!!errors.name}
                style={styles.helperText}
              >
                {errors.name.message}
              </HelperText>
            )}

            {/* Tipo de Conexi√≥n */}
            <View style={styles.radioGroupContainer}>
              <Text style={styles.radioGroupLabel}>Tipo de Conexi√≥n *</Text>
              <Controller
                name="connectionType"
                control={control}
                render={({ field: { onChange, value } }) => (
                  <RadioButton.Group onValueChange={onChange} value={value}>
                    <View style={styles.radioGroupHorizontal}>
                      <RadioButton.Item
                        label="Red"
                        value="NETWORK"
                        style={styles.radioButtonItem}
                        labelStyle={styles.radioLabel}
                        position="leading"
                        disabled={isSubmitting}
                      />
                      <RadioButton.Item
                        label="USB"
                        value="USB"
                        style={styles.radioButtonItem}
                        labelStyle={styles.radioLabel}
                        position="leading"
                        disabled={true}
                      />
                    </View>
                  </RadioButton.Group>
                )}
              />
              {errors.connectionType && (
                <HelperText
                  type="error"
                  visible={!!errors.connectionType}
                  style={styles.helperText}
                >
                  {errors.connectionType.message}
                </HelperText>
              )}
            </View>

            {/* Campos Condicionales */}
            {connectionType === 'NETWORK' && (
              <>
                <Controller
                  name="ipAddress"
                  control={control}
                  render={({ field: { onChange, onBlur, value } }) => (
                    <AnimatedLabelInput
                      label="Direcci√≥n IP *"
                      value={value ?? ''}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.ipAddress}
                      disabled={isSubmitting}
                      containerStyle={styles.input}
                      keyboardType="decimal-pad"
                    />
                  )}
                />
                {errors.ipAddress && (
                  <HelperText
                    type="error"
                    visible={!!errors.ipAddress}
                    style={styles.helperText}
                  >
                    {errors.ipAddress.message}
                  </HelperText>
                )}

                <Controller
                  name="port"
                  control={control}
                  render={({ field: { onChange, onBlur, value } }) => (
                    <AnimatedLabelInput
                      label="Puerto *"
                      value={
                        value !== undefined && value !== null
                          ? String(value)
                          : ''
                      }
                      onChangeText={(text) => {
                        if (!text) {
                          onChange(undefined);
                          return;
                        }
                        const parsedPort = parseInt(text, 10);
                        onChange(isNaN(parsedPort) ? undefined : parsedPort);
                      }}
                      onBlur={onBlur}
                      error={!!errors.port}
                      disabled={isSubmitting}
                      containerStyle={styles.input}
                      keyboardType="number-pad"
                    />
                  )}
                />
                {errors.port && (
                  <HelperText
                    type="error"
                    visible={!!errors.port}
                    style={styles.helperText}
                  >
                    {errors.port.message}
                  </HelperText>
                )}

                <Controller
                  name="macAddress"
                  control={control}
                  render={({ field: { onChange, onBlur, value } }) => (
                    <AnimatedLabelInput
                      label="Direcci√≥n MAC (Opcional)"
                      value={value ?? ''}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.macAddress}
                      disabled={isSubmitting}
                      containerStyle={styles.input}
                      autoCapitalize="characters"
                    />
                  )}
                />
                {errors.macAddress && (
                  <HelperText
                    type="error"
                    visible={!!errors.macAddress}
                    style={styles.helperText}
                  >
                    {errors.macAddress.message}
                  </HelperText>
                )}
              </>
            )}

            {connectionType !== 'NETWORK' && (
              <>
                <Controller
                  name="path"
                  control={control}
                  render={({ field: { onChange, onBlur, value } }) => (
                    <AnimatedLabelInput
                      label="Ruta / Identificador *"
                      value={value ?? ''}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.path}
                      disabled={isSubmitting}
                      containerStyle={styles.input}
                      placeholder={
                        connectionType === 'USB'
                          ? '/dev/usb/lp0'
                          : connectionType === 'SERIAL'
                            ? '/dev/ttyS0'
                            : 'Direcci√≥n BT'
                      }
                    />
                  )}
                />
                {errors.path && (
                  <HelperText
                    type="error"
                    visible={!!errors.path}
                    style={styles.helperText}
                  >
                    {errors.path.message}
                  </HelperText>
                )}
              </>
            )}

            {/* Estado Activo */}
            <View style={styles.switchComponentContainer}>
              <Text variant="bodyLarge" style={styles.switchLabel}>
                Activa
              </Text>
              <Controller
                name="isActive"
                control={control}
                render={({ field: { onChange, value } }) => (
                  <Switch
                    value={value}
                    onValueChange={onChange}
                    disabled={isSubmitting}
                  />
                )}
              />
            </View>
            {errors.isActive && (
              <HelperText
                type="error"
                visible={!!errors.isActive}
                style={styles.helperText}
              >
                {errors.isActive.message}
              </HelperText>
            )}

            {/* Configuraci√≥n de Impresi√≥n Autom√°tica */}
            <View style={styles.switchComponentContainer}>
              <Text variant="bodyLarge" style={styles.switchLabel}>
                Impresora Predeterminada
              </Text>
              <Controller
                name="isDefaultPrinter"
                control={control}
                render={({ field: { onChange, value } }) => (
                  <Switch
                    value={value}
                    onValueChange={onChange}
                    disabled={isSubmitting}
                  />
                )}
              />
            </View>

            <View style={styles.switchComponentContainer}>
              <Text variant="bodyLarge" style={styles.switchLabel}>
                Imprimir Autom√°ticamente Domicilio
              </Text>
              <Controller
                name="autoDeliveryPrint"
                control={control}
                render={({ field: { onChange, value } }) => (
                  <Switch
                    value={value}
                    onValueChange={onChange}
                    disabled={isSubmitting}
                  />
                )}
              />
            </View>

            <View style={styles.switchComponentContainer}>
              <Text variant="bodyLarge" style={styles.switchLabel}>
                Imprimir Autom√°ticamente Para Llevar
              </Text>
              <Controller
                name="autoPickupPrint"
                control={control}
                render={({ field: { onChange, value } }) => (
                  <Switch
                    value={value}
                    onValueChange={onChange}
                    disabled={isSubmitting}
                  />
                )}
              />
            </View>

            {/* Configuraci√≥n avanzada */}
            <PrinterAdvancedConfig
              control={control}
              errors={errors}
              isSubmitting={isSubmitting}
            />
          </ScrollView>

          {isSubmitting && (
            <View style={styles.loadingOverlay}>
              <ActivityIndicator
                animating={true}
                size="large"
                color={theme.colors.primary}
              />
            </View>
          )}

          <View style={styles.modalActions}>
            <Button
              mode="outlined"
              onPress={onDismiss}
              style={[styles.formButton, styles.cancelButton]}
              disabled={isSubmitting}
            >
              Cancelar
            </Button>
            <Button
              mode="contained"
              onPress={handleSubmit(onSubmit)}
              loading={isSubmitting}
              disabled={isSubmitting}
              style={styles.formButton}
            >
              {isEditing ? 'Guardar' : 'Crear'}
            </Button>
          </View>
        </View>
      </Modal>
    </Portal>
  );
};

export default PrinterFormModal;

================
File: app/src/modules/printers/schema/printer.schema.ts
================
import { z } from 'zod';
import { baseListQuerySchema } from '../../../app/types/query.types';

export const PrinterConnectionTypeSchema = z.enum([
  'NETWORK',
  'USB',
  'SERIAL',
  'BLUETOOTH',
]);
export type PrinterConnectionType = z.infer<typeof PrinterConnectionTypeSchema>;

const macRegex = /^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$/i;

export const thermalPrinterSchema = z.object({
  id: z.string().uuid(),
  name: z.string(),
  connectionType: PrinterConnectionTypeSchema,
  ipAddress: z.string().ip({ version: 'v4' }).nullable(),
  port: z.number().int().positive().nullable(),
  path: z.string().nullable(),
  isActive: z.boolean(),
  macAddress: z.string().regex(macRegex, 'MAC inv√°lida').nullable().optional(),
  isDefaultPrinter: z.boolean().optional().default(false),
  autoDeliveryPrint: z.boolean().optional().default(false),
  autoPickupPrint: z.boolean().optional().default(false),
  paperWidth: z.number().optional().default(80),
  charactersPerLine: z.number().optional().default(48),
  cutPaper: z.boolean().optional().default(true),
  feedLines: z.number().optional().default(3),
  createdAt: z.string().datetime().optional(),
  updatedAt: z.string().datetime().optional(),
  deletedAt: z.string().datetime().nullable().optional(),
});

export type ThermalPrinter = z.infer<typeof thermalPrinterSchema>;

const thermalPrinterDtoObjectSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido').max(100),
  connectionType: PrinterConnectionTypeSchema,
  ipAddress: z
    .string()
    .ip({ version: 'v4', message: 'IP inv√°lida' })
    .optional(),
  port: z.coerce
    .number()
    .int()
    .positive('El puerto debe ser un n√∫mero positivo')
    .optional(),
  path: z.string().optional(),
  isActive: z.boolean().optional().default(true),
  macAddress: z.string().regex(macRegex, 'MAC inv√°lida').optional(),
  isDefaultPrinter: z.boolean().optional().default(false),
  autoDeliveryPrint: z.boolean().optional().default(false),
  autoPickupPrint: z.boolean().optional().default(false),
  paperWidth: z
    .number()
    .min(58, 'El ancho del papel debe ser de al menos 58mm')
    .optional()
    .default(80),
  charactersPerLine: z
    .number()
    .min(32, 'Debe tener al menos 32 caracteres por l√≠nea')
    .optional()
    .default(48),
  cutPaper: z.boolean().optional().default(true),
  feedLines: z
    .number()
    .min(0, 'No puede ser menor a 0 l√≠neas')
    .max(50, 'No puede ser mayor a 50 l√≠neas')
    .optional()
    .default(3),
});

const refinePrinterDto = (
  data: Partial<z.infer<typeof thermalPrinterDtoObjectSchema>>,
  ctx: z.RefinementCtx,
) => {
  if (data.connectionType === undefined) return;

  if (data.connectionType === 'NETWORK') {
    if (!data.ipAddress) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'La direcci√≥n IP es requerida para conexi√≥n NETWORK',
        path: ['ipAddress'],
      });
    }
    if (!data.port) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'El puerto es requerido para conexi√≥n NETWORK',
        path: ['port'],
      });
    }
    if (data.path !== undefined && data.path !== null) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'La ruta debe estar vac√≠a para conexi√≥n NETWORK',
        path: ['path'],
      });
    }
  } else {
    if (!data.path) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message:
          'La ruta/identificador es requerido para este tipo de conexi√≥n',
        path: ['path'],
      });
    }
    if (data.ipAddress !== undefined && data.ipAddress !== null) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'La IP debe estar vac√≠a para este tipo de conexi√≥n',
        path: ['ipAddress'],
      });
    }
    if (data.port !== undefined && data.port !== null) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'El puerto debe estar vac√≠o para este tipo de conexi√≥n',
        path: ['port'],
      });
    }
  }
};

export const createThermalPrinterDtoSchema =
  thermalPrinterDtoObjectSchema.superRefine(refinePrinterDto);

export type CreateThermalPrinterDto = z.infer<
  typeof createThermalPrinterDtoSchema
>;

export const updateThermalPrinterDtoSchema = thermalPrinterDtoObjectSchema
  .partial()
  .superRefine(refinePrinterDto);

export type UpdateThermalPrinterDto = z.infer<
  typeof updateThermalPrinterDtoSchema
>;

export const findAllThermalPrintersFilterSchema = baseListQuerySchema.extend({
  name: z.string().optional(),
  connectionType: PrinterConnectionTypeSchema.optional(),
  isActive: z.boolean().optional(),
});

export type FindAllThermalPrintersDto = z.infer<
  typeof findAllThermalPrintersFilterSchema
>;

export const printerFormSchema = createThermalPrinterDtoSchema;
export type PrinterFormData = z.input<typeof printerFormSchema>;

export const discoveredPrinterSchema = z.object({
  ip: z.string().ip({ version: 'v4' }),
  port: z.number().int().positive(),
  name: z.string().optional(),
  model: z.string().optional(),
  type: z.string(),
  mac: z.string().regex(macRegex, 'MAC inv√°lida').optional(),
});

export type DiscoveredPrinter = z.infer<typeof discoveredPrinterSchema>;

================
File: app/src/modules/receipts/hooks/useReceiptsQueries.ts
================
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import {
  receiptService,
  receiptQueryOptions,
} from '../services/receiptService';
import { useSnackbarStore } from '@/app/store/snackbarStore';

export const useReceipts = (filters?: {
  startDate?: string;
  endDate?: string;
  orderType?: string;
}) => {
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const query = useQuery({
    ...receiptQueryOptions.receipts(filters || {}),
  });

  // Manejar errores
  if (query.error) {
    showSnackbar({
      message: query.error.message || 'Error al cargar los recibos',
      type: 'error',
    });
  }

  return query;
};

export const useReceipt = (id: string) => {
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const query = useQuery({
    ...receiptQueryOptions.receipt(id),
  });

  // Manejar errores
  if (query.error) {
    showSnackbar({
      message: query.error.message || 'Error al cargar el recibo',
      type: 'error',
    });
  }

  return query;
};

export const useRecoverOrder = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: (orderId: string) => receiptService.recoverOrder(orderId),
    onSuccess: () => {
      // Invalidar todas las queries relacionadas
      queryClient.invalidateQueries({ queryKey: ['receipts'] });
      queryClient.invalidateQueries({ queryKey: ['orders'] });
      showSnackbar({
        message: 'Orden recuperada exitosamente',
        type: 'success',
      });
    },
    onError: (error: Error) => {
      showSnackbar({
        message: error.message || 'Error al recuperar la orden',
        type: 'error',
      });
    },
  });
};

================
File: app/src/modules/restaurantConfig/components/BusinessHoursForm.tsx
================
import React from 'react';
import { View, StyleSheet, TouchableOpacity } from 'react-native';
import { Text, Switch, Chip, Card } from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import DateTimePickerSafe from '@/app/components/DateTimePickerSafe';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import {
  BusinessHours,
  CreateBusinessHoursDto,
} from '../types/restaurantConfig.types';

interface BusinessHoursFormProps {
  businessHours: BusinessHours[] | CreateBusinessHoursDto[];
  isEditing: boolean;
  onChange: (businessHours: CreateBusinessHoursDto[]) => void;
}

const DAYS_OF_WEEK = [
  'Domingo',
  'Lunes',
  'Martes',
  'Mi√©rcoles',
  'Jueves',
  'Viernes',
  'S√°bado',
];

const BusinessHoursForm: React.FC<BusinessHoursFormProps> = ({
  businessHours,
  isEditing,
  onChange,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);

  const [showTimePicker, setShowTimePicker] = React.useState(false);
  const [currentPickerConfig, setCurrentPickerConfig] = React.useState<{
    dayIndex: number;
    type: 'opening' | 'closing';
    currentDate: Date;
  } | null>(null);

  // Initialize business hours if empty
  const initializedHours = React.useMemo(() => {
    if (businessHours.length === 0) {
      return DAYS_OF_WEEK.map((_, index) => ({
        dayOfWeek: index,
        openingTime: '09:00',
        closingTime: '22:00',
        isClosed: false,
        closesNextDay: false,
      }));
    }

    // Asegurar que closesNextDay est√© calculado para cada horario
    return businessHours.map((hour) => {
      if (hour.openingTime && hour.closingTime && !hour.isClosed) {
        const [openHour, openMin] = hour.openingTime.split(':').map(Number);
        const [closeHour, closeMin] = hour.closingTime.split(':').map(Number);

        const closesNextDay =
          closeHour < openHour ||
          (closeHour === openHour && closeMin < openMin);

        return { ...hour, closesNextDay };
      }
      return { ...hour, closesNextDay: false };
    });
  }, [businessHours]);

  // Funci√≥n para detectar conflictos de horarios
  const checkScheduleConflict = (dayIndex: number): string | null => {
    const currentDay = initializedHours.find((h) => h.dayOfWeek === dayIndex);
    if (!currentDay || currentDay.isClosed || !currentDay.openingTime) {
      return null;
    }

    // Verificar si el d√≠a anterior cierra despu√©s de medianoche
    const previousDayIndex = dayIndex === 0 ? 6 : dayIndex - 1;
    const previousDay = initializedHours.find(
      (h) => h.dayOfWeek === previousDayIndex,
    );

    if (
      !previousDay ||
      previousDay.isClosed ||
      !previousDay.closesNextDay ||
      !previousDay.closingTime
    ) {
      return null;
    }

    // Comparar horarios
    const [currentOpenHour, currentOpenMin] = currentDay.openingTime
      .split(':')
      .map(Number);
    const [prevCloseHour, prevCloseMin] = previousDay.closingTime
      .split(':')
      .map(Number);

    const currentOpenMinutes = currentOpenHour * 60 + currentOpenMin;
    const prevCloseMinutes = prevCloseHour * 60 + prevCloseMin;

    // Si el d√≠a actual abre antes o exactamente cuando cierre el d√≠a anterior
    if (currentOpenMinutes <= prevCloseMinutes) {
      return `Conflicto: ${DAYS_OF_WEEK[previousDayIndex]} cierra a las ${previousDay.closingTime}. Debe haber al menos 1 minuto de diferencia`;
    }

    return null;
  };

  const handleTimeChange = (
    dayIndex: number,
    type: 'opening' | 'closing',
    time: string | null,
  ) => {
    if (!onChange || !isEditing) return;

    const updatedHours = [...initializedHours];
    const hourIndex = updatedHours.findIndex((h) => h.dayOfWeek === dayIndex);

    if (hourIndex !== -1 && time !== null) {
      if (type === 'opening') {
        updatedHours[hourIndex].openingTime = time;
      } else {
        updatedHours[hourIndex].closingTime = time;
      }

      // Detectar autom√°ticamente si cierra al d√≠a siguiente
      const hour = updatedHours[hourIndex];
      if (hour.openingTime && hour.closingTime) {
        const [openHour, openMin] = hour.openingTime.split(':').map(Number);
        const [closeHour, closeMin] = hour.closingTime.split(':').map(Number);

        // Si la hora de cierre es menor que la de apertura, cierra al d√≠a siguiente
        hour.closesNextDay =
          closeHour < openHour ||
          (closeHour === openHour && closeMin < openMin);
      } else {
        hour.closesNextDay = false;
      }

      onChange(updatedHours as CreateBusinessHoursDto[]);
    }
  };

  const handleClosedChange = (dayIndex: number, isClosed: boolean) => {
    if (!onChange || !isEditing) return;

    const updatedHours = [...initializedHours];
    const hourIndex = updatedHours.findIndex((h) => h.dayOfWeek === dayIndex);

    if (hourIndex !== -1) {
      updatedHours[hourIndex].isClosed = isClosed;
      if (isClosed) {
        updatedHours[hourIndex].openingTime = null;
        updatedHours[hourIndex].closingTime = null;
      }
      onChange(updatedHours as CreateBusinessHoursDto[]);
    }
  };

  const formatTimeForDisplay = (
    timeString: string | null | undefined,
  ): string => {
    if (!timeString) return '';
    // Si el string tiene segundos (formato HH:MM:SS), mostrar solo HH:MM
    if (timeString.length > 5) {
      return timeString.substring(0, 5);
    }
    return timeString;
  };

  const openTimePicker = (dayIndex: number, type: 'opening' | 'closing') => {
    if (!isEditing) return;

    const dayHours = initializedHours.find((h) => h.dayOfWeek === dayIndex);
    const currentTimeString =
      dayHours?.[type === 'opening' ? 'openingTime' : 'closingTime'];

    const date = new Date();
    if (currentTimeString) {
      const [hours, minutes] = currentTimeString.split(':').map(Number);
      date.setHours(hours, minutes, 0, 0);
    } else {
      // Default times
      date.setHours(type === 'opening' ? 9 : 22, 0, 0, 0);
    }

    setCurrentPickerConfig({ dayIndex, type, currentDate: date });
    setShowTimePicker(true);
  };

  const handleTimeConfirm = (date: Date) => {
    setShowTimePicker(false);

    if (currentPickerConfig && onChange) {
      const hours = date.getHours().toString().padStart(2, '0');
      const minutes = date.getMinutes().toString().padStart(2, '0');
      const timeString = `${hours}:${minutes}`;

      handleTimeChange(
        currentPickerConfig.dayIndex,
        currentPickerConfig.type,
        timeString,
      );
    }
    setCurrentPickerConfig(null);
  };

  const handleTimeCancel = () => {
    setShowTimePicker(false);
    setCurrentPickerConfig(null);
  };

  return (
    <>
      <View style={styles.container}>
        {DAYS_OF_WEEK.map((day, index) => {
          const dayHours = initializedHours.find(
            (h) => h.dayOfWeek === index,
          ) || {
            dayOfWeek: index,
            openingTime: null,
            closingTime: null,
            isClosed: false,
          };

          return (
            <Card key={index} style={styles.dayCard} mode="elevated">
              <View style={styles.dayHeader}>
                <Text style={styles.dayName}>{day}</Text>
                <View style={styles.dayActions}>
                  <Switch
                    value={!dayHours.isClosed}
                    onValueChange={(value) => {
                      if (isEditing && onChange) {
                        handleClosedChange(index, !value);
                      }
                    }}
                    disabled={!isEditing}
                    color={theme.colors.primary}
                  />
                </View>
              </View>

              {!dayHours.isClosed ? (
                <View style={styles.timeContainer}>
                  <TouchableOpacity
                    style={[
                      styles.timeButton,
                      !isEditing && styles.timeButtonDisabled,
                    ]}
                    onPress={() =>
                      isEditing && openTimePicker(index, 'opening')
                    }
                    disabled={!isEditing}
                  >
                    <View style={styles.timeButtonContent}>
                      <MaterialCommunityIcons
                        name="clock-outline"
                        size={20}
                        color={
                          !isEditing
                            ? theme.colors.onSurfaceDisabled
                            : theme.colors.primary
                        }
                      />
                      <View style={styles.timeTextContainer}>
                        <Text
                          style={[
                            styles.timeLabel,
                            !isEditing && styles.timeLabelDisabled,
                          ]}
                        >
                          Apertura
                        </Text>
                        <Text
                          style={[
                            styles.timeValue,
                            !isEditing && styles.timeValueDisabled,
                          ]}
                        >
                          {formatTimeForDisplay(dayHours.openingTime) ||
                            '--:--'}
                        </Text>
                      </View>
                    </View>
                  </TouchableOpacity>

                  <MaterialCommunityIcons
                    name="arrow-right"
                    size={24}
                    color={
                      !isEditing
                        ? theme.colors.onSurfaceDisabled
                        : theme.colors.onSurfaceVariant
                    }
                    style={styles.arrow}
                  />

                  <TouchableOpacity
                    style={[
                      styles.timeButton,
                      !isEditing && styles.timeButtonDisabled,
                    ]}
                    onPress={() =>
                      isEditing && openTimePicker(index, 'closing')
                    }
                    disabled={!isEditing}
                  >
                    <View style={styles.timeButtonContent}>
                      <MaterialCommunityIcons
                        name="clock-check-outline"
                        size={20}
                        color={
                          !isEditing
                            ? theme.colors.onSurfaceDisabled
                            : theme.colors.primary
                        }
                      />
                      <View style={styles.timeTextContainer}>
                        <Text
                          style={[
                            styles.timeLabel,
                            !isEditing && styles.timeLabelDisabled,
                          ]}
                        >
                          Cierre
                        </Text>
                        <Text
                          style={[
                            styles.timeValue,
                            !isEditing && styles.timeValueDisabled,
                          ]}
                        >
                          {formatTimeForDisplay(dayHours.closingTime) ||
                            '--:--'}
                        </Text>
                      </View>
                      {dayHours.closesNextDay && (
                        <View style={styles.nextDayBadge}>
                          <MaterialCommunityIcons
                            name="moon-waning-crescent"
                            size={12}
                            color={theme.colors.onPrimaryContainer}
                          />
                        </View>
                      )}
                    </View>
                  </TouchableOpacity>
                </View>
              ) : (
                <View style={styles.closedContainer}>
                  <Chip
                    icon="store-off"
                    mode="flat"
                    style={styles.closedChip}
                    textStyle={styles.closedChipText}
                  >
                    Cerrado
                  </Chip>
                </View>
              )}

              {/* Mostrar advertencia de conflicto */}
              {(() => {
                const conflict = checkScheduleConflict(index);
                if (conflict && !dayHours.isClosed) {
                  return (
                    <View style={styles.conflictWarning}>
                      <MaterialCommunityIcons
                        name="alert-circle"
                        size={16}
                        color={theme.colors.error}
                      />
                      <Text style={styles.conflictText}>{conflict}</Text>
                    </View>
                  );
                }
                return null;
              })()}
            </Card>
          );
        })}
      </View>

      <DateTimePickerSafe
        visible={showTimePicker}
        mode="time"
        value={currentPickerConfig?.currentDate || new Date()}
        onConfirm={handleTimeConfirm}
        onCancel={handleTimeCancel}
        minuteInterval={1}
        title={
          currentPickerConfig?.type === 'opening'
            ? `${DAYS_OF_WEEK[currentPickerConfig.dayIndex || 0]} - Apertura`
            : currentPickerConfig?.type === 'closing'
              ? `${DAYS_OF_WEEK[currentPickerConfig.dayIndex || 0]} - Cierre`
              : 'Seleccionar Hora'
        }
        allowManualInput={true}
      />
    </>
  );
};

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      gap: theme.spacing.s,
    },
    dayCard: {
      marginBottom: theme.spacing.s,
      backgroundColor: theme.colors.surface,
      overflow: 'hidden',
      padding: theme.spacing.m,
    },
    dayHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.s,
    },
    dayName: {
      fontSize: 16,
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    dayActions: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    copyButton: {
      margin: 0,
    },
    timeContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
    },
    timeButton: {
      flex: 1,
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: 12,
      padding: theme.spacing.m,
      borderWidth: 1,
      borderColor: theme.colors.outline,
      overflow: 'visible',
    },
    timeButtonDisabled: {
      backgroundColor: theme.colors.surface,
      borderColor: theme.colors.surfaceVariant,
    },
    timeButtonContent: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
      position: 'relative',
    },
    timeTextContainer: {
      flex: 1,
    },
    timeLabel: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 2,
    },
    timeLabelDisabled: {
      color: theme.colors.onSurfaceDisabled,
    },
    timeValue: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    timeValueDisabled: {
      color: theme.colors.onSurfaceDisabled,
      fontWeight: '500',
    },
    arrow: {
      marginHorizontal: theme.spacing.xs,
    },
    closedContainer: {
      alignItems: 'center',
      paddingVertical: theme.spacing.s,
    },
    closedChip: {
      backgroundColor: theme.colors.errorContainer,
    },
    closedChipText: {
      fontSize: 12,
      color: theme.colors.onErrorContainer,
    },
    nextDayBadge: {
      position: 'absolute',
      top: -4,
      right: -4,
      backgroundColor: theme.colors.primaryContainer,
      borderRadius: 10,
      width: 20,
      height: 20,
      justifyContent: 'center',
      alignItems: 'center',
      borderWidth: 2,
      borderColor: theme.colors.surface,
    },
    conflictWarning: {
      flexDirection: 'row',
      alignItems: 'center',
      backgroundColor: theme.colors.errorContainer,
      padding: theme.spacing.s,
      marginTop: theme.spacing.s,
      borderRadius: 8,
      gap: theme.spacing.xs,
    },
    conflictText: {
      flex: 1,
      fontSize: 12,
      color: theme.colors.onErrorContainer,
      lineHeight: 16,
    },
  });

export default BusinessHoursForm;

================
File: app/src/modules/restaurantConfig/components/TimeZoneSelector.tsx
================
import React, { useState, useMemo } from 'react';
import { View, StyleSheet, TouchableOpacity, FlatList } from 'react-native';
import {
  Text,
  Portal,
  Modal,
  Searchbar,
  List,
  Divider,
  Surface,
  IconButton,
} from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useAppTheme, AppTheme } from '@/app/styles/theme';

interface TimeZoneSelectorProps {
  value: string;
  onChange: (timezone: string) => void;
  disabled?: boolean;
}

// Lista de zonas horarias comunes en Am√©rica
const TIMEZONES = [
  // M√©xico
  { value: 'America/Mexico_City', label: 'Ciudad de M√©xico', offset: 'UTC-6' },
  { value: 'America/Tijuana', label: 'Tijuana', offset: 'UTC-8' },
  { value: 'America/Cancun', label: 'Canc√∫n', offset: 'UTC-5' },
  { value: 'America/Hermosillo', label: 'Hermosillo', offset: 'UTC-7' },
  { value: 'America/Monterrey', label: 'Monterrey', offset: 'UTC-6' },
  { value: 'America/Mazatlan', label: 'Mazatl√°n', offset: 'UTC-7' },
  { value: 'America/Chihuahua', label: 'Chihuahua', offset: 'UTC-7' },

  // Estados Unidos
  { value: 'America/New_York', label: 'Nueva York', offset: 'UTC-5' },
  { value: 'America/Chicago', label: 'Chicago', offset: 'UTC-6' },
  { value: 'America/Denver', label: 'Denver', offset: 'UTC-7' },
  { value: 'America/Los_Angeles', label: 'Los √Ångeles', offset: 'UTC-8' },
  { value: 'America/Phoenix', label: 'Phoenix', offset: 'UTC-7' },

  // Centroam√©rica
  { value: 'America/Guatemala', label: 'Guatemala', offset: 'UTC-6' },
  { value: 'America/El_Salvador', label: 'El Salvador', offset: 'UTC-6' },
  { value: 'America/Tegucigalpa', label: 'Honduras', offset: 'UTC-6' },
  { value: 'America/Managua', label: 'Nicaragua', offset: 'UTC-6' },
  { value: 'America/Costa_Rica', label: 'Costa Rica', offset: 'UTC-6' },
  { value: 'America/Panama', label: 'Panam√°', offset: 'UTC-5' },

  // Sudam√©rica
  { value: 'America/Bogota', label: 'Bogot√°', offset: 'UTC-5' },
  { value: 'America/Lima', label: 'Lima', offset: 'UTC-5' },
  { value: 'America/Quito', label: 'Quito', offset: 'UTC-5' },
  { value: 'America/Caracas', label: 'Caracas', offset: 'UTC-4' },
  { value: 'America/La_Paz', label: 'La Paz', offset: 'UTC-4' },
  { value: 'America/Santiago', label: 'Santiago', offset: 'UTC-3' },
  { value: 'America/Buenos_Aires', label: 'Buenos Aires', offset: 'UTC-3' },
  { value: 'America/Sao_Paulo', label: 'S√£o Paulo', offset: 'UTC-3' },
  { value: 'America/Montevideo', label: 'Montevideo', offset: 'UTC-3' },
  { value: 'America/Asuncion', label: 'Asunci√≥n', offset: 'UTC-3' },

  // Caribe
  { value: 'America/Havana', label: 'La Habana', offset: 'UTC-5' },
  { value: 'America/Santo_Domingo', label: 'Santo Domingo', offset: 'UTC-4' },
  { value: 'America/Puerto_Rico', label: 'Puerto Rico', offset: 'UTC-4' },
];

const TimeZoneSelector: React.FC<TimeZoneSelectorProps> = ({
  value,
  onChange,
  disabled = false,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);
  const [visible, setVisible] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');

  const selectedTimeZone = useMemo(
    () => TIMEZONES.find((tz) => tz.value === value) || TIMEZONES[0],
    [value],
  );

  const filteredTimeZones = useMemo(() => {
    if (!searchQuery.trim()) return TIMEZONES;

    const query = searchQuery.toLowerCase();
    return TIMEZONES.filter(
      (tz) =>
        tz.label.toLowerCase().includes(query) ||
        tz.value.toLowerCase().includes(query) ||
        tz.offset.toLowerCase().includes(query),
    );
  }, [searchQuery]);

  const handleSelect = (timezone: string) => {
    onChange(timezone);
    setVisible(false);
    setSearchQuery('');
  };

  const renderTimeZoneItem = ({ item }: { item: (typeof TIMEZONES)[0] }) => (
    <>
      <List.Item
        title={item.label}
        description={`${item.value} (${item.offset})`}
        onPress={() => handleSelect(item.value)}
        left={(props) => <List.Icon {...props} icon="clock-outline" />}
        right={(props) =>
          item.value === value ? (
            <List.Icon {...props} icon="check" color={theme.colors.primary} />
          ) : null
        }
        style={[styles.listItem, item.value === value && styles.selectedItem]}
        titleStyle={[
          styles.listItemTitle,
          item.value === value && styles.selectedItemText,
        ]}
        descriptionStyle={styles.listItemDescription}
      />
      <Divider />
    </>
  );

  return (
    <>
      <TouchableOpacity
        style={[styles.selector, disabled && styles.selectorDisabled]}
        onPress={() => !disabled && setVisible(true)}
        disabled={disabled}
      >
        <View style={styles.selectorContent}>
          <MaterialCommunityIcons
            name="earth"
            size={24}
            color={
              disabled ? theme.colors.onSurfaceDisabled : theme.colors.primary
            }
          />
          <View style={styles.textContainer}>
            <Text style={[styles.label, disabled && styles.labelDisabled]}>
              Zona Horaria
            </Text>
            <Text style={[styles.value, disabled && styles.valueDisabled]}>
              {selectedTimeZone.label}
            </Text>
            <Text style={[styles.offset, disabled && styles.offsetDisabled]}>
              {selectedTimeZone.offset}
            </Text>
          </View>
          <MaterialCommunityIcons
            name="chevron-down"
            size={24}
            color={
              disabled
                ? theme.colors.onSurfaceDisabled
                : theme.colors.onSurfaceVariant
            }
          />
        </View>
      </TouchableOpacity>

      <Portal>
        <Modal
          visible={visible}
          onDismiss={() => {
            setVisible(false);
            setSearchQuery('');
          }}
          contentContainerStyle={styles.modal}
        >
          <Surface style={styles.modalContent} elevation={3}>
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>Seleccionar Zona Horaria</Text>
              <IconButton
                icon="close"
                size={24}
                onPress={() => {
                  setVisible(false);
                  setSearchQuery('');
                }}
              />
            </View>

            <Searchbar
              placeholder="Buscar zona horaria..."
              onChangeText={setSearchQuery}
              value={searchQuery}
              style={styles.searchbar}
              inputStyle={styles.searchbarInput}
              icon="magnify"
              clearIcon="close"
            />

            <FlatList
              data={filteredTimeZones}
              renderItem={renderTimeZoneItem}
              keyExtractor={(item) => item.value}
              style={styles.list}
              contentContainerStyle={styles.listContent}
              showsVerticalScrollIndicator={true}
              ListEmptyComponent={
                <View style={styles.emptyContainer}>
                  <MaterialCommunityIcons
                    name="magnify-close"
                    size={48}
                    color={theme.colors.onSurfaceVariant}
                  />
                  <Text style={styles.emptyText}>
                    No se encontraron zonas horarias
                  </Text>
                </View>
              }
            />
          </Surface>
        </Modal>
      </Portal>
    </>
  );
};

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    selector: {
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: 12,
      padding: theme.spacing.m,
      borderWidth: 1,
      borderColor: theme.colors.outline,
    },
    selectorDisabled: {
      backgroundColor: theme.colors.surface,
      borderColor: theme.colors.surfaceVariant,
    },
    selectorContent: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.m,
    },
    textContainer: {
      flex: 1,
    },
    label: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 2,
    },
    labelDisabled: {
      color: theme.colors.onSurfaceDisabled,
    },
    value: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    valueDisabled: {
      color: theme.colors.onSurfaceDisabled,
      fontWeight: '500',
    },
    offset: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
    },
    offsetDisabled: {
      color: theme.colors.onSurfaceDisabled,
    },
    modal: {
      margin: theme.spacing.l,
      justifyContent: 'center',
    },
    modalContent: {
      borderRadius: 16,
      maxHeight: '80%',
      backgroundColor: theme.colors.surface,
    },
    modalHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: theme.spacing.l,
      paddingTop: theme.spacing.l,
      paddingBottom: theme.spacing.s,
    },
    modalTitle: {
      fontSize: 20,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    searchbar: {
      marginHorizontal: theme.spacing.l,
      marginBottom: theme.spacing.m,
      elevation: 0,
      backgroundColor: theme.colors.surfaceVariant,
    },
    searchbarInput: {
      fontSize: 14,
    },
    list: {
      maxHeight: 400,
    },
    listContent: {
      paddingBottom: theme.spacing.m,
    },
    listItem: {
      paddingHorizontal: theme.spacing.l,
    },
    selectedItem: {
      backgroundColor: theme.colors.primaryContainer,
    },
    listItemTitle: {
      fontSize: 16,
      color: theme.colors.onSurface,
    },
    selectedItemText: {
      color: theme.colors.primary,
      fontWeight: '600',
    },
    listItemDescription: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    emptyContainer: {
      alignItems: 'center',
      justifyContent: 'center',
      paddingVertical: theme.spacing.xl * 2,
    },
    emptyText: {
      fontSize: 16,
      color: theme.colors.onSurfaceVariant,
      marginTop: theme.spacing.m,
    },
  });

export default TimeZoneSelector;

================
File: app/src/modules/settings/navigation/SettingsStackNavigator.tsx
================
import React from 'react';
import { createStackNavigator } from '@react-navigation/stack';
import { ServerSettingsScreen } from '../screens/ServerSettingsScreen';
import { getDefaultScreenOptions } from '@/app/navigation/options';
import { useAppTheme } from '@/app/styles/theme';
import type { SettingsStackParamList } from './types';

const Stack = createStackNavigator<SettingsStackParamList>();

export function SettingsStackNavigator() {
  const theme = useAppTheme();

  return (
    <Stack.Navigator
      screenOptions={{
        ...getDefaultScreenOptions(theme),
        headerShown: false,
      }}
    >
      <Stack.Screen
        name="ServerSettings"
        component={ServerSettingsScreen}
        options={{
          title: 'Configuraci√≥n del Servidor',
        }}
      />
    </Stack.Navigator>
  );
}

================
File: app/src/modules/settings/navigation/types.ts
================
export type SettingsStackParamList = {
  ServerSettings: undefined;
};

================
File: app/src/modules/settings/screens/ServerSettingsScreen.tsx
================
import React, { useEffect, useState } from 'react';
import {
  ScrollView,
  View,
  StyleSheet,
  ActivityIndicator,
  Platform,
} from 'react-native';
import {
  Text,
  Card,
  RadioButton,
  TextInput,
  Button,
  HelperText,
  Portal,
  Dialog,
  Paragraph,
  IconButton,
  Chip,
  Surface,
  Icon,
  TouchableRipple,
  ProgressBar,
} from 'react-native-paper';
import { useNavigation } from '@react-navigation/native';
import { useSnackbar } from '@/hooks/useSnackbar';
import {
  serverConnectionService,
  ConnectionMode,
} from '@/services/serverConnectionService';
import { discoveryService } from '@/app/services/discoveryService';
import EncryptedStorage from '@/app/services/secureStorageService';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useServerConnection } from '@/app/hooks/useServerConnection';
import axios from 'axios';

const STORAGE_KEYS = {
  CONNECTION_MODE: 'connection_mode',
  MANUAL_URL: 'manual_server_url',
};

export function ServerSettingsScreen() {
  const navigation = useNavigation();
  const { showSnackbar } = useSnackbar();
  const theme = useAppTheme();
  const responsive = useResponsive();
  const { isConnected, isHealthy, serverUrl, isSearching } =
    useServerConnection();

  const [mode, setMode] = useState<ConnectionMode>('auto');
  const [manualUrl, setManualUrl] = useState('');
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [showInfo, setShowInfo] = useState(false);
  const [isDiscovering, setIsDiscovering] = useState(false);
  const [discoveryProgress, setDiscoveryProgress] = useState({
    current: 0,
    total: 0,
    message: '',
  });

  useEffect(() => {
    loadSettings();
  }, []);

  useEffect(() => {
    // Actualizar el campo manual cuando cambie serverUrl
    if (serverUrl && !loading) {
      try {
        const url = new URL(serverUrl);
        setManualUrl(url.hostname);
      } catch {
        // Si no es una URL v√°lida, intentar extraer la IP
        const cleanUrl = serverUrl.replace(/^https?:\/\//, '').split(':')[0];
        setManualUrl(cleanUrl);
      }
    }
  }, [serverUrl, loading]);

  const loadSettings = async () => {
    try {
      const [savedMode, savedUrl] = await Promise.all([
        EncryptedStorage.getItem(
          STORAGE_KEYS.CONNECTION_MODE,
        ) as Promise<ConnectionMode>,
        EncryptedStorage.getItem(STORAGE_KEYS.MANUAL_URL),
      ]);

      if (savedMode) setMode(savedMode);

      // Si hay una URL de servidor actual (de cualquier fuente), usarla para el campo manual
      if (serverUrl) {
        try {
          const url = new URL(serverUrl);
          setManualUrl(url.hostname);
        } catch {
          // Si no es una URL v√°lida, intentar extraer la IP
          const cleanUrl = serverUrl.replace(/^https?:\/\//, '').split(':')[0];
          setManualUrl(cleanUrl);
        }
      } else if (savedUrl) {
        // Si no hay servidor actual pero s√≠ una URL manual guardada, usarla
        try {
          const url = new URL(savedUrl);
          setManualUrl(url.hostname);
        } catch {
          // Si no es una URL v√°lida, usar como est√°
          setManualUrl(savedUrl);
        }
      }
    } catch (error) {
    } finally {
      setLoading(false);
    }
  };

  const validateUrl = (url: string): boolean => {
    // Validar que sea una IP v√°lida o un dominio
    const ipRegex = /^(\d{1,3}\.){3}\d{1,3}$/;
    const domainRegex =
      /^[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9](?:\.[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])*$/;

    // Quitar espacios
    const trimmed = url.trim();

    // No debe incluir protocolo ni puerto
    if (
      trimmed.includes('http://') ||
      trimmed.includes('https://') ||
      trimmed.includes(':')
    ) {
      return false;
    }

    return ipRegex.test(trimmed) || domainRegex.test(trimmed);
  };

  const saveSettings = async () => {
    setSaving(true);
    try {
      // Validar primero si es manual
      if (mode === 'manual') {
        if (!validateUrl(manualUrl)) {
          showSnackbar('Por favor ingresa una URL v√°lida', 'error');
          setSaving(false);
          return;
        }
      }

      // Guardar la configuraci√≥n
      await EncryptedStorage.setItem(STORAGE_KEYS.CONNECTION_MODE, mode);

      if (mode === 'manual') {
        // Guardar la URL completa, no solo la IP
        const fullUrl = `http://${manualUrl.trim()}:3737`;
        await EncryptedStorage.setItem(STORAGE_KEYS.MANUAL_URL, fullUrl);
      }

      // Primero establecer la URL si es necesario
      let urlToCheck: string | null = null;

      if (mode === 'manual') {
        // Construir la URL completa con http y el puerto est√°ndar
        const fullUrl = `http://${manualUrl.trim()}:3737`;
        await discoveryService.setServerUrl(fullUrl, true);
        urlToCheck = fullUrl;
      } else if (mode === 'auto') {
        // En modo auto, limpiar cualquier URL manual
        await discoveryService.setServerUrl(null, true);
      }

      // Luego establecer el modo (esto actualizar√° la URL mostrada)
      await serverConnectionService.setConnectionMode(mode);

      // Comportamiento diferente seg√∫n el modo
      if (mode === 'auto') {
        // En modo autom√°tico, hacer discovery
        setIsDiscovering(true);
        showSnackbar('Iniciando b√∫squeda de servidor...', 'info');

        try {
          // Limpiar cualquier URL manual previa
          await discoveryService.setServerUrl(null, true);

          // Configurar callback de progreso
          discoveryService.setProgressCallback((progress) => {
            setDiscoveryProgress(progress);
          });

          // Hacer discovery
          const discoveredUrl = await discoveryService.discoverServer();

          if (discoveredUrl) {
            showSnackbar('Servidor encontrado ‚úì', 'success');
            // El discovery ya actualiza el estado, solo necesitamos iniciar el monitoreo
            const { healthMonitoringService } = await import(
              '@/services/healthMonitoringService'
            );
            healthMonitoringService.startMonitoring();
          } else {
            showSnackbar('No se encontr√≥ servidor en la red', 'error');
          }
        } catch (error) {
          showSnackbar('Error al buscar servidor', 'error');
        } finally {
          setIsDiscovering(false);
          discoveryService.setProgressCallback(null);
          setDiscoveryProgress({ current: 0, total: 0, message: '' });
        }
      } else {
        // Para manual, hacer reconnect para aplicar la nueva configuraci√≥n
        showSnackbar('Aplicando configuraci√≥n...', 'info');

        try {
          // Hacer reconnect que reinicializar√° todo con la nueva URL
          await serverConnectionService.reconnect();

          showSnackbar('Configuraci√≥n guardada - Conectado ‚úì', 'success');
        } catch (error) {
          showSnackbar('Verificando conexi√≥n...', 'info');

          // Si el reconnect falla, intentar un health check directo
          const { healthMonitoringService } = await import(
            '@/services/healthMonitoringService'
          );

          try {
            const isHealthy = await healthMonitoringService.forceCheck();

            if (isHealthy) {
              showSnackbar(
                'Configuraci√≥n guardada - Servidor accesible ‚úì',
                'success',
              );
              healthMonitoringService.startMonitoring();
            } else {
              showSnackbar(
                'Configuraci√≥n guardada - El servidor no responde ‚úó',
                'warning',
              );
            }
          } catch (error) {
            showSnackbar(
              'Configuraci√≥n guardada - Error al verificar servidor',
              'warning',
            );
          }
        }
      }
    } catch (error: any) {
      showSnackbar(
        error.message || 'Error al guardar la configuraci√≥n',
        'error',
      );
    } finally {
      setSaving(false);
    }
  };

  const renderConnectionStatus = () => {
    let chipIcon = 'alert-circle';
    let chipText = 'Sin conexi√≥n';
    let chipColor = theme.colors.error;
    let chipBgColor = theme.dark
      ? 'rgba(244, 67, 54, 0.2)'
      : 'rgba(244, 67, 54, 0.1)';

    if (isSearching) {
      chipIcon = 'wifi-sync';
      chipText = 'Buscando...';
      chipColor = theme.colors.warning || '#FF9800';
      chipBgColor = theme.dark
        ? 'rgba(255, 152, 0, 0.2)'
        : 'rgba(255, 152, 0, 0.1)';
    } else if (isConnected && isHealthy) {
      chipIcon = 'check-circle';
      chipText = 'Conectado';
      chipColor = theme.colors.success || '#4CAF50';
      chipBgColor = theme.dark
        ? 'rgba(76, 175, 80, 0.2)'
        : 'rgba(76, 175, 80, 0.1)';
    }

    return (
      <Chip
        icon={chipIcon}
        mode="flat"
        compact
        style={{
          backgroundColor: chipBgColor,
          transform: [{ scale: 0.85 }],
        }}
        textStyle={{ color: chipColor, fontSize: 12 }}
      >
        {chipText}
      </Chip>
    );
  };

  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </View>
    );
  }

  return (
    <ScrollView
      style={styles.container}
      contentContainerStyle={styles.scrollContent}
    >
      {/* Estado de Conexi√≥n */}
      <View style={styles.section}>
        <View style={styles.sectionHeader}>
          <Text style={styles.sectionTitle}>Estado de Conexi√≥n</Text>
          {renderConnectionStatus()}
          <View style={{ flex: 1 }} />
          <IconButton
            icon="information"
            size={20}
            onPress={() => setShowInfo(true)}
            iconColor={theme.colors.onSurfaceVariant}
          />
        </View>

        <View>
          <Surface style={styles.infoCard} elevation={0}>
            <View style={styles.infoRow}>
              <View style={styles.infoItem}>
                <Icon
                  source="server"
                  size={20}
                  color={theme.colors.onSurfaceVariant}
                />
                <View style={styles.infoContent}>
                  <Text variant="labelSmall" style={styles.infoLabel}>
                    Servidor
                  </Text>
                  <Text variant="bodyMedium" style={styles.infoValue}>
                    {serverUrl
                      ? serverUrl.replace(/^https?:\/\//, '').split(':')[0]
                      : '-'}
                  </Text>
                </View>
              </View>

              <View style={styles.infoDivider} />

              <View style={styles.infoItem}>
                <Icon
                  source="ethernet-cable"
                  size={20}
                  color={theme.colors.onSurfaceVariant}
                />
                <View style={styles.infoContent}>
                  <Text variant="labelSmall" style={styles.infoLabel}>
                    Puerto
                  </Text>
                  <Text variant="bodyMedium" style={styles.infoValue}>
                    {serverUrl
                      ? serverUrl.split(':').pop()?.split('/')[0] || '3737'
                      : '3737'}
                  </Text>
                </View>
              </View>
            </View>

            {serverUrl && !isHealthy && isConnected && (
              <View style={styles.healthWarning}>
                <Icon
                  source="alert"
                  size={16}
                  color={theme.colors.warning || '#FF9800'}
                />
                <Text variant="labelSmall" style={styles.healthWarningText}>
                  El servidor no responde correctamente
                </Text>
              </View>
            )}
          </Surface>
        </View>
      </View>

      {/* Modo de Conexi√≥n */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Modo de Conexi√≥n</Text>

        <RadioButton.Group
          onValueChange={(value) => setMode(value as ConnectionMode)}
          value={mode}
        >
          <TouchableRipple
            onPress={() => setMode('auto')}
            style={[
              styles.radioOption,
              mode === 'auto' && styles.radioOptionActive,
            ]}
            rippleColor={`${theme.colors.primary}20`}
          >
            <View style={styles.radioContent}>
              <Icon
                source="wifi"
                size={24}
                color={
                  mode === 'auto'
                    ? theme.colors.primary
                    : theme.colors.onSurfaceVariant
                }
              />
              <View style={styles.radioTextContainer}>
                <Text
                  variant="titleMedium"
                  style={[
                    styles.radioTitle,
                    mode === 'auto' && { color: theme.colors.primary },
                  ]}
                >
                  Autom√°tico
                </Text>
                <Text variant="bodySmall" style={styles.radioSubtitle}>
                  Busca el servidor en tu red local
                </Text>
              </View>
              <RadioButton
                value="auto"
                status={mode === 'auto' ? 'checked' : 'unchecked'}
              />
            </View>
          </TouchableRipple>

          <TouchableRipple
            onPress={() => setMode('manual')}
            style={[
              styles.radioOption,
              mode === 'manual' && styles.radioOptionActive,
              { marginBottom: 0 },
            ]}
            rippleColor={`${theme.colors.primary}20`}
          >
            <View>
              <View style={styles.radioContent}>
                <Icon
                  source="pencil-outline"
                  size={24}
                  color={
                    mode === 'manual'
                      ? theme.colors.primary
                      : theme.colors.onSurfaceVariant
                  }
                />
                <View style={styles.radioTextContainer}>
                  <Text
                    variant="titleMedium"
                    style={[
                      styles.radioTitle,
                      mode === 'manual' && { color: theme.colors.primary },
                    ]}
                  >
                    Manual
                  </Text>
                  <Text variant="bodySmall" style={styles.radioSubtitle}>
                    Especifica la URL del servidor
                  </Text>
                </View>
                <RadioButton
                  value="manual"
                  status={mode === 'manual' ? 'checked' : 'unchecked'}
                />
              </View>
              {mode === 'manual' && (
                <View style={styles.manualInputContainer}>
                  <TextInput
                    label="Direcci√≥n IP o Dominio"
                    value={manualUrl}
                    onChangeText={setManualUrl}
                    placeholder="192.168.1.100"
                    mode="outlined"
                    autoCapitalize="none"
                    autoCorrect={false}
                    keyboardType="default"
                    error={manualUrl !== '' && !validateUrl(manualUrl)}
                    outlineColor={theme.colors.outline}
                    activeOutlineColor={theme.colors.primary}
                    style={styles.manualInput}
                  />
                  <HelperText
                    type={
                      manualUrl !== '' && !validateUrl(manualUrl)
                        ? 'error'
                        : 'info'
                    }
                    visible={true}
                  >
                    {manualUrl !== '' && !validateUrl(manualUrl)
                      ? 'Ingresa solo la IP (ej: 192.168.1.100) sin http:// ni puerto'
                      : 'Solo la direcci√≥n IP sin protocolo. El puerto 3737 se a√±adir√° autom√°ticamente.'}
                  </HelperText>
                </View>
              )}
            </View>
          </TouchableRipple>
        </RadioButton.Group>
      </View>

      {/* Indicador de progreso del discovery */}
      {isDiscovering && (
        <View style={styles.discoveryProgressContainer}>
          <Surface style={styles.discoveryProgressCard} elevation={1}>
            <View style={styles.discoveryHeader}>
              <Icon
                source="magnify-scan"
                size={24}
                color={theme.colors.primary}
              />
              <Text style={styles.discoveryTitle}>
                Buscando servidor en la red
              </Text>
            </View>
            <ProgressBar
              progress={
                discoveryProgress.total > 0
                  ? discoveryProgress.current / discoveryProgress.total
                  : 0
              }
              color={theme.colors.primary}
              style={styles.progressBar}
            />
            <Text style={styles.discoveryMessage}>
              {discoveryProgress.message || 'Iniciando b√∫squeda...'}
            </Text>
            {discoveryProgress.total > 0 && (
              <Text style={styles.discoveryStats}>
                {discoveryProgress.current} de {discoveryProgress.total} IPs
                escaneadas
              </Text>
            )}
          </Surface>
        </View>
      )}

      {/* Bot√≥n de guardar */}
      <View style={styles.actionButtons}>
        <Button
          mode="contained"
          onPress={saveSettings}
          loading={saving}
          disabled={saving || isDiscovering}
          icon="content-save"
          style={styles.saveButton}
          contentStyle={styles.buttonContent}
          labelStyle={styles.buttonLabel}
        >
          Guardar Configuraci√≥n
        </Button>
      </View>

      <Portal>
        <Dialog visible={showInfo} onDismiss={() => setShowInfo(false)}>
          <Dialog.Title>Informaci√≥n de Conexi√≥n</Dialog.Title>
          <Dialog.Content>
            <Paragraph style={styles.infoParagraph}>
              <Text style={styles.boldText}>Modo Autom√°tico:</Text>
              {'\n'}Ideal para uso en el restaurante. La app busca el servidor
              en la red local.
            </Paragraph>

            <Paragraph style={styles.infoParagraph}>
              <Text style={styles.boldText}>Modo Manual:</Text>
              {'\n'}Configura manualmente la URL del servidor para casos
              especiales.
            </Paragraph>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setShowInfo(false)}>Cerrar</Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </ScrollView>
  );
}

const createStyles = (theme: any, responsive: any) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    scrollContent: {
      paddingBottom: 40,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      backgroundColor: theme.colors.background,
    },
    section: {
      marginHorizontal: 16,
      marginTop: 20,
      marginBottom: 16,
    },
    sectionHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: 16,
    },
    sectionTitle: {
      fontSize: responsive?.isWeb ? 20 : 18,
      fontWeight: '600',
      color: theme.colors.onSurface,
      marginRight: 12,
    },
    infoCard: {
      backgroundColor: theme.dark
        ? theme.colors.surfaceVariant
        : theme.colors.surface,
      borderRadius: 12,
      padding: 20,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
    },
    infoRow: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-around',
    },
    infoItem: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
      gap: 8,
    },
    infoContent: {
      flex: 1,
    },
    infoLabel: {
      color: theme.colors.onSurfaceVariant,
      marginBottom: 2,
      fontSize: responsive?.isWeb ? 12 : 11,
    },
    infoValue: {
      color: theme.colors.onSurface,
      fontWeight: '600',
      fontSize: responsive?.isWeb ? 16 : 14,
    },
    infoDivider: {
      width: 1,
      height: 40,
      backgroundColor: theme.colors.outlineVariant,
      marginHorizontal: 12,
    },
    healthWarning: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 4,
      marginTop: 12,
      paddingTop: 12,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
    },
    healthWarningText: {
      color: theme.colors.warning || '#FF9800',
      flex: 1,
    },
    radioOption: {
      marginBottom: 12,
      borderRadius: 12,
      backgroundColor: theme.colors.surface,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
      overflow: 'hidden',
    },
    radioOptionActive: {
      borderColor: theme.colors.primary,
      backgroundColor: theme.dark
        ? 'rgba(103, 80, 164, 0.08)'
        : 'rgba(103, 80, 164, 0.05)',
    },
    radioContent: {
      flexDirection: 'row',
      alignItems: 'center',
      padding: 16,
      gap: 12,
    },
    radioTextContainer: {
      flex: 1,
    },
    radioTitle: {
      color: theme.colors.onSurface,
      fontWeight: '600',
    },
    radioSubtitle: {
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
    },
    radioDetails: {
      marginTop: 8,
      marginLeft: 48,
      marginRight: 16,
      marginBottom: 12,
      padding: 8,
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: 8,
    },
    radioDetailsText: {
      color: theme.colors.onSurfaceVariant,
      fontFamily: Platform.OS === 'ios' ? 'Menlo' : 'monospace',
    },
    manualInputContainer: {
      paddingTop: 8,
      paddingHorizontal: 16,
      paddingBottom: 12,
    },
    manualInput: {
      backgroundColor: theme.colors.surface,
    },
    actionButtons: {
      marginHorizontal: 16,
      marginTop: 12,
      marginBottom: 20,
    },
    saveButton: {
      backgroundColor: theme.colors.primary,
    },
    buttonContent: {
      paddingVertical: 8,
    },
    buttonLabel: {
      fontSize: responsive?.isWeb ? 16 : 14,
    },
    infoParagraph: {
      marginBottom: 12,
      color: theme.colors.onSurfaceVariant,
      lineHeight: responsive?.isWeb ? 24 : 20,
    },
    boldText: {
      fontWeight: 'bold',
      color: theme.colors.onSurface,
    },
    discoveryProgressContainer: {
      marginHorizontal: 16,
      marginTop: 16,
      marginBottom: 8,
    },
    discoveryProgressCard: {
      backgroundColor: theme.colors.surface,
      borderRadius: 12,
      padding: 16,
      borderWidth: 1,
      borderColor: theme.colors.primary,
    },
    discoveryHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 8,
      marginBottom: 12,
    },
    discoveryTitle: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
      flex: 1,
    },
    progressBar: {
      height: 6,
      borderRadius: 3,
      marginBottom: 12,
    },
    discoveryMessage: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 4,
    },
    discoveryStats: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
    },
  });

================
File: app/src/modules/shared/components/PrintTicketModal.tsx
================
import React, { useState, useEffect } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  ActivityIndicator,
  TouchableOpacity,
} from 'react-native';
import {
  Modal,
  Portal,
  Text,
  RadioButton,
  Button,
  Surface,
  IconButton,
  Divider,
} from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { usePrintersQuery } from '@/modules/printers/hooks/usePrintersQueries';

// Interfaz m√≠nima que requiere el componente
interface OrderBasicInfo {
  shiftOrderNumber: number;
  orderType: 'TAKE_AWAY' | 'DELIVERY' | 'DINE_IN' | 'TAKEOUT';
}

interface PrintTicketModalProps {
  visible: boolean;
  onDismiss: () => void;
  order: OrderBasicInfo | null;
  onPrint: (
    printerId: string,
    ticketType: 'GENERAL' | 'BILLING',
  ) => Promise<void>;
}

export const PrintTicketModal: React.FC<PrintTicketModalProps> = ({
  visible,
  onDismiss,
  order,
  onPrint,
}) => {
  const theme = useAppTheme();
  const { data: printersResponse, isLoading: isLoadingPrinters } =
    usePrintersQuery({ page: 1, limit: 100 });
  const [selectedTicketType, setSelectedTicketType] = useState<
    'GENERAL' | 'BILLING'
  >('GENERAL');
  const [selectedPrinterId, setSelectedPrinterId] = useState<string>('');
  const [isPrinting, setIsPrinting] = useState(false);

  // Extraer impresoras del response paginado y filtrar solo las activas
  const printers = printersResponse?.data || [];
  const activePrinters = printers.filter((printer) => printer.isActive);

  // Seleccionar la primera impresora activa por defecto
  useEffect(() => {
    if (activePrinters.length > 0 && !selectedPrinterId) {
      setSelectedPrinterId(activePrinters[0].id);
    }
  }, [activePrinters, selectedPrinterId]);

  // Seleccionar tipo de ticket seg√∫n el tipo de orden
  useEffect(() => {
    if (order) {
      // Para √≥rdenes DINE_IN, usar BILLING (ticket de cuenta)
      // Para TAKE_AWAY, TAKEOUT, DELIVERY, usar GENERAL
      if (order.orderType === 'DINE_IN') {
        setSelectedTicketType('BILLING');
      } else {
        setSelectedTicketType('GENERAL');
      }
    }
  }, [order]);

  const handlePrint = async () => {
    if (!selectedPrinterId || !order) return;

    setIsPrinting(true);
    try {
      await onPrint(selectedPrinterId, selectedTicketType);
      onDismiss();
    } catch (error) {
      // Error al imprimir ticket
    } finally {
      setIsPrinting(false);
    }
  };

  if (!order) return null;

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={[
          styles.modalContent,
          { backgroundColor: theme.colors.background },
        ]}
      >
        <View style={styles.header}>
          <Text style={[styles.title, { color: theme.colors.onSurface }]}>
            Imprimir Ticket - Orden #{order.shiftOrderNumber}
          </Text>
          <IconButton
            icon="close"
            size={24}
            onPress={onDismiss}
            style={styles.closeButton}
          />
        </View>

        <Divider />

        <ScrollView style={styles.content}>
          {/* Tipo de Ticket */}
          <View style={styles.section}>
            <Text
              style={[styles.sectionTitle, { color: theme.colors.primary }]}
            >
              Tipo de Ticket
            </Text>
            <RadioButton.Group
              onValueChange={(value) =>
                setSelectedTicketType(value as 'GENERAL' | 'BILLING')
              }
              value={selectedTicketType}
            >
              <TouchableOpacity
                activeOpacity={0.7}
                onPress={() => setSelectedTicketType('GENERAL')}
              >
                <Surface
                  style={[
                    styles.radioItem,
                    {
                      backgroundColor: theme.colors.surface,
                      borderColor:
                        selectedTicketType === 'GENERAL'
                          ? theme.colors.primary
                          : 'transparent',
                      borderWidth: selectedTicketType === 'GENERAL' ? 2 : 0,
                    },
                  ]}
                >
                  <View style={styles.radioContent}>
                    <RadioButton value="GENERAL" color={theme.colors.primary} />
                    <View style={styles.radioTextContainer}>
                      <Text
                        style={[
                          styles.radioLabel,
                          { color: theme.colors.onSurface },
                        ]}
                      >
                        üìã Ticket General
                      </Text>
                      <Text
                        style={[
                          styles.radioDescription,
                          { color: theme.colors.onSurfaceVariant },
                        ]}
                      >
                        Para cocina y delivery (letras grandes)
                      </Text>
                    </View>
                  </View>
                </Surface>
              </TouchableOpacity>
              <TouchableOpacity
                activeOpacity={0.7}
                onPress={() => setSelectedTicketType('BILLING')}
              >
                <Surface
                  style={[
                    styles.radioItem,
                    {
                      backgroundColor: theme.colors.surface,
                      borderColor:
                        selectedTicketType === 'BILLING'
                          ? theme.colors.primary
                          : 'transparent',
                      borderWidth: selectedTicketType === 'BILLING' ? 2 : 0,
                    },
                  ]}
                >
                  <View style={styles.radioContent}>
                    <RadioButton value="BILLING" color={theme.colors.primary} />
                    <View style={styles.radioTextContainer}>
                      <Text
                        style={[
                          styles.radioLabel,
                          { color: theme.colors.onSurface },
                        ]}
                      >
                        üíµ Ticket de Cuenta
                      </Text>
                      <Text
                        style={[
                          styles.radioDescription,
                          { color: theme.colors.onSurfaceVariant },
                        ]}
                      >
                        Para cobro al cliente (formato cuenta)
                      </Text>
                    </View>
                  </View>
                </Surface>
              </TouchableOpacity>
            </RadioButton.Group>
          </View>

          {/* Selecci√≥n de Impresora */}
          <View style={styles.section}>
            <Text
              style={[styles.sectionTitle, { color: theme.colors.primary }]}
            >
              Seleccionar Impresora
            </Text>
            {isLoadingPrinters ? (
              <ActivityIndicator size="small" color={theme.colors.primary} />
            ) : activePrinters.length === 0 ? (
              <Text
                style={[styles.noPrintersText, { color: theme.colors.error }]}
              >
                No hay impresoras activas disponibles
              </Text>
            ) : (
              <RadioButton.Group
                onValueChange={(value) => setSelectedPrinterId(value)}
                value={selectedPrinterId}
              >
                {activePrinters.map((printer) => (
                  <TouchableOpacity
                    key={printer.id}
                    activeOpacity={0.7}
                    onPress={() => setSelectedPrinterId(printer.id)}
                  >
                    <Surface
                      style={[
                        styles.radioItem,
                        {
                          backgroundColor: theme.colors.surface,
                          borderColor:
                            selectedPrinterId === printer.id
                              ? theme.colors.primary
                              : 'transparent',
                          borderWidth: selectedPrinterId === printer.id ? 2 : 0,
                        },
                      ]}
                    >
                      <View style={styles.radioContent}>
                        <RadioButton
                          value={printer.id}
                          color={theme.colors.primary}
                        />
                        <View style={styles.radioTextContainer}>
                          <Text
                            style={[
                              styles.radioLabel,
                              { color: theme.colors.onSurface },
                            ]}
                          >
                            üñ®Ô∏è {printer.name}
                          </Text>
                          <Text
                            style={[
                              styles.radioDescription,
                              { color: theme.colors.onSurfaceVariant },
                            ]}
                          >
                            {printer.ipAddress} - Puerto {printer.port}
                          </Text>
                        </View>
                      </View>
                    </Surface>
                  </TouchableOpacity>
                ))}
              </RadioButton.Group>
            )}
          </View>
        </ScrollView>

        <Divider />

        <View style={styles.footer}>
          <Button
            mode="outlined"
            onPress={onDismiss}
            textColor={theme.colors.error}
            style={[styles.footerButton, { borderColor: theme.colors.error }]}
          >
            Cancelar
          </Button>
          <Button
            mode="contained"
            onPress={handlePrint}
            loading={isPrinting}
            disabled={
              !selectedPrinterId || activePrinters.length === 0 || isPrinting
            }
            style={[styles.footerButton, styles.printButton]}
            buttonColor={theme.colors.primary}
          >
            Imprimir
          </Button>
        </View>
      </Modal>
    </Portal>
  );
};

const styles = StyleSheet.create({
  modalContent: {
    margin: 16,
    borderRadius: 16,
    maxHeight: '85%',
    overflow: 'hidden',
    elevation: 8,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 4,
    },
    shadowOpacity: 0.3,
    shadowRadius: 8,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingVertical: 10,
  },
  title: {
    fontSize: 18,
    fontWeight: '700',
    flex: 1,
  },
  closeButton: {
    margin: -8,
  },
  content: {
    maxHeight: 400,
  },
  section: {
    paddingHorizontal: 16,
    paddingVertical: 8,
  },
  sectionTitle: {
    fontSize: 14,
    fontWeight: '600',
    marginBottom: 8,
  },
  radioItem: {
    marginBottom: 6,
    borderRadius: 10,
    elevation: 1,
    padding: 2,
  },
  radioContent: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    paddingHorizontal: 12,
  },
  radioTextContainer: {
    flex: 1,
    marginLeft: 8,
  },
  radioLabel: {
    fontSize: 14,
    fontWeight: '600',
    marginBottom: 2,
  },
  radioDescription: {
    fontSize: 11,
    opacity: 0.7,
  },
  noPrintersText: {
    fontSize: 13,
    textAlign: 'center',
    padding: 12,
    fontWeight: '500',
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 12,
    paddingHorizontal: 16,
    gap: 12,
  },
  footerButton: {
    minWidth: 100,
    borderRadius: 8,
  },
  printButton: {
    paddingHorizontal: 4,
  },
});

================
File: app/src/modules/shiftAudit/components/index.ts
================
export { ShiftOrdersModal } from './ShiftOrdersModal';
export { OrderDetailsView } from './OrderDetailsView';
export { OrderHistoryView } from './OrderHistoryView';
export { ShiftSalesSummaryView } from './ShiftSalesSummaryView';

================
File: app/src/modules/shiftAudit/components/OrderDetailsView.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';
import {
  Surface,
  Text,
  Divider,
  Appbar,
  ActivityIndicator,
  IconButton,
  Chip,
} from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import type { Receipt } from '@/modules/receipts/types/receipt.types';
import {
  CustomizationType,
  PizzaHalf,
  CustomizationAction,
} from '@/modules/pizzaCustomizations/types/pizzaCustomization.types';

interface OrderDetailsViewProps {
  order: Receipt | null;
  onBack: () => void;
  onShowHistory?: () => void;
  isLoading?: boolean;
}

const formatPizzaCustomizations = (customizations: any[]): string => {
  if (!customizations || customizations.length === 0) return '';

  const groupedByHalf = customizations.reduce(
    (acc, curr) => {
      const half =
        curr.half === PizzaHalf.HALF_1
          ? 'HALF_1'
          : curr.half === PizzaHalf.HALF_2
            ? 'HALF_2'
            : 'FULL';

      if (!acc[half]) {
        acc[half] = {
          flavors: [],
          addedIngredients: [],
          removedIngredients: [],
        };
      }

      const name = curr.pizzaCustomization?.name || curr.pizzaCustomizationId;
      const type = curr.pizzaCustomization?.type;

      if (type === 'FLAVOR' || type === CustomizationType.FLAVOR) {
        acc[half].flavors.push(name);
      } else if (
        type === 'INGREDIENT' ||
        type === CustomizationType.INGREDIENT
      ) {
        if (curr.action === CustomizationAction.ADD) {
          acc[half].addedIngredients.push(name);
        } else {
          acc[half].removedIngredients.push(name);
        }
      }

      return acc;
    },
    {} as Record<
      string,
      {
        flavors: string[];
        addedIngredients: string[];
        removedIngredients: string[];
      }
    >,
  );

  if (groupedByHalf.FULL) {
    const parts: string[] = [];
    if (groupedByHalf.FULL.flavors.length > 0) {
      parts.push(groupedByHalf.FULL.flavors.join(', '));
    }
    if (groupedByHalf.FULL.addedIngredients.length > 0) {
      parts.push(`con: ${groupedByHalf.FULL.addedIngredients.join(', ')}`);
    }
    if (groupedByHalf.FULL.removedIngredients.length > 0) {
      parts.push(`sin: ${groupedByHalf.FULL.removedIngredients.join(', ')}`);
    }
    return parts.join(' - ');
  } else if (groupedByHalf.HALF_1 || groupedByHalf.HALF_2) {
    const formatHalf = (halfData: {
      flavors: string[];
      addedIngredients: string[];
      removedIngredients: string[];
    }) => {
      const parts: string[] = [];
      if (halfData.flavors.length > 0) {
        parts.push(halfData.flavors.join(', '));
      }
      if (halfData.addedIngredients.length > 0) {
        parts.push(`con: ${halfData.addedIngredients.join(', ')}`);
      }
      if (halfData.removedIngredients.length > 0) {
        parts.push(`sin: ${halfData.removedIngredients.join(', ')}`);
      }
      return parts.join(' - ');
    };

    const half1 = groupedByHalf.HALF_1 ? formatHalf(groupedByHalf.HALF_1) : '';
    const half2 = groupedByHalf.HALF_2 ? formatHalf(groupedByHalf.HALF_2) : '';

    return half1 && half2 ? `(${half1} / ${half2})` : half1 || half2;
  }

  return '';
};

export const OrderDetailsView: React.FC<OrderDetailsViewProps> = ({
  order,
  onBack,
  onShowHistory,
  isLoading = false,
}) => {
  const theme = useAppTheme();
  const [showPrintHistory, setShowPrintHistory] = useState(false);

  const getOrderTypeLabel = (type: string) => {
    switch (type) {
      case 'DINE_IN':
        return 'üçΩÔ∏è Local';
      case 'TAKE_AWAY':
        return 'ü•° Llevar';
      case 'DELIVERY':
        return 'üöö Env√≠o';
      default:
        return type;
    }
  };

  const getOrderStatusLabel = (status: string) => {
    switch (status) {
      case 'PENDING':
        return 'Pendiente';
      case 'IN_PROGRESS':
        return 'En preparaci√≥n';
      case 'READY':
        return 'Listo';
      case 'DELIVERED':
        return 'Entregado';
      case 'COMPLETED':
        return 'Completado';
      case 'CANCELLED':
        return 'Cancelado';
      default:
        return status;
    }
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'PENDING':
        return '#FFA726';
      case 'IN_PROGRESS':
        return theme.colors.primary;
      case 'READY':
        return '#66BB6A';
      case 'DELIVERED':
        return '#9C27B0';
      case 'COMPLETED':
        return '#10B981';
      case 'CANCELLED':
        return theme.colors.error;
      default:
        return theme.colors.onSurfaceVariant;
    }
  };

  const getPaymentStatus = () => {
    if (order?.payments && order.payments.length > 0) {
      const totalPaid = order.payments.reduce((sum, p) => sum + p.amount, 0);
      const totalAmount =
        typeof order.total === 'string'
          ? parseFloat(order.total)
          : order.total || 0;

      if (totalPaid >= totalAmount) {
        return { label: 'Pagado', color: '#10B981' };
      } else if (totalPaid > 0) {
        return { label: 'Parcial', color: '#F59E0B' };
      }
    }
    return { label: 'Pendiente', color: '#EF4444' };
  };

  const paymentStatus = order
    ? getPaymentStatus()
    : { label: 'Pendiente', color: '#EF4444' };

  const renderItem = (item: any) => {
    const quantity = item.quantity || 1;
    const unitPrice = parseFloat(item.finalPrice);
    const totalPrice = unitPrice * quantity;
    const preparationStatusColors = {
      PENDING: '#FFA726',
      IN_PROGRESS: '#42A5F5',
      READY: '#66BB6A',
      DELIVERED: '#26A69A',
      CANCELLED: '#EF5350',
    };
    const statusColor =
      preparationStatusColors[
        item.preparationStatus as keyof typeof preparationStatusColors
      ] || theme.colors.onSurfaceVariant;

    return (
      <Surface
        key={`${item.id}`}
        style={[
          styles.itemCard,
          { backgroundColor: theme.colors.elevation.level1, marginBottom: 8 },
        ]}
        elevation={1}
      >
        <View style={styles.itemContent}>
          <View style={styles.itemHeader}>
            <View style={styles.nameContainer}>
              <Text
                style={[styles.itemQuantity, { color: theme.colors.primary }]}
              >
                {quantity}x
              </Text>
              <Text
                style={[styles.itemName, { color: theme.colors.onSurface }]}
                numberOfLines={1}
              >
                {item.productVariant?.name || item.product.name}
              </Text>
            </View>
            {item.preparationStatus && (
              <View
                style={[styles.statusChip, { backgroundColor: statusColor }]}
              >
                <Text style={styles.statusChipText}>
                  {item.preparationStatus === 'PENDING' && 'Pendiente'}
                  {item.preparationStatus === 'IN_PROGRESS' && 'Preparando'}
                  {item.preparationStatus === 'READY' && 'Listo'}
                  {item.preparationStatus === 'DELIVERED' && 'Entregado'}
                  {item.preparationStatus === 'CANCELLED' && 'Cancelado'}
                </Text>
              </View>
            )}
          </View>

          <View style={styles.itemDetailsContainer}>
            {item.selectedPizzaCustomizations &&
              item.selectedPizzaCustomizations.length > 0 && (
                <View style={styles.customizationContainer}>
                  <Text
                    style={[
                      styles.pizzaCustomizationText,
                      { color: theme.colors.onSurfaceVariant },
                    ]}
                  >
                    {formatPizzaCustomizations(
                      item.selectedPizzaCustomizations,
                    )}
                  </Text>
                </View>
              )}

            {item.productModifiers && item.productModifiers.length > 0 && (
              <View style={styles.modifiersContainer}>
                {item.productModifiers.map((modifier: any) => (
                  <View key={modifier.id} style={styles.modifierRow}>
                    <Text
                      style={[
                        styles.modifierText,
                        { color: theme.colors.onSurfaceVariant },
                      ]}
                    >
                      ‚Ä¢ {modifier.name}
                    </Text>
                    {modifier.price && Number(modifier.price) > 0 && (
                      <Text
                        style={[
                          styles.modifierPrice,
                          { color: theme.colors.tertiary },
                        ]}
                      >
                        +${Number(modifier.price).toFixed(2)}
                      </Text>
                    )}
                  </View>
                ))}
              </View>
            )}

            {item.preparationNotes && (
              <View style={styles.notesContainer}>
                <Text
                  style={[
                    styles.notesText,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                  üìù {item.preparationNotes}
                </Text>
              </View>
            )}
          </View>

          <View style={styles.priceContainer}>
            <View style={styles.priceRow}>
              <Text
                style={[
                  styles.priceLabel,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                P. unitario:
              </Text>
              <Text
                style={[styles.priceValue, { color: theme.colors.onSurface }]}
              >
                ${unitPrice.toFixed(2)}
              </Text>
            </View>
            {quantity > 1 && (
              <View style={styles.priceRow}>
                <Text
                  style={[
                    styles.priceLabel,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                  Total √ó{quantity}:
                </Text>
                <Text
                  style={[styles.totalPrice, { color: theme.colors.primary }]}
                >
                  ${totalPrice.toFixed(2)}
                </Text>
              </View>
            )}
          </View>
        </View>
      </Surface>
    );
  };

  if (isLoading) {
    return (
      <View style={styles.container}>
        <Appbar.Header style={styles.appbarHeader}>
          <Appbar.BackAction onPress={onBack} />
          <Appbar.Content title="Cargando..." />
        </Appbar.Header>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
          <Text
            style={[
              styles.loadingText,
              { color: theme.colors.onSurfaceVariant },
            ]}
          >
            Cargando detalles del recibo...
          </Text>
        </View>
      </View>
    );
  }

  if (!order) {
    return null;
  }

  return (
    <View
      style={[styles.container, { backgroundColor: theme.colors.background }]}
    >
      <Appbar.Header style={styles.appbarHeader}>
        <Appbar.BackAction onPress={onBack} />
        <Appbar.Content title={`Recibo #${order?.shiftOrderNumber || ''}`} />
        <Appbar.Action
          icon="history"
          size={28}
          onPress={onShowHistory}
          disabled={!onShowHistory}
        />
      </Appbar.Header>

      <View style={styles.header}>
        <View style={styles.headerInfo}>
          <View style={styles.headerTopRow}>
            <View style={styles.headerLeft}>
              <Text style={[styles.orderType, { color: theme.colors.primary }]}>
                {order ? getOrderTypeLabel(order.orderType) : ''}
              </Text>
            </View>
          </View>
          <View style={styles.headerBottomRow}>
            <View style={styles.chipsRow}>
              <View
                style={[
                  styles.headerStatusChip,
                  {
                    backgroundColor: order
                      ? getStatusColor(order.orderStatus)
                      : theme.colors.surfaceVariant,
                  },
                ]}
              >
                <Text style={styles.headerStatusChipText}>
                  {order ? getOrderStatusLabel(order.orderStatus) : ''}
                </Text>
              </View>
              {order?.preparationScreens &&
                order.preparationScreens.map((screen, index) => (
                  <Chip
                    key={index}
                    mode="outlined"
                    compact
                    style={styles.screenChip}
                    textStyle={styles.screenChipText}
                  >
                    üç≥ {screen}
                  </Chip>
                ))}
            </View>
          </View>
          <View style={styles.headerDatesRow}>
            <Text
              style={[
                styles.headerDate,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Creado:{' '}
              {order?.createdAt
                ? format(new Date(order.createdAt), 'dd/MM/yyyy HH:mm', {
                    locale: es,
                  })
                : ''}
            </Text>
            {order?.finalizedAt && (
              <Text
                style={[styles.headerDate, { color: theme.colors.primary }]}
              >
                Finalizado:{' '}
                {format(new Date(order.finalizedAt), 'dd/MM/yyyy HH:mm', {
                  locale: es,
                })}
              </Text>
            )}
          </View>
        </View>
      </View>

      <ScrollView
        style={styles.scrollView}
        showsVerticalScrollIndicator={false}
        contentContainerStyle={styles.scrollContent}
      >
        <View style={styles.infoSection}>
          {order?.deliveryInfo?.recipientName && (
            <View style={styles.infoRow}>
              <Text
                style={[styles.contactText, { color: theme.colors.onSurface }]}
              >
                üë§ Nombre del Cliente: {order.deliveryInfo.recipientName}
              </Text>
            </View>
          )}

          {order?.deliveryInfo?.recipientPhone && (
            <View style={styles.infoRow}>
              <Text
                style={[styles.contactText, { color: theme.colors.onSurface }]}
              >
                üìû Tel√©fono: {order.deliveryInfo.recipientPhone}
              </Text>
            </View>
          )}

          {order?.orderType === 'DELIVERY' &&
            order?.deliveryInfo?.fullAddress && (
              <View style={styles.infoRow}>
                <Text
                  style={[
                    styles.addressText,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                  üì¶ Direcci√≥n de Entrega: {order.deliveryInfo.fullAddress}
                </Text>
              </View>
            )}

          {order?.orderType === 'DINE_IN' && order?.table && (
            <View style={styles.infoRow}>
              <Text
                style={[styles.tableText, { color: theme.colors.onSurface }]}
              >
                üèõÔ∏è Mesa: {order.table.area?.name || 'Sin √°rea'} -{' '}
                {order.table.number}
              </Text>
            </View>
          )}

          {order?.scheduledAt && (
            <View style={styles.infoRow}>
              <Text
                style={[
                  styles.contactText,
                  { color: theme.colors.primary, fontWeight: '600' },
                ]}
              >
                ‚è∞ Hora de Entrega Programada:{' '}
                {format(new Date(order.scheduledAt), 'HH:mm', {
                  locale: es,
                })}
              </Text>
            </View>
          )}

          {order?.user && (
            <View style={styles.infoRow}>
              <Text
                style={[
                  styles.contactText,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                üë®‚Äçüíº Atendido por: {order.user.firstName} {order.user.lastName}
              </Text>
            </View>
          )}

          {order?.notes && (
            <View style={styles.infoRow}>
              <Text
                style={[
                  styles.notesText,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                üìã Notas: {order.notes}
              </Text>
            </View>
          )}
        </View>

        <Divider style={styles.divider} />

        <View style={styles.itemsList}>
          {order?.orderItems?.map((item) => renderItem(item)) || []}
        </View>

        <Divider style={styles.divider} />

        {order?.payments && order.payments.length > 0 && (
          <>
            <View style={styles.paymentsSection}>
              <View style={styles.paymentSummaryCompact}>
                <View style={styles.summaryCompactRow}>
                  <Text
                    style={[
                      styles.summaryCompactLabel,
                      { color: theme.colors.onSurfaceVariant },
                    ]}
                  >
                    Total: $
                    {typeof order.total === 'string'
                      ? parseFloat(order.total).toFixed(2)
                      : (order.total || 0).toFixed(2)}
                  </Text>
                  <Text
                    style={[styles.summaryCompactLabel, { color: '#10B981' }]}
                  >
                    Pagado: $
                    {order.payments
                      .reduce((sum, p) => sum + p.amount, 0)
                      .toFixed(2)}
                  </Text>
                  {(() => {
                    const totalAmount =
                      typeof order.total === 'string'
                        ? parseFloat(order.total)
                        : order.total || 0;
                    const totalPaid = order.payments.reduce(
                      (sum, p) => sum + p.amount,
                      0,
                    );
                    const remaining = totalAmount - totalPaid;
                    if (remaining > 0) {
                      return (
                        <Text
                          style={[
                            styles.summaryCompactLabel,
                            {
                              color: theme.colors.error,
                              fontWeight: '600',
                            },
                          ]}
                        >
                          Resta: ${remaining.toFixed(2)}
                        </Text>
                      );
                    }
                    return null;
                  })()}
                </View>
              </View>

              {order.payments.map((payment, index) => {
                const getPaymentMethodLabel = (method: string) => {
                  switch (method) {
                    case 'CASH':
                    case 'cash':
                      return 'Efectivo';
                    case 'CREDIT_CARD':
                    case 'card':
                      return 'Tarjeta de Cr√©dito';
                    case 'DEBIT_CARD':
                      return 'Tarjeta de D√©bito';
                    case 'TRANSFER':
                    case 'transfer':
                      return 'Transferencia';
                    case 'OTHER':
                      return 'Otro';
                    default:
                      return method;
                  }
                };

                const getPaymentStatusColor = (status: string) => {
                  switch (status) {
                    case 'COMPLETED':
                      return '#10B981';
                    case 'PENDING':
                      return '#F59E0B';
                    case 'FAILED':
                      return theme.colors.error;
                    case 'REFUNDED':
                      return '#6B7280';
                    case 'CANCELLED':
                      return theme.colors.error;
                    default:
                      return theme.colors.onSurfaceVariant;
                  }
                };

                const getPaymentStatusLabel = (status: string) => {
                  switch (status) {
                    case 'COMPLETED':
                      return 'Completado';
                    case 'PENDING':
                      return 'Pendiente';
                    case 'FAILED':
                      return 'Fallido';
                    case 'REFUNDED':
                      return 'Reembolsado';
                    case 'CANCELLED':
                      return 'Cancelado';
                    default:
                      return status;
                  }
                };

                return (
                  <View
                    key={payment.id || index}
                    style={styles.paymentRowCompact}
                  >
                    <Text
                      style={[
                        styles.paymentMethodCompact,
                        { color: theme.colors.onSurface },
                      ]}
                    >
                      üí≥ {getPaymentMethodLabel(payment.paymentMethod)}
                    </Text>
                    <Text
                      style={[
                        styles.paymentDateCompact,
                        { color: theme.colors.onSurfaceVariant },
                      ]}
                    >
                      {format(new Date(payment.createdAt), 'HH:mm', {
                        locale: es,
                      })}
                    </Text>
                    <View
                      style={[
                        styles.paymentStatusBadgeCompact,
                        {
                          backgroundColor:
                            getPaymentStatusColor(payment.paymentStatus) + '20',
                        },
                      ]}
                    >
                      <Text
                        style={[
                          styles.paymentStatusTextCompact,
                          {
                            color: getPaymentStatusColor(payment.paymentStatus),
                          },
                        ]}
                      >
                        {getPaymentStatusLabel(payment.paymentStatus)}
                      </Text>
                    </View>
                    <Text
                      style={[
                        styles.paymentAmountCompact,
                        { color: theme.colors.primary },
                      ]}
                    >
                      ${payment.amount.toFixed(2)}
                    </Text>
                  </View>
                );
              })}
            </View>
            <Divider style={styles.divider} />
          </>
        )}

        {order?.ticketImpressions && order.ticketImpressions.length > 0 && (
          <>
            <View style={styles.ticketImpressionsSection}>
              <TouchableOpacity
                style={styles.collapsibleHeader}
                onPress={() => setShowPrintHistory(!showPrintHistory)}
                activeOpacity={0.7}
              >
                <Text
                  style={[styles.sectionTitle, { color: theme.colors.primary }]}
                >
                  üñ®Ô∏è Historial de Impresiones ({order.ticketImpressions.length})
                </Text>
                <IconButton
                  icon={showPrintHistory ? 'chevron-up' : 'chevron-down'}
                  size={20}
                  style={styles.collapseIcon}
                />
              </TouchableOpacity>

              {showPrintHistory && (
                <View style={styles.collapsibleContent}>
                  {order.ticketImpressions.map((impression, index) => {
                    const getTicketTypeLabel = (type: string) => {
                      switch (type) {
                        case 'KITCHEN':
                          return 'üç≥ Cocina';
                        case 'BAR':
                          return 'üç∫ Barra';
                        case 'BILLING':
                          return 'üíµ Cuenta';
                        case 'CUSTOMER_COPY':
                          return 'üìÑ Copia Cliente';
                        case 'GENERAL':
                          return 'üìã General';
                        default:
                          return type;
                      }
                    };

                    return (
                      <View
                        key={impression.id || index}
                        style={styles.impressionRow}
                      >
                        <View style={styles.impressionLeft}>
                          <Text
                            style={[
                              styles.impressionType,
                              { color: theme.colors.onSurface },
                            ]}
                          >
                            {getTicketTypeLabel(impression.ticketType)}
                          </Text>
                          <View style={styles.impressionDetails}>
                            {impression.user && (
                              <Text
                                style={[
                                  styles.impressionUser,
                                  { color: theme.colors.onSurfaceVariant },
                                ]}
                              >
                                por {impression.user.firstName || ''}{' '}
                                {impression.user.lastName || ''}
                              </Text>
                            )}
                            {impression.printer && (
                              <Text
                                style={[
                                  styles.impressionPrinter,
                                  { color: theme.colors.onSurfaceVariant },
                                ]}
                              >
                                üñ®Ô∏è {impression.printer.name}
                              </Text>
                            )}
                          </View>
                        </View>
                        <Text
                          style={[
                            styles.impressionTime,
                            { color: theme.colors.onSurfaceVariant },
                          ]}
                        >
                          {format(
                            new Date(impression.impressionTime),
                            'HH:mm:ss',
                            { locale: es },
                          )}
                        </Text>
                      </View>
                    );
                  })}
                </View>
              )}
            </View>
          </>
        )}
      </ScrollView>

      <Divider style={styles.divider} />

      <View style={styles.footer}>
        <View style={styles.footerLeft}>
          <Text
            style={[
              styles.totalLabel,
              { color: theme.colors.onSurfaceVariant },
            ]}
          >
            Total:
          </Text>
          <Text style={[styles.totalAmount, { color: theme.colors.primary }]}>
            $
            {order
              ? typeof order.total === 'string'
                ? parseFloat(order.total).toFixed(2)
                : (order.total || 0).toFixed(2)
              : '0.00'}
          </Text>
        </View>
        <View
          style={[
            styles.paymentBadge,
            { backgroundColor: paymentStatus.color },
          ]}
        >
          <Text style={styles.paymentBadgeText}>üíµ {paymentStatus.label}</Text>
        </View>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  appbarHeader: {
    elevation: 0,
  },
  header: {
    paddingHorizontal: 16,
    paddingTop: 10,
    paddingBottom: 6,
  },
  headerTopRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 6,
  },
  headerLeft: {
    flex: 1,
  },
  headerBottomRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 4,
  },
  headerDatesRow: {
    gap: 8,
    marginTop: 4,
  },
  chipsRow: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
    flexWrap: 'wrap',
  },
  headerSeparator: {
    fontSize: 14,
    marginHorizontal: 6,
  },
  orderType: {
    fontSize: 15,
    fontWeight: '600',
  },
  headerDate: {
    fontSize: 13,
  },
  headerInfo: {
    // Contenedor para toda la informaci√≥n del header
  },
  infoSection: {
    paddingHorizontal: 16,
    paddingTop: 4,
    paddingBottom: 6,
    gap: 4,
  },
  infoRow: {
    marginVertical: 2,
  },
  contactText: {
    fontSize: 14,
  },
  addressText: {
    fontSize: 14,
    lineHeight: 18,
  },
  tableText: {
    fontSize: 14,
  },
  screenChip: {
    height: 24,
  },
  screenChipText: {
    fontSize: 12,
    marginVertical: -2,
  },
  paymentBadge: {
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 12,
  },
  paymentBadgeText: {
    color: 'white',
    fontSize: 14,
    fontWeight: '600',
  },
  totalAmount: {
    fontSize: 18,
    fontWeight: '700',
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderTopWidth: 1,
    borderTopColor: 'rgba(0,0,0,0.08)',
    backgroundColor: 'inherit',
  },
  footerLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  totalLabel: {
    fontSize: 16,
    fontWeight: '600',
  },
  divider: {
    marginVertical: 2,
  },
  headerStatusChip: {
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 10,
  },
  headerStatusChipText: {
    color: 'white',
    fontSize: 13,
    fontWeight: '600',
  },
  scrollView: {
    flexGrow: 0,
    flexShrink: 1,
    maxHeight: '70%',
  },
  scrollContent: {
    paddingBottom: 8,
  },
  itemsList: {
    padding: 12,
    paddingBottom: 16,
  },
  itemCard: {
    borderRadius: 8,
    overflow: 'hidden',
  },
  itemContent: {
    padding: 10,
  },
  itemHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 6,
  },
  nameContainer: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    marginRight: 8,
  },
  itemQuantity: {
    fontSize: 16,
    fontWeight: '700',
    marginRight: 6,
  },
  itemName: {
    fontSize: 15,
    fontWeight: '600',
    flex: 1,
    lineHeight: 18,
  },
  statusChip: {
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 12,
  },
  statusChipText: {
    color: 'white',
    fontSize: 12,
    fontWeight: '600',
  },
  itemDetailsContainer: {
    marginBottom: 6,
  },
  customizationContainer: {
    marginBottom: 4,
  },
  pizzaCustomizationText: {
    fontSize: 13,
    fontStyle: 'italic',
    lineHeight: 16,
  },
  modifiersContainer: {
    marginTop: 2,
  },
  modifierRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 1,
  },
  modifierText: {
    fontSize: 13,
    flex: 1,
    lineHeight: 16,
  },
  modifierPrice: {
    fontSize: 13,
    fontWeight: '500',
    marginLeft: 4,
  },
  notesContainer: {
    marginTop: 4,
    paddingTop: 4,
    borderTopWidth: 1,
    borderTopColor: 'rgba(0,0,0,0.06)',
  },
  notesText: {
    fontSize: 13,
    fontStyle: 'italic',
    lineHeight: 16,
  },
  priceContainer: {
    marginTop: 6,
    paddingTop: 6,
    borderTopWidth: 1,
    borderTopColor: 'rgba(0,0,0,0.06)',
  },
  priceRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 2,
  },
  priceLabel: {
    fontSize: 13,
    opacity: 0.7,
  },
  priceValue: {
    fontSize: 14,
    fontWeight: '600',
  },
  totalPrice: {
    fontSize: 16,
    fontWeight: '700',
  },
  paymentsSection: {
    paddingHorizontal: 16,
    paddingVertical: 8,
  },
  paymentSummaryCompact: {
    marginBottom: 8,
  },
  summaryCompactRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  summaryCompactLabel: {
    fontSize: 14,
    fontWeight: '500',
  },
  paymentRowCompact: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 6,
    gap: 8,
  },
  paymentMethodCompact: {
    fontSize: 13,
    fontWeight: '500',
    flex: 1,
  },
  paymentDateCompact: {
    fontSize: 12,
  },
  paymentAmountCompact: {
    fontSize: 14,
    fontWeight: '600',
    minWidth: 50,
    textAlign: 'right',
  },
  paymentStatusBadgeCompact: {
    paddingHorizontal: 6,
    paddingVertical: 1,
    borderRadius: 10,
  },
  paymentStatusTextCompact: {
    fontSize: 11,
    fontWeight: '600',
  },
  ticketImpressionsSection: {
    paddingHorizontal: 16,
    paddingVertical: 8,
  },
  collapsibleHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingRight: 4,
  },
  collapseIcon: {
    margin: -8,
  },
  collapsibleContent: {
    marginTop: 8,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 0,
  },
  impressionRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
    paddingLeft: 8,
  },
  impressionLeft: {
    flex: 1,
    gap: 2,
  },
  impressionType: {
    fontSize: 14,
    fontWeight: '500',
  },
  impressionDetails: {
    gap: 2,
  },
  impressionUser: {
    fontSize: 13,
    opacity: 0.7,
  },
  impressionPrinter: {
    fontSize: 13,
    opacity: 0.7,
    fontStyle: 'italic',
  },
  impressionTime: {
    fontSize: 13,
    opacity: 0.7,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
  },
});

================
File: app/src/modules/shiftAudit/components/ShiftSalesSummaryView.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';
import {
  Text,
  IconButton,
  Divider,
  ActivityIndicator,
  DataTable,
  ProgressBar,
  Appbar,
} from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { formatCurrency } from '@/app/lib/formatters';
import { useShiftSalesSummary } from '../hooks/useShiftSalesSummary';
import type {
  CategorySalesSummary,
  SubcategorySalesSummary,
} from '../hooks/useShiftSalesSummary';

interface Props {
  shiftId: string;
  shiftNumber?: number;
  onBack: () => void;
}

export function ShiftSalesSummaryView({ shiftId, shiftNumber, onBack }: Props) {
  const theme = useAppTheme();
  const [expandedCategories, setExpandedCategories] = useState<Set<string>>(
    new Set(),
  );
  const [expandedSubcategories, setExpandedSubcategories] = useState<
    Set<string>
  >(new Set());

  const { data: summary, isLoading, error } = useShiftSalesSummary(shiftId);

  const toggleCategory = (categoryId: string) => {
    const newExpanded = new Set(expandedCategories);
    if (newExpanded.has(categoryId)) {
      newExpanded.delete(categoryId);
    } else {
      newExpanded.add(categoryId);
    }
    setExpandedCategories(newExpanded);
  };

  const toggleSubcategory = (subcategoryId: string) => {
    const newExpanded = new Set(expandedSubcategories);
    if (newExpanded.has(subcategoryId)) {
      newExpanded.delete(subcategoryId);
    } else {
      newExpanded.add(subcategoryId);
    }
    setExpandedSubcategories(newExpanded);
  };

  const renderHeader = () => (
    <Appbar.Header elevated>
      <Appbar.BackAction onPress={onBack} />
      <Appbar.Content
        title={`Resumen de Ventas - Turno #${shiftNumber || summary?.shiftNumber || 'N/A'}`}
        titleStyle={{ fontSize: 18 }}
      />
    </Appbar.Header>
  );

  const renderSummaryCards = () => {
    if (!summary) return null;

    return (
      <View style={styles.summaryCardsContainer}>
        <View style={styles.summaryRow}>
          <View style={styles.summaryCard}>
            <Text style={styles.summaryCardLabel}>VENTAS</Text>
            <Text style={styles.summaryCardValue}>
              {formatCurrency(summary.totalSales)}
            </Text>
          </View>

          <View style={styles.summaryCard}>
            <Text style={styles.summaryCardLabel}>√ìRDENES</Text>
            <Text style={styles.summaryCardValue}>
              {summary.completedOrders}
            </Text>
          </View>
        </View>

        <View style={styles.summaryRow}>
          <View style={styles.summaryCard}>
            <Text style={styles.summaryCardLabel}>PRODUCTOS</Text>
            <Text style={styles.summaryCardValue}>{summary.totalQuantity}</Text>
          </View>

          <View style={styles.summaryCard}>
            <Text style={styles.summaryCardLabel}>PROMEDIO</Text>
            <Text style={styles.summaryCardValue}>
              {formatCurrency(summary.averageTicket)}
            </Text>
          </View>
        </View>

        <Text style={styles.adjustmentNote}>
          * Los totales incluyen ajustes aplicados (descuentos y cargos)
        </Text>
      </View>
    );
  };

  const renderCategoryItem = (category: CategorySalesSummary) => {
    const isExpanded = expandedCategories.has(category.categoryId);

    return (
      <View key={category.categoryId}>
        <TouchableOpacity
          onPress={() => toggleCategory(category.categoryId)}
          activeOpacity={0.7}
        >
          <View style={styles.categoryItem}>
            <View style={styles.categoryHeader}>
              <View style={styles.categoryInfo}>
                <View style={styles.categoryTitleRow}>
                  <Text style={styles.categoryName}>
                    {category.categoryName}
                  </Text>
                  <Text style={styles.categoryPercentage}>
                    {category.percentage.toFixed(1)}%
                  </Text>
                </View>
                <View style={styles.categoryStatsRow}>
                  <Text style={styles.categoryQuantity}>
                    {category.quantity} productos vendidos
                  </Text>
                  <Text style={styles.categoryAmount}>
                    {formatCurrency(category.totalAmount)}
                  </Text>
                </View>
                <ProgressBar
                  progress={category.percentage / 100}
                  style={styles.progressBar}
                  color={theme.colors.primary}
                />
              </View>
              <IconButton
                icon={isExpanded ? 'chevron-up' : 'chevron-down'}
                size={24}
                iconColor={theme.colors.onSurfaceVariant}
                style={styles.expandIcon}
              />
            </View>
          </View>
        </TouchableOpacity>

        {isExpanded && category.subcategories.length > 0 && (
          <View style={styles.subcategoriesContainer}>
            {category.subcategories.map((subcategory) =>
              renderSubcategoryItem(subcategory),
            )}
          </View>
        )}
      </View>
    );
  };

  const renderSubcategoryItem = (subcategory: SubcategorySalesSummary) => {
    const isExpanded = expandedSubcategories.has(subcategory.subcategoryId);

    return (
      <View key={subcategory.subcategoryId}>
        <TouchableOpacity
          onPress={() => toggleSubcategory(subcategory.subcategoryId)}
          activeOpacity={0.7}
        >
          <View style={styles.subcategoryItem}>
            <View style={styles.subcategoryHeader}>
              <View style={styles.subcategoryInfo}>
                <Text style={styles.subcategoryName}>
                  {subcategory.subcategoryName}
                </Text>
                <Text style={styles.subcategoryStats}>
                  {subcategory.quantity} productos ‚Ä¢{' '}
                  {formatCurrency(subcategory.totalAmount)}
                </Text>
              </View>
              <IconButton
                icon={isExpanded ? 'chevron-up' : 'chevron-down'}
                size={18}
                iconColor={theme.colors.onSurfaceVariant}
              />
            </View>
          </View>
        </TouchableOpacity>

        {isExpanded && subcategory.products.length > 0 && (
          <View style={styles.productsContainer}>
            {subcategory.products.map((product) => (
              <View key={product.productId} style={styles.productItem}>
                <Text style={styles.productName}>{product.productName}</Text>
                <View style={styles.productStats}>
                  <Text style={styles.productQuantity}>
                    {product.quantity}x
                  </Text>
                  <Text style={styles.productAmount}>
                    {formatCurrency(product.totalAmount)}
                  </Text>
                </View>
              </View>
            ))}
          </View>
        )}
      </View>
    );
  };

  const renderTopProducts = () => {
    if (!summary || !summary.topProducts || summary.topProducts.length === 0) {
      return null;
    }

    return (
      <View style={styles.topProductsSection}>
        <Text style={styles.sectionTitle}>Top 10 Productos M√°s Vendidos</Text>
        <View style={styles.topProductsTable}>
          <DataTable>
            <DataTable.Header>
              <DataTable.Title style={styles.rankColumn}>#</DataTable.Title>
              <DataTable.Title style={styles.productColumn}>
                Producto
              </DataTable.Title>
              <DataTable.Title numeric style={styles.quantityColumn}>
                Cant.
              </DataTable.Title>
              <DataTable.Title numeric style={styles.amountColumn}>
                Total
              </DataTable.Title>
            </DataTable.Header>

            {summary.topProducts.slice(0, 10).map((product, index) => (
              <DataTable.Row key={product.productId}>
                <DataTable.Cell style={styles.rankColumn}>
                  <Text style={styles.rankNumber}>{index + 1}</Text>
                </DataTable.Cell>
                <DataTable.Cell style={styles.productColumn}>
                  <Text style={styles.topProductName} numberOfLines={2}>
                    {product.productName}
                  </Text>
                </DataTable.Cell>
                <DataTable.Cell numeric style={styles.quantityColumn}>
                  {product.quantity}
                </DataTable.Cell>
                <DataTable.Cell numeric style={styles.amountColumn}>
                  {formatCurrency(product.totalAmount)}
                </DataTable.Cell>
              </DataTable.Row>
            ))}
          </DataTable>
        </View>
      </View>
    );
  };

  const renderContent = () => {
    if (isLoading) {
      return (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" />
          <Text style={styles.loadingText}>Cargando resumen de ventas...</Text>
        </View>
      );
    }

    if (error) {
      return (
        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>
            Error al cargar el resumen de ventas
          </Text>
        </View>
      );
    }

    if (!summary) {
      return (
        <View style={styles.emptyContainer}>
          <Text style={styles.emptyText}>No hay datos disponibles</Text>
        </View>
      );
    }

    return (
      <ScrollView
        contentContainerStyle={styles.scrollContent}
        showsVerticalScrollIndicator={false}
      >
        {renderSummaryCards()}

        <Divider style={styles.sectionDivider} />

        <View style={styles.categoriesSection}>
          <Text style={styles.sectionTitle}>Ventas por Categor√≠a</Text>
          {summary.categories.map(renderCategoryItem)}
        </View>

        <Divider style={styles.sectionDivider} />

        {renderTopProducts()}
      </ScrollView>
    );
  };

  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    scrollContent: {
      paddingBottom: theme.spacing.xl,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.xl,
    },
    loadingText: {
      marginTop: theme.spacing.m,
      color: theme.colors.onSurfaceVariant,
    },
    errorContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.xl,
    },
    errorText: {
      color: theme.colors.error,
      fontSize: 16,
    },
    emptyContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.xl,
    },
    emptyText: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 16,
    },
    summaryCardsContainer: {
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.s,
    },
    summaryRow: {
      flexDirection: 'row',
      gap: theme.spacing.s,
      marginBottom: theme.spacing.s,
    },
    summaryCard: {
      flex: 1,
      paddingVertical: theme.spacing.s,
      paddingHorizontal: theme.spacing.m,
      borderRadius: theme.roundness,
      backgroundColor: theme.colors.surfaceVariant,
      alignItems: 'center',
    },
    summaryCardLabel: {
      fontSize: 10,
      fontWeight: '600',
      color: theme.colors.onSurfaceVariant,
      letterSpacing: 0.3,
    },
    summaryCardValue: {
      fontSize: 16,
      fontWeight: '700',
      color: theme.colors.onSurface,
      marginTop: 2,
    },
    adjustmentNote: {
      fontSize: 11,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      textAlign: 'center',
      marginTop: theme.spacing.s,
      paddingHorizontal: theme.spacing.m,
    },
    sectionDivider: {
      marginVertical: theme.spacing.s,
      marginHorizontal: theme.spacing.m,
    },
    categoriesSection: {
      paddingHorizontal: theme.spacing.m,
    },
    sectionTitle: {
      fontSize: 18,
      fontWeight: '700',
      color: theme.colors.onSurface,
      marginBottom: theme.spacing.m,
    },
    categoryItem: {
      marginBottom: theme.spacing.s,
      padding: theme.spacing.m,
      borderRadius: theme.roundness * 2,
      backgroundColor: theme.colors.surface,
      elevation: 1,
    },
    categoryHeader: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    categoryInfo: {
      flex: 1,
    },
    categoryTitleRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.xs,
    },
    categoryName: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    categoryPercentage: {
      fontSize: 18,
      fontWeight: '700',
      color: theme.colors.primary,
    },
    categoryStatsRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.s,
    },
    categoryQuantity: {
      fontSize: 13,
      color: theme.colors.onSurfaceVariant,
    },
    categoryAmount: {
      fontSize: 15,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    expandIcon: {
      marginLeft: theme.spacing.xs,
    },
    progressBar: {
      height: 4,
      borderRadius: 2,
      backgroundColor: theme.colors.surfaceVariant,
    },
    subcategoriesContainer: {
      paddingLeft: theme.spacing.m,
      paddingBottom: theme.spacing.s,
    },
    subcategoryItem: {
      marginBottom: theme.spacing.xs,
      marginHorizontal: theme.spacing.xs,
      padding: theme.spacing.m,
      borderRadius: theme.roundness,
      backgroundColor: theme.colors.background,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
    },
    subcategoryHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    subcategoryInfo: {
      flex: 1,
    },
    subcategoryName: {
      fontSize: 14,
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    subcategoryStats: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginTop: 4,
    },
    productsContainer: {
      paddingLeft: theme.spacing.m,
      paddingTop: theme.spacing.xs,
    },
    productItem: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingVertical: theme.spacing.s,
      paddingHorizontal: theme.spacing.m,
      marginHorizontal: theme.spacing.s,
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness,
      marginBottom: theme.spacing.xs,
    },
    productName: {
      flex: 1,
      fontSize: 12,
      color: theme.colors.onSurface,
    },
    productStats: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.m,
    },
    productQuantity: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      fontWeight: '500',
      minWidth: 30,
      textAlign: 'right',
    },
    productAmount: {
      fontSize: 12,
      fontWeight: '600',
      color: theme.colors.primary,
      minWidth: 60,
      textAlign: 'right',
    },
    topProductsSection: {
      paddingHorizontal: theme.spacing.m,
      paddingBottom: theme.spacing.m,
    },
    topProductsTable: {
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness * 2,
      overflow: 'hidden',
    },
    rankColumn: {
      flex: 0.5,
    },
    productColumn: {
      flex: 3,
    },
    quantityColumn: {
      flex: 1,
    },
    amountColumn: {
      flex: 1.5,
    },
    rankNumber: {
      fontWeight: '700',
      color: theme.colors.primary,
    },
    topProductName: {
      fontSize: 13,
      color: theme.colors.onSurface,
    },
  });

  return (
    <View style={styles.container}>
      {renderHeader()}
      {renderContent()}
    </View>
  );
}

================
File: app/src/modules/shiftAudit/hooks/useShiftOrders.ts
================
import { useQuery } from '@tanstack/react-query';
import { shiftsService } from '@/services/shifts';
import type { Order } from '@/app/schemas/domain/order.schema';
import type { Shift, ShiftSummary } from '../types';

export const useShiftOrders = (shiftId: string | undefined) => {
  return useQuery<Order[], Error>({
    queryKey: ['shifts', shiftId, 'orders'],
    queryFn: () => shiftsService.getOrdersByShift(shiftId!),
    enabled: !!shiftId,
    staleTime: 300000, // 5 minutos
  });
};

export const useShiftSummary = (shiftId: string | undefined) => {
  const shiftQuery = useQuery<Shift, Error>({
    queryKey: ['shifts', shiftId],
    queryFn: () => shiftsService.getById(shiftId!),
    enabled: !!shiftId,
  });

  const ordersQuery = useQuery<Order[], Error>({
    queryKey: ['shifts', shiftId, 'orders'],
    queryFn: () => shiftsService.getOrdersByShift(shiftId!),
    enabled: !!shiftId && shiftQuery.isSuccess,
  });

  const summary: ShiftSummary | undefined =
    shiftQuery.data && ordersQuery.data
      ? shiftsService.calculateShiftSummary(shiftQuery.data, ordersQuery.data)
      : undefined;

  return {
    summary,
    isLoading: shiftQuery.isLoading || ordersQuery.isLoading,
    error: shiftQuery.error || ordersQuery.error,
  };
};

================
File: app/src/modules/shiftAudit/navigation/ShiftAuditStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { ShiftsListScreen } from '../screens/ShiftsListScreen';
import type { ShiftAuditStackParamList } from './types';

const Stack = createNativeStackNavigator<ShiftAuditStackParamList>();

export function ShiftAuditStackNavigator() {
  return (
    <Stack.Navigator
      screenOptions={{
        headerShown: false,
      }}
    >
      <Stack.Screen
        name="ShiftsList"
        component={ShiftsListScreen}
        options={{
          title: 'Historial de Turnos',
        }}
      />
    </Stack.Navigator>
  );
}

================
File: app/src/modules/shiftAudit/navigation/types.ts
================
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import type { CompositeScreenProps } from '@react-navigation/native';
import type { DrawerScreenProps } from '@react-navigation/drawer';
import type { DrawerNavigatorParamList } from '@/app/navigation/types';

export type ShiftAuditStackParamList = {
  ShiftsList: undefined;
};

export type ShiftAuditStackScreenProps<
  T extends keyof ShiftAuditStackParamList,
> = CompositeScreenProps<
  NativeStackScreenProps<ShiftAuditStackParamList, T>,
  DrawerScreenProps<DrawerNavigatorParamList>
>;

export type ShiftsListScreenNavigationProp =
  ShiftAuditStackScreenProps<'ShiftsList'>['navigation'];
export type ShiftsListScreenRouteProp =
  ShiftAuditStackScreenProps<'ShiftsList'>['route'];

export type ShiftAuditStackNavigationProp = ShiftsListScreenNavigationProp;

================
File: app/src/modules/shiftAudit/screens/index.ts
================
export { ShiftsListScreen } from './ShiftsListScreen';

================
File: app/src/modules/shiftAudit/types/index.ts
================
export interface Shift {
  id: string;
  date: string;
  globalShiftNumber: number;
  shiftNumber: number;
  status: 'open' | 'closed';
  openedAt: string;
  closedAt: string | null;
  openedBy: User;
  closedBy: User | null;
  initialCash: number;
  finalCash: number | null;
  totalSales: number | null;
  totalOrders: number | null;
  cashDifference: number | null;
  expectedCash?: number | null;
  notes: string | null;
  closeNotes: string | null;
  createdAt?: string;
  updatedAt?: string;
}

export interface User {
  id: string;
  email?: string;
  firstName: string;
  lastName: string;
}

export interface ShiftSummary {
  shift: Shift;
  ordersCount: number;
  totalSales: number;
  paymentMethodsSummary: PaymentMethodSummary[];
  productsSummary: ProductSummary[];
}

export interface PaymentMethodSummary {
  method: string;
  count: number;
  total: number;
}

export interface ProductSummary {
  productName: string;
  quantity: number;
  total: number;
}

export interface ShiftOrder {
  id: string;
  orderNumber: string;
  total: number;
  status: string;
  paymentMethod: string;
  customerName: string | null;
  createdAt: string;
  items: OrderItem[];
}

export interface OrderItem {
  id: string;
  productName: string;
  quantity: number;
  unitPrice: number;
  total: number;
  modifiers?: string[];
}

================
File: app/src/modules/sync/screens/SyncStatusScreen.tsx
================
import React, { useState } from 'react';
import {
  ScrollView,
  RefreshControl,
  View,
  useWindowDimensions,
} from 'react-native';
import {
  Card,
  List,
  Text,
  ActivityIndicator,
  Divider,
  Icon,
  Chip,
  Surface,
} from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useQuery } from '@tanstack/react-query';
import { formatDistanceToNow } from 'date-fns';
import { es } from 'date-fns/locale';
import { syncService } from '../services/syncService';
import {
  SyncActivity,
  SyncStatus,
  SyncActivityType,
  SYNC_TYPE_LABELS,
  SYNC_DIRECTION_LABELS,
} from '../types/sync.types';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { StyleSheet } from 'react-native';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';

export function SyncStatusScreen() {
  const theme = useAppTheme();
  const { width: screenWidth } = useWindowDimensions();
  const { isTablet, deviceType } = useResponsive();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const [refreshing, setRefreshing] = useState(false);

  // Ajustar padding seg√∫n el dispositivo
  const contentPadding = isTablet ? theme.spacing.l : theme.spacing.m;

  // Query para el estado del servicio
  const {
    data: syncStatus,
    isLoading: isLoadingStatus,
    error: statusError,
    refetch: refetchStatus,
  } = useQuery({
    queryKey: ['sync-status'],
    queryFn: () => syncService.getSyncStatus(),
    refetchInterval: 30000, // Actualizar cada 30 segundos
  });

  // Query para la actividad reciente
  const {
    data: syncActivity,
    isLoading: isLoadingActivity,
    error: activityError,
    refetch: refetchActivity,
  } = useQuery({
    queryKey: ['sync-activity'],
    queryFn: () => syncService.getSyncActivity(20),
    refetchInterval: 30000,
  });

  const handleRefresh = async () => {
    setRefreshing(true);
    try {
      await Promise.all([refetchStatus(), refetchActivity()]);
    } catch (error) {
      showSnackbar('Error al actualizar informaci√≥n', 'error');
    } finally {
      setRefreshing(false);
    }
  };

  const formatTimestamp = (timestamp: string) => {
    try {
      return formatDistanceToNow(new Date(timestamp), {
        addSuffix: true,
        locale: es,
      });
    } catch {
      return 'Fecha inv√°lida';
    }
  };

  const getActivityIcon = (type: SyncActivityType) => {
    switch (type) {
      case SyncActivityType.PULL_CHANGES:
        return 'cloud-download';
      case SyncActivityType.RESTAURANT_DATA:
        return 'store';
      case SyncActivityType.ORDER_STATUS:
        return 'check-circle';
      default:
        return 'sync';
    }
  };

  const getStatusColor = (success: boolean) => {
    return success ? theme.colors.success : theme.colors.error;
  };

  // Crear estilos din√°micos con el tema
  const styles = React.useMemo(
    () => createStyles(theme, isTablet),
    [theme, isTablet],
  );

  if (isLoadingStatus || isLoadingActivity) {
    return (
      <SafeAreaView style={styles.container}>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
          <Text style={styles.loadingText}>Cargando informaci√≥n...</Text>
        </View>
      </SafeAreaView>
    );
  }

  if (statusError || activityError) {
    return (
      <SafeAreaView style={styles.container}>
        <View style={styles.errorContainer}>
          <Icon source="alert-circle" size={48} color={theme.colors.error} />
          <Text style={styles.errorText}>
            Error al cargar informaci√≥n de sincronizaci√≥n
          </Text>
        </View>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView style={styles.container}>
      <ScrollView
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={handleRefresh}
            colors={[theme.colors.primary]}
            tintColor={theme.colors.primary}
          />
        }
        contentContainerStyle={[
          styles.scrollContent,
          { padding: contentPadding },
          isTablet && styles.scrollContentTablet,
        ]}
      >
        {/* Estado del Servicio */}
        <Card style={styles.card} mode="elevated">
          <Card.Title
            title="Estado del Servicio"
            titleVariant="headlineSmall"
            left={(props) => <Icon {...props} source="information" />}
          />
          <Card.Content>
            <List.Item
              title="Sincronizaci√≥n"
              titleStyle={styles.listItemTitle}
              description={syncStatus?.enabled ? 'Habilitada' : 'Deshabilitada'}
              descriptionStyle={styles.listItemDescription}
              left={(props) => (
                <List.Icon
                  {...props}
                  icon={syncStatus?.enabled ? 'check-circle' : 'close-circle'}
                  color={
                    syncStatus?.enabled
                      ? theme.colors.success
                      : theme.colors.error
                  }
                />
              )}
            />
            <List.Item
              title="WebSocket"
              titleStyle={styles.listItemTitle}
              description={
                syncStatus?.webSocketEnabled
                  ? syncStatus?.webSocketConnected
                    ? 'Conectado'
                    : syncStatus?.webSocketFailed
                      ? 'Conexi√≥n fallida'
                      : 'Intentando conectar...'
                  : 'Deshabilitado'
              }
              descriptionStyle={[
                styles.listItemDescription,
                syncStatus?.webSocketFailed && { color: theme.colors.error },
              ]}
              left={(props) => (
                <List.Icon
                  {...props}
                  icon={
                    syncStatus?.webSocketFailed
                      ? 'access-point-off'
                      : 'access-point'
                  }
                  color={
                    syncStatus?.webSocketConnected
                      ? theme.colors.success
                      : syncStatus?.webSocketFailed
                        ? theme.colors.error
                        : syncStatus?.webSocketEnabled
                          ? theme.colors.warning
                          : theme.colors.outline
                  }
                />
              )}
            />
            {syncStatus?.remoteUrl && (
              <List.Item
                title="Servidor Remoto"
                titleStyle={styles.listItemTitle}
                description={syncStatus.remoteUrl}
                descriptionStyle={styles.listItemDescription}
                left={(props) => <List.Icon {...props} icon="server" />}
              />
            )}
            <List.Item
              title="Modo"
              titleStyle={styles.listItemTitle}
              description="Pull (bajo demanda)"
              descriptionStyle={styles.listItemDescription}
              left={(props) => <List.Icon {...props} icon="download" />}
            />
          </Card.Content>
        </Card>

        {/* Actividad Reciente */}
        <Card style={styles.card} mode="elevated">
          <Card.Title
            title="Actividad Reciente"
            titleVariant="headlineSmall"
            subtitle={`√öltimas ${syncActivity?.length || 0} sincronizaciones`}
            left={(props) => <Icon {...props} source="history" />}
          />
          <Card.Content>
            {syncActivity && syncActivity.length > 0 ? (
              syncActivity.map((activity, index) => (
                <React.Fragment key={activity.id}>
                  <Surface
                    style={[
                      styles.activityItem,
                      !activity.success && styles.activityItemError,
                    ]}
                    elevation={0}
                  >
                    <View style={styles.activityHeader}>
                      <View style={styles.activityLeft}>
                        <Icon
                          source={getActivityIcon(activity.type)}
                          size={24}
                          color={getStatusColor(activity.success)}
                        />
                        <View style={styles.activityInfo}>
                          <Text
                            variant="bodyMedium"
                            style={styles.activityType}
                          >
                            {SYNC_TYPE_LABELS[activity.type]}
                          </Text>
                          <Text variant="bodySmall" style={styles.activityTime}>
                            {formatTimestamp(activity.timestamp)}
                          </Text>
                        </View>
                      </View>
                      <View style={styles.activityRight}>
                        <Chip
                          compact
                          mode="flat"
                          textStyle={[
                            styles.chipText,
                            {
                              color:
                                activity.direction === 'IN'
                                  ? theme.colors.onInfoContainer
                                  : theme.colors.onSuccessContainer,
                            },
                          ]}
                          style={[
                            styles.directionChip,
                            activity.direction === 'IN'
                              ? styles.chipIn
                              : styles.chipOut,
                          ]}
                        >
                          {SYNC_DIRECTION_LABELS[activity.direction]}
                        </Chip>
                        <Icon
                          source={activity.success ? 'check' : 'close'}
                          size={20}
                          color={getStatusColor(activity.success)}
                        />
                      </View>
                    </View>
                  </Surface>
                  {index < syncActivity.length - 1 && (
                    <Divider style={styles.divider} />
                  )}
                </React.Fragment>
              ))
            ) : (
              <View style={styles.emptyState}>
                <Icon
                  source="cloud-off-outline"
                  size={48}
                  color={theme.colors.outline}
                />
                <Text
                  variant="bodyMedium"
                  style={[styles.emptyText, { color: theme.colors.outline }]}
                >
                  No hay actividad reciente
                </Text>
              </View>
            )}
          </Card.Content>
        </Card>

        {/* Informaci√≥n adicional */}
        <Card style={[styles.card, styles.infoCard]} mode="contained">
          <Card.Content>
            <View style={styles.infoRow}>
              <Icon
                source="information-outline"
                size={20}
                color={theme.colors.onInfoContainer}
              />
              <Text variant="bodySmall" style={styles.infoText}>
                La sincronizaci√≥n se ejecuta autom√°ticamente cuando hay cambios
                pendientes. No es necesaria ninguna acci√≥n manual.
              </Text>
            </View>
          </Card.Content>
        </Card>
      </ScrollView>
    </SafeAreaView>
  );
}

const createStyles = (
  theme: ReturnType<typeof useAppTheme>,
  isTablet: boolean,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    scrollContent: {
      paddingBottom: theme.spacing.xl,
    },
    scrollContentTablet: {
      maxWidth: 800,
      alignSelf: 'center',
      width: '100%',
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
    loadingText: {
      marginTop: theme.spacing.m,
      color: theme.colors.onSurfaceVariant,
    },
    errorContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.xl,
    },
    errorText: {
      marginTop: theme.spacing.m,
      textAlign: 'center',
      color: theme.colors.onSurfaceVariant,
    },
    card: {
      marginBottom: theme.spacing.m,
      elevation: 2,
    },
    listItemTitle: {
      fontSize: isTablet ? 16 : 14,
      color: theme.colors.onSurface,
    },
    listItemDescription: {
      fontSize: isTablet ? 14 : 12,
      color: theme.colors.onSurfaceVariant,
    },
    activityItem: {
      padding: theme.spacing.m,
      borderRadius: theme.roundness,
      marginVertical: theme.spacing.xs,
      backgroundColor: theme.colors.surfaceVariant,
    },
    activityItemError: {
      backgroundColor: theme.colors.errorContainer,
    },
    activityHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    activityLeft: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
    },
    activityInfo: {
      marginLeft: theme.spacing.m,
      flex: 1,
    },
    activityType: {
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    activityTime: {
      opacity: 0.7,
      marginTop: 2,
      color: theme.colors.onSurfaceVariant,
    },
    activityRight: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
    },
    directionChip: {
      height: 24,
    },
    chipText: {
      fontSize: isTablet ? 12 : 11,
      marginVertical: 0,
      marginHorizontal: theme.spacing.s,
    },
    chipIn: {
      backgroundColor: theme.colors.infoContainer,
    },
    chipOut: {
      backgroundColor: theme.colors.successContainer,
    },
    divider: {
      marginVertical: theme.spacing.xs,
    },
    emptyState: {
      alignItems: 'center',
      padding: theme.spacing.xl,
    },
    emptyText: {
      marginTop: theme.spacing.m,
    },
    infoCard: {
      backgroundColor: theme.colors.infoContainer,
    },
    infoRow: {
      flexDirection: 'row',
      alignItems: 'flex-start',
    },
    infoText: {
      marginLeft: theme.spacing.s,
      flex: 1,
      lineHeight: 20,
      color: theme.colors.onInfoContainer,
    },
  });

================
File: app/src/modules/sync/types/sync.types.ts
================
// Tipos simplificados para el nuevo sistema de sincronizaci√≥n

export enum SyncActivityType {
  PULL_CHANGES = 'PULL_CHANGES',
  RESTAURANT_DATA = 'RESTAURANT_DATA',
  ORDER_STATUS = 'ORDER_STATUS',
}

export type SyncDirection = 'IN' | 'OUT';

export interface SyncActivity {
  id: string;
  type: SyncActivityType;
  direction: SyncDirection;
  success: boolean;
  timestamp: string;
}

export interface SyncStatus {
  enabled: boolean;
  webSocketEnabled: boolean;
  webSocketConnected?: boolean;
  webSocketFailed?: boolean;
  remoteUrl: string | null;
  mode: string;
}

// Mapeo de tipos para mostrar en la UI
export const SYNC_TYPE_LABELS: Record<SyncActivityType, string> = {
  [SyncActivityType.PULL_CHANGES]: '√ìrdenes y Clientes',
  [SyncActivityType.RESTAURANT_DATA]: 'Men√∫ y Configuraci√≥n',
  [SyncActivityType.ORDER_STATUS]: 'Estado de Orden',
};

export const SYNC_DIRECTION_LABELS: Record<SyncDirection, string> = {
  IN: 'Desde la nube',
  OUT: 'Hacia la nube',
};

================
File: app/src/modules/users/services/usersApi.service.ts
================
import apiClient from '@/app/services/apiClient';
import { ApiError } from '@/app/lib/errors';
import { API_PATHS } from '@/app/constants/apiPaths';
import type {
  User,
  CreateUserDto,
  UpdateUserDto,
  UsersQuery,
  UsersResponse,
} from '../types';

export const usersApiService = {
  async findAll(params?: UsersQuery): Promise<UsersResponse> {
    const queryParams = new URLSearchParams();

    if (params?.page) queryParams.append('page', params.page.toString());
    if (params?.limit) queryParams.append('limit', params.limit.toString());
    if (params?.search) queryParams.append('search', params.search);
    if (params?.sortBy) queryParams.append('sortBy', params.sortBy);
    if (params?.sortOrder) queryParams.append('sortOrder', params.sortOrder);

    if (params?.filters) {
      if (params.filters.isActive !== undefined) {
        queryParams.append(
          'filters[isActive]',
          params.filters.isActive.toString(),
        );
      }
      if (params.filters.roles && params.filters.roles.length > 0) {
        queryParams.append(
          'filters[roles]',
          JSON.stringify(params.filters.roles),
        );
      }
    }

    const response = await apiClient.get(
      `${API_PATHS.USERS}?${queryParams.toString()}`,
    );

    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status);
    }

    return response.data;
  },

  async findOne(id: string): Promise<User> {
    const response = await apiClient.get(
      API_PATHS.USERS_BY_ID.replace(':id', id),
    );
    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status);
    }
    return response.data;
  },

  async create(data: CreateUserDto): Promise<User> {
    const response = await apiClient.post(API_PATHS.USERS, data);
    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status);
    }
    return response.data;
  },

  async update(id: string, data: UpdateUserDto): Promise<User> {
    const response = await apiClient.patch(
      API_PATHS.USERS_BY_ID.replace(':id', id),
      data,
    );
    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status);
    }
    return response.data;
  },

  async remove(id: string): Promise<void> {
    const response = await apiClient.delete(
      API_PATHS.USERS_BY_ID.replace(':id', id),
    );
    if (!response.ok) {
      throw ApiError.fromApiResponse(response.data, response.status);
    }
  },

  async resetPassword(id: string, newPassword: string): Promise<User> {
    const response = await apiClient.patch(
      API_PATHS.USERS_BY_ID.replace(':id', id),
      {
        password: newPassword,
      },
    );
    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status);
    }
    return response.data;
  },

  async toggleActive(id: string, isActive: boolean): Promise<User> {
    const response = await apiClient.patch(
      API_PATHS.USERS_BY_ID.replace(':id', id),
      {
        isActive,
      },
    );
    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status);
    }
    return response.data;
  },
};

================
File: app/src/services/serverConnectionService.ts
================
import { discoveryService } from '@/app/services/discoveryService';
import { healthMonitoringService } from '@/services/healthMonitoringService';
import { autoReconnectService } from '@/services/autoReconnectService';
import EncryptedStorage from '@/app/services/secureStorageService';
import NetInfo from '@react-native-community/netinfo';

export type ConnectionMode = 'auto' | 'manual';

interface ConnectionState {
  isConnected: boolean;
  isConnecting: boolean;
  lastError: string | null;
  mode: ConnectionMode;
  currentUrl: string | null;
  hasWifi: boolean;
  isHealthy: boolean;
  isSearching: boolean;
  error: string | null;
}

class ServerConnectionService {
  private state: ConnectionState = {
    isConnected: false,
    isConnecting: false,
    lastError: null,
    mode: 'auto',
    currentUrl: null,
    hasWifi: false,
    isHealthy: false,
    isSearching: false,
    error: null,
  };

  private listeners: Array<(state: ConnectionState) => void> = [];
  private connectionPromise: Promise<void> | null = null;
  private healthUnsubscribe: (() => void) | null = null;
  private reconnectUnsubscribe: (() => void) | null = null;
  private netInfoUnsubscribe: (() => void) | null = null;

  constructor() {
    this.loadConnectionMode();
    this.initializeListeners();

    setTimeout(() => {
      if (!this.state.isConnected && !this.state.isConnecting) {
        this.connect().catch(() => {});
      }
    }, 1000);
  }

  private async loadConnectionMode() {
    try {
      const savedMode = (await EncryptedStorage.getItem(
        'connection_mode',
      )) as ConnectionMode;
      if (savedMode) {
        this.state.mode = savedMode;
      }
    } catch (error) {}
  }

  private initializeListeners() {
    this.netInfoUnsubscribe = NetInfo.addEventListener((state) => {
      const hasWifi =
        !!state.isConnected &&
        (state.type === 'wifi' || state.type === 'ethernet');

      const previousHasWifi = this.state.hasWifi;

      // Si perdemos el WiFi, tambi√©n perdemos la conexi√≥n
      if (!hasWifi && previousHasWifi) {
        this.updateState({
          hasWifi: false,
          isConnected: false,
          isHealthy: false,
          error: 'Sin conexi√≥n WiFi',
        });
        // Detener el monitoreo de salud cuando no hay WiFi
        healthMonitoringService.stopMonitoring();
      }
      // Si recuperamos el WiFi y no estamos conectados, intentar reconectar
      else if (hasWifi && !previousHasWifi) {
        this.updateState({ hasWifi });
        // Intentar reconectar autom√°ticamente
        setTimeout(() => {
          if (!this.state.isConnected && !this.state.isConnecting) {
            this.connect().catch(() => {});
          }
        }, 1000);
      } else {
        this.updateState({ hasWifi });
      }
    });

    this.healthUnsubscribe = healthMonitoringService.subscribe(
      (healthState) => {
        const previousHealthy = this.state.isHealthy;
        this.updateState({
          isHealthy: healthState.isAvailable,
          error: healthState.message || this.state.error,
        });

        if (!previousHealthy && healthState.isAvailable && this.state.hasWifi) {
          this.updateState({
            isConnected: true,
            isHealthy: true,
            error: null,
            isSearching: false,
          });
        }
      },
    );

    this.reconnectUnsubscribe = autoReconnectService.subscribe(
      (reconnectState) => {
        this.updateState({
          isSearching: reconnectState.isReconnecting,
          error: reconnectState.lastError || this.state.error,
        });
      },
    );

    autoReconnectService.on('reconnected', async () => {
      const apiUrl = await discoveryService.getApiUrl();

      // Reinicializar el API client con la nueva URL
      const { reinitializeApiClient } = await import(
        '@/app/services/apiClient'
      );
      await reinitializeApiClient(apiUrl);

      this.updateState({
        isConnected: true,
        isConnecting: false,
        currentUrl: apiUrl,
        isHealthy: true,
        error: null,
        lastError: null,
        isSearching: false,
      });
      healthMonitoringService.startMonitoring();
    });

    healthMonitoringService.on('recovered', async () => {
      const apiUrl = await discoveryService.getApiUrl();

      // Reinicializar el API client con la nueva URL
      const { reinitializeApiClient } = await import(
        '@/app/services/apiClient'
      );
      await reinitializeApiClient(apiUrl);

      this.updateState({
        isConnected: true,
        isConnecting: false,
        currentUrl: apiUrl,
        isHealthy: true,
        error: null,
        lastError: null,
        isSearching: false,
      });

      if (!healthMonitoringService.isMonitoring()) {
        healthMonitoringService.startMonitoring();
      }
    });

    NetInfo.fetch().then((state) => {
      const hasWifi =
        !!state.isConnected &&
        (state.type === 'wifi' || state.type === 'ethernet');
      this.updateState({ hasWifi });

      // Si tenemos WiFi pero no estamos conectados, intentar conectar
      if (hasWifi && !this.state.isConnected && !this.state.isConnecting) {
        setTimeout(() => {
          this.connect().catch(() => {});
        }, 1000);
      }
    });
  }

  async setConnectionMode(mode: ConnectionMode) {
    this.state.mode = mode;

    // Si cambiamos a manual, actualizar la URL actual inmediatamente
    if (mode === 'manual') {
      const url = await discoveryService.getApiUrl();
      if (url) {
        this.updateState({ currentUrl: url });
      }
    }

    this.notifyListeners();
  }

  getConnectionMode(): ConnectionMode {
    return this.state.mode;
  }

  async connect(): Promise<void> {
    // Si ya hay una conexi√≥n en progreso, esperarla
    if (this.connectionPromise) {
      return this.connectionPromise;
    }

    this.connectionPromise = this.performConnection();

    try {
      await this.connectionPromise;
    } finally {
      this.connectionPromise = null;
    }
  }

  private async performConnection(): Promise<void> {
    this.updateState({ isConnecting: true, lastError: null });

    try {
      let apiUrl: string | null = null;

      // Intentar conectar seg√∫n el modo
      switch (this.state.mode) {
        case 'auto':
          // Primero intentar con la √∫ltima URL conocida
          apiUrl = await discoveryService.getLastKnownUrl();
          if (apiUrl) {
            const isHealthy =
              await healthMonitoringService.checkHealthWithUrl(apiUrl);
            if (!isHealthy) {
              // Si falla, intentar descubrimiento
              apiUrl = await discoveryService.discoverServer();
            }
          } else {
            // No hay URL conocida, hacer descubrimiento
            apiUrl = await discoveryService.discoverServer();
          }
          break;

        case 'manual':
          // Usar la URL configurada manualmente
          apiUrl = await discoveryService.getApiUrl();
          if (!apiUrl) {
            throw new Error('No se ha configurado una URL manual');
          }
          break;
      }

      if (!apiUrl) {
        throw new Error('No se pudo establecer conexi√≥n con el servidor');
      }

      // No sobrescribir la URL si ya est√° configurada manualmente
      // Solo actualizar si es modo auto
      if (this.state.mode === 'auto') {
        await discoveryService.setServerUrl(apiUrl, false);
      }

      // Verificar que el servidor est√© respondiendo
      const isHealthy =
        await healthMonitoringService.checkHealthWithUrl(apiUrl);
      if (!isHealthy) {
        throw new Error('El servidor no est√° respondiendo correctamente');
      }

      // Iniciar monitoreo de salud
      healthMonitoringService.startMonitoring();

      // Reinicializar el API client con la nueva URL
      const { reinitializeApiClient } = await import(
        '@/app/services/apiClient'
      );
      await reinitializeApiClient(apiUrl);

      this.updateState({
        isConnected: true,
        isConnecting: false,
        currentUrl: apiUrl,
        isHealthy: true,
        error: null,
      });
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : 'Error desconocido';
      this.updateState({
        isConnected: false,
        isConnecting: false,
        lastError: errorMessage,
        error: errorMessage,
        isHealthy: false,
      });
      throw error;
    }
  }

  async reconnect(): Promise<void> {
    return this.connect();
  }

  retry(): void {
    // Si no est√° conectado y hay WiFi, iniciar reconexi√≥n autom√°tica
    if (!this.state.isConnected && this.state.hasWifi) {
      autoReconnectService.startAutoReconnect();
    } else if (!this.state.hasWifi) {
      // Si no hay WiFi, actualizar el estado de error
      this.updateState({
        error: 'Sin conexi√≥n WiFi',
        lastError: 'Sin conexi√≥n WiFi',
      });
    }
  }

  async disconnect(): void {
    healthMonitoringService.stopMonitoring();
    autoReconnectService.stopAutoReconnect();
    this.updateState({
      isConnected: false,
      isConnecting: false,
      currentUrl: null,
      isHealthy: false,
    });
  }

  destroy() {
    if (this.healthUnsubscribe) {
      this.healthUnsubscribe();
    }
    if (this.reconnectUnsubscribe) {
      this.reconnectUnsubscribe();
    }
    if (this.netInfoUnsubscribe) {
      this.netInfoUnsubscribe();
    }
    // Limpiar los listeners de eventos
    autoReconnectService.off('reconnected');
    healthMonitoringService.off('recovered');
  }

  subscribe(listener: (state: ConnectionState) => void): () => void {
    this.listeners.push(listener);
    // Notificar inmediatamente el estado actual
    listener(this.state);

    // Retornar funci√≥n para desuscribirse
    return () => {
      this.listeners = this.listeners.filter((l) => l !== listener);
    };
  }

  getState(): ConnectionState {
    return { ...this.state };
  }

  isConnected(): boolean {
    return this.state.isConnected;
  }

  getCurrentUrl(): string | null {
    return this.state.currentUrl;
  }

  private updateState(updates: Partial<ConnectionState>): void {
    this.state = { ...this.state, ...updates };
    this.notifyListeners();
  }

  private notifyListeners(): void {
    this.listeners.forEach((listener) => listener(this.state));
  }
}

export const serverConnectionService = new ServerConnectionService();

================
File: app/src/utils/logging.ts
================
// Utilidad para logging completo sin truncar datos
export const logComplete = (label: string, data: any) => {
  console.log(`\n========== ${label} ==========`);

  if (typeof data === 'object' && data !== null) {
    // Para objetos y arrays, usar JSON.stringify con formato bonito
    console.log(JSON.stringify(data, null, 2));
  } else {
    // Para primitivos, mostrar directamente
    console.log(data);
  }

  console.log(`========== FIN ${label} ==========\n`);
};

// Logger espec√≠fico para errores con stack trace completo
export const logError = (label: string, error: any) => {
  console.error(`\n‚ùå ERROR: ${label}`);

  if (error instanceof Error) {
    console.error('Mensaje:', error.message);
    console.error('Stack completo:');
    console.error(error.stack);
  } else {
    console.error('Error completo:', JSON.stringify(error, null, 2));
  }

  console.error(`‚ùå FIN ERROR: ${label}\n`);
};

// Logger para respuestas de API
export const logApiResponse = (endpoint: string, response: any) => {
  console.log(`\nüì° API Response: ${endpoint}`);
  console.log('Status:', response.status || 'N/A');
  console.log('Headers:', response.headers || 'N/A');
  console.log('Data completa:');
  console.log(JSON.stringify(response.data || response, null, 2));
  console.log(`üì° FIN API Response: ${endpoint}\n`);
};

// Logger para debugging con m√∫ltiples valores
export const logDebug = (label: string, ...values: any[]) => {
  console.log(`\nüîç DEBUG: ${label}`);

  values.forEach((value, index) => {
    console.log(`Valor ${index + 1}:`);
    if (typeof value === 'object' && value !== null) {
      console.log(JSON.stringify(value, null, 2));
    } else {
      console.log(value);
    }
  });

  console.log(`üîç FIN DEBUG: ${label}\n`);
};

================
File: app/plugins/withCustomIcons.js
================
/* eslint-disable @typescript-eslint/no-var-requires */
const { withDangerousMod } = require('@expo/config-plugins');
const fs = require('fs');
const path = require('path');
/* eslint-enable @typescript-eslint/no-var-requires */

// Plugin para generar iconos personalizados
function withCustomIcons(config) {
  return withDangerousMod(config, [
    'android',
    async (config) => {
      const projectRoot = config.modRequest.projectRoot;
      const iconPath = path.join(projectRoot, 'assets', 'icon.png');
      const adaptiveIconPath = path.join(
        projectRoot,
        'assets',
        'adaptive-icon.png',
      );
      const splashPath = path.join(projectRoot, 'assets', 'splash.png');

      console.log('üé® CloudBite Icon Plugin - Starting icon generation...');

      // Verificar que existen los iconos
      if (!fs.existsSync(iconPath)) {
        console.error('‚ùå Icon not found at:', iconPath);
        return config;
      }

      console.log('‚úÖ Icon found at:', iconPath);

      // Durante el prebuild, los iconos ya son procesados por Expo
      // Este plugin solo sirve para logging y verificaci√≥n
      console.log('üì± Icons will be processed during EAS build');

      // Para splash screen
      if (fs.existsSync(splashPath)) {
        console.log('‚úÖ Splash screen found at:', splashPath);
      }

      // Para icono adaptativo
      if (fs.existsSync(adaptiveIconPath)) {
        console.log('‚úÖ Adaptive icon found at:', adaptiveIconPath);
      }

      return config;
    },
  ]);
}

module.exports = withCustomIcons;

================
File: app/src/app/components/common/AnimatedLabelInput.tsx
================
import React, { useState, useRef, useEffect } from 'react';
import {
  View,
  TextInput,
  Animated,
  StyleSheet,
  TextInputProps,
  StyleProp,
  ViewStyle,
  TextStyle,
  TouchableWithoutFeedback,
  Easing,
} from 'react-native';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';

interface AnimatedLabelInputProps extends TextInputProps {
  label: string;
  containerStyle?: StyleProp<ViewStyle>;
  inputStyle?: StyleProp<TextStyle>;
  labelStyle?: StyleProp<TextStyle>;
  activeLabelColor?: string;
  inactiveLabelColor?: string;
  borderColor?: string;
  activeBorderColor?: string;
  error?: boolean;
  errorColor?: string;
  disabled?: boolean;
}

const AnimatedLabelInput = React.forwardRef<TextInput, AnimatedLabelInputProps>(
  (
    {
      label,
      value,
      onChangeText,
      onFocus,
      onBlur,
      style,
      containerStyle,
      inputStyle,
      labelStyle,
      activeLabelColor,
      inactiveLabelColor,
      borderColor: defaultBorderColor,
      activeBorderColor: focusedBorderColor,
      error = false,
      errorColor: customErrorColor,
      multiline,
      disabled = false, // A√±adir disabled a las props destructuradas
      ...rest
    },
    ref,
  ) => {
    const theme = useAppTheme();
    const responsive = useResponsive();
    const [isFocused, setIsFocused] = useState(false);
    const animation = useRef(new Animated.Value(value ? 1 : 0)).current;

    const isActive = isFocused || (value != null && value !== '');

    const finalActiveLabelColor = activeLabelColor || theme.colors.primary;
    const finalInactiveLabelColor =
      inactiveLabelColor || theme.colors.onSurfaceVariant;
    const finalBorderColor = defaultBorderColor || theme.colors.outline;
    const finalActiveBorderColor = focusedBorderColor || theme.colors.primary;
    const finalErrorColor = customErrorColor || theme.colors.error;

    useEffect(() => {
      Animated.timing(animation, {
        toValue: isActive ? 1 : 0,
        duration: 150,
        useNativeDriver: false,
        easing: Easing.bezier(0.4, 0.0, 0.2, 1), // Material Design easing
      }).start();
    }, [isActive, animation]);

    const handleFocus = (e: any) => {
      setIsFocused(true);
      onFocus?.(e);
    };

    const handleBlur = (e: any) => {
      setIsFocused(false);
      onBlur?.(e);
    };

    // Usar ref externa o crear una nueva
    const inputRef = useRef<TextInput>(null);
    const finalRef = ref || inputRef;

    const labelScale = animation.interpolate({
      inputRange: [0, 1],
      outputRange: [1, 0.8], // Escala m√°s sutil
    });

    const labelColor = animation.interpolate({
      inputRange: [0, 1],
      outputRange: [finalInactiveLabelColor, finalActiveLabelColor],
    });

    const currentBorderColor = error
      ? finalErrorColor
      : isFocused
        ? finalActiveBorderColor
        : finalBorderColor;

    const styles = React.useMemo(
      () =>
        createStyles(theme, responsive, {
          multiline,
          disabled,
          finalInactiveLabelColor,
        }),
      [theme, responsive, multiline, disabled, finalInactiveLabelColor],
    );

    const animatedTranslateY = animation.interpolate({
      inputRange: [0, 1],
      outputRange: [0, -28],
    });

    const animatedTranslateX = animation.interpolate({
      inputRange: [0, 1],
      outputRange: [0, -4],
    });

    const animatedLabelStyle = {
      position: 'absolute' as const,
      top: 20,
      left: 12,
      zIndex: 10, // Aumentar z-index para mejor visibilidad
      transform: [
        { translateX: animatedTranslateX },
        { translateY: animatedTranslateY },
        { scale: labelScale },
      ],
      color: labelColor,
      backgroundColor: theme.colors.background,
      maxWidth: isActive ? ('85%' as `${number}%`) : ('90%' as `${number}%`),
    };

    // Estilos est√°ticos que no deben ser animados
    const staticLabelStyle = {
      paddingHorizontal: isActive ? 4 : 0,
      paddingVertical: isActive ? 1 : 0,
    };

    const handleContainerPress = () => {
      if (
        !disabled &&
        finalRef &&
        typeof finalRef !== 'function' &&
        finalRef.current
      ) {
        finalRef.current.focus();
      }
    };

    return (
      <TouchableWithoutFeedback
        onPress={handleContainerPress}
        disabled={disabled}
      >
        <View
          style={[
            styles.container,
            { borderColor: currentBorderColor },
            containerStyle,
          ]}
        >
          {/* L√≠nea de fondo para crear efecto de muesca en el borde */}
          <Animated.View
            style={{
              position: 'absolute',
              top: -1, // Sobre el borde superior
              left: 10,
              height: 2, // Mismo grosor que el borde
              backgroundColor: theme.colors.background,
              zIndex: 5,
              opacity: animation.interpolate({
                inputRange: [0, 0.5, 1],
                outputRange: [0, 0.8, 1],
              }),
              transform: [
                {
                  scaleX: animation.interpolate({
                    inputRange: [0, 1],
                    outputRange: [0, 1],
                  }),
                },
              ],
              width: Math.min(label.length * 6.5 + 16, 200), // Ancho fijo basado en el texto con l√≠mite m√°ximo
            }}
          />
          <Animated.Text
            style={[
              styles.label,
              staticLabelStyle,
              labelStyle,
              animatedLabelStyle,
            ]}
            numberOfLines={1}
            ellipsizeMode="tail"
          >
            {label}
          </Animated.Text>
          <View style={[styles.inputContainer, { pointerEvents: 'box-none' }]}>
            <TextInput
              ref={finalRef}
              value={value}
              onChangeText={onChangeText}
              onFocus={handleFocus}
              onBlur={handleBlur}
              style={[styles.input, inputStyle, style]}
              placeholder=""
              editable={!disabled}
              pointerEvents={disabled ? 'none' : 'auto'}
              underlineColorAndroid="transparent"
              placeholderTextColor={finalInactiveLabelColor}
              multiline={multiline}
              autoCorrect={false}
              keyboardAppearance={theme.dark ? 'dark' : 'light'}
              {...rest}
            />
          </View>
        </View>
      </TouchableWithoutFeedback>
    );
  },
);

AnimatedLabelInput.displayName = 'AnimatedLabelInput';

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
  props: {
    multiline?: boolean;
    disabled: boolean;
    finalInactiveLabelColor: string;
  },
) =>
  StyleSheet.create({
    container: {
      borderWidth: 1,
      borderRadius: theme.roundness,
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      position: 'relative',
      backgroundColor: theme.colors.background,
      minHeight: responsive.isTablet ? 52 : 58,
    },
    inputContainer: {
      flexDirection: 'row',
      alignItems: props.multiline ? 'flex-start' : 'center',
      paddingTop: responsive.isTablet ? 16 : 18,
      paddingBottom: responsive.isTablet ? 4 : 6,
      minHeight: responsive.isTablet ? 36 : 40,
    },
    label: {
      fontSize: responsive.fontSize(16),
      color: props.finalInactiveLabelColor,
    },
    input: {
      flex: 1,
      fontSize: responsive.fontSize(16),
      color: props.disabled
        ? theme.colors.onSurfaceDisabled
        : theme.colors.onSurface,
      paddingVertical: 0,
      paddingHorizontal: 0,
      margin: 0,
      borderWidth: 0,
      backgroundColor: 'transparent',
      textAlignVertical: props.multiline ? 'top' : 'center',
    },
  });

export default AnimatedLabelInput;

================
File: app/src/app/components/common/ConfirmationModal.tsx
================
import React from 'react';
import { ResponsiveConfirmModal } from '../responsive/ResponsiveModal';

interface ConfirmationModalProps {
  visible: boolean;
  title: string;
  message: string;
  onConfirm: () => void;
  onCancel?: () => void;
  onDismiss?: () => void;
  confirmText?: string;
  cancelText?: string;
  confirmButtonColor?: string;
}

const ConfirmationModal: React.FC<ConfirmationModalProps> = ({
  visible,
  title,
  message,
  onConfirm,
  onCancel,
  onDismiss,
  confirmText = 'Confirmar',
  cancelText = 'Cancelar',
  confirmButtonColor,
}) => {
  // Determinar si es destructivo basado en el color del bot√≥n
  const destructive =
    confirmButtonColor &&
    (confirmButtonColor.includes('error') ||
      confirmButtonColor === '#f44336' ||
      confirmButtonColor === '#F44336' ||
      confirmButtonColor === 'error');

  return (
    <ResponsiveConfirmModal
      visible={visible}
      onDismiss={onDismiss || (() => {})}
      title={title}
      message={message}
      onConfirm={onConfirm}
      onCancel={onCancel}
      confirmText={confirmText}
      cancelText={cancelText}
      destructive={destructive}
      maxWidth={450}
      widthTablet="70%"
      widthMobile="90%"
    />
  );
};

export default ConfirmationModal;

================
File: app/src/app/components/common/GlobalSnackbar.tsx
================
import React from 'react';
import { Snackbar, Portal, Text } from 'react-native-paper';
import { StyleSheet } from 'react-native';
import {
  useSnackbarStore,
  SnackbarType,
} from '../../../app/store/snackbarStore';
import { useAppTheme } from '../../../app/styles/theme';

const GlobalSnackbar: React.FC = () => {
  const { visible, message, type, duration, hideSnackbar } = useSnackbarStore();
  const theme = useAppTheme();

  React.useEffect(() => {
    if (visible && message) {
      const timer = setTimeout(() => {
        hideSnackbar();
      }, duration || 2500);

      return () => clearTimeout(timer);
    }
  }, [visible, message, duration, hideSnackbar]);

  const getBackgroundColor = (snackbarType: SnackbarType) => {
    switch (snackbarType) {
      case 'success':
        return theme.colors.successContainer;
      case 'error':
        return theme.colors.errorContainer;
      case 'warning':
        return theme.colors.warningContainer || theme.colors.tertiaryContainer;
      case 'info':
        return theme.colors.infoContainer || theme.colors.surfaceVariant;
      default:
        return theme.colors.inverseSurface;
    }
  };

  const getTextColor = (snackbarType: SnackbarType) => {
    const defaultTextColor = theme.dark
      ? theme.colors.surface
      : theme.colors.onSurface;

    switch (snackbarType) {
      case 'success':
        return theme.colors.onSuccessContainer || defaultTextColor;
      case 'error':
        return theme.colors.onErrorContainer;
      case 'warning':
        return (
          theme.colors.onWarningContainer || theme.colors.onTertiaryContainer
        );
      case 'info':
        return theme.colors.onInfoContainer || theme.colors.onSurfaceVariant;
      default:
        return theme.colors.inverseOnSurface;
    }
  };

  const backgroundColor = getBackgroundColor(type);
  const textColor = getTextColor(type);

  return (
    <Portal>
      <Snackbar
        visible={visible}
        onDismiss={hideSnackbar}
        duration={duration || 2500}
        style={[
          styles.snackbar,
          {
            backgroundColor,
            marginBottom: 40,
          },
        ]}
        theme={{
          ...theme,
          colors: {
            ...theme.colors,
            inversePrimary: textColor,
            inverseOnSurface: textColor,
          },
        }}
      >
        <Text style={styles.messageText}>{message || ''}</Text>
      </Snackbar>
    </Portal>
  );
};

const styles = StyleSheet.create({
  snackbar: {
    marginHorizontal: 16,
    borderRadius: 8,
    elevation: 6,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 3,
    },
    shadowOpacity: 0.27,
    shadowRadius: 4.65,
  },
  messageText: {
    textAlign: 'center',
    width: '100%',
  },
});

export default GlobalSnackbar;

================
File: app/src/app/hooks/useGlobalShift.ts
================
import { useQuery } from '@tanstack/react-query';
import { shiftsService, type Shift } from '@/services/shifts';

export const useGlobalShift = () => {
  return useQuery<Shift | null, Error>({
    queryKey: ['global', 'shift', 'current'],
    queryFn: () => shiftsService.getCurrentShift(),
    staleTime: 60 * 1000, // Los datos se consideran obsoletos despu√©s de 60 segundos
    cacheTime: 5 * 60 * 1000, // Mantener en cach√© por 5 minutos
    refetchInterval: 2 * 60 * 1000, // Actualizar cada 2 minutos autom√°ticamente
    refetchOnWindowFocus: false, // No actualizar autom√°ticamente al volver al foco
    refetchOnMount: 'always', // Actualizar siempre al montar el componente
    refetchOnReconnect: true, // Actualizar cuando se reconecta
    retry: 1, // Solo reintentar una vez en caso de error
    retryDelay: 1000, // Esperar 1 segundo antes de reintentar
  });
};

================
File: app/src/app/hooks/useRefreshOnFocus.ts
================
import { useEffect, useCallback } from 'react';
import { useFocusEffect } from '@react-navigation/native';
import { useQueryClient } from '@tanstack/react-query';

/**
 * Hook que refresca las queries especificadas cuando la pantalla recibe el foco
 * @param queryKeys - Array de query keys a invalidar cuando la pantalla reciba foco
 * @param options - Opciones adicionales
 */
export function useRefreshOnFocus(
  queryKeys: (string | readonly unknown[])[],
  options?: {
    enabled?: boolean;
    refetchOnMount?: boolean;
  },
) {
  const queryClient = useQueryClient();
  const { enabled = true, refetchOnMount = true } = options || {};

  // Invalidar queries cuando la pantalla recibe foco
  useFocusEffect(
    useCallback(() => {
      if (!enabled) return;

      // Invalidar todas las queries especificadas
      queryKeys.forEach((queryKey) => {
        queryClient.invalidateQueries({
          queryKey: Array.isArray(queryKey) ? queryKey : [queryKey],
        });
      });
    }, [enabled, queryKeys, queryClient]),
  );

  // Tambi√©n invalidar al montar si est√° habilitado
  useEffect(() => {
    if (!enabled || !refetchOnMount) return;

    queryKeys.forEach((queryKey) => {
      queryClient.invalidateQueries({
        queryKey: Array.isArray(queryKey) ? queryKey : [queryKey],
      });
    });
  }, [enabled, refetchOnMount, queryKeys, queryClient]);

  return {
    refetch: () => {
      queryKeys.forEach((queryKey) => {
        queryClient.invalidateQueries({
          queryKey: Array.isArray(queryKey) ? queryKey : [queryKey],
        });
      });
    },
  };
}

/**
 * Hook que refresca todas las queries de un m√≥dulo cuando la pantalla recibe foco
 * @param modulePrefix - Prefijo del m√≥dulo (ej: 'products', 'orders', etc)
 */
export function useRefreshModuleOnFocus(
  modulePrefix: string,
  options?: {
    enabled?: boolean;
  },
) {
  const queryClient = useQueryClient();
  const { enabled = true } = options || {};

  useFocusEffect(
    useCallback(() => {
      if (!enabled) return;

      // Invalidar todas las queries que empiecen con el prefijo del m√≥dulo
      queryClient.invalidateQueries({
        predicate: (query) => {
          const queryKey = query.queryKey;
          if (Array.isArray(queryKey) && queryKey.length > 0) {
            return queryKey[0] === modulePrefix;
          }
          return false;
        },
      });
    }, [enabled, modulePrefix, queryClient]),
  );
}

================
File: app/src/app/hooks/useResponsive.ts
================
import { useState, useEffect, useCallback, useMemo } from 'react';
import { Dimensions, PixelRatio, ScaledSize, Platform } from 'react-native';
import {
  BREAKPOINTS,
  DEVICE_TYPES,
  getDeviceType,
  isTablet as checkIsTablet,
  scaleWidth,
  scaleHeight,
  scaleWithLimits,
  getResponsiveDimension,
  RESPONSIVE_SPACING,
  RESPONSIVE_FONT_SIZES,
  RESPONSIVE_DIMENSIONS,
  applyResponsiveStyle,
  getGridColumns,
  getOrientation as getOrientationUtil,
  maintainAspectRatio,
  normalizeDPI,
} from '@/app/styles/responsive';

interface ResponsiveInfo {
  // Dimensiones de pantalla
  width: number;
  height: number;

  // Informaci√≥n del dispositivo
  deviceType: string;
  isTablet: boolean;
  isMobile: boolean;
  isSmallMobile: boolean;
  isWeb: boolean;
  isDesktop: boolean;

  // Orientaci√≥n
  orientation: 'portrait' | 'landscape';
  isPortrait: boolean;
  isLandscape: boolean;

  // Densidad de p√≠xeles
  pixelRatio: number;
  fontScale: number;

  // Funciones de escalado
  scaleWidth: (size: number) => number;
  scaleHeight: (size: number) => number;
  scaleWithLimits: (
    size: number,
    minScale?: number,
    maxScale?: number,
  ) => number;
  getResponsiveDimension: (mobile: number, tablet: number) => number;

  // Spacing responsive
  spacing: (value: number) => number;
  spacingPreset: {
    xxxs: number;
    xxs: number;
    xs: number;
    s: number;
    m: number;
    l: number;
    xl: number;
    xxl: number;
  };

  // Tama√±os de fuente responsive
  fontSize: (value: number) => number;
  fontSizePreset: {
    xs: number;
    s: number;
    m: number;
    l: number;
    xl: number;
    xxl: number;
    xxxl: number;
  };

  // Dimensiones comunes
  dimensions: {
    drawerWidth: number;
    modalWidth: number;
    headerHeight: number;
    buttonHeight: number;
    iconSize: {
      small: number;
      medium: number;
      large: number;
    };
    productImageSize: number;
    cardMinWidth: number;
  };

  // Utilidades
  applyResponsiveStyle: <T>(styles: {
    xs?: T;
    sm?: T;
    md?: T;
    lg?: T;
    xl?: T;
    xxl?: T;
  }) => T | undefined;
  getGridColumns: (
    minItemWidth?: number,
    gap?: number,
    padding?: number,
  ) => number;
  maintainAspectRatio: (
    originalWidth: number,
    originalHeight: number,
    maxWidth: number,
    maxHeight: number,
  ) => { width: number; height: number };
  normalizeDPI: (size: number) => number;

  // Breakpoints
  breakpoints: typeof BREAKPOINTS;

  // Helpers de comparaci√≥n
  isBreakpoint: {
    xs: boolean;
    sm: boolean;
    md: boolean;
    lg: boolean;
    xl: boolean;
    xxl: boolean;
  };
}

export const useResponsive = (): ResponsiveInfo => {
  // Estado para las dimensiones
  const [dimensions, setDimensions] = useState<ScaledSize>(() =>
    Dimensions.get('window'),
  );

  // Actualizar dimensiones cuando cambian
  useEffect(() => {
    const subscription = Dimensions.addEventListener('change', ({ window }) => {
      setDimensions(window);
    });

    return () => subscription?.remove();
  }, []);

  // Obtener informaci√≥n de p√≠xeles
  const pixelRatio = PixelRatio.get();
  const fontScale = PixelRatio.getFontScale();

  // Calcular valores derivados
  const deviceType = useMemo(
    () => getDeviceType(dimensions.width),
    [dimensions.width],
  );
  const isWeb = Platform.OS === 'web';
  const isDesktop = useMemo(
    () => isWeb && dimensions.width >= BREAKPOINTS.lg,
    [isWeb, dimensions.width],
  );
  const isTablet = useMemo(
    () =>
      checkIsTablet(dimensions.width) ||
      (isWeb &&
        dimensions.width >= BREAKPOINTS.md &&
        dimensions.width < BREAKPOINTS.lg),
    [dimensions.width, isWeb],
  );
  const isMobile = useMemo(
    () => !isTablet && !isDesktop,
    [isTablet, isDesktop],
  );
  const isSmallMobile = useMemo(
    () => deviceType === DEVICE_TYPES.MOBILE_SMALL,
    [deviceType],
  );

  const orientation = useMemo(
    () => getOrientationUtil(dimensions.width, dimensions.height),
    [dimensions.width, dimensions.height],
  );
  const isPortrait = orientation === 'portrait';
  const isLandscape = orientation === 'landscape';

  // Funciones de escalado memoizadas
  const scaleWidthMemo = useCallback(
    (size: number) => scaleWidth(size, dimensions.width),
    [dimensions.width],
  );

  const scaleHeightMemo = useCallback(
    (size: number) => scaleHeight(size, dimensions.height),
    [dimensions.height],
  );

  const scaleWithLimitsMemo = useCallback(
    (size: number, minScale?: number, maxScale?: number) =>
      scaleWithLimits(size, minScale, maxScale, dimensions.width),
    [dimensions.width],
  );

  const getResponsiveDimensionMemo = useCallback(
    (mobile: number, tablet: number) =>
      getResponsiveDimension(mobile, tablet, dimensions.width),
    [dimensions.width],
  );

  // Spacing responsive
  const spacingPreset = useMemo(
    () => ({
      xxxs: RESPONSIVE_SPACING.xxxs(dimensions.width),
      xxs: RESPONSIVE_SPACING.xxs(dimensions.width),
      xs: RESPONSIVE_SPACING.xs(dimensions.width),
      s: RESPONSIVE_SPACING.s(dimensions.width),
      m: RESPONSIVE_SPACING.m(dimensions.width),
      l: RESPONSIVE_SPACING.l(dimensions.width),
      xl: RESPONSIVE_SPACING.xl(dimensions.width),
      xxl: RESPONSIVE_SPACING.xxl(dimensions.width),
    }),
    [dimensions.width],
  );

  // Funci√≥n de spacing que escala valores arbitrarios
  const spacing = useCallback(
    (value: number) => {
      // Para web desktop, aumentar el spacing
      if (isDesktop) {
        return Math.round(value * 1.3); // 30% m√°s
      }
      // Para tablets, reducir el spacing en un 25-35%
      if (isTablet) {
        return Math.round(value * 0.7); // 30% menos
      }
      return value;
    },
    [isTablet, isDesktop],
  );

  // Tama√±os de fuente responsive
  const fontSizePreset = useMemo(
    () => ({
      xs: RESPONSIVE_FONT_SIZES.xs(dimensions.width),
      s: RESPONSIVE_FONT_SIZES.s(dimensions.width),
      m: RESPONSIVE_FONT_SIZES.m(dimensions.width),
      l: RESPONSIVE_FONT_SIZES.l(dimensions.width),
      xl: RESPONSIVE_FONT_SIZES.xl(dimensions.width),
      xxl: RESPONSIVE_FONT_SIZES.xxl(dimensions.width),
      xxxl: RESPONSIVE_FONT_SIZES.xxxl(dimensions.width),
    }),
    [dimensions.width],
  );

  // Funci√≥n de fontSize que escala valores arbitrarios
  const fontSize = useCallback(
    (value: number) => {
      // Para web desktop, aumentar las fuentes significativamente
      if (isDesktop) {
        return Math.round(value * 1.4); // 40% m√°s grande
      }
      // Para web tablet, aumentar un poco
      if (isWeb && isTablet) {
        return Math.round(value * 1.2); // 20% m√°s grande
      }
      // Para tablets nativos, reducir las fuentes en un 10-15%
      if (isTablet) {
        return Math.round(value * 0.87); // 13% menos
      }
      return value;
    },
    [isTablet, isDesktop, isWeb],
  );

  // Dimensiones comunes
  const commonDimensions = useMemo(
    () => ({
      drawerWidth: RESPONSIVE_DIMENSIONS.drawerWidth(dimensions.width),
      modalWidth: RESPONSIVE_DIMENSIONS.modalWidth(dimensions.width),
      headerHeight: RESPONSIVE_DIMENSIONS.headerHeight(dimensions.width),
      buttonHeight: RESPONSIVE_DIMENSIONS.buttonHeight(dimensions.width),
      iconSize: {
        small: RESPONSIVE_DIMENSIONS.iconSize.small(dimensions.width),
        medium: RESPONSIVE_DIMENSIONS.iconSize.medium(dimensions.width),
        large: RESPONSIVE_DIMENSIONS.iconSize.large(dimensions.width),
      },
      productImageSize: RESPONSIVE_DIMENSIONS.productImageSize(
        dimensions.width,
      ),
      cardMinWidth: RESPONSIVE_DIMENSIONS.cardMinWidth(dimensions.width),
    }),
    [dimensions.width],
  );

  // Aplicar estilos responsive
  const applyResponsiveStyleMemo = useCallback(
    <T>(styles: { xs?: T; sm?: T; md?: T; lg?: T; xl?: T; xxl?: T }) =>
      applyResponsiveStyle(dimensions.width, styles),
    [dimensions.width],
  );

  // Obtener columnas de grid
  const getGridColumnsMemo = useCallback(
    (minItemWidth?: number, gap?: number, padding?: number) =>
      getGridColumns(dimensions.width, minItemWidth, gap, padding),
    [dimensions.width],
  );

  // Helpers de breakpoint
  const isBreakpoint = useMemo(
    () => ({
      xs:
        dimensions.width >= BREAKPOINTS.xs && dimensions.width < BREAKPOINTS.sm,
      sm:
        dimensions.width >= BREAKPOINTS.sm && dimensions.width < BREAKPOINTS.md,
      md:
        dimensions.width >= BREAKPOINTS.md && dimensions.width < BREAKPOINTS.lg,
      lg:
        dimensions.width >= BREAKPOINTS.lg && dimensions.width < BREAKPOINTS.xl,
      xl:
        dimensions.width >= BREAKPOINTS.xl &&
        dimensions.width < BREAKPOINTS.xxl,
      xxl: dimensions.width >= BREAKPOINTS.xxl,
    }),
    [dimensions.width],
  );

  return {
    // Dimensiones
    width: dimensions.width,
    height: dimensions.height,

    // Informaci√≥n del dispositivo
    deviceType,
    isTablet,
    isMobile,
    isSmallMobile,
    isWeb,
    isDesktop,

    // Orientaci√≥n
    orientation,
    isPortrait,
    isLandscape,

    // Densidad de p√≠xeles
    pixelRatio,
    fontScale,

    // Funciones de escalado
    scaleWidth: scaleWidthMemo,
    scaleHeight: scaleHeightMemo,
    scaleWithLimits: scaleWithLimitsMemo,
    getResponsiveDimension: getResponsiveDimensionMemo,

    // Spacing y dimensiones
    spacing,
    spacingPreset,
    fontSize,
    fontSizePreset,
    dimensions: commonDimensions,

    // Utilidades
    applyResponsiveStyle: applyResponsiveStyleMemo,
    getGridColumns: getGridColumnsMemo,
    maintainAspectRatio,
    normalizeDPI,

    // Breakpoints
    breakpoints: BREAKPOINTS,
    isBreakpoint,
  };
};

// Hook adicional para estilos responsive con el tema
import { useAppTheme } from '@/app/styles/theme';

export const useResponsiveStyles = <T extends Record<string, any>>(
  styleFactory: (theme: any, responsive: ResponsiveInfo) => T,
): T => {
  const theme = useAppTheme();
  const responsive = useResponsive();

  return useMemo(
    () => styleFactory(theme, responsive),
    [theme, responsive, styleFactory],
  );
};

================
File: app/src/app/hooks/useServerConnection.ts
================
import { useState, useEffect, useCallback } from 'react';
import { serverConnectionService } from '@/services/serverConnectionService';


export interface ServerConnectionState {
  isSearching: boolean;
  isConnected: boolean;
  error: string | null;
  serverUrl: string | null;
  hasWifi: boolean;
  isHealthy: boolean;
  retry: () => void;
}

export function useServerConnection(): ServerConnectionState {
  const [state, setState] = useState(() => {
    const serviceState = serverConnectionService.getState();
    return {
      isSearching: serviceState.isSearching,
      isConnected: serviceState.isConnected,
      error: serviceState.error,
      serverUrl: serviceState.currentUrl,
      hasWifi: serviceState.hasWifi,
      isHealthy: serviceState.isHealthy,
      retry: () => {},
    };
  });

  useEffect(() => {
    const serviceState = serverConnectionService.getState();
    setState({
      isSearching: serviceState.isSearching,
      isConnected: serviceState.isConnected,
      error: serviceState.error,
      serverUrl: serviceState.currentUrl,
      hasWifi: serviceState.hasWifi,
      isHealthy: serviceState.isHealthy,
      retry: () => serverConnectionService.retry(),
    });

    const unsubscribe = serverConnectionService.subscribe((newState) => {
      setState({
        isSearching: newState.isSearching,
        isConnected: newState.isConnected,
        error: newState.error,
        serverUrl: newState.currentUrl,
        hasWifi: newState.hasWifi,
        isHealthy: newState.isHealthy,
        retry: () => serverConnectionService.retry(),
      });
    });

    return () => {
      unsubscribe();
    };
  }, []);

  const retry = useCallback(() => {
    serverConnectionService.retry();
  }, []);

  return state;
}

================
File: app/src/app/navigation/types.ts
================
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import type { DrawerScreenProps as NavigationDrawerScreenProps } from '@react-navigation/drawer';
import type { NavigatorScreenParams } from '@react-navigation/native';
import type { MenuStackParamList } from '../../modules/menu/navigation/types';
import type { PreparationScreensStackParamList } from '../../modules/preparationScreens/navigation/types';
import type { AreasTablesStackParamList } from '../../modules/areasTables/navigation/types';
import type { PrintersStackParamList } from '../../modules/printers/navigation/types'; // Importar tipos de impresoras
import type { ReceiptsStackParamList } from '../../modules/receipts/navigation/types'; // Importar tipos de recibos
import type { AvailabilityStackParamList } from '../../modules/availability/navigation/types';
import type { OrderFinalizationStackParamList } from '../../modules/orderFinalization/navigation/types';
import type { RestaurantConfigStackParamList } from '../../modules/restaurantConfig/navigation/types';
import type { CustomersStackParamList } from '../../modules/customers/navigation/CustomersStackNavigator';
import type { PizzaCustomizationsStackParamList } from '../../modules/pizzaCustomizations/navigation/types';
import type { SyncStackParamList } from '../../modules/sync/navigation/SyncStackNavigator';
import type { UsersStackParamList } from '../../modules/users/navigation/UsersStackNavigator';
import type { KitchenStackParamList } from '../../modules/kitchen/navigation/KitchenNavigator';
import type { ShiftAuditStackParamList } from '../../modules/shiftAudit/navigation/types';
import type { SettingsStackParamList } from '../../modules/settings/navigation/types';

export type AuthStackParamList = {
  Login: undefined;
};

export type OrdersStackParamList = {
  Orders: undefined; // Pantalla principal del m√≥dulo de √≥rdenes
  CreateOrder: undefined; // Pantalla para crear una nueva orden
  OpenOrders: undefined; // Pantalla para ver √≥rdenes abiertas
  AddProductsToOrder: {
    orderId: string; // ID de la orden a la que se est√°n agregando productos
    orderNumber: number; // N√∫mero de la orden
    existingOrderItemsCount?: number; // N√∫mero de items que ya est√°n en la orden
    existingTempProducts?: import('../../modules/orders/stores/useCartStore').CartItem[]; // Productos temporales existentes
    onProductsAdded?: (
      products: import('../../modules/orders/stores/useCartStore').CartItem[],
    ) => void; // Callback cuando se a√±aden productos
  }; // Pantalla para a√±adir productos a una orden existente
};

export type OrdersStackScreenProps<T extends keyof OrdersStackParamList> =
  NativeStackScreenProps<OrdersStackParamList, T>;

export type AuthStackScreenProps<T extends keyof AuthStackParamList> =
  NativeStackScreenProps<AuthStackParamList, T>;

export type ModifiersStackParamList = {
  ModifierGroupsScreen: undefined;
  ModifiersScreen: { groupId: string; groupName: string };
};

export type ModifiersStackScreenProps<T extends keyof ModifiersStackParamList> =
  NativeStackScreenProps<ModifiersStackParamList, T>;

export type AppDrawerParamList = {
  Welcome: undefined; // Mantener si existe una pantalla de bienvenida
  MenuStack: NavigatorScreenParams<MenuStackParamList>; // Renombrado
  ModifiersStack: NavigatorScreenParams<ModifiersStackParamList>; // Renombrado
  PreparationScreensStack: NavigatorScreenParams<PreparationScreensStackParamList>; // Renombrado para consistencia
  AreasTablesStack: NavigatorScreenParams<AreasTablesStackParamList>; // A√±adir el nuevo stack al Drawer
  OrdersStack: NavigatorScreenParams<OrdersStackParamList>; // A√±adir el stack de √≥rdenes al Drawer
  PrintersStack: NavigatorScreenParams<PrintersStackParamList>; // A√±adir el stack de impresoras DENTRO del bloque
  ReceiptsStack: NavigatorScreenParams<ReceiptsStackParamList>; // A√±adir el stack de recibos
  AvailabilityStack: NavigatorScreenParams<AvailabilityStackParamList>; // Stack de disponibilidad
  OrderFinalizationStack: NavigatorScreenParams<OrderFinalizationStackParamList>; // Stack de finalizaci√≥n de √≥rdenes
  RestaurantConfigStack: NavigatorScreenParams<RestaurantConfigStackParamList>; // Stack de configuraci√≥n del restaurante
  PizzaCustomizationsStack: NavigatorScreenParams<PizzaCustomizationsStackParamList>; // Stack de personalizaci√≥n de pizzas
  CustomersStack: NavigatorScreenParams<CustomersStackParamList>; // Stack de clientes
  SyncStack: NavigatorScreenParams<SyncStackParamList>; // Stack de sincronizaci√≥n
  UsersStack: NavigatorScreenParams<UsersStackParamList>; // Stack de usuarios
  KitchenStack: NavigatorScreenParams<KitchenStackParamList>; // Stack de cocina
  ShiftAuditStack: NavigatorScreenParams<ShiftAuditStackParamList>; // Stack de auditor√≠a de turnos
  SettingsStack: NavigatorScreenParams<SettingsStackParamList>; // Stack de configuraci√≥n
  ServerSettings: undefined; // Pantalla directa de configuraci√≥n del servidor
};

export type DrawerScreenProps<T extends keyof AppDrawerParamList> =
  NavigationDrawerScreenProps<AppDrawerParamList, T>;

export type DrawerNavigatorParamList = AppDrawerParamList;

declare global {
  namespace ReactNavigation {
    interface RootParamList
      extends AuthStackParamList,
        AppDrawerParamList,
        KitchenStackParamList,
        ModifiersStackParamList,
        PreparationScreensStackParamList,
        AreasTablesStackParamList,
        OrdersStackParamList,
        PrintersStackParamList,
        ReceiptsStackParamList,
        AvailabilityStackParamList,
        OrderFinalizationStackParamList,
        RestaurantConfigStackParamList,
        PizzaCustomizationsStackParamList,
        CustomersStackParamList,
        SyncStackParamList,
        UsersStackParamList,
        ShiftAuditStackParamList,
        SettingsStackParamList {}
  }
}

================
File: app/src/app/services/secureStorageService.ts
================
import * as SecureStore from 'expo-secure-store';
import { Platform } from 'react-native';

/**
 * Servicio de almacenamiento seguro usando expo-secure-store
 * Reemplaza a react-native-encrypted-storage
 */
class SecureStorageService {
  private isAvailable(): boolean {
    // SecureStore no est√° disponible en web
    return Platform.OS !== 'web';
  }

  async setItem(key: string, value: string): Promise<void> {
    if (!this.isAvailable()) {
      // Fallback para web: usar localStorage (no seguro)
      if (typeof window !== 'undefined' && window.localStorage) {
        window.localStorage.setItem(key, value);
      }
      return;
    }

    try {
      await SecureStore.setItemAsync(key, value);
    } catch (error) {
      console.error('Error storing secure item:', error);
      throw error;
    }
  }

  async getItem(key: string): Promise<string | null> {
    if (!this.isAvailable()) {
      // Fallback para web
      if (typeof window !== 'undefined' && window.localStorage) {
        return window.localStorage.getItem(key);
      }
      return null;
    }

    try {
      return await SecureStore.getItemAsync(key);
    } catch (error) {
      console.error('Error retrieving secure item:', error);
      return null;
    }
  }

  async removeItem(key: string): Promise<void> {
    if (!this.isAvailable()) {
      // Fallback para web
      if (typeof window !== 'undefined' && window.localStorage) {
        window.localStorage.removeItem(key);
      }
      return;
    }

    try {
      await SecureStore.deleteItemAsync(key);
    } catch (error) {
      console.error('Error removing secure item:', error);
      throw error;
    }
  }

  async clear(): Promise<void> {
    // expo-secure-store no tiene un m√©todo clear()
    // Necesitamos eliminar las claves conocidas manualmente
    const keysToRemove = [
      'auth_token',
      'refresh_token',
      'user_info',
      'last_known_api_url',
      'kitchen_filters_preferences',
      'app_theme_preference',
      'user_credentials',
      'remember_me_preference',
      'connection_mode',
      'manual_server_url',
    ];

    for (const key of keysToRemove) {
      try {
        await this.removeItem(key);
      } catch (error) {
        console.error(`Error removing key ${key}:`, error);
      }
    }
  }
}

// Exportar una instancia √∫nica para mantener compatibilidad con EncryptedStorage
const secureStorage = new SecureStorageService();

// Exportar con el mismo nombre que EncryptedStorage para facilitar la migraci√≥n
export default {
  setItem: (key: string, value: string) => secureStorage.setItem(key, value),
  getItem: (key: string) => secureStorage.getItem(key),
  removeItem: (key: string) => secureStorage.removeItem(key),
  clear: () => secureStorage.clear(),
};

// Tambi√©n exportar la clase por si se necesita
export { SecureStorageService };

================
File: app/src/app/styles/responsive.ts
================
import { Dimensions, PixelRatio } from 'react-native';

// Obtener dimensiones iniciales
const { width: screenWidth, height: screenHeight } = Dimensions.get('window');

// Breakpoints est√°ndar
export const BREAKPOINTS = {
  xs: 0, // Extra peque√±o (m√≥viles peque√±os)
  sm: 360, // Peque√±o (m√≥viles est√°ndar)
  md: 600, // Mediano (m√≥viles grandes y tablets peque√±as)
  lg: 900, // Grande (tablets)
  xl: 1200, // Extra grande (tablets grandes)
  xxl: 1536, // Doble extra grande (tablets pro)
} as const;

// Tipos de dispositivos
export const DEVICE_TYPES = {
  MOBILE_SMALL: 'mobile_small',
  MOBILE: 'mobile',
  TABLET_SMALL: 'tablet_small',
  TABLET: 'tablet',
  TABLET_LARGE: 'tablet_large',
} as const;

// Densidades de p√≠xeles est√°ndar
export const PIXEL_DENSITIES = {
  MDPI: 1, // ~160 DPI
  HDPI: 1.5, // ~240 DPI
  XHDPI: 2, // ~320 DPI
  XXHDPI: 3, // ~480 DPI
  XXXHDPI: 4, // ~640 DPI
} as const;

// Dimensiones de referencia para escalado
export const REFERENCE_DIMENSIONS = {
  width: 360, // Ancho de referencia (m√≥vil est√°ndar)
  height: 640, // Altura de referencia
} as const;

// Funci√≥n para obtener el tipo de dispositivo
export const getDeviceType = (width: number = screenWidth): string => {
  if (width < BREAKPOINTS.sm) return DEVICE_TYPES.MOBILE_SMALL;
  if (width < BREAKPOINTS.md) return DEVICE_TYPES.MOBILE;
  if (width < BREAKPOINTS.lg) return DEVICE_TYPES.TABLET_SMALL;
  if (width < BREAKPOINTS.xl) return DEVICE_TYPES.TABLET;
  return DEVICE_TYPES.TABLET_LARGE;
};

// Funci√≥n para verificar si es tablet
export const isTablet = (width: number = screenWidth): boolean => {
  return width >= BREAKPOINTS.md;
};

// Funci√≥n para obtener el factor de escala basado en el ancho
export const getWidthScale = (width: number = screenWidth): number => {
  return width / REFERENCE_DIMENSIONS.width;
};

// Funci√≥n para obtener el factor de escala basado en la altura
export const getHeightScale = (height: number = screenHeight): number => {
  return height / REFERENCE_DIMENSIONS.height;
};

// Funci√≥n para escalar un valor seg√∫n el ancho de pantalla
export const scaleWidth = (
  size: number,
  width: number = screenWidth,
): number => {
  const scale = getWidthScale(width);
  return Math.round(size * scale);
};

// Funci√≥n para escalar un valor seg√∫n la altura de pantalla
export const scaleHeight = (
  size: number,
  height: number = screenHeight,
): number => {
  const scale = getHeightScale(height);
  return Math.round(size * scale);
};

// Funci√≥n para escalar con l√≠mites
export const scaleWithLimits = (
  size: number,
  minScale: number = 0.8,
  maxScale: number = 1.5,
  width: number = screenWidth,
): number => {
  const scale = Math.max(minScale, Math.min(maxScale, getWidthScale(width)));
  return Math.round(size * scale);
};

// Funci√≥n para obtener dimensiones responsive
export const getResponsiveDimension = (
  mobile: number,
  tablet: number,
  width: number = screenWidth,
): number => {
  return isTablet(width) ? tablet : mobile;
};

// Escalas de spacing responsive (m√°s espacioso en tablets para mejor legibilidad)
export const RESPONSIVE_SPACING = {
  xxxs: (width: number = screenWidth) =>
    isTablet(width) ? scaleWidth(2, width) : scaleWidth(1, width),
  xxs: (width: number = screenWidth) =>
    isTablet(width) ? scaleWidth(4, width) : scaleWidth(2, width),
  xs: (width: number = screenWidth) =>
    isTablet(width) ? scaleWidth(6, width) : scaleWidth(4, width),
  s: (width: number = screenWidth) =>
    isTablet(width) ? scaleWidth(10, width) : scaleWidth(8, width),
  m: (width: number = screenWidth) =>
    isTablet(width) ? scaleWidth(16, width) : scaleWidth(16, width),
  l: (width: number = screenWidth) =>
    isTablet(width) ? scaleWidth(24, width) : scaleWidth(24, width),
  xl: (width: number = screenWidth) =>
    isTablet(width) ? scaleWidth(32, width) : scaleWidth(32, width),
  xxl: (width: number = screenWidth) =>
    isTablet(width) ? scaleWidth(40, width) : scaleWidth(40, width),
} as const;

// Tama√±os de fuente responsive (optimizadas para tablets)
export const RESPONSIVE_FONT_SIZES = {
  xs: (width: number = screenWidth) =>
    isTablet(width) ? 10 : scaleWithLimits(10, 0.9, 1.1, width),
  s: (width: number = screenWidth) =>
    isTablet(width) ? 12 : scaleWithLimits(12, 0.9, 1.1, width),
  m: (width: number = screenWidth) =>
    isTablet(width) ? 14 : scaleWithLimits(14, 0.9, 1.2, width),
  l: (width: number = screenWidth) =>
    isTablet(width) ? 16 : scaleWithLimits(16, 0.9, 1.2, width),
  xl: (width: number = screenWidth) =>
    isTablet(width) ? 18 : scaleWithLimits(20, 0.9, 1.3, width),
  xxl: (width: number = screenWidth) =>
    isTablet(width) ? 22 : scaleWithLimits(24, 0.9, 1.3, width),
  xxxl: (width: number = screenWidth) =>
    isTablet(width) ? 28 : scaleWithLimits(32, 0.9, 1.4, width),
} as const;

// Dimensiones comunes responsive
export const RESPONSIVE_DIMENSIONS = {
  // Drawer
  drawerWidth: (width: number = screenWidth) => {
    if (width < BREAKPOINTS.sm) return 280;
    if (width < BREAKPOINTS.md) return 300;
    if (width < BREAKPOINTS.lg) return 340;
    if (width < BREAKPOINTS.xl) return 360;
    return 380;
  },

  // Modales
  modalWidth: (width: number = screenWidth) => {
    if (width < BREAKPOINTS.sm) return width * 0.95;
    if (width < BREAKPOINTS.md) return width * 0.85;
    if (width < BREAKPOINTS.lg) return Math.min(width * 0.6, 500);
    return Math.min(width * 0.45, 550);
  },

  // Headers
  headerHeight: (width: number = screenWidth) => {
    return getResponsiveDimension(56, 64, width);
  },

  // Botones
  buttonHeight: (width: number = screenWidth) => {
    return getResponsiveDimension(48, 44, width);
  },

  // Iconos
  iconSize: {
    small: (width: number = screenWidth) =>
      getResponsiveDimension(16, 16, width),
    medium: (width: number = screenWidth) =>
      getResponsiveDimension(24, 24, width),
    large: (width: number = screenWidth) =>
      getResponsiveDimension(32, 32, width),
  },

  // Im√°genes de productos
  productImageSize: (width: number = screenWidth) => {
    if (width < BREAKPOINTS.sm) return 80;
    if (width < BREAKPOINTS.md) return 100;
    if (width < BREAKPOINTS.lg) return 90;
    return 100; // M√°s compacto en tablets
  },

  // Cards
  cardMinWidth: (width: number = screenWidth) => {
    if (width < BREAKPOINTS.sm) return width - 32;
    if (width < BREAKPOINTS.md) return 280;
    if (width < BREAKPOINTS.lg) return 320;
    return 360;
  },
} as const;

// Funci√≥n helper para aplicar estilos condicionales seg√∫n breakpoint
export const applyResponsiveStyle = <T>(
  width: number,
  styles: {
    xs?: T;
    sm?: T;
    md?: T;
    lg?: T;
    xl?: T;
    xxl?: T;
  },
): T | undefined => {
  const breakpoints = Object.keys(BREAKPOINTS).reverse() as Array<
    keyof typeof BREAKPOINTS
  >;

  for (const breakpoint of breakpoints) {
    if (width >= BREAKPOINTS[breakpoint] && styles[breakpoint]) {
      return styles[breakpoint];
    }
  }

  return undefined;
};

// Utilidad para calcular columnas en grids
export const getGridColumns = (
  width: number = screenWidth,
  minItemWidth: number = 150,
  gap: number = 16,
  padding: number = 16,
): number => {
  const availableWidth = width - padding * 2;
  const columns = Math.floor((availableWidth + gap) / (minItemWidth + gap));
  return Math.max(1, columns);
};

// Utilidad para obtener orientaci√≥n safe
export const getOrientation = (
  width: number = screenWidth,
  height: number = screenHeight,
) => {
  return width > height ? 'landscape' : 'portrait';
};

// Utilidad para calcular aspect ratio
export const maintainAspectRatio = (
  originalWidth: number,
  originalHeight: number,
  maxWidth: number,
  maxHeight: number,
) => {
  const aspectRatio = originalWidth / originalHeight;

  let width = maxWidth;
  let height = maxWidth / aspectRatio;

  if (height > maxHeight) {
    height = maxHeight;
    width = maxHeight * aspectRatio;
  }

  return { width: Math.round(width), height: Math.round(height) };
};

// Exportar utilidad para normalizar seg√∫n DPI
export const normalizeDPI = (size: number): number => {
  const pixelRatio = PixelRatio.get();
  return Math.round(size * pixelRatio) / pixelRatio;
};

// Utilidad para obtener dimensiones de pantalla actualizadas
export const getScreenDimensions = () => {
  return Dimensions.get('window');
};

// Multiplicador de densidad para tablets (m√°s compacto)
export const TABLET_DENSITY_MULTIPLIER = 0.75;

// Helper para obtener tama√±o compacto en tablets
export const getCompactSize = (
  mobileSize: number,
  width: number = screenWidth,
  compactRatio: number = TABLET_DENSITY_MULTIPLIER,
): number => {
  return isTablet(width) ? Math.round(mobileSize * compactRatio) : mobileSize;
};

// Helper para obtener tama√±o de fuente compacto
export const getCompactFontSize = (
  mobileSize: number,
  width: number = screenWidth,
  compactRatio: number = 0.85,
): number => {
  return isTablet(width) ? Math.round(mobileSize * compactRatio) : mobileSize;
};

// Helper para obtener spacing compacto
export const getCompactSpacing = (
  mobileSpacing: number,
  width: number = screenWidth,
  compactRatio: number = 0.65,
): number => {
  return isTablet(width)
    ? Math.round(mobileSpacing * compactRatio)
    : mobileSpacing;
};

================
File: app/src/modules/areasTables/services/areaService.ts
================
import { useQuery } from '@tanstack/react-query';
import ApiClientWrapper from '../../../app/services/apiClientWrapper';
import { ApiError } from '../../../app/lib/errors';
import { API_PATHS } from '../../../app/constants/apiPaths';
import { BackendErrorResponse } from '../../../app/types/api.types';
import { BaseListQuery } from '../../../app/types/query.types';
import {
  Area,
  CreateAreaDto,
  UpdateAreaDto,
  FindAllAreasDto,
} from '../schema/area.schema';

export const getAreas = async (
  filterOptions: FindAllAreasDto = {},
  paginationOptions: BaseListQuery = { page: 1, limit: 10 },
): Promise<Area[]> => {
  const response = await ApiClientWrapper.get<{
    items: Area[];
    total: number;
    page: number;
    limit: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  }>(API_PATHS.AREAS, {
    ...filterOptions,
    page: paginationOptions.page,
    limit: paginationOptions.limit,
  });

  if (!response.ok || !response.data) {
    // Error al obtener √°reas
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
  return response.data.items;
};

export const getAreaById = async (id: string): Promise<Area> => {
  const response = await ApiClientWrapper.get<Area>(
    API_PATHS.AREAS_BY_ID.replace(':id', id),
  );

  if (!response.ok || !response.data) {
    // Error al obtener √°rea por ID
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
  return response.data;
};

export const createArea = async (data: CreateAreaDto): Promise<Area> => {
  const response = await ApiClientWrapper.post<Area>(API_PATHS.AREAS, data);

  if (!response.ok || !response.data) {
    // Error al crear √°rea
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
  return response.data;
};

export const updateArea = async (
  id: string,
  data: UpdateAreaDto,
): Promise<Area> => {
  const response = await ApiClientWrapper.patch<Area>(
    API_PATHS.AREAS_BY_ID.replace(':id', id),
    data,
  );

  if (!response.ok || !response.data) {
    // Error al actualizar √°rea
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
  return response.data;
};

export const deleteArea = async (id: string): Promise<void> => {
  const response = await ApiClientWrapper.delete(
    API_PATHS.AREAS_BY_ID.replace(':id', id),
  );

  if (!response.ok) {
    // Error al eliminar √°rea
    throw ApiError.fromApiResponse(
      response.data as BackendErrorResponse | undefined,
      response.status,
    );
  }
};

// Claves de Query para √°reas
const areaQueryKeys = {
  all: ['areas'] as const,
};

/**
 * Hook para obtener la lista de todas las √°reas activas usando React Query.
 */
export function useGetAreas() {
  return useQuery<Area[], ApiError>({
    queryKey: areaQueryKeys.all,
    queryFn: () => getAreas(), // Llama a getAreas sin argumentos para obtener todos por defecto
    // Sin staleTime, se usar√° la configuraci√≥n global (0)
  });
}

================
File: app/src/modules/auth/components/RegisterForm.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';
import {
  Portal,
  Modal,
  Text,
  TextInput,
  Button,
  HelperText,
  Surface,
  IconButton,
  Chip,
  Avatar,
  Divider,
  Icon,
} from 'react-native-paper';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { z } from 'zod';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useMutation } from '@tanstack/react-query';
import { authService } from '../services/authService';
import { useSnackbarStore } from '../../../app/store/snackbarStore';
import { getApiErrorMessage } from '../../../app/lib/errorMapping';

const registerFormSchema = z.object({
  username: z
    .string()
    .min(3, 'El nombre de usuario debe tener al menos 3 caracteres')
    .max(20, 'El nombre de usuario no puede exceder 20 caracteres')
    .regex(/^[a-zA-Z0-9_]+$/, 'Solo se permiten letras, n√∫meros y gui√≥n bajo'),
  email: z.string().email('Email inv√°lido'),
  password: z.string().min(6, 'La contrase√±a debe tener al menos 6 caracteres'),
  firstName: z
    .string()
    .min(2, 'El nombre debe tener al menos 2 caracteres')
    .max(50, 'El nombre no puede exceder 50 caracteres'),
  lastName: z
    .string()
    .min(2, 'El apellido debe tener al menos 2 caracteres')
    .max(50, 'El apellido no puede exceder 50 caracteres'),
  phoneNumber: z
    .union([
      z.string().regex(/^\+?[0-9\s-]+$/, 'N√∫mero de tel√©fono inv√°lido'),
      z.literal(''),
    ])
    .optional(),
  role: z.number(),
});

type RegisterFormInputs = z.infer<typeof registerFormSchema>;

interface RegisterModalProps {
  visible: boolean;
  onDismiss: () => void;
  onRegisterSuccess?: (username: string, password: string) => void;
}

export function RegisterModal({
  visible,
  onDismiss,
  onRegisterSuccess,
}: RegisterModalProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = getStyles(theme, responsive);
  const [showPassword, setShowPassword] = useState(false);
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const {
    control,
    handleSubmit,
    formState: { errors },
    reset,
  } = useForm<RegisterFormInputs>({
    resolver: zodResolver(registerFormSchema),
    defaultValues: {
      username: '',
      email: '',
      password: '',
      firstName: '',
      lastName: '',
      phoneNumber: '',
      role: 4, // Default a Mesero
    },
  });

  const { mutate: register, isPending } = useMutation({
    mutationFn: (data: RegisterFormInputs) => {
      const registerData = {
        username: data.username,
        email: data.email,
        password: data.password,
        firstName: data.firstName,
        lastName: data.lastName,
        phoneNumber: data.phoneNumber || undefined,
        role: { id: data.role },
        isActive: true,
      };
      return authService.register(registerData as any);
    },
    onSuccess: (_, variables) => {
      showSnackbar({
        message: 'Registro exitoso. Ya puedes iniciar sesi√≥n.',
        type: 'success',
      });

      // Pasar los datos al formulario de login
      if (onRegisterSuccess) {
        onRegisterSuccess(variables.username, variables.password);
      }

      reset();
      onDismiss();
    },
    onError: (error: unknown) => {
      const userMessage = getApiErrorMessage(error);
      showSnackbar({
        message: userMessage,
        type: 'error',
        duration: 5000,
      });
    },
  });

  const onSubmit = (data: RegisterFormInputs) => {
    register(data);
  };

  const handleDismiss = () => {
    reset();
    setShowPassword(false);
    onDismiss();
  };

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={handleDismiss}
        contentContainerStyle={styles.modalContainer}
      >
        <Surface style={styles.modalContent} elevation={5}>
          <View
            style={[
              styles.headerContainer,
              { backgroundColor: theme.colors.primary },
            ]}
          >
            <View style={styles.headerLeft}>
              <Avatar.Icon
                size={32}
                icon="account-plus"
                style={[
                  styles.headerIcon,
                  { backgroundColor: theme.colors.onPrimary + '20' },
                ]}
                color={theme.colors.onPrimary}
              />
              <View style={styles.headerTextContainer}>
                <Text
                  style={[styles.modalTitle, { color: theme.colors.onPrimary }]}
                  variant="titleMedium"
                >
                  Crear cuenta
                </Text>
              </View>
            </View>
            <IconButton
              icon="close"
              size={24}
              onPress={handleDismiss}
              disabled={isPending}
              iconColor={theme.colors.onPrimary}
            />
          </View>

          <ScrollView
            style={styles.formContainer}
            showsVerticalScrollIndicator={false}
            keyboardShouldPersistTaps="handled"
          >
            <View style={styles.sectionContainer}>
              <View style={styles.sectionHeader}>
                <Icon
                  source="account-key"
                  size={20}
                  color={theme.colors.primary}
                />
                <Text style={styles.sectionTitle} variant="titleMedium">
                  Informaci√≥n de Cuenta
                </Text>
                <Chip
                  mode="flat"
                  compact
                  icon="check"
                  style={styles.requiredChip}
                  textStyle={styles.requiredChipText}
                >
                  Requerido
                </Chip>
              </View>

              <Controller
                control={control}
                name="username"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Nombre de usuario"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.username}
                      mode="outlined"
                      placeholder="usuario123"
                      autoCapitalize="none"
                      left={<TextInput.Icon icon="account" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.username && (
                      <HelperText type="error" visible={!!errors.username}>
                        {errors.username.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />

              <Controller
                control={control}
                name="email"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Email"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.email}
                      mode="outlined"
                      placeholder="usuario@ejemplo.com"
                      keyboardType="email-address"
                      autoCapitalize="none"
                      left={<TextInput.Icon icon="email" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.email && (
                      <HelperText type="error" visible={!!errors.email}>
                        {errors.email.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />

              <Controller
                control={control}
                name="password"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Contrase√±a"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.password}
                      mode="outlined"
                      placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                      secureTextEntry={!showPassword}
                      autoCapitalize="none"
                      left={<TextInput.Icon icon="lock" />}
                      right={
                        <TextInput.Icon
                          icon={showPassword ? 'eye-off' : 'eye'}
                          onPress={() => setShowPassword(!showPassword)}
                        />
                      }
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.password && (
                      <HelperText type="error" visible={!!errors.password}>
                        {errors.password.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />

              <Controller
                control={control}
                name="role"
                render={({ field: { onChange, value } }) => (
                  <View style={styles.inputContainer}>
                    <View style={styles.fieldLabelContainer}>
                      <Icon
                        source="badge-account"
                        size={20}
                        color={theme.colors.primary}
                      />
                      <Text style={styles.sectionTitle} variant="titleMedium">
                        Tipo de cuenta
                      </Text>
                    </View>
                    <View style={styles.rolesContainer}>
                      {[
                        {
                          value: 4,
                          label: 'Mesero',
                          icon: 'room-service',
                          description: 'Tomar y gestionar √≥rdenes',
                        },
                        {
                          value: 6,
                          label: 'Repartidor',
                          icon: 'moped',
                          description: 'Entregar pedidos',
                        },
                      ].map((role) => (
                        <Surface
                          key={role.value}
                          style={[
                            styles.roleCard,
                            value === role.value && styles.roleCardActive,
                          ]}
                          elevation={value === role.value ? 2 : 0}
                        >
                          <TouchableOpacity
                            onPress={() => onChange(role.value)}
                            style={styles.roleCardContent}
                          >
                            <Icon
                              source={role.icon}
                              size={24}
                              color={
                                value === role.value
                                  ? theme.colors.primary
                                  : theme.colors.onSurfaceVariant
                              }
                            />
                            <Text
                              style={[
                                styles.roleLabel,
                                value === role.value && styles.roleLabelActive,
                              ]}
                              variant="labelMedium"
                            >
                              {role.label}
                            </Text>
                            <Text
                              style={styles.roleDescription}
                              variant="bodySmall"
                              numberOfLines={2}
                            >
                              {role.description}
                            </Text>
                          </TouchableOpacity>
                        </Surface>
                      ))}
                    </View>
                  </View>
                )}
              />
            </View>

            <Divider style={styles.divider} />

            <View style={styles.sectionContainer}>
              <View style={styles.sectionHeader}>
                <Icon
                  source="account-circle"
                  size={20}
                  color={theme.colors.primary}
                />
                <Text style={styles.sectionTitle} variant="titleMedium">
                  Informaci√≥n Personal
                </Text>
                <Chip
                  mode="flat"
                  compact
                  icon="check"
                  style={styles.requiredChip}
                  textStyle={styles.requiredChipText}
                >
                  Requerido
                </Chip>
              </View>

              <Controller
                control={control}
                name="firstName"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Nombre"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.firstName}
                      mode="outlined"
                      placeholder="Juan"
                      left={<TextInput.Icon icon="account" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.firstName && (
                      <HelperText type="error" visible={!!errors.firstName}>
                        {errors.firstName.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />

              <Controller
                control={control}
                name="lastName"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Apellido"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.lastName}
                      mode="outlined"
                      placeholder="P√©rez"
                      left={<TextInput.Icon icon="account" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.lastName && (
                      <HelperText type="error" visible={!!errors.lastName}>
                        {errors.lastName.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />

              <Controller
                control={control}
                name="phoneNumber"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Tel√©fono (opcional)"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.phoneNumber}
                      mode="outlined"
                      placeholder="+52 55 1234 5678"
                      keyboardType="phone-pad"
                      left={<TextInput.Icon icon="phone" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.phoneNumber && (
                      <HelperText type="error" visible={!!errors.phoneNumber}>
                        {errors.phoneNumber.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />
            </View>
          </ScrollView>

          <Surface style={styles.buttonContainer} elevation={2}>
            <Button
              onPress={handleDismiss}
              disabled={isPending}
              style={[styles.button, styles.cancelButton]}
              textColor={theme.colors.onSecondaryContainer}
            >
              Cancelar
            </Button>
            <Button
              mode="contained"
              onPress={handleSubmit(onSubmit)}
              disabled={isPending}
              loading={isPending}
              style={[styles.button, styles.confirmButton]}
              buttonColor={theme.colors.primary}
            >
              Registrarse
            </Button>
          </Surface>
        </Surface>
      </Modal>
    </Portal>
  );
}

const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    modalContainer: {
      margin: responsive.isTablet ? 20 : 12,
      maxWidth: responsive.isTablet ? 600 : '100%',
      alignSelf: 'center',
      width: responsive.isTablet ? '80%' : '94%',
    },
    modalContent: {
      borderRadius: responsive.isTablet
        ? theme.roundness * 3
        : theme.roundness * 2,
      backgroundColor: theme.colors.surface,
      maxHeight: responsive.isTablet ? '90%' : '92%',
      minHeight: responsive.isTablet ? 600 : 550,
      overflow: 'hidden',
    },
    headerContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.s,
      borderTopLeftRadius: theme.roundness * 3,
      borderTopRightRadius: theme.roundness * 3,
    },
    headerLeft: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
    },
    headerIcon: {
      marginRight: theme.spacing.s,
    },
    headerTextContainer: {
      flex: 1,
    },
    modalTitle: {
      fontWeight: '700',
    },
    formContainer: {
      flex: 1,
      paddingHorizontal: responsive.isTablet
        ? responsive.spacing.m
        : responsive.spacing.s,
      paddingTop: responsive.isTablet
        ? responsive.spacing.s
        : responsive.spacing.xs,
      paddingBottom: responsive.spacing.xs,
    },
    sectionContainer: {
      marginBottom: responsive.isTablet
        ? theme.spacing.s
        : responsive.spacing.xs,
    },
    sectionHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: responsive.isTablet ? theme.spacing.xs : 6,
      gap: responsive.isTablet ? theme.spacing.xs : 6,
    },
    sectionTitle: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: responsive.isTablet ? 14 : 13,
      flex: 1,
    },
    requiredChip: {
      backgroundColor: theme.colors.primary + '20',
      borderWidth: 1,
      borderColor: theme.colors.primary + '40',
    },
    requiredChipText: {
      color: theme.colors.primary,
      fontSize: responsive.isTablet ? 11 : 10,
      fontWeight: '600',
    },
    inputContainer: {
      marginBottom: responsive.isTablet ? theme.spacing.xs : 6,
    },
    inputOutline: {
      borderRadius: theme.roundness * 2,
      borderWidth: 1,
    },
    input: {
      fontSize: responsive.isTablet ? 14 : 13,
      backgroundColor: theme.colors.surface,
      height: responsive.isTablet ? 48 : 44,
    },
    inputContent: {
      paddingVertical: responsive.isTablet ? 4 : 2,
      fontSize: responsive.isTablet ? 14 : 13,
      fontFamily: 'System',
    },
    fieldLabelContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.isTablet ? theme.spacing.xs : 6,
      marginBottom: responsive.isTablet ? theme.spacing.s : theme.spacing.xs,
    },
    rolesContainer: {
      flexDirection: 'row',
      gap: responsive.isTablet ? theme.spacing.s : theme.spacing.xs,
      justifyContent: 'center',
    },
    roleCard: {
      borderRadius: theme.roundness * 2,
      padding: responsive.isTablet ? theme.spacing.s : theme.spacing.xs,
      backgroundColor: theme.colors.surface,
      minWidth: responsive.isTablet ? 140 : 125,
      borderWidth: 1.5,
      borderColor: theme.colors.outlineVariant,
      elevation: 1,
    },
    roleCardActive: {
      backgroundColor: theme.colors.primaryContainer,
      borderColor: theme.colors.primary,
      elevation: 3,
    },
    roleCardContent: {
      alignItems: 'center',
    },
    roleLabel: {
      color: theme.colors.onSurfaceVariant,
      marginTop: responsive.isTablet ? theme.spacing.xs : 4,
      fontWeight: '500',
      fontSize: responsive.isTablet ? 14 : 13,
    },
    roleLabelActive: {
      color: theme.colors.onPrimaryContainer,
      fontWeight: '700',
    },
    roleDescription: {
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
      fontSize: responsive.isTablet ? 11 : 10,
      textAlign: 'center',
    },
    divider: {
      marginVertical: responsive.isTablet ? theme.spacing.s : theme.spacing.xs,
      marginHorizontal: responsive.isTablet
        ? -theme.spacing.m
        : -theme.spacing.s,
    },
    buttonContainer: {
      flexDirection: 'row',
      justifyContent: 'center',
      padding: responsive.isTablet ? theme.spacing.s : theme.spacing.xs,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      gap: responsive.isTablet ? theme.spacing.s : theme.spacing.xs,
    },
    button: {
      flex: 1,
      maxWidth: responsive.isTablet ? 150 : 140,
    },
    cancelButton: {
      backgroundColor: theme.colors.secondaryContainer,
    },
    confirmButton: {},
  });

================
File: app/src/modules/kitchen/components/OrderItemRow.tsx
================
import React from 'react';
import { View, StyleSheet, TouchableOpacity, Platform } from 'react-native';
import { Text, useTheme, Chip } from 'react-native-paper';
import { KitchenOrderItem, PreparationStatus } from '../types/kitchen.types';
import { useResponsive } from '@/app/hooks/useResponsive';

interface OrderItemRowProps {
  item: KitchenOrderItem;
  onPress?: () => void;
  onTogglePrepared?: (itemId: string, currentStatus: boolean) => void;
  isOrderInPreparation?: boolean;
}

export const OrderItemRow = React.memo<OrderItemRowProps>(
  ({ item, onTogglePrepared, isOrderInPreparation }) => {
    const theme = useTheme();
    const responsive = useResponsive();

    const isPrepared = item.preparationStatus === PreparationStatus.READY;
    const isInProgress =
      item.preparationStatus === PreparationStatus.IN_PROGRESS;
    const isDisabled = !item.belongsToMyScreen;
    // Permitir toggle si la orden est√° en preparaci√≥n, el item pertenece a esta pantalla y est√° IN_PROGRESS o READY
    const canToggle =
      isOrderInPreparation &&
      (isInProgress || isPrepared) &&
      item.belongsToMyScreen &&
      onTogglePrepared;

    const buildItemName = () => {
      // Si tiene variante, solo mostrar la variante
      // Si no tiene variante, mostrar el nombre del producto
      const displayName = item.variantName || item.productName;
      return `${item.quantity}x ${displayName}`;
    };

    const buildItemDetails = () => {
      const details: string[] = [];

      // Combinar mods y customizations en una l√≠nea si es posible
      const allCustoms: string[] = [];

      if (item.modifiers.length > 0) {
        allCustoms.push(...item.modifiers);
      }

      if (item.pizzaCustomizations && item.pizzaCustomizations.length > 0) {
        const customizations = item.pizzaCustomizations.map((pc) => {
          let text = pc.customizationName;
          if (pc.action) text += ` (${pc.action})`;
          if (pc.half) text += ` - ${pc.half}`;
          return text;
        });
        allCustoms.push(...customizations);
      }

      if (allCustoms.length > 0) {
        details.push(allCustoms.join(', '));
      }

      if (item.preparationNotes) {
        details.push(`üìù ${item.preparationNotes}`);
      }

      return details;
    };

    const styles = StyleSheet.create({
      container: {
        paddingHorizontal: responsive.isWeb
          ? responsive.spacing.m
          : responsive.spacing.s,
        paddingVertical: responsive.isWeb
          ? responsive.spacing.s
          : responsive.spacing.xs,
        minHeight: responsive.isWeb ? 52 : responsive.isTablet ? 40 : 36,
        display: 'flex',
        justifyContent: 'center',
      },
      disabled: {
        opacity: 0.5,
      },
      row: {
        flexDirection: 'row',
        alignItems: 'center',
        flex: 1,
      },
      content: {
        flex: 1,
      },
      withBorder: {
        borderRadius: theme.roundness / 2,
        borderWidth: 1,
        borderColor: theme.colors.outline,
        borderStyle: 'dashed',
      },
      clickable: {
        backgroundColor: 'rgba(0, 0, 0, 0.02)',
      },
      itemName: {
        fontWeight: '500',
        fontSize: responsive.isWeb ? 16 : responsive.isTablet ? 13 : 14,
        lineHeight: responsive.isWeb ? 24 : responsive.isTablet ? 18 : 20,
      },
      detail: {
        color: theme.colors.onSurfaceVariant,
        marginTop: responsive.isWeb ? 2 : -1,
        fontSize: responsive.isWeb ? 14 : responsive.isTablet ? 11 : 12,
        lineHeight: responsive.isWeb ? 20 : responsive.isTablet ? 14 : 16,
      },
      strikethrough: {
        textDecorationLine: 'line-through',
        textDecorationStyle: 'solid',
        textDecorationColor: theme.colors.error,
        opacity: 0.7,
      },
      disabledText: {
        color: theme.colors.onSurfaceDisabled || '#999',
      },
    });

    const handlePress = () => {
      if (canToggle) {
        onTogglePrepared(item.id, isPrepared);
      }
    };

    const Container = canToggle ? TouchableOpacity : View;

    return (
      <Container
        onPress={canToggle ? handlePress : undefined}
        activeOpacity={0.7}
        style={[
          styles.container,
          styles.withBorder,
          isDisabled && styles.disabled,
          canToggle && styles.clickable,
        ]}
      >
        <View style={styles.row}>
          <View style={styles.content}>
            <View
              style={{
                flexDirection: 'row',
                alignItems: 'center',
                gap: responsive.spacing.xs,
              }}
            >
              <Text
                variant="bodyMedium"
                style={[
                  styles.itemName,
                  isPrepared && styles.strikethrough,
                  isDisabled && styles.disabledText,
                ]}
              >
                {buildItemName()}
              </Text>
            </View>
            {buildItemDetails().map((detail, index) => (
              <Text
                key={index}
                variant="labelSmall"
                style={[
                  styles.detail,
                  isPrepared && styles.strikethrough,
                  isDisabled && styles.disabledText,
                ]}
              >
                {detail}
              </Text>
            ))}
          </View>
        </View>
      </Container>
    );
  },
);

OrderItemRow.displayName = 'OrderItemRow';

================
File: app/src/modules/kitchen/services/kitchenService.ts
================
import ApiClientWrapper from '@/app/services/apiClientWrapper';
import { KitchenOrder, KitchenFilters } from '../types/kitchen.types';
import { API_PATHS } from '@/app/constants/apiPaths';

interface _PaginationResponse<T> {
  data: T[];
  hasNextPage: boolean;
}

class KitchenService {
  async getKitchenOrders(
    filters: Partial<KitchenFilters> = {},
  ): Promise<KitchenOrder[]> {
    // Construir query string manualmente para evitar problemas de serializaci√≥n
    const queryParams = new URLSearchParams();

    // Solo enviar orderType si tiene un valor (no es undefined)
    if (filters.orderType) {
      queryParams.append('orderType', filters.orderType);
    }
    if (filters.showPrepared !== undefined) {
      queryParams.append('showPrepared', String(filters.showPrepared));
    }
    if (filters.showAllProducts !== undefined) {
      queryParams.append('showAllProducts', String(filters.showAllProducts));
    }
    if (filters.ungroupProducts !== undefined) {
      queryParams.append('ungroupProducts', String(filters.ungroupProducts));
    }
    if (filters.screenId !== undefined) {
      queryParams.append('screenId', filters.screenId);
    }

    const queryString = queryParams.toString();
    const url = queryString
      ? `${API_PATHS.KITCHEN_ORDERS}?${queryString}`
      : API_PATHS.KITCHEN_ORDERS;

    const response = await ApiClientWrapper.get<KitchenOrder[]>(url);
    return response.data || [];
  }

  async markItemPrepared(
    itemId: string,
    isPrepared: boolean = true,
  ): Promise<void> {
    await ApiClientWrapper.patch(
      API_PATHS.KITCHEN_MARK_PREPARED.replace(':itemId', itemId),
      {
        isPrepared,
      },
    );
  }

  async unmarkItemPrepared(itemId: string): Promise<void> {
    await ApiClientWrapper.patch(
      API_PATHS.KITCHEN_MARK_UNPREPARED.replace(':itemId', itemId),
    );
  }

  async startOrderPreparation(orderId: string): Promise<void> {
    await ApiClientWrapper.patch(
      API_PATHS.KITCHEN_ORDERS_START_PREPARATION.replace(':orderId', orderId),
    );
  }

  async cancelOrderPreparation(orderId: string): Promise<void> {
    await ApiClientWrapper.patch(
      API_PATHS.KITCHEN_ORDERS_CANCEL_PREPARATION.replace(':orderId', orderId),
    );
  }

  async completeOrderPreparation(orderId: string): Promise<void> {
    await ApiClientWrapper.patch(
      API_PATHS.KITCHEN_ORDERS_COMPLETE_PREPARATION.replace(
        ':orderId',
        orderId,
      ),
    );
  }
}

export const kitchenService = new KitchenService();

================
File: app/src/modules/kitchen/types/kitchen.types.ts
================
export enum OrderType {
  DINE_IN = 'DINE_IN',
  TAKE_AWAY = 'TAKE_AWAY',
  DELIVERY = 'DELIVERY',
}

export enum PreparationStatus {
  PENDING = 'PENDING',
  IN_PROGRESS = 'IN_PROGRESS',
  READY = 'READY',
  DELIVERED = 'DELIVERED',
  CANCELLED = 'CANCELLED',
}

export enum PreparationScreenStatus {
  PENDING = 'PENDING',
  IN_PREPARATION = 'IN_PREPARATION',
  READY = 'READY',
}

export interface KitchenOrderItem {
  id: string;
  productName: string;
  variantName?: string;
  modifiers: string[];
  pizzaCustomizations?: Array<{
    customizationName: string;
    action: string;
    half?: string;
  }>;
  preparationNotes?: string;
  preparationStatus: PreparationStatus;
  preparedAt?: string;
  preparedByUser?: {
    firstName: string;
    lastName: string;
  };
  quantity: number;
  belongsToMyScreen: boolean;
}

export interface PreparationScreenStatusInfo {
  screenId: string;
  screenName: string;
  status: PreparationScreenStatus;
}

export interface KitchenOrder {
  id: string;
  shiftOrderNumber: number;
  orderType: OrderType;
  orderStatus: string; // Estado real de la orden
  createdAt: string;
  orderNotes?: string;
  // Campos espec√≠ficos seg√∫n tipo
  deliveryAddress?: string;
  deliveryPhone?: string;
  receiptName?: string;
  customerPhone?: string;
  areaName?: string;
  tableName?: string;
  items: KitchenOrderItem[];
  hasPendingItems: boolean;
  screenStatuses: PreparationScreenStatusInfo[];
  myScreenStatus?: PreparationScreenStatus;
  isFromWhatsApp?: boolean;
}

export interface KitchenFilters {
  orderType?: OrderType;
  showPrepared: boolean;
  showAllProducts: boolean;
  ungroupProducts: boolean;
  screenId?: string;
}

export interface PreparationScreen {
  id: string;
  name: string;
  description?: string;
  isActive: boolean;
}

================
File: app/src/modules/menu/services/fileService.ts
================
import ApiClientWrapper from '../../../app/services/apiClientWrapper';
import { ApiError } from '../../../app/lib/errors';
import { Platform } from 'react-native';
import { API_PATHS } from '../../../app/constants/apiPaths';
import NetInfo from '@react-native-community/netinfo';

export interface FileUploadResponse {
  file: {
    id: string;
    path: string;
  };
  presignedUrl?: string;
}

export interface FileObject {
  uri: string;
  name: string;
  type: string;
}

// Verificar conectividad antes de intentar subir
const checkNetworkConnection = async (): Promise<boolean> => {
  const state = await NetInfo.fetch();
  return state.isConnected === true && state.isInternetReachable !== false;
};

export const uploadFile = async (
  fileToUpload: FileObject,
  maxRetries: number = 3,
): Promise<FileUploadResponse> => {
  // Verificar conexi√≥n antes de intentar
  const isConnected = await checkNetworkConnection();
  if (!isConnected) {
    throw new ApiError(
      'NETWORK_ERROR',
      'Sin conexi√≥n a internet. Verifica tu conexi√≥n e intenta nuevamente.',
      0,
    );
  }

  const formData = new FormData();
  formData.append('file', {
    uri:
      Platform.OS === 'android'
        ? fileToUpload.uri
        : fileToUpload.uri.replace('file://', ''),
    name: fileToUpload.name,
    type: fileToUpload.type,
  } as any);

  let lastError: any;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const response = await ApiClientWrapper.post<FileUploadResponse>(
        API_PATHS.FILES_UPLOAD,
        formData,
        {
          headers: {
            'Content-Type': 'multipart/form-data',
            // Agregar header para evitar problemas de cach√©
            'Cache-Control': 'no-cache',
          },
          timeout: 120000, // Aumentar timeout a 2 minutos para uploads
          // Configuraci√≥n adicional para mejorar la estabilidad
          maxContentLength: Infinity,
          maxBodyLength: Infinity,
        },
      );

      if (!response.ok || !response.data || !response.data.file) {
        lastError = ApiError.fromApiResponse(response.data, response.status);

        // Si no es un error de red, no reintentar
        if (response.status && response.status < 500) {
          throw lastError;
        }

        // Esperar antes de reintentar (backoff exponencial)
        if (attempt < maxRetries) {
          const delay = Math.min(1000 * Math.pow(2, attempt - 1), 5000);
          await new Promise((resolve) => setTimeout(resolve, delay));
          continue;
        }
      }

      return response.data!;
    } catch (error) {
      lastError = error;

      // Si es un error de cliente (4xx), no reintentar
      if (
        error instanceof ApiError &&
        error.status >= 400 &&
        error.status < 500
      ) {
        throw error;
      }

      // Si es el √∫ltimo intento, lanzar el error
      if (attempt === maxRetries) {
        if (error instanceof ApiError) throw error;
        throw new ApiError(
          'UPLOAD_FAILED',
          `Error al subir archivo despu√©s de ${maxRetries} intentos: ${error instanceof Error ? error.message : 'Error desconocido'}`,
          500,
        );
      }

      // Esperar antes de reintentar (backoff exponencial)
      const delay = Math.min(1000 * Math.pow(2, attempt - 1), 5000);
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
  }

  // Por si acaso llegamos aqu√≠
  throw (
    lastError ||
    new ApiError('UPLOAD_FAILED', 'Error desconocido al subir archivo', 500)
  );
};

const fileService = {
  uploadFile,
  uploadImage: uploadFile,
};

export default fileService;

================
File: app/src/modules/modifiers/services/modifierGroupService.ts
================
import apiClient from '@/app/services/apiClient';
import { ApiError } from '@/app/lib/errors';
import { API_PATHS } from '@/app/constants/apiPaths';
import {
  ModifierGroup,
  CreateModifierGroupInput,
  UpdateModifierGroupInput,
  modifierGroupApiSchema,
} from '../schema/modifierGroup.schema';
import { z } from 'zod';
import { PaginatedResponse } from '@/app/types/api.types';

const _modifierGroupsListSchema = z.array(modifierGroupApiSchema);

// Schema para respuesta paginada
const paginatedModifierGroupsSchema = z.object({
  items: z.array(modifierGroupApiSchema),
  total: z.number(),
  page: z.number(),
  limit: z.number(),
  hasNextPage: z.boolean(),
  hasPrevPage: z.boolean(),
});

interface FindAllParams {
  page?: number;
  limit?: number;
  isActive?: boolean;
  search?: string;
}

export const modifierGroupService = {
  /**
   * Obtiene todos los grupos de modificadores con paginaci√≥n.
   */
  async findAll(
    params: FindAllParams = {},
  ): Promise<PaginatedResponse<ModifierGroup>> {
    const queryParams = {
      page: params.page ?? 1,
      limit: params.limit ?? 10,
      ...(params.isActive !== undefined && { isActive: params.isActive }),
      ...(params.search && { search: params.search }),
    };
    const response = await apiClient.get<unknown>(
      API_PATHS.MODIFIER_GROUPS,
      queryParams,
    );

    if (!response.ok || !response.data) {
      // Error al obtener grupos de modificadores
      throw ApiError.fromApiResponse(response.data, response.status ?? 500);
    }

    // Parsear como respuesta paginada
    const paginatedResult = paginatedModifierGroupsSchema.safeParse(
      response.data,
    );
    if (paginatedResult.success) {
      // Transformar la respuesta del backend a PaginatedResponse
      return {
        data: paginatedResult.data.items,
        total: paginatedResult.data.total,
        page: paginatedResult.data.page,
        limit: paginatedResult.data.limit,
        totalPages: Math.ceil(
          paginatedResult.data.total / paginatedResult.data.limit,
        ),
      };
    }

    // Datos inv√°lidos recibidos para grupos de modificadores
    throw new Error('Received invalid data format for modifier groups.');
  },

  /**
   * Obtiene un grupo de modificadores por su ID.
   */
  async findOne(id: string): Promise<ModifierGroup> {
    const response = await apiClient.get<unknown>(
      API_PATHS.MODIFIER_GROUPS_BY_ID.replace(':id', id),
    );

    if (!response.ok || !response.data) {
      // Error al obtener grupo de modificador
      throw ApiError.fromApiResponse(response.data, response.status ?? 500);
    }

    const validationResult = modifierGroupApiSchema.safeParse(response.data);
    if (!validationResult.success) {
      // Datos inv√°lidos recibidos para grupo de modificador
      throw new Error(`Received invalid data format for modifier group ${id}.`);
    }
    return validationResult.data;
  },

  /**
   * Crea un nuevo grupo de modificadores.
   */
  async create(data: CreateModifierGroupInput): Promise<ModifierGroup> {
    const response = await apiClient.post<unknown>(
      API_PATHS.MODIFIER_GROUPS,
      data,
    );

    if (!response.ok || !response.data) {
      // Error al crear grupo de modificador
      throw ApiError.fromApiResponse(response.data, response.status ?? 500);
    }

    const validationResult = modifierGroupApiSchema.safeParse(response.data);
    if (!validationResult.success) {
      // Datos inv√°lidos recibidos despu√©s de crear grupo de modificador
      throw new Error(
        'Received invalid data format after creating modifier group.',
      );
    }
    return validationResult.data;
  },

  /**
   * Actualiza un grupo de modificadores existente.
   */
  async update(
    id: string,
    data: UpdateModifierGroupInput,
  ): Promise<ModifierGroup> {
    const response = await apiClient.patch<unknown>(
      API_PATHS.MODIFIER_GROUPS_BY_ID.replace(':id', id),
      data,
    );

    if (!response.ok || !response.data) {
      // Error al actualizar grupo de modificador
      throw ApiError.fromApiResponse(response.data, response.status ?? 500);
    }

    const validationResult = modifierGroupApiSchema.safeParse(response.data);
    if (!validationResult.success) {
      // Datos inv√°lidos recibidos despu√©s de actualizar grupo de modificador
      throw new Error(
        `Received invalid data format after updating modifier group ${id}.`,
      );
    }
    return validationResult.data;
  },

  /**
   * Elimina un grupo de modificadores.
   */
  async remove(id: string): Promise<void> {
    const response = await apiClient.delete(
      API_PATHS.MODIFIER_GROUPS_BY_ID.replace(':id', id),
    );

    if (!response.ok) {
      // Error al eliminar grupo de modificador
      throw ApiError.fromApiResponse(response.data, response.status ?? 500);
    }
  },
};

================
File: app/src/modules/modifiers/services/modifierService.ts
================
import apiClient from '@/app/services/apiClient';
import { ApiError } from '@/app/lib/errors';
import { API_PATHS } from '@/app/constants/apiPaths';
import {
  Modifier,
  CreateModifierInput,
  UpdateModifierInput,
  modifierApiSchema,
} from '../schema/modifier.schema';
import { z } from 'zod';
import { PaginatedResponse } from '@/app/types/api.types';

const modifiersListSchema = z.array(modifierApiSchema);

// Schema para respuesta paginada
const paginatedModifiersSchema = z.object({
  items: z.array(modifierApiSchema),
  total: z.number(),
  page: z.number(),
  limit: z.number(),
  hasNextPage: z.boolean(),
  hasPrevPage: z.boolean(),
});

interface FindAllModifiersParams {
  page?: number;
  limit?: number;
  groupId?: string;
}

export const modifierService = {
  /**
   * Obtiene todos los modificadores con paginaci√≥n.
   */
  async findAll(
    params?: FindAllModifiersParams,
  ): Promise<PaginatedResponse<Modifier>> {
    const queryParams = {
      page: params?.page ?? 1,
      limit: params?.limit ?? 10,
      ...params,
    };
    const response = await apiClient.get<unknown>(
      API_PATHS.MODIFIERS,
      queryParams,
    );

    if (!response.ok || !response.data) {
      // Error al obtener modificadores
      throw ApiError.fromApiResponse(response.data, response.status ?? 500);
    }

    // Parsear como respuesta paginada
    const paginatedResult = paginatedModifiersSchema.safeParse(response.data);
    if (paginatedResult.success) {
      // Transformar la respuesta del backend a PaginatedResponse
      return {
        data: paginatedResult.data.items,
        total: paginatedResult.data.total,
        page: paginatedResult.data.page,
        limit: paginatedResult.data.limit,
        totalPages: Math.ceil(
          paginatedResult.data.total / paginatedResult.data.limit,
        ),
      };
    }

    // Datos inv√°lidos recibidos para modificadores
    throw new Error('Received invalid data format for modifiers.');
  },

  /**
   * Obtiene un modificador por su ID.
   */
  async findOne(id: string): Promise<Modifier> {
    const response = await apiClient.get<unknown>(
      API_PATHS.MODIFIERS_BY_ID.replace(':id', id),
    );

    if (!response.ok || !response.data) {
      // Error al obtener modificador
      throw ApiError.fromApiResponse(response.data, response.status ?? 500);
    }

    const validationResult = modifierApiSchema.safeParse(response.data);
    if (!validationResult.success) {
      // Datos inv√°lidos recibidos para modificador
      throw new Error(`Received invalid data format for modifier ${id}.`);
    }
    return validationResult.data;
  },

  /**
   * Obtiene todos los modificadores asociados a un grupo espec√≠fico, con filtros opcionales.
   */
  async findByGroupId(
    modifierGroupId: string,
    params: { isActive?: boolean; search?: string } = {},
  ): Promise<Modifier[]> {
    const queryParams = {
      ...(params.isActive !== undefined && { isActive: params.isActive }),
      ...(params.search && { search: params.search }),
    };
    const response = await apiClient.get<unknown>(
      API_PATHS.MODIFIERS_BY_GROUP.replace(':modifierGroupId', modifierGroupId),
      queryParams,
    );

    if (!response.ok || !response.data) {
      // Error al obtener modificadores del grupo
      throw ApiError.fromApiResponse(response.data, response.status ?? 500);
    }

    const validationResult = modifiersListSchema.safeParse(response.data);
    if (!validationResult.success) {
      // Datos inv√°lidos recibidos para modificadores del grupo
      throw new Error(
        `Received invalid data format for modifiers of group ${modifierGroupId}.`,
      );
    }
    return validationResult.data;
  },

  /**
   * Crea un nuevo modificador.
   */
  async create(data: CreateModifierInput): Promise<Modifier> {
    const response = await apiClient.post<unknown>(API_PATHS.MODIFIERS, data);

    if (!response.ok || !response.data) {
      // Error al crear modificador
      throw ApiError.fromApiResponse(response.data, response.status ?? 500);
    }

    const validationResult = modifierApiSchema.safeParse(response.data);
    if (!validationResult.success) {
      // Datos inv√°lidos recibidos despu√©s de crear modificador
      throw new Error('Received invalid data format after creating modifier.');
    }
    return validationResult.data;
  },

  /**
   * Actualiza un modificador existente.
   */
  async update(id: string, data: UpdateModifierInput): Promise<Modifier> {
    const response = await apiClient.patch<unknown>(
      API_PATHS.MODIFIERS_BY_ID.replace(':id', id),
      data,
    );

    if (!response.ok || !response.data) {
      // Error al actualizar modificador
      throw ApiError.fromApiResponse(response.data, response.status ?? 500);
    }

    const validationResult = modifierApiSchema.safeParse(response.data);
    if (!validationResult.success) {
      // Datos inv√°lidos recibidos despu√©s de actualizar modificador
      throw new Error(
        `Received invalid data format after updating modifier ${id}.`,
      );
    }
    return validationResult.data;
  },

  /**
   * Elimina un modificador.
   */
  async remove(id: string): Promise<void> {
    const response = await apiClient.delete(
      API_PATHS.MODIFIERS_BY_ID.replace(':id', id),
    );

    if (!response.ok) {
      // Error al eliminar modificador
      throw ApiError.fromApiResponse(response.data, response.status ?? 500);
    }
  },
};

================
File: app/src/modules/orderFinalization/hooks/useOrderFinalizationQueries.ts
================
import { useQuery } from '@tanstack/react-query';
import { orderFinalizationService } from '../services/orderFinalizationService';

export const useOrdersForFinalizationList = () => {
  return useQuery({
    queryKey: ['orders', 'for-finalization-list'],
    queryFn: orderFinalizationService.getOrdersForFinalizationList,
    refetchInterval: 10000,
    refetchIntervalInBackground: false,
    refetchOnWindowFocus: true,
    refetchOnMount: true,
    staleTime: 5000,
    keepPreviousData: true,
    notifyOnChangeProps: ['data', 'error'],
  });
};

export const useOrderForFinalizationDetail = (orderId: string | null) => {
  return useQuery({
    queryKey: ['orders', 'for-finalization-detail', orderId],
    queryFn: () =>
      orderId
        ? orderFinalizationService.getOrderForFinalizationDetail(orderId)
        : null,
    enabled: !!orderId,
    staleTime: 30000,
  });
};

================
File: app/src/modules/orders/components/ChangeCalculatorModal.tsx
================
import React, { useState, useEffect, useMemo } from 'react';
import { View, StyleSheet, Pressable } from 'react-native';
import { Text, Button, TextInput } from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { ResponsiveModal } from '@/app/components/responsive/ResponsiveModal';

interface ChangeCalculatorModalProps {
  visible: boolean;
  onDismiss: () => void;
  onConfirm: () => void;
  amountToPay: number;
}

export const ChangeCalculatorModal: React.FC<ChangeCalculatorModalProps> = ({
  visible,
  onDismiss,
  onConfirm,
  amountToPay,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);

  const [receivedAmount, setReceivedAmount] = useState('');

  // Calcular cambio
  const changeAmount = useMemo(() => {
    const received = parseFloat(receivedAmount);
    if (isNaN(received)) return 0;
    return Math.max(0, received - amountToPay);
  }, [receivedAmount, amountToPay]);

  // Determinar qu√© botones de billetes mostrar
  const availableBills = useMemo(() => {
    const bills = [50, 100, 200, 500, 1000];
    // Filtrar billetes que sean mayores o iguales al monto a pagar
    const validBills = bills.filter((bill) => bill >= amountToPay);
    // Tomar m√°ximo 4 opciones para que quepan en una l√≠nea
    return validBills.slice(0, 4);
  }, [amountToPay]);

  // Resetear cuando se abre
  useEffect(() => {
    if (visible) {
      setReceivedAmount(amountToPay.toFixed(2));
    }
  }, [visible, amountToPay]);

  const handleConfirm = () => {
    const received = parseFloat(receivedAmount);
    if (!isNaN(received) && received >= amountToPay) {
      onConfirm();
    }
  };

  const footerActions = (
    <View style={styles.footer}>
      <Button
        mode="outlined"
        onPress={onDismiss}
        style={styles.cancelButton}
        labelStyle={styles.cancelButtonLabel}
        contentStyle={styles.footerButtonContent}
      >
        Cancelar
      </Button>
      <Button
        mode="contained"
        onPress={handleConfirm}
        disabled={
          !receivedAmount ||
          isNaN(parseFloat(receivedAmount)) ||
          parseFloat(receivedAmount) < amountToPay
        }
        style={styles.confirmButton}
        contentStyle={styles.footerButtonContent}
        labelStyle={styles.confirmButtonLabel}
      >
        Confirmar Pago
      </Button>
    </View>
  );

  return (
    <ResponsiveModal
      visible={visible}
      onDismiss={onDismiss}
      title="Calcular Cambio"
      widthTablet={480}
      maxWidthMobile="95%"
      scrollable={false}
      footer={footerActions}
    >
      <View style={styles.content}>
        {/* Inputs en l√≠nea */}
        <View style={styles.inputsRow}>
          {/* Total a pagar */}
          <View style={styles.inputContainer}>
            <Text style={styles.inputLabel}>Total a pagar</Text>
            <TextInput
              value={`$${amountToPay.toFixed(2)}`}
              editable={false}
              mode="flat"
              style={styles.totalInput}
              dense
              theme={{
                colors: {
                  primary: theme.colors.primary,
                  background: 'rgba(255, 255, 255, 0.05)',
                  text: theme.dark ? '#FFFFFF' : '#000000',
                },
              }}
            />
          </View>

          {/* Monto recibido */}
          <View style={styles.inputContainer}>
            <Text style={styles.inputLabel}>Monto recibido</Text>
            <TextInput
              value={receivedAmount}
              onChangeText={setReceivedAmount}
              keyboardType="decimal-pad"
              mode="flat"
              left={<TextInput.Affix text="$" />}
              style={styles.receivedInput}
              error={
                receivedAmount !== '' &&
                (isNaN(parseFloat(receivedAmount)) ||
                  parseFloat(receivedAmount) < amountToPay)
              }
              dense
              theme={{
                colors: {
                  primary: theme.colors.primary,
                  background: 'rgba(255, 255, 255, 0.05)',
                },
              }}
            />
          </View>
        </View>

        {/* Error message */}
        {receivedAmount !== '' &&
          (isNaN(parseFloat(receivedAmount)) ||
            parseFloat(receivedAmount) < amountToPay) && (
            <Text style={styles.errorText}>Monto insuficiente</Text>
          )}

        {/* Botones de billetes comunes */}
        {availableBills.length > 0 && (
          <View style={styles.quickAmountsRow}>
            {availableBills.map((bill) => (
              <Pressable
                key={bill}
                onPress={() => setReceivedAmount(`${bill}.00`)}
                style={({ pressed }) => [
                  styles.quickAmountButton,
                  pressed && styles.quickAmountButtonPressed,
                ]}
              >
                <Text style={styles.quickAmountButtonText}>
                  ${bill >= 1000 ? '1k' : bill}
                </Text>
              </Pressable>
            ))}
          </View>
        )}

        {/* Mostrar cambio */}
        {receivedAmount !== '' &&
          !isNaN(parseFloat(receivedAmount)) &&
          parseFloat(receivedAmount) >= amountToPay && (
            <View style={styles.changeSection}>
              <Text style={styles.changeLabel}>Cambio</Text>
              <Text style={styles.changeAmount}>
                ${changeAmount.toFixed(2)}
              </Text>
            </View>
          )}
      </View>
    </ResponsiveModal>
  );
};

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    content: {
      // Ya no necesita padding ya que ResponsiveModal lo maneja
    },
    inputsRow: {
      flexDirection: 'row',
      gap: 16,
      marginBottom: 20,
    },
    inputContainer: {
      flex: 1,
    },
    inputLabel: {
      ...theme.fonts.bodyMedium,
      color: theme.dark ? 'rgba(255, 255, 255, 0.7)' : 'rgba(0, 0, 0, 0.6)',
      marginBottom: 8,
      fontSize: 14,
    },
    totalInput: {
      backgroundColor: theme.dark
        ? 'rgba(255, 255, 255, 0.08)'
        : 'rgba(0, 0, 0, 0.04)',
      borderRadius: 12,
      fontSize: 20,
      height: 56,
      paddingHorizontal: 16,
      opacity: 0.8,
    },
    receivedInput: {
      backgroundColor: theme.dark
        ? 'rgba(255, 255, 255, 0.08)'
        : 'rgba(0, 0, 0, 0.04)',
      borderRadius: 12,
      fontSize: 20,
      height: 56,
      paddingHorizontal: 16,
    },
    quickAmountsRow: {
      flexDirection: 'row',
      gap: 12,
      marginTop: 16,
      justifyContent: 'center',
    },
    quickAmountButton: {
      backgroundColor: theme.dark
        ? 'rgba(255, 255, 255, 0.1)'
        : 'rgba(0, 0, 0, 0.05)',
      paddingHorizontal: 20,
      paddingVertical: 16,
      borderRadius: 12,
      flex: 1,
      alignItems: 'center',
      minHeight: 56,
      justifyContent: 'center',
    },
    quickAmountButtonPressed: {
      backgroundColor: theme.dark
        ? 'rgba(255, 255, 255, 0.2)'
        : 'rgba(0, 0, 0, 0.1)',
    },
    quickAmountButtonText: {
      ...theme.fonts.labelLarge,
      color: theme.dark ? '#FFFFFF' : '#000000',
      fontWeight: '700',
      fontSize: 18,
    },
    errorText: {
      ...theme.fonts.bodyMedium,
      color: '#FF4444',
      marginTop: 4,
      marginLeft: 4,
      fontSize: 14,
    },
    changeSection: {
      backgroundColor: theme.dark
        ? 'rgba(16, 185, 129, 0.1)'
        : 'rgba(16, 185, 129, 0.08)',
      padding: 20,
      borderRadius: 16,
      alignItems: 'center',
      marginTop: 16,
    },
    changeLabel: {
      ...theme.fonts.bodyLarge,
      color: theme.dark ? 'rgba(255, 255, 255, 0.7)' : 'rgba(0, 0, 0, 0.6)',
      marginBottom: 4,
      fontSize: 16,
    },
    changeAmount: {
      ...theme.fonts.headlineMedium,
      color: '#10B981',
      fontWeight: '700',
      letterSpacing: -0.5,
      fontSize: 32,
    },
    footer: {
      flexDirection: 'row',
      gap: 16,
      // ResponsiveModal maneja padding, border y background
    },
    cancelButton: {
      flex: 1,
      borderColor: theme.colors.error,
      backgroundColor: theme.colors.errorContainer,
    },
    cancelButtonLabel: {
      fontSize: 16,
      fontWeight: '700',
      color: theme.colors.onErrorContainer,
    },
    confirmButton: {
      flex: 2,
      backgroundColor: '#10B981',
    },
    confirmButtonLabel: {
      fontSize: 16,
      fontWeight: '700',
      color: '#FFFFFF',
    },
    footerButtonContent: {
      height: 48,
    },
  });

export default ChangeCalculatorModal;

================
File: app/src/modules/orders/components/CloseShiftModal.tsx
================
import React, { useState } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  TextInput,
  HelperText,
  Surface,
  Divider,
  Card,
} from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useAppTheme } from '@/app/styles/theme';
import { shiftsService, type Shift } from '@/services/shifts';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import SpeechRecognitionInput from '@/app/components/common/SpeechRecognitionInput';

interface CloseShiftModalProps {
  visible: boolean;
  onDismiss: () => void;
  onShiftClosed: () => void;
  shift: Shift | null;
}

export const CloseShiftModal: React.FC<CloseShiftModalProps> = ({
  visible,
  onDismiss,
  onShiftClosed,
  shift,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const [finalCash, setFinalCash] = useState('');
  const [closeNotes, setCloseNotes] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');

  const handleFinalCashChange = (text: string) => {
    // Permitir solo n√∫meros y un punto decimal
    const cleaned = text.replace(/[^0-9.]/g, '');

    // Prevenir m√∫ltiples puntos decimales
    const parts = cleaned.split('.');
    if (parts.length > 2) return;

    // Limitar a 2 decimales
    if (parts[1] && parts[1].length > 2) {
      setFinalCash(parts[0] + '.' + parts[1].substring(0, 2));
    } else {
      setFinalCash(cleaned);
    }
  };

  const handleCloseShift = async () => {
    if (!finalCash) {
      setError('El efectivo final es requerido');
      return;
    }

    const cashAmount = parseFloat(finalCash);
    if (isNaN(cashAmount) || cashAmount < 0) {
      setError('Ingresa un monto v√°lido');
      return;
    }

    setLoading(true);
    setError('');

    try {
      await shiftsService.closeShift({
        finalCash: cashAmount,
        closeNotes: closeNotes || undefined,
      });

      showSnackbar({ message: 'Turno cerrado exitosamente', type: 'success' });
      setFinalCash('');
      setCloseNotes('');
      onShiftClosed();
      onDismiss();
    } catch (error: any) {
      let errorMessage = 'Error al cerrar el turno';

      if (error?.message) {
        errorMessage = error.message;
      } else if (typeof error === 'string') {
        errorMessage = error;
      }

      setError(errorMessage);
      showSnackbar({ message: errorMessage, type: 'error' });
    } finally {
      setLoading(false);
    }
  };

  const handleDismiss = () => {
    if (!loading) {
      setFinalCash('');
      setCloseNotes('');
      setError('');
      onDismiss();
    }
  };

  const formatCurrency = (amount: number) => {
    return new Intl.NumberFormat('es-MX', {
      style: 'currency',
      currency: 'MXN',
    }).format(amount);
  };

  const formatTime = (dateString: string) => {
    return format(new Date(dateString), 'HH:mm', { locale: es });
  };

  const calculateDifference = () => {
    if (!finalCash || !shift?.expectedCash) return null;
    const cash = parseFloat(finalCash);
    if (isNaN(cash)) return null;
    return cash - shift.expectedCash;
  };

  const difference = calculateDifference();
  const today = new Date();
  const todayFormatted = format(today, "EEEE, d 'de' MMMM 'de' yyyy", {
    locale: es,
  });

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={handleDismiss}
        contentContainerStyle={styles.modalContainer}
        dismissable={!loading}
      >
        <KeyboardAvoidingView
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={{ flex: 1 }}
        >
          <ScrollView
            contentContainerStyle={styles.scrollViewContent}
            keyboardShouldPersistTaps="handled"
            showsVerticalScrollIndicator={false}
          >
            <Surface style={styles.modal} elevation={3}>
              {/* Header */}
              <View style={styles.header}>
                <View style={styles.iconContainer}>
                  <MaterialCommunityIcons
                    name="store-off"
                    size={48}
                    color="#FF5722"
                  />
                </View>
                <Text variant="headlineMedium" style={styles.title}>
                  Cierre de Turno
                </Text>
                <Text variant="bodyLarge" style={styles.date}>
                  {todayFormatted}
                </Text>
              </View>

              <Divider style={styles.divider} />

              {/* Resumen del turno */}
              {shift && (
                <View style={styles.content}>
                  <Card style={styles.summaryCard}>
                    <Card.Content>
                      <Text variant="titleMedium" style={styles.sectionTitle}>
                        Resumen del Turno #{shift.globalShiftNumber}
                      </Text>

                      <View style={styles.summaryRow}>
                        <Text variant="bodyMedium" style={styles.label}>
                          Abierto a las:
                        </Text>
                        <Text variant="bodyMedium" style={styles.value}>
                          {formatTime(shift.openedAt)}
                        </Text>
                      </View>

                      <View style={styles.summaryRow}>
                        <Text variant="bodyMedium" style={styles.label}>
                          Efectivo inicial:
                        </Text>
                        <Text variant="bodyMedium" style={styles.value}>
                          {formatCurrency(shift.initialCash)}
                        </Text>
                      </View>

                      {shift.totalSales !== null && (
                        <View style={styles.summaryRow}>
                          <Text variant="bodyMedium" style={styles.label}>
                            Ventas del turno:
                          </Text>
                          <Text
                            variant="bodyMedium"
                            style={[styles.value, styles.highlight]}
                          >
                            {formatCurrency(shift.totalSales)}
                          </Text>
                        </View>
                      )}

                      {shift.expectedCash !== null && (
                        <View style={styles.summaryRow}>
                          <Text variant="bodyMedium" style={styles.label}>
                            Efectivo esperado:
                          </Text>
                          <Text
                            variant="bodyMedium"
                            style={[styles.value, styles.highlight]}
                          >
                            {formatCurrency(shift.expectedCash)}
                          </Text>
                        </View>
                      )}
                    </Card.Content>
                  </Card>

                  {/* Formulario de cierre */}
                  <View style={styles.inputSection}>
                    <Text variant="titleMedium" style={styles.sectionTitle}>
                      Informaci√≥n de Cierre
                    </Text>

                    <TextInput
                      label="Efectivo final en caja"
                      value={finalCash}
                      onChangeText={handleFinalCashChange}
                      keyboardType="decimal-pad"
                      mode="outlined"
                      left={<TextInput.Affix text="$" />}
                      style={styles.input}
                      disabled={loading}
                      error={!!error}
                      placeholder="0.00"
                      outlineColor={
                        error ? theme.colors.error : theme.colors.outline
                      }
                      activeOutlineColor={
                        error ? theme.colors.error : theme.colors.primary
                      }
                    />

                    {difference !== null && (
                      <View
                        style={[
                          styles.differenceContainer,
                          difference < 0
                            ? styles.negativeDifference
                            : styles.positiveDifference,
                        ]}
                      >
                        <MaterialCommunityIcons
                          name={
                            difference >= 0 ? 'trending-up' : 'trending-down'
                          }
                          size={20}
                          color={difference >= 0 ? '#4CAF50' : '#FF5722'}
                        />
                        <Text
                          style={[
                            styles.differenceText,
                            { color: difference >= 0 ? '#4CAF50' : '#FF5722' },
                          ]}
                        >
                          {difference >= 0 ? 'Sobrante: ' : 'Faltante: '}
                          {formatCurrency(Math.abs(difference))}
                        </Text>
                      </View>
                    )}

                    <HelperText
                      type="error"
                      visible={!!error}
                      style={styles.errorText}
                    >
                      {error}
                    </HelperText>

                    <SpeechRecognitionInput
                      key="close-notes-input"
                      label="Notas de cierre (opcional)"
                      value={closeNotes}
                      onChangeText={setCloseNotes}
                      multiline
                      speechLang="es-MX"
                      placeholder="Ej: Observaciones del turno, incidencias..."
                      autoCapitalize="sentences"
                      autoCorrect={false}
                      disabled={loading}
                    />
                  </View>
                </View>
              )}

              {/* Footer */}
              <View style={styles.footer}>
                <Button
                  mode="text"
                  onPress={handleDismiss}
                  style={[styles.button, styles.cancelButton]}
                  labelStyle={styles.cancelButtonText}
                  disabled={loading}
                >
                  Cancelar
                </Button>
                <Button
                  mode="contained"
                  onPress={handleCloseShift}
                  style={[styles.button, styles.confirmButton]}
                  contentStyle={styles.confirmButtonContent}
                  labelStyle={styles.confirmButtonText}
                  loading={loading}
                  disabled={loading}
                  icon="stop-circle"
                >
                  Cerrar Turno
                </Button>
              </View>
            </Surface>
          </ScrollView>
        </KeyboardAvoidingView>
      </Modal>
    </Portal>
  );
};

const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    modalContainer: {
      flex: 1,
    },
    scrollViewContent: {
      flexGrow: 1,
      justifyContent: 'center',
      paddingVertical: theme.spacing.xl,
      paddingHorizontal: theme.spacing.m,
    },
    modal: {
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness * 3,
      borderWidth: 2,
      borderColor: theme.colors.outline,
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 8,
      },
      shadowOpacity: 0.25,
      shadowRadius: 16,
      elevation: 8,
    },
    header: {
      alignItems: 'center',
      paddingTop: theme.spacing.xl,
      paddingHorizontal: theme.spacing.l,
      paddingBottom: theme.spacing.l,
      borderTopLeftRadius: theme.roundness * 3,
      borderTopRightRadius: theme.roundness * 3,
      backgroundColor: theme.colors.surfaceVariant,
    },
    iconContainer: {
      width: 90,
      height: 90,
      borderRadius: 45,
      backgroundColor: theme.colors.surface,
      justifyContent: 'center',
      alignItems: 'center',
      marginBottom: theme.spacing.m,
      borderWidth: 3,
      borderColor: '#FF5722',
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 4,
      },
      shadowOpacity: 0.15,
      shadowRadius: 8,
      elevation: 4,
    },
    title: {
      color: theme.colors.onSurfaceVariant,
      fontWeight: '700',
      textAlign: 'center',
      marginBottom: theme.spacing.xs,
    },
    date: {
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
      textTransform: 'capitalize',
    },
    divider: {
      backgroundColor: theme.colors.outlineVariant,
      height: 1,
    },
    content: {
      padding: theme.spacing.l,
    },
    summaryCard: {
      backgroundColor: theme.colors.surfaceVariant,
      borderWidth: 1,
      borderColor: theme.colors.outline,
      borderRadius: theme.roundness * 2,
      marginBottom: theme.spacing.l,
    },
    sectionTitle: {
      color: theme.colors.onSurface,
      fontWeight: '600',
      marginBottom: theme.spacing.m,
    },
    summaryRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.s,
    },
    label: {
      color: theme.colors.onSurfaceVariant,
      flex: 1,
    },
    value: {
      color: theme.colors.onSurface,
      fontWeight: '500',
      textAlign: 'right',
    },
    highlight: {
      color: theme.colors.primary,
      fontWeight: '600',
    },
    inputSection: {
      marginTop: theme.spacing.s,
    },
    input: {
      backgroundColor: theme.colors.surface,
      marginBottom: theme.spacing.s,
    },
    differenceContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      padding: theme.spacing.m,
      borderRadius: theme.roundness,
      marginBottom: theme.spacing.s,
      gap: theme.spacing.s,
    },
    positiveDifference: {
      backgroundColor: 'rgba(76, 175, 80, 0.1)',
      borderWidth: 1,
      borderColor: '#4CAF50',
    },
    negativeDifference: {
      backgroundColor: 'rgba(255, 87, 34, 0.1)',
      borderWidth: 1,
      borderColor: '#FF5722',
    },
    differenceText: {
      fontWeight: '600',
    },
    errorText: {
      marginTop: -theme.spacing.xs,
      marginBottom: theme.spacing.s,
    },
    footer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      padding: theme.spacing.l,
      paddingTop: theme.spacing.s,
      gap: theme.spacing.m,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
      borderBottomLeftRadius: theme.roundness * 3,
      borderBottomRightRadius: theme.roundness * 3,
    },
    button: {
      flex: 1,
    },
    cancelButton: {
      borderWidth: 2,
      borderColor: theme.colors.outline,
      borderRadius: theme.roundness * 2,
    },
    cancelButtonText: {
      color: theme.colors.onSurface,
      fontWeight: '600',
    },
    confirmButton: {
      backgroundColor: '#FF5722',
      borderWidth: 2,
      borderColor: '#FF5722',
      borderRadius: theme.roundness * 2,
    },
    confirmButtonContent: {
      paddingVertical: theme.spacing.xs,
    },
    confirmButtonText: {
      color: '#FFFFFF',
      fontWeight: '600',
    },
  });

================
File: app/src/modules/orders/components/OpenShiftModal.tsx
================
import React, { useState } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  TextInput as _RNTextInput,
  Platform,
  KeyboardAvoidingView,
} from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  TextInput,
  HelperText,
  Surface,
  Divider,
} from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useAppTheme } from '@/app/styles/theme';
import { shiftsService } from '@/services/shifts';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import SpeechRecognitionInput from '@/app/components/common/SpeechRecognitionInput';

interface OpenShiftModalProps {
  visible: boolean;
  onDismiss: () => void;
  onShiftOpened: () => void;
}

export const OpenShiftModal: React.FC<OpenShiftModalProps> = ({
  visible,
  onDismiss,
  onShiftOpened,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const [initialCash, setInitialCash] = useState('');
  const [notes, setNotes] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');

  const handleInitialCashChange = (text: string) => {
    // Permitir solo n√∫meros y un punto decimal
    const cleaned = text.replace(/[^0-9.]/g, '');

    // Prevenir m√∫ltiples puntos decimales
    const parts = cleaned.split('.');
    if (parts.length > 2) return;

    // Limitar a 2 decimales
    if (parts[1] && parts[1].length > 2) {
      setInitialCash(parts[0] + '.' + parts[1].substring(0, 2));
    } else {
      setInitialCash(cleaned);
    }
  };

  const handleOpenShift = async () => {
    if (!initialCash) {
      setError('El monto inicial es requerido');
      return;
    }

    const cashAmount = parseFloat(initialCash);
    if (isNaN(cashAmount) || cashAmount < 0) {
      setError('Ingresa un monto v√°lido');
      return;
    }

    setLoading(true);
    setError('');

    try {
      await shiftsService.openShift({
        initialCash: cashAmount,
        notes: notes || undefined,
      });

      showSnackbar({ message: 'Turno abierto exitosamente', type: 'success' });
      setInitialCash('');
      setNotes('');
      onShiftOpened();
      onDismiss();
    } catch (error: any) {
      const errorMessage =
        error.response?.data?.message || 'Error al abrir el turno';
      setError(errorMessage);
      showSnackbar({ message: errorMessage, type: 'error' });
    } finally {
      setLoading(false);
    }
  };

  const handleDismiss = () => {
    if (!loading) {
      setInitialCash('');
      setNotes('');
      setError('');
      onDismiss();
    }
  };

  const today = new Date();
  const todayFormatted = format(today, "EEEE, d 'de' MMMM 'de' yyyy", {
    locale: es,
  });

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={handleDismiss}
        contentContainerStyle={styles.modalContainer}
        dismissable={!loading}
      >
        <KeyboardAvoidingView
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={{ flex: 1 }}
        >
          <ScrollView
            contentContainerStyle={styles.scrollViewContent}
            keyboardShouldPersistTaps="handled"
            showsVerticalScrollIndicator={false}
          >
            <Surface style={styles.modal} elevation={3}>
              {/* Header */}
              <View style={styles.header}>
                <View style={styles.iconContainer}>
                  <MaterialCommunityIcons
                    name="store-check"
                    size={48}
                    color={theme.colors.primary}
                  />
                </View>
                <Text variant="headlineMedium" style={styles.title}>
                  Apertura de Turno
                </Text>
                <Text variant="bodyLarge" style={styles.date}>
                  {todayFormatted}
                </Text>
              </View>

              <Divider style={styles.divider} />

              {/* Content */}
              <View style={styles.content}>
                <View style={styles.infoCard}>
                  <MaterialCommunityIcons
                    name="information"
                    size={20}
                    color={theme.colors.primary}
                  />
                  <Text variant="bodyMedium" style={styles.infoText}>
                    Registra el monto inicial para comenzar las operaciones del
                    turno.
                  </Text>
                </View>

                <View style={styles.inputSection}>
                  <Text variant="titleMedium" style={styles.sectionTitle}>
                    Informaci√≥n de Apertura
                  </Text>

                  <TextInput
                    label="Monto inicial en caja"
                    value={initialCash}
                    onChangeText={handleInitialCashChange}
                    keyboardType="decimal-pad"
                    mode="outlined"
                    left={<TextInput.Affix text="$" />}
                    style={styles.input}
                    disabled={loading}
                    error={!!error}
                    placeholder="0.00"
                    outlineColor={
                      error ? theme.colors.error : theme.colors.outline
                    }
                    activeOutlineColor={
                      error ? theme.colors.error : theme.colors.primary
                    }
                  />

                  <HelperText
                    type="error"
                    visible={!!error}
                    style={styles.errorText}
                  >
                    {error}
                  </HelperText>

                  <SpeechRecognitionInput
                    key="notes-input-shift"
                    label="Notas adicionales (opcional)"
                    value={notes}
                    onChangeText={setNotes}
                    multiline
                    speechLang="es-MX"
                    placeholder="Ej: Estado de la caja, observaciones..."
                    autoCapitalize="sentences"
                    autoCorrect={false}
                    disabled={loading}
                  />
                </View>
              </View>

              {/* Footer */}
              <View style={styles.footer}>
                <Button
                  mode="text"
                  onPress={handleDismiss}
                  style={[styles.button, styles.cancelButton]}
                  labelStyle={styles.cancelButtonText}
                  disabled={loading}
                >
                  Cancelar
                </Button>
                <Button
                  mode="contained"
                  onPress={handleOpenShift}
                  style={[styles.button, styles.confirmButton]}
                  contentStyle={styles.confirmButtonContent}
                  labelStyle={styles.confirmButtonText}
                  loading={loading}
                  disabled={loading}
                  icon="play-circle"
                >
                  Abrir Turno
                </Button>
              </View>
            </Surface>
          </ScrollView>
        </KeyboardAvoidingView>
      </Modal>
    </Portal>
  );
};

const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    modalContainer: {
      flex: 1,
    },
    scrollViewContent: {
      flexGrow: 1,
      justifyContent: 'center',
      paddingVertical: theme.spacing.xl,
    },
    modal: {
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness * 2,
      marginHorizontal: theme.spacing.m,
    },
    header: {
      alignItems: 'center',
      paddingTop: theme.spacing.xl,
      paddingHorizontal: theme.spacing.l,
      paddingBottom: theme.spacing.l,
    },
    iconContainer: {
      width: 80,
      height: 80,
      borderRadius: 40,
      backgroundColor: theme.colors.primaryContainer,
      justifyContent: 'center',
      alignItems: 'center',
      marginBottom: theme.spacing.m,
    },
    title: {
      color: theme.colors.onSurface,
      fontWeight: '700',
      textAlign: 'center',
      marginBottom: theme.spacing.xs,
    },
    date: {
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
      textTransform: 'capitalize',
    },
    divider: {
      backgroundColor: theme.colors.outlineVariant,
      height: 1,
    },
    content: {
      padding: theme.spacing.l,
    },
    infoCard: {
      flexDirection: 'row',
      backgroundColor: theme.colors.primaryContainer,
      padding: theme.spacing.m,
      borderRadius: theme.roundness,
      marginBottom: theme.spacing.l,
      gap: theme.spacing.s,
    },
    infoText: {
      flex: 1,
      color: theme.colors.onPrimaryContainer,
      lineHeight: 20,
    },
    inputSection: {
      marginTop: theme.spacing.s,
    },
    sectionTitle: {
      color: theme.colors.onSurface,
      fontWeight: '600',
      marginBottom: theme.spacing.m,
    },
    input: {
      backgroundColor: theme.colors.surface,
    },
    errorText: {
      marginTop: -theme.spacing.xs,
      marginBottom: theme.spacing.s,
    },
    footer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      padding: theme.spacing.l,
      paddingTop: theme.spacing.s,
      gap: theme.spacing.m,
    },
    button: {
      flex: 1,
    },
    cancelButton: {
      borderColor: theme.colors.outline,
      borderWidth: 1,
    },
    cancelButtonText: {
      color: theme.colors.onSurfaceVariant,
    },
    confirmButton: {
      backgroundColor: theme.colors.primary,
      elevation: 0,
    },
    confirmButtonContent: {
      paddingVertical: theme.spacing.xs,
    },
    confirmButtonText: {
      color: theme.colors.onPrimary,
      fontWeight: '600',
    },
  });

================
File: app/src/modules/orders/components/ShiftStatusBanner.tsx
================
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, Button, ActivityIndicator, Card } from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useAppTheme } from '@/app/styles/theme';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import type { Shift } from '@/services/shifts';

interface ShiftStatusBannerProps {
  shift: Shift | null;
  loading: boolean;
  onOpenShift: () => void;
  canOpenShift: boolean;
}

export const ShiftStatusBanner: React.FC<ShiftStatusBannerProps> = ({
  shift,
  loading,
  onOpenShift,
  canOpenShift,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="small" />
      </View>
    );
  }

  if (!shift || shift.status !== 'OPEN') {
    return (
      <Card style={styles.statusCard} mode="elevated">
        <Card.Content style={styles.closedShiftContent}>
          <View style={styles.iconContainer}>
            <MaterialCommunityIcons
              name="store-clock"
              size={64}
              color={theme.colors.primary}
            />
          </View>

          <Text variant="headlineSmall" style={styles.closedTitle}>
            {canOpenShift ? '¬°Bienvenido!' : 'Turno Cerrado'}
          </Text>

          <Text variant="bodyLarge" style={styles.closedDescription}>
            {canOpenShift
              ? 'Para comenzar a operar, necesitas abrir el turno.'
              : 'El restaurante a√∫n no ha abierto operaciones.'}
          </Text>

          {canOpenShift && (
            <View style={styles.adminInfo}>
              <MaterialCommunityIcons
                name="shield-crown"
                size={20}
                color={theme.colors.primary}
              />
              <Text variant="labelMedium" style={styles.adminText}>
                Como administrador, puedes iniciar las operaciones del turno
              </Text>
            </View>
          )}

          {canOpenShift && (
            <Button
              mode="contained"
              onPress={onOpenShift}
              style={styles.openShiftButton}
              icon="play-circle"
              contentStyle={styles.openShiftButtonContent}
            >
              Abrir Turno
            </Button>
          )}

          {!canOpenShift && (
            <View style={styles.contactInfo}>
              <MaterialCommunityIcons
                name="information"
                size={20}
                color={theme.colors.onSurfaceVariant}
              />
              <Text variant="bodyMedium" style={styles.contactText}>
                Contacta a tu administrador o gerente para iniciar operaciones
              </Text>
            </View>
          )}
        </Card.Content>
      </Card>
    );
  }

  return (
    <Card style={styles.openStatusCard} mode="elevated">
      <Card.Content>
        <View style={styles.statusHeader}>
          <View style={styles.openIconContainer}>
            <MaterialCommunityIcons
              name="store-check"
              size={28}
              color={theme.colors.primary}
            />
          </View>
          <View style={styles.statusHeaderText}>
            <Text variant="titleMedium" style={styles.statusTitle}>
              Turno Activo
            </Text>
            <Text variant="labelMedium" style={styles.statusSubtitle}>
              {format(new Date(shift.date), "EEEE, d 'de' MMMM", {
                locale: es,
              })}
            </Text>
          </View>
        </View>

        <View style={styles.statusInfoGrid}>
          <View style={styles.infoCard}>
            <MaterialCommunityIcons
              name="counter"
              size={20}
              color={theme.colors.primary}
            />
            <Text variant="labelSmall" style={styles.infoCardLabel}>
              Turno Global
            </Text>
            <Text variant="titleMedium" style={styles.infoCardValue}>
              #{shift.globalShiftNumber}
            </Text>
          </View>

          <View style={styles.infoCard}>
            <MaterialCommunityIcons
              name="calendar-today"
              size={20}
              color={theme.colors.primary}
            />
            <Text variant="labelSmall" style={styles.infoCardLabel}>
              Turno de Hoy
            </Text>
            <Text variant="titleMedium" style={styles.infoCardValue}>
              #{shift.shiftNumber}
            </Text>
          </View>

          <View style={styles.infoCard}>
            <MaterialCommunityIcons
              name="account-clock"
              size={20}
              color={theme.colors.primary}
            />
            <Text variant="labelSmall" style={styles.infoCardLabel}>
              Abierto desde
            </Text>
            <Text variant="titleMedium" style={styles.infoCardValue}>
              {format(new Date(shift.openedAt), 'HH:mm', {
                locale: es,
              })}
            </Text>
          </View>
        </View>

        <View style={styles.openedByInfo}>
          <MaterialCommunityIcons
            name="account-circle"
            size={16}
            color={theme.colors.onSurfaceVariant}
          />
          <Text variant="bodySmall" style={styles.openedByText}>
            Abierto por {shift.openedBy.firstName} {shift.openedBy.lastName}
          </Text>
        </View>
      </Card.Content>
    </Card>
  );
};

const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    loadingContainer: {
      padding: theme.spacing.m,
      alignItems: 'center',
    },
    statusCard: {
      margin: theme.spacing.m,
      marginBottom: theme.spacing.l,
      backgroundColor: theme.colors.surface,
      elevation: 4,
    },
    closedShiftContent: {
      alignItems: 'center',
      paddingVertical: theme.spacing.xl,
      paddingHorizontal: theme.spacing.l,
    },
    iconContainer: {
      marginBottom: theme.spacing.l,
      padding: theme.spacing.m,
      borderRadius: 100,
      backgroundColor: theme.colors.primaryContainer,
    },
    closedTitle: {
      color: theme.colors.onSurface,
      fontWeight: '700',
      marginBottom: theme.spacing.s,
      textAlign: 'center',
    },
    closedDescription: {
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
      marginBottom: theme.spacing.l,
      paddingHorizontal: theme.spacing.m,
    },
    adminInfo: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
      backgroundColor: theme.colors.primaryContainer,
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.s,
      borderRadius: theme.roundness * 2,
      marginBottom: theme.spacing.l,
    },
    adminText: {
      color: theme.colors.onPrimaryContainer,
      fontWeight: '500',
    },
    openShiftButton: {
      marginTop: theme.spacing.m,
      paddingHorizontal: theme.spacing.l,
    },
    openShiftButtonContent: {
      paddingVertical: theme.spacing.s,
    },
    contactInfo: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
      backgroundColor: theme.colors.surfaceVariant,
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.s,
      borderRadius: theme.roundness,
      marginTop: theme.spacing.m,
    },
    contactText: {
      color: theme.colors.onSurfaceVariant,
      flex: 1,
    },
    openStatusCard: {
      margin: theme.spacing.m,
      marginBottom: theme.spacing.l,
      backgroundColor: theme.colors.surface,
      elevation: 2,
    },
    statusHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.m,
      marginBottom: theme.spacing.l,
    },
    openIconContainer: {
      padding: theme.spacing.s,
      borderRadius: 50,
      backgroundColor: theme.colors.primaryContainer,
    },
    statusHeaderText: {
      flex: 1,
    },
    statusTitle: {
      color: theme.colors.onSurface,
      fontWeight: '600',
    },
    statusSubtitle: {
      color: theme.colors.onSurfaceVariant,
      textTransform: 'capitalize',
    },
    statusInfoGrid: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      gap: theme.spacing.s,
      marginBottom: theme.spacing.m,
    },
    infoCard: {
      flex: 1,
      backgroundColor: theme.colors.surfaceVariant,
      padding: theme.spacing.m,
      borderRadius: theme.roundness,
      alignItems: 'center',
      gap: theme.spacing.xs,
    },
    infoCardLabel: {
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
    },
    infoCardValue: {
      color: theme.colors.primary,
      fontWeight: '700',
      textAlign: 'center',
    },
    openedByInfo: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
      paddingTop: theme.spacing.s,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
    },
    openedByText: {
      color: theme.colors.onSurfaceVariant,
    },
  });

================
File: app/src/modules/orders/screens/AddProductsToOrderScreen.tsx
================
import React, {
  useState,
  useMemo,
  useRef,
  useCallback,
  useEffect,
} from 'react';
import { StyleSheet, View, FlatList } from 'react-native';
import {
  Text,
  Portal,
  ActivityIndicator,
  Card,
  Title,
  Appbar,
  IconButton,
} from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useNavigation, useRoute } from '@react-navigation/native';
import { useGetOrderMenu } from '../hooks/useMenuQueries';
import { Product, Category, SubCategory } from '../types/orders.types';
import { AutoImage } from '@/app/components/common/AutoImage';
import ProductCustomizationModal from '../components/ProductCustomizationModal';
import SimpleProductDescriptionModal from '../components/SimpleProductDescriptionModal';
import CartButton from '../components/CartButton';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import type { OrdersStackScreenProps } from '@/app/navigation/types';
import { CartItem, CartItemModifier } from '../context/CartContext';
import type { SelectedPizzaCustomization } from '@/app/schemas/domain/order.schema';

// Props de navegaci√≥n
type AddProductsRouteProps = {
  orderId: string;
  orderNumber: number;
  existingOrderItemsCount?: number; // N√∫mero de items que ya est√°n en la orden
  existingTempProducts?: CartItem[]; // Productos temporales existentes
  onProductsAdded?: (products: CartItem[]) => void;
};

interface CartButtonHandle {
  animate: () => void;
}

const AddProductsToOrderScreen = () => {
  const theme = useAppTheme();
  const { colors, fonts } = theme;
  const responsive = useResponsive();
  const navigation = useNavigation();
  const route =
    useRoute<OrdersStackScreenProps<'AddProductsToOrder'>['route']>();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const cartButtonRef = useRef<CartButtonHandle>(null);

  // Obtener par√°metros de navegaci√≥n
  const {
    orderId: _orderId,
    orderNumber,
    existingTempProducts,
    existingOrderItemsCount,
    onProductsAdded,
  } = route.params as AddProductsRouteProps;

  // Estados para navegaci√≥n y selecci√≥n
  const [navigationLevel, setNavigationLevel] = useState<
    'categories' | 'subcategories' | 'products'
  >('categories');
  const [selectedCategoryId, setSelectedCategoryId] = useState<string | null>(
    null,
  );
  const [selectedSubcategoryId, setSelectedSubcategoryId] = useState<
    string | null
  >(null);
  const [selectedProduct, setSelectedProduct] = useState<Product | null>(null);
  const [editingItem, setEditingItem] = useState<CartItem | null>(null);
  const [selectedProductForDescription, setSelectedProductForDescription] =
    useState<Product | null>(null);
  const [isDescriptionModalVisible, setIsDescriptionModalVisible] =
    useState(false);

  // Estado local para productos seleccionados - inicializar con productos existentes si los hay
  const [selectedProducts, setSelectedProducts] = useState<CartItem[]>(
    existingTempProducts || [],
  );

  const { data: menu, isLoading } = useGetOrderMenu();

  // Calcular total de items (incluir items existentes de la orden)
  const totalItemsCount = useMemo(() => {
    const newItemsCount = selectedProducts.reduce(
      (sum, item) => sum + item.quantity,
      0,
    );
    const existingItemsCount = existingOrderItemsCount || 0;
    return newItemsCount + existingItemsCount;
  }, [selectedProducts, existingOrderItemsCount]);

  // Mostrar mensaje si hay productos existentes al entrar
  useEffect(() => {
    if (existingTempProducts && existingTempProducts.length > 0) {
      const totalItems = existingTempProducts.reduce(
        (sum, item) => sum + item.quantity,
        0,
      );
      showSnackbar({
        message: `${totalItems} producto${totalItems > 1 ? 's' : ''} recuperado${totalItems > 1 ? 's' : ''}`,
        type: 'info',
      });
    }
  }, []);

  const handleCategorySelect = useCallback((categoryId: string) => {
    setSelectedCategoryId(categoryId);
    setSelectedSubcategoryId(null);
    setNavigationLevel('subcategories');
  }, []);

  const handleSubCategorySelect = useCallback((subcategoryId: string) => {
    setSelectedSubcategoryId(subcategoryId);
    setNavigationLevel('products');
  }, []);

  const productNeedsCustomization = useCallback((product: Product): boolean => {
    if (!product) return false;
    const hasVariants =
      product.hasVariants &&
      product.variants &&
      Array.isArray(product.variants) &&
      product.variants.length > 0;
    const hasModifiers =
      product.modifierGroups &&
      Array.isArray(product.modifierGroups) &&
      product.modifierGroups.length > 0;
    return hasVariants || hasModifiers;
  }, []);

  const handleProductSelect = useCallback(
    (product: Product) => {
      if (productNeedsCustomization(product)) {
        setSelectedProduct(product);
      } else {
        // A√±adir producto directamente sin personalizaci√≥n
        addItemToSelection(product, 1);
      }
    },
    [productNeedsCustomization, addItemToSelection],
  );

  const addItemToSelection = (
    product: Product,
    quantity: number,
    selectedVariantId?: string,
    selectedModifiers?: CartItemModifier[],
    preparationNotes?: string,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost?: number,
  ) => {
    const selectedVariant = product.variants?.find(
      (v) => v.id === selectedVariantId,
    );
    const variantPrice = selectedVariant?.price || product.price;
    const modifiersPrice =
      selectedModifiers?.reduce((sum, mod) => sum + (mod.price || 0), 0) || 0;
    const pizzaCost = pizzaExtraCost || 0;
    const unitPrice = variantPrice + modifiersPrice + pizzaCost;

    // Buscar si ya existe un item id√©ntico en la selecci√≥n actual
    const existingIndex = selectedProducts.findIndex((item) => {
      // Verificar si es el mismo producto, variante, modificadores y notas
      if (item.productId !== product.id) return false;
      if (item.variantId !== selectedVariantId) return false;
      if (item.preparationNotes !== preparationNotes) return false;

      // Comparar modificadores
      const itemModifierIds = item.modifiers
        .map((m) => m.id)
        .sort()
        .join(',');
      const newModifierIds = (selectedModifiers || [])
        .map((m) => m.id)
        .sort()
        .join(',');

      if (itemModifierIds !== newModifierIds) return false;

      // Comparar pizza customizations
      const existingCustomizations = item.selectedPizzaCustomizations || [];
      const newCustomizations = selectedPizzaCustomizations || [];

      if (existingCustomizations.length !== newCustomizations.length)
        return false;

      const sortedExistingCustomizations = [...existingCustomizations].sort(
        (a, b) =>
          `${a.pizzaCustomizationId}-${a.half}-${a.action}`.localeCompare(
            `${b.pizzaCustomizationId}-${b.half}-${b.action}`,
          ),
      );
      const sortedNewCustomizations = [...newCustomizations].sort((a, b) =>
        `${a.pizzaCustomizationId}-${a.half}-${a.action}`.localeCompare(
          `${b.pizzaCustomizationId}-${b.half}-${b.action}`,
        ),
      );

      for (let i = 0; i < sortedExistingCustomizations.length; i++) {
        if (
          sortedExistingCustomizations[i].pizzaCustomizationId !==
            sortedNewCustomizations[i].pizzaCustomizationId ||
          sortedExistingCustomizations[i].half !==
            sortedNewCustomizations[i].half ||
          sortedExistingCustomizations[i].action !==
            sortedNewCustomizations[i].action
        ) {
          return false;
        }
      }

      return true;
    });

    if (existingIndex !== -1) {
      // Si existe, actualizar la cantidad
      setSelectedProducts((prev) => {
        const updated = [...prev];
        const existingItem = updated[existingIndex];
        const newQuantity = existingItem.quantity + quantity;

        // Recalcular el precio total correctamente
        const modifiersTotal = existingItem.modifiers.reduce(
          (sum, mod) => sum + Number(mod.price || 0),
          0,
        );
        const pizzaCostTotal = existingItem.pizzaExtraCost || 0;
        const unitPriceWithModifiers =
          Number(existingItem.unitPrice || 0) + modifiersTotal + pizzaCostTotal;

        updated[existingIndex] = {
          ...existingItem,
          quantity: newQuantity,
          totalPrice: unitPriceWithModifiers * newQuantity,
        };
        return updated;
      });
    } else {
      // Si no existe, agregar nuevo item
      const newItem: CartItem = {
        id: `temp-${Date.now()}-${Math.floor(Math.random() * 1000000)}`,
        productId: product.id,
        productName: product.name,
        quantity,
        unitPrice: variantPrice,
        totalPrice: unitPrice * quantity,
        modifiers: selectedModifiers || [],
        variantId: selectedVariantId,
        variantName: selectedVariant?.name,
        preparationNotes,
        selectedPizzaCustomizations,
        pizzaExtraCost,
      };

      setSelectedProducts((prev) => [...prev, newItem]);
    }

    // Animar el carrito
    cartButtonRef.current?.animate();

    showSnackbar({
      message: `${product.name} a√±adido`,
      type: 'success',
    });
  };

  const updateItemInSelection = (
    itemId: string,
    quantity: number,
    modifiers: CartItemModifier[],
    preparationNotes?: string,
    variantId?: string,
    variantName?: string,
    unitPrice?: number,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost?: number,
  ) => {
    setSelectedProducts((prev) =>
      prev.map((item) => {
        if (item.id === itemId) {
          const modifiersPrice = modifiers.reduce(
            (sum, mod) => sum + Number(mod.price || 0),
            0,
          );
          const pizzaCost = pizzaExtraCost || 0;
          const finalUnitPrice =
            unitPrice !== undefined ? unitPrice : item.unitPrice;
          const newTotalPrice =
            (finalUnitPrice + modifiersPrice + pizzaCost) * quantity;

          return {
            ...item,
            quantity,
            modifiers,
            preparationNotes:
              preparationNotes !== undefined
                ? preparationNotes
                : item.preparationNotes,
            variantId: variantId !== undefined ? variantId : item.variantId,
            variantName:
              variantName !== undefined ? variantName : item.variantName,
            unitPrice: finalUnitPrice,
            totalPrice: newTotalPrice,
            selectedPizzaCustomizations:
              selectedPizzaCustomizations !== undefined
                ? selectedPizzaCustomizations
                : item.selectedPizzaCustomizations,
            pizzaExtraCost,
          };
        }
        return item;
      }),
    );
  };

  const handleAddToCart = (
    product: Product,
    quantity: number,
    selectedVariantId?: string,
    selectedModifiers?: CartItemModifier[],
    preparationNotes?: string,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost?: number,
  ) => {
    if (editingItem) {
      // Si estamos editando, actualizar el item existente
      updateItemInSelection(
        editingItem.id,
        quantity,
        selectedModifiers || [],
        preparationNotes,
        selectedVariantId,
        product.variants?.find((v) => v.id === selectedVariantId)?.name,
        selectedVariantId
          ? product.variants?.find((v) => v.id === selectedVariantId)?.price
          : product.price,
        selectedPizzaCustomizations,
        pizzaExtraCost,
      );
      setEditingItem(null);
    } else {
      // Si es nuevo, a√±adir a la selecci√≥n
      addItemToSelection(
        product,
        quantity,
        selectedVariantId,
        selectedModifiers,
        preparationNotes,
        selectedPizzaCustomizations,
        pizzaExtraCost,
      );
    }
    setSelectedProduct(null);
  };

  const handleCloseProductModal = useCallback(() => {
    setSelectedProduct(null);
    setEditingItem(null);
  }, []);

  const handleConfirmSelection = () => {
    // No mostrar mensaje si no hay productos nuevos seleccionados
    // pero permitir salir igualmente

    // Llamar callback con todos los productos (existentes + nuevos)
    if (onProductsAdded) {
      onProductsAdded(selectedProducts);
    }

    // Navegar de vuelta al resumen de orden
    navigation.goBack();
  };

  const handleBack = () => {
    if (selectedProduct) {
      setSelectedProduct(null);
    } else if (navigationLevel === 'products') {
      setNavigationLevel('subcategories');
      setSelectedSubcategoryId(null);
    } else if (navigationLevel === 'subcategories') {
      setNavigationLevel('categories');
      setSelectedCategoryId(null);
    } else {
      // Al salir, guardar los productos seleccionados
      if (onProductsAdded) {
        onProductsAdded(selectedProducts);
      }
      navigation.goBack();
    }
  };

  const getCategories = () => {
    if (!menu || !Array.isArray(menu)) return [];
    return menu;
  };

  const getSubcategories = () => {
    if (!selectedCategory || !Array.isArray(selectedCategory.subcategories))
      return [];
    return selectedCategory.subcategories;
  };

  const getProducts = () => {
    if (!selectedSubCategory || !Array.isArray(selectedSubCategory.products))
      return [];
    return selectedSubCategory.products;
  };

  const selectedCategory = menu?.find(
    (cat: Category) => cat.id === selectedCategoryId,
  );
  const selectedSubCategory = selectedCategory?.subcategories?.find(
    (sub: SubCategory) => sub.id === selectedSubcategoryId,
  );

  const getNavTitle = useCallback(() => {
    if (selectedProduct) {
      return selectedProduct.name;
    }
    switch (navigationLevel) {
      case 'categories':
        return `A√±adir a Orden #${orderNumber}`;
      case 'subcategories':
        return selectedCategory?.name || 'Subcategor√≠as';
      case 'products':
        return selectedSubCategory?.name || 'Productos';
      default:
        return 'Categor√≠as';
    }
  }, [
    navigationLevel,
    selectedCategory,
    selectedSubCategory,
    selectedProduct,
    orderNumber,
  ]);

  const handleShowProductDescription = (product: Product) => {
    setSelectedProductForDescription(product);
    setIsDescriptionModalVisible(true);
  };

  const handleCloseDescriptionModal = () => {
    setIsDescriptionModalVisible(false);
    setSelectedProductForDescription(null);
  };

  // Calcular n√∫mero de columnas din√°micamente
  const numColumns = useMemo(() => {
    // Para tablets (ancho >= 600px)
    if (responsive.width >= 600) {
      if (responsive.width >= 1200) return 6; // Tablets muy grandes
      if (responsive.width >= 900) return 5; // Tablets grandes
      if (responsive.width >= 768) return 4; // Tablets medianas
      return 3; // Tablets peque√±as (600-768px)
    }
    // Para m√≥viles (ancho < 600px)
    if (responsive.width >= 480) return 3; // M√≥viles grandes
    if (responsive.width >= 360) return 2; // M√≥viles est√°ndar
    return 2; // M√≥viles peque√±os
  }, [responsive.width]);

  // Calcular ancho de items basado en columnas
  const itemWidth = useMemo(() => {
    const padding = responsive.spacing(theme.spacing.m);
    const totalPadding = padding * 2;
    const gap = responsive.spacing(8);
    const totalGaps = gap * (numColumns - 1);
    const availableWidth = responsive.width - totalPadding - totalGaps;
    return Math.floor(availableWidth / numColumns);
  }, [responsive.width, numColumns, theme.spacing.m]);

  const styles = useMemo(
    () =>
      StyleSheet.create({
        safeArea: {
          flex: 1,
          backgroundColor: colors.background,
        },
        container: {
          flex: 1,
        },
        content: {
          flex: 1,
        },
        gridContainer: {
          padding: responsive.spacing(theme.spacing.m),
          paddingBottom: 60,
        },
        row: {
          justifyContent: 'flex-start',
          paddingHorizontal: 0,
          marginBottom: responsive.spacing(8),
          gap: responsive.spacing(8),
        },
        cardItem: {
          width: itemWidth,
          marginHorizontal: 0,
          marginVertical: 0,
          overflow: 'hidden',
          borderRadius: theme.roundness * 2,
          elevation: 2,
          backgroundColor: colors.surface,
          aspectRatio: 0.85,
        },
        cardItemInactive: {
          opacity: 0.5,
        },
        itemImage: {
          width: '100%',
          height: itemWidth * 0.65,
        },
        imageInactive: {
          opacity: 0.6,
        },
        cardContent: {
          paddingHorizontal: responsive.spacing(theme.spacing.s),
          paddingVertical: responsive.spacing(theme.spacing.xs),
          height: itemWidth * 0.35,
          justifyContent: 'center',
        },
        cardTitle: {
          fontSize: responsive.fontSize(responsive.width >= 600 ? 16 : 15),
          fontWeight: '600',
          lineHeight:
            responsive.fontSize(responsive.width >= 600 ? 16 : 15) * 1.2,
          marginBottom: responsive.spacing(2),
        },
        cardHeader: {
          flexDirection: 'row',
          justifyContent: 'space-between',
          alignItems: 'flex-start',
        },
        infoButton: {
          margin: -8,
          marginTop: -12,
          marginRight: -12,
        },
        priceText: {
          color: theme.colors.primary,
          fontWeight: '600',
          fontSize: responsive.fontSize(responsive.width >= 600 ? 14 : 13),
          marginTop: 2,
        },
        noItemsText: {
          textAlign: 'center',
          marginTop: 40,
          fontSize: 16,
          color: '#666',
        },
        loadingContainer: {
          flex: 1,
          justifyContent: 'center',
          alignItems: 'center',
        },
        appBar: {
          backgroundColor: colors.elevation.level2,
          alignItems: 'center',
        },
        appBarTitle: {
          ...fonts.titleMedium,
          color: colors.onSurface,
          fontWeight: 'bold',
          textAlign: 'center',
        },
        appBarContent: {},
        spacer: {
          width: 48,
        },
        inactiveBadge: {
          position: 'absolute',
          top: 8,
          right: 8,
          backgroundColor: colors.errorContainer,
          paddingHorizontal: 8,
          paddingVertical: 4,
          borderRadius: 4,
        },
        inactiveBadgeText: {
          fontSize: 12,
          color: colors.onErrorContainer,
          fontWeight: '600',
        },
      }),
    [colors, fonts, theme, responsive, itemWidth],
  );

  const blurhash =
    '|rF?hV%2WCj[ayj[a|j[az_NaeWBj@ayfRayfQfQM{M|azj[azf6fQfQfQIpWXofj[ayj[j[fQayWCoeoeaya}j[ayfQa{oLj?j[WVj[ayayj[fQoff7azayj[ayj[j[ayofayayayj[fQj[ayayj[ayfjj[j[ayjuayj[';

  const renderItem = useCallback(
    ({ item }: { item: Category | SubCategory | Product }) => {
      const imageSource = (() => {
        const photoPath = item.photo?.path || item.photo;
        return photoPath || null;
      })();
      const isActive = item.isActive !== false;

      // Verificar si es un producto sin pantalla de preparaci√≥n
      const isProductWithoutScreen =
        navigationLevel === 'products' &&
        'preparationScreenId' in item &&
        !item.preparationScreenId;

      const handlePress = () => {
        if (!isActive || isProductWithoutScreen) return;

        if (navigationLevel === 'categories') {
          handleCategorySelect(item.id);
        } else if (navigationLevel === 'subcategories') {
          handleSubCategorySelect(item.id);
        } else if ('price' in item) {
          handleProductSelect(item as Product);
        }
      };

      const handleLongPress = () => {
        if (
          navigationLevel === 'products' &&
          'price' in item &&
          isActive &&
          'description' in item &&
          (item as Product).description &&
          (item as Product).description.trim() !== ''
        ) {
          handleShowProductDescription(item as Product);
        }
      };

      const renderPrice = () => {
        if (
          navigationLevel === 'products' &&
          'price' in item &&
          'hasVariants' in item
        ) {
          const productItem = item as Product;
          if (
            !productItem.hasVariants &&
            productItem.price !== null &&
            productItem.price !== undefined
          ) {
            return (
              <Text style={styles.priceText}>
                ${Number(productItem.price).toFixed(2)}
              </Text>
            );
          }
        }
        return null;
      };

      return (
        <Card
          style={[
            styles.cardItem,
            (!isActive || isProductWithoutScreen) && styles.cardItemInactive,
          ]}
          onPress={handlePress}
          onLongPress={handleLongPress}
          disabled={!isActive || isProductWithoutScreen}
        >
          <AutoImage
            source={imageSource}
            style={[
              styles.itemImage,
              (!isActive || isProductWithoutScreen) && styles.imageInactive,
            ]}
            contentFit="cover"
            placeholder={blurhash}
            transition={300}
            placeholderIcon="image-outline"
          />
          <Card.Content style={styles.cardContent}>
            {navigationLevel === 'products' &&
            'price' in item &&
            (item as Product).description ? (
              <View style={styles.cardHeader}>
                <Title
                  style={[styles.cardTitle, { flex: 1 }]}
                  numberOfLines={2}
                  ellipsizeMode="tail"
                >
                  {item.name}
                </Title>
                <IconButton
                  icon="information-outline"
                  size={20}
                  onPress={() => handleShowProductDescription(item as Product)}
                  style={styles.infoButton}
                />
              </View>
            ) : (
              <Title
                style={styles.cardTitle}
                numberOfLines={2}
                ellipsizeMode="tail"
              >
                {item.name}
              </Title>
            )}
            {renderPrice()}
          </Card.Content>
          {!isActive && (
            <View style={styles.inactiveBadge}>
              <Text style={styles.inactiveBadgeText}>No disponible</Text>
            </View>
          )}
          {isProductWithoutScreen && (
            <View style={styles.inactiveBadge}>
              <Text style={styles.inactiveBadgeText}>SIN PANTALLA</Text>
            </View>
          )}
        </Card>
      );
    },
    [
      navigationLevel,
      handleCategorySelect,
      handleSubCategorySelect,
      handleProductSelect,
      handleShowProductDescription,
      styles,
      blurhash,
    ],
  );

  if (isLoading) {
    return (
      <SafeAreaView style={styles.safeArea}>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" />
        </View>
      </SafeAreaView>
    );
  }

  const currentData =
    navigationLevel === 'categories'
      ? getCategories()
      : navigationLevel === 'subcategories'
        ? getSubcategories()
        : getProducts();

  return (
    <SafeAreaView style={styles.safeArea} edges={['left', 'right', 'bottom']}>
      <View style={styles.container}>
        <Appbar.Header style={styles.appBar}>
          <Appbar.BackAction onPress={handleBack} />
          <Appbar.Content
            title={getNavTitle()}
            titleStyle={styles.appBarTitle}
            style={styles.appBarContent}
          />
          <CartButton
            ref={cartButtonRef}
            itemCount={totalItemsCount}
            onPress={handleConfirmSelection}
          />
        </Appbar.Header>

        <View style={styles.content}>
          {currentData.length === 0 ? (
            <Text style={styles.noItemsText}>
              {navigationLevel === 'categories'
                ? 'No hay categor√≠as disponibles'
                : navigationLevel === 'subcategories'
                  ? 'No hay subcategor√≠as disponibles'
                  : 'No hay productos disponibles'}
            </Text>
          ) : (
            <FlatList
              data={currentData}
              renderItem={renderItem}
              keyExtractor={(item) => item.id}
              numColumns={numColumns}
              key={numColumns}
              contentContainerStyle={styles.gridContainer}
              columnWrapperStyle={numColumns > 1 ? styles.row : undefined}
              showsVerticalScrollIndicator={false}
            />
          )}
        </View>

        {/* Modal de personalizaci√≥n de producto */}
        <Portal>
          {selectedProduct && (
            <ProductCustomizationModal
              visible={true}
              product={selectedProduct}
              editingItem={editingItem}
              onDismiss={handleCloseProductModal}
              onAddToCart={handleAddToCart}
              onUpdateItem={(
                itemId,
                quantity,
                modifiers,
                notes,
                variantId,
                variantName,
                unitPrice,
                selectedPizzaCustomizations,
                pizzaExtraCost,
              ) => {
                updateItemInSelection(
                  itemId,
                  quantity,
                  modifiers,
                  notes,
                  variantId,
                  variantName,
                  unitPrice,
                  selectedPizzaCustomizations,
                  pizzaExtraCost,
                );
                setEditingItem(null);
                setSelectedProduct(null);
              }}
            />
          )}

          {/* Modal de descripci√≥n del producto */}
          {selectedProductForDescription && (
            <SimpleProductDescriptionModal
              visible={isDescriptionModalVisible}
              product={selectedProductForDescription}
              onDismiss={handleCloseDescriptionModal}
            />
          )}
        </Portal>
      </View>
    </SafeAreaView>
  );
};

export default AddProductsToOrderScreen;

================
File: app/src/modules/preparationScreens/components/ProductSelectionModal.tsx
================
import React, { useState, useEffect, useMemo } from 'react';
import {
  View,
  ScrollView,
  StyleSheet,
  TouchableOpacity,
  ActivityIndicator,
} from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Checkbox,
  Button,
  Searchbar,
  Divider,
  IconButton,
} from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useTheme } from 'react-native-paper';

interface Product {
  id: string;
  name: string;
  photo: any;
  price: string | number | null | undefined;
  isAssociated: boolean;
  currentPreparationScreenId: string | null;
}

interface Subcategory {
  id: string;
  name: string;
  photo: any;
  products: Product[];
}

interface Category {
  id: string;
  name: string;
  photo: any;
  subcategories: Subcategory[];
}

interface MenuData {
  screenId: string;
  screenName: string;
  menu: Category[];
  screenAssignments?: Record<string, string>; // Mapeo de productId a nombre de pantalla
}

interface ProductSelectionModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSave: (productIds: string[]) => void;
  screenId: string;
  menuData?: MenuData;
  loading?: boolean;
}

export const ProductSelectionModal: React.FC<ProductSelectionModalProps> = ({
  visible,
  onDismiss,
  onSave,
  screenId,
  menuData,
  loading = false,
}) => {
  const theme = useTheme();
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedProducts, setSelectedProducts] = useState<Set<string>>(
    new Set(),
  );
  const [expandedCategories, setExpandedCategories] = useState<Set<string>>(
    new Set(),
  );
  const [expandedSubcategories, setExpandedSubcategories] = useState<
    Set<string>
  >(new Set());
  const [showConfirmDialog, setShowConfirmDialog] = useState(false);
  const [conflictingProducts, setConflictingProducts] = useState<
    Array<{ id: string; name: string; currentScreen: string }>
  >([]);

  // Inicializar productos seleccionados
  useEffect(() => {
    if (menuData) {
      const associatedProducts = new Set<string>();
      menuData.menu.forEach((category) => {
        category.subcategories.forEach((subcategory) => {
          subcategory.products.forEach((product) => {
            if (product.isAssociated) {
              associatedProducts.add(product.id);
            }
          });
        });
      });
      setSelectedProducts(associatedProducts);
    }
  }, [menuData]);

  // Crear mapeo de productos a nombres de pantalla para el mensaje de conflicto
  const getScreenNameForProduct = (productId: string): string => {
    // Primero intentar obtener el nombre desde screenAssignments
    if (menuData?.screenAssignments && menuData.screenAssignments[productId]) {
      return menuData.screenAssignments[productId];
    }

    // Si no est√° disponible, usar un nombre gen√©rico
    return 'otra pantalla de preparaci√≥n';
  };

  // Filtrar men√∫ basado en b√∫squeda
  const filteredMenu = useMemo(() => {
    if (!menuData || !searchQuery) return menuData?.menu || [];

    const query = searchQuery.toLowerCase();
    return menuData.menu
      .map((category) => ({
        ...category,
        subcategories: category.subcategories
          .map((subcategory) => ({
            ...subcategory,
            products: subcategory.products.filter((product) =>
              product.name.toLowerCase().includes(query),
            ),
          }))
          .filter((subcategory) => subcategory.products.length > 0),
      }))
      .filter((category) => category.subcategories.length > 0);
  }, [menuData, searchQuery]);

  const toggleCategory = (categoryId: string) => {
    const newExpanded = new Set(expandedCategories);
    if (newExpanded.has(categoryId)) {
      newExpanded.delete(categoryId);
    } else {
      newExpanded.add(categoryId);
    }
    setExpandedCategories(newExpanded);
  };

  const toggleSubcategory = (subcategoryId: string) => {
    const newExpanded = new Set(expandedSubcategories);
    if (newExpanded.has(subcategoryId)) {
      newExpanded.delete(subcategoryId);
    } else {
      newExpanded.add(subcategoryId);
    }
    setExpandedSubcategories(newExpanded);
  };

  const toggleProduct = (productId: string) => {
    const newSelected = new Set(selectedProducts);
    if (newSelected.has(productId)) {
      newSelected.delete(productId);
    } else {
      newSelected.add(productId);
    }
    setSelectedProducts(newSelected);
  };

  const toggleAllInCategory = (category: Category) => {
    const newSelected = new Set(selectedProducts);
    const categoryProducts = category.subcategories.flatMap((sub) =>
      sub.products.map((p) => p.id),
    );

    const allSelected = categoryProducts.every((id) => newSelected.has(id));

    if (allSelected) {
      categoryProducts.forEach((id) => newSelected.delete(id));
    } else {
      categoryProducts.forEach((id) => newSelected.add(id));
    }

    setSelectedProducts(newSelected);
  };

  const toggleAllInSubcategory = (subcategory: Subcategory) => {
    const newSelected = new Set(selectedProducts);
    const subcategoryProducts = subcategory.products.map((p) => p.id);

    const allSelected = subcategoryProducts.every((id) => newSelected.has(id));

    if (allSelected) {
      subcategoryProducts.forEach((id) => newSelected.delete(id));
    } else {
      subcategoryProducts.forEach((id) => newSelected.add(id));
    }

    setSelectedProducts(newSelected);
  };

  const isCategoryPartiallySelected = (category: Category) => {
    const categoryProducts = category.subcategories.flatMap((sub) =>
      sub.products.map((p) => p.id),
    );
    const selectedCount = categoryProducts.filter((id) =>
      selectedProducts.has(id),
    ).length;
    return selectedCount > 0 && selectedCount < categoryProducts.length;
  };

  const isCategoryFullySelected = (category: Category) => {
    const categoryProducts = category.subcategories.flatMap((sub) =>
      sub.products.map((p) => p.id),
    );
    return (
      categoryProducts.length > 0 &&
      categoryProducts.every((id) => selectedProducts.has(id))
    );
  };

  const isSubcategoryPartiallySelected = (subcategory: Subcategory) => {
    const selectedCount = subcategory.products.filter((p) =>
      selectedProducts.has(p.id),
    ).length;
    return selectedCount > 0 && selectedCount < subcategory.products.length;
  };

  const isSubcategoryFullySelected = (subcategory: Subcategory) => {
    return (
      subcategory.products.length > 0 &&
      subcategory.products.every((p) => selectedProducts.has(p.id))
    );
  };

  const handleSave = () => {
    // Verificar si hay productos seleccionados que ya est√°n asignados a otras pantallas
    const conflicts: Array<{
      id: string;
      name: string;
      currentScreen: string;
    }> = [];

    if (menuData) {
      menuData.menu.forEach((category) => {
        category.subcategories.forEach((subcategory) => {
          subcategory.products.forEach((product) => {
            if (
              selectedProducts.has(product.id) &&
              product.currentPreparationScreenId &&
              product.currentPreparationScreenId !== screenId
            ) {
              // Buscar el nombre de la pantalla actual del producto
              const screenName = getScreenNameForProduct(product.id);
              conflicts.push({
                id: product.id,
                name: product.name,
                currentScreen: screenName,
              });
            }
          });
        });
      });
    }

    if (conflicts.length > 0) {
      setConflictingProducts(conflicts);
      setShowConfirmDialog(true);
    } else {
      onSave(Array.from(selectedProducts));
    }
  };

  const handleConfirmSave = () => {
    setShowConfirmDialog(false);
    onSave(Array.from(selectedProducts));
  };

  const handleCancelSave = () => {
    setShowConfirmDialog(false);
  };

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={[
          styles.modalContainer,
          { backgroundColor: theme.colors.surface },
        ]}
      >
        <View style={styles.header}>
          <Text variant="headlineSmall">Seleccionar Productos</Text>
        </View>

        <Searchbar
          placeholder="Buscar productos..."
          onChangeText={setSearchQuery}
          value={searchQuery}
          style={styles.searchBar}
        />

        {loading ? (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
          </View>
        ) : (
          <ScrollView
            style={styles.scrollView}
            showsVerticalScrollIndicator={false}
          >
            {filteredMenu.map((category) => (
              <View key={category.id} style={styles.categoryContainer}>
                <TouchableOpacity
                  style={styles.categoryHeader}
                  onPress={() => toggleCategory(category.id)}
                >
                  <View style={styles.categoryTitleContainer}>
                    <IconButton
                      icon={
                        expandedCategories.has(category.id)
                          ? 'chevron-down'
                          : 'chevron-right'
                      }
                      size={20}
                    />
                    <Text variant="titleMedium" style={styles.categoryTitle}>
                      {category.name}
                    </Text>
                  </View>
                  <Checkbox.Android
                    status={
                      isCategoryFullySelected(category)
                        ? 'checked'
                        : isCategoryPartiallySelected(category)
                          ? 'indeterminate'
                          : 'unchecked'
                    }
                    onPress={() => toggleAllInCategory(category)}
                  />
                </TouchableOpacity>

                {expandedCategories.has(category.id) && (
                  <View style={styles.subcategoriesContainer}>
                    {category.subcategories.map((subcategory) => (
                      <View
                        key={subcategory.id}
                        style={styles.subcategoryContainer}
                      >
                        <TouchableOpacity
                          style={styles.subcategoryHeader}
                          onPress={() => toggleSubcategory(subcategory.id)}
                        >
                          <View style={styles.subcategoryTitleContainer}>
                            <IconButton
                              icon={
                                expandedSubcategories.has(subcategory.id)
                                  ? 'chevron-down'
                                  : 'chevron-right'
                              }
                              size={16}
                            />
                            <Text
                              variant="titleSmall"
                              style={styles.subcategoryTitle}
                            >
                              {subcategory.name}
                            </Text>
                          </View>
                          <Checkbox.Android
                            status={
                              isSubcategoryFullySelected(subcategory)
                                ? 'checked'
                                : isSubcategoryPartiallySelected(subcategory)
                                  ? 'indeterminate'
                                  : 'unchecked'
                            }
                            onPress={() => toggleAllInSubcategory(subcategory)}
                          />
                        </TouchableOpacity>

                        {expandedSubcategories.has(subcategory.id) && (
                          <View style={styles.productsContainer}>
                            {subcategory.products.map((product) => (
                              <TouchableOpacity
                                key={product.id}
                                style={styles.productItem}
                                onPress={() => toggleProduct(product.id)}
                              >
                                <View style={styles.productInfo}>
                                  <Text variant="bodyMedium">
                                    {product.name}
                                  </Text>
                                  {product.currentPreparationScreenId &&
                                    product.currentPreparationScreenId !==
                                      screenId && (
                                      <View style={styles.warningContainer}>
                                        <MaterialCommunityIcons
                                          name="alert"
                                          size={12}
                                          color={theme.colors.error}
                                        />
                                        <Text
                                          variant="bodySmall"
                                          style={[
                                            styles.warningText,
                                            { color: theme.colors.error },
                                          ]}
                                        >
                                          Asignado a otra pantalla
                                        </Text>
                                      </View>
                                    )}
                                </View>
                                <Checkbox.Android
                                  status={
                                    selectedProducts.has(product.id)
                                      ? 'checked'
                                      : 'unchecked'
                                  }
                                  onPress={() => toggleProduct(product.id)}
                                />
                              </TouchableOpacity>
                            ))}
                          </View>
                        )}
                      </View>
                    ))}
                  </View>
                )}
                <Divider style={styles.divider} />
              </View>
            ))}
          </ScrollView>
        )}

        <View style={styles.actions}>
          <Button mode="outlined" onPress={onDismiss}>
            Cancelar
          </Button>
          <Button mode="contained" onPress={handleSave} disabled={loading}>
            Guardar
          </Button>
        </View>
      </Modal>

      {/* Modal de confirmaci√≥n personalizado */}
      <Modal
        visible={showConfirmDialog}
        onDismiss={handleCancelSave}
        contentContainerStyle={{
          backgroundColor: theme.colors.surface,
          margin: 20,
          borderRadius: 16,
          maxHeight: '75%',
          elevation: 8,
        }}
      >
        {/* Header */}
        <View
          style={{
            flexDirection: 'row',
            alignItems: 'center',
            padding: 20,
            paddingBottom: 16,
            borderBottomWidth: 1,
            borderBottomColor: theme.colors.surfaceVariant,
          }}
        >
          <View
            style={{
              width: 40,
              height: 40,
              borderRadius: 20,
              backgroundColor: theme.colors.errorContainer,
              justifyContent: 'center',
              alignItems: 'center',
              marginRight: 12,
            }}
          >
            <MaterialCommunityIcons
              name="alert"
              size={24}
              color={theme.colors.error}
            />
          </View>
          <Text variant="headlineSmall" style={{ flex: 1 }}>
            Reasignar Productos
          </Text>
        </View>

        {/* Subtitle */}
        <View style={{ paddingHorizontal: 20, paddingTop: 16 }}>
          <Text
            variant="bodyLarge"
            style={{
              color: theme.colors.onSurfaceVariant,
            }}
          >
            {conflictingProducts.length === 1
              ? 'El siguiente producto ser√° reasignado:'
              : `Los siguientes ${conflictingProducts.length} productos ser√°n reasignados:`}
          </Text>
        </View>

        {/* Scrollable Product List */}
        <ScrollView
          style={{
            maxHeight: 250,
            marginTop: 16,
            marginHorizontal: 20,
          }}
          showsVerticalScrollIndicator={true}
        >
          {conflictingProducts.map((product, _index) => (
            <View
              key={product.id}
              style={{
                paddingVertical: 14,
                paddingHorizontal: 16,
                backgroundColor: theme.colors.surfaceVariant,
                borderRadius: 12,
                marginBottom: 8,
                borderLeftWidth: 4,
                borderLeftColor: theme.colors.error,
              }}
            >
              <Text
                variant="bodyLarge"
                style={{
                  fontWeight: '600',
                  color: theme.colors.onSurface,
                  marginBottom: 8,
                }}
              >
                {product.name}
              </Text>
              <View
                style={{
                  flexDirection: 'row',
                  alignItems: 'center',
                  backgroundColor: theme.colors.surface,
                  padding: 8,
                  borderRadius: 8,
                }}
              >
                <View style={{ flex: 1, alignItems: 'center' }}>
                  <Text
                    variant="labelSmall"
                    style={{
                      color: theme.colors.onSurfaceVariant,
                      marginBottom: 2,
                    }}
                  >
                    Desde
                  </Text>
                  <Text
                    variant="bodySmall"
                    style={{
                      color: theme.colors.error,
                      fontWeight: '500',
                    }}
                  >
                    {product.currentScreen}
                  </Text>
                </View>

                <MaterialCommunityIcons
                  name="arrow-right"
                  size={20}
                  color={theme.colors.primary}
                  style={{ marginHorizontal: 8 }}
                />

                <View style={{ flex: 1, alignItems: 'center' }}>
                  <Text
                    variant="labelSmall"
                    style={{
                      color: theme.colors.onSurfaceVariant,
                      marginBottom: 2,
                    }}
                  >
                    Hacia
                  </Text>
                  <Text
                    variant="bodySmall"
                    style={{
                      color: theme.colors.primary,
                      fontWeight: '500',
                    }}
                  >
                    {menuData?.screenName || 'Esta pantalla'}
                  </Text>
                </View>
              </View>
            </View>
          ))}
        </ScrollView>

        {/* Info Box */}
        <View
          style={{
            margin: 20,
            marginTop: 16,
            marginBottom: 0,
            padding: 16,
            backgroundColor: theme.colors.secondaryContainer,
            borderRadius: 12,
            flexDirection: 'row',
            alignItems: 'center',
          }}
        >
          <MaterialCommunityIcons
            name="information"
            size={20}
            color={theme.colors.onSecondaryContainer}
            style={{ marginRight: 12 }}
          />
          <Text
            variant="bodySmall"
            style={{
              color: theme.colors.onSecondaryContainer,
              flex: 1,
            }}
          >
            Los productos ser√°n removidos autom√°ticamente de sus pantallas
            actuales al confirmar.
          </Text>
        </View>

        {/* Actions */}
        <View
          style={{
            flexDirection: 'row',
            justifyContent: 'center',
            alignItems: 'center',
            padding: 20,
            paddingTop: 16,
            gap: 16,
            borderTopWidth: 1,
            borderTopColor: theme.colors.surfaceVariant,
            marginTop: 16,
          }}
        >
          <Button
            onPress={handleCancelSave}
            mode="outlined"
            style={{
              flex: 1,
              maxWidth: 150,
              borderColor: theme.colors.outline,
            }}
            contentStyle={{ paddingVertical: 4 }}
          >
            Cancelar
          </Button>
          <Button
            onPress={handleConfirmSave}
            mode="contained"
            buttonColor={theme.colors.error}
            icon="check-circle"
            style={{
              flex: 1,
              maxWidth: 150,
            }}
            contentStyle={{ paddingVertical: 4 }}
          >
            Reasignar
          </Button>
        </View>
      </Modal>
    </Portal>
  );
};

const styles = StyleSheet.create({
  modalContainer: {
    margin: 20,
    padding: 20,
    borderRadius: 8,
    maxHeight: '90%',
  },
  header: {
    marginBottom: 16,
  },
  searchBar: {
    marginBottom: 16,
  },
  scrollView: {
    maxHeight: 400,
  },
  loadingContainer: {
    height: 200,
    justifyContent: 'center',
    alignItems: 'center',
  },
  categoryContainer: {
    marginBottom: 8,
  },
  categoryHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 8,
  },
  categoryTitleContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  categoryTitle: {
    fontWeight: 'bold',
  },
  subcategoriesContainer: {
    paddingLeft: 20,
  },
  subcategoryContainer: {
    marginBottom: 4,
  },
  subcategoryHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 4,
  },
  subcategoryTitleContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  subcategoryTitle: {
    fontWeight: '600',
  },
  productsContainer: {
    paddingLeft: 20,
  },
  productItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 8,
    paddingLeft: 16,
  },
  productInfo: {
    flex: 1,
  },
  warningContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 2,
  },
  warningText: {
    marginLeft: 4,
    fontSize: 11,
  },
  divider: {
    marginTop: 8,
  },
  actions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 16,
  },
});

================
File: app/src/modules/preparationScreens/hooks/usePreparationScreensQueries.ts
================
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import * as preparationScreenService from '../services/preparationScreenService';
import {
  PreparationScreen,
  CreatePreparationScreenDto,
  UpdatePreparationScreenDto,
  FindAllPreparationScreensDto,
} from '../schema/preparationScreen.schema';
import { BaseListQuery } from '../../../app/types/query.types';
import { PaginatedResponse } from '../../../app/types/api.types';
import { useSnackbarStore } from '../../../app/store/snackbarStore';
import { getApiErrorMessage } from '../../../app/lib/errorMapping';

// --- Query Keys ---
const preparationScreensQueryKeys = {
  all: ['preparationScreens'] as const,
  lists: () => [...preparationScreensQueryKeys.all, 'list'] as const,
  list: (filters: FindAllPreparationScreensDto & BaseListQuery) =>
    [...preparationScreensQueryKeys.lists(), filters] as const,
  details: () => [...preparationScreensQueryKeys.all, 'detail'] as const,
  detail: (id: string) =>
    [...preparationScreensQueryKeys.details(), id] as const,
  products: (id: string) =>
    [...preparationScreensQueryKeys.detail(id), 'products'] as const,
  menuWithAssociations: (id: string) =>
    [
      ...preparationScreensQueryKeys.detail(id),
      'menuWithAssociations',
    ] as const,
};

// --- Hooks ---

/**
 * Hook to fetch a paginated list of preparation screens with filters.
 */
export const useGetPreparationScreens = (
  filters: FindAllPreparationScreensDto = {},
  pagination: BaseListQuery = { page: 1, limit: 15 }, // Default limit 15
) => {
  const queryKey = preparationScreensQueryKeys.list({
    ...filters,
    ...pagination,
  });
  return useQuery<PaginatedResponse<PreparationScreen>, Error>({
    queryKey,
    queryFn: () =>
      preparationScreenService.getPreparationScreens(filters, pagination),
    // Considerar placeholderData o initialData si es necesario para UX
  });
};

/**
 * Hook to fetch a single preparation screen by its ID.
 */
export const useGetPreparationScreenById = (
  id: string | null,
  options?: { enabled?: boolean },
) => {
  const queryKey = preparationScreensQueryKeys.detail(id!); // Use non-null assertion as it's enabled conditionally
  return useQuery<PreparationScreen, Error>({
    queryKey,
    queryFn: () => preparationScreenService.getPreparationScreenById(id!),
    enabled: !!id && (options?.enabled ?? true), // Only run query if id is provided and enabled
  });
};

/**
 * Hook for creating a new preparation screen.
 */
export const useCreatePreparationScreen = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<PreparationScreen, Error, CreatePreparationScreenDto>({
    mutationFn: preparationScreenService.createPreparationScreen,
    onSuccess: () => {
      // Invalidate list queries to refetch
      queryClient.invalidateQueries({
        queryKey: preparationScreensQueryKeys.lists(),
      });
      showSnackbar({
        message: 'Pantalla de preparaci√≥n creada con √©xito',
        type: 'success',
      });
    },
    onError: (error) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
    },
  });
};

/**
 * Hook for updating an existing preparation screen.
 */
export const useUpdatePreparationScreen = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  // Contexto para actualizaci√≥n optimista
  type UpdatePreparationScreenContext = { previousDetail?: PreparationScreen };

  return useMutation<
    PreparationScreen,
    Error,
    { id: string; data: UpdatePreparationScreenDto },
    UpdatePreparationScreenContext
  >({
    mutationFn: ({ id, data }) =>
      preparationScreenService.updatePreparationScreen(id, data),

    // --- Inicio Actualizaci√≥n Optimista ---
    onMutate: async (variables) => {
      const { id, data } = variables;
      const detailQueryKey = preparationScreensQueryKeys.detail(id);

      // 1. Cancelar query de detalle
      await queryClient.cancelQueries({ queryKey: detailQueryKey });

      // 2. Guardar estado anterior del detalle
      const previousDetail =
        queryClient.getQueryData<PreparationScreen>(detailQueryKey);

      // 3. Actualizar cach√© de detalle optimistamente
      if (previousDetail) {
        // Fusionar datos antiguos y nuevos. Asumiendo que UpdatePreparationScreenDto no tiene estructuras anidadas problem√°ticas.
        queryClient.setQueryData<PreparationScreen>(detailQueryKey, (old) =>
          old ? { ...old, ...data } : undefined,
        );
      }

      // 4. Retornar contexto
      return { previousDetail };
    },
    // --- Fin Actualizaci√≥n Optimista ---

    onError: (error, variables, context) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
      // Error al actualizar pantalla de preparaci√≥n

      // Revertir cach√© de detalle
      if (context?.previousDetail) {
        queryClient.setQueryData(
          preparationScreensQueryKeys.detail(variables.id),
          context.previousDetail,
        );
      }
    },

    onSettled: (data, error, variables) => {
      // Invalidar listas y detalle para consistencia final
      queryClient.invalidateQueries({
        queryKey: preparationScreensQueryKeys.lists(),
      });
      queryClient.invalidateQueries({
        queryKey: preparationScreensQueryKeys.detail(variables.id),
      });

      // Mostrar snackbar de √©xito solo si no hubo error
      if (!error && data) {
        showSnackbar({
          message: 'Pantalla de preparaci√≥n actualizada con √©xito',
          type: 'success',
        });
      }
    },
  });
};

/**
 * Hook for deleting a preparation screen.
 */
export const useDeletePreparationScreen = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  // Contexto para guardar el detalle eliminado
  type DeletePreparationScreenContext = { previousDetail?: PreparationScreen };

  return useMutation<void, Error, string, DeletePreparationScreenContext>({
    mutationFn: preparationScreenService.deletePreparationScreen,

    // --- Inicio Actualizaci√≥n Optimista ---
    onMutate: async (deletedId) => {
      const detailQueryKey = preparationScreensQueryKeys.detail(deletedId);

      // 1. Cancelar query de detalle
      await queryClient.cancelQueries({ queryKey: detailQueryKey });

      // 2. Guardar estado anterior del detalle
      const previousDetail =
        queryClient.getQueryData<PreparationScreen>(detailQueryKey);

      // 3. Eliminar optimistamente de la cach√© de detalle
      queryClient.removeQueries({ queryKey: detailQueryKey });

      // 4. Retornar contexto
      return { previousDetail };
    },
    // --- Fin Actualizaci√≥n Optimista ---

    onError: (error, deletedId, context) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });

      // Revertir cach√© de detalle si hubo error
      if (context?.previousDetail) {
        queryClient.setQueryData(
          preparationScreensQueryKeys.detail(deletedId),
          context.previousDetail,
        );
      }
    },

    onSettled: (_, error, deletedId) => {
      // Invalidar listas para asegurar consistencia final
      queryClient.invalidateQueries({
        queryKey: preparationScreensQueryKeys.lists(),
      });

      // Asegurar remoci√≥n en √©xito y mostrar snackbar
      if (!error) {
        queryClient.removeQueries({
          queryKey: preparationScreensQueryKeys.detail(deletedId),
        });
        showSnackbar({
          message: 'Pantalla de preparaci√≥n eliminada con √©xito',
          type: 'success',
        });
      }
    },
  });
};

/**
 * Hook to fetch products associated with a preparation screen.
 */
export const useGetPreparationScreenProducts = (
  id: string | null,
  options?: { enabled?: boolean },
) => {
  const queryKey = preparationScreensQueryKeys.products(id!);
  return useQuery<any[], Error>({
    queryKey,
    queryFn: () => preparationScreenService.getPreparationScreenProducts(id!),
    enabled: !!id && (options?.enabled ?? true),
  });
};

/**
 * Hook to fetch menu with associations for a preparation screen.
 */
export const useGetMenuWithAssociations = (
  id: string | null,
  options?: { enabled?: boolean },
) => {
  const queryKey = preparationScreensQueryKeys.menuWithAssociations(id!);
  return useQuery<any, Error>({
    queryKey,
    queryFn: () => preparationScreenService.getMenuWithAssociations(id!),
    enabled: !!id && (options?.enabled ?? true),
  });
};

/**
 * Hook for associating products with a preparation screen.
 */
export const useAssociateProducts = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<
    PreparationScreen,
    Error,
    { id: string; productIds: string[] }
  >({
    mutationFn: ({ id, productIds }) =>
      preparationScreenService.associateProducts(id, productIds),
    onSuccess: (_, variables) => {
      // Invalidate related queries
      queryClient.invalidateQueries({
        queryKey: preparationScreensQueryKeys.detail(variables.id),
      });
      queryClient.invalidateQueries({
        queryKey: preparationScreensQueryKeys.products(variables.id),
      });
      queryClient.invalidateQueries({
        queryKey: preparationScreensQueryKeys.menuWithAssociations(
          variables.id,
        ),
      });
      queryClient.invalidateQueries({
        queryKey: preparationScreensQueryKeys.lists(),
      });

      showSnackbar({
        message: 'Productos asociados con √©xito',
        type: 'success',
      });
    },
    onError: (error) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
    },
  });
};

================
File: app/src/modules/printers/hooks/usePrintersQueries.ts
================
import {
  useMutation,
  UseMutationResult,
  useQuery,
  UseQueryResult,
  useQueryClient,
} from '@tanstack/react-query';
import { printerService } from '../services/printerService';
import {
  DiscoveredPrinter,
  ThermalPrinter,
  CreateThermalPrinterDto,
  UpdateThermalPrinterDto,
  FindAllThermalPrintersDto,
} from '../types/printer.types';
import { ApiError } from '../../../app/lib/errors';
import { PaginatedResponse } from '../../../app/types/api.types';
import { useSnackbarStore } from '../../../app/store/snackbarStore';
import { getApiErrorMessage } from '../../../app/lib/errorMapping';

// --- Query Keys ---
const printerKeys = {
  all: ['thermalPrinters'] as const,
  lists: () => [...printerKeys.all, 'list'] as const,
  list: (filters: FindAllThermalPrintersDto) =>
    [...printerKeys.lists(), filters] as const,
  details: () => [...printerKeys.all, 'detail'] as const,
  detail: (id: string) => [...printerKeys.details(), id] as const,
  discover: ['discoverPrinters'] as const, // Clave para descubrimiento
};

/**
 * Hook para disparar el descubrimiento de impresoras.
 * Utiliza useMutation ya que es una acci√≥n iniciada por el usuario.
 */
export const useDiscoverPrinters = (): UseMutationResult<
  DiscoveredPrinter[], // Tipo de dato que devuelve la mutaci√≥n en caso de √©xito
  ApiError, // Tipo de error esperado
  number | undefined // Tipo del argumento que recibe la funci√≥n mutate (duration o undefined)
> => {
  // No necesita invalidar cach√©, es una acci√≥n puntual
  return useMutation<DiscoveredPrinter[], ApiError, number | undefined>({
    mutationFn: (duration: number | undefined) =>
      printerService.discoverPrinters(duration),
    // Opcional: manejo de errores/√©xito espec√≠fico para descubrimiento si es necesario
  });
};

/**
 * Hook para obtener la lista paginada de impresoras registradas.
 */
export const usePrintersQuery = (
  // Proporcionar valores por defecto para page y limit si params est√° vac√≠o
  params: FindAllThermalPrintersDto = { page: 1, limit: 10 },
  options?: { enabled?: boolean },
): UseQueryResult<PaginatedResponse<ThermalPrinter>, ApiError> => {
  const queryKey = printerKeys.list(params);
  return useQuery<PaginatedResponse<ThermalPrinter>, ApiError>({
    queryKey: queryKey,
    queryFn: () => printerService.findAllPrinters(params),
    enabled: options?.enabled ?? true,
  });
};

/**
 * Hook para obtener los detalles de una impresora registrada por ID.
 */
export const usePrinterQuery = (
  id: string | undefined,
  options?: { enabled?: boolean },
): UseQueryResult<ThermalPrinter, ApiError> => {
  const queryKey = printerKeys.detail(id!);
  return useQuery<ThermalPrinter, ApiError>({
    queryKey: queryKey,
    queryFn: () => printerService.findOnePrinter(id!),
    enabled: !!id && (options?.enabled ?? true),
  });
};

/**
 * Hook para crear una nueva impresora registrada.
 */
export const useCreatePrinterMutation = (): UseMutationResult<
  ThermalPrinter,
  ApiError,
  CreateThermalPrinterDto
> => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<ThermalPrinter, ApiError, CreateThermalPrinterDto>({
    mutationFn: printerService.createPrinter,
    onSuccess: (newPrinter) => {
      queryClient.invalidateQueries({ queryKey: printerKeys.lists() });
      showSnackbar({
        message: `Impresora "${newPrinter.name}" creada con √©xito`,
        type: 'success',
      });
    },
    onError: (error) => {
      showSnackbar({
        message: getApiErrorMessage(error),
        type: 'error',
      });
    },
  });
};

/**
 * Hook para actualizar una impresora registrada existente.
 */
export const useUpdatePrinterMutation = (): UseMutationResult<
  ThermalPrinter,
  ApiError,
  { id: string; data: UpdateThermalPrinterDto }
> => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<
    ThermalPrinter,
    ApiError,
    { id: string; data: UpdateThermalPrinterDto }
  >({
    mutationFn: ({ id, data }) => printerService.updatePrinter(id, data),
    onSuccess: (updatedPrinter, variables) => {
      // Invalidar lista y detalle espec√≠fico
      queryClient.invalidateQueries({ queryKey: printerKeys.lists() });
      queryClient.invalidateQueries({
        queryKey: printerKeys.detail(variables.id),
      });
      // Opcional: Actualizar cach√© directamente si se desea optimizaci√≥n
      // queryClient.setQueryData(printerKeys.detail(variables.id), updatedPrinter);
      showSnackbar({
        message: `Impresora "${updatedPrinter.name}" actualizada`,
        type: 'success',
      });
    },
    onError: (error, _variables) => {
      showSnackbar({
        message: getApiErrorMessage(error),
        type: 'error',
      });
    },
  });
};

/**
 * Hook para eliminar (soft delete) una impresora registrada.
 */
export const useDeletePrinterMutation = (): UseMutationResult<
  void,
  ApiError,
  string // ID de la impresora a eliminar
> => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<void, ApiError, string>({
    mutationFn: printerService.deletePrinter,
    onSuccess: (_, deletedId) => {
      queryClient.invalidateQueries({ queryKey: printerKeys.lists() });
      // Opcional: Remover de la cach√© de detalle
      queryClient.removeQueries({ queryKey: printerKeys.detail(deletedId) });
      showSnackbar({ message: 'Impresora eliminada', type: 'success' });
    },
    onError: (error) => {
      showSnackbar({
        message: `Error al eliminar impresora: ${getApiErrorMessage(error)}`,
        type: 'error',
      });
    },
  });
};

/**
 * Hook para realizar un ping a una impresora.
 */
export const usePingPrinterMutation = (): UseMutationResult<
  { status: string }, // Tipo de dato que devuelve la mutaci√≥n en caso de √©xito
  ApiError, // Tipo de error esperado
  string // Tipo del argumento que recibe la funci√≥n mutate (printer ID)
> => {
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<{ status: string }, ApiError, string>({
    mutationFn: (printerId: string) => printerService.pingPrinter(printerId),
    onSuccess: (data, _printerId) => {
      const message =
        data.status === 'online'
          ? `Impresora conectada (ping exitoso).`
          : `Impresora desconectada (ping fallido).`;
      const type = data.status === 'online' ? 'success' : 'warning';
      showSnackbar({ message, type });
    },
    onError: (error, _printerId) => {
      showSnackbar({
        message: `Error al hacer ping a la impresora: ${getApiErrorMessage(error)}`,
        type: 'error',
      });
      // Error al hacer ping a la impresora
    },
  });
};

/**
 * Hook para imprimir un ticket de prueba en una impresora descubierta.
 */
export const useTestPrintDiscoveredPrinter = (): UseMutationResult<
  { success: boolean; message?: string },
  ApiError,
  DiscoveredPrinter
> => {
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<
    { success: boolean; message?: string },
    ApiError,
    DiscoveredPrinter
  >({
    mutationFn: (printer: DiscoveredPrinter) =>
      printerService.testPrintDiscoveredPrinter(printer),
    onSuccess: (data) => {
      showSnackbar({
        message: data.message || 'Ticket de prueba impreso correctamente',
        type: 'success',
      });
    },
    onError: (error) => {
      showSnackbar({
        message: `Error al imprimir ticket de prueba: ${getApiErrorMessage(error)}`,
        type: 'error',
      });
      // Error al imprimir ticket de prueba
    },
  });
};

/**
 * Hook para imprimir un ticket de prueba en una impresora configurada.
 */
export const useTestPrintPrinter = (): UseMutationResult<
  { success: boolean; message?: string },
  ApiError,
  string
> => {
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<{ success: boolean; message?: string }, ApiError, string>({
    mutationFn: (printerId: string) =>
      printerService.testPrintPrinter(printerId),
    onSuccess: (data) => {
      showSnackbar({
        message: data.message || 'Ticket de prueba impreso correctamente',
        type: 'success',
      });
    },
    onError: (error) => {
      showSnackbar({
        message: `Error al imprimir ticket de prueba: ${getApiErrorMessage(error)}`,
        type: 'error',
      });
      // Error al imprimir ticket de prueba
    },
  });
};

================
File: app/src/modules/printers/services/printerService.ts
================
import ApiClientWrapper from '../../../app/services/apiClientWrapper';
import { handleApiError } from '../../../app/lib/apiResponseHelper';
import { API_PATHS } from '../../../app/constants/apiPaths';
import {
  DiscoveredPrinter,
  ThermalPrinter,
  CreateThermalPrinterDto,
  UpdateThermalPrinterDto,
  FindAllThermalPrintersDto,
} from '../types/printer.types';
import {
  PaginatedResponse,
  BaseListQueryDto,
} from '../../../app/types/api.types';

type PrinterFilterParams = Omit<
  FindAllThermalPrintersDto,
  keyof BaseListQueryDto
>;

const discoverPrinters = async (
  duration: number = 10000,
): Promise<DiscoveredPrinter[]> => {
  const response = await ApiClientWrapper.get<DiscoveredPrinter[]>(
    API_PATHS.THERMAL_PRINTERS_DISCOVER,
    { duration },
  );

  if (!response.ok || !response.data) {
    handleApiError(response);
  }

  return response.data;
};

const findAllPrinters = async (
  filters: PrinterFilterParams = {},
  pagination: BaseListQueryDto = { page: 1, limit: 10 },
): Promise<PaginatedResponse<ThermalPrinter>> => {
  const queryParams = Object.entries({ ...filters, ...pagination }).reduce(
    (acc, [key, value]) => {
      if (value !== undefined) {
        if (key === 'isActive' && typeof value === 'boolean') {
          acc[key] = String(value);
        } else {
          acc[key] = value;
        }
      }
      return acc;
    },
    {} as Record<string, any>,
  );

  type FindAllPrintersApiResponse = {
    items: ThermalPrinter[];
    total: number;
    page: number;
    limit: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  };

  const response = await ApiClientWrapper.get<FindAllPrintersApiResponse>(
    API_PATHS.THERMAL_PRINTERS,
    queryParams,
  );

  if (
    !response.ok ||
    !response.data ||
    typeof response.data !== 'object' ||
    !Array.isArray(response.data.items)
  ) {
    handleApiError(response);
  }

  return {
    data: response.data.items,
    total: response.data.total,
    page: response.data.page,
    limit: response.data.limit,
    totalPages: Math.ceil(response.data.total / response.data.limit),
  };
};

const findOnePrinter = async (id: string): Promise<ThermalPrinter> => {
  const response = await ApiClientWrapper.get<ThermalPrinter>(
    API_PATHS.THERMAL_PRINTERS_BY_ID.replace(':id', id),
  );
  if (!response.ok || !response.data) {
    handleApiError(response);
  }
  return response.data;
};

const createPrinter = async (
  data: CreateThermalPrinterDto,
): Promise<ThermalPrinter> => {
  const response = await ApiClientWrapper.post<ThermalPrinter>(
    API_PATHS.THERMAL_PRINTERS,
    data,
  );
  if (!response.ok || !response.data) {
    handleApiError(response);
  }
  return response.data;
};

const updatePrinter = async (
  id: string,
  data: UpdateThermalPrinterDto,
): Promise<ThermalPrinter> => {
  const response = await ApiClientWrapper.patch<ThermalPrinter>(
    API_PATHS.THERMAL_PRINTERS_BY_ID.replace(':id', id),
    data,
  );
  if (!response.ok || !response.data) {
    handleApiError(response);
  }
  return response.data;
};

const deletePrinter = async (id: string): Promise<void> => {
  const response = await ApiClientWrapper.delete(
    API_PATHS.THERMAL_PRINTERS_BY_ID.replace(':id', id),
  );
  if (!response.ok) {
    handleApiError(response);
  }
};

const pingPrinter = async (id: string): Promise<{ status: string }> => {
  const response = await ApiClientWrapper.get<{ status: string }>(
    API_PATHS.THERMAL_PRINTERS_PING.replace(':id', id),
  );

  if (
    !response.ok ||
    !response.data ||
    typeof response.data.status !== 'string'
  ) {
    handleApiError(response);
  }
  return response.data;
};

const testPrintDiscoveredPrinter = async (
  printer: DiscoveredPrinter,
): Promise<{ success: boolean; message?: string }> => {
  const response = await ApiClientWrapper.post<{
    success: boolean;
    message?: string;
  }>(API_PATHS.THERMAL_PRINTERS_TEST_PRINT, {
    ip: printer.ip,
    port: printer.port,
    connectionType: 'NETWORK',
  });

  if (!response.ok || !response.data) {
    handleApiError(response);
  }
  return response.data;
};

const testPrintPrinter = async (
  id: string,
): Promise<{ success: boolean; message?: string }> => {
  // Primero obtener la informaci√≥n de la impresora
  const printer = await findOnePrinter(id);

  // Preparar los datos seg√∫n el tipo de conexi√≥n
  const printerInfo: any = {
    connectionType: printer.connectionType,
  };

  if (printer.connectionType === 'NETWORK') {
    printerInfo.ip = printer.ipAddress;
    printerInfo.port = printer.port;
  } else {
    // Para otros tipos de conexi√≥n, usar la ruta
    printerInfo.path = printer.path;
  }

  const response = await ApiClientWrapper.post<{
    success: boolean;
    message?: string;
  }>(API_PATHS.THERMAL_PRINTERS_TEST_PRINT, printerInfo);

  if (!response.ok || !response.data) {
    handleApiError(response);
  }
  return response.data;
};

export const printerService = {
  discoverPrinters,
  findAllPrinters,
  findOnePrinter,
  createPrinter,
  updatePrinter,
  deletePrinter,
  pingPrinter,
  testPrintDiscoveredPrinter,
  testPrintPrinter,
};

================
File: app/src/modules/receipts/components/ReceiptDetailsModal.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, TouchableOpacity } from 'react-native';
import {
  Surface,
  Text,
  Divider,
  IconButton,
  Chip,
  ActivityIndicator,
} from 'react-native-paper';
import { Receipt } from '../types/receipt.types';
import { useAppTheme } from '@/app/styles/theme';
import { ResponsiveModal } from '@/app/components/responsive/ResponsiveModal';
import {
  CustomizationType,
  PizzaHalf,
  CustomizationAction,
} from '@/modules/pizzaCustomizations/types/pizzaCustomization.types';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import OrderHistoryModal from '@/modules/shared/components/OrderHistoryModal';

interface ReceiptDetailsModalProps {
  visible: boolean;
  onDismiss: () => void;
  receipt: Receipt | null;
  isLoading?: boolean;
}

const formatPizzaCustomizations = (customizations: any[]): string => {
  if (!customizations || customizations.length === 0) return '';

  const groupedByHalf = customizations.reduce(
    (acc, curr) => {
      const half =
        curr.half === PizzaHalf.HALF_1
          ? 'HALF_1'
          : curr.half === PizzaHalf.HALF_2
            ? 'HALF_2'
            : 'FULL';

      if (!acc[half]) {
        acc[half] = {
          flavors: [],
          addedIngredients: [],
          removedIngredients: [],
        };
      }

      const name = curr.pizzaCustomization?.name || curr.pizzaCustomizationId;
      const type = curr.pizzaCustomization?.type;

      if (type === 'FLAVOR' || type === CustomizationType.FLAVOR) {
        acc[half].flavors.push(name);
      } else if (
        type === 'INGREDIENT' ||
        type === CustomizationType.INGREDIENT
      ) {
        if (curr.action === CustomizationAction.ADD) {
          acc[half].addedIngredients.push(name);
        } else {
          acc[half].removedIngredients.push(name);
        }
      }

      return acc;
    },
    {} as Record<
      string,
      {
        flavors: string[];
        addedIngredients: string[];
        removedIngredients: string[];
      }
    >,
  );

  if (groupedByHalf.FULL) {
    const parts: string[] = [];
    if (groupedByHalf.FULL.flavors.length > 0) {
      parts.push(groupedByHalf.FULL.flavors.join(', '));
    }
    if (groupedByHalf.FULL.addedIngredients.length > 0) {
      parts.push(`con: ${groupedByHalf.FULL.addedIngredients.join(', ')}`);
    }
    if (groupedByHalf.FULL.removedIngredients.length > 0) {
      parts.push(`sin: ${groupedByHalf.FULL.removedIngredients.join(', ')}`);
    }
    return parts.join(' - ');
  } else if (groupedByHalf.HALF_1 || groupedByHalf.HALF_2) {
    const formatHalf = (halfData: {
      flavors: string[];
      addedIngredients: string[];
      removedIngredients: string[];
    }) => {
      const parts: string[] = [];
      if (halfData.flavors.length > 0) {
        parts.push(halfData.flavors.join(', '));
      }
      if (halfData.addedIngredients.length > 0) {
        parts.push(`con: ${halfData.addedIngredients.join(', ')}`);
      }
      if (halfData.removedIngredients.length > 0) {
        parts.push(`sin: ${halfData.removedIngredients.join(', ')}`);
      }
      return parts.join(' - ');
    };

    const half1 = groupedByHalf.HALF_1 ? formatHalf(groupedByHalf.HALF_1) : '';
    const half2 = groupedByHalf.HALF_2 ? formatHalf(groupedByHalf.HALF_2) : '';

    return half1 && half2 ? `(${half1} / ${half2})` : half1 || half2;
  }

  return '';
};

export const ReceiptDetailsModal: React.FC<ReceiptDetailsModalProps> = ({
  visible,
  onDismiss,
  receipt,
  isLoading = false,
}) => {
  const theme = useAppTheme();
  const [showPrintHistory, setShowPrintHistory] = useState(false);
  const [showOrderHistory, setShowOrderHistory] = useState(false);

  if (!receipt && !isLoading) return null;

  const getOrderTypeLabel = (type: string) => {
    switch (type) {
      case 'DINE_IN':
        return 'üçΩÔ∏è Local';
      case 'TAKE_AWAY':
        return 'ü•° Llevar';
      case 'DELIVERY':
        return 'üöö Env√≠o';
      default:
        return type;
    }
  };

  const getOrderStatusLabel = (status: string) => {
    switch (status) {
      case 'PENDING':
        return 'Pendiente';
      case 'IN_PROGRESS':
        return 'En preparaci√≥n';
      case 'READY':
        return 'Listo';
      case 'DELIVERED':
        return 'Entregado';
      case 'COMPLETED':
        return 'Completado';
      case 'CANCELLED':
        return 'Cancelado';
      default:
        return status;
    }
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'PENDING':
        return '#FFA726';
      case 'IN_PROGRESS':
        return theme.colors.primary;
      case 'READY':
        return '#66BB6A';
      case 'DELIVERED':
        return '#9C27B0';
      case 'COMPLETED':
        return '#10B981';
      case 'CANCELLED':
        return theme.colors.error;
      default:
        return theme.colors.onSurfaceVariant;
    }
  };

  const getPaymentStatus = () => {
    if (receipt?.payments && receipt.payments.length > 0) {
      const totalPaid = receipt.payments.reduce((sum, p) => sum + p.amount, 0);
      const totalAmount =
        typeof receipt.total === 'string'
          ? parseFloat(receipt.total)
          : receipt.total || 0;

      if (totalPaid >= totalAmount) {
        return { label: 'Pagado', color: '#10B981' };
      } else if (totalPaid > 0) {
        return { label: 'Parcial', color: '#F59E0B' };
      }
    }
    return { label: 'Pendiente', color: '#EF4444' };
  };

  if (isLoading || !receipt) {
    return (
      <ResponsiveModal
        visible={visible}
        onDismiss={onDismiss}
        title="Cargando..."
      >
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
          <Text
            style={[
              styles.loadingText,
              { color: theme.colors.onSurfaceVariant },
            ]}
          >
            Cargando detalles del recibo...
          </Text>
        </View>
      </ResponsiveModal>
    );
  }

  const paymentStatus = getPaymentStatus();

  const headerActions = (
    <IconButton
      icon="history"
      size={24}
      onPress={() => setShowOrderHistory(true)}
      style={styles.historyButton}
    />
  );

  const modalTitle = `Recibo #${receipt?.shiftOrderNumber || ''} ¬∑ ${getOrderTypeLabel(receipt?.orderType || '')}`;

  const footerContent = (
    <View style={styles.footer}>
      <View style={styles.footerLeft}>
        <Text
          style={[styles.totalLabel, { color: theme.colors.onSurfaceVariant }]}
        >
          Total:
        </Text>
        <Text style={[styles.totalAmount, { color: theme.colors.primary }]}>
          $
          {receipt
            ? typeof receipt.total === 'string'
              ? parseFloat(receipt.total).toFixed(2)
              : (receipt.total || 0).toFixed(2)
            : '0.00'}
        </Text>
      </View>
      <View
        style={[styles.paymentBadge, { backgroundColor: paymentStatus.color }]}
      >
        <Text style={styles.paymentBadgeText}>üíµ {paymentStatus.label}</Text>
      </View>
    </View>
  );

  const renderItem = (item: any) => {
    const quantity = item.quantity || 1;
    const unitPrice = parseFloat(item.finalPrice);
    const totalPrice = unitPrice * quantity;
    const preparationStatusColors = {
      PENDING: '#FFA726',
      IN_PROGRESS: '#42A5F5',
      READY: '#66BB6A',
      DELIVERED: '#26A69A',
      CANCELLED: '#EF5350',
    };
    const statusColor =
      preparationStatusColors[
        item.preparationStatus as keyof typeof preparationStatusColors
      ] || theme.colors.onSurfaceVariant;

    return (
      <Surface
        key={`${item.id}`}
        style={[
          styles.itemCard,
          { backgroundColor: theme.colors.elevation.level1, marginBottom: 8 },
        ]}
        elevation={1}
      >
        <View style={styles.itemContent}>
          <View style={styles.itemHeader}>
            <View style={styles.nameContainer}>
              <Text
                style={[styles.itemQuantity, { color: theme.colors.primary }]}
              >
                {quantity}x
              </Text>
              <Text
                style={[styles.itemName, { color: theme.colors.onSurface }]}
                numberOfLines={1}
              >
                {item.productVariant?.name || item.product.name}
              </Text>
            </View>
            {item.preparationStatus && (
              <View
                style={[styles.statusChip, { backgroundColor: statusColor }]}
              >
                <Text style={styles.statusChipText}>
                  {item.preparationStatus === 'PENDING' && 'Pendiente'}
                  {item.preparationStatus === 'IN_PROGRESS' && 'Preparando'}
                  {item.preparationStatus === 'READY' && 'Listo'}
                  {item.preparationStatus === 'DELIVERED' && 'Entregado'}
                  {item.preparationStatus === 'CANCELLED' && 'Cancelado'}
                </Text>
              </View>
            )}
          </View>

          <View style={styles.itemDetailsContainer}>
            {item.selectedPizzaCustomizations &&
              item.selectedPizzaCustomizations.length > 0 && (
                <View style={styles.customizationContainer}>
                  <Text
                    style={[
                      styles.pizzaCustomizationText,
                      { color: theme.colors.onSurfaceVariant },
                    ]}
                  >
                    {formatPizzaCustomizations(
                      item.selectedPizzaCustomizations,
                    )}
                  </Text>
                </View>
              )}

            {item.productModifiers && item.productModifiers.length > 0 && (
              <View style={styles.modifiersContainer}>
                {item.productModifiers.map((modifier: any) => (
                  <View key={modifier.id} style={styles.modifierRow}>
                    <Text
                      style={[
                        styles.modifierText,
                        { color: theme.colors.onSurfaceVariant },
                      ]}
                    >
                      ‚Ä¢ {modifier.name}
                    </Text>
                    {modifier.price && Number(modifier.price) > 0 && (
                      <Text
                        style={[
                          styles.modifierPrice,
                          { color: theme.colors.tertiary },
                        ]}
                      >
                        +${Number(modifier.price).toFixed(2)}
                      </Text>
                    )}
                  </View>
                ))}
              </View>
            )}

            {item.preparationNotes && (
              <View style={styles.notesContainer}>
                <Text
                  style={[
                    styles.notesText,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                  üìù {item.preparationNotes}
                </Text>
              </View>
            )}
          </View>

          <View style={styles.priceContainer}>
            <View style={styles.priceRow}>
              <Text
                style={[
                  styles.priceLabel,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                P. unitario:
              </Text>
              <Text
                style={[styles.priceValue, { color: theme.colors.onSurface }]}
              >
                ${unitPrice.toFixed(2)}
              </Text>
            </View>
            {item.quantity > 1 && (
              <View style={styles.priceRow}>
                <Text
                  style={[
                    styles.priceLabel,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                  Total √ó{item.quantity}:
                </Text>
                <Text
                  style={[styles.totalPrice, { color: theme.colors.primary }]}
                >
                  ${totalPrice.toFixed(2)}
                </Text>
              </View>
            )}
          </View>
        </View>
      </Surface>
    );
  };

  return (
    <>
      <ResponsiveModal
        visible={visible}
        onDismiss={onDismiss}
        title={modalTitle}
        headerActions={headerActions}
        maxHeightTablet="90%"
        scrollable={true}
        footer={footerContent}
        footerStyle={{ paddingTop: 0 }}
      >
        {/* Header info con status y fechas */}
        <View style={styles.headerInfo}>
          <View style={styles.chipsRow}>
            <View
              style={[
                styles.headerStatusChip,
                {
                  backgroundColor: getStatusColor(receipt.orderStatus),
                },
              ]}
            >
              <Text style={styles.headerStatusChipText}>
                {getOrderStatusLabel(receipt.orderStatus)}
              </Text>
            </View>
            {receipt.preparationScreens &&
              receipt.preparationScreens.map((screen, index) => (
                <Chip
                  key={index}
                  mode="outlined"
                  compact
                  style={styles.screenChip}
                  textStyle={styles.screenChipText}
                >
                  üç≥ {screen}
                </Chip>
              ))}
          </View>
          <View style={styles.headerDatesRow}>
            <Text
              style={[
                styles.headerDate,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Creado:{' '}
              {receipt.createdAt
                ? format(new Date(receipt.createdAt), 'dd/MM/yyyy HH:mm', {
                    locale: es,
                  })
                : ''}
            </Text>
            {receipt.finalizedAt && (
              <Text
                style={[styles.headerDate, { color: theme.colors.primary }]}
              >
                Finalizado:{' '}
                {format(new Date(receipt.finalizedAt), 'dd/MM/yyyy HH:mm', {
                  locale: es,
                })}
              </Text>
            )}
          </View>
        </View>

        {/* Informaci√≥n del recibo */}
        <View style={styles.infoSection}>
          {receipt.deliveryInfo?.recipientName && (
            <View style={styles.infoRow}>
              <Text
                style={[styles.contactText, { color: theme.colors.onSurface }]}
              >
                üë§ Nombre del Cliente: {receipt.deliveryInfo.recipientName}
              </Text>
            </View>
          )}

          {receipt.deliveryInfo?.recipientPhone && (
            <View style={styles.infoRow}>
              <Text
                style={[styles.contactText, { color: theme.colors.onSurface }]}
              >
                üìû Tel√©fono: {receipt.deliveryInfo.recipientPhone}
              </Text>
            </View>
          )}

          {receipt.orderType === 'DELIVERY' &&
            receipt.deliveryInfo?.fullAddress && (
              <View style={styles.infoRow}>
                <Text
                  style={[
                    styles.addressText,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                  üì¶ Direcci√≥n de Entrega: {receipt.deliveryInfo.fullAddress}
                </Text>
              </View>
            )}

          {receipt.orderType === 'DINE_IN' && receipt.table && (
            <View style={styles.infoRow}>
              <Text
                style={[styles.tableText, { color: theme.colors.onSurface }]}
              >
                üèõÔ∏è Mesa: {receipt.table.area?.name || 'Sin √°rea'} -{' '}
                {receipt.table.number}
              </Text>
            </View>
          )}

          {receipt.scheduledAt && (
            <View style={styles.infoRow}>
              <Text
                style={[
                  styles.contactText,
                  { color: theme.colors.primary, fontWeight: '600' },
                ]}
              >
                ‚è∞ Hora de Entrega Programada:{' '}
                {format(new Date(receipt.scheduledAt), 'HH:mm', {
                  locale: es,
                })}
              </Text>
            </View>
          )}

          {receipt.user && (
            <View style={styles.infoRow}>
              <Text
                style={[
                  styles.contactText,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                üë®‚Äçüíº Atendido por: {receipt.user.firstName}{' '}
                {receipt.user.lastName}
              </Text>
            </View>
          )}

          {receipt.notes && (
            <View style={styles.infoRow}>
              <Text
                style={[
                  styles.notesText,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                üìã Notas: {receipt.notes}
              </Text>
            </View>
          )}
        </View>

        <Divider style={styles.divider} />

        {/* Lista de productos */}
        <View style={styles.itemsList}>
          {receipt.orderItems?.map((item) => renderItem(item)) || []}
        </View>

        <Divider style={styles.divider} />

        {/* Pagos */}
        {receipt.payments && receipt.payments.length > 0 && (
          <>
            <View style={styles.paymentsSection}>
              <View style={styles.paymentSummaryCompact}>
                <View style={styles.summaryCompactRow}>
                  <Text
                    style={[
                      styles.summaryCompactLabel,
                      { color: theme.colors.onSurfaceVariant },
                    ]}
                  >
                    Total: $
                    {typeof receipt.total === 'string'
                      ? parseFloat(receipt.total).toFixed(2)
                      : (receipt.total || 0).toFixed(2)}
                  </Text>
                  <Text
                    style={[styles.summaryCompactLabel, { color: '#10B981' }]}
                  >
                    Pagado: $
                    {receipt.payments
                      .reduce((sum, p) => sum + p.amount, 0)
                      .toFixed(2)}
                  </Text>
                  {(() => {
                    const totalAmount =
                      typeof receipt.total === 'string'
                        ? parseFloat(receipt.total)
                        : receipt.total || 0;
                    const totalPaid = receipt.payments.reduce(
                      (sum, p) => sum + p.amount,
                      0,
                    );
                    const remaining = totalAmount - totalPaid;
                    if (remaining > 0) {
                      return (
                        <Text
                          style={[
                            styles.summaryCompactLabel,
                            {
                              color: theme.colors.error,
                              fontWeight: '600',
                            },
                          ]}
                        >
                          Resta: ${remaining.toFixed(2)}
                        </Text>
                      );
                    }
                    return null;
                  })()}
                </View>
              </View>

              {receipt.payments.map((payment, index) => {
                const getPaymentMethodLabel = (method: string) => {
                  switch (method) {
                    case 'CASH':
                    case 'cash':
                      return 'Efectivo';
                    case 'CREDIT_CARD':
                    case 'card':
                      return 'Tarjeta de Cr√©dito';
                    case 'DEBIT_CARD':
                      return 'Tarjeta de D√©bito';
                    case 'TRANSFER':
                    case 'transfer':
                      return 'Transferencia';
                    case 'OTHER':
                      return 'Otro';
                    default:
                      return method;
                  }
                };

                const getPaymentStatusColor = (status: string) => {
                  switch (status) {
                    case 'COMPLETED':
                      return '#10B981';
                    case 'PENDING':
                      return '#F59E0B';
                    case 'FAILED':
                      return theme.colors.error;
                    case 'REFUNDED':
                      return '#6B7280';
                    case 'CANCELLED':
                      return theme.colors.error;
                    default:
                      return theme.colors.onSurfaceVariant;
                  }
                };

                const getPaymentStatusLabel = (status: string) => {
                  switch (status) {
                    case 'COMPLETED':
                      return 'Completado';
                    case 'PENDING':
                      return 'Pendiente';
                    case 'FAILED':
                      return 'Fallido';
                    case 'REFUNDED':
                      return 'Reembolsado';
                    case 'CANCELLED':
                      return 'Cancelado';
                    default:
                      return status;
                  }
                };

                return (
                  <View
                    key={payment.id || index}
                    style={styles.paymentRowCompact}
                  >
                    <Text
                      style={[
                        styles.paymentMethodCompact,
                        { color: theme.colors.onSurface },
                      ]}
                    >
                      üí≥ {getPaymentMethodLabel(payment.paymentMethod)}
                    </Text>
                    <Text
                      style={[
                        styles.paymentDateCompact,
                        { color: theme.colors.onSurfaceVariant },
                      ]}
                    >
                      {format(new Date(payment.createdAt), 'HH:mm', {
                        locale: es,
                      })}
                    </Text>
                    <View
                      style={[
                        styles.paymentStatusBadgeCompact,
                        {
                          backgroundColor:
                            getPaymentStatusColor(payment.paymentStatus) + '20',
                        },
                      ]}
                    >
                      <Text
                        style={[
                          styles.paymentStatusTextCompact,
                          {
                            color: getPaymentStatusColor(payment.paymentStatus),
                          },
                        ]}
                      >
                        {getPaymentStatusLabel(payment.paymentStatus)}
                      </Text>
                    </View>
                    <Text
                      style={[
                        styles.paymentAmountCompact,
                        { color: theme.colors.primary },
                      ]}
                    >
                      ${payment.amount.toFixed(2)}
                    </Text>
                  </View>
                );
              })}
            </View>
            <Divider style={styles.divider} />
          </>
        )}

        {/* Historial de impresiones */}
        {receipt.ticketImpressions && receipt.ticketImpressions.length > 0 && (
          <>
            <View style={styles.ticketImpressionsSection}>
              <TouchableOpacity
                style={styles.collapsibleHeader}
                onPress={() => setShowPrintHistory(!showPrintHistory)}
                activeOpacity={0.7}
              >
                <Text
                  style={[styles.sectionTitle, { color: theme.colors.primary }]}
                >
                  üñ®Ô∏è Historial de Impresiones (
                  {receipt.ticketImpressions.length})
                </Text>
                <IconButton
                  icon={showPrintHistory ? 'chevron-up' : 'chevron-down'}
                  size={20}
                  style={styles.collapseIcon}
                />
              </TouchableOpacity>

              {showPrintHistory && (
                <View style={styles.collapsibleContent}>
                  {receipt.ticketImpressions.map((impression, index) => {
                    const getTicketTypeLabel = (type: string) => {
                      switch (type) {
                        case 'KITCHEN':
                          return 'üç≥ Cocina';
                        case 'BAR':
                          return 'üç∫ Barra';
                        case 'BILLING':
                          return 'üíµ Cuenta';
                        case 'CUSTOMER_COPY':
                          return 'üìÑ Copia Cliente';
                        case 'GENERAL':
                          return 'üìã General';
                        default:
                          return type;
                      }
                    };

                    return (
                      <View
                        key={impression.id || index}
                        style={styles.impressionRow}
                      >
                        <View style={styles.impressionLeft}>
                          <Text
                            style={[
                              styles.impressionType,
                              { color: theme.colors.onSurface },
                            ]}
                          >
                            {getTicketTypeLabel(impression.ticketType)}
                          </Text>
                          <View style={styles.impressionDetails}>
                            {impression.user && (
                              <Text
                                style={[
                                  styles.impressionUser,
                                  {
                                    color: theme.colors.onSurfaceVariant,
                                  },
                                ]}
                              >
                                por {impression.user.firstName || ''}{' '}
                                {impression.user.lastName || ''}
                              </Text>
                            )}
                            {impression.printer && (
                              <Text
                                style={[
                                  styles.impressionPrinter,
                                  {
                                    color: theme.colors.onSurfaceVariant,
                                  },
                                ]}
                              >
                                üñ®Ô∏è {impression.printer.name}
                              </Text>
                            )}
                          </View>
                        </View>
                        <Text
                          style={[
                            styles.impressionTime,
                            {
                              color: theme.colors.onSurfaceVariant,
                            },
                          ]}
                        >
                          {format(
                            new Date(impression.impressionTime),
                            'HH:mm:ss',
                            { locale: es },
                          )}
                        </Text>
                      </View>
                    );
                  })}
                </View>
              )}
            </View>
          </>
        )}
      </ResponsiveModal>

      {/* Modal de historial */}
      {receipt && (
        <OrderHistoryModal
          visible={showOrderHistory}
          onDismiss={() => setShowOrderHistory(false)}
          orderId={receipt.id}
        />
      )}
    </>
  );
};

const styles = StyleSheet.create({
  loadingContainer: {
    minHeight: 200,
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 40,
  },
  loadingText: {
    marginTop: 16,
    fontSize: 14,
  },
  historyButton: {
    margin: -8,
  },
  headerInfo: {
    paddingBottom: 16,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(0,0,0,0.08)',
    marginBottom: 16,
  },
  chipsRow: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
    flexWrap: 'wrap',
    marginBottom: 8,
  },
  headerStatusChip: {
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 10,
  },
  headerStatusChipText: {
    color: 'white',
    fontSize: 11,
    fontWeight: '600',
  },
  screenChip: {
    height: 20,
  },
  screenChipText: {
    fontSize: 10,
    marginVertical: -2,
  },
  headerDatesRow: {
    gap: 8,
  },
  headerDate: {
    fontSize: 11,
  },
  infoSection: {
    gap: 4,
    marginBottom: 16,
  },
  infoRow: {
    marginVertical: 2,
  },
  contactText: {
    fontSize: 12,
  },
  addressText: {
    fontSize: 12,
    lineHeight: 16,
  },
  tableText: {
    fontSize: 12,
  },
  divider: {
    marginVertical: 2,
  },
  itemsList: {
    marginBottom: 16,
  },
  itemCard: {
    borderRadius: 8,
    overflow: 'hidden',
  },
  itemContent: {
    padding: 10,
  },
  itemHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 6,
  },
  nameContainer: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    marginRight: 8,
  },
  itemQuantity: {
    fontSize: 14,
    fontWeight: '700',
    marginRight: 6,
  },
  itemName: {
    fontSize: 13,
    fontWeight: '600',
    flex: 1,
    lineHeight: 16,
  },
  statusChip: {
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 12,
  },
  statusChipText: {
    color: 'white',
    fontSize: 10,
    fontWeight: '600',
  },
  itemDetailsContainer: {
    marginBottom: 6,
  },
  customizationContainer: {
    marginBottom: 4,
  },
  pizzaCustomizationText: {
    fontSize: 11,
    fontStyle: 'italic',
    lineHeight: 14,
  },
  modifiersContainer: {
    marginTop: 2,
  },
  modifierRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 1,
  },
  modifierText: {
    fontSize: 11,
    flex: 1,
    lineHeight: 14,
  },
  modifierPrice: {
    fontSize: 11,
    fontWeight: '500',
    marginLeft: 4,
  },
  notesContainer: {
    marginTop: 4,
    paddingTop: 4,
    borderTopWidth: 1,
    borderTopColor: 'rgba(0,0,0,0.06)',
  },
  notesText: {
    fontSize: 11,
    fontStyle: 'italic',
    lineHeight: 14,
  },
  priceContainer: {
    marginTop: 6,
    paddingTop: 6,
    borderTopWidth: 1,
    borderTopColor: 'rgba(0,0,0,0.06)',
  },
  priceRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 2,
  },
  priceLabel: {
    fontSize: 11,
    opacity: 0.7,
  },
  priceValue: {
    fontSize: 12,
    fontWeight: '600',
  },
  totalPrice: {
    fontSize: 14,
    fontWeight: '700',
  },
  paymentsSection: {
    marginBottom: 16,
  },
  paymentSummaryCompact: {
    marginBottom: 8,
  },
  summaryCompactRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  summaryCompactLabel: {
    fontSize: 12,
    fontWeight: '500',
  },
  paymentRowCompact: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 6,
    gap: 8,
  },
  paymentMethodCompact: {
    fontSize: 11,
    fontWeight: '500',
    flex: 1,
  },
  paymentDateCompact: {
    fontSize: 10,
  },
  paymentAmountCompact: {
    fontSize: 12,
    fontWeight: '600',
    minWidth: 50,
    textAlign: 'right',
  },
  paymentStatusBadgeCompact: {
    paddingHorizontal: 6,
    paddingVertical: 1,
    borderRadius: 10,
  },
  paymentStatusTextCompact: {
    fontSize: 9,
    fontWeight: '600',
  },
  ticketImpressionsSection: {
    marginBottom: 16,
  },
  collapsibleHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingRight: 4,
  },
  collapseIcon: {
    margin: -8,
  },
  collapsibleContent: {
    marginTop: 8,
  },
  sectionTitle: {
    fontSize: 14,
    fontWeight: '600',
    marginBottom: 0,
  },
  impressionRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
    paddingLeft: 8,
  },
  impressionLeft: {
    flex: 1,
    gap: 2,
  },
  impressionType: {
    fontSize: 12,
    fontWeight: '500',
  },
  impressionDetails: {
    gap: 2,
  },
  impressionUser: {
    fontSize: 11,
    opacity: 0.7,
  },
  impressionPrinter: {
    fontSize: 11,
    opacity: 0.7,
    fontStyle: 'italic',
  },
  impressionTime: {
    fontSize: 11,
    opacity: 0.7,
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    // ResponsiveModal maneja padding y border
  },
  footerLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  totalLabel: {
    fontSize: 14,
    fontWeight: '600',
  },
  totalAmount: {
    fontSize: 16,
    fontWeight: '700',
  },
  paymentBadge: {
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 12,
  },
  paymentBadgeText: {
    color: 'white',
    fontSize: 12,
    fontWeight: '600',
  },
});

================
File: app/src/modules/restaurantConfig/types/restaurantConfig.types.ts
================
export interface DeliveryCoveragePoint {
  lat: number;
  lng: number;
}

export interface BusinessHours {
  id: string;
  dayOfWeek: number; // 0 = Domingo, 1 = Lunes, ... 6 = S√°bado
  openingTime: string | null; // HH:mm
  closingTime: string | null; // HH:mm
  closesNextDay?: boolean; // true si cierra despu√©s de medianoche
  isClosed: boolean;
  restaurantConfigId: string;
  createdAt: string;
  updatedAt: string;
}

export interface RestaurantConfig {
  id: string;
  // Informaci√≥n b√°sica
  restaurantName: string;
  phoneMain: string | null;
  phoneSecondary: string | null;
  address: string | null;
  city: string | null;
  state: string | null;
  postalCode: string | null;
  country: string | null;

  // Configuraci√≥n de operaci√≥n
  acceptingOrders: boolean;
  estimatedPickupTime: number;
  estimatedDeliveryTime: number;
  estimatedDineInTime: number;
  openingGracePeriod: number;
  closingGracePeriod: number;
  timeZone: string;
  scheduledOrdersLeadTime: number;

  // Configuraci√≥n de delivery
  deliveryCoverageArea: DeliveryCoveragePoint[] | null;
  minimumOrderValueForDelivery: number | string; // Puede venir como string desde el backend (decimal)

  // Relaciones
  businessHours: BusinessHours[];

  createdAt: string;
  updatedAt: string;
}

export interface UpdateRestaurantConfigDto {
  // Informaci√≥n b√°sica
  restaurantName?: string;
  phoneMain?: string | null;
  phoneSecondary?: string | null;
  address?: string | null;
  city?: string | null;
  state?: string | null;
  postalCode?: string | null;
  country?: string | null;

  // Configuraci√≥n de operaci√≥n
  acceptingOrders?: boolean;
  estimatedPickupTime?: number;
  estimatedDeliveryTime?: number;
  estimatedDineInTime?: number;
  openingGracePeriod?: number;
  closingGracePeriod?: number;
  timeZone?: string;
  scheduledOrdersLeadTime?: number;

  // Configuraci√≥n de delivery
  deliveryCoverageArea?: DeliveryCoveragePoint[] | null;
  minimumOrderValueForDelivery?: number;

  // Horarios
  businessHours?: CreateBusinessHoursDto[];
}

export interface CreateBusinessHoursDto {
  dayOfWeek: number;
  openingTime?: string | null;
  closingTime?: string | null;
  closesNextDay?: boolean;
  isClosed?: boolean;
  restaurantConfigId?: string;
}

export interface UpdateBusinessHoursDto {
  openingTime?: string | null;
  closingTime?: string | null;
  closesNextDay?: boolean;
  isClosed?: boolean;
}

================
File: app/src/modules/shiftAudit/components/OrderHistoryView.tsx
================
import React, { useMemo, useState } from 'react';
import {
  View,
  StyleSheet,
  FlatList,
  ActivityIndicator,
  TouchableOpacity,
} from 'react-native';
import {
  Text,
  Divider,
  Chip,
  Button,
  Avatar,
  Surface,
  Appbar,
} from 'react-native-paper';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import { useAppTheme } from '@/app/styles/theme';
import { useQuery } from '@tanstack/react-query';
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';

interface HistoryItem {
  id: string | number;
  orderId: string;
  orderItemId?: string;
  operation: 'INSERT' | 'UPDATE' | 'DELETE' | 'BATCH';
  changedBy: string;
  changedAt: string;
  diff?: Record<string, any> | null;
  snapshot?: Record<string, any>;
  productId?: string;
  preparationStatus?: string;
  changedByUser?: {
    id?: string;
    firstName: string;
    lastName: string;
  };
  user?: {
    firstName: string;
    lastName: string;
  };
  itemDescription?: string;
  formattedChanges?: Record<string, any>;
  batchOperations?: any[];
  type: 'order' | 'item';
}

interface OrderHistoryViewProps {
  orderId: string | null;
  orderNumber?: number;
  onBack: () => void;
}

// Helper para obtener el icono de la operaci√≥n
const getOperationIcon = (
  operation: string,
  type: 'order' | 'item' = 'item',
) => {
  if (type === 'order') {
    return 'receipt';
  }
  switch (operation) {
    case 'INSERT':
      return 'plus-circle';
    case 'UPDATE':
      return 'pencil';
    case 'DELETE':
      return 'delete';
    case 'BATCH':
      return 'folder-multiple';
    default:
      return 'information';
  }
};

// Helper para obtener el label de la operaci√≥n
const getOperationLabel = (
  operation: string,
  type: 'order' | 'item' = 'item',
) => {
  if (type === 'order') {
    const orderOperationMap: Record<string, string> = {
      INSERT: 'Orden creada',
      UPDATE: 'Orden modificada',
      DELETE: 'Orden eliminada',
    };
    return orderOperationMap[operation] || operation;
  }

  const operationMap: Record<string, string> = {
    INSERT: 'Item agregado',
    UPDATE: 'Item modificado',
    DELETE: 'Item eliminado',
    BATCH: 'Cambios m√∫ltiples',
  };
  return operationMap[operation] || operation;
};

// Helper para obtener color del estado
const getStatusColor = (
  status: string,
  theme: ReturnType<typeof useAppTheme>,
) => {
  const statusColors: Record<string, string> = {
    PENDING: theme.colors.onSurfaceDisabled,
    IN_PROGRESS: theme.colors.warning || '#FFA500',
    READY: theme.colors.success || '#4CAF50',
    CANCELLED: theme.colors.error,
  };
  return statusColors[status] || theme.colors.onSurfaceDisabled;
};

// Helper para formatear nombres de campos
const formatFieldName = (field: string): string => {
  const fieldMap: Record<string, string> = {
    orderStatus: 'Estado de la orden',
    orderType: 'Tipo de orden',
    tableId: 'Mesa',
    table: 'Mesa',
    notes: 'Notas',
    deliveryInfo: 'Informaci√≥n de entrega',
    customerName: 'Nombre del cliente',
    customerPhone: 'Tel√©fono del cliente',
    recipientName: 'Nombre del destinatario',
    recipientPhone: 'Tel√©fono del destinatario',
    deliveryAddress: 'Direcci√≥n de entrega',
    fullAddress: 'Direcci√≥n',
    estimatedDeliveryTime: 'Tiempo estimado de entrega',
    preparationStatus: 'Estado de preparaci√≥n',
    preparationNotes: 'Notas de preparaci√≥n',
    customerId: 'Cliente',
    scheduledAt: 'Fecha programada',
    total: 'Total',
    subtotal: 'Subtotal',
    finalizedAt: 'Finalizado',
  };
  return fieldMap[field] || field;
};

// Helper para formatear valores
const formatValue = (field: string, value: any): string => {
  if (value === null || value === undefined) {
    return 'No especificado';
  }

  if (field === 'orderStatus') {
    const statusMap: Record<string, string> = {
      PENDING: 'Pendiente',
      IN_PROGRESS: 'En Progreso',
      COMPLETED: 'Completada',
      CANCELLED: 'Cancelada',
      DELIVERED: 'Entregada',
    };
    return statusMap[value] || value;
  }

  if (field === 'orderType') {
    const typeMap: Record<string, string> = {
      DINE_IN: 'Para Comer Aqu√≠',
      TAKE_AWAY: 'Para Llevar',
      DELIVERY: 'Domicilio',
    };
    return typeMap[value] || value;
  }

  if (field === 'preparationStatus') {
    const statusMap: Record<string, string> = {
      PENDING: 'Pendiente',
      IN_PROGRESS: 'En Preparaci√≥n',
      READY: 'Listo',
      CANCELLED: 'Cancelado',
    };
    return statusMap[value] || value;
  }

  if (field === 'tableId' && typeof value === 'object' && value.name) {
    return value.name;
  }

  if (
    field === 'estimatedDeliveryTime' ||
    field === 'scheduledAt' ||
    field === 'finalizedAt'
  ) {
    try {
      return format(new Date(value), 'dd/MM/yyyy HH:mm', { locale: es });
    } catch {
      return value;
    }
  }

  if (field === 'total' || field === 'subtotal') {
    return `$${parseFloat(value).toFixed(2)}`;
  }

  if (field === 'customerId') {
    return value || 'Sin cliente registrado';
  }

  if (field === 'scheduledAt') {
    return value
      ? format(new Date(value), 'dd/MM/yyyy HH:mm', { locale: es })
      : 'No programado';
  }

  return String(value);
};

// Componente para cada item del historial (copiado de OrderHistoryModal)
const HistoryItemComponent: React.FC<{
  item: HistoryItem;
  theme: ReturnType<typeof useAppTheme>;
}> = ({ item, theme }) => {
  const [expanded, setExpanded] = useState(false);
  const styles = useMemo(() => createStyles(theme), [theme]);

  const renderChangeDetail = (change: any, fieldName?: string) => {
    if (
      change &&
      typeof change === 'object' &&
      change.anterior !== undefined &&
      change.nuevo !== undefined
    ) {
      // Para descripci√≥n del item, mostrar en formato vertical si es muy largo
      if (
        (fieldName === 'Descripci√≥n del Item' || fieldName === 'Descripci√≥n') &&
        (String(change.anterior).length > 30 ||
          String(change.nuevo).length > 30)
      ) {
        return (
          <View style={{ marginTop: 4 }}>
            <View
              style={{
                backgroundColor: theme.colors.errorContainer,
                padding: 8,
                borderRadius: 6,
                marginBottom: 8,
              }}
            >
              <Text
                variant="labelSmall"
                style={{
                  color: theme.colors.onErrorContainer,
                  fontWeight: '600',
                  marginBottom: 4,
                }}
              >
                Antes:
              </Text>
              <Text
                variant="bodySmall"
                style={{ color: theme.colors.onErrorContainer }}
              >
                {String(change.anterior)}
              </Text>
            </View>
            <View
              style={{
                backgroundColor: theme.colors.primaryContainer,
                padding: 8,
                borderRadius: 6,
              }}
            >
              <Text
                variant="labelSmall"
                style={{
                  color: theme.colors.onPrimaryContainer,
                  fontWeight: '600',
                  marginBottom: 4,
                }}
              >
                Despu√©s:
              </Text>
              <Text
                variant="bodySmall"
                style={{ color: theme.colors.onPrimaryContainer }}
              >
                {String(change.nuevo)}
              </Text>
            </View>
          </View>
        );
      }
      // Formato horizontal para cambios cortos
      return (
        <View style={styles.changeDetail}>
          <View
            style={{
              backgroundColor: theme.colors.errorContainer,
              paddingHorizontal: 6,
              paddingVertical: 2,
              borderRadius: 4,
              marginRight: 6,
            }}
          >
            <Text
              variant="labelSmall"
              style={{
                color: theme.colors.onErrorContainer,
                fontWeight: '500',
              }}
            >
              {String(change.anterior)}
            </Text>
          </View>
          <Icon
            name="arrow-right"
            size={16}
            color={theme.colors.onSurfaceVariant}
            style={{ marginHorizontal: 4 }}
          />
          <View
            style={{
              backgroundColor: theme.colors.primaryContainer,
              paddingHorizontal: 6,
              paddingVertical: 2,
              borderRadius: 4,
            }}
          >
            <Text
              variant="labelSmall"
              style={{
                color: theme.colors.onPrimaryContainer,
                fontWeight: '500',
              }}
            >
              {String(change.nuevo)}
            </Text>
          </View>
        </View>
      );
    } else if (Array.isArray(change) && change.length === 2) {
      // Para el formato de array [antes, despu√©s] - usado en cambios de orden
      const oldVal = formatValue(fieldName || '', change[0]);
      const newVal = formatValue(fieldName || '', change[1]);
      // Para campos largos o especiales, usar formato vertical
      if (
        fieldName &&
        ['notes', 'deliveryInfo', 'customerName', 'deliveryAddress'].includes(
          fieldName,
        )
      ) {
        return (
          <View style={{ marginTop: 4 }}>
            <View
              style={{
                backgroundColor: theme.colors.errorContainer,
                padding: 8,
                borderRadius: 6,
                marginBottom: 8,
              }}
            >
              <Text
                variant="labelSmall"
                style={{
                  color: theme.colors.onErrorContainer,
                  fontWeight: '600',
                  marginBottom: 4,
                }}
              >
                Antes:
              </Text>
              <Text
                variant="bodySmall"
                style={{ color: theme.colors.onErrorContainer }}
              >
                {oldVal}
              </Text>
            </View>
            <View
              style={{
                backgroundColor: theme.colors.primaryContainer,
                padding: 8,
                borderRadius: 6,
              }}
            >
              <Text
                variant="labelSmall"
                style={{
                  color: theme.colors.onPrimaryContainer,
                  fontWeight: '600',
                  marginBottom: 4,
                }}
              >
                Despu√©s:
              </Text>
              <Text
                variant="bodySmall"
                style={{ color: theme.colors.onPrimaryContainer }}
              >
                {newVal}
              </Text>
            </View>
          </View>
        );
      }
      // Formato horizontal para cambios cortos
      return (
        <View style={styles.changeDetail}>
          <View
            style={{
              backgroundColor: theme.colors.errorContainer,
              paddingHorizontal: 8,
              paddingVertical: 4,
              borderRadius: 4,
              marginRight: 6,
            }}
          >
            <Text
              variant="labelSmall"
              style={{
                color: theme.colors.onErrorContainer,
                fontWeight: '500',
              }}
            >
              {oldVal}
            </Text>
          </View>
          <Icon
            name="arrow-right"
            size={16}
            color={theme.colors.onSurfaceVariant}
            style={{ marginHorizontal: 4 }}
          />
          <View
            style={{
              backgroundColor: theme.colors.primaryContainer,
              paddingHorizontal: 8,
              paddingVertical: 4,
              borderRadius: 4,
            }}
          >
            <Text
              variant="labelSmall"
              style={{
                color: theme.colors.onPrimaryContainer,
                fontWeight: '500',
              }}
            >
              {newVal}
            </Text>
          </View>
        </View>
      );
    }
    return null;
  };

  return (
    <Surface
      style={[
        styles.historyItem,
        { backgroundColor: theme.colors.surfaceVariant },
      ]}
      elevation={1}
    >
      <TouchableOpacity
        onPress={() => setExpanded(!expanded)}
        activeOpacity={0.7}
      >
        <View style={styles.historyHeader}>
          <View style={{ flex: 1, marginRight: 12 }}>
            <View
              style={{
                flexDirection: 'row',
                alignItems: 'center',
                marginBottom: 4,
              }}
            >
              <Avatar.Icon
                size={24}
                icon={getOperationIcon(item.operation, item.type)}
                style={{
                  backgroundColor:
                    item.type === 'order'
                      ? theme.colors.primary
                      : theme.colors.secondary,
                  marginRight: 6,
                }}
              />
              <Text
                variant="bodySmall"
                style={{ fontWeight: '600', flex: 1 }}
                numberOfLines={1}
              >
                {item.changedByUser
                  ? `${item.changedByUser.firstName} ${item.changedByUser.lastName}`
                  : item.user
                    ? `${item.user.firstName} ${item.user.lastName}`
                    : 'Sistema'}
              </Text>
              <View
                style={{
                  width: 32,
                  height: 32,
                  borderRadius: 16,
                  backgroundColor: theme.colors.surfaceVariant,
                  alignItems: 'center',
                  justifyContent: 'center',
                }}
              >
                <Icon
                  name={expanded ? 'chevron-up' : 'chevron-down'}
                  size={20}
                  color={theme.colors.onSurfaceVariant}
                />
              </View>
            </View>
            <View
              style={{
                flexDirection: 'row',
                alignItems: 'center',
                flexWrap: 'wrap',
                gap: 4,
              }}
            >
              <View
                style={{
                  flexDirection: 'row',
                  alignItems: 'center',
                  backgroundColor:
                    (item.type === 'order'
                      ? theme.colors.primary
                      : theme.colors.secondary) + '15',
                  paddingHorizontal: 5,
                  paddingVertical: 1,
                  borderRadius: 10,
                }}
              >
                <Icon
                  name={getOperationIcon(item.operation, item.type)}
                  size={10}
                  color={
                    item.type === 'order'
                      ? theme.colors.primary
                      : theme.colors.secondary
                  }
                  style={{ marginRight: 3 }}
                />
                <Text
                  style={{
                    color:
                      item.type === 'order'
                        ? theme.colors.primary
                        : theme.colors.secondary,
                    fontSize: 9,
                    fontWeight: '600',
                  }}
                >
                  {getOperationLabel(item.operation, item.type)}
                </Text>
              </View>
              {item.preparationStatus && (
                <Chip
                  mode="flat"
                  textStyle={{ fontSize: 9 }}
                  style={{
                    backgroundColor:
                      getStatusColor(item.preparationStatus, theme) + '20',
                    transform: [{ scale: 0.8 }],
                    height: 20,
                  }}
                  compact
                >
                  {formatValue('preparationStatus', item.preparationStatus)}
                </Chip>
              )}
              <Text variant="labelSmall" style={{ opacity: 0.6, fontSize: 10 }}>
                {format(new Date(item.changedAt), 'dd/MM/yyyy HH:mm', {
                  locale: es,
                })}
              </Text>
            </View>
          </View>
        </View>
      </TouchableOpacity>
      {expanded && (
        <View style={styles.expandedContent}>
          <Divider style={{ marginBottom: 8 }} />
          {/* Contenido para √≥rdenes */}
          {item.type === 'order' && (
            <View style={styles.changesContainer}>
              {item.operation === 'INSERT' && (
                <>
                  {/* Si hay diff consolidado para INSERT, usarlo */}
                  {item.diff && (item.diff.order || item.diff.items) ? (
                    <>
                      {item.diff.summary && (
                        <Text
                          variant="bodySmall"
                          style={{
                            color: theme.colors.primary,
                            fontWeight: '600',
                            marginBottom: 8,
                            fontStyle: 'italic',
                          }}
                        >
                          {item.diff.summary}
                        </Text>
                      )}

                      {/* Informaci√≥n de la orden */}
                      {item.diff.order && (
                        <View
                          style={{
                            backgroundColor: theme.colors.surface,
                            padding: 8,
                            borderRadius: 6,
                            marginBottom: 8,
                          }}
                        >
                          <Text
                            variant="labelSmall"
                            style={{
                              color: theme.colors.primary,
                              fontWeight: '600',
                              marginBottom: 6,
                            }}
                          >
                            Detalles de la orden:
                          </Text>

                          {item.diff.order.fields?.orderType && (
                            <Text
                              variant="bodySmall"
                              style={{ marginBottom: 4 }}
                            >
                              <Text style={{ fontWeight: '600' }}>Tipo:</Text>{' '}
                              {formatValue(
                                'orderType',
                                item.diff.order.fields.orderType[1],
                              )}
                            </Text>
                          )}
                          {item.diff.order.fields?.tableId && (
                            <Text
                              variant="bodySmall"
                              style={{ marginBottom: 4 }}
                            >
                              <Text style={{ fontWeight: '600' }}>Mesa:</Text>{' '}
                              {item.snapshot?.table?.name ||
                                `Mesa ${item.diff.order.fields.tableId[1]}`}
                            </Text>
                          )}
                          {item.diff.order.fields?.notes && (
                            <Text
                              variant="bodySmall"
                              style={{ marginBottom: 4 }}
                            >
                              <Text style={{ fontWeight: '600' }}>Notas:</Text>{' '}
                              {item.diff.order.fields.notes[1]}
                            </Text>
                          )}

                          {/* Informaci√≥n de entrega */}
                          {item.diff.order.deliveryInfo && (
                            <>
                              {item.diff.order.deliveryInfo.recipientName && (
                                <Text
                                  variant="bodySmall"
                                  style={{ marginBottom: 4 }}
                                >
                                  <Text style={{ fontWeight: '600' }}>
                                    Cliente:
                                  </Text>{' '}
                                  {
                                    item.diff.order.deliveryInfo
                                      .recipientName[1]
                                  }
                                </Text>
                              )}
                              {item.diff.order.deliveryInfo.recipientPhone && (
                                <Text
                                  variant="bodySmall"
                                  style={{ marginBottom: 4 }}
                                >
                                  <Text style={{ fontWeight: '600' }}>
                                    Tel√©fono:
                                  </Text>{' '}
                                  {
                                    item.diff.order.deliveryInfo
                                      .recipientPhone[1]
                                  }
                                </Text>
                              )}
                              {item.diff.order.deliveryInfo.fullAddress && (
                                <Text
                                  variant="bodySmall"
                                  style={{ marginBottom: 4 }}
                                >
                                  <Text style={{ fontWeight: '600' }}>
                                    Direcci√≥n:
                                  </Text>{' '}
                                  {item.diff.order.deliveryInfo.fullAddress[1]}
                                </Text>
                              )}
                            </>
                          )}
                        </View>
                      )}

                      {/* Productos agregados */}
                      {item.diff.items?.added &&
                        item.diff.items.added.length > 0 && (
                          <>
                            <Text
                              variant="labelSmall"
                              style={{
                                color: theme.colors.primary,
                                fontWeight: '600',
                                marginBottom: 8,
                                marginTop: 8,
                              }}
                            >
                              Productos incluidos en la orden:
                            </Text>
                            {item.diff.items.added.map(
                              (addedItem: any, idx: number) => (
                                <View
                                  key={`added-${idx}`}
                                  style={{
                                    marginBottom: 8,
                                    paddingLeft: 8,
                                    borderLeftWidth: 2,
                                    borderLeftColor:
                                      theme.colors.primary + '50',
                                    backgroundColor: theme.colors.surface,
                                    padding: 8,
                                    marginLeft: 4,
                                    borderRadius: 4,
                                  }}
                                >
                                  <Text
                                    variant="bodySmall"
                                    style={{ fontWeight: '600' }}
                                  >
                                    {addedItem.productName}
                                    {addedItem.variantName
                                      ? ` - ${addedItem.variantName}`
                                      : ''}
                                  </Text>
                                  {addedItem.modifiers?.length > 0 && (
                                    <Text
                                      variant="labelSmall"
                                      style={{
                                        marginTop: 2,
                                        color: theme.colors.onSurfaceVariant,
                                      }}
                                    >
                                      Modificadores:{' '}
                                      {addedItem.modifiers.join(', ')}
                                    </Text>
                                  )}
                                  {addedItem.customizations?.length > 0 && (
                                    <Text
                                      variant="labelSmall"
                                      style={{
                                        marginTop: 2,
                                        color: theme.colors.onSurfaceVariant,
                                      }}
                                    >
                                      Personalizaciones:{' '}
                                      {addedItem.customizations.join(', ')}
                                    </Text>
                                  )}
                                  {addedItem.notes && (
                                    <Text
                                      variant="labelSmall"
                                      style={{
                                        marginTop: 2,
                                        fontStyle: 'italic',
                                      }}
                                    >
                                      Notas: {addedItem.notes}
                                    </Text>
                                  )}
                                  <Text
                                    variant="labelSmall"
                                    style={{
                                      marginTop: 4,
                                      color: theme.colors.primary,
                                      fontWeight: '600',
                                    }}
                                  >
                                    Precio: $
                                    {addedItem.finalPrice ||
                                      addedItem.basePrice}
                                  </Text>
                                </View>
                              ),
                            )}
                          </>
                        )}
                    </>
                  ) : item.formattedChanges ? (
                    // Si hay formattedChanges (formato nuevo)
                    Object.entries(item.formattedChanges).map(
                      ([section, changes]) => {
                        if (section === 'Resumen') {
                          return (
                            <Text
                              key={section}
                              variant="bodySmall"
                              style={{
                                color: theme.colors.primary,
                                fontWeight: '600',
                                marginBottom: 8,
                                fontStyle: 'italic',
                              }}
                            >
                              {changes as string}
                            </Text>
                          );
                        }
                        return (
                          <View key={section} style={{ marginBottom: 12 }}>
                            <Text
                              variant="labelSmall"
                              style={{
                                color: theme.colors.primary,
                                fontWeight: '600',
                                marginBottom: 6,
                              }}
                            >
                              {section}:
                            </Text>
                            {typeof changes === 'object' &&
                              Object.entries(changes).map(([field, change]) => (
                                <View
                                  key={field}
                                  style={{ marginBottom: 4, marginLeft: 8 }}
                                >
                                  <Text
                                    variant="labelSmall"
                                    style={{
                                      color: theme.colors.onSurfaceVariant,
                                      marginBottom: 2,
                                    }}
                                  >
                                    {field}:
                                  </Text>
                                  {renderChangeDetail(change, field)}
                                </View>
                              ))}
                          </View>
                        );
                      },
                    )
                  ) : (
                    // Formato original (legacy)
                    <Text
                      variant="bodySmall"
                      style={{ fontWeight: '600', marginBottom: 8 }}
                    >
                      Nueva orden creada
                      {item.snapshot?.orderType &&
                        ` - ${formatValue('orderType', item.snapshot.orderType)}`}
                    </Text>
                  )}
                </>
              )}

              {item.operation === 'UPDATE' &&
                (() => {
                  // Para formato nuevo con formattedChanges
                  if (item.formattedChanges) {
                    return Object.entries(item.formattedChanges).map(
                      ([section, changes]) => {
                        if (section === 'Resumen') {
                          return (
                            <Text
                              key={section}
                              variant="bodySmall"
                              style={{
                                color: theme.colors.primary,
                                fontWeight: '600',
                                marginBottom: 8,
                                fontStyle: 'italic',
                              }}
                            >
                              {changes as string}
                            </Text>
                          );
                        }
                        return (
                          <View key={section} style={{ marginBottom: 12 }}>
                            <Text
                              variant="labelSmall"
                              style={{
                                color: theme.colors.primary,
                                fontWeight: '600',
                                marginBottom: 6,
                              }}
                            >
                              {section}:
                            </Text>
                            {typeof changes === 'object' &&
                              Object.entries(changes).map(([field, change]) => (
                                <View
                                  key={field}
                                  style={{ marginBottom: 4, marginLeft: 8 }}
                                >
                                  <Text
                                    variant="labelSmall"
                                    style={{
                                      color: theme.colors.onSurfaceVariant,
                                      marginBottom: 2,
                                    }}
                                  >
                                    {field}:
                                  </Text>
                                  {renderChangeDetail(change, field)}
                                </View>
                              ))}
                          </View>
                        );
                      },
                    );
                  }

                  // Para formato con diff
                  if (item.diff) {
                    return (
                      <>
                        {item.diff.summary && (
                          <Text
                            variant="bodySmall"
                            style={{
                              color: theme.colors.primary,
                              fontWeight: '600',
                              marginBottom: 8,
                              fontStyle: 'italic',
                            }}
                          >
                            {item.diff.summary}
                          </Text>
                        )}
                        {item.diff.order?.fields &&
                          Object.entries(item.diff.order.fields).map(
                            ([field, values]) => (
                              <View key={field} style={{ marginBottom: 8 }}>
                                <Text
                                  variant="labelSmall"
                                  style={{
                                    color: theme.colors.onSurfaceVariant,
                                    fontWeight: '600',
                                    marginBottom: 4,
                                  }}
                                >
                                  {formatFieldName(field)}:
                                </Text>
                                {renderChangeDetail(values, field)}
                              </View>
                            ),
                          )}
                      </>
                    );
                  }

                  // Formato legacy
                  const relevantChanges = Object.entries(item.snapshot || {})
                    .filter(([field]) =>
                      [
                        'orderStatus',
                        'orderType',
                        'tableId',
                        'notes',
                        'deliveryInfo',
                        'estimatedDeliveryTime',
                        'scheduledAt',
                        'customerId',
                      ].includes(field),
                    )
                    .map(([field, value]) => ({ field, change: value }));

                  if (relevantChanges.length === 0) {
                    return (
                      <Text
                        variant="bodySmall"
                        style={{ color: theme.colors.onSurfaceVariant }}
                      >
                        Actualizaci√≥n de productos de la orden
                      </Text>
                    );
                  }

                  return (
                    <>
                      <Text
                        variant="bodySmall"
                        style={{
                          color: theme.colors.primary,
                          fontWeight: '600',
                          marginBottom: 8,
                        }}
                      >
                        Cambios en la orden:
                      </Text>
                      {relevantChanges.map(({ field, change }) => (
                        <View key={field} style={{ marginBottom: 8 }}>
                          <Text
                            variant="labelSmall"
                            style={{
                              color: theme.colors.onSurfaceVariant,
                              fontWeight: '600',
                              marginBottom: 4,
                              textTransform: 'capitalize',
                            }}
                          >
                            {formatFieldName(field)}:
                          </Text>
                          {renderChangeDetail(change, field)}
                        </View>
                      ))}
                    </>
                  );
                })()}

              {item.operation === 'DELETE' && (
                <Text variant="bodySmall" style={{ color: theme.colors.error }}>
                  La orden fue eliminada
                </Text>
              )}
            </View>
          )}

          {/* Contenido consolidado nuevo formato */}
          {item.diff &&
            (item.diff.order || item.diff.items || item.diff.summary) && (
              <View style={styles.changesContainer}>
                {/* Resumen de cambios */}
                {item.diff.summary && (
                  <Text
                    variant="bodySmall"
                    style={{
                      color: theme.colors.primary,
                      fontWeight: '600',
                      marginBottom: 8,
                      fontStyle: 'italic',
                    }}
                  >
                    {item.diff.summary}
                  </Text>
                )}

                {/* Cambios en items (agregados/modificados/eliminados) */}
                {item.diff.items && (
                  <>
                    {item.diff.items.added?.length > 0 && (
                      <>
                        <Text
                          variant="labelSmall"
                          style={{
                            color: theme.colors.success,
                            fontWeight: '600',
                            marginBottom: 6,
                          }}
                        >
                          Productos agregados:
                        </Text>
                        {item.diff.items.added.map(
                          (addedItem: any, idx: number) => (
                            <View
                              key={`added-${idx}`}
                              style={{
                                marginBottom: 8,
                                paddingLeft: 8,
                                borderLeftWidth: 2,
                                borderLeftColor: theme.colors.success + '50',
                                backgroundColor: theme.colors.surface,
                                padding: 8,
                                marginLeft: 4,
                                borderRadius: 4,
                              }}
                            >
                              <Text
                                variant="bodySmall"
                                style={{ fontWeight: '600' }}
                              >
                                {addedItem.productName}
                                {addedItem.variantName
                                  ? ` - ${addedItem.variantName}`
                                  : ''}
                              </Text>
                              {(addedItem.modifiers?.length > 0 ||
                                addedItem.customizations?.length > 0 ||
                                addedItem.notes) && (
                                <Text
                                  variant="labelSmall"
                                  style={{
                                    marginTop: 2,
                                    color: theme.colors.onSurfaceVariant,
                                  }}
                                >
                                  {[
                                    addedItem.modifiers?.length > 0 &&
                                      `Modificadores: ${addedItem.modifiers.join(', ')}`,
                                    addedItem.customizations?.length > 0 &&
                                      `Personalizaciones: ${addedItem.customizations.join(', ')}`,
                                    addedItem.notes &&
                                      `Notas: ${addedItem.notes}`,
                                  ]
                                    .filter(Boolean)
                                    .join(' ‚Ä¢ ')}
                                </Text>
                              )}
                              <Text
                                variant="labelSmall"
                                style={{
                                  marginTop: 4,
                                  color: theme.colors.primary,
                                  fontWeight: '600',
                                }}
                              >
                                Precio: $
                                {addedItem.finalPrice || addedItem.basePrice}
                              </Text>
                            </View>
                          ),
                        )}
                      </>
                    )}

                    {item.diff.items.removed?.length > 0 && (
                      <>
                        <Text
                          variant="labelSmall"
                          style={{
                            color: theme.colors.error,
                            fontWeight: '600',
                            marginBottom: 6,
                            marginTop: 8,
                          }}
                        >
                          Productos eliminados:
                        </Text>
                        {item.diff.items.removed.map(
                          (removedItem: any, idx: number) => (
                            <View
                              key={`removed-${idx}`}
                              style={{
                                marginBottom: 8,
                                paddingLeft: 8,
                                borderLeftWidth: 2,
                                borderLeftColor: theme.colors.error + '50',
                                backgroundColor: theme.colors.surface,
                                padding: 8,
                                marginLeft: 4,
                                borderRadius: 4,
                              }}
                            >
                              <Text
                                variant="bodySmall"
                                style={{
                                  textDecorationLine: 'line-through',
                                  color: theme.colors.error,
                                }}
                              >
                                {removedItem.productName}
                                {removedItem.variantName
                                  ? ` - ${removedItem.variantName}`
                                  : ''}
                              </Text>
                            </View>
                          ),
                        )}
                      </>
                    )}

                    {item.diff.items.modified?.length > 0 && (
                      <>
                        <Text
                          variant="labelSmall"
                          style={{
                            color: theme.colors.warning || theme.colors.primary,
                            fontWeight: '600',
                            marginBottom: 6,
                            marginTop: 8,
                          }}
                        >
                          Productos modificados:
                        </Text>
                        {item.diff.items.modified.map(
                          (modifiedItem: any, idx: number) => (
                            <View
                              key={`modified-${idx}`}
                              style={{
                                marginBottom: 8,
                                paddingLeft: 8,
                                borderLeftWidth: 2,
                                borderLeftColor:
                                  (theme.colors.warning ||
                                    theme.colors.primary) + '50',
                                backgroundColor: theme.colors.surface,
                                padding: 8,
                                marginLeft: 4,
                                borderRadius: 4,
                              }}
                            >
                              <Text
                                variant="bodySmall"
                                style={{ fontWeight: '600' }}
                              >
                                {modifiedItem.productName}
                                {modifiedItem.variantName
                                  ? ` - ${modifiedItem.variantName}`
                                  : ''}
                              </Text>
                              {modifiedItem.changes &&
                                Object.entries(modifiedItem.changes).map(
                                  ([field, change]: [string, any]) => (
                                    <View key={field} style={{ marginTop: 4 }}>
                                      <Text
                                        variant="labelSmall"
                                        style={{
                                          color: theme.colors.onSurfaceVariant,
                                        }}
                                      >
                                        {formatFieldName(field)}:
                                      </Text>
                                      {renderChangeDetail(change, field)}
                                    </View>
                                  ),
                                )}
                            </View>
                          ),
                        )}
                      </>
                    )}
                  </>
                )}
              </View>
            )}

          {/* Contenido para items individuales */}
          {item.type === 'item' && (
            <View style={styles.changesContainer}>
              {item.operation === 'INSERT' && (
                <Text
                  variant="bodySmall"
                  style={{ color: theme.colors.success, marginBottom: 8 }}
                >
                  Item agregado:
                </Text>
              )}
              {item.operation === 'UPDATE' && item.formattedChanges && (
                <>
                  <Text
                    variant="bodySmall"
                    style={{
                      color: theme.colors.primary,
                      fontWeight: '600',
                      marginBottom: 8,
                    }}
                  >
                    Cambios en el item:
                  </Text>
                  {Object.entries(item.formattedChanges).map(
                    ([field, change]) => (
                      <View key={field} style={{ marginBottom: 8 }}>
                        <Text
                          variant="labelSmall"
                          style={{
                            color: theme.colors.onSurfaceVariant,
                            fontWeight: '600',
                            marginBottom: 4,
                          }}
                        >
                          {field}:
                        </Text>
                        {renderChangeDetail(change, field)}
                      </View>
                    ),
                  )}
                </>
              )}
              {item.operation === 'DELETE' && (
                <Text
                  variant="bodySmall"
                  style={{ color: theme.colors.error, marginBottom: 8 }}
                >
                  Item eliminado:
                </Text>
              )}
              {/* Mostrar la descripci√≥n del item para INSERT y DELETE */}
              {(item.operation === 'INSERT' || item.operation === 'DELETE') &&
                item.itemDescription && (
                  <Text
                    variant="bodySmall"
                    style={{
                      color: theme.colors.onSurface,
                      backgroundColor: theme.colors.surface,
                      padding: 8,
                      borderRadius: 6,
                    }}
                  >
                    {item.itemDescription}
                  </Text>
                )}
            </View>
          )}

          {/* Contenido para batch de items */}
          {item.operation === 'BATCH' && item.batchOperations && (
            <View style={styles.changesContainer}>
              <Text
                variant="bodySmall"
                style={{
                  color: theme.colors.primary,
                  fontWeight: '600',
                  marginBottom: 8,
                }}
              >
                Cambios realizados en una sola edici√≥n:
              </Text>
              {item.batchOperations.map((op: any, idx: number) => (
                <View
                  key={idx}
                  style={{
                    marginBottom:
                      idx < item.batchOperations!.length - 1 ? 12 : 0,
                    paddingLeft: 8,
                    borderLeftWidth: 2,
                    borderLeftColor: theme.colors.primary + '30',
                    marginLeft: 4,
                  }}
                >
                  <View
                    style={{
                      flexDirection: 'row',
                      alignItems: 'flex-start',
                      marginBottom: 4,
                    }}
                  >
                    <Icon
                      name={getOperationIcon(op.operation)}
                      size={14}
                      color={theme.colors.primary}
                      style={{ marginRight: 6, marginTop: 2 }}
                    />
                    <View style={{ flex: 1 }}>
                      <Text
                        variant="labelSmall"
                        style={{
                          color: theme.colors.primary,
                          fontWeight: '500',
                          marginBottom: 4,
                        }}
                      >
                        {getOperationLabel(op.operation)}
                      </Text>

                      {/* Mostrar descripci√≥n del item */}
                      {(op.itemDescription || op.snapshot?.itemDescription) && (
                        <Text
                          variant="bodySmall"
                          style={{
                            color: theme.colors.onSurface,
                            backgroundColor: theme.colors.surface,
                            padding: 6,
                            borderRadius: 4,
                          }}
                        >
                          {op.itemDescription || op.snapshot?.itemDescription}
                        </Text>
                      )}

                      {/* Para UPDATE, mostrar el cambio */}
                      {op.operation === 'UPDATE' && op.formattedChanges && (
                        <View style={{ marginTop: 4 }}>
                          {Object.entries(op.formattedChanges)
                            .filter(([fieldName]) => {
                              // Solo mostrar campos relevantes (no precios)
                              const allowedFields = [
                                'Descripci√≥n del Item',
                                'Descripci√≥n',
                                'Estado',
                                'Notas de preparaci√≥n',
                                'Estado de preparaci√≥n',
                              ];
                              return allowedFields.some((allowed) =>
                                fieldName.includes(allowed),
                              );
                            })
                            .map(([field, change]) => (
                              <View key={field} style={{ marginBottom: 4 }}>
                                <Text
                                  variant="labelSmall"
                                  style={{
                                    color: theme.colors.onSurfaceVariant,
                                    fontSize: 11,
                                  }}
                                >
                                  {field}:
                                </Text>
                                {renderChangeDetail(change, field)}
                              </View>
                            ))}
                        </View>
                      )}
                    </View>
                  </View>
                </View>
              ))}
            </View>
          )}
        </View>
      )}
    </Surface>
  );
};

export const OrderHistoryView: React.FC<OrderHistoryViewProps> = ({
  orderId,
  orderNumber,
  onBack,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);

  // Query combinado para obtener ambos historiales
  const {
    data: historyData,
    isError,
    refetch,
    isLoading,
  } = useQuery({
    queryKey: ['combinedHistory', orderId],
    queryFn: async () => {
      if (!orderId) throw new Error('No order ID');

      // Obtener historial consolidado de la orden
      const orderHistoryResponse = await apiClient.get(
        API_PATHS.ORDERS_HISTORY.replace(':orderId', orderId),
        {
          page: 1,
          limit: 100,
        },
      );

      const orderHistory =
        orderHistoryResponse.ok && orderHistoryResponse.data?.data
          ? orderHistoryResponse.data.data.map((item: any) => ({
              ...item,
              type: 'order' as const,
            }))
          : [];

      return orderHistory;
    },
    enabled: !!orderId,
    staleTime: 30000,
  });

  const renderHistoryItem = ({ item }: { item: HistoryItem }) => {
    return <HistoryItemComponent item={item} theme={theme} />;
  };

  const renderEmpty = () => (
    <View style={styles.emptyContainer}>
      <Icon
        name="history"
        size={48}
        color={theme.colors.onSurfaceDisabled}
        style={{ opacity: 0.5 }}
      />
      <Text
        variant="bodyLarge"
        style={{
          color: theme.colors.onSurfaceDisabled,
          marginTop: theme.spacing.m,
        }}
      >
        No hay historial disponible
      </Text>
      <Text
        variant="bodySmall"
        style={{
          color: theme.colors.onSurfaceVariant,
          marginTop: theme.spacing.s,
          textAlign: 'center',
        }}
      >
        Los cambios realizados en esta orden aparecer√°n aqu√≠
      </Text>
    </View>
  );

  return (
    <View style={styles.container}>
      <Appbar.Header style={styles.header}>
        <Appbar.BackAction onPress={onBack} />
        <Appbar.Content
          title={`Historial de Orden #${orderNumber || ''}`}
          subtitle={`${historyData?.length || 0} cambios registrados`}
        />
      </Appbar.Header>

      <View style={styles.content}>
        {isError ? (
          <View style={styles.emptyContainer}>
            <Icon
              name="alert-circle"
              size={48}
              color={theme.colors.error}
              style={{ opacity: 0.7 }}
            />
            <Text
              variant="bodyLarge"
              style={{
                color: theme.colors.error,
                marginTop: theme.spacing.m,
                textAlign: 'center',
              }}
            >
              Error al cargar el historial
            </Text>
            <Button
              onPress={() => refetch()}
              mode="text"
              style={{ marginTop: 16 }}
            >
              Reintentar
            </Button>
          </View>
        ) : isLoading ? (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
            <Text style={styles.loadingText}>Cargando historial...</Text>
          </View>
        ) : (
          <FlatList
            data={historyData || []}
            renderItem={renderHistoryItem}
            keyExtractor={(item) => item.id.toString()}
            contentContainerStyle={styles.listContent}
            ListEmptyComponent={renderEmpty}
            showsVerticalScrollIndicator={false}
          />
        )}
      </View>
    </View>
  );
};

const createStyles = (theme: ReturnType<typeof useAppTheme>) => {
  return StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    header: {
      backgroundColor: theme.colors.surface,
      elevation: 2,
    },
    content: {
      flex: 1,
    },
    listContent: {
      padding: theme.spacing.m,
      paddingBottom: theme.spacing.xl * 2,
    },
    loadingContainer: {
      flex: 1,
      padding: theme.spacing.xl,
      alignItems: 'center',
      justifyContent: 'center',
    },
    loadingText: {
      marginTop: theme.spacing.m,
      color: theme.colors.onSurfaceVariant,
    },
    historyItem: {
      padding: theme.spacing.s,
      marginBottom: theme.spacing.s,
      marginHorizontal: theme.spacing.xs,
      borderRadius: theme.roundness * 2,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 1 },
      shadowOpacity: 0.05,
      shadowRadius: 2,
      elevation: 2,
    },
    historyHeader: {
      // Estructura vertical para evitar encimamiento
    },
    expandedContent: {
      marginTop: theme.spacing.s,
      paddingTop: theme.spacing.s,
    },
    changesContainer: {
      marginTop: theme.spacing.xs,
    },
    changeDetail: {
      flexDirection: 'row',
      alignItems: 'center',
      marginTop: 4,
      flexWrap: 'wrap',
    },
    emptyContainer: {
      flex: 1,
      alignItems: 'center',
      justifyContent: 'center',
      padding: theme.spacing.xl,
    },
  });
};

================
File: app/src/modules/shiftAudit/hooks/useShiftSalesSummary.ts
================
import { useQuery } from '@tanstack/react-query';
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';

export interface ProductSalesSummary {
  productId: string;
  productName: string;
  quantity: number;
  totalAmount: number;
  averagePrice: number;
}

export interface SubcategorySalesSummary {
  subcategoryId: string;
  subcategoryName: string;
  quantity: number;
  totalAmount: number;
  products: ProductSalesSummary[];
}

export interface CategorySalesSummary {
  categoryId: string;
  categoryName: string;
  quantity: number;
  totalAmount: number;
  percentage: number;
  subcategories: SubcategorySalesSummary[];
}

export interface ShiftSalesSummary {
  shiftId: string;
  shiftNumber: number;
  date: string;
  totalSales: number;
  totalQuantity: number;
  completedOrders: number;
  averageTicket: number;
  categories: CategorySalesSummary[];
  topProducts: ProductSalesSummary[];
  startTime: string;
  endTime: string | null;
}

export function useShiftSalesSummary(shiftId: string | null) {
  return useQuery({
    queryKey: ['shiftSalesSummary', shiftId],
    queryFn: async () => {
      if (!shiftId) return null;

      const response = await apiClient.get(
        API_PATHS.ORDERS_BY_SHIFT_SALES_SUMMARY.replace(':shiftId', shiftId),
      );

      if (!response.ok) {
        throw new Error(
          response.problem || 'Error al obtener resumen de ventas',
        );
      }

      return response.data as ShiftSalesSummary;
    },
    enabled: !!shiftId,
  });
}

================
File: app/src/modules/users/screens/UsersListScreen.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Portal, Chip, Text } from 'react-native-paper';
import { useDrawerStatus } from '@react-navigation/drawer';
import GenericList from '@/app/components/crud/GenericList';
import { UserFormModal } from '../components/UserFormModal';
import { UserDetailModal } from '../components/UserDetailModal';
import { useListState } from '@/app/hooks/useListState';
import { useCrudScreenLogic } from '@/app/hooks/useCrudScreenLogic';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useGetUsers, useDeleteUser } from '../hooks';
import type { User, UsersQuery } from '../types';
import { RoleEnum } from '../types';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';

export function UsersListScreen() {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const drawerStatus = useDrawerStatus();
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedFilter, setSelectedFilter] = useState('all');
  const [isRefreshing, setIsRefreshing] = useState(false);

  const deleteUserMutation = useDeleteUser();

  const {
    isFormModalVisible,
    isDetailModalVisible,
    selectedItem,
    editingItem,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
  } = useCrudScreenLogic<User>({
    entityName: 'Usuario',
    queryKey: ['users'],
    deleteMutationFn: async (id) => {
      await deleteUserMutation.mutateAsync(id);
    },
  });

  const queryParams: UsersQuery = {
    page: 1,
    limit: 100,
    search: searchQuery || undefined,
    filters:
      selectedFilter === 'all'
        ? undefined
        : selectedFilter === 'active'
          ? { isActive: true }
          : selectedFilter === 'inactive'
            ? { isActive: false }
            : selectedFilter === 'admin'
              ? { roles: [{ id: RoleEnum.ADMIN }] }
              : selectedFilter === 'user'
                ? { roles: [{ id: RoleEnum.WAITER }] }
                : undefined,
    sortBy: 'createdAt',
    sortOrder: 'DESC',
  };

  const { data, isLoading, error, refetch } = useGetUsers(queryParams);

  // Recargar autom√°ticamente cuando la pantalla recibe foco
  useRefreshModuleOnFocus('users');

  // Funciones auxiliares definidas antes del useMemo
  const getStatusColor = (user: User) => {
    return user.isActive ? 'success' : 'error';
  };

  const getStatusText = (user: User) => {
    return user.isActive ? 'Activo' : 'Inactivo';
  };

  const getUserDescription = (user: User) => {
    const parts = [];

    // Mostrar username primero
    parts.push(`@${user.username}`);

    // Luego el email en una nueva l√≠nea si existe
    if (user.email) {
      parts.push(`\n${user.email}`);
    }

    // Si es usuario de cocina y tiene pantalla asignada, mostrarla
    if (user.role?.id === 5 && user.preparationScreen) {
      parts.push(`\nPantalla: ${user.preparationScreen.name}`);
    }

    return parts.join('');
  };

  // Mapear los usuarios para agregar campos calculados
  const mappedUsers = React.useMemo(() => {
    const users = data?.data || [];

    return users.map((user) => {
      const displayName =
        `${user.firstName || ''} ${user.lastName || ''}`.trim() ||
        user.username;
      const displayInfo = getUserDescription(user);

      return {
        ...user,
        displayName,
        displayInfo,
        displayNameWithRole: { name: displayName, roleId: user.role?.id },
        statusText: getStatusText(user),
        statusColor: getStatusColor(user),
      };
    });
  }, [data]);

  const handleCreateUser = () => {
    handleOpenCreateModal();
  };

  const { ListEmptyComponent } = useListState({
    isLoading,
    isError: error ? true : false,
    data: mappedUsers,
    emptyConfig: {
      title: 'No hay usuarios',
      message: 'No hay usuarios registrados en el sistema',
      icon: 'account-multiple-outline',
      actionLabel: 'Agregar usuario',
      onAction: handleCreateUser,
    },
    errorConfig: {
      title: 'Error al cargar usuarios',
      message: 'No se pudieron cargar los usuarios. Verifica tu conexi√≥n.',
      icon: 'alert-circle-outline',
      onAction: refetch,
    },
  });

  const filterOptions = [
    { label: 'Todos', value: 'all' },
    { label: 'Activos', value: 'active' },
    { label: 'Inactivos', value: 'inactive' },
    { label: 'Administradores', value: 'admin' },
    { label: 'Usuarios', value: 'user' },
  ];

  const handleEditUser = (user: User) => {
    handleOpenEditModal(user);
  };

  const handleViewUser = (user: User) => {
    handleOpenDetailModal(user);
  };

  const handleRefresh = async () => {
    setIsRefreshing(true);
    await refetch();
    setIsRefreshing(false);
  };

  const getRoleChipProps = (roleId: number | undefined) => {
    switch (roleId) {
      case 1:
        return {
          label: 'Admin',
          icon: 'shield-account',
          color: theme.colors.error,
        };
      case 2:
        return {
          label: 'Gerente',
          icon: 'account-tie',
          color: theme.colors.primary,
        };
      case 3:
        return {
          label: 'Cajero',
          icon: 'cash-register',
          color: theme.colors.tertiary,
        };
      case 4:
        return {
          label: 'Mesero',
          icon: 'room-service',
          color: theme.colors.secondary,
        };
      case 5:
        return { label: 'Cocina', icon: 'chef-hat', color: '#FF6B6B' };
      case 6:
        return { label: 'Repartidor', icon: 'moped', color: '#4ECDC4' };
      default:
        return {
          label: 'Usuario',
          icon: 'account',
          color: theme.colors.onSurfaceVariant,
        };
    }
  };

  const renderDescription = (user: User) => {
    const roleProps = getRoleChipProps(user.role?.id);

    return (
      <View style={styles.descriptionContainer}>
        <View style={styles.userInfoRow}>
          <Text style={styles.username}>@{user.username}</Text>
          <Chip
            mode="flat"
            icon={roleProps.icon}
            style={[
              styles.roleChipInDescription,
              { backgroundColor: roleProps.color + '20' },
            ]}
            textStyle={[styles.roleChipText, { color: roleProps.color }]}
            compact
          >
            {roleProps.label}
          </Chip>
        </View>
        {user.email && (
          <Text style={styles.email} numberOfLines={1}>
            {user.email}
          </Text>
        )}
        {user.role?.id === 5 && user.preparationScreen && (
          <Text style={styles.screenInfo}>
            Pantalla: {user.preparationScreen.name}
          </Text>
        )}
      </View>
    );
  };

  const renderTitle = (user: User) => {
    const firstName = user.firstName || '';
    const lastName = user.lastName || '';
    const fullName = `${firstName} ${lastName}`.trim();
    const displayName = fullName || user.username;

    return (
      <View style={styles.titleContainer}>
        <Text style={styles.title} numberOfLines={1} ellipsizeMode="tail">
          {displayName}
        </Text>
      </View>
    );
  };

  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    listContainer: {
      flex: 1,
    },
    titleContainer: {
      flex: 1,
      paddingRight: responsive.isTablet ? theme.spacing.xs : theme.spacing.s,
    },
    title: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: responsive.isTablet ? 14 : 16,
      lineHeight: responsive.isTablet ? 18 : 22,
    },
    descriptionContainer: {
      flex: 1,
      gap: responsive.isTablet ? 2 : theme.spacing.xs / 2,
      paddingTop: responsive.isTablet ? 2 : theme.spacing.xs / 2,
    },
    userInfoRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.isTablet ? theme.spacing.xs : theme.spacing.s,
      flexWrap: 'wrap',
    },
    username: {
      fontSize: responsive.isTablet ? 12 : 14,
      color: theme.colors.onSurfaceVariant,
      fontWeight: '500',
    },
    email: {
      fontSize: responsive.isTablet ? 11 : 13,
      color: theme.colors.onSurfaceVariant,
      opacity: 0.8,
    },
    screenInfo: {
      fontSize: responsive.isTablet ? 11 : 13,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
    },
    roleChipInDescription: {
      minHeight: responsive.isTablet ? 20 : 28,
      height: 'auto',
      borderRadius: theme.roundness * 2,
      paddingHorizontal: responsive.isTablet ? 6 : responsive.spacing.s,
      paddingVertical: responsive.isTablet ? 1 : 4,
    },
    roleChipText: {
      fontSize: responsive.isTablet ? 10 : 12,
      fontWeight: '600',
      lineHeight: responsive.isTablet ? 12 : 16,
      marginVertical: 0,
      paddingVertical: 0,
    },
  });

  return (
    <SafeAreaView style={styles.container} edges={['bottom']}>
      <View style={styles.container}>
        <GenericList
          items={mappedUsers}
          isLoading={isLoading}
          isRefreshing={isRefreshing}
          onRefresh={handleRefresh}
          onItemPress={handleViewUser}
          ListEmptyComponent={ListEmptyComponent}
          listItemStyle={
            responsive.isTablet
              ? {
                  marginVertical: 1,
                  marginHorizontal: responsive.spacing.xs,
                }
              : undefined
          }
          listItemContentStyle={
            responsive.isTablet
              ? {
                  paddingVertical: 2,
                  minHeight: 36,
                }
              : undefined
          }
          contentContainerStyle={
            responsive.isTablet
              ? {
                  paddingTop: 2,
                  paddingBottom: 80,
                }
              : undefined
          }
          renderConfig={{
            titleField: 'displayName' as any,
            descriptionField: 'displayInfo' as any,
            statusConfig: {
              field: 'isActive' as any,
              activeValue: true,
              activeLabel: 'Activo',
              inactiveLabel: 'Inactivo',
            },
            renderTitle: renderTitle,
            renderDescription: renderDescription,
          }}
          enableSearch={true}
          searchQuery={searchQuery}
          onSearchChange={setSearchQuery}
          searchPlaceholder="Buscar por nombre, email o usuario..."
          filterOptions={filterOptions}
          filterValue={selectedFilter}
          onFilterChange={(value) => setSelectedFilter(value as string)}
          showFab={true}
          onFabPress={handleCreateUser}
          fabIcon="account-plus"
          fabLabel="Nuevo Usuario"
          fabVisible={drawerStatus === 'closed'}
          showImagePlaceholder={false}
          isDrawerOpen={drawerStatus === 'open'}
        />
      </View>

      <Portal>
        {isFormModalVisible && (
          <UserFormModal
            visible={isFormModalVisible}
            onDismiss={handleCloseModals}
            user={editingItem}
          />
        )}

        {isDetailModalVisible && selectedItem && (
          <UserDetailModal
            visible={isDetailModalVisible}
            onDismiss={handleCloseModals}
            user={selectedItem}
            onEdit={handleEditUser}
          />
        )}
      </Portal>
    </SafeAreaView>
  );
}

================
File: app/src/services/audioOrderService.ts
================
import ApiClientWrapper from '../app/services/apiClientWrapper';
import * as FileSystem from 'expo-file-system';
import { API_PATHS } from '@/app/constants/apiPaths';

export interface AIOrderItem {
  productId: string;
  productName?: string;
  variantId?: string;
  variantName?: string;
  quantity: number;
  modifiers?: string[];
  pizzaCustomizations?: Array<{
    customizationId: string;
    customizationName?: string;
    half: 'FULL' | 'HALF_1' | 'HALF_2';
    action: 'ADD' | 'REMOVE';
  }>;
}

export interface DeliveryInfoData {
  fullAddress?: string;
  recipientName?: string;
  recipientPhone?: string;
}

export interface ScheduledDeliveryData {
  time?: string;
}

export interface AudioOrderResponse {
  success: boolean;
  data?: {
    orderItems?: AIOrderItem[];
    deliveryInfo?: DeliveryInfoData;
    scheduledDelivery?: ScheduledDeliveryData;
    orderType?: 'DELIVERY' | 'TAKE_AWAY' | 'DINE_IN';
    warnings?: string;
    processingTime: number;
  };
  error?: {
    code: string;
    message: string;
    type: string;
    timestamp: string;
    requestId: string;
  };
}

class AudioOrderService {
  constructor() {
    // API URL se maneja en apiClient
  }

  async processAudioOrder(
    audioUri: string,
    transcription: string,
  ): Promise<AudioOrderResponse> {
    try {
      // Convertir audio a base64
      const audioBase64 = await FileSystem.readAsStringAsync(audioUri, {
        encoding: FileSystem.EncodingType.Base64,
      });

      // Preparar payload para el backend
      const payload = {
        audioData: audioBase64,
        transcription: transcription,
        audioFormat: 'audio/mp4',
      };

      // Enviar al backend con timeout extendido para procesamiento de audio
      const response = await ApiClientWrapper.post(
        API_PATHS.AUDIO_ORDERS_PROCESS,
        payload,
        { timeout: 60000 }, // 60 segundos para permitir procesamiento de audio
      );

      // Verificar que tengamos una respuesta v√°lida
      if (!response || !response?.ok || !response.data) {
        throw new Error('No se recibi√≥ respuesta del servidor');
      }

      const responseData = response.data as any;

      // Adaptar la respuesta del backend al formato esperado
      if (responseData.success) {
        return {
          success: true,
          data: responseData.extractedData || {
            orderItems: [],
            deliveryInfo: {},
            scheduledDelivery: {},
            orderType: 'DELIVERY', // Valor por defecto si no hay datos
            warnings: undefined,
            processingTime: 0,
          },
        };
      } else {
        throw new Error(
          responseData.error?.message ||
            responseData.message ||
            'Error procesando audio',
        );
      }
    } catch (error: any) {
      return {
        success: false,
        error: {
          code: error.response?.data?.error?.code || 'PROCESSING_ERROR',
          message: this.getErrorMessage(error),
          type: 'error',
          timestamp: new Date().toISOString(),
          requestId: 'local-' + Date.now(),
        },
      };
    }
  }

  getErrorMessage(error: any): string {
    if (error.response?.data?.error) {
      const apiError = error.response.data.error;

      switch (apiError.code) {
        case 'BL015':
          return 'El archivo de audio es muy grande. M√°ximo 10MB.';
        case 'AUTH001':
          return 'Error de autenticaci√≥n. Contacta al administrador.';
        case 'BL016':
          return 'No se pudo procesar el audio. Intenta de nuevo.';
        case 'BL002':
          return 'Faltan datos requeridos.';
        default:
          return apiError.message || 'Error desconocido';
      }
    }

    return error.message || 'Error al procesar la orden por voz';
  }

  // M√©todo para validar antes de enviar
  validateBeforeSending(
    audioFileSize: number,
    transcription: string,
  ): string[] {
    const errors: string[] = [];

    // Validar tama√±o (50MB m√°ximo para audio de hasta 5 minutos)
    if (audioFileSize > 50 * 1024 * 1024) {
      errors.push('El archivo de audio es muy grande (m√°ximo 50MB)');
    }

    // Validar transcripci√≥n
    if (!transcription || transcription.trim().length < 5) {
      errors.push('La transcripci√≥n est√° vac√≠a o es muy corta');
    }

    return errors;
  }
}

export const audioOrderService = new AudioOrderService();

================
File: app/package.json
================
{
  "name": "cloudbite",
  "version": "1.0.0",
  "main": "index.ts",
  "scripts": {
    "start": "expo start",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web",
    "test": "jest --watchAll",
    "test:ci": "jest",
    "lint": "eslint . --ext .js,.jsx,.ts,.tsx --fix",
    "compile": "tsc --noEmit --skipLibCheck",
    "compile:check": "./compile-check.sh",
    "build:ios:sim": "eas build --platform ios --profile development --local",
    "build:android:sim": "eas build --platform android --profile development --local",
    "build:ios:dev": "eas build --platform ios --profile preview --local",
    "build:android:dev": "eas build --platform android --profile preview --local",
    "build:android:prod": "eas build --platform android --profile production --local",
    "build:android:prod-apk": "eas build --platform android --profile production-apk --local",
    "build:prod": "eas build --platform android --profile production",
    "submit:prod": "eas submit --platform android --profile production",
    "release:prod": "npm run build:prod && npm run submit:prod",
    "release:prod:auto": "eas build --platform android --profile production --auto-submit",
    "release:playstore": "./scripts/release-to-playstore.sh",
    "postinstall": "patch-package"
  },
  "dependencies": {
    "@expo/config-plugins": "~10.0.0",
    "@expo/metro-config": "~0.20.0",
    "@expo/metro-runtime": "~5.0.4",
    "@expo/prebuild-config": "~9.0.0",
    "@expo/vector-icons": "^14.0.4",
    "@react-native-community/datetimepicker": "^8.4.2",
    "@react-native-community/netinfo": "11.3.1",
    "@react-navigation/drawer": "^7.3.8",
    "@react-navigation/native": "^7.1.5",
    "@react-navigation/native-stack": "^7.3.9",
    "@shopify/flash-list": "1.7.6",
    "@tanstack/react-query": "^5.72.1",
    "@types/eventemitter3": "^1.2.0",
    "apisauce": "^3.1.1",
    "axios": "^1.8.4",
    "axios-retry": "^4.5.0",
    "babel-plugin-module-resolver": "^5.0.2",
    "date-fns": "^4.1.0",
    "eventemitter3": "^5.0.1",
    "expo": "^53.0.0",
    "expo-audio": "~0.4.7",
    "expo-build-properties": "^0.14.8",
    "expo-crypto": "~14.1.5",
    "expo-dev-client": "~5.2.4",
    "expo-file-system": "~18.1.10",
    "expo-image": "~2.3.0",
    "expo-image-picker": "~16.1.4",
    "expo-screen-orientation": "^8.1.7",
    "expo-secure-store": "~14.2.3",
    "expo-speech-recognition": "^0.3.2",
    "lodash.debounce": "^4.0.8",
    "react": "19.0.0",
    "react-dom": "19.0.0",
    "react-hook-form": "^7.55.0",
    "react-native": "0.79.4",
    "react-native-gesture-handler": "~2.24.0",
    "react-native-paper": "^5.13.1",
    "react-native-paper-dates": "^0.22.46",
    "react-native-reanimated": "~3.17.4",
    "react-native-safe-area-context": "5.4.0",
    "react-native-screens": "~4.11.1",
    "react-native-web": "^0.20.0",
    "react-native-webview": "^13.15.0",
    "zod": "^3.24.2",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@types/lodash": "^4.17.16",
    "@types/react": "~19.0.10",
    "@typescript-eslint/eslint-plugin": "^7.13.1",
    "@typescript-eslint/parser": "^7.13.1",
    "eslint": "^8.57.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.1.3",
    "eslint-plugin-react": "^7.34.3",
    "eslint-plugin-react-hooks": "^4.6.2",
    "eslint-plugin-react-native": "^4.1.0",
    "http-proxy-middleware": "^3.0.5",
    "patch-package": "^8.0.0",
    "typescript": "~5.8.3"
  },
  "private": true,
  "expo": {
    "doctor": {
      "reactNativeDirectoryCheck": {
        "exclude": [
          "@hookform/resolvers",
          "dotenv"
        ],
        "listUnknownPackages": false
      }
    }
  }
}

================
File: app/src/app/components/common/AdaptiveModal.tsx
================
import React, { ReactNode, useMemo } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  Dimensions,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import { Modal, Portal } from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';

interface AdaptiveModalProps {
  visible: boolean;
  onDismiss: () => void;
  children: ReactNode;
  contentContainerStyle?: any;
  maxWidth?: number | string;
  minHeight?: number;
  maxHeight?: string | number;
  dismissable?: boolean;
  dismissableBackButton?: boolean;
  scrollable?: boolean;
  footer?: ReactNode;
  stickyFooter?: boolean;
}

export const AdaptiveModal: React.FC<AdaptiveModalProps> = ({
  visible,
  onDismiss,
  children,
  contentContainerStyle,
  maxWidth,
  minHeight = 200,
  maxHeight = '90%',
  dismissable = true,
  dismissableBackButton = true,
  scrollable = true,
  footer,
  stickyFooter = true,
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const screenHeight = Dimensions.get('window').height;

  const maxHeightPixels = useMemo(() => {
    if (typeof maxHeight === 'string' && maxHeight.endsWith('%')) {
      const percentage = parseInt(maxHeight) / 100;
      return screenHeight * percentage;
    }
    return typeof maxHeight === 'number' ? maxHeight : screenHeight * 0.9;
  }, [maxHeight, screenHeight]);

  const styles = useMemo(
    () =>
      StyleSheet.create({
        modalContainer: {
          backgroundColor: theme.colors.surface,
          borderRadius: theme.roundness * 2,
          width: '90%',
          maxWidth: maxWidth || (responsive.isTablet ? 600 : 500),
          minHeight: minHeight,
          maxHeight: maxHeightPixels,
          alignSelf: 'center',
          overflow: 'hidden',
          elevation: 24,
          shadowColor: '#000',
          shadowOffset: { width: 0, height: 12 },
          shadowOpacity: 0.58,
          shadowRadius: 16.0,
        },
        scrollView: {
          maxHeight: maxHeightPixels - (footer ? 100 : 20),
        },
        scrollContent: {
          padding: responsive.isTablet
            ? responsive.spacing.l
            : responsive.spacing.m,
        },
        contentPadding: {
          padding: responsive.isTablet
            ? responsive.spacing.l
            : responsive.spacing.m,
          flex: 1,
        },
        footer: {
          borderTopWidth: 1,
          borderTopColor: theme.colors.surfaceVariant,
          padding: responsive.spacing.m,
          backgroundColor: theme.colors.surface,
        },
      }),
    [theme, responsive, minHeight, maxHeightPixels, maxWidth, footer],
  );

  const modalContent = (
    <View style={styles.modalContainer}>
      {scrollable ? (
        <>
          <ScrollView
            style={styles.scrollView}
            contentContainerStyle={[
              styles.scrollContent,
              contentContainerStyle,
            ]}
            showsVerticalScrollIndicator={false}
            keyboardShouldPersistTaps="handled"
          >
            {children}
          </ScrollView>
          {stickyFooter && footer && (
            <View style={styles.footer}>{footer}</View>
          )}
        </>
      ) : (
        <>
          <View style={[styles.contentPadding, contentContainerStyle]}>
            {children}
          </View>
          {footer && <View style={styles.footer}>{footer}</View>}
        </>
      )}
    </View>
  );

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        dismissable={dismissable}
        dismissableBackButton={dismissableBackButton}
        contentContainerStyle={{
          justifyContent: 'center',
          alignItems: 'center',
          flex: 1,
        }}
      >
        {Platform.OS === 'ios' ? (
          <KeyboardAvoidingView behavior="position" keyboardVerticalOffset={20}>
            {modalContent}
          </KeyboardAvoidingView>
        ) : (
          modalContent
        )}
      </Modal>
    </Portal>
  );
};

export default AdaptiveModal;

================
File: app/src/app/components/common/PhoneNumberInput.tsx
================
import React, { useState, useEffect } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import { TextInput, Menu, Button, HelperText } from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';

interface Country {
  code: string;
  name: string;
  prefix: string;
  flag: string;
}

// Lista de pa√≠ses m√°s comunes en Am√©rica
// IMPORTANTE: Ordenados con prefijos m√°s largos primero para evitar conflictos
const COUNTRIES: Country[] = [
  // Pa√≠ses con prefijos de 4 d√≠gitos
  { code: 'DO', name: 'Rep. Dominicana', prefix: '+1809', flag: 'üá©üá¥' },
  { code: 'PR', name: 'Puerto Rico', prefix: '+1787', flag: 'üáµüá∑' },

  // Pa√≠ses con prefijos de 3 d√≠gitos
  { code: 'EC', name: 'Ecuador', prefix: '+593', flag: 'üá™üá®' },
  { code: 'BO', name: 'Bolivia', prefix: '+591', flag: 'üáßüá¥' },
  { code: 'PY', name: 'Paraguay', prefix: '+595', flag: 'üáµüáæ' },
  { code: 'UY', name: 'Uruguay', prefix: '+598', flag: 'üá∫üáæ' },
  { code: 'GT', name: 'Guatemala', prefix: '+502', flag: 'üá¨üáπ' },
  { code: 'SV', name: 'El Salvador', prefix: '+503', flag: 'üá∏üáª' },
  { code: 'HN', name: 'Honduras', prefix: '+504', flag: 'üá≠üá≥' },
  { code: 'NI', name: 'Nicaragua', prefix: '+505', flag: 'üá≥üáÆ' },
  { code: 'CR', name: 'Costa Rica', prefix: '+506', flag: 'üá®üá∑' },
  { code: 'PA', name: 'Panam√°', prefix: '+507', flag: 'üáµüá¶' },

  // Pa√≠ses con prefijos de 2 d√≠gitos
  { code: 'MX', name: 'M√©xico', prefix: '+52', flag: 'üá≤üáΩ' },
  { code: 'AR', name: 'Argentina', prefix: '+54', flag: 'üá¶üá∑' },
  { code: 'BR', name: 'Brasil', prefix: '+55', flag: 'üáßüá∑' },
  { code: 'CL', name: 'Chile', prefix: '+56', flag: 'üá®üá±' },
  { code: 'CO', name: 'Colombia', prefix: '+57', flag: 'üá®üá¥' },
  { code: 'PE', name: 'Per√∫', prefix: '+51', flag: 'üáµüá™' },
  { code: 'VE', name: 'Venezuela', prefix: '+58', flag: 'üáªüá™' },
  { code: 'CU', name: 'Cuba', prefix: '+53', flag: 'üá®üá∫' },
  { code: 'ES', name: 'Espa√±a', prefix: '+34', flag: 'üá™üá∏' },

  // Pa√≠ses con prefijo de 1 d√≠gito (al final)
  { code: 'US', name: 'Estados Unidos', prefix: '+1', flag: 'üá∫üá∏' },
  { code: 'CA', name: 'Canad√°', prefix: '+1', flag: 'üá®üá¶' },
];

interface PhoneNumberInputProps {
  value: string;
  onChange: (fullNumber: string) => void;
  error?: boolean;
  helperText?: string;
  placeholder?: string;
}

export default function PhoneNumberInput({
  value,
  onChange,
  error,
  helperText,
  placeholder = 'Tel√©fono',
}: PhoneNumberInputProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => getStyles(theme, responsive),
    [theme, responsive],
  );

  const [selectedCountry, setSelectedCountry] = useState<Country>(COUNTRIES[0]);
  const [phoneNumber, setPhoneNumber] = useState('');
  const [menuVisible, setMenuVisible] = useState(false);

  // Detectar pa√≠s y n√∫mero al recibir un valor completo
  useEffect(() => {
    if (value && value.startsWith('+')) {
      // Ordenar pa√≠ses por longitud de prefijo (m√°s largos primero) para evitar coincidencias err√≥neas
      const sortedCountries = [...COUNTRIES].sort(
        (a, b) => b.prefix.length - a.prefix.length,
      );

      // Encontrar el pa√≠s por el prefijo
      const country = sortedCountries.find((c) => value.startsWith(c.prefix));
      if (country) {
        setSelectedCountry(country);
        setPhoneNumber(value.substring(country.prefix.length));
      } else {
        // Si no encontramos el pa√≠s, usar el default y mostrar todo el n√∫mero
        setPhoneNumber(value);
      }
    } else {
      setPhoneNumber(value || '');
    }
  }, [value]);

  const handlePhoneChange = (text: string) => {
    // Solo permitir n√∫meros y limitar a 15 d√≠gitos (est√°ndar internacional)
    const cleaned = text.replace(/[^\d]/g, '').slice(0, 15);
    setPhoneNumber(cleaned);

    // Actualizar el valor completo
    if (cleaned) {
      onChange(`${selectedCountry.prefix}${cleaned}`);
    } else {
      onChange('');
    }
  };

  const handleCountrySelect = (country: Country) => {
    setSelectedCountry(country);
    setMenuVisible(false);

    // Actualizar el valor completo con el nuevo pa√≠s
    if (phoneNumber) {
      onChange(`${country.prefix}${phoneNumber}`);
    }
  };

  return (
    <View>
      <View style={styles.container}>
        <Menu
          visible={menuVisible}
          onDismiss={() => setMenuVisible(false)}
          anchor={
            <Button
              mode="outlined"
              onPress={() => setMenuVisible(true)}
              style={styles.countryButton}
              labelStyle={styles.countryButtonLabel}
            >
              {selectedCountry.flag} {selectedCountry.prefix}
            </Button>
          }
          contentStyle={styles.menuContent}
        >
          <ScrollView
            style={styles.menuScrollView}
            showsVerticalScrollIndicator={true}
            nestedScrollEnabled={true}
          >
            {COUNTRIES.map((country) => (
              <Menu.Item
                key={country.code}
                onPress={() => handleCountrySelect(country)}
                title={`${country.flag} ${country.name} (${country.prefix})`}
                titleStyle={styles.menuItem}
              />
            ))}
          </ScrollView>
        </Menu>

        <TextInput
          value={phoneNumber}
          onChangeText={handlePhoneChange}
          placeholder={placeholder}
          keyboardType="phone-pad"
          mode="outlined"
          error={error}
          style={styles.input}
          outlineStyle={styles.inputOutline}
          maxLength={15}
        />
      </View>

      {helperText && (
        <HelperText type="error" visible={error}>
          {helperText}
        </HelperText>
      )}
    </View>
  );
}

const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.spacing(theme.spacing.s),
    },
    countryButton: {
      minWidth: responsive.isTablet ? 85 : 90,
      height: responsive.isTablet ? 48 : 56,
      justifyContent: 'center',
    },
    countryButtonLabel: {
      fontSize: responsive.fontSize(16),
    },
    menuContent: {
      maxHeight: responsive.isTablet ? 400 : 350,
      backgroundColor: theme.colors.surface,
    },
    menuScrollView: {
      maxHeight: responsive.isTablet ? 390 : 340,
    },
    menuItem: {
      fontSize: responsive.fontSize(14),
    },
    input: {
      flex: 1,
      height: responsive.isTablet ? 48 : 56,
    },
    inputOutline: {
      borderRadius: theme.roundness * 2,
    },
  });

================
File: app/src/app/components/crud/GenericFormModal.tsx
================
import React, {
  useEffect,
  useMemo,
  useState,
  useCallback,
  useRef,
} from 'react';
import {
  View,
  StyleSheet,
  Alert,
  ScrollView,
  StyleProp,
  ViewStyle,
} from 'react-native';
import {
  Text,
  TextInput,
  Button,
  Switch,
  HelperText,
  ActivityIndicator,
} from 'react-native-paper';
import {
  useForm,
  Controller,
  SubmitHandler,
  FieldValues,
  Path,
  UseFormReturn,
  DeepPartial,
  DefaultValues,
  Control,
  FieldError, // Importar FieldError
} from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { z } from 'zod';
import { useAppTheme, AppTheme } from '../../styles/theme';
import CustomImagePicker, { FileObject } from '../common/CustomImagePicker';
import {
  ImageUploadService,
  EntityWithOptionalPhoto,
} from '../../lib/imageUploadService';
import { ResponsiveModal } from '../responsive/ResponsiveModal';
import { useResponsive } from '../../hooks/useResponsive';

type FieldType =
  | 'text'
  | 'textarea'
  | 'switch'
  | 'number'
  | 'email'
  | 'password';

export interface FormFieldConfig<TFormData extends FieldValues> {
  name: Path<TFormData>;
  label: string;
  type: FieldType;
  placeholder?: string;
  required?: boolean;
  defaultValue?: any;
  inputProps?: any;
  switchProps?: Partial<React.ComponentProps<typeof Switch>>;
  numberOfLines?: number;
  switchLabel?: string;
}

export interface ImagePickerConfig<TFormData extends FieldValues> {
  imageUriField: Path<TFormData>;
  onImageUpload: (file: FileObject) => Promise<{ id: string } | null>;
  determineFinalPhotoId?: (
    currentImageUri: string | null,
    editingItem: EntityWithOptionalPhoto | undefined,
  ) => string | null | undefined;
  imagePickerSize?: number;
  placeholderIcon?: string;
  placeholderText?: string;
}

interface GenericFormModalProps<
  TFormData extends FieldValues,
  TItem extends { id: string },
> {
  visible: boolean;
  onDismiss: () => void;
  onSubmit: (
    data: TFormData,
    photoId: string | null | undefined,
  ) => Promise<void>;
  formSchema: z.ZodType<TFormData>;
  formFields: FormFieldConfig<TFormData>[];
  imagePickerConfig?: ImagePickerConfig<TFormData>;
  initialValues?: DeepPartial<TFormData>;
  editingItem: (TItem & Partial<EntityWithOptionalPhoto>) | null;
  isSubmitting: boolean;
  modalTitle: (isEditing: boolean) => string;
  submitButtonLabel?: (isEditing: boolean) => string;
  cancelButtonLabel?: string;
  modalStyle?: StyleProp<ViewStyle>;
  formContainerStyle?: StyleProp<ViewStyle>;
  onFileSelected?: (file: FileObject | null) => void;
}

// Componente separado para manejar campos num√©ricos correctamente
interface NumericInputProps {
  value: number | null | undefined;
  onChange: (value: number | null) => void;
  onBlur: () => void;
  label: string;
  placeholder?: string;
  keyboardType?: any; // Permitir cualquier KeyboardTypeOptions
  error?: boolean;
  disabled?: boolean;
  inputProps?: any;
}

const NumericInput: React.FC<NumericInputProps> = ({
  value,
  onChange,
  onBlur,
  label,
  placeholder,
  keyboardType = 'decimal-pad',
  error,
  disabled,
  inputProps,
}) => {
  const [inputValue, setInputValue] = useState<string>(
    value === null || value === undefined ? '' : String(value),
  );

  useEffect(() => {
    const stringValue =
      value === null || value === undefined ? '' : String(value);
    if (stringValue !== inputValue) {
      const numericValueFromInput = parseFloat(inputValue);
      if (
        !(inputValue.endsWith('.') && numericValueFromInput === value) &&
        !(inputValue === '.' && value === null)
      ) {
        setInputValue(stringValue);
      }
    }
  }, [value, inputValue]);

  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = getStyles(theme, responsive);

  return (
    <TextInput
      label={label}
      value={inputValue}
      onChangeText={(text) => {
        const formattedText = text.replace(/,/g, '.');
        if (/^(\d*\.?\d*)$/.test(formattedText)) {
          setInputValue(formattedText);

          if (formattedText === '' || formattedText === '.') {
            if (value !== null) onChange(null);
          } else {
            const numericValue = parseFloat(formattedText);
            if (!isNaN(numericValue) && numericValue !== value) {
              onChange(numericValue);
            } else if (isNaN(numericValue) && value !== null) {
              onChange(null);
            }
          }
        }
      }}
      onBlur={onBlur}
      mode="outlined"
      style={styles.input}
      placeholder={placeholder}
      keyboardType={keyboardType}
      error={error}
      disabled={disabled}
      {...inputProps}
    />
  );
};

const getDefaultValueForType = (
  type: FieldType,
): string | number | boolean | null | undefined => {
  switch (type) {
    case 'text':
    case 'textarea':
    case 'email':
    case 'password':
      return '';
    case 'number':
      return null;
    case 'switch':
      return false;
    default:
      return undefined;
  }
};

const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    modalSurface: {
      padding: 0,
      margin: responsive.spacing(20),
      marginHorizontal: responsive.isTablet
        ? responsive.spacing(40)
        : responsive.spacing(20),
      borderRadius: theme.roundness * 2,
      elevation: 4,
      backgroundColor: theme.colors.background,
      maxHeight: responsive.isTablet ? '92%' : '90%',
      maxWidth: responsive.isTablet ? 600 : 500,
      alignSelf: 'center',
      width: responsive.isTablet ? '85%' : '90%',
      overflow: 'hidden',
    },
    modalHeader: {
      backgroundColor: theme.colors.primary,
      paddingVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      paddingHorizontal: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
    },
    formContainer: {
      maxHeight: '100%',
    },
    scrollViewContent: {
      padding: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
      paddingBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.l)
        : responsive.spacing(theme.spacing.xl),
    },
    modalTitle: {
      color: theme.colors.onPrimary,
      fontWeight: '700',
      textAlign: 'center',
    },
    input: {
      marginBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: theme.roundness,
    },
    switchLabel: {
      color: theme.colors.onSurfaceVariant,
      marginRight: responsive.spacing(theme.spacing.m),
      fontSize: responsive.isTablet ? 14 : 16,
      flexShrink: 1,
    },
    switchComponentContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'flex-start',
      marginBottom: responsive.spacing(theme.spacing.m),
      paddingVertical: responsive.spacing(theme.spacing.s),
    },
    imagePickerContainer: {
      alignItems: 'center',
      marginBottom: responsive.spacing(theme.spacing.l),
    },
    modalActions: {
      flexDirection: 'row',
      justifyContent: 'center',
      paddingTop: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
      paddingBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.l)
        : responsive.spacing(theme.spacing.xl),
      paddingHorizontal: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
      gap: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      minHeight: responsive.isTablet ? 70 : 80,
    },
    formButton: {
      borderRadius: theme.roundness,
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      flex: 1,
      maxWidth: 200,
      minWidth: responsive.isTablet ? 120 : 140,
    },
    cancelButton: {},
    loadingOverlay: {
      ...StyleSheet.absoluteFillObject,
      backgroundColor: 'rgba(0, 0, 0, 0.3)',
      justifyContent: 'center',
      alignItems: 'center',
      borderRadius: theme.roundness * 2,
      zIndex: 10,
    },
    helperText: {
      marginTop: -responsive.spacing(theme.spacing.s),
      marginBottom: responsive.spacing(theme.spacing.s),
    },
  });

const GenericFormModal = <
  TFormData extends FieldValues,
  TItem extends { id: string },
>({
  visible,
  onDismiss,
  onSubmit,
  formSchema,
  formFields,
  imagePickerConfig,
  initialValues,
  editingItem,
  isSubmitting: isParentSubmitting,
  modalTitle,
  submitButtonLabel = (isEditing: boolean) => (isEditing ? 'Guardar' : 'Crear'),
  cancelButtonLabel = 'Cancelar',
  modalStyle,
  formContainerStyle,
  onFileSelected,
}: GenericFormModalProps<TFormData, TItem>) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = useMemo(
    () => getStyles(theme, responsive),
    [theme, responsive],
  );
  const [isInternalImageUploading, setIsInternalImageUploading] =
    useState(false);
  const [localSelectedFile, setLocalSelectedFile] = useState<FileObject | null>(
    null,
  );
  const prevVisibleRef = useRef(visible);
  const prevEditingItemIdRef = useRef(editingItem?.id);

  const isEditing = !!editingItem;
  const isActuallySubmitting = isParentSubmitting || isInternalImageUploading;

  const {
    control,
    handleSubmit,
    reset,
    setValue,
    watch,
    getValues: _getValues,
    formState: { errors },
  }: UseFormReturn<TFormData> = useForm<TFormData>({
    resolver: zodResolver(formSchema) as any,
    defaultValues: useMemo((): DefaultValues<TFormData> => {
      const defaults = formFields.reduce(
        (acc: DefaultValues<TFormData>, field) => {
          acc[field.name] =
            field.defaultValue ?? getDefaultValueForType(field.type);
          return acc;
        },
        {} as DefaultValues<TFormData>,
      );
      return { ...defaults, ...(initialValues as DefaultValues<TFormData>) };
    }, [formFields, initialValues]),
  });

  const watchedImageUri = imagePickerConfig
    ? watch(imagePickerConfig.imageUriField)
    : undefined;
  const currentImageUri =
    typeof watchedImageUri === 'string' ? watchedImageUri : null;

  useEffect(() => {
    const loadInitialData = async () => {
      const justOpened = visible && !prevVisibleRef.current;
      const itemChanged =
        visible && editingItem?.id !== prevEditingItemIdRef.current;

      if (visible) {
        const defaultFormValues = formFields.reduce(
          (acc: DefaultValues<TFormData>, field) => {
            acc[field.name] =
              field.defaultValue ?? getDefaultValueForType(field.type);
            return acc;
          },
          {} as DefaultValues<TFormData>,
        );

        const resetValues = {
          ...defaultFormValues,
          ...(initialValues as DefaultValues<TFormData>),
        };

        reset(resetValues, { keepDirtyValues: !justOpened && !itemChanged });

        if (justOpened || itemChanged) {
          setLocalSelectedFile(null);
          onFileSelected?.(null);
          setIsInternalImageUploading(false);
        }
      }

      prevVisibleRef.current = visible;
      prevEditingItemIdRef.current = editingItem?.id;
    };

    loadInitialData();
  }, [
    visible,
    editingItem?.id,
    reset,
    formFields,
    initialValues,
    onFileSelected,
    imagePickerConfig,
  ]);

  const handleImageSelected = useCallback(
    (uri: string, file: FileObject) => {
      if (imagePickerConfig) {
        const fieldName = imagePickerConfig.imageUriField;
        setValue(fieldName, uri as any, {
          shouldValidate: true,
          shouldDirty: true,
          shouldTouch: true,
        });
        setLocalSelectedFile(file);
        onFileSelected?.(file);
      }
    },
    [setValue, imagePickerConfig, onFileSelected],
  );

  const handleImageRemoved = useCallback(() => {
    if (imagePickerConfig) {
      setValue(imagePickerConfig.imageUriField, null as any, {
        shouldValidate: true,
      });
      setLocalSelectedFile(null);
      onFileSelected?.(null);
    }
  }, [setValue, imagePickerConfig, onFileSelected]);

  const processSubmit: SubmitHandler<TFormData> = async (formData) => {
    if (isActuallySubmitting) return;

    let finalPhotoId: string | null | undefined = undefined;

    if (imagePickerConfig) {
      const formImageUri = imagePickerConfig.imageUriField
        ? formData[imagePickerConfig.imageUriField]
        : null;

      const isNewLocalImage =
        typeof formImageUri === 'string' && formImageUri.startsWith('file://');
      if (isNewLocalImage && localSelectedFile) {
        setIsInternalImageUploading(true);
        try {
          const uploadResult =
            await imagePickerConfig.onImageUpload(localSelectedFile);
          if (uploadResult?.id) {
            finalPhotoId = uploadResult.id;
          } else {
            throw new Error('La subida de la imagen no devolvi√≥ un ID.');
          }
        } catch (error) {
          Alert.alert(
            'Error',
            `No se pudo subir la imagen: ${error instanceof Error ? error.message : 'Error desconocido'}`,
          );
          setIsInternalImageUploading(false);
          return;
        } finally {
          setIsInternalImageUploading(false);
        }
      } else {
        const determineFn =
          imagePickerConfig.determineFinalPhotoId ??
          ImageUploadService.determinePhotoId;
        const entityForPhotoCheck = editingItem ?? undefined;
        finalPhotoId = await determineFn(formImageUri, entityForPhotoCheck);
      }
    }

    await onSubmit(formData, finalPhotoId);
  };

  const renderFormField = (fieldConfig: FormFieldConfig<TFormData>) => {
    const fieldName = fieldConfig.name;
    const fieldError = errors[fieldName] as FieldError | undefined;
    const errorMessage = fieldError?.message;

    switch (fieldConfig.type) {
      case 'textarea':
      case 'text':
      case 'number':
      case 'email':
      case 'password':
        return (
          <View key={String(fieldName)}>
            {/* Controller para campos num√©ricos con manejo de string local y decimales */}
            <Controller
              name={fieldName}
              control={control as Control<FieldValues>}
              render={({ field: { onChange, onBlur, value } }) => {
                if (fieldConfig.type === 'number') {
                  return (
                    <NumericInput
                      value={value}
                      onChange={onChange}
                      onBlur={onBlur}
                      label={fieldConfig.label}
                      placeholder={fieldConfig.placeholder}
                      keyboardType={
                        fieldConfig.inputProps?.keyboardType ?? 'decimal-pad'
                      }
                      error={!!errorMessage}
                      disabled={isActuallySubmitting}
                      inputProps={fieldConfig.inputProps}
                    />
                  );
                } else {
                  return (
                    <TextInput
                      label={fieldConfig.label}
                      value={value ?? ''}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      mode="outlined"
                      style={styles.input}
                      placeholder={fieldConfig.placeholder}
                      secureTextEntry={fieldConfig.type === 'password'}
                      keyboardType={
                        fieldConfig.type === 'email'
                          ? 'email-address'
                          : 'default'
                      }
                      multiline={fieldConfig.type === 'textarea'}
                      numberOfLines={
                        fieldConfig.numberOfLines ??
                        (fieldConfig.type === 'textarea' ? 3 : 1)
                      }
                      error={!!errorMessage}
                      disabled={isActuallySubmitting}
                      {...fieldConfig.inputProps}
                    />
                  );
                }
              }}
            />
            {errorMessage && (
              <HelperText
                type="error"
                visible={!!errorMessage}
                style={styles.helperText}
              >
                {errorMessage}
              </HelperText>
            )}
          </View>
        );
      case 'switch':
        return (
          <View key={String(fieldName)} style={styles.switchComponentContainer}>
            <Text variant="bodyLarge" style={styles.switchLabel}>
              {fieldConfig.switchLabel ?? fieldConfig.label}
            </Text>
            <Controller
              name={fieldName}
              control={control as Control<FieldValues>}
              render={({ field: { onChange, value } }) => (
                <Switch
                  value={value}
                  onValueChange={onChange}
                  disabled={isActuallySubmitting}
                  style={{ transform: [{ scaleX: 1.5 }, { scaleY: 1.5 }] }}
                  {...fieldConfig.switchProps}
                />
              )}
            />
            {errorMessage && (
              <HelperText
                type="error"
                visible={!!errorMessage}
                style={styles.helperText}
              >
                {errorMessage}
              </HelperText>
            )}
          </View>
        );
      default:
        return null;
    }
  };

  return (
    <ResponsiveModal
      visible={visible}
      onDismiss={onDismiss}
      title={modalTitle(isEditing)}
      dismissable={!isActuallySubmitting}
      scrollable={false}
      style={modalStyle}
      contentContainerStyle={styles.modalSurface}
      footer={
        <View style={styles.modalActions}>
          <Button
            mode="outlined"
            onPress={onDismiss}
            style={[styles.formButton, styles.cancelButton]}
            disabled={isActuallySubmitting}
          >
            {cancelButtonLabel}
          </Button>
          <Button
            mode="contained"
            onPress={() => {
              handleSubmit(processSubmit)();
            }}
            loading={isActuallySubmitting}
            disabled={isActuallySubmitting}
            style={styles.formButton}
          >
            {submitButtonLabel(isEditing)}
          </Button>
        </View>
      }
    >
      <View style={[styles.formContainer, formContainerStyle]}>
        <ScrollView
          contentContainerStyle={styles.scrollViewContent}
          showsVerticalScrollIndicator={false}
        >
          {imagePickerConfig && (
            <View style={styles.imagePickerContainer}>
              <CustomImagePicker
                value={currentImageUri}
                onImageSelected={handleImageSelected}
                onImageRemoved={handleImageRemoved}
                isLoading={isInternalImageUploading}
                disabled={isParentSubmitting}
                size={
                  imagePickerConfig.imagePickerSize ??
                  responsive.getResponsiveDimension(150, 200)
                }
                placeholderIcon={imagePickerConfig.placeholderIcon}
                placeholderText={imagePickerConfig.placeholderText}
              />
              {(
                errors[imagePickerConfig.imageUriField] as
                  | FieldError
                  | undefined
              )?.message && (
                <HelperText
                  type="error"
                  visible={!!errors[imagePickerConfig.imageUriField]}
                  style={styles.helperText}
                >
                  {
                    (
                      errors[imagePickerConfig.imageUriField] as
                        | FieldError
                        | undefined
                    )?.message
                  }
                </HelperText>
              )}
            </View>
          )}

          {formFields.map(renderFormField)}
        </ScrollView>

        {isActuallySubmitting && (
          <View style={styles.loadingOverlay}>
            <ActivityIndicator
              animating={true}
              size="large"
              color={theme.colors.primary}
            />
          </View>
        )}
      </View>
    </ResponsiveModal>
  );
};

export default GenericFormModal;

================
File: app/src/app/navigation/components/CustomDrawerContent.tsx
================
import React from 'react';
import { View, StyleSheet, Platform, TouchableOpacity } from 'react-native';
import { DrawerContentScrollView } from '@react-navigation/drawer';
import {
  Drawer as PaperDrawer,
  Text,
  Divider,
  Switch,
  TouchableRipple,
  Icon,
  Surface,
  IconButton,
} from 'react-native-paper';
import { useThemeStore } from '../../store/themeStore';
import { THEME_MODE } from '../../types/theme.types';
import { useAuthStore } from '../../store/authStore';
import { useAppTheme, AppTheme } from '../../styles/theme';
import { useResponsive } from '../../hooks/useResponsive';
import { clearImageCache } from '../../lib/imageCache';
import { useSnackbarStore } from '../../store/snackbarStore';
import {
  hasPermission,
  DRAWER_SECTIONS,
  DrawerSection,
} from '../../constants/rolePermissions';
import { generateNavigationAction } from '../helpers/navigationHelpers';
import { RoleEnum } from '@/modules/users/types/user.types';
import { useNavigation, DrawerActions } from '@react-navigation/native';

import type { DrawerContentComponentProps } from '@react-navigation/drawer';

// Traducciones de roles
const ROLE_TRANSLATIONS: Record<number, string> = {
  [RoleEnum.ADMIN]: 'Administrador',
  [RoleEnum.MANAGER]: 'Gerente',
  [RoleEnum.CASHIER]: 'Cajero',
  [RoleEnum.WAITER]: 'Mesero',
  [RoleEnum.KITCHEN]: 'Cocina',
  [RoleEnum.DELIVERY]: 'Repartidor',
};

const getRoleTranslation = (roleId?: number): string => {
  if (!roleId) return 'Desconocido';
  return ROLE_TRANSLATIONS[roleId] || 'Desconocido';
};

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
    },
    userInfoSection: {
      padding: responsive.spacing(theme.spacing.m),
    },
    title: {
      ...theme.fonts.titleMedium,
      fontSize: responsive.fontSize(theme.fonts.titleMedium.fontSize),
      color: theme.colors.onSurface,
      marginBottom: responsive.spacing(4),
    },
    caption: {
      ...theme.fonts.bodySmall,
      fontSize: responsive.fontSize(theme.fonts.bodySmall.fontSize),
      color: theme.colors.onSurfaceVariant,
      marginBottom: responsive.spacing(2),
    },
    drawerSection: {
      marginTop: responsive.spacing(theme.spacing.s),
    },
    bottomDrawerSection: {
      marginBottom: responsive.spacing(theme.spacing.m),
      marginTop: 'auto',
      borderTopColor: theme.colors.outlineVariant,
      borderTopWidth: StyleSheet.hairlineWidth,
      paddingTop: responsive.spacing(theme.spacing.s),
    },
    preference: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      paddingVertical: responsive.spacing(theme.spacing.s),
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      alignItems: 'center',
      marginHorizontal: responsive.spacing(theme.spacing.xs),
      borderRadius: theme.roundness * 2,
    },
    drawerItemLabel: {
      ...theme.fonts.labelLarge,
      fontSize: responsive.fontSize(theme.fonts.labelLarge.fontSize),
    },
    drawerItemContainer: {
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingVertical: responsive.spacing(theme.spacing.m),
      flexDirection: 'row',
      alignItems: 'center',
      borderRadius: theme.roundness * 2,
      marginHorizontal: responsive.spacing(theme.spacing.xs),
      marginVertical: responsive.spacing(theme.spacing.xxs),
    },
    drawerItemActive: {
      backgroundColor: theme.colors.primaryContainer,
    },
    drawerItemIconContainer: {
      marginRight: responsive.spacing(theme.spacing.l),
      width: responsive.isTablet ? 20 : theme.spacing.l,
      alignItems: 'center',
    },
    divider: {
      marginVertical: responsive.spacing(theme.spacing.s),
      marginHorizontal: responsive.spacing(theme.spacing.m),
    },

    configSubheader: {
      ...theme.fonts.labelLarge,
      fontSize: responsive.fontSize(theme.fonts.labelLarge.fontSize),
      color: theme.colors.onSurfaceVariant,
      paddingLeft: responsive.spacing(theme.spacing.l),
      paddingRight: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.s),
      paddingBottom: responsive.spacing(theme.spacing.xxs),
    },
  });

export function CustomDrawerContent(props: DrawerContentComponentProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const logout = useAuthStore((state) => state.logout);
  const setThemePreference = useThemeStore((state) => state.setThemePreference);
  const user = useAuthStore((state) => state.user);
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const navigation = useNavigation<any>();

  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );

  const getItemActive = (routeName: string) => {
    const currentRoute = props.state.routes[props.state.index];
    return currentRoute?.name === routeName;
  };

  const getItemColor = (routeName: string) => {
    return getItemActive(routeName)
      ? theme.colors.primary
      : theme.colors.onSurfaceVariant;
  };

  const renderDrawerItem = (
    routeName: string,
    label: string,
    iconName: string,
    navigateToScreen: () => void,
  ) => {
    // Verificar permisos antes de renderizar
    if (!hasPermission(user?.role?.id, routeName as DrawerSection)) {
      return null;
    }

    const isActive = getItemActive(routeName);

    return (
      <TouchableRipple
        key={routeName}
        onPress={navigateToScreen}
        style={[
          styles.drawerItemContainer,
          isActive && styles.drawerItemActive,
        ]}
        rippleColor={`${theme.colors.primary}20`}
      >
        <View style={{ flexDirection: 'row', alignItems: 'center' }}>
          <View style={styles.drawerItemIconContainer}>
            <Icon
              source={iconName}
              size={responsive.isTablet ? 20 : 24}
              color={getItemColor(routeName)}
            />
          </View>
          <Text
            style={[styles.drawerItemLabel, { color: getItemColor(routeName) }]}
          >
            {label}
          </Text>
        </View>
      </TouchableRipple>
    );
  };

  // Helper simplificado para renderizar items del drawer
  const renderDrawerItemSimple = (
    route: DrawerSection,
    label: string,
    icon: string,
  ) => {
    return renderDrawerItem(route, label, icon, () => {
      // For kitchen users in KitchenOnlyNavigator, handle navigation differently
      const isKitchenUser = user?.role?.id === 5;
      if (isKitchenUser && route === 'KitchenStack') {
        // Simply navigate to the Kitchen screen without reset
        props.navigation.navigate('Kitchen');
      } else {
        const action = generateNavigationAction(route, user?.role?.id);
        if (action) {
          props.navigation.dispatch(action);
        }
      }
    });
  };

  const handleClearCache = async () => {
    try {
      await clearImageCache();
      showSnackbar({
        message: 'Cach√© de im√°genes limpiado exitosamente',
        type: 'success',
      });
    } catch (error) {
      showSnackbar({
        message: 'Error al limpiar el cach√©',
        type: 'error',
      });
    }
  };

  return (
    <Surface
      style={{
        flex: 1,
        backgroundColor: theme.colors.surface,
      }}
      elevation={0}
    >
      <DrawerContentScrollView
        {...props}
        contentContainerStyle={{ paddingTop: 0 }}
      >
        <View style={styles.container}>
          <Surface style={styles.userInfoSection} elevation={0}>
            {user ? (
              <>
                <Text style={styles.title} numberOfLines={1}>
                  {`${user.firstName ?? ''} ${user.lastName ?? ''}`.trim() ||
                    user.username ||
                    'Usuario'}
                </Text>
                <Text style={styles.caption} numberOfLines={1}>
                  Rol: {getRoleTranslation(user.role?.id)}
                </Text>
                <Text style={styles.caption} numberOfLines={1}>
                  {user.email ?? ''}
                </Text>
                <Text style={styles.caption} numberOfLines={1}>
                  @{user.username ?? 'username'}
                </Text>
              </>
            ) : (
              <Text style={styles.title}>Invitado</Text>
            )}
          </Surface>
          <Divider style={styles.divider} />

          {/* Secci√≥n de Ventas - Solo visible si tiene permisos */}
          {DRAWER_SECTIONS.sales.items.some((item) =>
            hasPermission(user?.role?.id, item.route as DrawerSection),
          ) && (
            <PaperDrawer.Section style={styles.drawerSection}>
              <Text style={styles.configSubheader}>
                {DRAWER_SECTIONS.sales.title}
              </Text>
              {DRAWER_SECTIONS.sales.items.map((item) =>
                renderDrawerItemSimple(
                  item.route as DrawerSection,
                  item.label,
                  item.icon,
                ),
              )}
            </PaperDrawer.Section>
          )}

          {/* Secci√≥n de Cocina - Solo para usuarios con rol kitchen */}
          {hasPermission(user?.role?.id, 'KitchenStack') && (
            <PaperDrawer.Section style={styles.drawerSection}>
              <Text style={styles.configSubheader}>Cocina</Text>
              {renderDrawerItemSimple(
                'KitchenStack',
                'Pantalla de Preparaci√≥n',
                'chef-hat',
              )}
            </PaperDrawer.Section>
          )}

          {/* Secci√≥n de Configuraci√≥n - Solo visible si tiene permisos */}
          {DRAWER_SECTIONS.configuration.items.some((item) =>
            hasPermission(user?.role?.id, item.route as DrawerSection),
          ) && (
            <>
              <Divider style={styles.divider} />
              <PaperDrawer.Section style={styles.drawerSection}>
                <Text style={styles.configSubheader}>
                  {DRAWER_SECTIONS.configuration.title}
                </Text>
                {DRAWER_SECTIONS.configuration.items.map((item) =>
                  renderDrawerItemSimple(
                    item.route as DrawerSection,
                    item.label,
                    item.icon,
                  ),
                )}
              </PaperDrawer.Section>
            </>
          )}

          {/* Secci√≥n de Administraci√≥n - Solo visible si tiene permisos */}
          {DRAWER_SECTIONS.administration.items.some((item) =>
            hasPermission(user?.role?.id, item.route as DrawerSection),
          ) && (
            <>
              <Divider style={styles.divider} />

              <PaperDrawer.Section style={styles.drawerSection}>
                <Text style={styles.configSubheader}>
                  {DRAWER_SECTIONS.administration.title}
                </Text>
                {DRAWER_SECTIONS.administration.items.map((item) =>
                  renderDrawerItemSimple(
                    item.route as DrawerSection,
                    item.label,
                    item.icon,
                  ),
                )}
              </PaperDrawer.Section>
            </>
          )}
        </View>
      </DrawerContentScrollView>

      <PaperDrawer.Section style={styles.bottomDrawerSection}>
        <TouchableRipple
          onPress={() => {
            const newPreference = theme.dark
              ? THEME_MODE.LIGHT
              : THEME_MODE.DARK;
            setThemePreference(newPreference);
          }}
          style={styles.preference}
        >
          <View
            style={{
              flexDirection: 'row',
              alignItems: 'center',
              justifyContent: 'space-between',
              width: '100%',
            }}
          >
            <View style={{ flexDirection: 'row', alignItems: 'center' }}>
              <View style={styles.drawerItemIconContainer}>
                <Icon
                  source={theme.dark ? 'weather-night' : 'white-balance-sunny'}
                  size={responsive.isTablet ? 20 : 24}
                  color={theme.colors.onSurfaceVariant}
                />
              </View>
              <Text
                style={[
                  styles.drawerItemLabel,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                Modo Oscuro
              </Text>
            </View>
            <View style={{ pointerEvents: 'none' }}>
              <Switch value={theme.dark} color={theme.colors.primary} />
            </View>
          </View>
        </TouchableRipple>

        <TouchableRipple
          onPress={handleClearCache}
          style={styles.drawerItemContainer}
          rippleColor={`${theme.colors.primary}20`}
        >
          <View style={{ flexDirection: 'row', alignItems: 'center' }}>
            <View style={styles.drawerItemIconContainer}>
              <Icon
                source="broom"
                size={responsive.isTablet ? 20 : 24}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <Text
              style={[
                styles.drawerItemLabel,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Limpiar Cach√©
            </Text>
          </View>
        </TouchableRipple>

        <TouchableRipple
          onPress={() => {
            props.navigation.navigate('ServerSettings');
          }}
          style={styles.drawerItemContainer}
          rippleColor={`${theme.colors.primary}20`}
        >
          <View style={{ flexDirection: 'row', alignItems: 'center' }}>
            <View style={styles.drawerItemIconContainer}>
              <Icon
                source="server-network"
                size={responsive.isTablet ? 20 : 24}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <Text
              style={[
                styles.drawerItemLabel,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Configuraci√≥n del Servidor
            </Text>
          </View>
        </TouchableRipple>

        <TouchableRipple
          onPress={() => {
            logout();
          }}
          style={styles.drawerItemContainer}
          rippleColor={`${theme.colors.error}20`}
        >
          <View style={{ flexDirection: 'row', alignItems: 'center' }}>
            <View style={styles.drawerItemIconContainer}>
              <Icon
                source="logout"
                size={responsive.isTablet ? 20 : 24}
                color={theme.colors.error}
              />
            </View>
            <Text
              style={[styles.drawerItemLabel, { color: theme.colors.error }]}
            >
              Cerrar Sesi√≥n
            </Text>
          </View>
        </TouchableRipple>
      </PaperDrawer.Section>
    </Surface>
  );
}

================
File: app/src/app/schemas/domain/order.schema.ts
================
import { z } from 'zod';
import { adjustmentSchema } from './adjustment.schema';
import { DeliveryInfoSchema } from './delivery-info.schema';
import { tableSchema } from './table.schema';

// Definir enums localmente para evitar dependencias circulares
enum PizzaHalf {
  FULL = 'FULL',
  HALF_1 = 'HALF_1',
  HALF_2 = 'HALF_2',
}

enum CustomizationAction {
  ADD = 'ADD',
  REMOVE = 'REMOVE',
}

// Enum para los estados de la orden
export const orderStatusSchema = z.enum([
  'PENDING',
  'IN_PROGRESS',
  'IN_PREPARATION',
  'READY',
  'DELIVERED',
  'COMPLETED',
  'CANCELLED',
]);
export type OrderStatus = z.infer<typeof orderStatusSchema>;

// Enum para los tipos de orden
export const orderTypeSchema = z.enum(['DINE_IN', 'TAKE_AWAY', 'DELIVERY']);
export type OrderType = z.infer<typeof orderTypeSchema>;

// Schema para los modificadores dentro de un √≠tem de orden
export const orderItemModifierSchema = z.object({
  productModifierId: z.string(),
  modifierName: z.string(),
  price: z.number(),
});
export type OrderItemModifier = z.infer<typeof orderItemModifierSchema>;

// Schema para las personalizaciones de pizza seleccionadas
export const selectedPizzaCustomizationSchema = z.object({
  pizzaCustomizationId: z.string(),
  pizzaCustomization: z
    .object({
      id: z.string(),
      name: z.string(),
      type: z.enum(['FLAVOR', 'INGREDIENT']),
      ingredients: z.string().nullable().optional(),
      toppingValue: z.number(),
      isActive: z.boolean(),
      sortOrder: z.number(),
    })
    .optional(),
  half: z.nativeEnum(PizzaHalf),
  action: z.nativeEnum(CustomizationAction),
});
export type SelectedPizzaCustomization = z.infer<
  typeof selectedPizzaCustomizationSchema
>;

// Schema para un √≠tem individual de la orden
export const orderItemSchema = z.object({
  id: z.string(),
  productId: z.string().uuid(),
  productName: z.string(),
  quantity: z.number().int().positive(),
  unitPrice: z.number(),
  totalPrice: z.number(),
  modifiers: z.array(orderItemModifierSchema),
  variantId: z.string().uuid().nullable().optional(),
  variantName: z.string().nullable().optional(),
  notes: z.string().nullable().optional(),
  selectedPizzaCustomizations: z
    .array(selectedPizzaCustomizationSchema)
    .optional(),
});
export type OrderItem = z.infer<typeof orderItemSchema>;

// Schema para la orden completa
export const orderSchema = z.object({
  id: z.string().uuid(),
  orderNumber: z.string().optional(),
  shiftOrderNumber: z.number().int().positive(),
  orderItems: z.array(z.any()).optional(),
  total: z.union([z.string(), z.number()]).optional(),
  orderStatus: orderStatusSchema,
  orderType: orderTypeSchema,
  createdAt: z.union([z.string().datetime(), z.date()]),
  updatedAt: z.union([z.string().datetime(), z.date()]),
  finalizedAt: z.union([z.string().datetime(), z.date()]).nullable().optional(),
  userId: z.string().uuid().nullable().optional(),
  tableId: z.string().uuid().nullable().optional(),
  notes: z.string().nullable().optional(),
  scheduledAt: z.union([z.string().datetime(), z.date()]).nullable().optional(),
  deliveryInfo: DeliveryInfoSchema,
  user: z.any().optional(),
  table: tableSchema.optional(),
  payments: z.array(z.any()).optional(),
  deletedAt: z.string().nullable().optional(),
  adjustments: z.array(adjustmentSchema).optional(),
  subtotal: z.union([z.string(), z.number()]).optional(),
  isFromWhatsApp: z.boolean().optional().default(false),
  estimatedDeliveryTime: z
    .union([z.string().datetime(), z.date()])
    .nullable()
    .optional(),
});
export type Order = z.infer<typeof orderSchema>;

================
File: app/src/app/utils/networkDiagnostics.ts
================
import axios from 'axios';
import NetInfo from '@react-native-community/netinfo';
import { serverConnectionService } from '@/services/serverConnectionService';
import { API_PATHS } from '@/app/constants/apiPaths';

interface NetworkDiagnosticResult {
  timestamp: Date;
  apiUrl: string;
  networkState: {
    isConnected: boolean | null;
    isInternetReachable: boolean | null;
    type: string;
    details: any;
  };
  apiTest: {
    success: boolean;
    responseTime?: number;
    error?: string;
    errorCode?: string;
  };
  dnsTest: {
    success: boolean;
    responseTime?: number;
    error?: string;
  };
  recommendations: string[];
}

export async function runNetworkDiagnostics(): Promise<NetworkDiagnosticResult> {
  // Obtener la URL del servicio de conexi√≥n sin provocar discovery
  const connectionState = serverConnectionService.getState();
  const apiUrl = connectionState.serverUrl || '';

  const result: NetworkDiagnosticResult = {
    timestamp: new Date(),
    apiUrl: apiUrl || 'URL no disponible',
    networkState: {
      isConnected: null,
      isInternetReachable: null,
      type: 'unknown',
      details: null,
    },
    apiTest: {
      success: false,
    },
    dnsTest: {
      success: false,
    },
    recommendations: [],
  };

  // Iniciando diagn√≥stico de red...

  // 1. Verificar estado de la red
  try {
    const netInfoState = await NetInfo.fetch();
    result.networkState = {
      isConnected: netInfoState.isConnected,
      isInternetReachable: netInfoState.isInternetReachable,
      type: netInfoState.type,
      details: netInfoState.details,
    };
    // Estado de red obtenido
  } catch (error: any) {
    // Error obteniendo estado de red
  }

  // 2. Probar conexi√≥n directa a la API
  const apiStartTime = Date.now();
  try {
    // Probando conexi√≥n a API
    const baseUrl = apiUrl.endsWith('/') ? apiUrl.slice(0, -1) : apiUrl;
    const response = await axios.get(`${baseUrl}${API_PATHS.HEALTH}`, {
      timeout: 5000,
      validateStatus: () => true, // Aceptar cualquier status
    });
    const responseTime = Date.now() - apiStartTime;

    result.apiTest = {
      success: response.status < 500,
      responseTime,
      error: response.status >= 500 ? `Status ${response.status}` : undefined,
    };
    // Resultado API test obtenido
  } catch (error: any) {
    const responseTime = Date.now() - apiStartTime;
    result.apiTest = {
      success: false,
      responseTime,
      error: error.message,
      errorCode: error.code,
    };
    // Error en API test
  }

  // 3. Probar resoluci√≥n DNS con un servicio externo
  const dnsStartTime = Date.now();
  try {
    // Probando DNS con servicio externo...
    await axios.get('https://dns.google/resolve?name=google.com', {
      timeout: 5000,
    });
    const responseTime = Date.now() - dnsStartTime;

    result.dnsTest = {
      success: true,
      responseTime,
    };
    // DNS test exitoso
  } catch (error: any) {
    const responseTime = Date.now() - dnsStartTime;
    result.dnsTest = {
      success: false,
      responseTime,
      error: error.message,
    };
    // Error en DNS test
  }

  // 4. Generar recomendaciones basadas en los resultados
  if (!result.networkState.isConnected) {
    result.recommendations.push(
      'No hay conexi√≥n de red. Verifica tu WiFi o datos m√≥viles.',
    );
  }

  if (
    result.networkState.isConnected &&
    !result.networkState.isInternetReachable
  ) {
    result.recommendations.push(
      'Conectado a la red pero sin acceso a Internet. Verifica tu router o punto de acceso.',
    );
  }

  if (!result.apiTest.success && result.apiTest.errorCode === 'ECONNREFUSED') {
    result.recommendations.push(
      'El servidor backend no est√° respondiendo. Verifica que est√© en ejecuci√≥n.',
    );
  }

  if (!result.apiTest.success && result.apiTest.errorCode === 'ETIMEDOUT') {
    result.recommendations.push(
      'Timeout al conectar con el servidor. Posible problema de red local o firewall.',
    );
  }

  if (!result.apiTest.success && result.apiTest.errorCode === 'ENOTFOUND') {
    result.recommendations.push(
      'No se puede resolver la direcci√≥n del servidor. Verifica la configuraci√≥n de API_URL.',
    );
  }

  if (result.apiTest.responseTime && result.apiTest.responseTime > 3000) {
    result.recommendations.push(
      'La latencia de red es muy alta. Considera acercarte al router o usar una conexi√≥n m√°s estable.',
    );
  }

  if (!result.dnsTest.success) {
    result.recommendations.push(
      'Problemas con la resoluci√≥n DNS. Intenta cambiar los servidores DNS de tu red.',
    );
  }

  // Recomendaciones espec√≠ficas para el problema del PC
  if (
    result.apiTest.errorCode === 'ECONNRESET' ||
    result.apiTest.errorCode === 'ECONNABORTED'
  ) {
    result.recommendations.push(
      'La conexi√≥n se est√° interrumpiendo. Posibles causas:',
    );
    result.recommendations.push('- Firewall o antivirus interfiriendo');
    result.recommendations.push('- Problemas con el adaptador de red');
    result.recommendations.push(
      '- Configuraci√≥n de ahorro de energ√≠a en el adaptador',
    );
    result.recommendations.push('- Driver de red desactualizado');
  }

  // Diagn√≥stico completo
  return result;
}

export function formatDiagnosticResult(
  result: NetworkDiagnosticResult,
): string {
  let output = '=== DIAGN√ìSTICO DE RED ===\n\n';

  output += `Fecha: ${result.timestamp.toLocaleString()}\n`;
  output += `URL de API: ${result.apiUrl}\n\n`;

  output += 'üì° ESTADO DE RED:\n';
  output += `- Conectado: ${result.networkState.isConnected ? 'S√≠' : 'No'}\n`;
  output += `- Internet accesible: ${result.networkState.isInternetReachable ? 'S√≠' : 'No'}\n`;
  output += `- Tipo: ${result.networkState.type}\n\n`;

  output += 'üîå TEST DE API:\n';
  output += `- Exitoso: ${result.apiTest.success ? 'S√≠' : 'No'}\n`;
  if (result.apiTest.responseTime) {
    output += `- Tiempo de respuesta: ${result.apiTest.responseTime}ms\n`;
  }
  if (result.apiTest.error) {
    output += `- Error: ${result.apiTest.error}\n`;
    output += `- C√≥digo: ${result.apiTest.errorCode || 'N/A'}\n`;
  }
  output += '\n';

  output += 'üåê TEST DNS:\n';
  output += `- Exitoso: ${result.dnsTest.success ? 'S√≠' : 'No'}\n`;
  if (result.dnsTest.responseTime) {
    output += `- Tiempo de respuesta: ${result.dnsTest.responseTime}ms\n`;
  }
  if (result.dnsTest.error) {
    output += `- Error: ${result.dnsTest.error}\n`;
  }
  output += '\n';

  if (result.recommendations.length > 0) {
    output += 'üí° RECOMENDACIONES:\n';
    result.recommendations.forEach((rec) => {
      output += `- ${rec}\n`;
    });
  }

  return output;
}

================
File: app/src/app/utils/roleUtils.ts
================
import type { User } from '@/modules/auth/schema/auth.schema';

/**
 * Enum de roles basado en los IDs del backend
 */
export enum RoleEnum {
  ADMIN = 1,
  MANAGER = 2,
  CASHIER = 3,
  WAITER = 4,
  KITCHEN = 5,
}

/**
 * Verifica si el usuario tiene un rol espec√≠fico
 */
export const hasRole = (user: User | null, roleId: RoleEnum): boolean => {
  return user?.role?.id === roleId;
};

/**
 * Verifica si el usuario tiene alguno de los roles especificados
 */
export const hasAnyRole = (user: User | null, roleIds: RoleEnum[]): boolean => {
  if (!user?.role?.id) return false;
  return roleIds.includes(user.role.id);
};

/**
 * Verificaciones de roles espec√≠ficos
 */
export const isAdmin = (user: User | null): boolean => {
  return hasRole(user, RoleEnum.ADMIN);
};

export const isManager = (user: User | null): boolean => {
  return hasRole(user, RoleEnum.MANAGER);
};

export const isCashier = (user: User | null): boolean => {
  return hasRole(user, RoleEnum.CASHIER);
};

export const isWaiter = (user: User | null): boolean => {
  return hasRole(user, RoleEnum.WAITER);
};

export const isKitchen = (user: User | null): boolean => {
  return hasRole(user, RoleEnum.KITCHEN);
};

/**
 * Permisos espec√≠ficos de funcionalidad
 */
export const canOpenShift = (user: User | null): boolean => {
  return hasAnyRole(user, [RoleEnum.ADMIN, RoleEnum.MANAGER]);
};

export const canRegisterPayments = (user: User | null): boolean => {
  return hasAnyRole(user, [RoleEnum.ADMIN, RoleEnum.MANAGER, RoleEnum.CASHIER]);
};

export const canManageOrders = (user: User | null): boolean => {
  return hasAnyRole(user, [
    RoleEnum.ADMIN,
    RoleEnum.MANAGER,
    RoleEnum.WAITER,
    RoleEnum.CASHIER,
  ]);
};

export const canAccessKitchen = (user: User | null): boolean => {
  return hasRole(user, RoleEnum.KITCHEN);
};

/**
 * Obtiene el nombre del rol para mostrar en la UI
 */
export const getRoleName = (user: User | null): string => {
  if (!user?.role) return 'Sin rol';

  // Usar el nombre del rol si est√° disponible
  if (user.role.name) {
    return user.role.name;
  }

  // Fallback basado en el ID
  switch (user.role.id) {
    case RoleEnum.ADMIN:
      return 'Administrador';
    case RoleEnum.MANAGER:
      return 'Gerente';
    case RoleEnum.CASHIER:
      return 'Cajero';
    case RoleEnum.WAITER:
      return 'Mesero';
    case RoleEnum.KITCHEN:
      return 'Cocina';
    default:
      return 'Usuario';
  }
};

================
File: app/src/modules/auth/components/LoginForm.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, Text } from 'react-native';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import {
  TextInput,
  Button,
  HelperText,
  Checkbox,
  TouchableRipple,
} from 'react-native-paper';
import { useAppTheme } from '../../../app/styles/theme';
import { useResponsive } from '../../../app/hooks/useResponsive';
import { loginSchema, LoginFormInputs } from '../schema/auth.schema';

interface LoginFormProps {
  onSubmit: (data: LoginFormInputs, rememberMe: boolean) => void;
  isLoading: boolean;
  initialEmailOrUsername?: string;
  initialPassword?: string;
  initialRememberMe?: boolean;
}

const LoginForm: React.FC<LoginFormProps> = ({
  onSubmit,
  isLoading,
  initialEmailOrUsername = '',
  initialPassword = '',
  initialRememberMe = false,
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const [secureTextEntry, setSecureTextEntry] = useState(true);
  const [rememberMe, setRememberMe] = useState(initialRememberMe);

  const {
    control,
    handleSubmit,
    formState: { errors },
    reset,
  } = useForm<LoginFormInputs>({
    resolver: zodResolver(loginSchema),
    defaultValues: {
      emailOrUsername: initialEmailOrUsername,
      password: initialPassword,
    },
  });

  React.useEffect(() => {
    if (initialEmailOrUsername || initialPassword) {
      reset({
        emailOrUsername: initialEmailOrUsername || '',
        password: initialPassword || '',
      });
    }
  }, [initialEmailOrUsername, initialPassword, reset]);

  const toggleSecureEntry = () => {
    setSecureTextEntry(!secureTextEntry);
  };

  const styles = React.useMemo(
    () =>
      StyleSheet.create({
        container: {
          width: '100%',
        },
        input: {
          marginBottom: 8,
          fontSize: responsive.fontSizePreset.m,
        },
        firstInput: {
          marginTop: responsive.spacingPreset.xs,
        },
        button: {
          marginTop: 16,
          paddingVertical: responsive.spacingPreset.xs,
        },
        helperText: {
          marginBottom: responsive.spacingPreset.xs,
          fontSize: responsive.fontSizePreset.s,
        },
        checkboxContainer: {
          flexDirection: 'row',
          alignItems: 'center',
          marginTop: 4,
          marginBottom: 8,
        },
        checkbox: {},
        checkboxLabel: {
          color: theme.colors.onSurface,
          marginLeft: responsive.spacingPreset.s,
          flex: 1,
          flexShrink: 1,
          fontSize: responsive.fontSizePreset.m,
        },
      }),
    [theme, responsive],
  );

  return (
    <View style={styles.container}>
      <Controller
        control={control}
        name="emailOrUsername"
        render={({ field: { onChange, onBlur, value } }) => (
          <View>
            <TextInput
              label="Correo o Usuario"
              mode="outlined"
              onBlur={onBlur}
              onChangeText={onChange}
              value={value}
              error={!!errors.emailOrUsername}
              style={[styles.input, styles.firstInput]}
              autoCapitalize="none"
              keyboardType="email-address"
              disabled={isLoading}
            />
            {errors.emailOrUsername && (
              <HelperText
                type="error"
                visible={!!errors.emailOrUsername}
                style={styles.helperText}
              >
                <Text>{errors.emailOrUsername?.message}</Text>
              </HelperText>
            )}
          </View>
        )}
      />

      <Controller
        control={control}
        name="password"
        render={({ field: { onChange, onBlur, value } }) => (
          <View>
            <TextInput
              label="Contrase√±a"
              mode="outlined"
              onBlur={onBlur}
              onChangeText={onChange}
              value={value}
              secureTextEntry={secureTextEntry}
              error={!!errors.password}
              style={styles.input}
              autoCapitalize="none"
              right={
                <TextInput.Icon
                  icon={secureTextEntry ? 'eye' : 'eye-off'}
                  onPress={toggleSecureEntry}
                  forceTextInputFocus={false}
                  color={errors.password ? theme.colors.error : undefined}
                />
              }
              disabled={isLoading}
            />
            {errors.password && (
              <HelperText
                type="error"
                visible={!!errors.password}
                style={styles.helperText}
              >
                <Text>{errors.password?.message}</Text>
              </HelperText>
            )}
          </View>
        )}
      />

      <TouchableRipple
        onPress={() => !isLoading && setRememberMe(!rememberMe)}
        style={styles.checkboxContainer}
        disabled={isLoading}
      >
        <>
          <Checkbox
            status={rememberMe ? 'checked' : 'unchecked'}
            onPress={() => setRememberMe(!rememberMe)}
            disabled={isLoading}
          />
          <Text
            style={styles.checkboxLabel}
            numberOfLines={1}
            adjustsFontSizeToFit
            minimumFontScale={0.8}
            disabled={isLoading}
          >
            Recordarme
          </Text>
        </>
      </TouchableRipple>

      <Button
        mode="contained"
        onPress={handleSubmit((data) => onSubmit(data, rememberMe))}
        loading={isLoading}
        disabled={isLoading}
        style={[
          styles.button,
          {
            backgroundColor: theme.colors.primary,
            borderRadius: 30,
          },
        ]}
        contentStyle={{
          height: 42,
          paddingHorizontal: responsive.spacingPreset.s,
        }}
        labelStyle={{
          fontSize: responsive.fontSizePreset.m,
          fontWeight: '600',
        }}
      >
        {isLoading ? 'Ingresando...' : 'Ingresar'}
      </Button>
    </View>
  );
};

export default LoginForm;

================
File: app/src/modules/availability/components/CategoryAvailabilityItem.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, Switch, Divider, IconButton } from 'react-native-paper';
import { CategoryAvailability } from '../types/availability.types';
import { useOptimisticAvailability } from '../hooks/useOptimisticAvailability';
import { useAppTheme } from '@/app/styles/theme';
import { AvailabilityListItem } from './AvailabilityListItem';

interface CategoryAvailabilityItemProps {
  category: CategoryAvailability;
  onRefresh?: () => void;
}

export const CategoryAvailabilityItem: React.FC<
  CategoryAvailabilityItemProps
> = ({ category, onRefresh: _onRefresh }) => {
  const theme = useAppTheme();
  const [expanded, setExpanded] = useState(false);
  const updateAvailability = useOptimisticAvailability();

  const handleCategoryToggle = (value: boolean) => {
    updateAvailability.mutate({
      type: 'category',
      id: category.id,
      isActive: value,
      cascade: true,
    });
  };

  const handleSubcategoryToggle = (subcategoryId: string, value: boolean) => {
    updateAvailability.mutate({
      type: 'subcategory',
      id: subcategoryId,
      isActive: value,
      cascade: true,
    });
  };

  const handleProductToggle = (productId: string, value: boolean) => {
    updateAvailability.mutate({
      type: 'product',
      id: productId,
      isActive: value,
    });
  };

  const totalProducts = category.subcategories.reduce(
    (acc, sub) => acc + sub.products.length,
    0,
  );
  const activeProducts = category.subcategories.reduce(
    (acc, sub) => acc + sub.products.filter((p) => p.isActive).length,
    0,
  );

  return (
    <AvailabilityListItem
      title={category.name}
      subtitle={`${activeProducts}/${totalProducts} productos activos`}
      icon="folder-outline"
      isActive={category.isActive}
      onToggle={handleCategoryToggle}
      isExpanded={expanded}
      onToggleExpand={() => setExpanded(!expanded)}
    >
      {category.subcategories.map((subcategory, index) => (
        <View key={subcategory.id}>
          {index > 0 && <Divider style={styles.divider} />}
          <View
            style={[
              styles.subcategoryHeader,
              { opacity: subcategory.isActive ? 1 : 0.6 },
            ]}
          >
            <View style={styles.subcategoryLeft}>
              <IconButton
                icon="folder-open-outline"
                size={16}
                iconColor={
                  subcategory.isActive
                    ? theme.colors.primary
                    : theme.colors.outline
                }
                style={{ margin: 0, marginRight: 8 }}
              />
              <Text
                style={[
                  styles.subcategoryTitle,
                  { color: theme.colors.onSurface },
                ]}
              >
                {subcategory.name}
              </Text>
            </View>
            <Switch
              value={subcategory.isActive}
              onValueChange={(value) =>
                handleSubcategoryToggle(subcategory.id, value)
              }
              disabled={!category.isActive}
            />
          </View>
          <View style={styles.productsContainer}>
            {subcategory.products.map((product) => (
              <View
                key={product.id}
                style={[
                  styles.productItem,
                  { opacity: !product.isActive ? 0.5 : 1 },
                ]}
              >
                <Text
                  style={[
                    styles.productTitle,
                    !product.isActive && styles.strikethrough,
                    { color: theme.colors.onSurface },
                  ]}
                >
                  {product.name}
                </Text>
                <Switch
                  value={product.isActive}
                  onValueChange={(value) =>
                    handleProductToggle(product.id, value)
                  }
                  disabled={!category.isActive || !subcategory.isActive}
                />
              </View>
            ))}
          </View>
        </View>
      ))}
    </AvailabilityListItem>
  );
};

const styles = StyleSheet.create({
  divider: {
    marginVertical: 8,
  },
  subcategoryHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 8,
  },
  subcategoryLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  subcategoryTitle: {
    fontSize: 14,
    fontWeight: '500',
  },
  productsContainer: {
    paddingLeft: 16,
  },
  productItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 4,
  },
  productTitle: {
    fontSize: 13,
  },
  strikethrough: {
    textDecorationLine: 'line-through',
  },
});

================
File: app/src/modules/availability/components/PizzaCustomizationAvailabilityItem.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, Switch, Divider } from 'react-native-paper';
import { PizzaCustomizationGroupAvailability } from '../types/availability.types';
import { useOptimisticAvailability } from '../hooks/useOptimisticAvailability';
import { useAppTheme } from '@/app/styles/theme';
import { AvailabilityListItem } from './AvailabilityListItem';

interface PizzaCustomizationAvailabilityItemProps {
  group: PizzaCustomizationGroupAvailability;
}

export function PizzaCustomizationAvailabilityItem({
  group,
}: PizzaCustomizationAvailabilityItemProps) {
  const theme = useAppTheme();
  const [expanded, setExpanded] = useState(false);
  const updateAvailability = useOptimisticAvailability();

  const handleToggle = (id: string, currentState: boolean) => {
    updateAvailability.mutate({
      type: 'pizzaCustomization',
      id,
      isActive: !currentState,
    });
  };

  const activeCount = group.items.filter((item) => item.isActive).length;
  const totalCount = group.items.length;
  const allActive = activeCount === totalCount;
  const someActive = activeCount > 0 && activeCount < totalCount;

  const getTypeIcon = () => {
    return group.type === 'FLAVOR' ? 'pizza' : 'cheese';
  };

  const getTypeLabel = () => {
    return group.type === 'FLAVOR' ? 'Sabores' : 'Ingredientes';
  };

  const getSubtitle = () => {
    if (allActive) return 'Todos disponibles';
    if (!allActive && !someActive) return 'Ninguno disponible';
    return `${activeCount} de ${totalCount} disponibles`;
  };

  return (
    <AvailabilityListItem
      title={getTypeLabel()}
      subtitle={getSubtitle()}
      icon={getTypeIcon()}
      isActive={allActive}
      onToggle={() => {}} // No toggle para el grupo completo en este caso
      isExpanded={expanded}
      onToggleExpand={() => setExpanded(!expanded)}
    >
      {group.items.map((item, index) => (
        <React.Fragment key={item.id}>
          <View style={styles.item}>
            <Text
              style={[
                styles.itemName,
                !item.isActive && styles.strikethrough,
                { color: theme.colors.onSurface },
              ]}
            >
              {item.name}
            </Text>
            <Switch
              value={item.isActive}
              onValueChange={() => handleToggle(item.id, item.isActive)}
            />
          </View>
          {index < group.items.length - 1 && <Divider style={styles.divider} />}
        </React.Fragment>
      ))}
    </AvailabilityListItem>
  );
}

const styles = StyleSheet.create({
  item: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 4,
  },
  itemName: {
    fontSize: 13,
  },
  strikethrough: {
    textDecorationLine: 'line-through',
  },
  divider: {
    marginVertical: 8,
  },
});

================
File: app/src/modules/availability/screens/AvailabilityScreen.tsx
================
import React, { useState, useMemo, useCallback } from 'react';
import { View, StyleSheet, RefreshControl, FlatList } from 'react-native';
import {
  Searchbar,
  SegmentedButtons as _SegmentedButtons,
  ActivityIndicator,
  Surface,
  Text,
  Menu,
  IconButton,
  Badge as _Badge,
} from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { CategoryAvailabilityItem } from '../components/CategoryAvailabilityItem';
import { ModifierGroupAvailabilityItem } from '../components/ModifierGroupAvailabilityItem';
import { PizzaCustomizationAvailabilityItem } from '../components/PizzaCustomizationAvailabilityItem';
import {
  useMenuAvailability,
  useModifierGroupsAvailability,
} from '../hooks/useAvailabilityQueries';
import { usePizzaCustomizationsAvailability } from '../hooks/usePizzaCustomizationsAvailability';
import EmptyState from '@/app/components/common/EmptyState';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';

export const AvailabilityScreen: React.FC = () => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const [searchQuery, setSearchQuery] = useState('');
  const [viewMode, setViewMode] = useState<
    'menu' | 'modifiers' | 'pizzaCustomizations'
  >('menu');
  const [filterMenuVisible, setFilterMenuVisible] = useState(false);

  const {
    data: menuData,
    isLoading: isLoadingMenu,
    isError: isErrorMenu,
    refetch: refetchMenu,
  } = useMenuAvailability();

  const {
    data: modifiersData,
    isLoading: isLoadingModifiers,
    isError: isErrorModifiers,
    refetch: refetchModifiers,
  } = useModifierGroupsAvailability();

  const {
    data: pizzaCustomizationsData,
    isLoading: isLoadingPizzaCustomizations,
    isError: isErrorPizzaCustomizations,
    refetch: refetchPizzaCustomizations,
  } = usePizzaCustomizationsAvailability(searchQuery);

  // Recargar autom√°ticamente cuando la pantalla recibe foco
  useRefreshModuleOnFocus('availability');

  const handleRefresh = useCallback(() => {
    if (viewMode === 'menu') {
      refetchMenu();
    } else if (viewMode === 'modifiers') {
      refetchModifiers();
    } else {
      refetchPizzaCustomizations();
    }
  }, [viewMode, refetchMenu, refetchModifiers, refetchPizzaCustomizations]);

  const filteredMenuData = useMemo(() => {
    if (!menuData) return [];

    return menuData
      .map((category) => ({
        ...category,
        subcategories: category.subcategories
          .map((subcategory) => ({
            ...subcategory,
            products: subcategory.products.filter((product) => {
              const matchesSearch = product.name
                .toLowerCase()
                .includes(searchQuery.toLowerCase());
              return matchesSearch;
            }),
          }))
          .filter((subcategory) => subcategory.products.length > 0),
      }))
      .filter((category) => category.subcategories.length > 0);
  }, [menuData, searchQuery]);

  const filteredModifiersData = useMemo(() => {
    if (!modifiersData) return [];

    return modifiersData
      .map((group) => ({
        ...group,
        modifiers: group.modifiers.filter((modifier) => {
          const matchesSearch = modifier.name
            .toLowerCase()
            .includes(searchQuery.toLowerCase());
          return matchesSearch;
        }),
      }))
      .filter((group) => {
        const matchesSearch = group.name
          .toLowerCase()
          .includes(searchQuery.toLowerCase());
        return matchesSearch || group.modifiers.length > 0;
      });
  }, [modifiersData, searchQuery]);

  const isLoading =
    viewMode === 'menu'
      ? isLoadingMenu
      : viewMode === 'modifiers'
        ? isLoadingModifiers
        : isLoadingPizzaCustomizations;

  const isError =
    viewMode === 'menu'
      ? isErrorMenu
      : viewMode === 'modifiers'
        ? isErrorModifiers
        : isErrorPizzaCustomizations;

  const isEmpty =
    viewMode === 'menu'
      ? filteredMenuData.length === 0
      : viewMode === 'modifiers'
        ? filteredModifiersData.length === 0
        : !pizzaCustomizationsData || pizzaCustomizationsData.length === 0;

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.colors.background }]}
      edges={['top']}
    >
      <Surface style={styles.header} elevation={2}>
        <View style={styles.searchRow}>
          <Searchbar
            placeholder={`Buscar ${viewMode === 'menu' ? 'productos' : viewMode === 'modifiers' ? 'modificadores' : 'ingredientes y sabores'}...`}
            onChangeText={setSearchQuery}
            value={searchQuery}
            style={styles.searchbar}
            elevation={0}
            icon="magnify"
            inputStyle={{ color: theme.colors.onSurface }}
            placeholderTextColor={theme.colors.onSurfaceVariant}
            iconColor={theme.colors.onSurfaceVariant}
          />
          <View style={styles.filterButtonContainer}>
            <Menu
              visible={filterMenuVisible}
              onDismiss={() => setFilterMenuVisible(false)}
              anchor={
                <IconButton
                  icon={
                    viewMode === 'menu'
                      ? 'food'
                      : viewMode === 'modifiers'
                        ? 'tune'
                        : 'cheese'
                  }
                  mode="contained-tonal"
                  size={24}
                  onPress={() => setFilterMenuVisible(true)}
                  style={styles.filterIconButton}
                />
              }
              anchorPosition="bottom"
              contentStyle={styles.menuContent}
            >
              <Menu.Item
                onPress={() => {
                  setViewMode('menu');
                  setFilterMenuVisible(false);
                }}
                title="Men√∫"
                leadingIcon="food"
                trailingIcon={viewMode === 'menu' ? 'check' : undefined}
                titleStyle={
                  viewMode === 'menu'
                    ? { color: theme.colors.primary, fontWeight: '600' }
                    : undefined
                }
              />
              <Menu.Item
                onPress={() => {
                  setViewMode('modifiers');
                  setFilterMenuVisible(false);
                }}
                title="Modificadores"
                leadingIcon="tune"
                trailingIcon={viewMode === 'modifiers' ? 'check' : undefined}
                titleStyle={
                  viewMode === 'modifiers'
                    ? { color: theme.colors.primary, fontWeight: '600' }
                    : undefined
                }
              />
              <Menu.Item
                onPress={() => {
                  setViewMode('pizzaCustomizations');
                  setFilterMenuVisible(false);
                }}
                title="Ingredientes Pizza"
                leadingIcon="cheese"
                trailingIcon={
                  viewMode === 'pizzaCustomizations' ? 'check' : undefined
                }
                titleStyle={
                  viewMode === 'pizzaCustomizations'
                    ? { color: theme.colors.primary, fontWeight: '600' }
                    : undefined
                }
              />
            </Menu>
          </View>
        </View>
      </Surface>

      <View style={styles.content}>
        {isLoading ? (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
            <Text
              style={[
                styles.loadingText,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Cargando{' '}
              {viewMode === 'menu'
                ? 'categor√≠as'
                : viewMode === 'modifiers'
                  ? 'modificadores'
                  : 'ingredientes'}
              ...
            </Text>
          </View>
        ) : isError ? (
          <EmptyState
            title="Error al cargar datos"
            message="No se pudieron cargar los datos. Verifica tu conexi√≥n."
            icon="alert-circle-outline"
            actionLabel="Reintentar"
            onAction={handleRefresh}
          />
        ) : isEmpty ? (
          <EmptyState
            title="No se encontraron resultados"
            message={
              searchQuery
                ? 'Intenta con otros t√©rminos de b√∫squeda'
                : 'No hay elementos para mostrar'
            }
            icon="magnify"
          />
        ) : viewMode === 'menu' ? (
          <FlatList
            data={filteredMenuData}
            keyExtractor={(item) => item.id}
            renderItem={({ item }) => (
              <CategoryAvailabilityItem
                category={item}
                onRefresh={handleRefresh}
              />
            )}
            refreshControl={
              <RefreshControl
                refreshing={isLoading}
                onRefresh={handleRefresh}
                colors={[theme.colors.primary]}
              />
            }
            contentContainerStyle={styles.listContent}
            showsVerticalScrollIndicator={false}
            ItemSeparatorComponent={() => (
              <View style={{ height: responsive.spacing(theme.spacing.s) }} />
            )}
          />
        ) : viewMode === 'modifiers' ? (
          <FlatList
            data={filteredModifiersData}
            keyExtractor={(item) => item.id}
            renderItem={({ item }) => (
              <ModifierGroupAvailabilityItem
                modifierGroup={item}
                onRefresh={handleRefresh}
              />
            )}
            refreshControl={
              <RefreshControl
                refreshing={isLoading}
                onRefresh={handleRefresh}
                colors={[theme.colors.primary]}
              />
            }
            contentContainerStyle={styles.listContent}
            showsVerticalScrollIndicator={false}
            ItemSeparatorComponent={() => (
              <View style={{ height: responsive.spacing(theme.spacing.s) }} />
            )}
          />
        ) : (
          <FlatList
            data={pizzaCustomizationsData || []}
            keyExtractor={(item) => item.type}
            renderItem={({ item }) => (
              <PizzaCustomizationAvailabilityItem group={item} />
            )}
            refreshControl={
              <RefreshControl
                refreshing={isLoading}
                onRefresh={handleRefresh}
                colors={[theme.colors.primary]}
              />
            }
            contentContainerStyle={styles.listContent}
            showsVerticalScrollIndicator={false}
            ItemSeparatorComponent={() => (
              <View style={{ height: responsive.spacing(theme.spacing.s) }} />
            )}
          />
        )}
      </View>
    </SafeAreaView>
  );
};

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
    },
    header: {
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.m),
      paddingBottom: responsive.spacing(theme.spacing.m),
      borderBottomLeftRadius: 24,
      borderBottomRightRadius: 24,
    },
    searchRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.spacing(theme.spacing.s),
    },
    searchbar: {
      flex: 1,
      borderRadius: 12,
      height: responsive.isTablet ? 42 : 48,
    },
    filterButtonContainer: {
      position: 'relative',
    },
    filterIconButton: {
      margin: 0,
    },
    menuContent: {
      marginTop: responsive.spacing(4),
    },
    content: {
      flex: 1,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
    loadingText: {
      marginTop: responsive.spacing(theme.spacing.m),
      fontSize: responsive.fontSize(14),
    },
    listContent: {
      paddingVertical: responsive.spacing(theme.spacing.m),
    },
  });

================
File: app/src/modules/customers/screens/CustomersScreen.tsx
================
import React, { useMemo, useCallback, useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { Portal, Text } from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useDrawerStatus } from '@react-navigation/drawer';
import debounce from 'lodash.debounce';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';

import {
  useCustomers,
  useCreateCustomer,
  useUpdateCustomer,
  useDeleteCustomer,
} from '../hooks/useCustomersQueries';
import { Customer } from '../types/customer.types';
import { CustomerFormInputs } from '../schema/customer.schema';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import GenericList, { FilterOption } from '@/app/components/crud/GenericList';
import GenericDetailModal from '@/app/components/crud/GenericDetailModal';
import CustomerFormModal from '../components/CustomerFormModal';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { useCrudScreenLogic } from '@/app/hooks/useCrudScreenLogic';
import { useListState } from '@/app/hooks/useListState';
import { formatCurrency } from '@/app/lib/formatters';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';

function CustomersScreen(): React.ReactElement {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme as AppTheme), [theme]);
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';

  const [searchQuery, setSearchQuery] = useState('');
  const [statusFilter, setStatusFilter] = useState<
    'all' | 'active' | 'inactive' | 'banned'
  >('all');
  const [debouncedSearchQuery, setDebouncedSearchQuery] = useState('');
  const [selectedCustomer, setSelectedCustomer] = useState<Customer | null>(
    null,
  );
  const [detailModalVisible, setDetailModalVisible] = useState(false);
  const [showDeleteConfirmation, setShowDeleteConfirmation] = useState(false);
  const [customerToDelete, setCustomerToDelete] = useState<string | null>(null);

  const debouncedSetSearch = useCallback(
    debounce((query: string) => setDebouncedSearchQuery(query), 300),
    [],
  );

  const handleSearchChange = (query: string) => {
    setSearchQuery(query);
    debouncedSetSearch(query);
  };

  const handleFilterChange = (value: string | number) => {
    if (
      value === 'all' ||
      value === 'active' ||
      value === 'inactive' ||
      value === 'banned'
    ) {
      setStatusFilter(value);
    } else {
      setStatusFilter('all');
    }
  };

  const queryFilters = useMemo(() => {
    const filters: any = {};

    // Solo agregar b√∫squeda si hay texto
    if (debouncedSearchQuery) {
      filters.firstName = debouncedSearchQuery;
      filters.lastName = debouncedSearchQuery;
    }

    // Manejar filtros de estado
    if (statusFilter === 'active') {
      filters.isActive = true;
    } else if (statusFilter === 'inactive') {
      filters.isActive = false;
    } else if (statusFilter === 'banned') {
      filters.isBanned = true;
    }

    return filters;
  }, [debouncedSearchQuery, statusFilter]);

  const {
    data: customers,
    isLoading,
    error,
    refetch,
    isFetching,
  } = useCustomers(queryFilters);

  const createMutation = useCreateCustomer();
  const updateMutation = useUpdateCustomer();
  const { mutateAsync: deleteCustomer } = useDeleteCustomer();

  // Refrescar clientes cuando la pantalla recibe foco
  useRefreshModuleOnFocus('customers');

  const {
    isFormModalVisible,
    editingItem,
    handleOpenCreateModal,
    handleOpenEditModal: originalHandleOpenEditModal,
    handleCloseModals: originalHandleCloseModals,
  } = useCrudScreenLogic<Customer>({
    entityName: 'Cliente',
    queryKey: ['customers', queryFilters],
    deleteMutationFn: deleteCustomer,
  });

  const handleOpenEditModal = useCallback(
    (item: any) => {
      setDetailModalVisible(false);
      // Remover el fullName antes de pasar al modal de edici√≥n
      const { fullName, ...originalCustomer } = item;
      originalHandleOpenEditModal(originalCustomer as Customer);
    },
    [originalHandleOpenEditModal],
  );

  const handleCloseModals = useCallback(() => {
    originalHandleCloseModals();
    setDetailModalVisible(false);
  }, [originalHandleCloseModals]);

  const handleItemPress = useCallback((item: Customer) => {
    setSelectedCustomer(item);
    setDetailModalVisible(true);
  }, []);

  const handleDelete = useCallback((id: string) => {
    setCustomerToDelete(id);
    setShowDeleteConfirmation(true);
  }, []);

  const handleConfirmDelete = useCallback(async () => {
    if (!customerToDelete) return;

    try {
      await deleteCustomer(customerToDelete);
      showSnackbar({
        message: 'Cliente eliminado con √©xito',
        type: 'success',
      });
      setDetailModalVisible(false);
      setShowDeleteConfirmation(false);
      setCustomerToDelete(null);
    } catch (error) {
      showSnackbar({
        message: 'Error al eliminar el cliente',
        type: 'error',
      });
    }
  }, [deleteCustomer, showSnackbar, customerToDelete]);

  const filterOptions: FilterOption<
    'all' | 'active' | 'inactive' | 'banned'
  >[] = [
    { label: 'Todos', value: 'all' },
    { label: 'Activos', value: 'active' },
    { label: 'Inactivos', value: 'inactive' },
    { label: 'Baneados', value: 'banned' },
  ];

  const { ListEmptyComponent } = useListState({
    isLoading,
    isError: !!error,
    data: customers,
    emptyConfig: {
      title: 'No hay clientes',
      message:
        statusFilter !== 'all'
          ? `No hay clientes ${
              statusFilter === 'active'
                ? 'activos'
                : statusFilter === 'inactive'
                  ? 'inactivos'
                  : 'baneados'
            }.`
          : 'No hay clientes registrados. Presiona el bot√≥n + para crear el primero.',
      icon: 'account-group-outline',
    },
    errorConfig: {
      title: 'Error al cargar clientes',
      message: 'No se pudieron cargar los clientes. Verifica tu conexi√≥n.',
      icon: 'alert-circle-outline',
      onRetry: refetch,
    },
  });

  // Mapear los clientes para combinar firstName y lastName
  const mappedCustomers = useMemo(() => {
    return (
      customers?.map((customer) => ({
        ...customer,
        fullName: `${customer.firstName} ${customer.lastName}`.trim(),
        displayTitle:
          `${customer.firstName} ${customer.lastName} - ${customer.whatsappPhoneNumber}`.trim(),
        displayStatus: customer.isActive ? 'active' : 'inactive',
        whatsappInfo:
          customer.whatsappMessageCount > 0
            ? `üí¨ ${customer.whatsappMessageCount}`
            : null,
      })) || []
    );
  }, [customers]);

  const handleSubmit = useCallback(
    async (data: CustomerFormInputs) => {
      try {
        if (editingItem) {
          await updateMutation.mutateAsync({
            id: editingItem.id,
            data,
          });
          showSnackbar({
            message: 'Cliente actualizado con √©xito',
            type: 'success',
          });
        } else {
          await createMutation.mutateAsync(data);
          showSnackbar({
            message: 'Cliente creado con √©xito',
            type: 'success',
          });
        }
        handleCloseModals();
      } catch (error) {
        showSnackbar({
          message: 'Error al guardar el cliente',
          type: 'error',
        });
      }
    },
    [
      editingItem,
      createMutation,
      updateMutation,
      handleCloseModals,
      showSnackbar,
    ],
  );

  return (
    <SafeAreaView style={styles.container} edges={['bottom']}>
      <View style={styles.container}>
        <GenericList
          items={mappedCustomers}
          isLoading={isLoading}
          isRefreshing={isFetching}
          onRefresh={refetch}
          onItemPress={handleItemPress}
          renderConfig={{
            titleField: 'displayTitle' as keyof Customer,
            statusConfig: {
              field: 'displayStatus' as keyof Customer,
              activeValue: 'active',
              activeLabel: 'Activo',
              inactiveLabel: 'Inactivo',
            },
            renderDescription: (item: any) => (
              <View>
                {item.email && (
                  <Text variant="bodySmall" style={{ opacity: 0.7 }}>
                    {item.email}
                  </Text>
                )}
                <View style={{ flexDirection: 'row', gap: 8, marginTop: 2 }}>
                  <Text variant="bodySmall" style={{ opacity: 0.7 }}>
                    {item.isBanned ? '‚õî Baneado' : '‚úÖ No baneado'}
                  </Text>
                  <Text variant="bodySmall" style={{ opacity: 0.7 }}>
                    ‚Ä¢ üìç {item.addresses?.length || 0} direcciones
                  </Text>
                </View>
              </View>
            ),
          }}
          searchQuery={searchQuery}
          onSearchChange={handleSearchChange}
          searchPlaceholder="Buscar por nombre..."
          filterOptions={filterOptions}
          filterValue={statusFilter}
          onFilterChange={handleFilterChange}
          showFab={true}
          onFabPress={handleOpenCreateModal}
          ListEmptyComponent={ListEmptyComponent}
          isDrawerOpen={isDrawerOpen}
          enableSearch={true}
          showImagePlaceholder={false}
          placeholderIcon="account-group-outline"
        />
      </View>

      <Portal>
        <CustomerFormModal
          visible={isFormModalVisible}
          onDismiss={handleCloseModals}
          onSubmit={handleSubmit}
          editingItem={editingItem}
          isSubmitting={createMutation.isPending || updateMutation.isPending}
        />

        <GenericDetailModal
          visible={detailModalVisible}
          onDismiss={() => setDetailModalVisible(false)}
          item={
            selectedCustomer
              ? {
                  ...selectedCustomer,
                  fullName:
                    `${selectedCustomer.firstName} ${selectedCustomer.lastName}`.trim(),
                }
              : null
          }
          titleField="fullName"
          descriptionField="email"
          statusConfig={{
            field: 'isActive' as keyof Customer,
            activeValue: true,
            activeLabel: 'Activo',
            inactiveLabel: 'Inactivo',
          }}
          onEdit={handleOpenEditModal}
          onDelete={handleDelete}
          isDeleting={false}
          showImage={false}
          fieldsToDisplay={[
            {
              field: 'isBanned' as keyof Customer,
              label: 'Estado de baneo',
              render: (value) => (value ? '‚õî Baneado' : '‚úÖ No baneado'),
            },
            {
              field: 'whatsappPhoneNumber' as keyof Customer,
              label: 'WhatsApp',
              render: (value) => (value as string) || 'No registrado',
            },
            {
              field: 'stripeCustomerId' as keyof Customer,
              label: 'Stripe Customer ID',
              render: (value) => (value as string) || 'No registrado',
            },
            {
              field: 'email' as keyof Customer,
              label: 'Correo',
              render: (value) => (value as string) || 'No registrado',
            },
            {
              field: 'birthDate' as keyof Customer,
              label: 'Fecha de nacimiento',
              render: (value) =>
                value
                  ? new Date(value as string).toLocaleDateString()
                  : 'No registrada',
            },
            {
              field: 'addresses' as keyof Customer,
              label: 'Direcciones',
              render: (value) => {
                const addresses = value as any[];
                const count = addresses?.length || 0;
                if (count === 0) return '‚ùå Sin direcciones';
                if (count === 1) return 'üìç 1 direcci√≥n';
                return `üìç ${count} direcciones ${count > 3 ? '‚ú®' : ''}`;
              },
            },
            {
              field: 'totalOrders' as keyof Customer,
              label: 'Total de pedidos',
              render: (value) => value?.toString() || '0',
            },
            {
              field: 'totalSpent' as keyof Customer,
              label: 'Total gastado',
              render: (value) => formatCurrency((value as number) || 0),
            },
            {
              field: 'lastInteraction' as keyof Customer,
              label: '√öltima interacci√≥n',
              render: (value) =>
                value
                  ? new Date(value as string).toLocaleString()
                  : 'Sin interacciones',
            },
            {
              field: 'whatsappMessageCount' as keyof Customer,
              label: 'Mensajes de WhatsApp',
              render: (value) => `${value || 0} mensajes`,
            },
            {
              field: 'lastWhatsappMessageTime' as keyof Customer,
              label: '√öltimo mensaje WhatsApp',
              render: (value) =>
                value
                  ? new Date(value as string).toLocaleString()
                  : 'Sin mensajes',
            },
          ]}
        />

        <ConfirmationModal
          visible={showDeleteConfirmation}
          title="Confirmar Eliminaci√≥n"
          message="¬øEst√°s seguro de que quieres eliminar este cliente? Esta acci√≥n no se puede deshacer."
          confirmText="Eliminar"
          cancelText="Cancelar"
          confirmButtonColor={theme.colors.error}
          onConfirm={handleConfirmDelete}
          onCancel={() => {
            setShowDeleteConfirmation(false);
            setCustomerToDelete(null);
          }}
          onDismiss={() => {
            setShowDeleteConfirmation(false);
            setCustomerToDelete(null);
          }}
        />
      </Portal>
    </SafeAreaView>
  );
}

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    rightContent: {
      flexDirection: 'column',
      alignItems: 'flex-end',
      gap: theme.spacing.xs,
    },
    activeChip: {
      backgroundColor: theme.colors.primaryContainer,
    },
    inactiveChip: {
      backgroundColor: theme.colors.errorContainer,
    },
    statsChip: {
      backgroundColor: theme.colors.surfaceVariant,
    },
  });

export default CustomersScreen;

================
File: app/src/modules/kitchen/hooks/useKitchenOrders.ts
================
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { kitchenService } from '../services/kitchenService';
import { KitchenFilters } from '../types/kitchen.types';
import { useKitchenSnackbar } from './useKitchenSnackbar';

export const KITCHEN_ORDERS_KEY = 'kitchen-orders';

/**
 * Hook principal para obtener √≥rdenes de cocina
 * Optimizado con refetch cada 30 segundos para balance entre actualizaci√≥n y rendimiento
 */
export function useKitchenOrders(filters: Partial<KitchenFilters> = {}) {
  return useQuery({
    queryKey: [KITCHEN_ORDERS_KEY, filters],
    queryFn: () => kitchenService.getKitchenOrders(filters),
    refetchInterval: 30000, // Refetch cada 30 segundos - balance √≥ptimo
    refetchIntervalInBackground: false,
    refetchOnWindowFocus: true,
    refetchOnMount: true,
    staleTime: 25000, // Datos frescos por 25 segundos
    gcTime: 5 * 60 * 1000, // Cache por 5 minutos
    keepPreviousData: true, // Evitar parpadeos durante refetch
    notifyOnChangeProps: ['data', 'error'],
  });
}

/**
 * Hook para marcar items como preparados con actualizaci√≥n optimista granular
 * No invalida toda la query, solo actualiza el item espec√≠fico
 */
export function useUpdateKitchenItem() {
  const queryClient = useQueryClient();
  const { showError } = useKitchenSnackbar();

  const updateAllQueriesForItem = (itemId: string, isPrepared: boolean) => {
    const queryCache = queryClient.getQueryCache();
    const queries = queryCache.getAll();
    const previousData: any[] = [];

    queries.forEach((query) => {
      const queryKey = query.queryKey;
      if (Array.isArray(queryKey) && queryKey[0] === KITCHEN_ORDERS_KEY) {
        const oldData = query.state.data;
        if (oldData) {
          previousData.push([queryKey, oldData]);

          queryClient.setQueryData(queryKey, (old: any) => {
            if (!old || !Array.isArray(old)) return old;

            return old.map((order: any) => ({
              ...order,
              items: order.items?.map((item: any) =>
                item.id === itemId
                  ? {
                      ...item,
                      preparationStatus: isPrepared ? 'READY' : 'IN_PROGRESS',
                      preparedAt: isPrepared ? new Date().toISOString() : null,
                    }
                  : item,
              ),
            }));
          });
        }
      }
    });

    return previousData;
  };

  const rollbackAllQueries = (previousData: any[]) => {
    previousData.forEach(([queryKey, data]) => {
      queryClient.setQueryData(queryKey, data);
    });
  };

  return useMutation({
    mutationFn: ({
      itemId,
      isPrepared,
    }: {
      itemId: string;
      isPrepared: boolean;
    }) => kitchenService.markItemPrepared(itemId, isPrepared),

    onMutate: async ({ itemId, isPrepared }) => {
      await queryClient.cancelQueries({ queryKey: [KITCHEN_ORDERS_KEY] });
      const previousData = updateAllQueriesForItem(itemId, isPrepared);
      return { previousData };
    },

    onError: (error: any, variables, context) => {
      if (context?.previousData) {
        rollbackAllQueries(context.previousData);
      }
      showError(error.response?.data?.message || 'Error al actualizar el item');
    },

    // NO invalidar inmediatamente - dejar que el background refetch se encargue
    onSettled: () => {
      // Invalidar despu√©s de 2 segundos para permitir ver el cambio optimista
      setTimeout(() => {
        queryClient.invalidateQueries({
          queryKey: [KITCHEN_ORDERS_KEY],
          refetchType: 'none', // Solo marcar como stale, no refetch inmediato
        });
      }, 2000);
    },
  });
}

/**
 * Hook para iniciar preparaci√≥n de √≥rdenes con actualizaci√≥n optimista granular
 */
export function useUpdateKitchenOrderStatus() {
  const queryClient = useQueryClient();
  const { showError } = useKitchenSnackbar();

  const updateAllQueriesForOrder = (
    orderId: string,
    status: string,
    extraUpdates?: any,
  ) => {
    const queryCache = queryClient.getQueryCache();
    const queries = queryCache.getAll();
    const previousData: any[] = [];

    queries.forEach((query) => {
      const queryKey = query.queryKey;
      if (Array.isArray(queryKey) && queryKey[0] === KITCHEN_ORDERS_KEY) {
        const oldData = query.state.data;
        if (oldData) {
          previousData.push([queryKey, oldData]);

          queryClient.setQueryData(queryKey, (old: any) => {
            if (!old || !Array.isArray(old)) return old;

            return old.map((order: any) =>
              order.id === orderId
                ? {
                    ...order,
                    myScreenStatus: status,
                    preparationStartedAt:
                      status === 'IN_PREPARATION'
                        ? new Date().toISOString()
                        : order.preparationStartedAt,
                    preparationCompletedAt:
                      status === 'READY'
                        ? new Date().toISOString()
                        : order.preparationCompletedAt,
                    // Si se cancela, resetear items
                    items:
                      status === 'PENDING'
                        ? order.items?.map((item: any) => ({
                            ...item,
                            preparationStatus: item.belongsToMyScreen
                              ? 'IN_PROGRESS'
                              : item.preparationStatus,
                            preparedAt: item.belongsToMyScreen
                              ? null
                              : item.preparedAt,
                          }))
                        : order.items,
                    ...extraUpdates,
                  }
                : order,
            );
          });
        }
      }
    });

    return previousData;
  };

  const rollbackAllQueries = (previousData: any[]) => {
    previousData.forEach(([queryKey, data]) => {
      queryClient.setQueryData(queryKey, data);
    });
  };

  return {
    // Funci√≥n gen√©rica para actualizar status
    updateStatus: useMutation({
      mutationFn: ({
        orderId,
        status,
        serverAction,
      }: {
        orderId: string;
        status: string;
        serverAction: () => Promise<any>;
      }) => serverAction(),

      onMutate: async ({ orderId, status }) => {
        await queryClient.cancelQueries({ queryKey: [KITCHEN_ORDERS_KEY] });
        const previousData = updateAllQueriesForOrder(orderId, status);
        return { previousData };
      },

      onError: (error: any, variables, context) => {
        if (context?.previousData) {
          rollbackAllQueries(context.previousData);
        }
        showError(error.response?.data?.message || 'Error al actualizar orden');
      },

      onSettled: () => {
        setTimeout(() => {
          queryClient.invalidateQueries({
            queryKey: [KITCHEN_ORDERS_KEY],
            refetchType: 'none',
          });
        }, 2000);
      },
    }),

    // Helpers espec√≠ficos
    startPreparation: (orderId: string) => ({
      orderId,
      status: 'IN_PREPARATION',
      serverAction: () => kitchenService.startOrderPreparation(orderId),
    }),

    cancelPreparation: (orderId: string) => ({
      orderId,
      status: 'PENDING',
      serverAction: () => kitchenService.cancelOrderPreparation(orderId),
    }),

    completePreparation: (orderId: string) => ({
      orderId,
      status: 'READY',
      serverAction: () => kitchenService.completeOrderPreparation(orderId),
    }),
  };
}

/**
 * Hook de conveniencia para iniciar preparaci√≥n
 */
export function useStartOrderPreparation() {
  const { updateStatus, startPreparation } = useUpdateKitchenOrderStatus();

  return useMutation({
    mutationFn: (orderId: string) => {
      const params = startPreparation(orderId);
      return updateStatus.mutateAsync(params);
    },
  });
}

/**
 * Hook de conveniencia para cancelar preparaci√≥n
 */
export function useCancelOrderPreparation() {
  const { updateStatus, cancelPreparation } = useUpdateKitchenOrderStatus();

  return useMutation({
    mutationFn: (orderId: string) => {
      const params = cancelPreparation(orderId);
      return updateStatus.mutateAsync(params);
    },
  });
}

/**
 * Hook de conveniencia para completar preparaci√≥n
 */
export function useCompleteOrderPreparation() {
  const { updateStatus, completePreparation } = useUpdateKitchenOrderStatus();

  return useMutation({
    mutationFn: (orderId: string) => {
      const params = completePreparation(orderId);
      return updateStatus.mutateAsync(params);
    },
  });
}

/**
 * Hook de conveniencia para marcar items como preparados
 * Mantiene la API existente para compatibilidad
 */
export function useMarkItemPrepared() {
  const updateItem = useUpdateKitchenItem();

  return useMutation({
    mutationFn: ({
      itemId,
      isPrepared,
    }: {
      itemId: string;
      isPrepared: boolean;
    }) => {
      return updateItem.mutateAsync({ itemId, isPrepared });
    },
  });
}

================
File: app/src/modules/kitchen/store/kitchenStore.ts
================
import { create } from 'zustand';
import { createJSONStorage, persist } from 'zustand/middleware';
import EncryptedStorage from '@/app/services/secureStorageService';
import { KitchenFilters } from '../types/kitchen.types';

const KITCHEN_FILTERS_STORAGE_KEY = 'kitchen_filters_preferences';

interface KitchenStore {
  filters: KitchenFilters;
  setFilters: (filters: KitchenFilters) => void;
  resetFilters: () => void;
}

const defaultFilters: KitchenFilters = {
  orderType: undefined,
  showPrepared: true,
  showAllProducts: true,
  ungroupProducts: false,
};

export const useKitchenStore = create<KitchenStore>()(
  persist(
    (set) => ({
      filters: defaultFilters,
      setFilters: (filters) => set({ filters }),
      resetFilters: () => set({ filters: defaultFilters }),
    }),
    {
      name: KITCHEN_FILTERS_STORAGE_KEY,
      storage: createJSONStorage(() => EncryptedStorage),
      partialize: (state) => ({ filters: state.filters }),
      onRehydrateStorage: () => {
        return (state, error) => {
          if (error) {
            // Error al rehidratar filtros de cocina
            return;
          }
          if (!state) {
            // Estado no disponible durante la rehidrataci√≥n de filtros de cocina
            return;
          }
          // Filtros de cocina restaurados
        };
      },
    },
  ),
);

================
File: app/src/modules/menu/screens/ProductsScreen.tsx
================
import React, { useMemo, useCallback, useState } from 'react';
import { StyleSheet } from 'react-native';
import { Portal } from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useRoute, RouteProp, useNavigation } from '@react-navigation/native';
import { useDrawerStatus } from '@react-navigation/drawer';
import debounce from 'lodash.debounce';
import { useQueryClient } from '@tanstack/react-query';

import {
  useProductsQuery,
  useCreateProductMutation,
  useUpdateProductMutation,
  useDeleteProductMutation,
} from '../hooks/useProductsQueries';
import { Product, ProductFormInputs } from '../schema/products.schema';
import { MenuStackParamList } from '@/modules/menu/navigation/types';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { getApiErrorMessage } from '@/app/lib/errorMapping';
import GenericList, { FilterOption } from '@/app/components/crud/GenericList';
import ProductFormModal from '../components/ProductFormModal';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { FileObject } from '@/app/components/common/CustomImagePicker';
import { useCrudScreenLogic } from '@/app/hooks/useCrudScreenLogic';
import { useListState } from '@/app/hooks/useListState';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';

type ProductsScreenRouteProp = RouteProp<MenuStackParamList, 'Products'>;

function ProductsScreen(): React.ReactElement {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme as AppTheme), [theme]);
  const navigation = useNavigation();
  const route = useRoute<ProductsScreenRouteProp>();
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';

  const { subcategoryId, subCategoryName } = route.params;

  const [searchQuery, setSearchQuery] = useState('');
  const [statusFilter, setStatusFilter] = useState<
    'all' | 'active' | 'inactive'
  >('all');
  const [debouncedSearchQuery, setDebouncedSearchQuery] = useState('');

  const debouncedSetSearch = useCallback(
    debounce((query: string) => setDebouncedSearchQuery(query), 300),
    [],
  );

  const handleSearchChange = (query: string) => {
    setSearchQuery(query);
    debouncedSetSearch(query);
  };

  const handleFilterChange = (value: string | number) => {
    if (value === 'all' || value === 'active' || value === 'inactive') {
      setStatusFilter(value);
    } else {
      setStatusFilter('all');
    }
  };

  const queryFilters = useMemo(
    () => ({
      subcategoryId: subcategoryId,
      search: debouncedSearchQuery || undefined,
      limit: 20,
      page: 1,
      isActive: statusFilter === 'all' ? undefined : statusFilter === 'active',
    }),
    [subcategoryId, debouncedSearchQuery, statusFilter],
  );

  const {
    data: productsResponse,
    isLoading,
    error,
    refetch,
    isFetching,
  } = useProductsQuery(queryFilters, {});

  // Refrescar productos cuando la pantalla recibe foco

  useRefreshModuleOnFocus('products');

  const createMutation = useCreateProductMutation();
  const updateMutation = useUpdateProductMutation();
  const { mutateAsync: deleteProduct } = useDeleteProductMutation();

  const {
    isFormModalVisible,
    editingItem,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleCloseModals,
  } = useCrudScreenLogic<Product>({
    entityName: 'Producto',
    queryKey: ['products', queryFilters],
    deleteMutationFn: deleteProduct,
  });

  const products = useMemo(() => {
    return (productsResponse?.data ?? []).map((p: Product) => ({
      ...p,
      displayDescription: p.hasVariants
        ? `${p.variants?.length || 0} variante(s)`
        : !isNaN(parseFloat(String(p.price)))
          ? `$${parseFloat(String(p.price)).toFixed(2)}`
          : 'Precio no definido',
    }));
  }, [productsResponse]);

  const handleFormSubmit = useCallback(
    async (
      formData: ProductFormInputs,
      photoId: string | null | undefined,
      _file?: FileObject | null,
    ) => {
      const isEditing = !!editingItem;

      const { imageUri, ...dataToSend } = formData;

      const mutationData = {
        ...dataToSend,
        modifierGroupIds: dataToSend.modifierGroupIds ?? [],
        ...(photoId !== undefined && { photoId }),
      };

      try {
        let productResult: Product;

        if (isEditing && editingItem) {
          productResult = await updateMutation.mutateAsync({
            id: editingItem.id,
            data: mutationData,
          });
        } else {
          productResult = await createMutation.mutateAsync(mutationData);
        }

        // √âxito
        const message = isEditing
          ? 'Producto actualizado con √©xito'
          : 'Producto creado con √©xito';

        showSnackbar({ message, type: 'success' });
        handleCloseModals();

        queryClient.invalidateQueries({
          queryKey: ['products', queryFilters],
        });
        if (productResult?.id) {
          queryClient.invalidateQueries({
            queryKey: ['product', productResult.id],
          });
        }
      } catch (err) {
        const errorMessage = getApiErrorMessage(err);
        showSnackbar({
          message: `Error al ${isEditing ? 'actualizar' : 'crear'} producto: ${errorMessage}`,
          type: 'error',
        });
      }
    },
    [
      editingItem,
      updateMutation,
      createMutation,
      showSnackbar,
      handleCloseModals,
      queryClient,
      queryFilters,
    ],
  );

  const listRenderConfig = {
    titleField: 'name' as keyof Product,
    descriptionField: 'displayDescription' as keyof (Product & {
      displayDescription: string;
    }),
    imageField: 'photo' as keyof Product,
    sortOrderField: 'sortOrder' as keyof Product,
    statusConfig: {
      field: 'isActive' as keyof Product,
      activeValue: true,
      activeLabel: 'Activo',
      inactiveLabel: 'Inactivo',
    },
  };

  const filterOptions: FilterOption<'all' | 'active' | 'inactive'>[] = [
    { value: 'all', label: 'Todos' },
    { value: 'active', label: 'Activos' },
    { value: 'inactive', label: 'Inactivos' },
  ];

  const { ListEmptyComponent } = useListState({
    isLoading,
    isError: !!error,
    data: products,
    emptyConfig: {
      title: debouncedSearchQuery
        ? `No se encontraron productos`
        : 'No hay productos',
      message: debouncedSearchQuery
        ? `No se encontraron productos para "${debouncedSearchQuery}"`
        : `No hay productos en "${subCategoryName}". Presiona el bot√≥n + para crear el primero.`,
      icon: 'package-variant',
    },
    errorConfig: {
      title: 'Error al cargar productos',
      message: 'No se pudieron cargar los productos. Verifica tu conexi√≥n.',
      icon: 'alert-circle-outline',
      onRetry: refetch,
    },
  });

  React.useLayoutEffect(() => {
    navigation.setOptions({
      title: subCategoryName ? `Productos de ${subCategoryName}` : 'Productos',
    });
  }, [navigation, subCategoryName]);

  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      <GenericList<Product & { displayDescription: string }>
        items={products}
        renderConfig={listRenderConfig}
        onItemPress={handleOpenEditModal}
        onRefresh={refetch}
        isRefreshing={isFetching && !isLoading}
        ListEmptyComponent={ListEmptyComponent}
        isLoading={isLoading && !isFetching}
        filterValue={statusFilter}
        onFilterChange={handleFilterChange}
        filterOptions={filterOptions}
        enableSearch={true}
        searchQuery={searchQuery}
        onSearchChange={handleSearchChange}
        searchPlaceholder="Buscar productos..."
        showFab={true}
        onFabPress={handleOpenCreateModal}
        isModalOpen={isFormModalVisible}
        enableSort={false}
        contentContainerStyle={styles.contentContainer}
        showImagePlaceholder={true}
        placeholderIcon="food-outline"
        isDrawerOpen={isDrawerOpen}
      />

      <Portal>
        {isFormModalVisible && (
          <ProductFormModal
            visible={isFormModalVisible}
            onDismiss={handleCloseModals}
            onSubmit={handleFormSubmit}
            initialData={editingItem}
            isSubmitting={createMutation.isPending || updateMutation.isPending}
            productId={editingItem?.id}
            subcategoryId={subcategoryId}
          />
        )}
      </Portal>
    </SafeAreaView>
  );
}

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    centered: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.l,
    },
    errorText: {
      color: theme.colors.error,
      textAlign: 'center',
    },
    contentContainer: {
      paddingBottom: 80,
    },
  });

export default ProductsScreen;

================
File: app/src/modules/modifiers/screens/ModifierGroupsScreen.tsx
================
import React, { useMemo, useCallback, useState } from 'react';
import { StyleSheet } from 'react-native';
import { Text, IconButton } from 'react-native-paper';
import { useQuery } from '@tanstack/react-query';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useNavigation } from '@react-navigation/native';
import { useDrawerStatus } from '@react-navigation/drawer';

import { modifierGroupService } from '../services/modifierGroupService';
import { ModifierGroup } from '../schema/modifierGroup.schema';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import debounce from 'lodash.debounce';
import ModifierGroupFormModal from '../components/ModifierGroupFormModal';
import GenericList, {
  RenderItemConfig,
  FilterOption,
} from '@/app/components/crud/GenericList';
import GenericDetailModal, {
  DisplayFieldConfig,
} from '@/app/components/crud/GenericDetailModal';
import { useCrudScreenLogic } from '@/app/hooks/useCrudScreenLogic';
import { PaginatedResponse } from '@/app/types/api.types';
import { useListState } from '@/app/hooks/useListState';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';

type NavigationProps = {
  navigate: (screen: string, params?: any) => void;
};

type StatusFilter = 'all' | 'active' | 'inactive';

const QUERY_KEY = ['modifierGroups'];

const ModifierGroupsScreen = () => {
  const theme = useAppTheme();
  const navigation = useNavigation<NavigationProps>();
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';

  const [statusFilter, setStatusFilter] = useState<StatusFilter>('all');
  const [searchQuery, setSearchQuery] = useState('');
  const [debouncedSearchQuery, setDebouncedSearchQuery] = useState('');

  const debouncedSetSearch = useCallback(
    debounce((query: string) => setDebouncedSearchQuery(query), 300),
    [],
  );

  const handleSearchChange = (query: string) => {
    setSearchQuery(query);
    debouncedSetSearch(query);
  };

  const queryParams = useMemo(() => {
    const params: Parameters<typeof modifierGroupService.findAll>[0] = {};
    if (statusFilter !== 'all') {
      params.isActive = statusFilter === 'active';
    }
    if (debouncedSearchQuery) {
      params.search = debouncedSearchQuery;
    }
    return params;
  }, [statusFilter, debouncedSearchQuery]);

  const {
    data: paginatedData,
    isLoading,
    isError,
    error: _error,
    refetch,
    isRefetching,
  } = useQuery<PaginatedResponse<ModifierGroup>, Error>({
    queryKey: [QUERY_KEY[0], queryParams],
    queryFn: () => modifierGroupService.findAll(queryParams),
  });

  // Refrescar todos los modificadores cuando la pantalla recibe foco
  useRefreshModuleOnFocus('modifierGroups');

  const modifierGroups = paginatedData?.data || [];

  const {
    isFormModalVisible,
    isDetailModalVisible,
    editingItem,
    selectedItem,
    isDeleting,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
    deleteConfirmation,
  } = useCrudScreenLogic<ModifierGroup>({
    entityName: 'Grupo de Modificadores',
    queryKey: [QUERY_KEY[0], queryParams],
    deleteMutationFn: modifierGroupService.remove,
  });

  const handleNavigateToModifiers = (groupId: string, groupName: string) => {
    navigation.navigate('ModifiersScreen', { groupId, groupName });
  };

  const handleFormSaveSuccess = () => {
    handleCloseModals();
  };

  const handleFilterChange = (value: string | number) => {
    // Validar que el valor sea uno de los StatusFilter esperados
    if (value === 'all' || value === 'active' || value === 'inactive') {
      setStatusFilter(value as StatusFilter);
    } else {
      // Opcional: manejar valor inesperado, por ahora default a 'all'
      setStatusFilter('all');
    }
  };

  const handleRefresh = () => {
    refetch();
  };

  const listRenderConfig: RenderItemConfig<ModifierGroup> = {
    titleField: 'name',
    descriptionField: 'description',
    sortOrderField: 'sortOrder',
    statusConfig: {
      field: 'isActive',
      activeValue: true,
      activeLabel: 'Activo',
      inactiveLabel: 'Inactivo',
    },
    renderDescription: (item) => {
      const parts = [];

      // Agregar orden de visualizaci√≥n
      if (item.sortOrder !== undefined && item.sortOrder !== null) {
        parts.push(`Orden: ${item.sortOrder}`);
      }

      // Agregar si es requerido
      parts.push(`Requerido: ${item.isRequired ? 'S√≠' : 'No'}`);

      // Agregar si permite m√∫ltiples
      parts.push(`M√∫ltiples: ${item.allowMultipleSelections ? 'S√≠' : 'No'}`);

      // Agregar descripci√≥n si existe
      if (item.description) {
        parts.push(item.description);
      }

      return (
        <Text style={{ color: theme.colors.onSurfaceVariant, fontSize: 12 }}>
          {parts.join(' ‚Ä¢ ')}
        </Text>
      );
    },
  };

  const detailFields: DisplayFieldConfig<ModifierGroup>[] = [
    { field: 'sortOrder', label: 'Orden de Visualizaci√≥n' },
    { field: 'minSelections', label: 'M√≠n. Selecciones' },
    { field: 'maxSelections', label: 'M√°x. Selecciones' },
    {
      field: 'isRequired',
      label: 'Requerido',
      render: (value) => (
        <Text style={{ color: theme.colors.onSurface }}>
          {value ? 'S√≠' : 'No'}
        </Text>
      ),
    },
    {
      field: 'allowMultipleSelections',
      label: 'Permite M√∫ltiples',
      render: (value) => (
        <Text style={{ color: theme.colors.onSurface }}>
          {value ? 'S√≠' : 'No'}
        </Text>
      ),
    },
  ];

  const styles = useMemo(() => createStyles(theme), [theme]);

  const filterOptions: FilterOption<StatusFilter>[] = [
    { value: 'all', label: 'Todos' },
    { value: 'active', label: 'Activos' },
    { value: 'inactive', label: 'Inactivos' },
  ];

  const { ListEmptyComponent } = useListState({
    isLoading: isLoading && !isRefetching,
    isError,
    data: modifierGroups,
    emptyConfig: {
      title: searchQuery
        ? 'No se encontraron grupos'
        : 'No hay grupos de modificadores',
      message: searchQuery
        ? `No se encontraron grupos para "${searchQuery}"`
        : statusFilter !== 'all'
          ? `No hay grupos de modificadores ${statusFilter === 'active' ? 'activos' : 'inactivos'}.`
          : 'No hay grupos de modificadores registrados. Presiona el bot√≥n + para crear el primero.',
      icon: 'folder-multiple-outline',
    },
    errorConfig: {
      title: 'Error al cargar grupos',
      message:
        'No se pudieron cargar los grupos de modificadores. Verifica tu conexi√≥n.',
      icon: 'alert-circle-outline',
      onRetry: refetch,
    },
  });

  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      <GenericList<ModifierGroup>
        items={modifierGroups}
        renderConfig={listRenderConfig}
        onItemPress={handleOpenDetailModal}
        onRefresh={handleRefresh}
        isRefreshing={isRefetching}
        ListEmptyComponent={ListEmptyComponent}
        isLoading={isLoading} // Pasar directamente el estado de carga principal
        enableSearch={true}
        searchQuery={searchQuery}
        onSearchChange={handleSearchChange}
        searchPlaceholder="Buscar grupos..."
        filterValue={statusFilter}
        onFilterChange={handleFilterChange}
        filterOptions={filterOptions}
        showFab={true}
        onFabPress={handleOpenCreateModal}
        isModalOpen={isFormModalVisible || isDetailModalVisible}
        showImagePlaceholder={false}
        isDrawerOpen={isDrawerOpen}
        renderItemActions={(item) => (
          <IconButton
            icon="format-list-bulleted"
            size={24}
            onPress={(e) => {
              e.stopPropagation();
              handleNavigateToModifiers(item.id, item.name);
            }}
          />
        )}
      />

      <ModifierGroupFormModal
        visible={isFormModalVisible}
        onDismiss={handleCloseModals}
        onSaveSuccess={handleFormSaveSuccess}
        initialData={editingItem}
      />

      <GenericDetailModal<ModifierGroup>
        visible={isDetailModalVisible}
        onDismiss={handleCloseModals}
        item={selectedItem}
        titleField="name"
        descriptionField="description"
        statusConfig={listRenderConfig.statusConfig}
        fieldsToDisplay={detailFields}
        onEdit={() => {
          if (selectedItem) {
            handleOpenEditModal(selectedItem);
          }
        }}
        deleteConfirmation={deleteConfirmation}
        isDeleting={isDeleting}
        editButtonLabel="Editar"
        deleteButtonLabel="Eliminar"
        showImage={false}
      ></GenericDetailModal>
    </SafeAreaView>
  );
};

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    centered: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: 20,
    },
    emptyText: {
      textAlign: 'center',
      fontSize: 18,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 8,
    },
    errorText: {
      color: theme.colors.error,
      marginBottom: 10,
      textAlign: 'center',
    },
    detailActionButton: {
      marginTop: theme.spacing.m,
      alignSelf: 'stretch',
      borderRadius: theme.roundness,
    },
  });

export default ModifierGroupsScreen;

================
File: app/src/modules/modifiers/screens/ModifiersScreen.tsx
================
import React, { useLayoutEffect, useCallback, useMemo, useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, Portal, Button } from 'react-native-paper';
import { useQuery } from '@tanstack/react-query';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useNavigation, useRoute, RouteProp } from '@react-navigation/native';
import { useDrawerStatus } from '@react-navigation/drawer';

import { modifierService } from '../services/modifierService';
import { Modifier } from '../schema/modifier.schema';
import { useAppTheme } from '@/app/styles/theme';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import debounce from 'lodash.debounce';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';
import { useCrudScreenLogic } from '@/app/hooks/useCrudScreenLogic';

import ModifierFormModal from '@/modules/modifiers/components/ModifierFormModal';
import GenericList, {
  RenderItemConfig,
  FilterOption,
} from '@/app/components/crud/GenericList';
import GenericDetailModal, {
  DisplayFieldConfig,
} from '@/app/components/crud/GenericDetailModal';
import { useListState } from '@/app/hooks/useListState';

type StatusFilter = 'all' | 'active' | 'inactive';

type ModifiersScreenRouteParams = {
  groupId: string;
  groupName: string;
};

type ModifiersScreenRouteProp = RouteProp<
  { params: ModifiersScreenRouteParams },
  'params'
>;

type NavigationProps = {
  goBack: () => void;
  setOptions: (options: object) => void;
};

const ModifiersScreen = () => {
  const theme = useAppTheme();
  const navigation = useNavigation<NavigationProps>();
  const route = useRoute<ModifiersScreenRouteProp>();
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';

  const { groupId, groupName } = route.params ?? {};

  const [statusFilter, setStatusFilter] = useState<StatusFilter>('all');
  const [searchQuery, setSearchQuery] = useState('');
  const [debouncedSearchQuery, setDebouncedSearchQuery] = useState('');

  const QUERY_KEY = ['modifiers', groupId];

  const debouncedSetSearch = useCallback(
    debounce((query: string) => setDebouncedSearchQuery(query), 300),
    [],
  );

  const handleSearchChange = (query: string) => {
    setSearchQuery(query);
    debouncedSetSearch(query);
  };

  useLayoutEffect(() => {
    if (groupName) {
      navigation.setOptions({
        headerTitle: `Modificadores: ${groupName}`,
      });
    }
  }, [navigation, groupName]);

  const queryParams = useMemo(() => {
    const params: Parameters<typeof modifierService.findByGroupId>[1] = {};
    if (statusFilter !== 'all') {
      params.isActive = statusFilter === 'active';
    }
    if (debouncedSearchQuery) {
      params.search = debouncedSearchQuery;
    }
    return params;
  }, [statusFilter, debouncedSearchQuery]);

  const {
    data: modifiers = [],
    isLoading,
    isError,
    error: _error,
    refetch,
    isRefetching,
  } = useQuery<Modifier[], Error>({
    queryKey: [QUERY_KEY[0], groupId, queryParams],
    queryFn: () => modifierService.findByGroupId(groupId, queryParams),
    enabled: !!groupId,
  });

  // Recargar autom√°ticamente cuando la pantalla recibe foco
  useRefreshModuleOnFocus('modifiers');

  const {
    isFormModalVisible,
    isDetailModalVisible,
    editingItem,
    selectedItem,
    isDeleting,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
    deleteConfirmation,
  } = useCrudScreenLogic<Modifier>({
    entityName: 'Modificador',
    queryKey: QUERY_KEY,
    deleteMutationFn: modifierService.remove,
  });

  const handleFormModalSave = () => {
    handleCloseModals();
  };

  const handleEditFromDetails = (modifier: Modifier) => {
    handleOpenEditModal(modifier);
  };

  const handleFilterChange = (value: StatusFilter) => {
    setStatusFilter(value);
  };

  const styles = React.useMemo(() => createStyles(theme), [theme]);

  const { ListEmptyComponent } = useListState({
    isLoading,
    isError,
    data: modifiers,
    emptyConfig: {
      title: searchQuery
        ? 'No se encontraron modificadores'
        : 'No hay modificadores',
      message: searchQuery
        ? `No se encontraron modificadores para "${searchQuery}"`
        : statusFilter !== 'all'
          ? `No hay modificadores ${statusFilter === 'active' ? 'activos' : 'inactivos'} en este grupo.`
          : `No hay modificadores en "${groupName}". Presiona el bot√≥n + para crear el primero.`,
      icon: 'format-list-bulleted',
    },
    errorConfig: {
      title: 'Error al cargar modificadores',
      message: 'No se pudieron cargar los modificadores. Verifica tu conexi√≥n.',
      icon: 'alert-circle-outline',
      onRetry: refetch,
    },
  });

  if (!groupId) {
    return (
      <View style={styles.centered}>
        <Text style={styles.errorText}>
          Error: No se proporcion√≥ ID del grupo.
        </Text>
        <Button onPress={() => navigation.goBack()}>Volver</Button>
      </View>
    );
  }

  const listRenderConfig: RenderItemConfig<Modifier> = {
    titleField: 'name',
    priceField: 'price',
    sortOrderField: 'sortOrder',
    isDefaultField: 'isDefault',
    statusConfig: {
      field: 'isActive',
      activeValue: true,
      activeLabel: 'Activo',
      inactiveLabel: 'Inactivo',
    },
  };

  const detailFields: DisplayFieldConfig<Modifier>[] = [
    {
      field: 'price',
      label: 'Precio Adicional',
      render: (value) => (
        <Text style={styles.fieldValue}>
          {value !== null ? `$${Number(value).toFixed(2)}` : 'N/A'}
        </Text>
      ),
    },
    {
      field: 'sortOrder',
      label: 'Orden',
    },
    {
      field: 'isDefault',
      label: 'Por Defecto',
    },
  ];

  const filterOptions: FilterOption<StatusFilter>[] = [
    { value: 'all', label: 'Todos' },
    { value: 'active', label: 'Activos' },
    { value: 'inactive', label: 'Inactivos' },
  ];

  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      <GenericList<Modifier>
        items={modifiers}
        renderConfig={listRenderConfig}
        onItemPress={handleOpenDetailModal}
        onRefresh={refetch}
        isRefreshing={isRefetching}
        ListEmptyComponent={ListEmptyComponent}
        isLoading={isLoading && !isRefetching}
        enableSearch={true}
        searchQuery={searchQuery}
        onSearchChange={handleSearchChange}
        searchPlaceholder="Buscar modificadores..."
        filterValue={statusFilter}
        onFilterChange={handleFilterChange}
        filterOptions={filterOptions}
        showFab={true}
        onFabPress={handleOpenCreateModal}
        fabLabel="A√±adir Modificador"
        isModalOpen={isFormModalVisible || isDetailModalVisible}
        showImagePlaceholder={false}
        isDrawerOpen={isDrawerOpen}
      />

      <Portal>
        <ModifierFormModal
          visible={isFormModalVisible}
          onDismiss={handleCloseModals}
          onSaveSuccess={handleFormModalSave}
          initialData={editingItem}
          groupId={groupId}
        />

        <GenericDetailModal<Modifier>
          visible={isDetailModalVisible}
          onDismiss={handleCloseModals}
          item={selectedItem}
          titleField="name"
          descriptionField="description"
          statusConfig={listRenderConfig.statusConfig}
          fieldsToDisplay={detailFields}
          onEdit={handleEditFromDetails}
          deleteConfirmation={deleteConfirmation}
          isDeleting={isDeleting}
          showImage={false}
        />
      </Portal>
    </SafeAreaView>
  );
};

const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    centered: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: 20,
    },
    emptyText: {
      textAlign: 'center',
      fontSize: 18,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 8,
    },
    emptySubText: {
      textAlign: 'center',
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    errorText: {
      color: theme.colors.error,
      marginBottom: 10,
      textAlign: 'center',
    },
    fieldValue: {
      flexShrink: 1,
      textAlign: 'right',
      color: theme.colors.onSurface,
    },
  });

export default ModifiersScreen;

================
File: app/src/modules/orders/components/CartButton.tsx
================
import React, { useRef, useCallback, useMemo } from 'react';
import { StyleSheet, View, Animated } from 'react-native';
import { IconButton, Badge, useTheme, MD3Theme } from 'react-native-paper';

interface CartButtonProps {
  itemCount: number;
  onPress: () => void;
}

const createStyles = (theme: MD3Theme) =>
  StyleSheet.create({
    cartButton: {
      margin: 0,
      backgroundColor: theme.colors.surfaceVariant,
      zIndex: 999,
    },
    cartBadge: {
      position: 'absolute',
      top: 0,
      right: 0,
      backgroundColor: theme.colors.error,
      zIndex: 1000,
    },
    touchableArea: {
      padding: 5,
    },
    // Estilos adicionales para eliminar inline styles
    animatedContainer: {
      // El transform se aplica din√°micamente
    },
    badgeContainer: {
      position: 'absolute',
      top: 0,
      right: 0,
      pointerEvents: 'none',
    },
  });

const CartButton = React.forwardRef(
  ({ itemCount, onPress }: CartButtonProps, ref) => {
    const theme = useTheme();
    const cartBadgeScale = useRef(new Animated.Value(1)).current;
    const cartBounceAnimation = useRef(new Animated.Value(1)).current;
    const isPressedRef = useRef(false);

    const styles = useMemo(() => createStyles(theme), [theme]);

    const animateCartButton = () => {
      Animated.sequence([
        Animated.timing(cartBounceAnimation, {
          toValue: 1.3,
          duration: 200,
          useNativeDriver: true,
        }),
        Animated.timing(cartBounceAnimation, {
          toValue: 1,
          duration: 200,
          useNativeDriver: true,
        }),
      ]).start();

      Animated.sequence([
        Animated.timing(cartBadgeScale, {
          toValue: 1.6,
          duration: 200,
          useNativeDriver: true,
        }),
        Animated.timing(cartBadgeScale, {
          toValue: 1,
          duration: 200,
          useNativeDriver: true,
        }),
      ]).start();
    };

    React.useImperativeHandle(ref, () => ({
      animate: animateCartButton,
    }));

    const handlePress = useCallback(() => {
      if (isPressedRef.current) return;

      isPressedRef.current = true;
      onPress();

      setTimeout(() => {
        isPressedRef.current = false;
      }, 150);
    }, [onPress]);

    return (
      <View style={styles.touchableArea}>
        <Animated.View
          style={[
            styles.animatedContainer,
            { transform: [{ scale: cartBounceAnimation }] },
          ]}
        >
          <IconButton
            icon="cart-outline"
            iconColor={theme.colors.primary}
            size={30}
            onPress={handlePress}
            style={styles.cartButton}
            rippleColor={theme.colors.primary + '20'}
          />
        </Animated.View>
        {itemCount > 0 && (
          <Animated.View
            style={[
              styles.badgeContainer,
              { transform: [{ scale: cartBadgeScale }] },
            ]}
          >
            <Badge style={styles.cartBadge} size={22}>
              {itemCount}
            </Badge>
          </Animated.View>
        )}
      </View>
    );
  },
);

export default CartButton;

================
File: app/src/modules/orders/components/ShiftStatusModal.tsx
================
import React from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  Surface,
  Divider,
  Card,
  Chip,
} from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useAppTheme } from '@/app/styles/theme';
import { type Shift } from '@/services/shifts';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';

interface ShiftStatusModalProps {
  visible: boolean;
  onDismiss: () => void;
  shift: Shift | null;
  onOpenShift: () => void;
  onCloseShift?: () => void;
  canOpenShift: boolean;
  loading: boolean;
}

export const ShiftStatusModal: React.FC<ShiftStatusModalProps> = ({
  visible,
  onDismiss,
  shift,
  onOpenShift,
  onCloseShift,
  canOpenShift,
  loading: _loading,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);

  const isShiftOpen = shift && shift.status === 'OPEN';
  const today = new Date();
  const todayFormatted = format(today, "EEEE, d 'de' MMMM 'de' yyyy", {
    locale: es,
  });

  const handleOpenShift = () => {
    onDismiss();
    onOpenShift();
  };

  const formatCurrency = (amount: number) => {
    return new Intl.NumberFormat('es-MX', {
      style: 'currency',
      currency: 'MXN',
    }).format(amount);
  };

  const formatTime = (dateString: string) => {
    return format(new Date(dateString), 'HH:mm', { locale: es });
  };

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalContainer}
      >
        <ScrollView showsVerticalScrollIndicator={false}>
          <Surface style={styles.modal} elevation={3}>
            {/* Header */}
            <View style={styles.header}>
              <View style={styles.iconContainer}>
                <MaterialCommunityIcons
                  name={isShiftOpen ? 'store-check' : 'store-alert'}
                  size={48}
                  color={isShiftOpen ? '#4CAF50' : '#FF9800'}
                />
              </View>
              <Text variant="headlineMedium" style={styles.title}>
                {isShiftOpen ? 'Turno Abierto' : 'Turno Cerrado'}
              </Text>
              <Text variant="bodyLarge" style={styles.date}>
                {todayFormatted}
              </Text>
              <Chip
                mode="outlined"
                style={[
                  styles.statusChip,
                  { borderColor: isShiftOpen ? '#4CAF50' : '#FF9800' },
                ]}
                textStyle={{ color: isShiftOpen ? '#4CAF50' : '#FF9800' }}
              >
                {isShiftOpen ? 'ABIERTO' : 'CERRADO'}
              </Chip>
            </View>

            <Divider style={styles.divider} />

            {/* Content */}
            <View style={styles.content}>
              {isShiftOpen && shift ? (
                <>
                  {/* Informaci√≥n del turno abierto */}
                  <Card style={styles.infoCard}>
                    <Card.Content>
                      <Text variant="titleMedium" style={styles.sectionTitle}>
                        Informaci√≥n del Turno
                      </Text>

                      <View style={styles.infoRow}>
                        <Text variant="bodyMedium" style={styles.label}>
                          Turno #:
                        </Text>
                        <Text variant="bodyMedium" style={styles.value}>
                          {shift.globalShiftNumber}
                        </Text>
                      </View>

                      <View style={styles.infoRow}>
                        <Text variant="bodyMedium" style={styles.label}>
                          Abierto a las:
                        </Text>
                        <Text variant="bodyMedium" style={styles.value}>
                          {formatTime(shift.openedAt)}
                        </Text>
                      </View>

                      <View style={styles.infoRow}>
                        <Text variant="bodyMedium" style={styles.label}>
                          Abierto por:
                        </Text>
                        <Text variant="bodyMedium" style={styles.value}>
                          {shift.openedBy.firstName} {shift.openedBy.lastName}
                        </Text>
                      </View>

                      <View style={styles.infoRow}>
                        <Text variant="bodyMedium" style={styles.label}>
                          Efectivo inicial:
                        </Text>
                        <Text variant="bodyMedium" style={styles.value}>
                          {formatCurrency(shift.initialCash)}
                        </Text>
                      </View>

                      {shift.totalSales !== null && (
                        <View style={styles.infoRow}>
                          <Text variant="bodyMedium" style={styles.label}>
                            Ventas del turno:
                          </Text>
                          <Text
                            variant="bodyMedium"
                            style={[styles.value, styles.highlight]}
                          >
                            {formatCurrency(shift.totalSales)}
                          </Text>
                        </View>
                      )}

                      {shift.totalOrders !== null && (
                        <View style={styles.infoRow}>
                          <Text variant="bodyMedium" style={styles.label}>
                            √ìrdenes:
                          </Text>
                          <Text variant="bodyMedium" style={styles.value}>
                            {shift.totalOrders}
                          </Text>
                        </View>
                      )}

                      {shift.expectedCash !== null && (
                        <View style={styles.infoRow}>
                          <Text variant="bodyMedium" style={styles.label}>
                            Efectivo esperado:
                          </Text>
                          <Text
                            variant="bodyMedium"
                            style={[styles.value, styles.highlight]}
                          >
                            {formatCurrency(shift.expectedCash)}
                          </Text>
                        </View>
                      )}

                      {shift.notes && (
                        <View style={styles.notesSection}>
                          <Text variant="bodyMedium" style={styles.label}>
                            Notas:
                          </Text>
                          <Text variant="bodySmall" style={styles.notes}>
                            {shift.notes}
                          </Text>
                        </View>
                      )}
                    </Card.Content>
                  </Card>
                </>
              ) : (
                <>
                  {/* Turno cerrado */}
                  <View style={styles.closedInfo}>
                    <MaterialCommunityIcons
                      name="information"
                      size={20}
                      color={theme.colors.primary}
                    />
                    <Text variant="bodyMedium" style={styles.closedText}>
                      {canOpenShift
                        ? 'El turno est√° cerrado. Para comenzar las operaciones, abre el turno.'
                        : 'El turno est√° cerrado. Contacta a un administrador para abrirlo.'}
                    </Text>
                  </View>
                </>
              )}
            </View>

            {/* Footer */}
            <View style={styles.footer}>
              <Button
                mode="text"
                onPress={onDismiss}
                style={styles.cancelButton}
                labelStyle={styles.cancelButtonText}
              >
                Cerrar
              </Button>

              {!isShiftOpen && canOpenShift && (
                <Button
                  mode="contained"
                  onPress={handleOpenShift}
                  style={styles.actionButton}
                  contentStyle={styles.actionButtonContent}
                  labelStyle={styles.actionButtonText}
                  icon="play-circle"
                >
                  Abrir Turno
                </Button>
              )}

              {isShiftOpen && canOpenShift && onCloseShift && (
                <Button
                  mode="contained"
                  onPress={() => {
                    onDismiss();
                    onCloseShift();
                  }}
                  style={styles.closeShiftButton}
                  contentStyle={styles.actionButtonContent}
                  labelStyle={styles.closeShiftButtonText}
                  icon="stop-circle"
                >
                  Cerrar Turno
                </Button>
              )}
            </View>
          </Surface>
        </ScrollView>
      </Modal>
    </Portal>
  );
};

const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    modalContainer: {
      flex: 1,
      justifyContent: 'center',
      paddingVertical: theme.spacing.xl,
      paddingHorizontal: theme.spacing.m,
    },
    modal: {
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness * 3,
      borderWidth: 2,
      borderColor: theme.colors.outline,
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 8,
      },
      shadowOpacity: 0.25,
      shadowRadius: 16,
      elevation: 8,
    },
    header: {
      alignItems: 'center',
      paddingTop: theme.spacing.xl,
      paddingHorizontal: theme.spacing.l,
      paddingBottom: theme.spacing.l,
      borderTopLeftRadius: theme.roundness * 3,
      borderTopRightRadius: theme.roundness * 3,
      backgroundColor: theme.colors.surfaceVariant,
    },
    iconContainer: {
      width: 90,
      height: 90,
      borderRadius: 45,
      backgroundColor: theme.colors.surface,
      justifyContent: 'center',
      alignItems: 'center',
      marginBottom: theme.spacing.m,
      borderWidth: 3,
      borderColor: theme.colors.primary,
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 4,
      },
      shadowOpacity: 0.15,
      shadowRadius: 8,
      elevation: 4,
    },
    title: {
      color: theme.colors.onSurfaceVariant,
      fontWeight: '700',
      textAlign: 'center',
      marginBottom: theme.spacing.xs,
    },
    date: {
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
      textTransform: 'capitalize',
      marginBottom: theme.spacing.m,
    },
    statusChip: {
      backgroundColor: theme.colors.surface,
      borderWidth: 2,
    },
    divider: {
      backgroundColor: theme.colors.outlineVariant,
      height: 1,
    },
    content: {
      padding: theme.spacing.l,
    },
    infoCard: {
      backgroundColor: theme.colors.surfaceVariant,
      borderWidth: 1,
      borderColor: theme.colors.outline,
      borderRadius: theme.roundness * 2,
    },
    sectionTitle: {
      color: theme.colors.onSurface,
      fontWeight: '600',
      marginBottom: theme.spacing.m,
    },
    infoRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.s,
    },
    label: {
      color: theme.colors.onSurfaceVariant,
      flex: 1,
    },
    value: {
      color: theme.colors.onSurface,
      fontWeight: '500',
      textAlign: 'right',
    },
    highlight: {
      color: theme.colors.primary,
      fontWeight: '600',
    },
    notesSection: {
      marginTop: theme.spacing.m,
      paddingTop: theme.spacing.m,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outline,
    },
    notes: {
      color: theme.colors.onSurfaceVariant,
      marginTop: theme.spacing.xs,
      fontStyle: 'italic',
    },
    closedInfo: {
      flexDirection: 'row',
      backgroundColor: theme.colors.primaryContainer,
      padding: theme.spacing.m,
      borderRadius: theme.roundness * 2,
      borderWidth: 1,
      borderColor: theme.colors.primary,
      gap: theme.spacing.s,
    },
    closedText: {
      flex: 1,
      color: theme.colors.onPrimaryContainer,
      lineHeight: 20,
    },
    footer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      padding: theme.spacing.l,
      paddingTop: theme.spacing.s,
      gap: theme.spacing.m,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
      borderBottomLeftRadius: theme.roundness * 3,
      borderBottomRightRadius: theme.roundness * 3,
    },
    cancelButton: {
      flex: 1,
      borderWidth: 2,
      borderColor: theme.colors.outline,
      borderRadius: theme.roundness * 2,
    },
    cancelButtonText: {
      color: theme.colors.onSurface,
      fontWeight: '600',
    },
    actionButton: {
      flex: 1,
      backgroundColor: theme.colors.primary,
      borderWidth: 2,
      borderColor: theme.colors.primary,
      borderRadius: theme.roundness * 2,
    },
    actionButtonContent: {
      paddingVertical: theme.spacing.xs,
    },
    actionButtonText: {
      color: theme.colors.onPrimary,
      fontWeight: '600',
    },
    closeShiftButton: {
      flex: 1,
      backgroundColor: '#FF5722',
      borderWidth: 2,
      borderColor: '#FF5722',
      borderRadius: theme.roundness * 2,
    },
    closeShiftButtonText: {
      color: '#FFFFFF',
      fontWeight: '600',
    },
  });

================
File: app/src/modules/orders/types/orders.types.ts
================
// Importar tipos de dominio centralizados desde /app/schemas/domain/
import type { Photo } from '@/app/schemas/domain/photo.schema';
import type { Modifier } from '@/app/schemas/domain/modifier.schema';
import type { ModifierGroup } from '@/app/schemas/domain/modifier-group.schema';
import type { ProductVariant } from '@/app/schemas/domain/product-variant.schema'; // Asumiendo que se crear√°
import type { Product } from '@/app/schemas/domain/product.schema'; // Asumiendo que se crear√°
import type { SubCategory } from '@/app/schemas/domain/subcategory.schema'; // Asumiendo que se crear√°
import type { Category } from '@/app/schemas/domain/category.schema';
import {
  orderStatusSchema, // Importar el schema Zod
  orderTypeSchema, // Importar el schema Zod
} from '@/app/schemas/domain/order.schema';
import type {
  OrderItemModifier,
  OrderItem,
  OrderStatus,
  OrderType,
  Order,
} from '@/app/schemas/domain/order.schema'; // Mantener importaci√≥n de tipos

// Re-exportar tipos de dominio para que otros archivos dentro de este m√≥dulo puedan importarlos desde aqu√≠
export type {
  Photo,
  Modifier,
  ModifierGroup,
  ProductVariant,
  Product,
  SubCategory,
  Category,
  OrderItemModifier,
  OrderItem,
  OrderStatus,
  OrderType,
  Order,
};

// Exportar los valores de los enums para uso en runtime
export const OrderStatusEnum = orderStatusSchema.enum;
export const OrderTypeEnum = orderTypeSchema.enum;

// --- Tipos espec√≠ficos del m√≥dulo de √ìrdenes que no son entidades de dominio ---

// Tipos extendidos para el men√∫ completo con relaciones anidadas
export interface FullMenuModifierGroup extends ModifierGroup {
  productModifiers?: Modifier[];
}

export interface FullMenuProduct extends Product {
  variants?: ProductVariant[];
  modifierGroups?: FullMenuModifierGroup[];
}

export interface FullMenuSubCategory extends SubCategory {
  products?: FullMenuProduct[];
}

export interface FullMenuCategory extends Category {
  subcategories?: FullMenuSubCategory[];
}

// DTO para filtrar √≥rdenes (basado en el backend DTO)
// Este tipo es espec√≠fico para la API de este m√≥dulo, por lo que permanece aqu√≠.
export interface FindAllOrdersDto {
  userId?: string;
  tableId?: string;
  orderStatus?: OrderStatus | OrderStatus[]; // Permitir un array de estados
  orderType?: OrderType;
  startDate?: string; // Usar string para fechas en DTOs
  endDate?: string; // Usar string para fechas en DTOs
  page?: number; // A√±adir paginaci√≥n
  limit?: number; // A√±adir paginaci√≥n
  // A√±adir otros campos de filtro si existen en el backend DTO
}

// Otros tipos espec√≠ficos de este m√≥dulo podr√≠an ir aqu√≠, por ejemplo:
// - Tipos para el estado del carrito si no se maneja con Zustand/Context
// - Tipos para formularios espec√≠ficos de este m√≥dulo

// Tipo optimizado para lista de √≥rdenes abiertas
export interface OrderOpenList
  extends Omit<
    Order,
    'orderItems' | 'payments' | 'adjustments' | 'user' | 'customer'
  > {
  // Informaci√≥n b√°sica de la mesa
  table?: {
    id: string;
    number: number;
    name: string;
    isTemporary: boolean;
    area?: {
      name: string;
    };
  } | null;

  // Informaci√≥n b√°sica de entrega
  deliveryInfo?: {
    recipientName: string;
    recipientPhone: string | null;
    fullAddress: string;
  } | null;

  // Campos adicionales calculados
  paymentsSummary?: {
    totalPaid: number;
  };
  preparationScreens?: string[];
  preparationScreenStatuses?: Array<{
    name: string;
    status: 'PENDING' | 'IN_PROGRESS' | 'READY';
  }>;
  ticketImpressionCount?: number;

  // Informaci√≥n del usuario creador
  createdBy?: {
    username: string;
    firstName?: string | null;
    lastName?: string | null;
  };
}

================
File: app/src/modules/pizzaCustomizations/components/PizzaConfigurationModal.tsx
================
import React, { useState, useEffect } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Portal,
  Modal,
  Text,
  TextInput,
  Button,
  IconButton,
  HelperText,
  Divider,
} from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { Controller, useForm } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { z } from 'zod';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { pizzaConfigurationsService } from '../services/pizzaConfigurationsService';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import type { Product } from '@/modules/menu/schema/products.schema';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';

interface PizzaConfigurationModalProps {
  visible: boolean;
  onDismiss: () => void;
  product: Product | null;
}

const configurationSchema = z.object({
  includedToppings: z.number().int().min(0),
  extraToppingCost: z.number().min(0),
});

type ConfigurationFormData = z.infer<typeof configurationSchema>;

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    modal: {
      backgroundColor: theme.colors.background,
      margin: responsive.spacing(theme.spacing.l),
      borderRadius: theme.roundness * 2,
      maxHeight: responsive.isTablet ? '85%' : '80%',
      maxWidth: responsive.isTablet ? 650 : 500,
      width: responsive.isTablet ? '85%' : '100%',
      alignSelf: 'center',
    },
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      padding: responsive.spacing(theme.spacing.m),
      paddingBottom: 0,
    },
    title: {
      fontSize: responsive.fontSize(20),
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    closeButton: {
      margin: 0,
    },
    content: {
      padding: responsive.spacing(theme.spacing.m),
    },
    productInfo: {
      backgroundColor: theme.colors.surfaceVariant,
      padding: responsive.spacing(theme.spacing.m),
      borderRadius: theme.roundness,
      marginBottom: responsive.spacing(theme.spacing.l),
    },
    productName: {
      fontWeight: '600',
      marginBottom: responsive.spacing(theme.spacing.xs),
      fontSize: responsive.fontSize(16),
    },
    section: {
      marginBottom: responsive.spacing(theme.spacing.l),
    },
    sectionTitle: {
      marginBottom: responsive.spacing(theme.spacing.m),
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: responsive.fontSize(16),
    },
    input: {
      marginBottom: responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surface,
    },
    helperText: {
      marginTop: -responsive.spacing(theme.spacing.s),
      marginBottom: responsive.spacing(theme.spacing.m),
      fontSize: responsive.fontSize(12),
    },
    infoBox: {
      backgroundColor: theme.colors.primaryContainer,
      padding: responsive.spacing(theme.spacing.m),
      borderRadius: theme.roundness,
      marginBottom: responsive.spacing(theme.spacing.m),
    },
    infoText: {
      color: theme.colors.onPrimaryContainer,
      fontSize: responsive.fontSize(12),
    },
    example: {
      marginTop: responsive.spacing(theme.spacing.m),
      padding: responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: theme.roundness,
    },
    exampleTitle: {
      fontWeight: '600',
      marginBottom: responsive.spacing(theme.spacing.xs),
      fontSize: responsive.fontSize(14),
    },
    exampleText: {
      fontSize: responsive.fontSize(12),
      color: theme.colors.onSurfaceVariant,
    },
    actions: {
      flexDirection: 'row',
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.s),
      gap: responsive.spacing(theme.spacing.m),
    },
    actionButton: {
      flex: 1,
      borderWidth: 1,
      borderColor: theme.colors.outline,
      maxWidth: responsive.isTablet ? 180 : 160,
    },
    cancelButton: {
      borderColor: theme.colors.outlineVariant,
    },
    saveButton: {
      borderWidth: 0,
    },
    buttonLabel: {
      fontSize: responsive.fontSize(14),
      fontWeight: '600',
    },
  });

export function PizzaConfigurationModal({
  visible,
  onDismiss,
  product,
}: PizzaConfigurationModalProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const [showConfirmation, setShowConfirmation] = useState(false);
  const [extraCostText, setExtraCostText] = useState('20.00');

  // Query para obtener la configuraci√≥n existente
  const { data: configuration, isLoading: _isLoading } = useQuery({
    queryKey: ['pizza-configuration', product?.id],
    queryFn: async () => {
      if (!product?.id) return null;
      try {
        return await pizzaConfigurationsService.findByProductId(product.id);
      } catch (error) {
        return null;
      }
    },
    enabled: !!product?.id && visible,
  });

  // Form
  const {
    control,
    handleSubmit,
    formState: { errors, isDirty },
    reset,
    setValue,
    getValues: _getValues,
  } = useForm<ConfigurationFormData>({
    resolver: zodResolver(configurationSchema),
    defaultValues: {
      includedToppings: 4,
      extraToppingCost: 20,
    },
  });

  // Cargar datos de configuraci√≥n existente
  useEffect(() => {
    if (visible && product) {
      if (
        configuration &&
        configuration.extraToppingCost !== undefined &&
        configuration.extraToppingCost !== null
      ) {
        const cost = Number(configuration.extraToppingCost);
        const toppings = Number(configuration.includedToppings) || 4;
        reset({
          includedToppings: toppings,
          extraToppingCost: cost,
        });
        setExtraCostText(cost.toFixed(2));
        // Asegurar que el valor est√© sincronizado
        setValue('extraToppingCost', cost, { shouldValidate: false });
      } else {
        // Reset a valores por defecto cuando se abre el modal sin configuraci√≥n
        const defaultCost = 20;
        const defaultToppings = 4;
        reset({
          includedToppings: defaultToppings,
          extraToppingCost: defaultCost,
        });
        setExtraCostText(defaultCost.toFixed(2));
        // Asegurar que el valor est√© sincronizado
        setValue('extraToppingCost', defaultCost, { shouldValidate: false });
      }
    }
  }, [configuration, reset, visible, product, setValue]);

  // Mutation para guardar
  const saveMutation = useMutation({
    mutationFn: async (data: ConfigurationFormData) => {
      if (!product) throw new Error('No product selected');

      if (configuration) {
        return await pizzaConfigurationsService.update(configuration.id, data);
      } else {
        return await pizzaConfigurationsService.create({
          ...data,
          productId: product.id,
        });
      }
    },
    onSuccess: () => {
      showSnackbar({
        message: 'Configuraci√≥n guardada exitosamente',
        type: 'success',
      });
      queryClient.invalidateQueries({
        queryKey: ['pizza-configuration', product?.id],
      });
      queryClient.invalidateQueries({ queryKey: ['pizza-configurations'] });
      onDismiss();
    },
    onError: (error) => {
      showSnackbar({
        message: error instanceof Error ? error.message : 'Error al guardar',
        type: 'error',
      });
    },
  });

  const onSubmit = (data: ConfigurationFormData) => {
    saveMutation.mutate(data);
  };

  if (!product) return null;

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={() => {
          if (isDirty) {
            setShowConfirmation(true);
          } else {
            onDismiss();
          }
        }}
        contentContainerStyle={styles.modal}
        dismissable={true}
      >
        <View style={styles.header}>
          <Text style={styles.title}>Configuraci√≥n de Pizza</Text>
          <IconButton
            icon="close"
            size={24}
            onPress={() => {
              if (isDirty) {
                setShowConfirmation(true);
              } else {
                onDismiss();
              }
            }}
            style={styles.closeButton}
          />
        </View>

        <Divider />

        <ScrollView style={styles.content}>
          <View style={styles.productInfo}>
            <Text variant="titleMedium" style={styles.productName}>
              {product.name}
            </Text>
            <Text variant="bodySmall">
              {product.variants?.length || 0} variantes disponibles
            </Text>
          </View>

          <View style={styles.section}>
            <View style={styles.infoBox}>
              <Text style={styles.infoText}>
                ‚ÑπÔ∏è Esta configuraci√≥n determina cu√°ntos toppings est√°n incluidos
                en el precio base y cu√°nto se cobra por cada topping adicional.
              </Text>
            </View>

            <Controller
              control={control}
              name="includedToppings"
              render={({ field: { onChange, onBlur, value } }) => (
                <TextInput
                  label="Toppings incluidos en el precio base *"
                  value={value?.toString() || ''}
                  onChangeText={(text) => {
                    // Solo permitir n√∫meros enteros
                    const cleanText = text.replace(/[^0-9]/g, '');
                    if (cleanText === '') {
                      onChange(0);
                    } else {
                      const num = parseInt(cleanText, 10);
                      onChange(isNaN(num) ? 0 : num);
                    }
                  }}
                  onBlur={onBlur}
                  mode="outlined"
                  style={styles.input}
                  keyboardType="number-pad"
                  error={!!errors.includedToppings}
                />
              )}
            />
            {errors.includedToppings && (
              <HelperText type="error" visible style={styles.helperText}>
                Debe ser un n√∫mero entero mayor o igual a 0
              </HelperText>
            )}
            <HelperText type="info" visible style={styles.helperText}>
              Cantidad de toppings que el cliente puede elegir sin costo
              adicional
            </HelperText>

            <Controller
              control={control}
              name="extraToppingCost"
              render={({ field: { onChange, onBlur } }) => (
                <TextInput
                  label="Costo por topping adicional *"
                  value={extraCostText}
                  onChangeText={(text) => {
                    // Permitir n√∫meros y punto decimal
                    let cleanText = text.replace(/[^0-9.]/g, '');

                    // Evitar m√∫ltiples puntos decimales
                    const parts = cleanText.split('.');
                    if (parts.length > 2) {
                      cleanText = parts[0] + '.' + parts.slice(1).join('');
                    }

                    // Limitar a 2 decimales
                    if (parts.length === 2 && parts[1].length > 2) {
                      cleanText = parts[0] + '.' + parts[1].substring(0, 2);
                    }

                    // Actualizar el texto mostrado
                    setExtraCostText(cleanText);

                    // Convertir a n√∫mero y actualizar el formulario
                    const numValue = parseFloat(cleanText);
                    if (!isNaN(numValue)) {
                      onChange(numValue);
                      setValue('extraToppingCost', numValue, {
                        shouldValidate: true,
                      });
                    } else if (cleanText === '' || cleanText === '.') {
                      onChange(0);
                      setValue('extraToppingCost', 0, { shouldValidate: true });
                    }
                  }}
                  onBlur={() => {
                    onBlur();
                    // Formatear al perder el foco
                    const numValue = parseFloat(extraCostText);
                    if (!isNaN(numValue)) {
                      setExtraCostText(numValue.toFixed(2));
                      setValue('extraToppingCost', numValue, {
                        shouldValidate: true,
                      });
                    } else {
                      setExtraCostText('0.00');
                      setValue('extraToppingCost', 0, { shouldValidate: true });
                    }
                  }}
                  mode="outlined"
                  style={styles.input}
                  keyboardType="decimal-pad"
                  error={!!errors.extraToppingCost}
                  left={<TextInput.Affix text="$" />}
                />
              )}
            />
            {errors.extraToppingCost && (
              <HelperText type="error" visible style={styles.helperText}>
                {errors.extraToppingCost.message ||
                  'Debe ser un n√∫mero mayor o igual a 0'}
              </HelperText>
            )}
            <HelperText type="info" visible style={styles.helperText}>
              Precio que se cobra por cada topping despu√©s de los incluidos
            </HelperText>

            <View style={styles.example}>
              <Text variant="labelLarge" style={styles.exampleTitle}>
                Ejemplo de c√°lculo:
              </Text>
              <Text style={styles.exampleText}>
                Si configuras 4 toppings incluidos y $20 por extra:{'\n'}‚Ä¢
                Cliente elige 4 toppings: Sin costo adicional{'\n'}‚Ä¢ Cliente
                elige 6 toppings: +$40 (2 extras √ó $20)
              </Text>
            </View>
          </View>
        </ScrollView>

        <Divider />

        <View style={styles.actions}>
          <Button
            mode="outlined"
            onPress={() => {
              if (isDirty) {
                setShowConfirmation(true);
              } else {
                onDismiss();
              }
            }}
            style={[styles.actionButton, styles.cancelButton]}
            contentStyle={{ paddingVertical: responsive.isTablet ? 4 : 6 }}
            labelStyle={styles.buttonLabel}
          >
            Cancelar
          </Button>
          <Button
            mode="contained"
            onPress={handleSubmit(onSubmit)}
            loading={saveMutation.isPending}
            style={[styles.actionButton, styles.saveButton]}
            contentStyle={{ paddingVertical: responsive.isTablet ? 4 : 6 }}
            labelStyle={styles.buttonLabel}
          >
            Guardar
          </Button>
        </View>
      </Modal>

      <ConfirmationModal
        visible={showConfirmation}
        title="¬øSalir sin guardar?"
        message="Los cambios se perder√°n"
        confirmText="Salir"
        cancelText="Cancelar"
        confirmButtonColor={theme.colors.error}
        onConfirm={() => {
          setShowConfirmation(false);
          reset();
          setExtraCostText('20.00');
          onDismiss();
        }}
        onCancel={() => setShowConfirmation(false)}
        onDismiss={() => setShowConfirmation(false)}
      />
    </Portal>
  );
}

================
File: app/src/modules/pizzaCustomizations/components/PizzaCustomizationFormModal.tsx
================
import React, { useEffect } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
  Pressable,
} from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  TextInput,
  Switch,
  SegmentedButtons,
  HelperText,
  ActivityIndicator,
  IconButton,
  Surface,
} from 'react-native-paper';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import {
  pizzaCustomizationFormSchema,
  PizzaCustomizationFormInputs,
} from '../schema/pizzaCustomization.schema';
import {
  usePizzaCustomization,
  useCreatePizzaCustomization,
  useUpdatePizzaCustomization,
} from '../hooks/usePizzaCustomizationsQueries';
import { CustomizationType } from '../types/pizzaCustomization.types';

interface PizzaCustomizationFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  customizationId?: string;
  onSuccess?: () => void;
}

const createStyles = (theme: any, responsive: any) => {
  const isTablet = responsive.isTablet;

  return StyleSheet.create({
    container: {
      flex: 1,
      justifyContent: 'center',
      paddingHorizontal: responsive.spacing(theme.spacing.m),
    },
    backdrop: {
      ...StyleSheet.absoluteFillObject,
      backgroundColor: 'rgba(0, 0, 0, 0.5)',
    },
    modalContent: {
      backgroundColor: theme.colors.surface,
      borderRadius: 28,
      maxHeight: isTablet ? '90%' : '85%',
      minHeight: isTablet ? 600 : undefined,
      maxWidth: isTablet ? 650 : 500,
      width: '100%',
      alignSelf: 'center',
      overflow: 'hidden',
      elevation: 24,
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 12,
      },
      shadowOpacity: 0.58,
      shadowRadius: 16.0,
    },
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingTop: responsive.spacing(theme.spacing.m),
      paddingBottom: responsive.spacing(theme.spacing.m),
      paddingHorizontal: responsive.spacing(theme.spacing.l),
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    headerTitle: {
      fontSize: responsive.fontSize(18),
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    closeButton: {
      margin: -responsive.spacing(theme.spacing.xs),
    },
    scrollContent: {
      padding: responsive.spacing(theme.spacing.l),
      paddingTop: responsive.spacing(theme.spacing.m),
    },
    formGroup: {
      marginBottom: responsive.spacing(theme.spacing.l),
    },
    label: {
      fontSize: responsive.fontSize(12),
      fontWeight: '600',
      color: theme.colors.onSurfaceVariant,
      marginBottom: responsive.spacing(theme.spacing.xs),
      marginLeft: responsive.spacing(theme.spacing.xs),
      textTransform: 'uppercase',
      letterSpacing: 0.5,
    },
    segmentedButtons: {
      marginBottom: responsive.spacing(theme.spacing.xs),
      borderRadius: 16,
    },
    row: {
      flexDirection: 'row',
      gap: responsive.spacing(theme.spacing.m),
      marginBottom: responsive.spacing(theme.spacing.l),
    },
    halfWidth: {
      flex: 1,
    },
    switchRow: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingVertical: responsive.spacing(theme.spacing.m),
      paddingHorizontal: responsive.spacing(theme.spacing.l),
      backgroundColor: theme.colors.secondaryContainer,
      borderRadius: 16,
      marginBottom: responsive.spacing(theme.spacing.l),
    },
    switchLabel: {
      fontSize: responsive.fontSize(16),
      fontWeight: '500',
      color: theme.colors.onSecondaryContainer,
    },
    footer: {
      flexDirection: 'row',
      justifyContent: 'center',
      padding: responsive.spacing(theme.spacing.l),
      paddingTop: responsive.spacing(theme.spacing.m),
      gap: responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.elevation.level1,
    },
    button: {
      borderRadius: 24,
      flex: 1,
      maxWidth: isTablet ? 180 : 160,
    },
    buttonContent: {
      paddingVertical: responsive.spacing(theme.spacing.xs),
    },
    loadingContainer: {
      padding: responsive.spacing(theme.spacing.xl * 2),
      alignItems: 'center',
    },
    inputStyle: {
      backgroundColor: theme.colors.elevation.level1,
    },
  });
};

export function PizzaCustomizationFormModal({
  visible,
  onDismiss,
  customizationId,
  onSuccess,
}: PizzaCustomizationFormModalProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const isEditMode = !!customizationId;
  const styles = createStyles(theme, responsive);

  const { data: customization, isLoading: isLoadingCustomization } =
    usePizzaCustomization(customizationId || '');

  const createMutation = useCreatePizzaCustomization();
  const updateMutation = useUpdatePizzaCustomization();

  const {
    control,
    handleSubmit,
    formState: { errors, isSubmitting },
    reset,
    watch,
    setValue,
  } = useForm<PizzaCustomizationFormInputs>({
    resolver: zodResolver(pizzaCustomizationFormSchema),
    defaultValues: {
      name: '',
      type: CustomizationType.INGREDIENT,
      ingredients: '',
      toppingValue: 1,
      isActive: true,
      sortOrder: 100,
    },
  });

  const watchType = watch('type');

  useEffect(() => {
    if (customization && isEditMode) {
      reset({
        name: customization.name,
        type: customization.type,
        ingredients: customization.ingredients || '',
        toppingValue: customization.toppingValue,
        isActive: customization.isActive,
        sortOrder: customization.sortOrder,
      });
    } else if (!visible) {
      reset({
        name: '',
        type: CustomizationType.INGREDIENT,
        ingredients: '',
        toppingValue: 1,
        isActive: true,
        sortOrder: 100,
      });
    }
  }, [customization, isEditMode, reset, visible]);

  // Limpiar ingredientes cuando se cambie de FLAVOR a INGREDIENT
  useEffect(() => {
    if (watchType === CustomizationType.INGREDIENT) {
      setValue('ingredients', '');
    }
  }, [watchType, setValue]);

  const onSubmit = async (data: PizzaCustomizationFormInputs) => {
    try {
      // Asegurar que los ingredientes est√©n vac√≠os para tipo INGREDIENT
      const submissionData = {
        ...data,
        ingredients:
          data.type === CustomizationType.INGREDIENT ? '' : data.ingredients,
      };

      if (isEditMode && customizationId) {
        await updateMutation.mutateAsync({
          id: customizationId,
          data: submissionData,
        });
      } else {
        await createMutation.mutateAsync(submissionData);
      }
      onSuccess?.();
      onDismiss();
    } catch (error) {
      // El error ya se maneja en los hooks con snackbar
    }
  };

  if (isLoadingCustomization && isEditMode) {
    return (
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onDismiss}
          contentContainerStyle={styles.container}
        >
          <Pressable style={styles.backdrop} onPress={onDismiss} />
          <Surface style={styles.modalContent} elevation={5}>
            <View style={styles.loadingContainer}>
              <ActivityIndicator size="large" color={theme.colors.primary} />
              <Text
                variant="bodyLarge"
                style={{
                  marginTop: responsive.spacing(theme.spacing.m),
                  color: theme.colors.onSurfaceVariant,
                }}
              >
                Cargando personalizaci√≥n...
              </Text>
            </View>
          </Surface>
        </Modal>
      </Portal>
    );
  }

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.container}
      >
        <Pressable style={styles.backdrop} onPress={onDismiss} />
        <KeyboardAvoidingView
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={{ width: '100%' }}
        >
          <Surface style={styles.modalContent} elevation={5}>
            <View style={styles.header}>
              <Text style={styles.headerTitle}>
                {isEditMode ? 'Editar' : 'Nueva'} personalizaci√≥n
              </Text>
              <IconButton
                icon="close"
                size={20}
                onPress={onDismiss}
                iconColor={theme.colors.onSurfaceVariant}
                style={styles.closeButton}
              />
            </View>

            <ScrollView
              contentContainerStyle={styles.scrollContent}
              showsVerticalScrollIndicator={false}
            >
              <View style={styles.formGroup}>
                <Text style={styles.label}>Nombre del producto</Text>
                <Controller
                  control={control}
                  name="name"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <TextInput
                      placeholder="Ej: Pepperoni, Hawaiana"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.name}
                      mode="outlined"
                      outlineColor={theme.colors.outline}
                      activeOutlineColor={theme.colors.primary}
                      style={styles.inputStyle}
                      outlineStyle={{ borderRadius: 12 }}
                    />
                  )}
                />
                {errors.name && (
                  <HelperText type="error" visible={!!errors.name}>
                    {errors.name.message}
                  </HelperText>
                )}
              </View>

              <View style={styles.formGroup}>
                <Text style={styles.label}>Tipo de personalizaci√≥n</Text>
                <Controller
                  control={control}
                  name="type"
                  render={({ field: { onChange, value } }) => (
                    <SegmentedButtons
                      value={value}
                      onValueChange={onChange}
                      buttons={[
                        {
                          value: CustomizationType.FLAVOR,
                          label: 'Sabor',
                          icon: 'pizza',
                          style: {
                            backgroundColor:
                              value === CustomizationType.FLAVOR
                                ? theme.colors.primaryContainer
                                : 'transparent',
                          },
                        },
                        {
                          value: CustomizationType.INGREDIENT,
                          label: 'Ingrediente',
                          icon: 'cheese',
                          style: {
                            backgroundColor:
                              value === CustomizationType.INGREDIENT
                                ? theme.colors.primaryContainer
                                : 'transparent',
                          },
                        },
                      ]}
                      style={styles.segmentedButtons}
                    />
                  )}
                />
              </View>

              {watchType === CustomizationType.FLAVOR && (
                <View style={styles.formGroup}>
                  <Text style={styles.label}>Ingredientes del sabor</Text>
                  <Controller
                    control={control}
                    name="ingredients"
                    render={({ field: { onChange, onBlur, value } }) => (
                      <TextInput
                        placeholder="Ej: Jam√≥n, Pi√±a, Queso"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.ingredients}
                        mode="outlined"
                        multiline
                        numberOfLines={2}
                        outlineColor={theme.colors.outline}
                        activeOutlineColor={theme.colors.primary}
                        style={styles.inputStyle}
                        outlineStyle={{ borderRadius: 12 }}
                      />
                    )}
                  />
                  {errors.ingredients && (
                    <HelperText type="error" visible={!!errors.ingredients}>
                      {errors.ingredients.message}
                    </HelperText>
                  )}
                </View>
              )}

              <View style={styles.row}>
                <View style={styles.halfWidth}>
                  <Text style={styles.label}>Valor del topping</Text>
                  <Controller
                    control={control}
                    name="toppingValue"
                    render={({ field: { onChange, onBlur, value } }) => (
                      <TextInput
                        placeholder="0"
                        value={value?.toString() || ''}
                        onChangeText={(text) => {
                          const num = parseInt(text, 10);
                          onChange(isNaN(num) ? 0 : num);
                        }}
                        onBlur={onBlur}
                        error={!!errors.toppingValue}
                        mode="outlined"
                        keyboardType="numeric"
                        outlineColor={theme.colors.outline}
                        activeOutlineColor={theme.colors.primary}
                        style={styles.inputStyle}
                        outlineStyle={{ borderRadius: 12 }}
                      />
                    )}
                  />
                  {errors.toppingValue && (
                    <HelperText type="error" visible={!!errors.toppingValue}>
                      {errors.toppingValue.message}
                    </HelperText>
                  )}
                </View>

                <View style={styles.halfWidth}>
                  <Text style={styles.label}>Orden de aparici√≥n</Text>
                  <Controller
                    control={control}
                    name="sortOrder"
                    render={({ field: { onChange, onBlur, value } }) => (
                      <TextInput
                        placeholder="100"
                        value={value?.toString() || ''}
                        onChangeText={(text) => {
                          const num = parseInt(text, 10);
                          onChange(isNaN(num) ? 0 : num);
                        }}
                        onBlur={onBlur}
                        error={!!errors.sortOrder}
                        mode="outlined"
                        keyboardType="numeric"
                        outlineColor={theme.colors.outline}
                        activeOutlineColor={theme.colors.primary}
                        style={styles.inputStyle}
                        outlineStyle={{ borderRadius: 12 }}
                      />
                    )}
                  />
                  {errors.sortOrder && (
                    <HelperText type="error" visible={!!errors.sortOrder}>
                      {errors.sortOrder.message}
                    </HelperText>
                  )}
                </View>
              </View>

              <Controller
                control={control}
                name="isActive"
                render={({ field: { onChange, value } }) => (
                  <View style={styles.switchRow}>
                    <Text style={styles.switchLabel}>Activo</Text>
                    <Switch
                      value={value}
                      onValueChange={onChange}
                      color={theme.colors.primary}
                    />
                  </View>
                )}
              />
            </ScrollView>

            <View style={styles.footer}>
              <Button
                mode="contained-tonal"
                onPress={onDismiss}
                disabled={
                  isSubmitting ||
                  createMutation.isPending ||
                  updateMutation.isPending
                }
                style={styles.button}
                contentStyle={styles.buttonContent}
                labelStyle={{
                  fontSize: responsive.fontSize(16),
                  fontWeight: '600',
                }}
              >
                Cancelar
              </Button>
              <Button
                mode="contained"
                onPress={handleSubmit(onSubmit)}
                loading={
                  isSubmitting ||
                  createMutation.isPending ||
                  updateMutation.isPending
                }
                disabled={
                  isSubmitting ||
                  createMutation.isPending ||
                  updateMutation.isPending
                }
                style={[
                  styles.button,
                  { backgroundColor: theme.colors.primary },
                ]}
                contentStyle={styles.buttonContent}
                labelStyle={{
                  fontSize: responsive.fontSize(16),
                  fontWeight: '600',
                }}
                icon={isEditMode ? 'check' : 'plus'}
              >
                {isEditMode ? 'Guardar' : 'Crear'}
              </Button>
            </View>
          </Surface>
        </KeyboardAvoidingView>
      </Modal>
    </Portal>
  );
}

================
File: app/src/modules/preparationScreens/components/PreparationScreenFormModal.tsx
================
import React, { useState, useEffect } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  TextInput,
  Button,
  Switch,
  HelperText,
  Surface,
  List,
  Divider,
} from 'react-native-paper';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { User, RoleEnum } from '@/modules/users/types/user.types';
import { useGetUsers } from '@/modules/users/hooks/useUsers';
import {
  PreparationScreen,
  CreatePreparationScreenDto,
  UpdatePreparationScreenDto,
  CreatePreparationScreenSchema,
  UpdatePreparationScreenSchema,
} from '../schema/preparationScreen.schema';
import {
  useCreatePreparationScreen,
  useUpdatePreparationScreen,
  useGetPreparationScreens,
} from '../hooks/usePreparationScreensQueries';

interface PreparationScreenFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  editingItem: PreparationScreen | null;
  onSubmitSuccess?: () => void;
}

type FormData = CreatePreparationScreenDto | UpdatePreparationScreenDto;

const PreparationScreenFormModal: React.FC<PreparationScreenFormModalProps> = ({
  visible,
  onDismiss,
  editingItem,
  onSubmitSuccess,
}) => {
  const theme = useAppTheme();
  const styles = getStyles(theme);
  const isEditing = !!editingItem;
  const [showUserDropdown, setShowUserDropdown] = useState(false);
  const [selectedUser, setSelectedUser] = useState<User | null>(null);

  // Obtener todos los usuarios activos
  const { data: usersData, isLoading: isLoadingUsers } = useGetUsers({
    filters: {
      isActive: true,
    },
  });

  // Obtener todas las pantallas de preparaci√≥n para verificar usuarios asignados
  const { data: screensData } = useGetPreparationScreens(
    {},
    { page: 1, limit: 100 }, // Obtener todas las pantallas
  );

  // Crear mapa de usuarios asignados a pantallas
  const userAssignments = React.useMemo(() => {
    if (!screensData?.data) return new Map<string, string>();

    const assignments = new Map<string, string>();
    screensData.data.forEach((screen) => {
      // Excluir la pantalla actual al editar
      if (editingItem && screen.id === editingItem.id) return;

      if (screen.users && screen.users.length > 0) {
        screen.users.forEach((user) => {
          assignments.set(user.id, screen.name);
        });
      }
    });
    return assignments;
  }, [screensData, editingItem]);

  // Todos los usuarios, ordenados con los de cocina primero y disponibles al inicio
  const allUsers = React.useMemo(() => {
    if (!usersData?.data) return [];

    return usersData.data.sort((a, b) => {
      // Primero ordenar por disponibilidad
      const aAssigned = userAssignments.has(a.id);
      const bAssigned = userAssignments.has(b.id);
      if (!aAssigned && bAssigned) return -1;
      if (aAssigned && !bAssigned) return 1;

      // Luego por rol de cocina
      const aIsKitchen = a.role?.id === RoleEnum.KITCHEN;
      const bIsKitchen = b.role?.id === RoleEnum.KITCHEN;
      if (aIsKitchen && !bIsKitchen) return -1;
      if (!aIsKitchen && bIsKitchen) return 1;

      return 0;
    });
  }, [usersData, userAssignments]);

  // Hooks de mutaci√≥n
  const createScreen = useCreatePreparationScreen();
  const updateScreen = useUpdatePreparationScreen();

  // Configuraci√≥n del formulario
  const formSchema = isEditing
    ? UpdatePreparationScreenSchema
    : CreatePreparationScreenSchema;

  const {
    control,
    handleSubmit,
    formState: { errors },
    reset,
    setValue,
  } = useForm<FormData>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      name: '',
      description: undefined,
      isActive: true,
      userId: '',
    },
  });

  // Efecto para cargar datos al editar
  useEffect(() => {
    if (editingItem) {
      reset({
        name: editingItem.name,
        description: editingItem.description ?? undefined,
        isActive: editingItem.isActive,
        userId:
          editingItem.users && editingItem.users.length > 0
            ? editingItem.users[0].id
            : '', // Siempre string vac√≠o para activar validaci√≥n
      });
      setSelectedUser(
        editingItem.users && editingItem.users.length > 0
          ? (editingItem.users[0] as User)
          : null,
      );
    } else {
      reset({
        name: '',
        description: undefined,
        isActive: true,
        userId: '',
      });
      setSelectedUser(null);
    }
  }, [editingItem, reset]);

  // Manejo del env√≠o del formulario
  const onSubmit = async (data: FormData) => {
    try {
      if (isEditing && editingItem) {
        await updateScreen.mutateAsync({
          id: editingItem.id,
          data: data as UpdatePreparationScreenDto,
        });
      } else {
        await createScreen.mutateAsync(data as CreatePreparationScreenDto);
      }
      onSubmitSuccess?.();
      onDismiss();
    } catch (error: any) {
      // No mostrar snackbar aqu√≠ porque el hook ya lo hace
      // Solo hacer log para debugging
    }
  };

  // Manejo de selecci√≥n de usuario
  const handleUserSelect = (user: User) => {
    setSelectedUser(user);
    setValue('userId', user.id);
    setShowUserDropdown(false);
  };

  const handleClearUser = () => {
    setSelectedUser(null);
    setValue('userId', '');
  };

  const isSubmitting = createScreen.isPending || updateScreen.isPending;

  // Funciones auxiliares para roles
  const getRoleLabel = (roleId?: number) => {
    switch (roleId) {
      case RoleEnum.ADMIN:
        return 'Administrador';
      case RoleEnum.MANAGER:
        return 'Gerente';
      case RoleEnum.CASHIER:
        return 'Cajero';
      case RoleEnum.WAITER:
        return 'Mesero';
      case RoleEnum.KITCHEN:
        return 'Cocina';
      case RoleEnum.DELIVERY:
        return 'Repartidor';
      default:
        return 'Sin rol';
    }
  };

  const getIconForRole = (roleId?: number) => {
    switch (roleId) {
      case RoleEnum.ADMIN:
        return 'shield-account';
      case RoleEnum.MANAGER:
        return 'account-tie';
      case RoleEnum.CASHIER:
        return 'cash-register';
      case RoleEnum.WAITER:
        return 'room-service';
      case RoleEnum.KITCHEN:
        return 'chef-hat';
      case RoleEnum.DELIVERY:
        return 'moped';
      default:
        return 'account';
    }
  };

  return (
    <>
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onDismiss}
          contentContainerStyle={styles.modalContent}
        >
          <ScrollView>
            <Surface style={styles.surface}>
              <Text variant="headlineSmall" style={styles.title}>
                {isEditing
                  ? 'Editar Pantalla de Preparaci√≥n'
                  : 'Crear Nueva Pantalla'}
              </Text>

              <View style={styles.form}>
                {/* Campo Nombre */}
                <Controller
                  control={control}
                  name="name"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.field}>
                      <TextInput
                        label="Nombre de la Pantalla *"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.name}
                        disabled={isSubmitting}
                        placeholder="Ej: Cocina Principal, Barra Fr√≠a"
                        mode="outlined"
                      />
                      {errors.name && (
                        <HelperText type="error" visible={!!errors.name}>
                          {errors.name.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />

                {/* Campo Descripci√≥n */}
                <Controller
                  control={control}
                  name="description"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.field}>
                      <TextInput
                        label="Descripci√≥n (Opcional)"
                        value={value || ''}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.description}
                        disabled={isSubmitting}
                        placeholder="Ej: Pantalla para √≥rdenes de cocina caliente"
                        mode="outlined"
                        multiline
                        numberOfLines={3}
                      />
                      {errors.description && (
                        <HelperText type="error" visible={!!errors.description}>
                          {errors.description.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />

                {/* Campo Usuario */}
                <Controller
                  control={control}
                  name="userId"
                  render={() => (
                    <View style={styles.field}>
                      <TextInput
                        label="Usuario de Cocina *"
                        value={
                          selectedUser
                            ? `${selectedUser.firstName || ''} ${selectedUser.lastName || ''}`.trim() ||
                              selectedUser.username
                            : ''
                        }
                        mode="outlined"
                        error={!!errors.userId}
                        disabled={isSubmitting || isLoadingUsers}
                        onPressOut={() => {
                          if (
                            !isSubmitting &&
                            !isLoadingUsers &&
                            allUsers.length > 0
                          ) {
                            setShowUserDropdown(true);
                          }
                        }}
                        showSoftInputOnFocus={false}
                        editable={false}
                        right={
                          selectedUser ? (
                            <TextInput.Icon
                              icon="close"
                              onPress={() => {
                                handleClearUser();
                              }}
                              disabled={isSubmitting}
                            />
                          ) : (
                            <TextInput.Icon
                              icon={isLoadingUsers ? 'loading' : 'chevron-down'}
                              disabled={isSubmitting || isLoadingUsers}
                              onPress={() => {
                                if (!isSubmitting && !isLoadingUsers) {
                                  setShowUserDropdown(true);
                                }
                              }}
                            />
                          )
                        }
                      />
                      {errors.userId && (
                        <HelperText type="error" visible={!!errors.userId}>
                          {errors.userId.message}
                        </HelperText>
                      )}
                      {!errors.userId && (
                        <HelperText type="info" visible={true}>
                          Nota: Un usuario solo puede estar asignado a una
                          pantalla a la vez
                        </HelperText>
                      )}
                    </View>
                  )}
                />

                {/* Campo Activa */}
                <Controller
                  control={control}
                  name="isActive"
                  render={({ field: { onChange, value } }) => (
                    <View style={styles.switchField}>
                      <Text variant="bodyLarge">¬øEst√° activa?</Text>
                      <Switch
                        value={value}
                        onValueChange={onChange}
                        disabled={isSubmitting}
                        color={theme.colors.primary}
                      />
                    </View>
                  )}
                />
              </View>

              <View style={styles.actions}>
                <Button mode="text" onPress={onDismiss} disabled={isSubmitting}>
                  Cancelar
                </Button>
                <Button
                  mode="contained"
                  onPress={handleSubmit(onSubmit)}
                  loading={isSubmitting}
                  disabled={isSubmitting}
                >
                  {isEditing ? 'Actualizar' : 'Crear'}
                </Button>
              </View>
            </Surface>
          </ScrollView>
        </Modal>
      </Portal>

      {/* Dropdown de usuarios */}
      <Portal>
        <Modal
          visible={showUserDropdown}
          onDismiss={() => setShowUserDropdown(false)}
          contentContainerStyle={[styles.dropdownModal, { maxHeight: 300 }]}
        >
          <Surface style={styles.dropdownContent}>
            <View style={styles.dropdownHeader}>
              <Text variant="titleMedium" style={styles.dropdownTitle}>
                Seleccionar Usuario de Cocina
              </Text>
              <Text variant="bodySmall" style={styles.dropdownSubtitle}>
                Solo los usuarios con rol de cocina pueden ser seleccionados
              </Text>
            </View>
            <Divider />
            <ScrollView>
              {isLoadingUsers ? (
                <View style={styles.loadingContainer}>
                  <Text>Cargando usuarios...</Text>
                </View>
              ) : allUsers.length === 0 ? (
                <View style={styles.emptyContainer}>
                  <Text>No hay usuarios disponibles</Text>
                </View>
              ) : (
                allUsers.map((user) => {
                  const displayName =
                    `${user.firstName || ''} ${user.lastName || ''}`.trim() ||
                    user.username;
                  const isKitchenUser = user.role?.id === RoleEnum.KITCHEN;
                  const roleLabel = getRoleLabel(user.role?.id);
                  const assignedScreen = userAssignments.get(user.id);
                  const isAssigned = !!assignedScreen;
                  const isSelectable = isKitchenUser && !isAssigned;

                  return (
                    <List.Item
                      key={user.id}
                      title={displayName}
                      description={
                        isAssigned
                          ? `Asignado a: ${assignedScreen}`
                          : `${user.username !== displayName ? user.username + ' ‚Ä¢ ' : ''}${roleLabel}`
                      }
                      onPress={
                        isSelectable ? () => handleUserSelect(user) : undefined
                      }
                      left={(props) => (
                        <List.Icon
                          {...props}
                          icon={getIconForRole(user.role?.id)}
                          color={
                            isAssigned ? theme.colors.outline : props.color
                          }
                        />
                      )}
                      style={[
                        styles.dropdownItem,
                        !isSelectable && styles.disabledDropdownItem,
                      ]}
                      disabled={!isSelectable}
                      titleStyle={!isSelectable && styles.disabledText}
                      descriptionStyle={[
                        !isSelectable && styles.disabledText,
                        isAssigned && { color: theme.colors.error },
                      ]}
                    />
                  );
                })
              )}
            </ScrollView>
          </Surface>
        </Modal>
      </Portal>
    </>
  );
};

const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    modalContent: {
      margin: 20,
    },
    surface: {
      borderRadius: theme.roundness * 2,
      overflow: 'hidden',
    },
    title: {
      padding: 24,
      paddingBottom: 16,
      color: theme.colors.onSurface,
    },
    form: {
      paddingHorizontal: 24,
    },
    field: {
      marginBottom: 16,
    },
    switchField: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 16,
      paddingVertical: 8,
    },
    actions: {
      flexDirection: 'row',
      justifyContent: 'flex-end',
      padding: 16,
      paddingTop: 8,
      gap: 8,
      borderTopWidth: 1,
      borderTopColor: theme.colors.surfaceVariant,
    },
    dropdownModal: {
      margin: 20,
      marginTop: '30%',
    },
    dropdownContent: {
      borderRadius: theme.roundness * 2,
      overflow: 'hidden',
    },
    dropdownHeader: {
      padding: 16,
      paddingBottom: 12,
    },
    dropdownTitle: {
      marginBottom: 4,
    },
    dropdownSubtitle: {
      color: theme.colors.onSurfaceVariant,
    },
    dropdownItem: {
      paddingHorizontal: 16,
    },
    disabledDropdownItem: {
      opacity: 0.5,
      backgroundColor: theme.colors.surfaceDisabled,
    },
    disabledText: {
      color: theme.colors.onSurfaceDisabled,
    },
    loadingContainer: {
      padding: 20,
      alignItems: 'center',
    },
    emptyContainer: {
      padding: 20,
      alignItems: 'center',
    },
  });

export default PreparationScreenFormModal;

================
File: app/src/modules/receipts/types/receipt.types.ts
================
import type {
  OrderType,
  OrderStatus,
} from '@/modules/orders/types/orders.types';

// Tipo para la lista optimizada de recibos
export interface ReceiptList {
  id: string;
  shiftOrderNumber: number;
  orderType: OrderType;
  orderStatus: OrderStatus;
  total: number;
  createdAt: string;
  scheduledAt?: string;
  finalizedAt: string;
  notes?: string;
  paymentsSummary?: {
    totalPaid: number;
  };
  table?: {
    id: string;
    number: string;
    name: string;
    isTemporary: boolean;
    area?: {
      name: string;
    };
  };
  deliveryInfo?: {
    recipientName?: string;
    recipientPhone?: string;
    fullAddress?: string;
  };
  preparationScreenStatuses?: Array<{
    name: string;
    status: 'PENDING' | 'IN_PROGRESS' | 'READY';
  }>;
  ticketImpressionCount?: number;
  createdBy?: {
    username: string;
    firstName?: string | null;
    lastName?: string | null;
  };
  isFromWhatsApp?: boolean;
}

// Tipo para el detalle completo del recibo
export interface Receipt {
  id: string;
  shiftOrderNumber: number;
  orderType: OrderType;
  orderStatus: OrderStatus;
  total: number;
  subtotal: number;
  createdAt: string;
  updatedAt: string;
  finalizedAt?: string;
  scheduledAt?: string;
  notes?: string;
  userId?: string;
  tableId?: string;
  customerId?: string;
  isFromWhatsApp?: boolean;
  estimatedDeliveryTime?: string;
  user?: {
    id: string;
    firstName?: string;
    lastName?: string;
    username?: string;
  };
  table?: {
    id: string;
    number: string;
    name: string;
    isTemporary: boolean;
    area?: {
      id: string;
      name: string;
    };
  };
  customer?: {
    id: string;
    name: string;
    phone?: string;
    email?: string;
  };
  deliveryInfo?: {
    id: string;
    recipientName?: string;
    recipientPhone?: string;
    deliveryInstructions?: string;
    fullAddress?: string;
    street?: string;
    number?: string;
    interiorNumber?: string;
    neighborhood?: string;
    city?: string;
    state?: string;
    zipCode?: string;
    country?: string;
    latitude?: number;
    longitude?: number;
  };
  preparationScreens?: string[];
  orderItems: Array<{
    id: string;
    quantity?: number;
    basePrice: number;
    finalPrice: number;
    preparationNotes?: string;
    preparationStatus?: string;
    product: {
      id: string;
      name: string;
      description?: string;
      price: number;
    };
    productVariant?: {
      id: string;
      name: string;
      price: number;
    };
    productModifiers?: Array<{
      id: string;
      name: string;
      price: number;
    }>;
    selectedPizzaCustomizations?: Array<any>;
  }>;
  payments?: Array<{
    id: string;
    amount: number;
    paymentMethod: string;
    paymentStatus: string;
    createdAt: string;
    updatedAt: string;
  }>;
  adjustments?: Array<{
    id: string;
    type: string;
    amount: number;
    reason?: string;
    createdAt: string;
  }>;
  ticketImpressions?: Array<{
    id: string;
    ticketType: string;
    impressionTime: string;
    user?: {
      id: string;
      firstName?: string;
      lastName?: string;
    };
    printer?: {
      id: string;
      name: string;
    };
  }>;
}

// Respuesta de lista de recibos (sin paginaci√≥n)
export type ReceiptsListResponse = ReceiptList[];

// Filtros para buscar recibos
export interface ReceiptFilters {
  startDate?: string;
  endDate?: string;
  orderType?: OrderType;
}

================
File: app/src/modules/shiftAudit/components/ShiftOrdersModal.tsx
================
import React, { useState, useMemo } from 'react';
import {
  Modal,
  View,
  StyleSheet,
  TouchableOpacity,
  RefreshControl,
  FlatList,
} from 'react-native';
import {
  Portal,
  Appbar,
  Searchbar,
  Text,
  ActivityIndicator,
} from 'react-native-paper';
import OrderSummaryCard from '@/modules/shared/components/OrderSummaryCard';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useShiftOrders } from '../hooks/useShiftOrders';
import EmptyState from '@/app/components/common/EmptyState';
import type { Order } from '@/app/schemas/domain/order.schema';
import { OrderTypeEnum } from '@/modules/orders/types/orders.types';
import {
  formatOrderTypeShort,
  getPaymentStatus,
} from '@/app/utils/orderFormatters';
import { receiptService } from '@/modules/receipts/services/receiptService';
import type { Receipt } from '@/modules/receipts/types/receipt.types';
import { OrderDetailsView } from './OrderDetailsView';
import { OrderHistoryView } from './OrderHistoryView';

interface ShiftOrdersModalProps {
  visible: boolean;
  onClose: () => void;
  shiftId: string;
}

export function ShiftOrdersModal({
  visible,
  onClose,
  shiftId,
}: ShiftOrdersModalProps) {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);

  const [searchQuery, setSearchQuery] = useState('');
  const [selectedReceipt, setSelectedReceipt] = useState<Receipt | null>(null);
  const [showReceiptDetails, setShowReceiptDetails] = useState(false);
  const [showOrderHistory, setShowOrderHistory] = useState(false);
  const [isRefreshing, setIsRefreshing] = useState(false);

  const {
    data: orders,
    isLoading,
    error,
    refetch,
    isRefetching,
  } = useShiftOrders(shiftId);

  const handleRefresh = async () => {
    setIsRefreshing(true);
    await refetch();
    setIsRefreshing(false);
  };

  const handleReceiptPress = async (order: Order) => {
    try {
      const fullOrder = await receiptService.getReceiptById(order.id);
      setSelectedReceipt(fullOrder);
      setShowReceiptDetails(true);
    } catch (error) {
      // Error al cargar detalles del recibo
    }
  };

  // Filtrar √≥rdenes basado en b√∫squeda
  const filteredOrders = useMemo(() => {
    if (!orders) return [];
    if (!searchQuery.trim()) return orders;

    const search = searchQuery.toLowerCase().trim();
    return orders.filter((order) => {
      // Buscar por n√∫mero de orden
      if (order.shiftOrderNumber?.toString().includes(search)) return true;
      if (order.orderNumber?.toString().includes(search)) return true;

      // Buscar en informaci√≥n de entrega
      if (order.deliveryInfo) {
        // Campos principales
        if (order.deliveryInfo.customerName?.toLowerCase().includes(search))
          return true;
        if (order.deliveryInfo.customerPhone?.includes(search)) return true;
        if (order.deliveryInfo.address?.toLowerCase().includes(search))
          return true;

        // Campos alternativos que pueden venir del backend
        if (order.deliveryInfo.recipientName?.toLowerCase().includes(search))
          return true;
        if (order.deliveryInfo.recipientPhone?.includes(search)) return true;
        if (order.deliveryInfo.fullAddress?.toLowerCase().includes(search))
          return true;

        // Campos adicionales de direcci√≥n
        if (order.deliveryInfo.street?.toLowerCase().includes(search))
          return true;
        if (order.deliveryInfo.neighborhood?.toLowerCase().includes(search))
          return true;
        if (order.deliveryInfo.city?.toLowerCase().includes(search))
          return true;
      }

      // Buscar en mesa/√°rea para √≥rdenes locales
      if (order.table) {
        if (order.table.name?.toLowerCase().includes(search)) return true;
        if (order.table.number?.toString().includes(search)) return true;
        if (order.table.area?.name?.toLowerCase().includes(search)) return true;
      }

      // Buscar en √°rea directa
      if (order.area?.name?.toLowerCase().includes(search)) return true;

      // Buscar en notas
      if (order.notes?.toLowerCase().includes(search)) return true;

      // Buscar en nombre del usuario creador
      if (order.createdBy) {
        if (order.createdBy.firstName?.toLowerCase().includes(search))
          return true;
        if (order.createdBy.lastName?.toLowerCase().includes(search))
          return true;
        if (order.createdBy.username?.toLowerCase().includes(search))
          return true;
      }

      // Buscar en user (campo alternativo)
      if (order.user) {
        if (order.user.firstName?.toLowerCase().includes(search)) return true;
        if (order.user.lastName?.toLowerCase().includes(search)) return true;
      }

      return false;
    });
  }, [orders, searchQuery]);

  // Funci√≥n espec√≠fica para el color de estado en recibos
  const getReceiptStatusColor = (status: string) => {
    switch (status) {
      case 'COMPLETED':
        return theme.colors.primary;
      case 'CANCELLED':
        return theme.colors.error;
      case 'DELIVERED':
        return '#9333EA'; // Morado
      default:
        return theme.colors.onSurfaceDisabled;
    }
  };

  const getStatusLabel = (status: string) => {
    switch (status) {
      case 'COMPLETED':
        return 'Completada';
      case 'CANCELLED':
        return 'Cancelada';
      case 'DELIVERED':
        return 'Entregada';
      default:
        return status;
    }
  };

  // Renderizar item de recibo usando el componente compartido
  const renderReceiptItem = ({ item }: { item: Order }) => (
    <OrderSummaryCard
      item={item}
      onPress={() => handleReceiptPress(item)}
      getStatusColor={getReceiptStatusColor}
      getStatusLabel={getStatusLabel}
    />
  );


  // Renderizar lista vac√≠a
  const renderEmptyComponent = () => {
    if (isLoading) {
      return (
        <View style={styles.centerContainer}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
        </View>
      );
    }

    return (
      <EmptyState
        icon="receipt"
        title="No hay √≥rdenes"
        message={
          searchQuery
            ? 'No se encontraron √≥rdenes con los criterios de b√∫squeda'
            : 'Este turno no tiene √≥rdenes registradas'
        }
      />
    );
  };

  return (
    <Portal>
      <Modal
        visible={visible}
        onRequestClose={onClose}
        animationType="slide"
        presentationStyle="formSheet"
      >
        <View style={styles.container}>
          {showOrderHistory && selectedReceipt ? (
            <OrderHistoryView
              orderId={selectedReceipt.id}
              orderNumber={
                selectedReceipt.shiftOrderNumber || selectedReceipt.orderNumber
              }
              onBack={() => {
                setShowOrderHistory(false);
                setShowReceiptDetails(true);
              }}
            />
          ) : showReceiptDetails && selectedReceipt ? (
            <OrderDetailsView
              order={selectedReceipt}
              onBack={() => {
                setShowReceiptDetails(false);
                setSelectedReceipt(null);
              }}
              onShowHistory={() => {
                setShowReceiptDetails(false);
                setShowOrderHistory(true);
              }}
            />
          ) : (
            <>
              <Appbar.Header style={styles.header}>
                <Appbar.BackAction onPress={onClose} />
                <Appbar.Content title="√ìrdenes del Turno" />
                <Appbar.Action
                  icon="refresh"
                  onPress={handleRefresh}
                  disabled={isLoading || isRefreshing}
                />
              </Appbar.Header>

              {/* B√∫squeda */}
              <View style={styles.searchContainer}>
                <Searchbar
                  placeholder="Buscar por nombre, tel√©fono o direcci√≥n..."
                  onChangeText={setSearchQuery}
                  value={searchQuery}
                  style={styles.searchbar}
                  elevation={0}
                />
              </View>

              {/* Lista de √≥rdenes */}
              {error ? (
                <EmptyState
                  icon="alert-circle"
                  title="Error al cargar"
                  message={error.message || 'No se pudieron cargar las √≥rdenes'}
                  actionLabel="Reintentar"
                  onAction={refetch}
                />
              ) : (
                <FlatList
                  data={filteredOrders}
                  renderItem={renderReceiptItem}
                  keyExtractor={(item) => item.id}
                  contentContainerStyle={styles.listContent}
                  refreshControl={
                    <RefreshControl
                      refreshing={isRefetching}
                      onRefresh={refetch}
                      colors={[theme.colors.primary]}
                    />
                  }
                  ListEmptyComponent={renderEmptyComponent}
                />
              )}
            </>
          )}
        </View>
      </Modal>
    </Portal>
  );
}

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    header: {
      backgroundColor: theme.colors.surface,
      elevation: 2,
    },
    searchContainer: {
      paddingHorizontal: 16,
      paddingVertical: 12,
      backgroundColor: theme.colors.surface,
    },
    searchbar: {
      backgroundColor: theme.colors.background,
      elevation: 0,
    },
    listContent: {
      padding: theme.spacing.s,
      paddingBottom: theme.spacing.l * 2,
    },
    orderCard: {
      marginBottom: 8,
    },
    cardContent: {
      paddingBottom: 8,
    },
    mainContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
    },
    leftContainer: {
      flex: 1,
      paddingRight: 12,
      flexShrink: 1,
    },
    rightContainer: {
      alignItems: 'flex-end',
      justifyContent: 'space-between',
      minWidth: 120,
      gap: 8,
      flexShrink: 0,
    },
    orderNumber: {
      fontSize: 16,
      fontWeight: 'bold',
      lineHeight: 22,
      marginBottom: 4,
    },
    orderPrice: {
      fontSize: 15,
      fontWeight: '700',
    },
    orderTime: {
      fontSize: 16,
      fontWeight: '600',
    },
    timeAndPaymentRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 0,
    },
    statusChip: {
      minHeight: 24,
      alignSelf: 'flex-end',
      paddingVertical: 2,
    },
    statusChipText: {
      fontSize: 12,
      fontWeight: '600',
      color: 'white',
      lineHeight: 14,
      marginVertical: 0,
      paddingVertical: 0,
    },
    notesInline: {
      fontSize: 12,
      fontStyle: 'italic',
    },
    inlinePreparationBadge: {
      paddingHorizontal: 6,
      paddingVertical: 2,
      borderRadius: 10,
      borderWidth: 0.5,
    },
    inlinePreparationText: {
      fontSize: 10,
      fontWeight: '500',
    },
    centerContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: 32,
    },
    miniPaymentBadge: {
      width: 20,
      height: 20,
      borderRadius: 10,
      alignItems: 'center',
      justifyContent: 'center',
      marginLeft: 6,
    },
    miniPaymentText: {
      fontSize: 10,
      fontWeight: 'bold',
      color: '#FFFFFF',
    },
    createdByText: {
      fontSize: 10,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 4,
      textAlign: 'right',
    },
  });

================
File: app/src/modules/shiftAudit/hooks/useShifts.ts
================
import { useQuery } from '@tanstack/react-query';
import { shiftsService, type Shift } from '@/services/shifts';

export const useShifts = (params?: {
  startDate?: string;
  endDate?: string;
}) => {
  return useQuery<Shift[], Error>({
    queryKey: ['shifts', 'history', params],
    queryFn: () => shiftsService.getHistory(params),
    staleTime: 0,
    gcTime: 0,
    refetchOnWindowFocus: false,
    refetchOnMount: true,
  });
};

export const useCurrentShift = () => {
  return useQuery<Shift | null, Error>({
    queryKey: ['shifts', 'current'],
    queryFn: () => shiftsService.getCurrentShift(),
    staleTime: 30000,
    refetchInterval: 60000,
    refetchOnWindowFocus: true,
    refetchOnMount: true,
  });
};

export const useShiftDetail = (shiftId: string | undefined) => {
  return useQuery<Shift, Error>({
    queryKey: ['shifts', shiftId],
    queryFn: () => shiftsService.getById(shiftId!),
    enabled: !!shiftId,
    staleTime: 300000,
    refetchOnWindowFocus: false,
    refetchOnMount: false,
  });
};

================
File: app/src/modules/sync/services/syncService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import { SyncStatus, SyncActivity } from '../types/sync.types';

class SyncService {
  /**
   * Obtiene el estado actual del servicio de sincronizaci√≥n
   */
  async getSyncStatus(): Promise<SyncStatus> {
    const response = await apiClient.get<SyncStatus>(API_PATHS.SYNC_STATUS);
    if (!response.data) {
      throw new Error('No se pudo obtener el estado de sincronizaci√≥n');
    }
    return response.data;
  }

  /**
   * Obtiene el historial de actividad reciente de sincronizaci√≥n
   * @param limit N√∫mero m√°ximo de registros (por defecto 20)
   */
  async getSyncActivity(limit: number = 20): Promise<SyncActivity[]> {
    const response = await apiClient.get<SyncActivity[]>(
      API_PATHS.SYNC_ACTIVITY,
      { params: { limit } },
    );
    if (!response.data) {
      throw new Error('No se pudo obtener la actividad de sincronizaci√≥n');
    }
    return response.data;
  }

  /**
   * Verifica si el servicio de sincronizaci√≥n est√° disponible
   */
  async checkSyncAvailability(): Promise<boolean> {
    try {
      const status = await this.getSyncStatus();
      return status.enabled;
    } catch (error) {
      console.error(
        'Error verificando disponibilidad de sincronizaci√≥n:',
        error,
      );
      return false;
    }
  }
}

export const syncService = new SyncService();

================
File: app/src/modules/users/components/UserDetailModal.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Portal,
  Modal,
  Text,
  Surface,
  IconButton,
  Chip,
  Button,
  Dialog,
  TextInput,
  Icon,
} from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useResetPassword, useDeleteUser } from '../hooks';
import type { User } from '../types';

interface UserDetailModalProps {
  visible: boolean;
  onDismiss: () => void;
  user: User;
  onEdit: (user: User) => void;
}

export function UserDetailModal({
  visible,
  onDismiss,
  user,
  onEdit,
}: UserDetailModalProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = getStyles(theme, responsive);

  const [showPasswordDialog, setShowPasswordDialog] = useState(false);
  const [newPassword, setNewPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);

  const resetPasswordMutation = useResetPassword();
  const deleteUserMutation = useDeleteUser();

  const handleResetPassword = async () => {
    if (newPassword !== confirmPassword) {
      return;
    }
    if (newPassword.length < 6) {
      return;
    }

    try {
      await resetPasswordMutation.mutateAsync({
        id: user.id,
        password: newPassword,
      });
      setShowPasswordDialog(false);
      setNewPassword('');
      setConfirmPassword('');
    } catch (error) {
      // Error handled in mutation
    }
  };

  const handleDeleteUser = async () => {
    try {
      await deleteUserMutation.mutateAsync(user.id);
      onDismiss();
    } catch (error) {
      // Error handled in mutation
    }
  };

  const getGenderLabel = (gender?: string | null) => {
    switch (gender) {
      case 'male':
        return 'Masculino';
      case 'female':
        return 'Femenino';
      case 'other':
        return 'Otro';
      default:
        return 'No especificado';
    }
  };

  const getRoleInfo = (roleId?: number) => {
    switch (roleId) {
      case 1:
        return {
          label: 'Administrador',
          icon: 'shield-account',
          color: theme.colors.error,
        };
      case 2:
        return {
          label: 'Gerente',
          icon: 'account-tie',
          color: theme.colors.primary,
        };
      case 3:
        return {
          label: 'Cajero',
          icon: 'cash-register',
          color: theme.colors.tertiary,
        };
      case 4:
        return {
          label: 'Mesero',
          icon: 'room-service',
          color: theme.colors.secondary,
        };
      case 5:
        return { label: 'Cocina', icon: 'chef-hat', color: '#FF6B6B' };
      case 6:
        return { label: 'Repartidor', icon: 'moped', color: '#4ECDC4' };
      default:
        return {
          label: 'Sin rol',
          icon: 'account',
          color: theme.colors.onSurfaceVariant,
        };
    }
  };

  return (
    <>
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onDismiss}
          contentContainerStyle={styles.modalContainer}
        >
          <Surface style={styles.modalContent} elevation={3}>
            {/* Header */}
            <View
              style={[
                styles.headerContainer,
                { backgroundColor: theme.colors.elevation.level2 },
              ]}
            >
              <View style={styles.headerContent}>
                <View style={styles.headerNameRow}>
                  <Text
                    style={[
                      styles.modalTitle,
                      { color: theme.colors.onSurface },
                    ]}
                    variant="titleMedium"
                  >
                    {`${user.firstName || ''} ${user.lastName || ''}`.trim() ||
                      user.username}
                  </Text>
                  <Chip
                    mode="flat"
                    icon={getRoleInfo(user.role?.id).icon}
                    style={[
                      styles.headerRoleChip,
                      { backgroundColor: theme.colors.surface },
                    ]}
                    textStyle={[
                      styles.headerRoleChipText,
                      { color: getRoleInfo(user.role?.id).color },
                    ]}
                    compact
                  >
                    {getRoleInfo(user.role?.id).label}
                  </Chip>
                </View>
                <Text
                  style={[
                    styles.modalSubtitle,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                  variant="bodySmall"
                >
                  {user.username}
                </Text>
              </View>
              <IconButton
                icon="close"
                size={20}
                onPress={onDismiss}
                iconColor={theme.colors.onSurfaceVariant}
              />
            </View>

            <ScrollView
              style={styles.contentContainer}
              showsVerticalScrollIndicator={false}
            >
              {/* Contact Information */}
              <View style={styles.infoSection}>
                <View style={styles.sectionHeader}>
                  <Icon
                    source="contacts"
                    size={20}
                    color={theme.colors.primary}
                  />
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Informaci√≥n de Contacto
                  </Text>
                </View>

                <View style={styles.compactRow}>
                  <Icon source="email" size={18} color={theme.colors.primary} />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Email
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.email || 'No especificado'}
                    </Text>
                  </View>
                </View>

                <View style={styles.compactRow}>
                  <Icon source="phone" size={18} color={theme.colors.primary} />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Tel√©fono
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.phoneNumber || 'No especificado'}
                    </Text>
                  </View>
                </View>
              </View>

              {/* Personal Information */}
              <View style={styles.infoSection}>
                <View style={styles.sectionHeader}>
                  <Icon
                    source="account-details"
                    size={20}
                    color={theme.colors.primary}
                  />
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Informaci√≥n Personal
                  </Text>
                </View>

                <View style={styles.compactRow}>
                  <Icon
                    source="account"
                    size={18}
                    color={theme.colors.primary}
                  />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Nombre completo
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {`${user.firstName || 'No especificado'} ${user.lastName || 'No especificado'}`}
                    </Text>
                  </View>
                </View>

                <View style={styles.compactRow}>
                  <Icon
                    source="gender-transgender"
                    size={18}
                    color={theme.colors.primary}
                  />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      G√©nero
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {getGenderLabel(user.gender)}
                    </Text>
                  </View>
                </View>

                <View style={styles.compactRow}>
                  <Icon
                    source="cake-variant"
                    size={18}
                    color={theme.colors.primary}
                  />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Fecha de nacimiento
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.birthDate
                        ? new Date(user.birthDate).toLocaleDateString('es-MX', {
                            year: 'numeric',
                            month: 'long',
                            day: 'numeric',
                          })
                        : 'No especificado'}
                    </Text>
                  </View>
                </View>

                <View style={styles.compactRow}>
                  <Icon
                    source={
                      user.isActive
                        ? 'check-circle-outline'
                        : 'close-circle-outline'
                    }
                    size={18}
                    color={
                      user.isActive ? theme.colors.primary : theme.colors.error
                    }
                  />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Estado de la cuenta
                    </Text>
                    <Text
                      style={[
                        styles.compactValue,
                        {
                          color: user.isActive
                            ? theme.colors.primary
                            : theme.colors.error,
                        },
                      ]}
                      variant="bodySmall"
                    >
                      {user.isActive ? 'Activa' : 'Inactiva'}
                    </Text>
                  </View>
                </View>

                {/* Preparation Screen for Kitchen Role */}
                {user.role?.id === 5 && (
                  <View style={styles.compactRow}>
                    <Icon
                      source="monitor"
                      size={18}
                      color={theme.colors.primary}
                    />
                    <View style={styles.compactContent}>
                      <Text style={styles.compactLabel} variant="labelSmall">
                        Pantalla de Preparaci√≥n
                      </Text>
                      <Text style={styles.compactValue} variant="bodySmall">
                        {user.preparationScreen?.name || 'No asignada'}
                      </Text>
                    </View>
                  </View>
                )}
              </View>

              {/* Address Information */}
              <View style={styles.infoSection}>
                <View style={styles.sectionHeader}>
                  <Icon
                    source="map-marker"
                    size={20}
                    color={theme.colors.primary}
                  />
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Direcci√≥n
                  </Text>
                </View>

                <View style={styles.compactRow}>
                  <Icon source="home" size={18} color={theme.colors.primary} />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Direcci√≥n
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.address || 'No especificado'}
                    </Text>
                  </View>
                </View>

                <View style={styles.compactRow}>
                  <Icon source="city" size={18} color={theme.colors.primary} />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Ciudad
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.city || 'No especificado'}
                    </Text>
                  </View>
                </View>

                <View style={styles.compactRow}>
                  <Icon source="map" size={18} color={theme.colors.primary} />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Estado/Provincia
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.state || 'No especificado'}
                    </Text>
                  </View>
                </View>

                <View style={styles.compactRow}>
                  <Icon source="earth" size={18} color={theme.colors.primary} />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Pa√≠s
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.country || 'No especificado'}
                    </Text>
                  </View>
                </View>

                <View style={styles.compactRow}>
                  <Icon
                    source="mailbox"
                    size={18}
                    color={theme.colors.primary}
                  />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      C√≥digo Postal
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.zipCode || 'No especificado'}
                    </Text>
                  </View>
                </View>
              </View>

              {/* Emergency Contact */}
              <View style={styles.infoSection}>
                <View style={styles.sectionHeader}>
                  <Icon
                    source="alert-circle"
                    size={20}
                    color={theme.colors.error}
                  />
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Contacto de Emergencia
                  </Text>
                </View>

                <View style={styles.compactRow}>
                  <Icon
                    source="account-alert"
                    size={18}
                    color={theme.colors.primary}
                  />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Nombre
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.emergencyContact?.name || 'No especificado'}
                    </Text>
                  </View>
                </View>

                <View style={styles.compactRow}>
                  <Icon
                    source="phone-alert"
                    size={18}
                    color={theme.colors.primary}
                  />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Tel√©fono
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.emergencyContact?.phone || 'No especificado'}
                    </Text>
                  </View>
                </View>

                <View style={styles.compactRow}>
                  <Icon
                    source="account-multiple"
                    size={18}
                    color={theme.colors.primary}
                  />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Relaci√≥n
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.emergencyContact?.relationship || 'No especificado'}
                    </Text>
                  </View>
                </View>
              </View>

              {/* Actions */}
              <View style={styles.actionsContainer}>
                <Button
                  mode="contained-tonal"
                  onPress={() => onEdit(user)}
                  icon="pencil"
                  style={styles.actionButton}
                  contentStyle={styles.buttonContent}
                  labelStyle={styles.buttonLabel}
                  compact
                >
                  Editar Usuario
                </Button>

                <Button
                  mode="contained-tonal"
                  onPress={() => setShowPasswordDialog(true)}
                  icon="lock-reset"
                  style={styles.actionButton}
                  contentStyle={styles.buttonContent}
                  labelStyle={styles.buttonLabel}
                  buttonColor={theme.colors.secondaryContainer}
                  compact
                >
                  Cambiar Contrase√±a
                </Button>

                <Button
                  mode="outlined"
                  onPress={() => setShowDeleteDialog(true)}
                  icon="delete"
                  style={[styles.actionButton, styles.deleteButton]}
                  contentStyle={styles.buttonContent}
                  labelStyle={styles.buttonLabel}
                  textColor={theme.colors.error}
                  compact
                >
                  Eliminar Usuario
                </Button>
              </View>
            </ScrollView>
          </Surface>
        </Modal>
      </Portal>

      {/* Password Reset Dialog */}
      <Portal>
        <Dialog
          visible={showPasswordDialog}
          onDismiss={() => {
            setShowPasswordDialog(false);
            setNewPassword('');
            setConfirmPassword('');
            setShowPassword(false);
          }}
          style={styles.passwordDialog}
        >
          <View
            style={[
              styles.passwordDialogContainer,
              { borderColor: theme.colors.primary },
            ]}
          >
            <View style={styles.passwordDialogHeader}>
              <Icon
                source="lock-reset"
                size={40}
                color={theme.colors.primary}
              />
              <Dialog.Title style={styles.passwordDialogTitle}>
                Cambiar Contrase√±a
              </Dialog.Title>
              <View style={styles.passwordDialogUserInfo}>
                <Text
                  variant="bodyMedium"
                  style={styles.passwordDialogUserName}
                >
                  {`${user.firstName || ''} ${user.lastName || ''}`.trim() ||
                    user.username}
                </Text>
                <Text
                  variant="bodySmall"
                  style={styles.passwordDialogUserDetail}
                >
                  {user.email}
                </Text>
                <Text
                  variant="labelSmall"
                  style={styles.passwordDialogUserDetail}
                >
                  @{user.username}
                </Text>
              </View>
            </View>

            <Dialog.Content style={styles.passwordDialogContent}>
              <TextInput
                label="Nueva contrase√±a"
                value={newPassword}
                onChangeText={setNewPassword}
                mode="flat"
                secureTextEntry={!showPassword}
                autoCapitalize="none"
                autoCorrect={false}
                autoComplete="new-password"
                style={styles.passwordInput}
                contentStyle={styles.passwordInputContent}
                underlineColor={theme.colors.surfaceVariant}
                activeUnderlineColor={theme.colors.primary}
                right={
                  <TextInput.Icon
                    icon={showPassword ? 'eye-off' : 'eye'}
                    onPress={() => setShowPassword(!showPassword)}
                    size={20}
                    style={styles.passwordInputIcon}
                  />
                }
              />

              <TextInput
                label="Confirmar contrase√±a"
                value={confirmPassword}
                onChangeText={setConfirmPassword}
                mode="flat"
                secureTextEntry={!showPassword}
                autoCapitalize="none"
                autoCorrect={false}
                autoComplete="new-password"
                style={styles.passwordInput}
                contentStyle={styles.passwordInputContent}
                underlineColor={theme.colors.surfaceVariant}
                activeUnderlineColor={theme.colors.primary}
              />

              {(newPassword.length > 0 || confirmPassword.length > 0) && (
                <View style={styles.passwordValidation}>
                  <View style={styles.validationItem}>
                    <Icon
                      source={
                        newPassword.length >= 6
                          ? 'check-circle'
                          : 'circle-outline'
                      }
                      size={16}
                      color={
                        newPassword.length >= 6
                          ? theme.colors.primary
                          : theme.colors.onSurfaceVariant
                      }
                    />
                    <Text
                      variant="bodySmall"
                      style={[
                        styles.validationText,
                        {
                          color:
                            newPassword.length >= 6
                              ? theme.colors.primary
                              : theme.colors.onSurfaceVariant,
                        },
                      ]}
                    >
                      M√≠nimo 6 caracteres
                    </Text>
                  </View>

                  <View style={styles.validationItem}>
                    <Icon
                      source={
                        newPassword === confirmPassword &&
                        newPassword.length > 0
                          ? 'check-circle'
                          : 'circle-outline'
                      }
                      size={16}
                      color={
                        newPassword === confirmPassword &&
                        newPassword.length > 0
                          ? theme.colors.primary
                          : theme.colors.onSurfaceVariant
                      }
                    />
                    <Text
                      variant="bodySmall"
                      style={[
                        styles.validationText,
                        {
                          color:
                            newPassword === confirmPassword &&
                            newPassword.length > 0
                              ? theme.colors.primary
                              : theme.colors.onSurfaceVariant,
                        },
                      ]}
                    >
                      Las contrase√±as coinciden
                    </Text>
                  </View>
                </View>
              )}
            </Dialog.Content>

            <Dialog.Actions style={styles.passwordDialogActions}>
              <Button
                mode="text"
                onPress={() => {
                  setShowPasswordDialog(false);
                  setNewPassword('');
                  setConfirmPassword('');
                  setShowPassword(false);
                }}
                style={[
                  styles.passwordDialogButton,
                  styles.passwordDialogCancelButton,
                ]}
                labelStyle={styles.passwordDialogButtonLabel}
              >
                Cancelar
              </Button>
              <Button
                mode="contained"
                onPress={handleResetPassword}
                loading={resetPasswordMutation.isPending}
                disabled={
                  resetPasswordMutation.isPending ||
                  newPassword.length < 6 ||
                  newPassword !== confirmPassword
                }
                style={[
                  styles.passwordDialogButton,
                  styles.passwordDialogPrimaryButton,
                ]}
                labelStyle={styles.passwordDialogButtonLabel}
              >
                Cambiar
              </Button>
            </Dialog.Actions>
          </View>
        </Dialog>
      </Portal>

      {/* Delete Confirmation Dialog */}
      <Portal>
        <Dialog
          visible={showDeleteDialog}
          onDismiss={() => setShowDeleteDialog(false)}
        >
          <Dialog.Icon icon="alert" color={theme.colors.error} />
          <Dialog.Title style={{ textAlign: 'center' }}>
            Eliminar Usuario
          </Dialog.Title>
          <Dialog.Content>
            <Text variant="bodyMedium" style={{ textAlign: 'center' }}>
              ¬øEst√°s seguro de que deseas eliminar al usuario{' '}
              <Text style={{ fontWeight: 'bold' }}>{user.username}</Text>?
            </Text>
            <Text
              variant="bodySmall"
              style={{
                textAlign: 'center',
                marginTop: theme.spacing.s,
                color: theme.colors.error,
              }}
            >
              Esta acci√≥n no se puede deshacer
            </Text>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setShowDeleteDialog(false)}>Cancelar</Button>
            <Button
              onPress={handleDeleteUser}
              loading={deleteUserMutation.isPending}
              disabled={deleteUserMutation.isPending}
              textColor={theme.colors.error}
            >
              Eliminar
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </>
  );
}

const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    passwordDialog: {
      backgroundColor: 'transparent',
    },
    passwordDialogContainer: {
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness * 4,
      borderWidth: 2,
      overflow: 'hidden',
    },
    passwordDialogHeader: {
      alignItems: 'center',
      paddingTop: theme.spacing.l,
      paddingBottom: theme.spacing.s,
      backgroundColor: theme.colors.elevation.level1,
    },
    passwordDialogTitle: {
      textAlign: 'center',
      fontSize: 20,
      fontWeight: '600',
      marginTop: theme.spacing.s,
      marginBottom: theme.spacing.s,
    },
    passwordDialogUserInfo: {
      alignItems: 'center',
      paddingHorizontal: theme.spacing.l,
      marginBottom: theme.spacing.xs,
    },
    passwordDialogUserName: {
      textAlign: 'center',
      fontWeight: '600',
      color: theme.colors.onSurface,
      marginBottom: theme.spacing.xs,
    },
    passwordDialogUserDetail: {
      textAlign: 'center',
      color: theme.colors.onSurfaceVariant,
      marginBottom: 2,
    },
    passwordDialogContent: {
      paddingTop: theme.spacing.m,
      paddingBottom: theme.spacing.s,
    },
    passwordInput: {
      backgroundColor: 'transparent',
      marginBottom: theme.spacing.m,
    },
    passwordInputContent: {
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: theme.roundness * 2,
      paddingHorizontal: theme.spacing.m,
      paddingRight: theme.spacing.m,
    },
    passwordInputIcon: {
      marginRight: -theme.spacing.xs,
    },
    passwordValidation: {
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: theme.roundness * 2,
      padding: theme.spacing.m,
      gap: theme.spacing.s,
    },
    validationItem: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
    },
    validationText: {
      fontSize: 12,
    },
    passwordDialogActions: {
      justifyContent: 'center',
      paddingBottom: theme.spacing.m,
      paddingHorizontal: theme.spacing.l,
      gap: theme.spacing.s,
    },
    passwordDialogButton: {
      minWidth: 100,
      borderRadius: theme.roundness * 3,
    },
    passwordDialogCancelButton: {
      marginRight: theme.spacing.s,
    },
    passwordDialogPrimaryButton: {
      elevation: 0,
    },
    passwordDialogButtonLabel: {
      fontSize: 14,
      fontWeight: '600',
      letterSpacing: 0.1,
    },
    modalContainer: {
      margin: responsive.isTablet ? theme.spacing.xl : theme.spacing.m,
      maxWidth: responsive.isTablet ? 700 : 420,
      alignSelf: 'center',
      width: responsive.isTablet ? '85%' : '92%',
      paddingHorizontal: 0,
      height: responsive.isTablet ? '80%' : '80%',
      maxHeight: responsive.isTablet ? '85%' : '92%',
      justifyContent: 'center',
    },
    modalContent: {
      borderRadius: theme.roundness * 3,
      backgroundColor: theme.colors.surface,
      height: '100%',
      flex: 1,
      overflow: 'hidden',
      elevation: 5,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
    },
    headerContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingHorizontal: responsive.isTablet
        ? theme.spacing.l
        : theme.spacing.m,
      paddingVertical: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
      borderTopLeftRadius: theme.roundness * 3,
      borderTopRightRadius: theme.roundness * 3,
    },
    headerContent: {
      flex: 1,
      flexDirection: 'column',
      justifyContent: 'center',
    },
    headerNameRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
    },
    modalTitle: {
      fontWeight: '600',
      marginRight: theme.spacing.xs,
      fontSize: responsive.isTablet ? 15 : 16,
    },
    modalSubtitle: {
      marginTop: 2,
      fontSize: responsive.isTablet ? 12 : 14,
    },
    headerRoleChip: {
      minHeight: responsive.isTablet ? 32 : 28,
      height: 'auto',
      borderRadius: theme.roundness * 2,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
      paddingHorizontal: theme.spacing.s,
      paddingVertical: 3,
      alignItems: 'center',
      justifyContent: 'center',
    },
    headerRoleChipText: {
      fontSize: 12,
      fontWeight: '600',
      lineHeight: 16,
      marginVertical: 0,
      paddingVertical: 0,
      includeFontPadding: false,
    },
    contentContainer: {
      flex: 1,
      paddingHorizontal: responsive.isTablet
        ? theme.spacing.l
        : theme.spacing.m,
      paddingTop: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
      paddingBottom: responsive.isTablet ? theme.spacing.l : theme.spacing.m,
    },
    infoSection: {
      borderRadius: theme.roundness * 2,
      padding: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
      marginBottom: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
      backgroundColor: theme.colors.elevation.level1,
      borderWidth: 0,
      elevation: 0,
    },
    sectionHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.isTablet ? theme.spacing.xs : theme.spacing.xs,
      marginBottom: responsive.isTablet ? theme.spacing.s : theme.spacing.xs,
    },
    sectionTitle: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: responsive.isTablet ? 14 : 14,
    },
    listItemTitle: {
      color: theme.colors.onSurface,
      fontWeight: '500',
      fontSize: 14,
    },
    listItemDescription: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 11,
    },
    actionsContainer: {
      gap: responsive.isTablet ? theme.spacing.s : theme.spacing.xs,
      marginBottom: responsive.isTablet ? theme.spacing.l : theme.spacing.m,
      marginTop: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
      paddingHorizontal: 0,
    },
    actionButton: {
      borderRadius: theme.roundness * 2,
      elevation: 0,
      height: responsive.isTablet ? 36 : 40,
    },
    buttonContent: {
      height: responsive.isTablet ? 36 : 40,
      paddingTop: 0,
      paddingBottom: 0,
    },
    buttonLabel: {
      fontSize: responsive.isTablet ? 13 : 14,
      lineHeight: responsive.isTablet ? 18 : 20,
      marginVertical: responsive.isTablet ? 6 : 8,
      includeFontPadding: false,
    },
    deleteButton: {
      borderColor: theme.colors.error,
      marginTop: theme.spacing.xs,
    },
    compactRow: {
      flexDirection: 'row',
      alignItems: 'flex-start',
      gap: responsive.isTablet ? theme.spacing.s : theme.spacing.s,
      paddingVertical: responsive.isTablet ? theme.spacing.s : theme.spacing.xs,
    },
    compactContent: {
      flex: 1,
    },
    compactLabel: {
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 11 : 11,
      lineHeight: responsive.isTablet ? 14 : 14,
    },
    compactValue: {
      color: theme.colors.onSurface,
      fontSize: responsive.isTablet ? 13 : 13,
      fontWeight: '500',
      lineHeight: responsive.isTablet ? 16 : 16,
    },
  });

================
File: app/src/services/appConfig.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';

export interface AppConfig {
  maps: {
    apiKey: string;
  };
}

class AppConfigService {
  private config: AppConfig | null = null;

  async getConfig(): Promise<AppConfig> {
    if (this.config) {
      return this.config;
    }

    try {
      const response = await apiClient.get<AppConfig>(API_PATHS.APP_CONFIG);
      this.config = response.data;
      return this.config;
    } catch (error) {
      const defaultConfig: AppConfig = {
        maps: {
          apiKey: '',
        },
      };
      this.config = defaultConfig;
      return defaultConfig;
    }
  }

  async getMapsApiKey(): Promise<string> {
    const config = await this.getConfig();
    return config.maps.apiKey;
  }

  // Limpiar cach√© si es necesario
  clearCache() {
    this.config = null;
  }
}

export const appConfigService = new AppConfigService();

================
File: app/android/app/src/main/res/xml/network_security_config.xml
================
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <!-- Configuraci√≥n base para producci√≥n - Solo HTTPS por defecto -->
    <base-config cleartextTrafficPermitted="false">
        <trust-anchors>
            <certificates src="system" />
        </trust-anchors>
    </base-config>
    
    <!-- Permitir tr√°fico cleartext SOLO para redes locales (auto-descubrimiento) -->
    <!-- Esto es necesario para el sistema de discovery del servidor -->
    <domain-config cleartextTrafficPermitted="true">
        <!-- Redes privadas IPv4 (RFC 1918) -->
        <domain>10.0.0.0/8</domain>
        <domain>172.16.0.0/12</domain>
        <domain>192.168.0.0/16</domain>
        
        <!-- Localhost y loopback -->
        <domain>localhost</domain>
        <domain>127.0.0.1</domain>
        <domain>10.0.2.2</domain> <!-- Emulador Android -->
        
        <!-- Patr√≥n para IPs locales comunes -->
        <domain includeSubdomains="false">192.168.1.*</domain>
        <domain includeSubdomains="false">192.168.0.*</domain>
        <domain includeSubdomains="false">10.0.0.*</domain>
        <domain includeSubdomains="false">172.16.*.*</domain>
    </domain-config>
    
    <!-- Configuraci√≥n espec√≠fica para tu dominio de producci√≥n -->
    <!-- TODO: Reemplaza "tu-dominio.com" con tu dominio real de producci√≥n -->
    <domain-config>
        <domain includeSubdomains="true">tu-dominio.com</domain>
        <trust-anchors>
            <certificates src="system" />
        </trust-anchors>
        
        <!-- Certificate Pinning (opcional pero recomendado para producci√≥n) -->
        <!-- TODO: Descomentar y actualizar con los hashes SHA-256 de tu certificado
        <pin-set expiration="2026-01-01">
            <pin digest="SHA-256">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=</pin>
            <pin digest="SHA-256">BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB=</pin>
        </pin-set>
        -->
    </domain-config>
    
    <!-- Solo para desarrollo - Se ignora en builds de producci√≥n -->
    <debug-overrides>
        <trust-anchors>
            <!-- Permite certificados del sistema -->
            <certificates src="system" />
            <!-- Permite certificados instalados por el usuario (ej: Charles Proxy) -->
            <certificates src="user" />
        </trust-anchors>
    </debug-overrides>
</network-security-config>

================
File: app/src/app/components/crud/GenericList.tsx
================
import React, { useCallback, useMemo, useState } from 'react';
import { useIsFocused } from '@react-navigation/native';
import {
  StyleSheet,
  RefreshControl,
  ViewStyle,
  StyleProp,
  View,
  TextStyle,
} from 'react-native';
import { FlashList } from '@shopify/flash-list';
import {
  List,
  Chip,
  Text,
  Surface,
  Searchbar,
  FAB,
  Portal,
  Menu,
  IconButton,
  Badge,
} from 'react-native-paper';
import AutoImage from '../common/AutoImage';
import { useAppTheme, AppTheme } from '../../styles/theme';
import { useResponsive } from '../../hooks/useResponsive';
export interface FilterOption<TValue> {
  value: TValue;
  label: string;
  icon?: string;
  disabled?: boolean;
}

interface StatusConfig<TItem> {
  field: keyof TItem;
  activeValue: TItem[keyof TItem];
  activeLabel: string;
  inactiveLabel: string;
}

export interface RenderItemConfig<TItem> {
  titleField: keyof TItem;
  descriptionField?: keyof TItem;
  descriptionFormatter?: (value: any) => string | undefined;
  descriptionMaxLength?: number;
  priceField?: keyof TItem;
  sortOrderField?: keyof TItem;
  imageField?: keyof TItem;
  isDefaultField?: keyof TItem;
  statusConfig?: StatusConfig<TItem>;
  renderTitle?: (item: TItem) => React.ReactNode;
  renderDescription?: (item: TItem) => React.ReactNode;
}

interface GenericListProps<TItem extends { id: string }> {
  items: TItem[];
  renderConfig: RenderItemConfig<TItem>;
  onItemPress: (item: TItem) => void;
  onRefresh: () => void;
  isRefreshing: boolean;
  ListEmptyComponent: React.ComponentType<any> | React.ReactElement | null;
  isLoading?: boolean;
  listItemStyle?: StyleProp<ViewStyle>;
  listItemContentStyle?: StyleProp<ViewStyle>;
  contentContainerStyle?: StyleProp<ViewStyle>;
  imageStyle?: StyleProp<ViewStyle>;
  itemActionsContainerStyle?: StyleProp<ViewStyle>;
  renderItemActions?: (item: TItem) => React.ReactNode;
  renderItem?: ({ item }: { item: TItem }) => React.ReactElement;
  enableSearch?: boolean;
  searchPlaceholder?: string;
  searchQuery?: string;
  onSearchChange?: (query: string) => void;
  enableSort?: boolean;
  filterValue?: string | number;
  onFilterChange?: (value: string | number) => void;
  filterOptions?: FilterOption<string | number>[];
  showFab?: boolean;
  onFabPress?: () => void;
  fabIcon?: string;
  fabLabel?: string;
  fabVisible?: boolean;
  showImagePlaceholder?: boolean;
  placeholderIcon?: string;
  isModalOpen?: boolean;
  isDrawerOpen?: boolean;
  enableGrid?: boolean;
  gridColumns?: number;
  gridColumnsTablet?: number;
  minItemWidth?: number;
  itemSpacing?: number;
}

const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) => {
  const listItemHorizontalMargin = responsive.spacing(theme.spacing.m);
  return StyleSheet.create({
    listContainer: {
      flex: 1,
    },
    searchbarContainer: {
      paddingHorizontal:
        listItemHorizontalMargin - responsive.spacing(theme.spacing.xs),
      paddingTop: responsive.spacing(theme.spacing.xs),
      paddingBottom: responsive.spacing(theme.spacing.s),
      backgroundColor: theme.colors.background,
    },
    searchRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.spacing(theme.spacing.s),
    },
    searchbar: {
      flex: 1,
      backgroundColor: theme.colors.elevation.level2,
    },
    searchbarWithFilter: {
      flex: 1,
    },
    filterButtonContainer: {
      position: 'relative',
    },
    filterIconButton: {
      margin: 0,
      backgroundColor: theme.colors.elevation.level2,
    },
    filterBadge: {
      position: 'absolute',
      top: 4,
      right: 4,
      backgroundColor: theme.colors.primary,
    },
    menuContent: {
      backgroundColor: theme.colors.elevation.level3,
      marginTop: responsive.spacing(theme.spacing.xs),
    },
    listItem: {
      backgroundColor: theme.colors.surface,
      marginVertical: responsive.isTablet
        ? responsive.spacing(3)
        : responsive.spacing(4),
      marginHorizontal: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      borderRadius: theme.roundness * 1.5,
      elevation: 1,
      overflow: 'hidden',
    },
    gridListItem: {
      backgroundColor: theme.colors.surface,
      flex: 1,
      marginHorizontal: responsive.spacing(theme.spacing.xs),
      marginVertical: responsive.spacing(theme.spacing.xs),
      borderRadius: theme.roundness * 2,
      elevation: 2,
      overflow: 'hidden',
    },
    listItemContent: {
      paddingVertical: responsive.isTablet
        ? 4
        : responsive.spacing(theme.spacing.s),
      paddingHorizontal: responsive.spacing(theme.spacing.xs),
      minHeight: responsive.isTablet ? 40 : 56,
      flexWrap: 'wrap',
      alignItems: 'flex-start',
    },
    listItemImage: {
      width: responsive.isTablet ? 36 : 40,
      height: responsive.isTablet ? 36 : 40,
      borderRadius: theme.roundness,
      marginLeft: responsive.spacing(theme.spacing.xs),
      marginRight: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
      backgroundColor: theme.colors.surfaceDisabled,
    },
    gridItemImage: {
      width: responsive.scaleWidth(64),
      height: responsive.scaleWidth(64),
      borderRadius: theme.roundness,
      marginLeft: responsive.spacing(theme.spacing.s),
      marginRight: responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surfaceDisabled,
    },
    statusChip: {
      borderRadius: theme.roundness * 1.5,
      height: responsive.isTablet ? 32 : 28,
      alignSelf: 'center',
      paddingHorizontal: responsive.spacing(theme.spacing.s),
    },
    title: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: responsive.isTablet ? 15 : 14,
      lineHeight: responsive.isTablet ? 20 : 18,
    },
    description: {
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 13 : 12,
      lineHeight: responsive.isTablet ? 18 : 16,
    },
    emptyListContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.spacing(theme.spacing.l),
    },
    defaultContentContainer: {
      paddingBottom: 80,
      paddingTop: responsive.spacing(theme.spacing.xs),
    },
    itemActionsContainer: {
      justifyContent: 'center',
      alignItems: 'center',
      paddingLeft: responsive.spacing(theme.spacing.xs),
    },
    filtersOuterContainer: {
      paddingTop: responsive.spacing(theme.spacing.s),
      paddingBottom: responsive.spacing(theme.spacing.xs),
      paddingHorizontal: responsive.spacing(theme.spacing.xs),
      backgroundColor: theme.colors.background,
    },
    segmentedButtons: {
      backgroundColor: 'transparent',
      borderRadius: theme.roundness,
      minHeight: 40,
    },
    filterButton: {
      borderWidth: 0,
      paddingVertical: responsive.spacing(theme.spacing.xs),
    },
    filterButtonLabel: {
      fontSize: 15,
      letterSpacing: 0.15,
      paddingVertical: responsive.spacing(theme.spacing.xs),
    },
    fab: {
      position: 'absolute',
      margin: 16,
      right: 0,
      bottom: 0,
    },
  });
};

const GenericList = <TItem extends { id: string }>({
  items,
  renderConfig,
  onItemPress,
  onRefresh,
  isRefreshing,
  ListEmptyComponent,
  listItemStyle,
  listItemContentStyle,
  contentContainerStyle,
  imageStyle,
  renderItemActions,
  itemActionsContainerStyle,
  enableSearch = false,
  searchPlaceholder = 'Buscar...',
  enableSort = false,
  filterValue,
  onFilterChange,
  filterOptions,
  searchQuery: externalSearchQuery,
  onSearchChange,
  showFab = false,
  onFabPress,
  fabIcon = 'plus',
  fabLabel,
  fabVisible = true,
  showImagePlaceholder = true,
  placeholderIcon = 'image-outline',
  isModalOpen = false,
  isDrawerOpen = false,
  renderItem,
  enableGrid = false,
  gridColumns = 1,
  gridColumnsTablet,
  minItemWidth,
  itemSpacing,
}: GenericListProps<TItem>) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = useMemo(
    () => getStyles(theme, responsive),
    [theme, responsive],
  );
  const [internalSearchTerm, setInternalSearchTerm] = useState('');
  const [filterMenuVisible, setFilterMenuVisible] = useState(false);
  const isSearchControlled =
    externalSearchQuery !== undefined && onSearchChange !== undefined;
  const currentSearchTerm = isSearchControlled
    ? externalSearchQuery
    : internalSearchTerm;
  const isFocused = useIsFocused();

  const processedItems = useMemo(() => {
    let processed = [...items];

    if (enableSort && renderConfig.titleField) {
      processed.sort((a, b) => {
        const titleA = String(a[renderConfig.titleField] ?? '').toLowerCase();
        const titleB = String(b[renderConfig.titleField] ?? '').toLowerCase();
        return titleA.localeCompare(titleB);
      });
    }

    if (enableSearch && !isSearchControlled && currentSearchTerm.trim()) {
      const lowerCaseSearchTerm = currentSearchTerm.toLowerCase();
      processed = processed.filter((item) => {
        const title = String(item[renderConfig.titleField] ?? '').toLowerCase();
        if (title.includes(lowerCaseSearchTerm)) {
          return true;
        }
        if (renderConfig.descriptionField) {
          const description = String(
            item[renderConfig.descriptionField] ?? '',
          ).toLowerCase();
          if (description.includes(lowerCaseSearchTerm)) {
            return true;
          }
        }
        return false;
      });
    }

    return processed;
  }, [
    items,
    enableSort,
    enableSearch,
    isSearchControlled,
    currentSearchTerm,
    renderConfig,
  ]);

  const numColumns = useMemo(() => {
    if (!enableGrid) return 1;

    if (minItemWidth) {
      const gap = itemSpacing || responsive.spacing(theme.spacing.m);
      const padding = responsive.spacing(theme.spacing.m);
      return responsive.getGridColumns(minItemWidth, gap, padding);
    }

    if (responsive.isTablet && gridColumnsTablet) {
      return gridColumnsTablet;
    }

    return gridColumns;
  }, [
    enableGrid,
    minItemWidth,
    itemSpacing,
    responsive,
    gridColumns,
    gridColumnsTablet,
  ]);

  const renderGenericItem = useCallback(
    ({ item }: { item: TItem }) => {
      const title = String(item[renderConfig.titleField] ?? '');

      let description = '';
      if (
        renderConfig.descriptionField &&
        item.hasOwnProperty(renderConfig.descriptionField)
      ) {
        const fieldValue = item[renderConfig.descriptionField];
        if (renderConfig.descriptionFormatter) {
          const formattedDescription =
            renderConfig.descriptionFormatter(fieldValue);
          if (formattedDescription) {
            description = formattedDescription;
          }
        } else {
          const rawDescription = String(fieldValue || '');
          if (rawDescription && rawDescription.toLowerCase() !== 'null') {
            description = rawDescription;
          }
        }
      }

      let sortOrderString: string | null = null;
      if (
        renderConfig.sortOrderField &&
        item.hasOwnProperty(renderConfig.sortOrderField)
      ) {
        const sortOrderValue = item[renderConfig.sortOrderField];
        if (sortOrderValue !== null && sortOrderValue !== undefined) {
          sortOrderString = `Posicion: ${String(sortOrderValue)}`;
        }
      }

      let priceString: string | null = null;
      if (
        renderConfig.priceField &&
        item.hasOwnProperty(renderConfig.priceField)
      ) {
        const priceValue = item[renderConfig.priceField];
        if (priceValue !== null && priceValue !== undefined) {
          const numericPrice = Number(priceValue);
          if (!isNaN(numericPrice)) {
            priceString = `$${numericPrice.toFixed(2)}`;
          } else if (
            typeof priceValue === 'string' &&
            priceValue.trim() !== ''
          ) {
            priceString = String(priceValue);
          }
        }
      }

      let imageSource: string | undefined = undefined;
      if (
        renderConfig.imageField &&
        item.hasOwnProperty(renderConfig.imageField)
      ) {
        const imageFieldValue = item[renderConfig.imageField];
        if (
          typeof imageFieldValue === 'object' &&
          imageFieldValue !== null &&
          'path' in imageFieldValue &&
          typeof imageFieldValue.path === 'string'
        ) {
          imageSource = imageFieldValue.path;
        } else if (typeof imageFieldValue === 'string') {
          imageSource = imageFieldValue;
        }
      }

      let statusChip = null;
      if (
        renderConfig.statusConfig &&
        item.hasOwnProperty(renderConfig.statusConfig.field)
      ) {
        const { field, activeValue, activeLabel, inactiveLabel } =
          renderConfig.statusConfig;
        const isActive = item[field] === activeValue;
        const chipLabel = isActive ? activeLabel : inactiveLabel;

        statusChip = (props: {
          color: string;
          style?: StyleProp<TextStyle>;
        }) => (
          <Chip
            {...props}
            mode="flat"
            selectedColor={
              isActive ? theme.colors.success : theme.colors.onSurfaceVariant
            }
            style={[
              styles.statusChip,
              {
                backgroundColor: isActive
                  ? theme.colors.successContainer
                  : theme.colors.surfaceVariant,
              },
            ]}
            textStyle={{
              fontSize: responsive.isTablet ? 12 : 11,
              marginVertical: 0,
            }}
            compact
          >
            {chipLabel}
          </Chip>
        );
      }

      const isGrid = enableGrid && numColumns > 1;

      return (
        <Surface
          style={[
            isGrid ? styles.gridListItem : styles.listItem,
            listItemStyle,
          ]}
          elevation={1}
        >
          <List.Item
            title={() =>
              renderConfig.renderTitle ? (
                renderConfig.renderTitle(item)
              ) : (
                <Text variant="bodyLarge" style={styles.title}>
                  {title}
                </Text>
              )
            }
            description={() => {
              if (renderConfig.renderDescription) {
                return renderConfig.renderDescription(item);
              }

              const parts = [];

              if (
                renderConfig.isDefaultField &&
                item.hasOwnProperty(renderConfig.isDefaultField) &&
                item[renderConfig.isDefaultField] === true
              ) {
                parts.push('‚úì Por defecto');
              }

              if (sortOrderString) {
                parts.push(sortOrderString);
              }

              if (description) {
                parts.push(description);
              }

              if (priceString) {
                parts.push(priceString);
              }

              const combinedText = parts.join(' - ');

              if (combinedText.trim()) {
                return (
                  <Text variant="bodySmall" style={styles.description}>
                    {combinedText}
                  </Text>
                );
              }
              return null;
            }}
            left={() => {
              if (imageSource || showImagePlaceholder) {
                return (
                  <AutoImage
                    source={imageSource}
                    placeholderIcon={placeholderIcon}
                    style={[
                      isGrid ? styles.gridItemImage : styles.listItemImage,
                      imageStyle,
                    ]}
                    contentFit="cover"
                    transition={300}
                  />
                );
              } else {
                return null;
              }
            }}
            right={() => (
              <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                {statusChip && statusChip({ color: theme.colors.onSurface })}
                {renderItemActions && (
                  <View
                    style={[
                      styles.itemActionsContainer,
                      itemActionsContainerStyle,
                    ]}
                  >
                    {renderItemActions(item)}
                  </View>
                )}
              </View>
            )}
            onPress={() => onItemPress(item)}
            style={[styles.listItemContent, listItemContentStyle]}
          />
        </Surface>
      );
    },
    [
      theme,
      renderConfig,
      onItemPress,
      styles,
      listItemStyle,
      listItemContentStyle,
      imageStyle,
      renderItemActions,
      itemActionsContainerStyle,
      enableGrid,
      numColumns,
      showImagePlaceholder,
      placeholderIcon,
      responsive,
    ],
  );

  const finalContentContainerStyle = useMemo(() => {
    return StyleSheet.flatten([
      styles.defaultContentContainer,
      contentContainerStyle,
    ]);
  }, [styles.defaultContentContainer, contentContainerStyle]);

  const hasActiveFilter = filterValue !== 'all' && filterValue !== undefined;

  return (
    <View style={styles.listContainer}>
      {(enableSearch ||
        (filterOptions && filterValue !== undefined && onFilterChange)) && (
        <View style={styles.searchbarContainer}>
          <View style={styles.searchRow}>
            {enableSearch && (
              <Searchbar
                placeholder={searchPlaceholder}
                onChangeText={
                  isSearchControlled ? onSearchChange : setInternalSearchTerm
                }
                value={currentSearchTerm}
                style={[
                  styles.searchbar,
                  filterOptions ? styles.searchbarWithFilter : {},
                ]}
                inputStyle={{
                  color: theme.colors.onSurface,
                  fontSize: 14,
                  minHeight: 40,
                }}
                placeholderTextColor={theme.colors.onSurfaceVariant}
                iconColor={theme.colors.onSurfaceVariant}
                clearIcon={
                  currentSearchTerm
                    ? () => <List.Icon icon="close-circle" />
                    : undefined
                }
                onClearIconPress={() =>
                  isSearchControlled
                    ? onSearchChange('')
                    : setInternalSearchTerm('')
                }
              />
            )}
            {filterOptions && filterValue !== undefined && onFilterChange && (
              <View style={styles.filterButtonContainer}>
                <Menu
                  visible={filterMenuVisible}
                  onDismiss={() => setFilterMenuVisible(false)}
                  anchor={
                    <IconButton
                      icon={hasActiveFilter ? 'filter-check' : 'filter-variant'}
                      mode="contained-tonal"
                      size={24}
                      onPress={() => setFilterMenuVisible(true)}
                      style={styles.filterIconButton}
                      iconColor={
                        hasActiveFilter
                          ? theme.colors.primary
                          : theme.colors.onSurfaceVariant
                      }
                    />
                  }
                  anchorPosition="bottom"
                  contentStyle={styles.menuContent}
                >
                  {filterOptions.map((option) => (
                    <Menu.Item
                      key={String(option.value)}
                      onPress={() => {
                        onFilterChange(option.value);
                        setFilterMenuVisible(false);
                      }}
                      title={option.label}
                      leadingIcon={option.icon}
                      trailingIcon={
                        filterValue === option.value ? 'check' : undefined
                      }
                      disabled={option.disabled}
                      titleStyle={
                        filterValue === option.value
                          ? { color: theme.colors.primary, fontWeight: '600' }
                          : undefined
                      }
                    />
                  ))}
                </Menu>
                {hasActiveFilter && (
                  <Badge style={styles.filterBadge} size={8} />
                )}
              </View>
            )}
          </View>
        </View>
      )}

      <FlashList
        data={processedItems}
        renderItem={renderItem || renderGenericItem}
        keyExtractor={(item) => item.id}
        estimatedItemSize={enableGrid && numColumns > 1 ? 150 : 80}
        numColumns={numColumns}
        contentContainerStyle={finalContentContainerStyle}
        ListEmptyComponent={
          processedItems.length === 0 ? ListEmptyComponent || null : null
        }
        ItemSeparatorComponent={
          enableGrid && numColumns > 1
            ? () => (
                <View
                  style={{
                    height: itemSpacing || responsive.spacing(theme.spacing.m),
                  }}
                />
              )
            : undefined
        }
        refreshControl={
          <RefreshControl
            refreshing={isRefreshing}
            onRefresh={() => {
              if (isSearchControlled) {
                onSearchChange('');
              } else {
                setInternalSearchTerm('');
              }
              onRefresh();
            }}
            colors={[theme.colors.primary]}
            tintColor={theme.colors.primary}
          />
        }
        keyboardShouldPersistTaps="handled"
      />
      {showFab && onFabPress && (
        <Portal>
          <FAB
            icon={fabIcon}
            style={styles.fab}
            onPress={onFabPress}
            visible={
              isFocused &&
              showFab &&
              fabVisible &&
              !isModalOpen &&
              !isDrawerOpen
            }
            label={fabLabel}
            color={theme.colors.onPrimary}
            theme={{ colors: { primaryContainer: theme.colors.primary } }}
          />
        </Portal>
      )}
    </View>
  );
};

export default GenericList;

================
File: app/src/app/navigation/AppNavigator.tsx
================
import React, { useEffect } from 'react';
import {
  NavigationContainer,
  Theme as NavigationTheme,
} from '@react-navigation/native';
import { useAuthStore } from '../store/authStore';
import { AuthStack } from './AuthStack';
import { ConditionalAppNavigator } from './ConditionalAppNavigator';
import { useAppTheme } from '../styles/theme';
import { initImageCache } from '../lib/imageCache';
import { reconnectionSnackbarService } from '@/services/reconnectionSnackbarService';
import { serverConnectionService } from '@/services/serverConnectionService';

export function AppNavigator() {
  const isAuthenticated = useAuthStore((state) => state.isAuthenticated);
  const paperTheme = useAppTheme();

  // Inicializar servicios una sola vez al montar la app
  useEffect(() => {
    initImageCache();

    // El servicio se inicializa autom√°ticamente en su constructor
    // No necesita llamada expl√≠cita a initialize()

    return () => {
      // Limpiar cuando se desmonte toda la app
      serverConnectionService.destroy();
    };
  }, []); // Sin dependencias para que solo se ejecute una vez

  // Manejar servicios de notificaci√≥n basados en autenticaci√≥n
  useEffect(() => {
    if (isAuthenticated) {
      reconnectionSnackbarService.start();
    } else {
      reconnectionSnackbarService.stop();
    }

    return () => {
      reconnectionSnackbarService.stop();
    };
  }, [isAuthenticated]);

  const navigationTheme: NavigationTheme = {
    dark: paperTheme.dark,
    colors: {
      primary: paperTheme.colors.primary,
      background: paperTheme.colors.background,
      card: paperTheme.colors.surface,
      text: paperTheme.colors.onBackground,
      border: paperTheme.colors.outline,
      notification: paperTheme.colors.error,
    },
    fonts: {
      regular: {
        ...paperTheme.fonts.bodyMedium,
        fontWeight: paperTheme.fonts.bodyMedium.fontWeight ?? 'normal',
      },
      medium: {
        ...paperTheme.fonts.titleMedium,
        fontWeight: paperTheme.fonts.titleMedium.fontWeight ?? 'normal',
      },
      bold: {
        ...paperTheme.fonts.titleLarge,
        fontWeight: paperTheme.fonts.titleLarge.fontWeight ?? 'bold',
      },
      heavy: {
        ...paperTheme.fonts.titleLarge,
        fontWeight: paperTheme.fonts.titleLarge.fontWeight ?? '900',
      },
    },
  };

  return (
    <NavigationContainer theme={navigationTheme}>
      {isAuthenticated ? <ConditionalAppNavigator /> : <AuthStack />}
    </NavigationContainer>
  );
}

================
File: app/src/app/navigation/KitchenOnlyNavigator.tsx
================
import React, { useEffect } from 'react';
import {
  BackHandler,
  TouchableOpacity,
  StatusBar,
  StyleSheet,
  View,
  Text,
  Platform,
} from 'react-native';
import { createDrawerNavigator } from '@react-navigation/drawer';
import KitchenNavigator from '../../modules/kitchen/navigation/KitchenNavigator';
import { CustomDrawerContent } from './components/CustomDrawerContent';
import { ServerSettingsScreen } from '../../modules/settings/screens/ServerSettingsScreen';
import { useAppTheme } from '../styles/theme';
import { Icon, Surface, Checkbox } from 'react-native-paper';
import { useResponsive } from '../hooks/useResponsive';
import { ConnectionIndicator } from '../components/ConnectionIndicator';
import { KitchenFilterButton } from '../../modules/kitchen/components/KitchenFilterButton';
import { RefreshButton } from '../../modules/kitchen/components/RefreshButton';
import { useAuthStore } from '../store/authStore';
import { useKitchenStore } from '../../modules/kitchen/store/kitchenStore';
import { OrderType } from '../../modules/kitchen/types/kitchen.types';
import { KitchenProvider } from '../../modules/kitchen/context/KitchenContext';

const Drawer = createDrawerNavigator();

function KitchenOnlyNavigatorContent() {
  const theme = useAppTheme();
  const user = useAuthStore((state) => state.user);
  const { filters, setFilters } = useKitchenStore();
  const screenName = user?.preparationScreen?.name || 'Pantalla de Preparaci√≥n';

  // Obtener el texto del filtro activo
  const getFilterText = () => {
    switch (filters.orderType) {
      case OrderType.DINE_IN:
        return ' ‚Ä¢ Mesa';
      case OrderType.TAKE_AWAY:
        return ' ‚Ä¢ Llevar';
      case OrderType.DELIVERY:
        return ' ‚Ä¢ Domicilio';
      default:
        return '';
    }
  };

  // Prevenir navegaci√≥n hacia atr√°s en Android (no aplicar en web)
  useEffect(() => {
    if (Platform.OS !== 'web') {
      const backHandler = BackHandler.addEventListener(
        'hardwareBackPress',
        () => {
          // Retornar true previene el comportamiento por defecto
          return true;
        },
      );

      return () => backHandler.remove();
    }
  }, []);

  const responsive = useResponsive();

  const styles = React.useMemo(
    () =>
      StyleSheet.create({
        drawerButtonContainer: {
          width: 56,
          height: 56,
          justifyContent: 'center',
          alignItems: 'center',
          marginLeft: 0,
          borderRadius: 28,
        },
        headerStyle: {
          backgroundColor: theme.colors.primary,
          height: responsive.isWeb ? 80 : responsive.dimensions.headerHeight,
          elevation: 2,
        },
        headerTitleStyle: {
          ...theme.fonts.titleLarge,
          color: theme.colors.onPrimary,
          fontWeight: 'bold',
          fontSize: responsive.isWeb ? 26 : responsive.isTablet ? 20 : 22,
        },
        drawerStyle: {
          backgroundColor: theme.colors.surface,
          width: responsive.isWeb ? 320 : responsive.dimensions.drawerWidth,
          borderTopRightRadius: responsive.isWeb ? 0 : theme.roundness * 2,
          borderBottomRightRadius: responsive.isWeb ? 0 : theme.roundness * 2,
          borderRightWidth: 0,
          borderRightColor: theme.colors.outlineVariant,
          elevation: 2,
          shadowColor: '#000',
          shadowOffset: { width: 0, height: 0 },
          shadowOpacity: 0,
          shadowRadius: 0,
        },
        titleContainer: {
          flexDirection: 'row',
          alignItems: 'center',
        },
        filterIndicator: {
          ...theme.fonts.titleMedium,
          fontWeight: '500',
          opacity: 0.9,
        },
      }),
    [theme, responsive],
  );

  return (
    <>
      <StatusBar
        backgroundColor={theme.colors.primary}
        barStyle={theme.dark ? 'light-content' : 'dark-content'}
      />
      <Drawer.Navigator
        initialRouteName="Kitchen"
        drawerContent={(props) => <CustomDrawerContent {...props} />}
        defaultStatus="closed"
        screenOptions={({ navigation }) => ({
          headerStyle: styles.headerStyle,
          headerTintColor: theme.colors.onPrimary,
          headerTitleStyle: styles.headerTitleStyle,
          drawerStyle: styles.drawerStyle,
          drawerActiveTintColor: theme.colors.primary,
          drawerInactiveTintColor: theme.colors.onSurfaceVariant,
          drawerLabelStyle: {
            ...theme.fonts.labelLarge,
            fontSize: responsive.fontSize.m,
          },
          drawerItemStyle: {
            marginVertical: responsive.spacing.xxs,
            borderRadius: theme.roundness * 2,
            paddingVertical: responsive.spacing.xxs,
            paddingHorizontal: responsive.spacing.xs,
          },
          headerShown: true,
          drawerType: 'slide',
          drawerPosition: 'left',
          headerShadowVisible: false,
          swipeEdgeWidth: 0,
          swipeEnabled: false,
          drawerHideStatusBarOnOpen: false,
          headerLeft: () => (
            <TouchableOpacity
              style={styles.drawerButtonContainer}
              onPress={() => navigation.openDrawer()}
              hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
            >
              <Icon
                source="menu"
                size={responsive.isWeb ? 36 : 32}
                color={theme.colors.onPrimary}
              />
            </TouchableOpacity>
          ),
          headerTitle: () => (
            <Surface
              elevation={0}
              style={{
                backgroundColor: 'transparent',
              }}
            >
              <View style={styles.titleContainer}>
                <Text style={styles.headerTitleStyle}>{screenName}</Text>
                {filters.orderType && (
                  <Text
                    style={[
                      styles.filterIndicator,
                      { color: theme.colors.onPrimary },
                    ]}
                  >
                    {getFilterText()}
                  </Text>
                )}
              </View>
            </Surface>
          ),
          headerRight: () => (
            <View style={{ flexDirection: 'row', alignItems: 'center' }}>
              {/* Checkbox para mostrar/ocultar ordenes listas */}
              <TouchableOpacity
                style={{
                  flexDirection: 'row',
                  alignItems: 'center',
                  paddingHorizontal: 12,
                  paddingVertical: 8,
                  marginRight: 8,
                  backgroundColor: filters.showPrepared
                    ? 'rgba(255,255,255,0.2)'
                    : 'transparent',
                  borderRadius: 20,
                }}
                onPress={() =>
                  setFilters({
                    ...filters,
                    showPrepared: !filters.showPrepared,
                  })
                }
              >
                <Checkbox
                  status={filters.showPrepared ? 'checked' : 'unchecked'}
                  onPress={() =>
                    setFilters({
                      ...filters,
                      showPrepared: !filters.showPrepared,
                    })
                  }
                  color={theme.colors.onPrimary}
                  uncheckedColor={theme.colors.onPrimary}
                />
                <Text
                  style={{
                    color: theme.colors.onPrimary,
                    fontSize: responsive.isWeb ? 16 : 14,
                    marginLeft: 4,
                    fontWeight: filters.showPrepared ? 'bold' : 'normal',
                  }}
                >
                  Mostrar Listas
                </Text>
              </TouchableOpacity>
              <KitchenFilterButton />
              {/* Bot√≥n de recargar */}
              <RefreshButton />
              <ConnectionIndicator />
            </View>
          ),
        })}
      >
        <Drawer.Screen
          name="Kitchen"
          options={{
            title: screenName,
            drawerIcon: ({ color, size }) => (
              <Icon source="chef-hat" color={color} size={size} />
            ),
          }}
        >
          {() => <KitchenNavigator />}
        </Drawer.Screen>

        <Drawer.Screen
          name="ServerSettings"
          component={ServerSettingsScreen}
          options={{
            title: 'Configuraci√≥n del Servidor',
            drawerIcon: ({ color, size }) => (
              <Icon source="server-network" color={color} size={size} />
            ),
            headerShown: true,
            headerStyle: styles.headerStyle,
            headerTintColor: theme.colors.onPrimary,
            headerTitleStyle: styles.headerTitleStyle,
          }}
        />
      </Drawer.Navigator>
    </>
  );
}

export function KitchenOnlyNavigator() {
  // Usar navegador web personalizado en plataforma web
  if (Platform.OS === 'web') {
    const { KitchenWebNavigator } = require('./KitchenWebNavigator');
    return <KitchenWebNavigator />;
  }

  // Usar navegador nativo para otras plataformas
  return (
    <KitchenProvider>
      <KitchenOnlyNavigatorContent />
    </KitchenProvider>
  );
}

================
File: app/src/components/AudioOrderModal.tsx
================
import React, { useState, useEffect, useCallback, useMemo } from 'react';
import {
  View,
  ScrollView,
  StyleSheet,
  ActivityIndicator,
  Dimensions,
  TouchableOpacity,
  Animated,
} from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  Divider,
  Surface,
  IconButton,
} from 'react-native-paper';
import { MaterialIcons } from '@expo/vector-icons';
import { useAppTheme } from '@/app/styles/theme';
import { useGetOrderMenu } from '@/modules/orders/hooks/useMenuQueries';
import type {
  AIOrderItem,
  DeliveryInfoData,
  ScheduledDeliveryData,
} from '@/services/audioOrderService';
import ProductCustomizationModal from '@/modules/orders/components/ProductCustomizationModal';
import type { FullMenuProduct as Product } from '@/modules/orders/types/orders.types';
import type {
  CartItem,
  CartItemModifier,
} from '@/modules/orders/stores/useCartStore';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import type { SelectedPizzaCustomization } from '@/app/schemas/domain/order.schema';
import { Swipeable } from 'react-native-gesture-handler';
import {
  OrderTypeEnum,
  type OrderType,
} from '@/modules/orders/types/orders.types';
import SpeechRecognitionInput from '@/app/components/common/SpeechRecognitionInput';
import { useGetAreas } from '@/modules/areasTables/services/areaService';
import { useGetTablesByArea } from '@/modules/areasTables/services/tableService';
import type { Table } from '@/modules/areasTables/types/areasTables.types';
import AnimatedLabelSelector from '@/app/components/common/AnimatedLabelSelector';
import { Menu, Checkbox, HelperText } from 'react-native-paper';
import type { DeliveryInfo } from '@/app/schemas/domain/delivery-info.schema';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';

interface AudioOrderModalProps {
  visible: boolean;
  onDismiss: () => void;
  onConfirm: (
    items: AIOrderItem[],
    deliveryInfo?: DeliveryInfoData,
    scheduledDelivery?: ScheduledDeliveryData,
    orderType?: OrderType,
  ) => void;
  isProcessing: boolean;
  orderData?: {
    orderItems?: AIOrderItem[];
    deliveryInfo?: DeliveryInfoData;
    scheduledDelivery?: ScheduledDeliveryData;
    orderType?: OrderType;
    warnings?: string;
    processingTime?: number;
  };
  error?: string;
}

const { width: screenWidth, height: screenHeight } = Dimensions.get('window');
const modalWidth = Math.min(screenWidth * 0.95, 500);

export const AudioOrderModal: React.FC<AudioOrderModalProps> = ({
  visible,
  onDismiss,
  onConfirm,
  isProcessing,
  orderData,
  error,
}) => {
  const theme = useAppTheme();
  const { colors } = theme;
  const [editableDeliveryInfo, setEditableDeliveryInfo] =
    useState<DeliveryInfo>({});
  const [editableItems, setEditableItems] = useState<AIOrderItem[]>([]);
  const [editableOrderType, setEditableOrderType] = useState<OrderType>(
    OrderTypeEnum.DINE_IN,
  );
  const [editableSelectedAreaId, setEditableSelectedAreaId] = useState<
    string | null
  >(null);
  const [editableSelectedTableId, setEditableSelectedTableId] = useState<
    string | null
  >(null);
  const [editableIsTemporaryTable, setEditableIsTemporaryTable] =
    useState<boolean>(false);
  const [editableTemporaryTableName, setEditableTemporaryTableName] =
    useState<string>('');
  const [editingItem, setEditingItem] = useState<CartItem | null>(null);
  const [editingProduct, setEditingProduct] = useState<Product | null>(null);
  const [showCustomizationModal, setShowCustomizationModal] = useState(false);

  // Estados para validaci√≥n de productos
  const [itemsWithErrors, setItemsWithErrors] = useState<Set<number>>(
    new Set(),
  );
  const [itemValidationErrors, setItemValidationErrors] = useState<
    Record<number, string[]>
  >({});

  // Estados de error
  const [areaError, setAreaError] = useState<string | null>(null);
  const [tableError, setTableError] = useState<string | null>(null);
  const [recipientNameError, setRecipientNameError] = useState<string | null>(
    null,
  );
  const [recipientPhoneError, setRecipientPhoneError] = useState<string | null>(
    null,
  );
  const [addressError, setAddressError] = useState<string | null>(null);

  // Estado para modal de confirmaci√≥n de salida
  const [showExitConfirmationModal, setShowExitConfirmationModal] =
    useState(false);

  // Estados de men√∫s
  const [areaMenuVisible, setAreaMenuVisible] = useState(false);
  const [tableMenuVisible, setTableMenuVisible] = useState(false);

  const { data: menu } = useGetOrderMenu();

  // Queries para √°reas y mesas
  const {
    data: areasData,
    isLoading: isLoadingAreas,
    error: errorAreas,
  } = useGetAreas();
  const {
    data: tablesData,
    isLoading: isLoadingTables,
    error: errorTables,
  } = useGetTablesByArea(editableSelectedAreaId);
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  // Nombres computed para √°rea y mesa
  const selectedAreaName = useMemo(
    () => areasData?.find((a: any) => a.id === editableSelectedAreaId)?.name,
    [areasData, editableSelectedAreaId],
  );
  const selectedTableName = useMemo(() => {
    return tablesData?.find((t) => t.id === editableSelectedTableId)?.name;
  }, [tablesData, editableSelectedTableId]);

  // Funci√≥n para validar un producto seg√∫n las reglas del ProductCustomizationModal
  const validateProductItem = useCallback(
    (item: AIOrderItem, product?: Product) => {
      if (!menu || !product) return [];

      const errors: string[] = [];

      // 1. Validar variante requerida
      if (
        product.hasVariants &&
        product.variants &&
        product.variants.length > 0
      ) {
        if (!item.variantId) {
          errors.push('Variante requerida');
        }
      }

      // 2. Validar modificadores requeridos
      if (product.modifierGroups && product.modifierGroups.length > 0) {
        for (const group of product.modifierGroups) {
          const selectedModifiersInGroup = (item.modifiers || []).filter(
            (modName) => {
              // Buscar si este modificador pertenece a este grupo
              return group.productModifiers?.some((pm) => pm.name === modName);
            },
          );

          const selectedCount = selectedModifiersInGroup.length;
          const minRequired = Math.max(
            group.minSelections || 0,
            group.isRequired ? 1 : 0,
          );

          if (selectedCount < minRequired) {
            if (group.isRequired && minRequired === 1) {
              errors.push(`${group.name}: Requerido`);
            } else {
              errors.push(`${group.name}: M√≠nimo ${minRequired}`);
            }
          }

          // Validar m√°ximo
          if (group.maxSelections && selectedCount > group.maxSelections) {
            errors.push(`${group.name}: M√°ximo ${group.maxSelections}`);
          }
        }
      }

      // 3. Validar personalizaciones de pizza
      if (
        product.category?.name?.toLowerCase().includes('pizza') &&
        item.pizzaCustomizations
      ) {
        // Las pizzas necesitan al menos una personalizaci√≥n v√°lida
        const validCustomizations = item.pizzaCustomizations.filter(
          (custom) => custom.customizationId && custom.action,
        );

        if (validCustomizations.length === 0) {
          errors.push('Pizza requiere personalizaciones');
        }
      }

      return errors;
    },
    [menu],
  );

  // Funci√≥n para encontrar el producto completo en el men√∫
  const findProductInMenu = useCallback(
    (productId: string): Product | undefined => {
      if (!menu) return undefined;

      for (const category of menu) {
        for (const subcategory of category.subcategories || []) {
          for (const product of subcategory.products || []) {
            if (product.id === productId) {
              return product;
            }
          }
        }
      }
      return undefined;
    },
    [menu],
  );

  // Validar todos los productos cuando cambien
  useEffect(() => {
    if (!editableItems || editableItems.length === 0) {
      setItemsWithErrors(new Set());
      setItemValidationErrors({});
      return;
    }

    const newItemsWithErrors = new Set<number>();
    const newValidationErrors: Record<number, string[]> = {};

    editableItems.forEach((item, index) => {
      const product = findProductInMenu(item.productId);
      const errors = validateProductItem(item, product);

      if (errors.length > 0) {
        newItemsWithErrors.add(index);
        newValidationErrors[index] = errors;
      }
    });

    setItemsWithErrors(newItemsWithErrors);
    setItemValidationErrors(newValidationErrors);
  }, [editableItems, findProductInMenu, validateProductItem]);

  // Funci√≥n para abrir modal de personalizaci√≥n para un producto espec√≠fico
  // Se definir√° despu√©s de handleEditItem para evitar problemas de dependencias

  // Verificar si hay productos con errores que bloqueen el guardado
  const hasValidationErrors = useMemo(() => {
    return itemsWithErrors.size > 0;
  }, [itemsWithErrors]);

  // Verificar si hay datos modificados que se perder√≠an al salir
  const hasUnsavedChanges = useMemo(() => {
    // Si hay productos procesados o datos editados, hay cambios sin guardar
    return (
      editableItems.length > 0 ||
      editableDeliveryInfo.recipientName?.trim() ||
      editableDeliveryInfo.recipientPhone?.trim() ||
      editableDeliveryInfo.fullAddress?.trim() ||
      editableSelectedAreaId ||
      editableSelectedTableId ||
      editableTemporaryTableName?.trim()
    );
  }, [
    editableItems.length,
    editableDeliveryInfo.recipientName,
    editableDeliveryInfo.recipientPhone,
    editableDeliveryInfo.fullAddress,
    editableSelectedAreaId,
    editableSelectedTableId,
    editableTemporaryTableName,
  ]);

  // Sincronizar la informaci√≥n cuando cambie orderData
  useEffect(() => {
    if (orderData?.deliveryInfo) {
      setEditableDeliveryInfo(orderData.deliveryInfo as DeliveryInfo);
    }
    if (orderData?.orderItems) {
      setEditableItems(orderData.orderItems);
    }
    // Si orderType viene del backend, usarlo; si es undefined, usar DELIVERY como defecto
    if (orderData?.orderType !== undefined) {
      setEditableOrderType(orderData.orderType);
    } else if (orderData) {
      // Solo cambiar a DELIVERY si hay datos de la orden pero orderType es undefined
      setEditableOrderType(OrderTypeEnum.DELIVERY);
    }
  }, [orderData?.deliveryInfo, orderData?.orderItems, orderData?.orderType]);

  // Limpiar errores cuando cambie el tipo de orden
  useEffect(() => {
    setAreaError(null);
    setTableError(null);
    setRecipientNameError(null);
    setRecipientPhoneError(null);
    setAddressError(null);
  }, [editableOrderType]);

  const handleConfirm = () => {
    // Resetear errores
    setAreaError(null);
    setTableError(null);
    setRecipientNameError(null);
    setRecipientPhoneError(null);
    setAddressError(null);

    if (editableItems && editableItems.length > 0) {
      // Solo verificar errores de validaci√≥n de productos
      if (hasValidationErrors) {
        showSnackbar({
          message:
            'Hay productos con errores que deben corregirse antes de continuar',
          type: 'error',
        });
        return;
      }

      // Crear deliveryInfo adaptada
      const adaptedDeliveryInfo: DeliveryInfoData = {
        recipientName: editableDeliveryInfo.recipientName,
        recipientPhone: editableDeliveryInfo.recipientPhone,
        fullAddress: editableDeliveryInfo.fullAddress,
      };

      onConfirm(
        editableItems,
        adaptedDeliveryInfo,
        orderData?.scheduledDelivery,
        editableOrderType,
      );
    }
  };

  // Funci√≥n para actualizar la cantidad de un item
  const updateItemQuantity = useCallback(
    (itemId: string, index: number, newQuantity: number) => {
      if (newQuantity < 1) {
        return; // No permitir cantidad menor a 1 con los botones
      }

      setEditableItems((prev) =>
        prev.map((item, i) => {
          if (i === index) {
            return { ...item, quantity: newQuantity };
          }
          return item;
        }),
      );
    },
    [],
  );

  // Funci√≥n para eliminar un item
  const removeItem = useCallback(
    (index: number) => {
      setEditableItems((prev) => prev.filter((_, i) => i !== index));
      showSnackbar({
        message: 'Producto eliminado',
        type: 'info',
      });
    },
    [showSnackbar],
  );

  // Funci√≥n para manejar la edici√≥n de un item
  const handleEditItem = useCallback(
    (item: AIOrderItem, index: number) => {
      if (!menu) {
        showSnackbar({
          message: 'El men√∫ no est√° disponible',
          type: 'error',
        });
        return;
      }

      // Buscar el producto en el men√∫
      let foundProduct: Product | null = null;
      outer: for (const category of menu) {
        for (const subcategory of category.subcategories || []) {
          for (const product of subcategory.products || []) {
            if (product.id === item.productId) {
              foundProduct = product;
              break outer;
            }
          }
        }
      }

      if (!foundProduct) {
        showSnackbar({
          message: 'Producto no encontrado en el men√∫',
          type: 'error',
        });
        return;
      }

      // Convertir AIOrderItem a CartItem para el modal
      const cartItem: CartItem = {
        id: `${item.productId}-${index}`,
        productId: item.productId,
        productName: foundProduct.name,
        quantity: item.quantity,
        unitPrice:
          foundProduct.variants?.find((v) => v.id === item.variantId)?.price ||
          foundProduct.price ||
          0,
        totalPrice: 0, // Se calcular√° en el modal
        modifiers:
          item.modifiers?.map((modName) => {
            // Buscar el modificador en el producto
            for (const modGroup of foundProduct.modifierGroups || []) {
              const modifier = modGroup.productModifiers?.find(
                (m) => m.name === modName,
              );
              if (modifier) {
                return {
                  id: modifier.id,
                  modifierGroupId: modGroup.id,
                  name: modifier.name,
                  price: modifier.price || 0,
                };
              }
            }
            return {
              id: modName,
              modifierGroupId: '',
              name: modName,
              price: 0,
            };
          }) || [],
        variantId: item.variantId,
        variantName: foundProduct.variants?.find((v) => v.id === item.variantId)
          ?.name,
        selectedPizzaCustomizations: item.pizzaCustomizations?.map((pc) => ({
          pizzaCustomizationId: pc.customizationId,
          half: pc.half as any,
          action: pc.action as any,
        })),
      };

      setEditingItem(cartItem);
      setEditingProduct(foundProduct);
      setShowCustomizationModal(true);
    },
    [menu, showSnackbar],
  );

  // Funci√≥n para manejar la actualizaci√≥n desde el modal
  const handleUpdateEditedItem = useCallback(
    (
      itemId: string,
      quantity: number,
      modifiers: CartItemModifier[],
      preparationNotes?: string,
      variantId?: string,
      variantName?: string,
      unitPrice?: number,
      selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    ) => {
      const index = parseInt(itemId.split('-').pop() || '0');

      setEditableItems((prev) =>
        prev.map((item, i) => {
          if (i === index) {
            return {
              ...item,
              quantity,
              variantId,
              modifiers: modifiers.map((m) => m.name),
              pizzaCustomizations: selectedPizzaCustomizations?.map((pc) => ({
                customizationId: pc.pizzaCustomizationId,
                half: pc.half,
                action: pc.action,
              })),
            };
          }
          return item;
        }),
      );

      setShowCustomizationModal(false);
      setEditingItem(null);
      setEditingProduct(null);

      showSnackbar({
        message: 'Producto actualizado',
        type: 'success',
      });
    },
    [showSnackbar],
  );

  // Funciones para manejo de confirmaci√≥n de salida
  const handleAttemptExit = useCallback(() => {
    if (!hasUnsavedChanges) {
      onDismiss();
    } else {
      setShowExitConfirmationModal(true);
    }
  }, [hasUnsavedChanges, onDismiss]);

  const handleConfirmExit = useCallback(() => {
    setShowExitConfirmationModal(false);
    onDismiss();
  }, [onDismiss]);

  const handleCancelExit = useCallback(() => {
    setShowExitConfirmationModal(false);
  }, []);

  // Funci√≥n para obtener el nombre del producto desde el men√∫
  const getProductDetails = (productId: string, variantId?: string) => {
    if (!menu)
      return {
        productName: `Producto ${productId.slice(-4)}`,
        variantName: undefined,
      };

    for (const category of menu) {
      for (const subcategory of category.subcategories || []) {
        for (const product of subcategory.products || []) {
          if (product.id === productId) {
            const variant = variantId
              ? product.variants?.find((v) => v.id === variantId)
              : undefined;
            return {
              productName: product.name,
              variantName: variant?.name,
            };
          }
        }
      }
    }
    return {
      productName: `Producto ${productId.slice(-4)}`,
      variantName: undefined,
    };
  };

  // Funci√≥n para formatear personalizaciones de pizza
  const formatPizzaCustomizations = (customizations?: any[]) => {
    if (!customizations || customizations.length === 0) return '';

    const groupedByHalf = customizations.reduce(
      (acc, curr) => {
        const half = curr.half || 'FULL';
        if (!acc[half]) {
          acc[half] = { ingredients: [] };
        }

        let name = curr.customizationName;
        if (!name && menu) {
          // Buscar el nombre en el men√∫
          outer: for (const category of menu) {
            for (const subcategory of category.subcategories || []) {
              for (const product of subcategory.products || []) {
                if (product.pizzaCustomizations) {
                  const customization = product.pizzaCustomizations.find(
                    (pc) => pc.id === curr.customizationId,
                  );
                  if (customization) {
                    name = customization.name;
                    break outer;
                  }
                }
              }
            }
          }
        }

        if (!name) {
          name = curr.customizationId.slice(-4);
        }

        const prefix = curr.action === 'ADD' ? '+ ' : '- ';
        acc[half].ingredients.push(prefix + name);

        return acc;
      },
      {} as Record<string, { ingredients: string[] }>,
    );

    if (groupedByHalf.FULL) {
      return groupedByHalf.FULL.ingredients.join(', ');
    } else if (groupedByHalf.HALF_1 || groupedByHalf.HALF_2) {
      const half1 = groupedByHalf.HALF_1
        ? `Mitad 1: ${groupedByHalf.HALF_1.ingredients.join(', ')}`
        : '';
      const half2 = groupedByHalf.HALF_2
        ? `Mitad 2: ${groupedByHalf.HALF_2.ingredients.join(', ')}`
        : '';
      return [half1, half2].filter(Boolean).join(' / ');
    }

    return '';
  };

  const renderProcessingState = () => (
    <View style={styles.processingContainer}>
      <View style={styles.processingContent}>
        <MaterialIcons
          name="mic"
          size={80}
          color={colors.primary}
          style={styles.processingIcon}
        />
        <ActivityIndicator
          size="large"
          color={colors.primary}
          style={styles.processingSpinner}
        />
        <Text style={[styles.processingTitle, { color: colors.onSurface }]}>
          Analizando tu solicitud
        </Text>
        <Text
          style={[styles.processingSubtext, { color: colors.onSurfaceVariant }]}
        >
          Extrayendo productos y detalles de tu pedido por voz...
        </Text>
        <View style={styles.processingSteps}>
          <View style={styles.processingStep}>
            <MaterialIcons name="hearing" size={24} color={colors.primary} />
            <Text style={[styles.stepText, { color: colors.onSurfaceVariant }]}>
              Transcribiendo audio
            </Text>
          </View>
          <View style={styles.processingStep}>
            <MaterialIcons name="psychology" size={24} color={colors.primary} />
            <Text style={[styles.stepText, { color: colors.onSurfaceVariant }]}>
              Analizando productos
            </Text>
          </View>
          <View style={styles.processingStep}>
            <MaterialIcons name="list-alt" size={24} color={colors.primary} />
            <Text style={[styles.stepText, { color: colors.onSurfaceVariant }]}>
              Generando orden
            </Text>
          </View>
        </View>
        <Text
          style={[styles.processingFooter, { color: colors.onSurfaceVariant }]}
        >
          ‚è±Ô∏è Esto puede tomar unos segundos
        </Text>
      </View>
    </View>
  );

  const renderErrorState = () => (
    <View style={styles.errorContainer}>
      <View style={styles.errorContent}>
        <MaterialIcons name="error-outline" size={80} color={colors.error} />
        <Text style={[styles.errorTitle, { color: colors.error }]}>
          No se pudo procesar tu solicitud
        </Text>
        <Text style={[styles.errorMessage, { color: colors.onSurfaceVariant }]}>
          {error}
        </Text>
        <View style={styles.errorActions}>
          <Button
            mode="outlined"
            onPress={onDismiss}
            style={styles.errorButton}
            icon="refresh"
          >
            Intentar de nuevo
          </Button>
          <Button
            mode="contained"
            onPress={handleAttemptExit}
            style={styles.errorButton}
            icon="close"
          >
            Cerrar
          </Button>
        </View>
        <Text style={[styles.errorFooter, { color: colors.onSurfaceVariant }]}>
          üí° Aseg√∫rate de hablar claramente y mencionar los productos que deseas
        </Text>
      </View>
    </View>
  );

  const renderOrderSummary = () => {
    if (!orderData) return null;

    const { scheduledDelivery, warnings } = orderData;

    return (
      <ScrollView
        style={styles.scrollView}
        showsVerticalScrollIndicator={false}
      >
        {/* Header con tiempo de procesamiento - REMOVIDO */}

        {/* Tipo de Orden - Always visible at top */}
        <View style={styles.orderTypeSection}>
          <View style={styles.compactSectionHeader}>
            <MaterialIcons name="restaurant" size={20} color={colors.primary} />
            <Text
              style={[styles.compactSectionTitle, { color: colors.onSurface }]}
            >
              Tipo de Orden
            </Text>
          </View>

          <View style={styles.orderTypeButtons}>
            <TouchableOpacity
              style={[
                styles.orderTypeButton,
                editableOrderType === OrderTypeEnum.DINE_IN &&
                  styles.orderTypeButtonActive,
                {
                  backgroundColor:
                    editableOrderType === OrderTypeEnum.DINE_IN
                      ? colors.primaryContainer
                      : colors.surface,
                },
              ]}
              onPress={() => setEditableOrderType(OrderTypeEnum.DINE_IN)}
            >
              <MaterialIcons
                name="restaurant"
                size={16}
                color={
                  editableOrderType === OrderTypeEnum.DINE_IN
                    ? colors.primary
                    : colors.onSurfaceVariant
                }
              />
              <Text
                style={[
                  styles.orderTypeButtonText,
                  {
                    color:
                      editableOrderType === OrderTypeEnum.DINE_IN
                        ? colors.primary
                        : colors.onSurfaceVariant,
                  },
                ]}
              >
                Comer aqu√≠
              </Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[
                styles.orderTypeButton,
                editableOrderType === OrderTypeEnum.TAKE_AWAY &&
                  styles.orderTypeButtonActive,
                {
                  backgroundColor:
                    editableOrderType === OrderTypeEnum.TAKE_AWAY
                      ? colors.primaryContainer
                      : colors.surface,
                },
              ]}
              onPress={() => setEditableOrderType(OrderTypeEnum.TAKE_AWAY)}
            >
              <MaterialIcons
                name="shopping-bag"
                size={16}
                color={
                  editableOrderType === OrderTypeEnum.TAKE_AWAY
                    ? colors.primary
                    : colors.onSurfaceVariant
                }
              />
              <Text
                style={[
                  styles.orderTypeButtonText,
                  {
                    color:
                      editableOrderType === OrderTypeEnum.TAKE_AWAY
                        ? colors.primary
                        : colors.onSurfaceVariant,
                  },
                ]}
              >
                Para llevar
              </Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[
                styles.orderTypeButton,
                editableOrderType === OrderTypeEnum.DELIVERY &&
                  styles.orderTypeButtonActive,
                {
                  backgroundColor:
                    editableOrderType === OrderTypeEnum.DELIVERY
                      ? colors.primaryContainer
                      : colors.surface,
                },
              ]}
              onPress={() => setEditableOrderType(OrderTypeEnum.DELIVERY)}
            >
              <MaterialIcons
                name="moped"
                size={16}
                color={
                  editableOrderType === OrderTypeEnum.DELIVERY
                    ? colors.primary
                    : colors.onSurfaceVariant
                }
              />
              <Text
                style={[
                  styles.orderTypeButtonText,
                  {
                    color:
                      editableOrderType === OrderTypeEnum.DELIVERY
                        ? colors.primary
                        : colors.onSurfaceVariant,
                  },
                ]}
              >
                Domicilio
              </Text>
            </TouchableOpacity>
          </View>
        </View>

        {/* Renderizado condicional seg√∫n tipo de orden - EXACTAMENTE como OrderCartDetail */}
        {editableOrderType === OrderTypeEnum.DINE_IN && (
          <View style={styles.compactSectionContainer}>
            <View style={styles.compactSectionHeader}>
              <MaterialIcons
                name="restaurant"
                size={20}
                color={colors.primary}
              />
              <Text
                style={[
                  styles.compactSectionTitle,
                  { color: colors.onSurface },
                ]}
              >
                Mesa y √Årea
              </Text>
            </View>

            <View style={styles.compactDeliveryContainer}>
              {/* √Årea y Mesa en la misma fila */}
              <View style={styles.dineInSelectorsRow}>
                {/* √Årea */}
                <View style={styles.dineInSelectorContainer}>
                  <Menu
                    visible={areaMenuVisible}
                    onDismiss={() => setAreaMenuVisible(false)}
                    anchor={
                      <AnimatedLabelSelector
                        label="√Årea *"
                        value={selectedAreaName}
                        onPress={() => setAreaMenuVisible(true)}
                        isLoading={isLoadingAreas}
                        error={!!areaError || !!errorAreas}
                        disabled={isLoadingAreas}
                      />
                    }
                  >
                    {areasData?.map((area: any) => (
                      <Menu.Item
                        key={area.id}
                        onPress={() => {
                          setEditableSelectedAreaId(area.id);
                          setEditableSelectedTableId(null);
                          setAreaMenuVisible(false);
                          setAreaError(null);
                        }}
                        title={area.name}
                      />
                    ))}
                    {errorAreas && (
                      <Menu.Item title="Error al cargar √°reas" disabled />
                    )}
                  </Menu>
                  {areaError && !errorAreas && (
                    <HelperText
                      type="error"
                      visible={true}
                      style={styles.helperTextFix}
                    >
                      {areaError}
                    </HelperText>
                  )}
                  {errorAreas && (
                    <HelperText
                      type="error"
                      visible={true}
                      style={styles.helperTextFix}
                    >
                      Error al cargar √°reas
                    </HelperText>
                  )}
                </View>

                {/* Mesa */}
                <View style={styles.dineInSelectorContainer}>
                  <Menu
                    visible={tableMenuVisible}
                    onDismiss={() => setTableMenuVisible(false)}
                    anchor={
                      <AnimatedLabelSelector
                        label="Mesa *"
                        value={selectedTableName}
                        onPress={() => setTableMenuVisible(true)}
                        isLoading={isLoadingTables}
                        error={!!tableError || !!errorTables}
                        disabled={
                          !editableSelectedAreaId ||
                          isLoadingTables ||
                          isLoadingAreas ||
                          editableIsTemporaryTable
                        }
                      />
                    }
                  >
                    {tablesData?.map((table: Table) => (
                      <Menu.Item
                        key={table.id}
                        onPress={() => {
                          if (table.isAvailable) {
                            setEditableSelectedTableId(table.id);
                            setTableMenuVisible(false);
                            setTableError(null);
                          }
                        }}
                        title={`${table.name}${!table.isAvailable ? ' (Ocupada)' : ''}`}
                        disabled={!table.isAvailable}
                        titleStyle={
                          !table.isAvailable
                            ? { color: colors.error }
                            : undefined
                        }
                      />
                    ))}
                    {editableSelectedAreaId &&
                      tablesData?.length === 0 &&
                      !isLoadingTables &&
                      !errorTables && (
                        <Menu.Item title="No hay mesas" disabled />
                      )}
                    {errorTables && (
                      <Menu.Item title="Error al cargar mesas" disabled />
                    )}
                  </Menu>
                  {tableError && !errorTables && !editableIsTemporaryTable && (
                    <HelperText
                      type="error"
                      visible={true}
                      style={styles.helperTextFix}
                    >
                      {tableError}
                    </HelperText>
                  )}
                  {errorTables && (
                    <HelperText
                      type="error"
                      visible={true}
                      style={styles.helperTextFix}
                    >
                      Error al cargar mesas
                    </HelperText>
                  )}
                </View>
              </View>

              {/* Opci√≥n de mesa temporal */}
              <TouchableOpacity
                onPress={() => {
                  setEditableIsTemporaryTable(!editableIsTemporaryTable);
                  if (!editableIsTemporaryTable) {
                    setEditableSelectedTableId(null);
                    setTableError(null);
                  } else {
                    setEditableTemporaryTableName('');
                  }
                }}
                style={styles.checkboxContainer}
              >
                <Checkbox.Android
                  status={editableIsTemporaryTable ? 'checked' : 'unchecked'}
                  onPress={() => {
                    setEditableIsTemporaryTable(!editableIsTemporaryTable);
                    if (!editableIsTemporaryTable) {
                      setEditableSelectedTableId(null);
                      setTableError(null);
                    } else {
                      setEditableTemporaryTableName('');
                    }
                  }}
                  color={colors.primary}
                />
                <Text style={styles.checkboxLabel}>Crear mesa temporal</Text>
              </TouchableOpacity>

              {/* Campo para nombre de mesa temporal */}
              {editableIsTemporaryTable && (
                <View style={styles.temporaryTableInputContainer}>
                  <SpeechRecognitionInput
                    label="Nombre de la Mesa Temporal *"
                    value={editableTemporaryTableName}
                    onChangeText={(text) => {
                      setEditableTemporaryTableName(text);
                      if (tableError) setTableError(null);
                    }}
                    error={!!tableError && editableIsTemporaryTable}
                    speechLang="es-MX"
                    autoCapitalize="words"
                    autoCorrect={false}
                    placeholder="Ej: Mesa Terraza 1"
                    style={styles.compactTextInput}
                    dense
                  />
                  {tableError && editableIsTemporaryTable && (
                    <HelperText
                      type="error"
                      visible={true}
                      style={styles.helperTextFix}
                    >
                      {tableError}
                    </HelperText>
                  )}
                </View>
              )}
            </View>
          </View>
        )}

        {/* Para llevar - Solo nombre del cliente */}
        {editableOrderType === OrderTypeEnum.TAKE_AWAY && (
          <View style={styles.compactSectionContainer}>
            <View style={styles.compactSectionHeader}>
              <MaterialIcons name="person" size={20} color={colors.primary} />
              <Text
                style={[
                  styles.compactSectionTitle,
                  { color: colors.onSurface },
                ]}
              >
                Informaci√≥n del Cliente
              </Text>
            </View>

            <View style={styles.compactDeliveryContainer}>
              <SpeechRecognitionInput
                label="Nombre del Cliente *"
                value={editableDeliveryInfo.recipientName || ''}
                onChangeText={(text) => {
                  setEditableDeliveryInfo((prev) => ({
                    ...prev,
                    recipientName: text,
                  }));
                  if (recipientNameError) setRecipientNameError(null);
                }}
                error={!!recipientNameError}
                speechLang="es-MX"
                autoCapitalize="words"
                autoCorrect={false}
                style={styles.compactTextInput}
                dense
              />
              {recipientNameError && (
                <HelperText
                  type="error"
                  visible={true}
                  style={styles.helperTextFix}
                >
                  {recipientNameError}
                </HelperText>
              )}

              <SpeechRecognitionInput
                label="Tel√©fono (Opcional)"
                value={editableDeliveryInfo.recipientPhone || ''}
                onChangeText={(text) => {
                  setEditableDeliveryInfo((prev) => ({
                    ...prev,
                    recipientPhone: text,
                  }));
                  if (recipientPhoneError) setRecipientPhoneError(null);
                }}
                error={!!recipientPhoneError}
                speechLang="es-MX"
                keyboardType="phone-pad"
                style={styles.compactTextInput}
                dense
              />
              {recipientPhoneError && (
                <HelperText
                  type="error"
                  visible={true}
                  style={styles.helperTextFix}
                >
                  {recipientPhoneError}
                </HelperText>
              )}
            </View>
          </View>
        )}

        {/* Domicilio - Solo direcci√≥n y tel√©fono */}
        {editableOrderType === OrderTypeEnum.DELIVERY && (
          <View style={styles.compactSectionContainer}>
            <View style={styles.compactSectionHeader}>
              <MaterialIcons
                name="local-shipping"
                size={20}
                color={colors.primary}
              />
              <Text
                style={[
                  styles.compactSectionTitle,
                  { color: colors.onSurface },
                ]}
              >
                Informaci√≥n de Entrega
              </Text>
            </View>

            <View style={styles.compactDeliveryContainer}>
              <SpeechRecognitionInput
                label="Direcci√≥n completa *"
                value={editableDeliveryInfo.fullAddress || ''}
                onChangeText={(text) => {
                  setEditableDeliveryInfo((prev) => ({
                    ...prev,
                    fullAddress: text,
                  }));
                  if (addressError) setAddressError(null);
                }}
                error={!!addressError}
                speechLang="es-MX"
                multiline
                numberOfLines={2}
                style={styles.compactTextInput}
                dense
              />
              {addressError && (
                <HelperText
                  type="error"
                  visible={true}
                  style={styles.helperTextFix}
                >
                  {addressError}
                </HelperText>
              )}

              <SpeechRecognitionInput
                label="Tel√©fono *"
                value={editableDeliveryInfo.recipientPhone || ''}
                onChangeText={(text) => {
                  setEditableDeliveryInfo((prev) => ({
                    ...prev,
                    recipientPhone: text,
                  }));
                  if (recipientPhoneError) setRecipientPhoneError(null);
                }}
                error={!!recipientPhoneError}
                speechLang="es-MX"
                keyboardType="phone-pad"
                style={styles.compactTextInput}
                dense
              />
              {recipientPhoneError && (
                <HelperText
                  type="error"
                  visible={true}
                  style={styles.helperTextFix}
                >
                  {recipientPhoneError}
                </HelperText>
              )}
            </View>
          </View>
        )}

        {/* Advertencias */}
        {warnings && (
          <Surface
            style={[
              styles.warningContainer,
              { backgroundColor: colors.tertiaryContainer },
            ]}
          >
            <MaterialIcons name="warning" size={20} color={colors.tertiary} />
            <Text
              style={[
                styles.warningText,
                { color: colors.onTertiaryContainer },
              ]}
            >
              {warnings}
            </Text>
          </Surface>
        )}

        {/* Items de la orden - Versi√≥n compacta */}
        <View
          style={[
            styles.compactSectionContainer,
            { borderTopWidth: 1, borderTopColor: colors.primary + '40' },
          ]}
        >
          <View style={styles.compactSectionHeader}>
            <MaterialIcons
              name="restaurant-menu"
              size={20}
              color={colors.primary}
            />
            <Text
              style={[styles.compactSectionTitle, { color: colors.onSurface }]}
            >
              Productos ({editableItems.length})
            </Text>
          </View>

          {editableItems.length === 0 ? (
            <View style={styles.emptyContainerCompact}>
              <MaterialIcons
                name="mic-off"
                size={32}
                color={colors.onSurfaceVariant}
              />
              <Text
                style={[
                  styles.emptyTextCompact,
                  { color: colors.onSurfaceVariant },
                ]}
              >
                No se detectaron productos
              </Text>
            </View>
          ) : (
            <View style={styles.compactItemsList}>
              {editableItems.map((item, index) => {
                const itemKey = `${item.productId}-${index}`;
                const { productName, variantName } = getProductDetails(
                  item.productId,
                  item.variantId,
                );
                const pizzaCustomizationsText = formatPizzaCustomizations(
                  item.pizzaCustomizations,
                );

                // Funci√≥n para renderizar acciones de deslizar
                const renderRightActions = (_progress: any, dragX: any) => {
                  const translateX = dragX.interpolate({
                    inputRange: [-100, 0],
                    outputRange: [0, 100],
                    extrapolate: 'clamp',
                  });

                  const scale = dragX.interpolate({
                    inputRange: [-100, -50, 0],
                    outputRange: [1, 0.8, 0.5],
                    extrapolate: 'clamp',
                  });

                  const opacity = dragX.interpolate({
                    inputRange: [-100, -20, 0],
                    outputRange: [1, 0.5, 0],
                    extrapolate: 'clamp',
                  });

                  return (
                    <Animated.View
                      style={[
                        styles.deleteActionContainer,
                        {
                          opacity,
                          transform: [{ translateX }],
                        },
                      ]}
                    >
                      <Animated.View
                        style={[
                          styles.deleteAction,
                          {
                            backgroundColor: colors.error,
                            transform: [{ scale }],
                          },
                        ]}
                      >
                        <View style={styles.deleteIconContainer}>
                          <IconButton
                            icon="delete-sweep"
                            size={28}
                            iconColor="white"
                            style={styles.deleteIcon}
                          />
                        </View>
                        <Text style={styles.deleteActionText}>ELIMINAR</Text>
                      </Animated.View>
                    </Animated.View>
                  );
                };

                return (
                  <View key={itemKey}>
                    <Swipeable
                      renderRightActions={renderRightActions}
                      overshootRight={false}
                      friction={2}
                      rightThreshold={90}
                      leftThreshold={100}
                      onSwipeableOpen={(direction) => {
                        if (direction === 'right') {
                          setTimeout(() => {
                            removeItem(index);
                          }, 150);
                        }
                      }}
                    >
                      <TouchableOpacity
                        onPress={() => handleEditItem(item, index)}
                        activeOpacity={0.7}
                        style={[
                          styles.compactItemContainer,
                          itemsWithErrors.has(index) && {
                            borderWidth: 1,
                            borderColor: colors.error,
                            backgroundColor: colors.errorContainer + '20',
                          },
                        ]}
                      >
                        <View style={styles.compactItemContent}>
                          <View style={styles.compactItemLeft}>
                            <Text
                              style={[
                                styles.compactItemTitle,
                                { color: colors.onSurface },
                              ]}
                            >
                              {`${item.quantity}x ${variantName || productName}`}
                            </Text>

                            {/* Mostrar errores de validaci√≥n */}
                            {itemValidationErrors[index] && (
                              <View style={styles.validationErrorsContainer}>
                                {itemValidationErrors[index].map(
                                  (error, errorIdx) => (
                                    <Text
                                      key={errorIdx}
                                      style={[
                                        styles.validationErrorText,
                                        { color: colors.error },
                                      ]}
                                    >
                                      ‚ö†Ô∏è {error}
                                    </Text>
                                  ),
                                )}
                              </View>
                            )}

                            {/* Renderizar personalizaciones de pizza */}
                            {pizzaCustomizationsText && (
                              <Text
                                style={[
                                  styles.compactItemSubtitle,
                                  { color: colors.onSurfaceVariant },
                                ]}
                              >
                                {pizzaCustomizationsText}
                              </Text>
                            )}

                            {/* Renderizar modificadores */}
                            {item.modifiers &&
                              item.modifiers.length > 0 &&
                              item.modifiers.map((mod, idx) => (
                                <Text
                                  key={idx}
                                  style={[
                                    styles.compactItemSubtitle,
                                    { color: colors.onSurfaceVariant },
                                  ]}
                                >
                                  ‚Ä¢ {mod}
                                </Text>
                              ))}
                          </View>

                          <View style={styles.compactItemRight}>
                            <View style={styles.compactQuantityActions}>
                              <IconButton
                                icon="minus-circle-outline"
                                size={18}
                                onPress={() =>
                                  updateItemQuantity(
                                    item.productId,
                                    index,
                                    item.quantity - 1,
                                  )
                                }
                                style={styles.compactQuantityButton}
                                disabled={item.quantity <= 1}
                              />
                              <Text
                                style={[
                                  styles.compactQuantityText,
                                  { color: colors.onSurface },
                                ]}
                              >
                                {item.quantity}
                              </Text>
                              <IconButton
                                icon="plus-circle-outline"
                                size={18}
                                onPress={() =>
                                  updateItemQuantity(
                                    item.productId,
                                    index,
                                    item.quantity + 1,
                                  )
                                }
                                style={styles.compactQuantityButton}
                              />
                            </View>
                            <IconButton
                              icon="pencil"
                              size={16}
                              onPress={() => handleEditItem(item, index)}
                              style={styles.compactEditButton}
                            />
                          </View>
                        </View>
                      </TouchableOpacity>
                    </Swipeable>

                    {index < editableItems.length - 1 && (
                      <Divider style={styles.compactItemDivider} />
                    )}
                  </View>
                );
              })}
            </View>
          )}
        </View>

        {/* Hora programada - Versi√≥n compacta */}
        {scheduledDelivery?.time && (
          <View style={styles.compactSectionContainer}>
            <View style={styles.compactSectionHeader}>
              <MaterialIcons name="schedule" size={20} color={colors.primary} />
              <Text
                style={[
                  styles.compactSectionTitle,
                  { color: colors.onSurface },
                ]}
              >
                Entrega Programada
              </Text>
            </View>
            <Text
              style={[styles.compactScheduledTime, { color: colors.onSurface }]}
            >
              {scheduledDelivery.time}
            </Text>
          </View>
        )}
      </ScrollView>
    );
  };

  return (
    <>
      {visible && (
        <Portal>
          <Modal
            visible={visible}
            onDismiss={onDismiss}
            contentContainerStyle={[
              styles.modalContainer,
              {
                width: modalWidth,
                backgroundColor: colors.surface,
                maxHeight: screenHeight * 0.9,
                height: screenHeight * 0.85,
                // Borde grueso y muy visible
                borderWidth: 6,
                borderColor: colors.primary,
                // Sombra pronunciada con color primario
                shadowColor: colors.primary,
                shadowOffset: { width: 0, height: 6 },
                shadowOpacity: 0.6,
                shadowRadius: 16,
                // Para Android - elevaci√≥n alta
                elevation: 20,
              },
            ]}
          >
            {/* Header din√°mico seg√∫n el estado */}
            <View style={styles.header}>
              <Text style={[styles.title, { color: colors.onSurface }]}>
                {isProcessing && 'üé§ Procesando orden por voz...'}
                {error && '‚ö†Ô∏è Error en el procesamiento'}
                {!isProcessing &&
                  !error &&
                  hasValidationErrors &&
                  '‚ö†Ô∏è Revisa los productos'}
                {!isProcessing &&
                  !error &&
                  !hasValidationErrors &&
                  'Agregar a tu orden üõí'}
              </Text>
              <IconButton
                icon="close"
                size={24}
                onPress={handleAttemptExit}
                style={styles.closeButton}
              />
            </View>

            {/* Divider solo cuando no est√° procesando ni hay error */}
            {!isProcessing && !error && (
              <Divider style={{ backgroundColor: colors.outlineVariant }} />
            )}

            {isProcessing && renderProcessingState()}
            {error && renderErrorState()}
            {!isProcessing && !error && orderData && renderOrderSummary()}

            {!isProcessing && !error && orderData && (
              <>
                <Divider style={{ backgroundColor: colors.outlineVariant }} />
                <View style={styles.footer}>
                  {editableItems && editableItems.length > 0 ? (
                    <>
                      <Button
                        mode="outlined"
                        onPress={handleAttemptExit}
                        style={styles.footerButton}
                      >
                        Cancelar
                      </Button>
                      <Button
                        mode="contained"
                        onPress={handleConfirm}
                        style={[
                          styles.footerButton,
                          hasValidationErrors && {
                            backgroundColor: colors.error,
                          },
                        ]}
                        icon={hasValidationErrors ? 'alert-circle' : 'plus'}
                        buttonColor={
                          hasValidationErrors ? colors.error : undefined
                        }
                      >
                        {hasValidationErrors ? 'Hay errores' : 'Agregar'}
                      </Button>
                    </>
                  ) : (
                    <Button
                      mode="contained"
                      onPress={handleAttemptExit}
                      style={[styles.footerButton, { flex: 1 }]}
                    >
                      Cerrar
                    </Button>
                  )}
                </View>
              </>
            )}
          </Modal>

          {/* Modal de personalizaci√≥n de producto */}
          {showCustomizationModal && editingProduct && editingItem && (
            <ProductCustomizationModal
              visible={showCustomizationModal}
              product={editingProduct}
              editingItem={editingItem}
              onDismiss={() => {
                setShowCustomizationModal(false);
                setEditingItem(null);
                setEditingProduct(null);
              }}
              onAddToCart={() => {}}
              onUpdateItem={handleUpdateEditedItem}
            />
          )}
        </Portal>
      )}

      {/* Modal de confirmaci√≥n de salida */}
      <ConfirmationModal
        visible={showExitConfirmationModal}
        title="¬øDescartar datos?"
        message="Tienes datos sin guardar. Si sales, se perder√°n los productos y la informaci√≥n que has modificado. ¬øEst√°s seguro?"
        confirmText="Salir y Descartar"
        cancelText="Cancelar"
        onConfirm={handleConfirmExit}
        onCancel={handleCancelExit}
        onDismiss={handleCancelExit}
        confirmButtonColor={colors.error}
      />
    </>
  );
};

const styles = StyleSheet.create({
  modalContainer: {
    borderRadius: 16,
    alignSelf: 'center',
    flex: 1,
    marginVertical: 16,
    marginHorizontal: 12,
    // Sombra base adicional en negro para mayor contraste
    shadowColor: '#000000',
    shadowOffset: {
      width: 0,
      height: 8,
    },
    shadowOpacity: 0.3,
    shadowRadius: 20,
    elevation: 24,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingVertical: 12,
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  closeButton: {
    margin: 0,
  },
  scrollView: {
    flex: 1,
  },
  processingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 32,
    paddingVertical: 40,
  },
  processingContent: {
    alignItems: 'center',
    maxWidth: 400,
    width: '100%',
  },
  processingIcon: {
    marginBottom: 16,
    opacity: 0.8,
  },
  processingSpinner: {
    marginBottom: 24,
  },
  processingTitle: {
    fontSize: 24,
    fontWeight: '700',
    marginBottom: 12,
    textAlign: 'center',
  },
  processingSubtext: {
    fontSize: 16,
    marginBottom: 32,
    textAlign: 'center',
    lineHeight: 22,
  },
  processingSteps: {
    width: '100%',
    marginBottom: 32,
    gap: 16,
  },
  processingStep: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
    paddingHorizontal: 16,
  },
  stepText: {
    fontSize: 14,
    flex: 1,
  },
  processingFooter: {
    fontSize: 14,
    textAlign: 'center',
    fontStyle: 'italic',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 32,
    paddingVertical: 40,
  },
  errorContent: {
    alignItems: 'center',
    maxWidth: 400,
    width: '100%',
  },
  errorTitle: {
    fontSize: 24,
    fontWeight: '700',
    marginTop: 16,
    marginBottom: 12,
    textAlign: 'center',
  },
  errorMessage: {
    fontSize: 16,
    marginBottom: 32,
    textAlign: 'center',
    lineHeight: 22,
  },
  errorActions: {
    flexDirection: 'row',
    gap: 12,
    marginBottom: 24,
    width: '100%',
  },
  errorButton: {
    flex: 1,
  },
  errorFooter: {
    fontSize: 14,
    textAlign: 'center',
    fontStyle: 'italic',
    lineHeight: 20,
  },
  // Estilos de processingTime removidos
  warningContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    margin: 16,
    borderRadius: 8,
    gap: 8,
  },
  warningText: {
    flex: 1,
    fontSize: 14,
  },
  sectionCard: {
    margin: 16,
    marginBottom: 8,
  },
  emptyText: {
    textAlign: 'center',
    paddingVertical: 16,
  },
  itemRightContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  expandedContent: {
    paddingLeft: 16,
    paddingRight: 16,
    paddingBottom: 12,
  },
  sectionLabel: {
    fontSize: 12,
    fontWeight: '600',
    marginBottom: 4,
  },
  modifiersContainer: {
    marginTop: 8,
  },
  modifierText: {
    fontSize: 14,
    marginLeft: 8,
    marginVertical: 2,
  },
  pizzaContainer: {
    marginTop: 8,
  },
  customizationRow: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    marginVertical: 4,
  },
  customizationChip: {
    height: 24,
  },
  halfText: {
    fontSize: 12,
  },
  infoRow: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
    marginVertical: 6,
  },
  infoText: {
    fontSize: 14,
    flex: 1,
  },
  scheduledTime: {
    fontSize: 18,
    fontWeight: '600',
    textAlign: 'center',
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    padding: 16,
    gap: 12,
  },
  footerButton: {
    flex: 1,
  },
  itemTextContainer: {
    flex: 1,
    paddingRight: 8,
  },
  itemTitleText: {
    fontSize: 16,
    fontWeight: '500',
    marginBottom: 4,
  },
  itemDescription: {
    fontSize: 14,
    color: '#666',
    marginTop: 2,
  },
  listItem: {
    paddingVertical: 12,
    paddingHorizontal: 0,
  },
  itemDivider: {
    marginVertical: 8,
  },
  itemActionsContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  quantityBadge: {
    backgroundColor: '#E0E0E0',
    borderRadius: 12,
    paddingHorizontal: 10,
    paddingVertical: 4,
    minWidth: 28,
    alignItems: 'center',
  },
  quantityBadgeText: {
    fontSize: 14,
    fontWeight: '600',
  },
  expandButton: {
    margin: 0,
  },
  deliveryInfoContainer: {
    gap: 12,
  },
  textInput: {
    backgroundColor: 'transparent',
  },
  quantityActions: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 4,
  },
  quantityButton: {
    margin: 0,
  },
  quantityTextContainer: {
    minWidth: 24,
    alignItems: 'center',
    justifyContent: 'center',
  },
  quantityText: {
    fontSize: 14,
    fontWeight: '600',
    textAlign: 'center',
  },
  editButton: {
    margin: 0,
    marginLeft: 8,
  },
  deleteActionContainer: {
    position: 'absolute',
    right: 0,
    top: 0,
    bottom: 0,
    justifyContent: 'center',
    alignItems: 'flex-end',
  },
  deleteAction: {
    borderRadius: 8,
    paddingHorizontal: 20,
    paddingVertical: 8,
    marginRight: 16,
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  deleteIconContainer: {
    justifyContent: 'center',
    alignItems: 'center',
  },
  deleteIcon: {
    margin: 0,
  },
  deleteActionText: {
    color: 'white',
    fontWeight: '600',
    fontSize: 14,
  },
  emptyContainer: {
    alignItems: 'center',
    paddingVertical: 32,
    gap: 16,
  },
  emptyAddButton: {
    marginTop: 8,
  },
  emptySubtext: {
    fontSize: 14,
    marginTop: 4,
  },
  orderTypeContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    paddingVertical: 8,
  },
  orderTypeChip: {
    paddingHorizontal: 16,
  },
  // Nuevos estilos compactos
  compactSectionContainer: {
    margin: 16,
    marginBottom: 8,
  },
  compactSectionHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingBottom: 12,
    gap: 8,
  },
  compactSectionTitle: {
    fontSize: 16,
    fontWeight: '600',
  },
  emptyContainerCompact: {
    alignItems: 'center',
    paddingVertical: 24,
    gap: 12,
  },
  emptyTextCompact: {
    fontSize: 14,
    textAlign: 'center',
  },
  compactItemsList: {
    gap: 2,
  },
  compactItemContainer: {
    paddingVertical: 8,
    paddingHorizontal: 12,
  },
  compactItemContent: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  compactItemLeft: {
    flex: 1,
    paddingRight: 8,
  },
  compactItemTitle: {
    fontSize: 14,
    fontWeight: '500',
    marginBottom: 2,
  },
  compactItemSubtitle: {
    fontSize: 12,
    marginTop: 1,
    lineHeight: 16,
  },
  compactItemRight: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 4,
  },
  compactQuantityActions: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  compactQuantityButton: {
    margin: 0,
    width: 32,
    height: 32,
  },
  compactQuantityText: {
    fontSize: 13,
    fontWeight: '600',
    minWidth: 20,
    textAlign: 'center',
  },
  compactEditButton: {
    margin: 0,
    width: 28,
    height: 28,
    marginLeft: 4,
  },
  compactItemDivider: {
    marginVertical: 4,
    marginHorizontal: 12,
  },
  compactDeliveryContainer: {
    gap: 8,
  },
  compactTextInput: {
    backgroundColor: 'transparent',
  },
  compactScheduledTime: {
    fontSize: 14,
    fontWeight: '600',
    textAlign: 'center',
    paddingVertical: 8,
  },
  compactOrderTypeContainer: {
    alignItems: 'flex-start',
    paddingVertical: 4,
  },
  compactOrderTypeChip: {
    paddingHorizontal: 12,
    height: 28,
  },
  // Estilos para el tipo de orden editable
  orderTypeSection: {
    margin: 16,
    marginBottom: 8,
  },
  orderTypeButtons: {
    flexDirection: 'row',
    gap: 4,
  },
  orderTypeButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 8,
    gap: 6,
    elevation: 1,
  },
  orderTypeButtonActive: {
    elevation: 2,
  },
  orderTypeButtonText: {
    fontSize: 12,
    fontWeight: '500',
  },
  errorText: {
    fontSize: 12,
    marginTop: 4,
    marginLeft: 4,
  },
  compactInputContainer: {
    marginBottom: 8,
  },
  helperTextFix: {
    marginTop: 4,
  },
  checkboxContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginVertical: 8,
  },
  checkboxLabel: {
    marginLeft: 8,
    fontSize: 14,
  },
  temporaryTableInputContainer: {
    marginTop: 8,
  },
  dineInSelectorsRow: {
    flexDirection: 'row',
    gap: 8,
    marginBottom: 8,
  },
  dineInSelectorContainer: {
    flex: 1,
  },
  // Estilos para validaci√≥n de productos
  validationErrorsContainer: {
    marginTop: 4,
    gap: 2,
  },
  validationErrorText: {
    fontSize: 11,
    fontWeight: '500',
  },
});

================
File: app/src/modules/menu/screens/SubcategoriesScreen.tsx
================
import React, { useCallback, useMemo, useEffect, useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { Portal, IconButton } from 'react-native-paper';
import {
  useFocusEffect,
  useRoute,
  RouteProp,
  useNavigation,
} from '@react-navigation/native';
import { useDrawerStatus } from '@react-navigation/drawer';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import GenericList from '../../../app/components/crud/GenericList';
import GenericDetailModal from '../../../app/components/crud/GenericDetailModal';
import GenericFormModal, {
  FormFieldConfig,
  ImagePickerConfig,
} from '../../../app/components/crud/GenericFormModal';
import { FilterOption } from '../../../app/components/crud/GenericList';
import { useCrudScreenLogic } from '../../../app/hooks/useCrudScreenLogic';
import { useListState } from '../../../app/hooks/useListState';

import {
  ImageUploadService,
  FileObject,
} from '../../../app/lib/imageUploadService';
import {
  useFindAllSubcategories,
  useCreateSubcategory,
  useUpdateSubcategory,
  useRemoveSubcategory,
} from '../hooks/useSubcategoriesQueries';
import {
  SubCategory,
  createSubCategoryDtoSchema,
  updateSubCategoryDtoSchema,
  SubCategoryFormInputs,
  UpdateSubCategoryFormInputs,
  findAllSubcategoriesDtoSchema,
} from '../schema/subcategories.schema';
import { z } from 'zod';
import { MenuStackParamList } from '@/modules/menu/navigation/types';

type SubcategoriesScreenRouteProp = RouteProp<
  MenuStackParamList,
  'SubcategoriesScreen'
>;
type SubcategoriesScreenNavigationProp = NativeStackNavigationProp<
  MenuStackParamList,
  'SubcategoriesScreen'
>;

type StatusFilter = 'all' | 'active' | 'inactive';
type FindAllSubcategoriesDto = z.infer<typeof findAllSubcategoriesDtoSchema>;

const SubcategoriesScreen: React.FC = () => {
  const theme = useAppTheme();
  const route = useRoute<SubcategoriesScreenRouteProp>();
  const navigation = useNavigation<SubcategoriesScreenNavigationProp>();
  const { categoryId, categoryName } = route.params;
  const styles = useMemo(() => createStyles(theme), [theme]);
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';

  const [statusFilter, setStatusFilter] = React.useState<StatusFilter>('all');

  // Estado para manejar los valores iniciales del formulario
  const [formInitialValues, setFormInitialValues] = useState<
    SubCategoryFormInputs | UpdateSubCategoryFormInputs
  >({
    name: '',
    description: '',
    isActive: true,
    categoryId: categoryId,
    sortOrder: 0,
    imageUri: null,
  });

  const queryParams = useMemo((): FindAllSubcategoriesDto => {
    let isActive: boolean | undefined;
    if (statusFilter === 'active') isActive = true;
    if (statusFilter === 'inactive') isActive = false;

    const params: FindAllSubcategoriesDto = { categoryId, page: 1, limit: 100 };
    if (isActive !== undefined) {
      params.isActive = isActive;
    }
    return params;
  }, [statusFilter, categoryId]);

  const {
    data: subcategoriesData,
    isLoading: isLoadingList,
    isFetching: isFetchingList,
    refetch: refetchList,
    error: listError,
  } = useFindAllSubcategories(queryParams);

  const createMutation = useCreateSubcategory();
  const updateMutation = useUpdateSubcategory();
  const { mutateAsync: removeSubcategory } = useRemoveSubcategory();

  const {
    isFormModalVisible,
    isDetailModalVisible,
    editingItem,
    selectedItem,
    isDeleting,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
    deleteConfirmation,
  } = useCrudScreenLogic<SubCategory>({
    entityName: 'Subcategor√≠a',
    queryKey: ['subcategories', queryParams],
    deleteMutationFn: removeSubcategory,
  });

  const handleRefresh = useCallback(() => {
    refetchList();
  }, [refetchList]);

  // Efecto para cargar valores iniciales incluyendo la imagen
  useEffect(() => {
    const loadFormData = async () => {
      if (editingItem) {
        let imageUrl = null;
        if (editingItem.photo?.path) {
          try {
            const { getImageUrl } = await import('@/app/lib/imageUtils');
            imageUrl = await getImageUrl(editingItem.photo.path);
          } catch (error) {
            imageUrl = editingItem.photo.path;
          }
        }

        setFormInitialValues({
          name: editingItem.name,
          description: editingItem.description ?? '',
          isActive: editingItem.isActive,
          categoryId: editingItem.categoryId,
          sortOrder: editingItem.sortOrder ?? 0,
          imageUri: imageUrl,
        });
      } else {
        setFormInitialValues({
          name: '',
          description: '',
          isActive: true,
          categoryId: categoryId,
          sortOrder: 0,
          imageUri: null,
        });
      }
    };

    loadFormData();
  }, [editingItem, categoryId]);

  useFocusEffect(
    useCallback(() => {
      refetchList();
    }, [refetchList]),
  );

  const handleFormSubmit = async (
    formData: SubCategoryFormInputs | UpdateSubCategoryFormInputs,
    photoId: string | null | undefined,
  ) => {
    const { imageUri, ...dataToSubmit } = formData;
    const finalData = {
      ...dataToSubmit,
      ...(photoId !== undefined && { photoId }),
    };

    if (finalData.photoId === undefined && !editingItem) {
      delete (finalData as any).photoId;
    }

    try {
      if (editingItem) {
        await updateMutation.mutateAsync({
          id: editingItem.id,
          data: finalData as UpdateSubCategoryFormInputs,
        });
      } else {
        await createMutation.mutateAsync(finalData as SubCategoryFormInputs);
      }
      handleCloseModals();
    } catch (error) {}
  };

  const listRenderConfig = {
    titleField: 'name' as keyof SubCategory,
    descriptionField: 'description' as keyof SubCategory,
    imageField: 'photo' as keyof SubCategory,
    sortOrderField: 'sortOrder' as keyof SubCategory,
    statusConfig: {
      field: 'isActive' as keyof SubCategory,
      activeValue: true,
      activeLabel: 'Activa',
      inactiveLabel: 'Inactiva',
    },
  };

  const formatDate = (value: string | Date) => {
    if (!value) return 'N/A';
    const date = new Date(value);
    return date.toLocaleDateString('es-ES', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  const detailFieldsToDisplay: Array<{
    field: keyof SubCategory;
    label: string;
    render?: (value: any) => string;
  }> = [
    {
      field: 'sortOrder',
      label: 'Orden de visualizaci√≥n',
      render: (value) => value ?? '0',
    },
    {
      field: 'createdAt',
      label: 'Fecha de creaci√≥n',
      render: formatDate,
    },
    {
      field: 'updatedAt',
      label: '√öltima actualizaci√≥n',
      render: formatDate,
    },
  ];

  const filterOptions: FilterOption<StatusFilter>[] = [
    { value: 'all', label: 'Todas' },
    { value: 'active', label: 'Activas' },
    { value: 'inactive', label: 'Inactivas' },
  ];

  const formFields: FormFieldConfig<
    SubCategoryFormInputs | UpdateSubCategoryFormInputs
  >[] = [
    { name: 'name', label: 'Nombre *', type: 'text', required: true },
    {
      name: 'description',
      label: 'Descripci√≥n',
      type: 'textarea',
      numberOfLines: 3,
    },
    {
      name: 'sortOrder',
      label: 'Orden de visualizaci√≥n',
      type: 'number',
      placeholder: '0',
    },
    {
      name: 'isActive',
      label: 'Activo',
      type: 'switch',
      switchLabel: 'Activo',
      defaultValue: true,
    },
  ];

  const imagePickerConfig: ImagePickerConfig<
    SubCategoryFormInputs | UpdateSubCategoryFormInputs
  > = {
    imageUriField: 'imageUri',
    onImageUpload: async (file: FileObject) => {
      const result = await ImageUploadService.uploadImage(file);
      if (result.success && result.photoId) {
        return { id: result.photoId };
      }
      throw new Error(result.error || 'Error desconocido al subir imagen');
    },
    determineFinalPhotoId: ImageUploadService.determinePhotoId,
    imagePickerSize: 150,
    placeholderIcon: 'folder-open-outline',
    placeholderText: 'Imagen de subcategor√≠a',
  };

  const renderSubcategoryActions = (item: SubCategory) => (
    <IconButton
      icon="chevron-right"
      size={28}
      onPress={() =>
        navigation.navigate('Products', {
          subcategoryId: item.id,
          subCategoryName: item.name,
        })
      }
      style={{ margin: 0 }}
    />
  );

  const { ListEmptyComponent } = useListState({
    isLoading: isLoadingList,
    isError: !!listError,
    data: subcategoriesData?.data,
    emptyConfig: {
      title: 'No hay subcategor√≠as',
      message: `No hay subcategor√≠as registradas para ${categoryName}. Presiona el bot√≥n + para crear la primera.`,
      icon: 'folder-outline',
    },
    errorConfig: {
      title: 'Error al cargar subcategor√≠as',
      message: 'No se pudieron cargar las subcategor√≠as. Verifica tu conexi√≥n.',
      icon: 'alert-circle-outline',
      onRetry: refetchList,
    },
  });

  const handleFilterChange = (value: string | number) => {
    if (value === 'all' || value === 'active' || value === 'inactive') {
      setStatusFilter(value);
    } else {
      setStatusFilter('all');
    }
  };

  return (
    <View style={styles.container}>
      <GenericList<SubCategory>
        items={subcategoriesData?.data ?? []}
        enableSort={true}
        enableSearch={true}
        searchPlaceholder="Buscar subcategor√≠as..."
        filterValue={statusFilter}
        onFilterChange={handleFilterChange}
        filterOptions={filterOptions}
        renderConfig={listRenderConfig}
        onItemPress={handleOpenDetailModal}
        onRefresh={handleRefresh}
        isRefreshing={isFetchingList && !isLoadingList}
        ListEmptyComponent={ListEmptyComponent}
        isLoading={isLoadingList}
        contentContainerStyle={styles.listContentContainer}
        renderItemActions={renderSubcategoryActions}
        showFab={true}
        onFabPress={handleOpenCreateModal}
        isModalOpen={isDetailModalVisible || isFormModalVisible}
        showImagePlaceholder={true}
        placeholderIcon="folder-open-outline"
        isDrawerOpen={isDrawerOpen}
      />

      <Portal>
        <GenericDetailModal<SubCategory>
          visible={isDetailModalVisible}
          onDismiss={handleCloseModals}
          item={selectedItem}
          titleField="name"
          imageField="photo"
          descriptionField="description"
          statusConfig={listRenderConfig.statusConfig}
          fieldsToDisplay={detailFieldsToDisplay}
          onEdit={() => {
            if (selectedItem) {
              handleOpenEditModal(selectedItem);
            }
          }}
          deleteConfirmation={deleteConfirmation}
          isDeleting={isDeleting}
          showImage={true}
        />

        <GenericFormModal<
          SubCategoryFormInputs | UpdateSubCategoryFormInputs,
          SubCategory
        >
          visible={isFormModalVisible}
          onDismiss={handleCloseModals}
          onSubmit={handleFormSubmit}
          formSchema={
            editingItem
              ? updateSubCategoryDtoSchema
              : createSubCategoryDtoSchema
          }
          formFields={formFields}
          imagePickerConfig={imagePickerConfig}
          initialValues={formInitialValues}
          editingItem={editingItem}
          isSubmitting={createMutation.isPending || updateMutation.isPending}
          modalTitle={(editing) =>
            editing ? 'Editar Subcategor√≠a' : 'Crear Subcategor√≠a'
          }
        />
      </Portal>
    </View>
  );
};

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    listContentContainer: {
      paddingBottom: 80,
    },
  });

export default SubcategoriesScreen;

================
File: app/src/modules/orders/components/OrderDetailModal.tsx
================
import React, { useMemo } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  IconButton,
  Divider,
  Card,
  Chip,
  Surface,
} from 'react-native-paper';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import { useAppTheme } from '@/app/styles/theme';
import { OrderStatusEnum } from '../types/orders.types';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';

interface OrderDetailModalProps {
  visible: boolean;
  onDismiss: () => void;
  orderId: string | null;
  orderNumber?: number;
  orderData?: any; // Datos de la orden pasados como prop
}

const getStatusColor = (status: string, theme: any) => {
  switch (status) {
    case OrderStatusEnum.PENDING:
      return '#FFA000';
    case OrderStatusEnum.IN_PROGRESS:
      return theme.colors.primary;
    case OrderStatusEnum.IN_PREPARATION:
      return '#FF6B35';
    case OrderStatusEnum.READY:
      return '#4CAF50';
    case OrderStatusEnum.DELIVERED:
      return theme.colors.tertiary;
    case OrderStatusEnum.COMPLETED:
      return '#9E9E9E';
    case OrderStatusEnum.CANCELLED:
      return theme.colors.error;
    default:
      return theme.colors.onSurfaceVariant;
  }
};

const getStatusLabel = (status: string) => {
  const statusMap: Record<string, string> = {
    [OrderStatusEnum.PENDING]: 'Pendiente',
    [OrderStatusEnum.IN_PROGRESS]: 'En Progreso',
    [OrderStatusEnum.IN_PREPARATION]: 'En Preparaci√≥n',
    [OrderStatusEnum.READY]: 'Lista',
    [OrderStatusEnum.DELIVERED]: 'Entregada',
    [OrderStatusEnum.COMPLETED]: 'Completada',
    [OrderStatusEnum.CANCELLED]: 'Cancelada',
  };
  return statusMap[status] || status;
};

const getPreparationStatusLabel = (status: string) => {
  const statusMap: Record<string, string> = {
    PENDING: 'Pendiente',
    IN_PROGRESS: 'En Preparaci√≥n',
    READY: 'Listo',
    DELIVERED: 'Entregado',
    CANCELLED: 'Cancelado',
  };
  return statusMap[status] || status;
};

const getPreparationStatusColor = (status: string, theme: any) => {
  switch (status) {
    case 'PENDING':
      return theme.colors.error;
    case 'IN_PROGRESS':
      return '#FFA000';
    case 'READY':
      return '#4CAF50';
    case 'DELIVERED':
      return theme.colors.tertiary;
    case 'CANCELLED':
      return theme.colors.onSurfaceDisabled;
    default:
      return theme.colors.onSurfaceVariant;
  }
};

// Componente interno para mostrar el contenido de detalles
export const OrderDetailContent: React.FC<{
  orderId: string | null;
  orderNumber?: number;
  orderData?: any; // Datos de la orden pasados como prop
}> = ({ orderId: _orderId, orderNumber: _orderNumber, orderData }) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);

  return (
    <ScrollView style={styles.content} showsVerticalScrollIndicator={false}>
      {!orderData ? (
        <View style={styles.errorContainer}>
          <Icon
            name="alert-circle-outline"
            size={48}
            color={theme.colors.error}
          />
          <Text style={styles.errorText}>
            No hay datos de la orden disponibles
          </Text>
        </View>
      ) : (
        <>
          {/* Informaci√≥n General - Simplificada */}
          <View style={styles.infoHeader}>
            <View style={styles.infoHeaderRow}>
              <Text style={styles.infoHeaderLabel}>Hora de creaci√≥n:</Text>
              <Text style={styles.infoHeaderValue}>
                {format(new Date(orderData.createdAt), 'HH:mm', { locale: es })}
              </Text>
            </View>
          </View>

          {/* Items de la Orden */}
          <Card style={styles.itemsCard}>
            <Card.Content style={styles.cardContentCompact}>
              <Text style={styles.sectionTitle}>
                Art√≠culos ({orderData.orderItems?.length || 0})
              </Text>

              {orderData.orderItems?.map((item: any, index: number) => (
                <View key={item.id || index} style={styles.itemRow}>
                  <View style={styles.itemCompactRow}>
                    <View style={styles.itemMainInfo}>
                      <View style={styles.itemTitleRow}>
                        <Text style={styles.itemName}>
                          {item.product?.name || 'Producto desconocido'}
                          {item.productVariant &&
                            ` - ${item.productVariant.name}`}
                        </Text>
                        <Chip
                          mode="flat"
                          compact
                          style={[
                            styles.preparationChip,
                            {
                              backgroundColor:
                                getPreparationStatusColor(
                                  item.preparationStatus,
                                  theme,
                                ) + '20',
                            },
                          ]}
                          textStyle={[
                            styles.preparationChipText,
                            {
                              color: getPreparationStatusColor(
                                item.preparationStatus,
                                theme,
                              ),
                            },
                          ]}
                        >
                          {getPreparationStatusLabel(item.preparationStatus)}
                        </Chip>
                      </View>
                      {item.preparationNotes && (
                        <Text style={styles.itemNotes}>
                          üìù {item.preparationNotes}
                        </Text>
                      )}
                    </View>
                    {item.preparedAt && (
                      <Text style={styles.preparedTime}>
                        {format(new Date(item.preparedAt), 'HH:mm')}
                      </Text>
                    )}
                  </View>
                  {index < orderData.orderItems.length - 1 && (
                    <Divider style={styles.itemDivider} />
                  )}
                </View>
              ))}
            </Card.Content>
          </Card>
        </>
      )}
    </ScrollView>
  );
};

export const OrderDetailModal: React.FC<OrderDetailModalProps> = ({
  visible,
  onDismiss,
  orderId,
  orderNumber,
  orderData,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);

  if (!visible) return null;

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalContainer}
      >
        <Surface style={styles.surface} elevation={2}>
          {/* Header */}
          <View style={styles.header}>
            <View style={styles.headerContent}>
              <Text style={styles.title}>
                {orderNumber ? `Orden #${orderNumber}` : 'Detalles de la Orden'}
              </Text>
              {orderData && (
                <Chip
                  mode="flat"
                  style={[
                    styles.statusChip,
                    {
                      backgroundColor: getStatusColor(
                        orderData.orderStatus,
                        theme,
                      ),
                    },
                  ]}
                  textStyle={styles.statusChipText}
                >
                  {getStatusLabel(orderData.orderStatus)}
                </Chip>
              )}
            </View>
            <IconButton
              icon="close-circle"
              size={32}
              onPress={onDismiss}
              style={styles.closeButton}
              iconColor={theme.colors.error}
            />
          </View>

          <Divider />

          {/* Content */}
          <OrderDetailContent
            orderId={orderId}
            orderNumber={orderNumber}
            orderData={order}
          />
        </Surface>
      </Modal>
    </Portal>
  );
};

const createStyles = (theme: any) =>
  StyleSheet.create({
    modalContainer: {
      padding: 12,
      maxWidth: 600,
      width: '95%',
      alignSelf: 'center',
      maxHeight: '92%',
    },
    surface: {
      borderRadius: theme.roundness * 2,
      overflow: 'hidden',
    },
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: 12,
      paddingVertical: 8,
      minHeight: 56,
    },
    headerContent: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      gap: 12,
      marginRight: 8,
    },
    title: {
      fontSize: 20,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    statusChip: {
      minHeight: 28,
      height: 'auto',
      paddingVertical: 4,
    },
    statusChipText: {
      fontSize: 13,
      fontWeight: '600',
      color: 'white',
      lineHeight: 18,
      includeFontPadding: false,
      textAlignVertical: 'center',
    },
    closeButton: {
      margin: -4,
      backgroundColor: theme.colors.errorContainer,
      borderRadius: 20,
    },
    content: {
      maxHeight: 600,
    },
    loadingContainer: {
      padding: 40,
      alignItems: 'center',
    },
    loadingText: {
      marginTop: 16,
      color: theme.colors.onSurfaceVariant,
    },
    errorContainer: {
      padding: 40,
      alignItems: 'center',
    },
    errorText: {
      marginTop: 16,
      color: theme.colors.error,
    },
    infoHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      paddingHorizontal: 12,
      paddingVertical: 8,
      backgroundColor: theme.colors.surfaceVariant,
      marginBottom: 4,
    },
    infoHeaderRow: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    infoHeaderLabel: {
      fontSize: 13,
      color: theme.colors.onSurfaceVariant,
      marginRight: 8,
    },
    infoHeaderValue: {
      fontSize: 14,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    infoCard: {
      margin: 8,
      marginBottom: 4,
    },
    itemsCard: {
      marginHorizontal: 8,
      marginTop: 4,
      marginBottom: 8,
      flex: 1,
    },
    itemRow: {
      paddingVertical: 3,
    },
    itemCompactRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      gap: 8,
    },
    itemMainInfo: {
      flex: 1,
    },
    itemTitleRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 8,
      flexWrap: 'nowrap',
    },
    itemStatusInfo: {
      alignItems: 'flex-end',
      gap: 2,
    },
    itemContent: {
      flex: 1,
    },
    itemHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 2,
    },
    itemFooter: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginTop: 8,
    },
    itemDivider: {
      marginTop: 2,
      marginBottom: 1,
      backgroundColor: theme.colors.outlineVariant,
    },
    sectionTitle: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
      marginBottom: 12,
    },
    itemName: {
      fontWeight: '600',
      fontSize: 13,
      color: theme.colors.onSurface,
      flex: 1,
      flexShrink: 1,
    },
    itemVariant: {
      fontSize: 13,
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
    },
    itemNotes: {
      fontSize: 10,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      marginTop: 0,
    },
    preparationChip: {
      minHeight: 26,
      height: 'auto',
      paddingHorizontal: 10,
      paddingVertical: 4,
    },
    preparationChipText: {
      fontSize: 12,
      fontWeight: '600',
      lineHeight: 16,
      includeFontPadding: false,
      textAlignVertical: 'center',
    },
    preparedTime: {
      fontSize: 12,
      color: theme.colors.primary,
      fontWeight: '600',
      minWidth: 40,
      textAlign: 'right',
      alignSelf: 'center',
      lineHeight: 16,
    },
    itemTimesContainer: {
      flex: 1,
      alignItems: 'flex-end',
    },
    itemCreatedTime: {
      fontSize: 11,
      color: theme.colors.onSurfaceVariant,
    },
    preparedByText: {
      fontSize: 11,
      color: theme.colors.primary,
      fontWeight: '500',
      marginTop: 2,
    },
    notPrepared: {
      fontSize: 12,
      color: theme.colors.onSurfaceDisabled,
    },
    cardContentCompact: {
      paddingVertical: 6,
      paddingHorizontal: 10,
    },
  });

export default OrderDetailModal;

================
File: app/src/modules/orders/components/PaymentModal.tsx
================
import React, { useState, useEffect, useMemo, useRef } from 'react';
import {
  View,
  ScrollView,
  StyleSheet,
  TouchableOpacity,
  Keyboard,
} from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  RadioButton,
  TextInput,
  HelperText,
  Divider,
  IconButton,
  Chip,
  ActivityIndicator,
  Surface,
} from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import {
  PaymentMethodEnum,
  PaymentStatusEnum,
  type PaymentMethod,
} from '../types/payment.types';
import {
  useGetPaymentsByOrderIdQuery,
  useCreatePaymentMutation,
  useUpdatePaymentMutation as _useUpdatePaymentMutation,
  useDeletePaymentMutation,
} from '../hooks/usePaymentQueries';
import { useCompleteOrderMutation } from '../hooks/useOrdersQueries';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
import ChangeCalculatorModal from './ChangeCalculatorModal';
import { prepaymentService } from '@/modules/payments/services/prepaymentService';

interface PaymentModalProps {
  visible: boolean;
  onDismiss: () => void;
  orderId?: string; // Opcional para modo pre-pago
  orderTotal: number;
  orderNumber?: number;
  orderStatus?: string; // Estado de la orden
  onOrderCompleted?: () => void; // Callback cuando se completa la orden
  mode?: 'payment' | 'prepayment'; // Modo del modal
  onPrepaymentCreated?: (
    prepaymentId: string,
    amount: number,
    method: PaymentMethod,
  ) => void; // Callback para pre-pago
  existingPrepaymentId?: string; // ID del pre-pago existente para edici√≥n
  onPrepaymentDeleted?: () => void; // Callback para eliminar pre-pago
}

const PAYMENT_METHOD_LABELS: Record<PaymentMethod, string> = {
  CASH: 'üíµ Efectivo',
  CARD: 'üí≥ Tarjeta',
  TRANSFER: 'üì± Transferencia',
};

const PAYMENT_METHOD_ICONS: Record<PaymentMethod, string> = {
  CASH: 'cash',
  CARD: 'credit-card',
  TRANSFER: 'bank-transfer',
};

// M√©todos de pago deshabilitados temporalmente
const DISABLED_METHODS: PaymentMethod[] = ['CARD', 'TRANSFER'];

// Helper para formatear el estado de la orden
const formatOrderStatus = (status: string): string => {
  switch (status) {
    case 'PENDING':
      return 'Pendiente';
    case 'IN_PROGRESS':
      return 'En Progreso';
    case 'IN_PREPARATION':
      return 'En Preparaci√≥n';
    case 'READY':
      return 'Lista';
    case 'DELIVERED':
      return 'Entregada';
    case 'COMPLETED':
      return 'Completada';
    case 'CANCELLED':
      return 'Cancelada';
    default:
      return status;
  }
};

export const PaymentModal: React.FC<PaymentModalProps> = ({
  visible,
  onDismiss,
  orderId,
  orderTotal,
  orderNumber,
  orderStatus,
  onOrderCompleted,
  mode = 'payment',
  onPrepaymentCreated,
  existingPrepaymentId,
  onPrepaymentDeleted,
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const scrollViewRef = useRef<ScrollView>(null);
  const amountInputRef = useRef<View>(null);

  // Estado del formulario
  const [selectedMethod, setSelectedMethod] = useState<PaymentMethod>(
    PaymentMethodEnum.CASH,
  );
  const [amount, setAmount] = useState('');
  const [showChangeCalculator, setShowChangeCalculator] = useState(false);
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
  const [paymentToDelete, setPaymentToDelete] = useState<string | null>(null);
  const [keyboardVisible, setKeyboardVisible] = useState(false);
  const [showFinalizeConfirm, setShowFinalizeConfirm] = useState(false);
  const [isCreatingPrepayment, setIsCreatingPrepayment] = useState(false);
  const [showDeletePrepaymentConfirm, setShowDeletePrepaymentConfirm] =
    useState(false);

  // Queries y mutations (solo para modo payment)
  const { data: payments = [], isLoading: isLoadingPayments } =
    useGetPaymentsByOrderIdQuery(orderId || '', {
      enabled: mode === 'payment' && !!orderId,
    });
  const createPaymentMutation = useCreatePaymentMutation();
  // const updatePaymentMutation = useUpdatePaymentMutation(); // No se usa actualmente
  const deletePaymentMutation = useDeletePaymentMutation();
  const completeOrderMutation = useCompleteOrderMutation();

  // Calcular totales
  const totalPaid = useMemo(() => {
    if (mode === 'prepayment') {
      return 0; // En modo pre-pago, no hay pagos previos
    }
    return (payments || [])
      .filter((p) => p.paymentStatus === PaymentStatusEnum.COMPLETED)
      .reduce((sum, payment) => sum + (Number(payment.amount) || 0), 0);
  }, [payments, mode]);

  const pendingAmount = orderTotal - totalPaid;
  const isFullyPaid = pendingAmount <= 0;

  // Resetear formulario cuando se abre el modal
  useEffect(() => {
    if (visible) {
      if (mode === 'prepayment') {
        setAmount(orderTotal.toFixed(2));
      } else {
        setAmount(pendingAmount > 0 ? pendingAmount.toFixed(2) : '');
      }
      setShowChangeCalculator(false);
      setSelectedMethod(PaymentMethodEnum.CASH);
    }
  }, [visible, pendingAmount, orderTotal, mode]);

  // Manejar el teclado
  useEffect(() => {
    const keyboardDidShowListener = Keyboard.addListener(
      'keyboardDidShow',
      () => {
        setKeyboardVisible(true);
        // Peque√±o delay para asegurar que el layout est√© actualizado
        setTimeout(() => {
          if (amountInputRef.current && scrollViewRef.current) {
            amountInputRef.current.measureLayout(
              scrollViewRef.current as any,
              (x, y) => {
                scrollViewRef.current?.scrollTo({ y: y - 50, animated: true });
              },
              () => {},
            );
          }
        }, 100);
      },
    );

    const keyboardDidHideListener = Keyboard.addListener(
      'keyboardDidHide',
      () => {
        setKeyboardVisible(false);
      },
    );

    return () => {
      keyboardDidShowListener.remove();
      keyboardDidHideListener.remove();
    };
  }, []);

  const handleSubmit = async () => {
    const parsedAmount = parseFloat(amount);

    if (isNaN(parsedAmount) || parsedAmount <= 0) {
      return;
    }

    // Si es efectivo, mostrar calculadora de cambio
    if (selectedMethod === PaymentMethodEnum.CASH) {
      setShowChangeCalculator(true);
      return;
    }

    // Para otros m√©todos de pago, procesar directamente
    await processPayment();
  };

  const processPayment = async () => {
    const parsedAmount = parseFloat(amount);

    try {
      if (mode === 'prepayment') {
        // Crear pre-pago
        setIsCreatingPrepayment(true);
        const prepayment = await prepaymentService.createPrepayment({
          paymentMethod: selectedMethod,
          amount: parsedAmount,
        });

        // Notificar al componente padre
        onPrepaymentCreated?.(prepayment.id, parsedAmount, selectedMethod);

        // Cerrar el modal
        onDismiss();
      } else {
        // Crear pago normal
        await createPaymentMutation.mutateAsync({
          orderId: orderId!,
          paymentMethod: selectedMethod,
          amount: parsedAmount,
        });

        // Resetear formulario
        setAmount('');
        setShowChangeCalculator(false);

        // Si ya est√° totalmente pagado, cerrar el modal
        if (pendingAmount - parsedAmount <= 0) {
          onDismiss();
        }
      }
    } catch (error) {
      // Error ya manejado por el mutation hook
    } finally {
      setIsCreatingPrepayment(false);
    }
  };

  const handleDeletePayment = async () => {
    if (!paymentToDelete) return;

    try {
      await deletePaymentMutation.mutateAsync(paymentToDelete);
      setShowDeleteConfirm(false);
      setPaymentToDelete(null);
    } catch (error) {}
  };

  const handleFinalizeOrder = async () => {
    try {
      await completeOrderMutation.mutateAsync(orderId);
      setShowFinalizeConfirm(false);

      // Llamar al callback si existe
      if (onOrderCompleted) {
        onOrderCompleted();
      } else {
        // Si no hay callback, solo cerrar el modal
        onDismiss();
      }
    } catch (error) {}
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case PaymentStatusEnum.COMPLETED:
        return '#4CAF50';
      case PaymentStatusEnum.PENDING:
        return theme.colors.primary;
      case PaymentStatusEnum.CANCELLED:
        return theme.colors.error;
      case PaymentStatusEnum.FAILED:
        return theme.colors.error;
      case PaymentStatusEnum.REFUNDED:
        return '#FF9800';
      default:
        return theme.colors.onSurfaceVariant;
    }
  };

  const getStatusText = (status: string) => {
    switch (status) {
      case PaymentStatusEnum.COMPLETED:
        return 'Completado';
      case PaymentStatusEnum.PENDING:
        return 'Pendiente';
      case PaymentStatusEnum.CANCELLED:
        return 'Cancelado';
      case PaymentStatusEnum.FAILED:
        return 'Fallido';
      case PaymentStatusEnum.REFUNDED:
        return 'Reembolsado';
      default:
        return status;
    }
  };

  const handleDeletePrepayment = async () => {
    if (!existingPrepaymentId) return;

    try {
      setIsCreatingPrepayment(true);
      await prepaymentService.deletePrepayment(existingPrepaymentId);
      onPrepaymentDeleted?.();
      setShowDeletePrepaymentConfirm(false);
      onDismiss();
    } catch (error) {
      // Error manejado en el servicio
    } finally {
      setIsCreatingPrepayment(false);
    }
  };

  return (
    <Portal>
      <Modal
        visible={visible && !showChangeCalculator}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalContainer}
      >
        <View style={styles.modalWrapper}>
          <Surface style={styles.modalContent} elevation={3}>
            {/* Header */}
            <View style={styles.header}>
              <View style={styles.headerTextContainer}>
                <Text style={styles.title}>
                  {mode === 'prepayment' ? 'Registrar Pago' : 'Pagos'}
                </Text>
                {orderNumber && mode !== 'prepayment' && (
                  <Text style={styles.orderNumber}>Orden #{orderNumber}</Text>
                )}
                {mode === 'prepayment' && (
                  <Text style={styles.orderNumber}>Pago anticipado</Text>
                )}
              </View>
              <IconButton icon="close" size={24} onPress={onDismiss} />
            </View>

            <Divider />

            <ScrollView
              ref={scrollViewRef}
              style={[
                styles.scrollView,
                keyboardVisible && styles.scrollViewWithKeyboard,
              ]}
              contentContainerStyle={styles.scrollViewContent}
              showsVerticalScrollIndicator={true}
              keyboardShouldPersistTaps="handled"
              bounces={true}
              nestedScrollEnabled={true}
            >
              {/* Resumen de pagos */}
              <View style={styles.summaryContainer}>
                <View style={styles.summaryItem}>
                  <Text style={styles.summaryLabel}>Total</Text>
                  <Text style={styles.summaryAmount}>
                    ${orderTotal.toFixed(2)}
                  </Text>
                </View>
                {mode !== 'prepayment' && (
                  <>
                    <View style={styles.summaryDividerVertical} />
                    <View style={styles.summaryItem}>
                      <Text style={styles.summaryLabel}>Pagado</Text>
                      <Text
                        style={[styles.summaryAmount, { color: '#4CAF50' }]}
                      >
                        ${totalPaid.toFixed(2)}
                      </Text>
                    </View>
                    <View style={styles.summaryDividerVertical} />
                    <View style={styles.summaryItem}>
                      <Text
                        style={[styles.summaryLabel, { fontWeight: 'bold' }]}
                      >
                        Pendiente
                      </Text>
                      <Text
                        style={[
                          styles.summaryAmount,
                          {
                            fontWeight: 'bold',
                            color:
                              pendingAmount > 0
                                ? theme.colors.error
                                : '#4CAF50',
                          },
                        ]}
                      >
                        ${pendingAmount.toFixed(2)}
                      </Text>
                    </View>
                  </>
                )}
              </View>

              {/* Lista de pagos existentes - Solo mostrar en modo payment */}
              {mode === 'payment' && (
                <>
                  {isLoadingPayments ? (
                    <ActivityIndicator style={styles.loader} />
                  ) : (payments || []).length > 0 ? (
                    <View style={styles.paymentsSection}>
                      <Text style={styles.sectionTitle}>Pagos registrados</Text>
                      {(payments || []).map((payment) => (
                        <View key={payment.id} style={styles.paymentItem}>
                          <View style={styles.paymentLeftInfo}>
                            <View style={styles.paymentMethodRow}>
                              <Text style={styles.paymentMethodCompact}>
                                {PAYMENT_METHOD_LABELS[payment.paymentMethod]}
                              </Text>
                            </View>
                            <Text style={styles.paymentDateCompact}>
                              {new Date(payment.createdAt).toLocaleTimeString(
                                'es-MX',
                                {
                                  hour: '2-digit',
                                  minute: '2-digit',
                                },
                              )}
                            </Text>
                          </View>

                          <View style={styles.paymentRightInfo}>
                            <Text style={styles.paymentAmountCompact}>
                              ${(Number(payment.amount) || 0).toFixed(2)}
                            </Text>

                            <Chip
                              mode="flat"
                              style={[
                                styles.statusChipCompact,
                                {
                                  backgroundColor: getStatusColor(
                                    payment.paymentStatus,
                                  ),
                                },
                              ]}
                              textStyle={styles.statusChipTextCompact}
                            >
                              {getStatusText(payment.paymentStatus)}
                            </Chip>

                            <IconButton
                              icon="delete"
                              size={20}
                              iconColor={theme.colors.error}
                              onPress={() => {
                                setPaymentToDelete(payment.id);
                                setShowDeleteConfirm(true);
                              }}
                              disabled={deletePaymentMutation.isPending}
                              style={styles.deleteIconButton}
                            />
                          </View>
                        </View>
                      ))}
                    </View>
                  ) : null}
                </>
              )}

              {/* Formulario para nuevo pago */}
              {(mode === 'prepayment' || !isFullyPaid) && (
                <View style={styles.formSection}>
                  <Text style={styles.sectionTitle}>
                    {mode === 'prepayment'
                      ? 'Configurar pago'
                      : 'Registrar nuevo pago'}
                  </Text>

                  {/* M√©todos de pago */}
                  <View style={styles.methodsContainer}>
                    {Object.entries(PaymentMethodEnum).map(([key, value]) => {
                      const isDisabled = DISABLED_METHODS.includes(
                        value as PaymentMethod,
                      );
                      return (
                        <TouchableOpacity
                          key={key}
                          style={[
                            styles.methodCard,
                            selectedMethod === value &&
                              styles.methodCardSelected,
                            isDisabled && styles.methodCardDisabled,
                          ]}
                          onPress={() =>
                            !isDisabled && setSelectedMethod(value)
                          }
                          disabled={isDisabled}
                        >
                          <RadioButton
                            value={value}
                            status={
                              selectedMethod === value ? 'checked' : 'unchecked'
                            }
                            onPress={() =>
                              !isDisabled && setSelectedMethod(value)
                            }
                            disabled={isDisabled}
                          />
                          <View style={styles.methodLabelContainer}>
                            <Text
                              style={[
                                styles.methodText,
                                selectedMethod === value &&
                                  styles.methodTextSelected,
                                isDisabled && styles.methodTextDisabled,
                              ]}
                            >
                              {PAYMENT_METHOD_LABELS[value]}
                            </Text>
                            {isDisabled && (
                              <Text style={styles.comingSoonText}>
                                Pr√≥ximamente
                              </Text>
                            )}
                          </View>
                        </TouchableOpacity>
                      );
                    })}
                  </View>

                  {/* Campo de monto */}
                  <View style={styles.amountContainer} ref={amountInputRef}>
                    <View style={styles.amountRow}>
                      <TextInput
                        label="Monto a pagar"
                        value={amount}
                        onChangeText={setAmount}
                        keyboardType="decimal-pad"
                        mode="outlined"
                        left={<TextInput.Affix text="$" />}
                        style={styles.amountInput}
                        error={
                          amount !== '' &&
                          (isNaN(parseFloat(amount)) || parseFloat(amount) <= 0)
                        }
                      />
                      <Button
                        mode="outlined"
                        onPress={() => setAmount(pendingAmount.toFixed(2))}
                        style={styles.totalPendingButton}
                        labelStyle={styles.totalPendingButtonLabel}
                        contentStyle={styles.totalPendingButtonContent}
                        compact
                      >
                        Total a pagar
                      </Button>
                    </View>
                    <HelperText
                      type="error"
                      visible={
                        amount !== '' &&
                        (isNaN(parseFloat(amount)) || parseFloat(amount) <= 0)
                      }
                    >
                      Ingrese un monto v√°lido
                    </HelperText>
                  </View>
                </View>
              )}
            </ScrollView>

            {/* Botones de acci√≥n */}
            <View style={styles.footer}>
              <Button
                mode="outlined"
                onPress={onDismiss}
                style={[styles.footerButton, styles.cancelButton]}
                contentStyle={styles.footerButtonContent}
              >
                Cerrar
              </Button>
              {mode === 'prepayment' && existingPrepaymentId && (
                <Button
                  mode="outlined"
                  onPress={() => setShowDeletePrepaymentConfirm(true)}
                  style={[
                    styles.footerButton,
                    { borderColor: theme.colors.error },
                  ]}
                  contentStyle={styles.footerButtonContent}
                  textColor={theme.colors.error}
                  icon="delete"
                >
                  Eliminar
                </Button>
              )}
              {(mode === 'prepayment' || !isFullyPaid) && (
                <Button
                  mode="contained"
                  onPress={handleSubmit}
                  disabled={
                    !amount ||
                    isNaN(parseFloat(amount)) ||
                    parseFloat(amount) <= 0 ||
                    createPaymentMutation.isPending ||
                    isCreatingPrepayment
                  }
                  loading={
                    createPaymentMutation.isPending || isCreatingPrepayment
                  }
                  style={styles.footerButton}
                  contentStyle={styles.footerButtonContent}
                >
                  {mode === 'prepayment'
                    ? 'Registrar Pre-pago'
                    : 'Registrar Pago'}
                </Button>
              )}
              {isFullyPaid && mode !== 'prepayment' && (
                <Button
                  mode="contained"
                  onPress={() => setShowFinalizeConfirm(true)}
                  disabled={completeOrderMutation.isPending}
                  loading={completeOrderMutation.isPending}
                  style={[styles.footerButton, { backgroundColor: '#10B981' }]}
                  contentStyle={styles.footerButtonContent}
                  icon="check-circle"
                >
                  Finalizar Orden
                </Button>
              )}
            </View>
          </Surface>
        </View>
      </Modal>

      {/* Modal de confirmaci√≥n para eliminar */}
      <ConfirmationModal
        visible={showDeleteConfirm}
        onDismiss={() => {
          setShowDeleteConfirm(false);
          setPaymentToDelete(null);
        }}
        onCancel={() => {
          setShowDeleteConfirm(false);
          setPaymentToDelete(null);
        }}
        onConfirm={handleDeletePayment}
        title="Eliminar pago"
        message="¬øEst√° seguro de que desea eliminar este pago? Esta acci√≥n no se puede deshacer."
        confirmText="S√≠, eliminar"
        cancelText="No, cancelar"
        confirmButtonColor={theme.colors.error}
      />

      {/* Modal de c√°lculo de cambio */}
      <ChangeCalculatorModal
        visible={showChangeCalculator}
        onDismiss={() => {
          setShowChangeCalculator(false);
        }}
        onConfirm={() => {
          setShowChangeCalculator(false);
          processPayment();
        }}
        amountToPay={parseFloat(amount) || 0}
      />

      {/* Modal de confirmaci√≥n para finalizar orden */}
      <ConfirmationModal
        visible={showFinalizeConfirm}
        onDismiss={() => setShowFinalizeConfirm(false)}
        onCancel={() => setShowFinalizeConfirm(false)}
        onConfirm={handleFinalizeOrder}
        title="Finalizar orden"
        message={
          orderStatus && orderStatus !== 'READY'
            ? `‚ö†Ô∏è ADVERTENCIA: Esta orden est√° en estado "${formatOrderStatus(orderStatus)}" y no "Lista".\n\n¬øEst√° seguro de que desea finalizar la orden #${orderNumber}? La orden se marcar√° como completada.`
            : `¬øEst√° seguro de que desea finalizar la orden #${orderNumber}? La orden se marcar√° como completada.`
        }
        confirmText={
          orderStatus && orderStatus !== 'READY'
            ? 'Finalizar igual'
            : 'S√≠, finalizar'
        }
        cancelText="No, cancelar"
        confirmButtonColor={
          orderStatus && orderStatus !== 'READY'
            ? theme.colors.error
            : '#10B981'
        }
      />

      {/* Modal de confirmaci√≥n para eliminar pre-pago */}
      <ConfirmationModal
        visible={showDeletePrepaymentConfirm}
        onDismiss={() => setShowDeletePrepaymentConfirm(false)}
        onCancel={() => setShowDeletePrepaymentConfirm(false)}
        onConfirm={handleDeletePrepayment}
        title="Eliminar pago"
        message="¬øEst√° seguro de que desea eliminar este pago registrado? Esta acci√≥n no se puede deshacer."
        confirmText="S√≠, eliminar"
        cancelText="Cancelar"
        confirmButtonColor={theme.colors.error}
      />
    </Portal>
  );
};

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    modalContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.spacing(theme.spacing.m, theme.spacing.s),
    },
    modalWrapper: {
      width: '100%',
      maxWidth: responsive.isTablet ? 700 : 600,
      maxHeight: responsive.isTablet ? '90%' : '85%',
    },
    modalContent: {
      borderRadius: theme.roundness * 2,
      backgroundColor: theme.colors.surface,
      width: '100%',
      maxHeight: '100%',
      minHeight: responsive.isTablet ? 550 : undefined,
      overflow: 'hidden',
      borderWidth: 2,
      borderColor: theme.colors.outline,
    },
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: responsive.spacing(theme.spacing.m, theme.spacing.s),
      paddingVertical: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
    },
    headerTextContainer: {
      flex: 1,
    },
    title: {
      ...theme.fonts.headlineSmall,
      fontSize: responsive.fontSize(theme.fonts.headlineSmall.fontSize),
      color: theme.colors.onSurface,
      fontWeight: 'bold',
    },
    orderNumber: {
      ...theme.fonts.bodyMedium,
      fontSize: responsive.fontSize(theme.fonts.bodyMedium.fontSize),
      color: theme.colors.onSurfaceVariant,
    },
    scrollView: {
      maxHeight: responsive.isTablet ? 600 : 500,
    },
    scrollViewContent: {
      paddingBottom: responsive.spacing(theme.spacing.m, theme.spacing.s),
    },
    scrollViewWithKeyboard: {
      maxHeight: responsive.isTablet ? 350 : 250,
    },
    summaryContainer: {
      flexDirection: 'row',
      justifyContent: 'space-around',
      alignItems: 'center',
      backgroundColor: theme.colors.primaryContainer,
      paddingVertical: responsive.spacing(theme.spacing.s, theme.spacing.xs),
      paddingHorizontal: responsive.spacing(theme.spacing.m, theme.spacing.s),
      marginHorizontal: responsive.spacing(theme.spacing.m, theme.spacing.s),
      marginTop: responsive.spacing(theme.spacing.s, theme.spacing.xs),
      marginBottom: responsive.spacing(theme.spacing.m, theme.spacing.s),
      borderRadius: theme.roundness,
    },
    summaryItem: {
      flex: 1,
      alignItems: 'center',
    },
    summaryLabel: {
      ...theme.fonts.bodySmall,
      fontSize: responsive.fontSize(theme.fonts.bodySmall.fontSize),
      color: theme.colors.onPrimaryContainer,
      opacity: 0.8,
      marginBottom: 2,
    },
    summaryAmount: {
      ...theme.fonts.titleSmall,
      fontSize: responsive.fontSize(theme.fonts.titleSmall.fontSize),
      fontWeight: 'bold',
      color: theme.colors.onPrimaryContainer,
    },
    summaryDividerVertical: {
      width: 1,
      height: '80%',
      backgroundColor: theme.colors.onPrimaryContainer,
      opacity: 0.2,
      marginHorizontal: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
    },
    loader: {
      marginVertical: responsive.spacing(theme.spacing.xl, theme.spacing.l),
    },
    paymentsSection: {
      paddingHorizontal: responsive.spacing(theme.spacing.m, theme.spacing.s),
      paddingBottom: responsive.spacing(theme.spacing.s, theme.spacing.xs),
    },
    sectionTitle: {
      ...theme.fonts.titleSmall,
      fontSize: responsive.fontSize(theme.fonts.titleSmall.fontSize),
      color: theme.colors.onSurface,
      marginBottom: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
      fontWeight: '600',
    },
    paymentItem: {
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: theme.roundness,
      padding: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
      marginBottom: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    paymentLeftInfo: {
      flex: 1,
    },
    paymentRightInfo: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
    },
    paymentMethodRow: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    paymentMethodCompact: {
      ...theme.fonts.bodyMedium,
      fontSize: responsive.fontSize(theme.fonts.bodyMedium.fontSize),
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    paymentAmountCompact: {
      ...theme.fonts.bodyMedium,
      fontSize: responsive.fontSize(theme.fonts.bodyMedium.fontSize),
      fontWeight: 'bold',
      color: theme.colors.primary,
      minWidth: responsive.isTablet ? 60 : 70,
      textAlign: 'right',
    },
    paymentDateCompact: {
      ...theme.fonts.bodySmall,
      fontSize: responsive.fontSize(theme.fonts.bodySmall.fontSize),
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
    },
    statusChipCompact: {
      height: responsive.isTablet ? 24 : 26,
      minWidth: responsive.isTablet ? 80 : 90,
    },
    statusChipTextCompact: {
      fontSize: responsive.fontSize(11),
      fontWeight: '600',
      color: 'white',
      lineHeight: responsive.isTablet ? 12 : 14,
    },
    deleteIconButton: {
      margin: 0,
      width: responsive.isTablet ? 32 : 36,
      height: responsive.isTablet ? 32 : 36,
    },
    formSection: {
      paddingHorizontal: responsive.spacing(theme.spacing.m, theme.spacing.s),
      paddingBottom: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
    },
    methodsContainer: {
      marginBottom: responsive.spacing(theme.spacing.s, theme.spacing.xs),
    },
    methodCard: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingVertical: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
      paddingHorizontal: responsive.spacing(theme.spacing.s, theme.spacing.xs),
      marginBottom: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
      borderRadius: theme.roundness,
      borderWidth: 1,
      borderColor: theme.colors.outline,
      backgroundColor: theme.colors.surface,
    },
    methodCardSelected: {
      borderColor: theme.colors.primary,
      backgroundColor: theme.colors.primaryContainer,
    },
    methodText: {
      ...theme.fonts.bodyLarge,
      fontSize: responsive.fontSize(theme.fonts.bodyLarge.fontSize),
      color: theme.colors.onSurface,
      marginLeft: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
    },
    methodTextSelected: {
      color: theme.colors.onPrimaryContainer,
      fontWeight: '500',
    },
    methodCardDisabled: {
      opacity: 0.5,
      borderColor: theme.colors.outlineVariant,
    },
    methodLabelContainer: {
      flex: 1,
      marginLeft: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
    },
    methodTextDisabled: {
      color: theme.colors.onSurfaceDisabled,
    },
    comingSoonText: {
      ...theme.fonts.bodySmall,
      fontSize: responsive.fontSize(theme.fonts.bodySmall.fontSize),
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      marginTop: 2,
    },
    amountContainer: {
      marginTop: responsive.spacing(theme.spacing.s, theme.spacing.xs),
    },
    amountRow: {
      flexDirection: 'row',
      gap: responsive.spacing(theme.spacing.xs, theme.spacing.xxs),
      alignItems: 'flex-start',
    },
    amountInput: {
      backgroundColor: theme.colors.surface,
      flex: 1,
    },
    totalPendingButton: {
      marginTop: 4, // Alinear con el input que tiene un label
      height: responsive.isTablet ? 48 : 56, // Misma altura que el TextInput con outlined
      borderColor: theme.colors.primary,
      justifyContent: 'center',
    },
    totalPendingButtonContent: {
      height: '100%',
      paddingVertical: 0,
      paddingHorizontal: responsive.spacing(theme.spacing.s, theme.spacing.xs),
    },
    totalPendingButtonLabel: {
      fontSize: responsive.fontSize(13),
      lineHeight: responsive.isTablet ? 18 : 20,
      textAlignVertical: 'center',
    },
    footer: {
      flexDirection: 'row',
      justifyContent: 'center',
      alignItems: 'center',
      gap: responsive.spacing(theme.spacing.m, theme.spacing.s),
      paddingHorizontal: responsive.spacing(theme.spacing.m, theme.spacing.s),
      paddingVertical: responsive.spacing(theme.spacing.m, theme.spacing.s),
      paddingTop: responsive.spacing(theme.spacing.s, theme.spacing.xs),
      backgroundColor: theme.colors.surface,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
    },
    footerButton: {
      minWidth: responsive.isTablet ? 110 : 120,
    },
    footerButtonContent: {
      height: responsive.isTablet ? 36 : 40,
    },
    cancelButton: {
      borderColor: theme.colors.outline,
    },
  });

export default PaymentModal;

================
File: app/src/modules/orders/services/orderService.ts
================
import apiClient from '@/app/services/apiClient';
import { handleApiResponse } from '@/app/lib/apiHelpers';
import { API_PATHS } from '@/app/constants/apiPaths';
import { ApiError } from '@/app/lib/errors';
import type { Order } from '../../../app/schemas/domain/order.schema';
import type { FindAllOrdersDto, OrderOpenList } from '../types/orders.types';
import type { PaginatedResponse } from '../../../app/types/api.types';
import type { OrderDetailsForBackend } from '../components/OrderCartDetail';
import type { UpdateOrderPayload } from '../types/update-order.types';

const createOrder = async (
  orderData: OrderDetailsForBackend,
): Promise<Order> => {
  const response = await apiClient.post<Order>(API_PATHS.ORDERS, orderData);
  return handleApiResponse(response);
};

export const orderService = {
  createOrder,
  getOrders: async (
    filters: FindAllOrdersDto = {},
  ): Promise<PaginatedResponse<Order>> => {
    const queryParams: Record<string, any> = {};
    for (const [key, value] of Object.entries(filters)) {
      if (value !== undefined) {
        if (key !== 'page' && key !== 'limit') {
          queryParams[key] = value;
        }
      }
    }

    const page = filters.page ?? 1;
    const limit = filters.limit ?? 10;
    queryParams.page = page;
    queryParams.limit = limit;
    const response = await apiClient.get<[Order[], number]>(
      API_PATHS.ORDERS,
      queryParams,
    );

    if (
      !response.ok ||
      !response.data ||
      !Array.isArray(response.data) ||
      response.data.length !== 2
    ) {
      throw ApiError.fromApiResponse(response.data, response.status);
    }

    const [data, total] = response.data;
    const totalPages = limit > 0 ? Math.ceil(total / limit) : 1;

    return {
      data,
      total,
      page,
      limit,
      totalPages,
    };
  },
  getOpenOrdersCurrentShift: async (): Promise<Order[]> => {
    const response = await apiClient.get<Order[]>(
      API_PATHS.ORDERS_OPEN_CURRENT_SHIFT,
    );
    return handleApiResponse(response);
  },
  getOpenOrdersList: async (): Promise<OrderOpenList[]> => {
    const response = await apiClient.get<OrderOpenList[]>(
      API_PATHS.ORDERS_OPEN_ORDERS_LIST,
    );
    return handleApiResponse(response);
  },
  printOrderTicket: async (
    orderId: string,
    printerId: string,
  ): Promise<void> => {
    const url = API_PATHS.PRINT_ORDER_TICKET;
    const body = { orderId, printerId };
    const response = await apiClient.post<any>(url, body);

    if (!response.ok) {
      throw ApiError.fromApiResponse(response.data, response.status);
    }
  },
  getOrderById: async (orderId: string): Promise<Order> => {
    const response = await apiClient.get<Order>(
      API_PATHS.ORDERS_BY_ID.replace(':orderId', orderId),
    );

    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status);
    }
    return response.data;
  },
  updateOrder: async (
    orderId: string,
    payload: UpdateOrderPayload,
  ): Promise<Order> => {
    const response = await apiClient.patch<Order>(
      API_PATHS.ORDERS_BY_ID.replace(':orderId', orderId),
      payload,
    );

    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status);
    }
    return response.data;
  },
  cancelOrder: async (orderId: string): Promise<Order> => {
    const payload: UpdateOrderPayload = {
      orderStatus: 'CANCELLED',
    };

    const response = await apiClient.patch<Order>(
      API_PATHS.ORDERS_BY_ID.replace(':orderId', orderId),
      payload,
    );

    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status);
    }
    return response.data;
  },
};

================
File: app/src/modules/restaurantConfig/components/WebViewDeliveryCoverageMap.tsx
================
import React, { useRef, useEffect, useState } from 'react';
import { View, StyleSheet, Alert, useWindowDimensions } from 'react-native';
import { WebView } from 'react-native-webview';
import {
  Surface,
  IconButton,
  ActivityIndicator,
  Text,
} from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { DeliveryCoveragePoint } from '../types/restaurantConfig.types';
import { useGoogleMapsConfig } from '@/hooks/useGoogleMapsConfig';

interface DeliveryCoverageMapProps {
  initialPolygon?: DeliveryCoveragePoint[] | null;
  isEditing: boolean;
  onChange?: (polygon: DeliveryCoveragePoint[]) => void;
  restaurantLocation?: {
    latitude: number;
    longitude: number;
  };
}

export const WebViewDeliveryCoverageMap: React.FC<DeliveryCoverageMapProps> = ({
  initialPolygon,
  isEditing,
  onChange,
  restaurantLocation,
}) => {
  const theme = useAppTheme();
  const { width, height } = useWindowDimensions();
  const webViewRef = useRef<WebView>(null);
  const { config: mapsConfig, loading: isLoadingApiKey } =
    useGoogleMapsConfig();
  const apiKey = mapsConfig?.apiKey;

  const styles = React.useMemo(
    () => createStyles(theme, width, height),
    [theme, width, height],
  );

  const [mapReady, setMapReady] = useState(false);
  const [isDrawing, setIsDrawing] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [currentPolygon, setCurrentPolygon] = useState<DeliveryCoveragePoint[]>(
    () => {
      return initialPolygon || [];
    },
  );

  // HTML del mapa con Google Maps API
  const mapHtml = apiKey
    ? `
<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      height: 100%;
      width: 100%;
      overflow: hidden;
    }
    #map {
      height: 100%;
      width: 100%;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <script>
    let map;
    let polygon;
    let markers = [];
    let isEditing = false;
    let polygonPath = [];

    function initMap() {
      // Inicializar el mapa
      const initialLocation = ${
        restaurantLocation
          ? `{ lat: ${restaurantLocation.latitude}, lng: ${restaurantLocation.longitude} }`
          : '{ lat: 20.5425, lng: -102.7935 }'
      };
      
      map = new google.maps.Map(document.getElementById('map'), {
        center: initialLocation,
        zoom: 14,
        disableDefaultUI: true,
        zoomControl: true,
        mapTypeControl: false,
        scaleControl: false,
        streetViewControl: false,
        rotateControl: false,
        fullscreenControl: false
      });

      // Escuchar mensajes desde React Native
      window.addEventListener('message', handleMessage);
      
      // Notificar que el mapa est√° listo
      sendMessage('mapReady', {});
    }

    function handleMessage(event) {
      try {
        const data = JSON.parse(event.data);
        
        switch(data.type) {
          case 'setPolygon':
            setPolygon(data.coordinates);
            break;
          case 'setEditMode':
            setEditMode(data.isEditing);
            break;
          case 'centerOnPolygon':
            centerOnPolygon();
            break;
          case 'clearPolygon':
            clearPolygon();
            break;
        }
      } catch (e) {
        // Error handling message
      }
    }

    function setPolygon(coordinates) {
      // Limpiar pol√≠gono anterior
      if (polygon) {
        polygon.setMap(null);
      }
      
      // Limpiar marcadores
      markers.forEach(marker => marker.setMap(null));
      markers = [];
      
      // Convertir coordenadas
      polygonPath = coordinates.map(coord => ({
        lat: coord.lat || coord.latitude,
        lng: coord.lng || coord.longitude
      }));
      
      
      if (polygonPath.length >= 3) {
        // Crear pol√≠gono
        polygon = new google.maps.Polygon({
          paths: polygonPath,
          strokeColor: '#FF0000',
          strokeOpacity: 0.8,
          strokeWeight: 3,
          fillColor: '#FF0000',
          fillOpacity: 0.35,
          editable: false,
          draggable: false
        });
        
        polygon.setMap(map);
        
        // Centrar en el pol√≠gono
        setTimeout(() => {
          centerOnPolygon();
          // Notificar que el pol√≠gono se ha dibujado
          sendMessage('polygonSet', {});
        }, 100);
      }
    }

    function setEditMode(editing) {
      isEditing = editing;
      
      if (isEditing) {
        // Habilitar clicks en el mapa
        google.maps.event.clearListeners(map, 'click');
        map.addListener('click', function(event) {
          addPoint(event.latLng);
        });
        
        // Mostrar marcadores inmediatamente
        updateMarkers();
      } else {
        // Deshabilitar clicks
        google.maps.event.clearListeners(map, 'click');
        
        // Ocultar marcadores
        markers.forEach(marker => marker.setMap(null));
        markers = [];
      }
    }

    function addPoint(latLng) {
      if (!isEditing) return;
      
      polygonPath.push({
        lat: latLng.lat(),
        lng: latLng.lng()
      });
      
      updatePolygon();
      updateMarkers();
      
      // Enviar actualizaci√≥n a React Native
      sendMessage('polygonUpdated', {
        coordinates: polygonPath
      });
    }

    function updatePolygon() {
      if (polygon) {
        polygon.setPath(polygonPath);
      } else if (polygonPath.length >= 3) {
        polygon = new google.maps.Polygon({
          paths: polygonPath,
          strokeColor: '#FF0000',
          strokeOpacity: 0.8,
          strokeWeight: 3,
          fillColor: '#FF0000',
          fillOpacity: 0.35
        });
        polygon.setMap(map);
      }
    }

    function updateMarkers() {
      // Limpiar marcadores anteriores
      markers.forEach(marker => marker.setMap(null));
      markers = [];
      
      if (!isEditing) return;
      
      // Crear nuevos marcadores
      polygonPath.forEach((point, index) => {
        const marker = new google.maps.Marker({
          position: point,
          map: map,
          draggable: true,
          label: {
            text: (index + 1).toString(),
            color: 'white',
            fontSize: '12px',
            fontWeight: 'bold'
          },
          icon: {
            path: google.maps.SymbolPath.CIRCLE,
            scale: 20,
            fillColor: '#2563eb',
            fillOpacity: 1,
            strokeColor: 'white',
            strokeWeight: 2
          }
        });
        
        // Permitir arrastrar
        marker.addListener('dragend', function() {
          polygonPath[index] = {
            lat: marker.getPosition().lat(),
            lng: marker.getPosition().lng()
          };
          updatePolygon();
          sendMessage('polygonUpdated', {
            coordinates: polygonPath
          });
        });
        
        // Click para eliminar
        marker.addListener('click', function() {
          polygonPath.splice(index, 1);
          updatePolygon();
          updateMarkers();
          sendMessage('polygonUpdated', {
            coordinates: polygonPath
          });
        });
        
        markers.push(marker);
      });
    }

    function centerOnPolygon() {
      if (polygonPath.length > 0) {
        const bounds = new google.maps.LatLngBounds();
        polygonPath.forEach(point => {
          bounds.extend(point);
        });
        map.fitBounds(bounds);
        
        // Ajustar el zoom si es necesario
        const listener = google.maps.event.addListener(map, 'idle', function() { 
          if (map.getZoom() > 18) {
            map.setZoom(18);
          }
          google.maps.event.removeListener(listener);
        });
      }
    }

    function clearPolygon() {
      polygonPath = [];
      if (polygon) {
        polygon.setMap(null);
        polygon = null;
      }
      markers.forEach(marker => marker.setMap(null));
      markers = [];
      
      sendMessage('polygonUpdated', {
        coordinates: []
      });
    }

    function sendMessage(type, data) {
      try {
        if (window.ReactNativeWebView) {
          window.ReactNativeWebView.postMessage(JSON.stringify({
            type: type,
            ...data
          }));
        }
      } catch (e) {
        // Error sending message
      }
    }
  </script>
  <script async defer
    src="https://maps.googleapis.com/maps/api/js?key=${apiKey}&callback=initMap">
  </script>
</body>
</html>
  `
    : '';

  // Manejar mensajes del WebView
  const handleWebViewMessage = (event: any) => {
    try {
      const data = JSON.parse(event.nativeEvent.data);

      switch (data.type) {
        case 'mapReady':
          setMapReady(true);

          // Enviar pol√≠gono inicial si existe
          if (initialPolygon && initialPolygon.length > 0) {
            setTimeout(() => {
              sendMessageToWebView('setPolygon', {
                coordinates: initialPolygon,
              });
            }, 1000);
          } else {
            // Si no hay pol√≠gono inicial, ocultar el loading
            setIsLoading(false);
          }
          break;
        case 'polygonSet':
          // El pol√≠gono se ha dibujado en el mapa
          setIsLoading(false);
          break;
        case 'polygonUpdated': {
          const newPolygon = data.coordinates;
          setCurrentPolygon(newPolygon);
          if (onChange) {
            onChange(newPolygon);
          }
          break;
        }
      }
    } catch (e) {}
  };

  // Enviar mensaje al WebView
  const sendMessageToWebView = (type: string, data: any) => {
    if (webViewRef.current) {
      const message = JSON.stringify({ type, ...data });
      webViewRef.current.postMessage(message);
    }
  };

  // Actualizar el modo de edici√≥n cuando cambie
  useEffect(() => {
    if (mapReady) {
      sendMessageToWebView('setEditMode', {
        isEditing: isEditing && isDrawing,
      });
    }
  }, [isEditing, isDrawing, mapReady]);

  // Actualizar el pol√≠gono cuando cambie desde fuera
  useEffect(() => {
    if (mapReady && initialPolygon && initialPolygon.length > 0) {
      setCurrentPolygon(initialPolygon);
      sendMessageToWebView('setPolygon', { coordinates: initialPolygon });
    }
  }, [initialPolygon, mapReady]);

  // Resetear estados cuando el componente se monta
  useEffect(() => {
    setIsLoading(true);
    setMapReady(false);
  }, []);

  const toggleDrawing = () => {
    if (isDrawing && currentPolygon.length < 3) {
      Alert.alert(
        '√Årea incompleta',
        'Necesitas al menos 3 puntos para crear un √°rea de cobertura.',
      );
      return;
    }
    const newDrawingState = !isDrawing;
    setIsDrawing(newDrawingState);

    // Enviar el estado de edici√≥n al mapa inmediatamente
    if (webViewRef.current) {
      const jsCode = `
        if (typeof setEditMode === 'function') {
          setEditMode(${newDrawingState});
        }
        true;
      `;
      webViewRef.current.injectJavaScript(jsCode);
    }
  };

  const clearPolygon = () => {
    sendMessageToWebView('clearPolygon', {});

    // Tambi√©n usar inyecci√≥n directa
    if (webViewRef.current) {
      const jsCode = `
        if (typeof clearPolygon === 'function') {
          clearPolygon();
        }
        true;
      `;
      webViewRef.current.injectJavaScript(jsCode);
    }

    setCurrentPolygon([]);
    setIsDrawing(false);
    if (onChange) {
      onChange([]);
    }
  };

  const centerOnPolygon = () => {
    sendMessageToWebView('centerOnPolygon', {});

    // Tambi√©n usar inyecci√≥n directa
    if (webViewRef.current) {
      const jsCode = `
        if (typeof centerOnPolygon === 'function') {
          centerOnPolygon();
        }
        true;
      `;
      webViewRef.current.injectJavaScript(jsCode);
    }
  };

  // Si estamos cargando la API key o no tenemos HTML, mostrar loading
  if (isLoadingApiKey || !mapHtml) {
    return (
      <View style={[styles.container, styles.loadingContainer]}>
        <Surface style={styles.loadingCard} elevation={3}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
          <Text style={styles.loadingText}>
            Cargando configuraci√≥n del mapa...
          </Text>
        </Surface>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <WebView
        ref={webViewRef}
        source={{ html: mapHtml }}
        style={styles.map}
        onMessage={handleWebViewMessage}
        onLoad={() => {
          // Inyectar c√≥digo JavaScript despu√©s de cargar
          if (
            webViewRef.current &&
            initialPolygon &&
            initialPolygon.length > 0
          ) {
            const jsCode = `
              setTimeout(() => {
                if (typeof setPolygon === 'function') {
                  setPolygon(${JSON.stringify(initialPolygon)});
                }
              }, 1500);
              true;
            `;
            webViewRef.current.injectJavaScript(jsCode);
          }
        }}
        onError={(_error) => {}}
        javaScriptEnabled={true}
        domStorageEnabled={true}
        startInLoadingState={true}
        mixedContentMode="compatibility"
        allowsInlineMediaPlayback={true}
        originWhitelist={['*']}
      />

      {/* Indicador de carga */}
      {isLoading && (
        <View style={styles.loadingContainer}>
          <Surface style={styles.loadingCard} elevation={3}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
            <Text style={styles.loadingText}>Cargando mapa...</Text>
          </Surface>
        </View>
      )}

      {/* Controles flotantes */}
      {isEditing && (
        <View style={styles.controls}>
          <Surface style={styles.controlsCard} elevation={2}>
            <View style={styles.controlsRow}>
              <IconButton
                icon={isDrawing ? 'check' : 'draw'}
                mode="contained"
                containerColor={
                  isDrawing ? theme.colors.primary : theme.colors.secondary
                }
                iconColor={
                  isDrawing ? theme.colors.onPrimary : theme.colors.onSecondary
                }
                size={24}
                onPress={toggleDrawing}
              />
              <IconButton
                icon="crosshairs-gps"
                mode="contained"
                containerColor={theme.colors.tertiaryContainer}
                iconColor={theme.colors.onTertiaryContainer}
                size={24}
                onPress={centerOnPolygon}
                disabled={currentPolygon.length === 0}
              />
              <IconButton
                icon="delete"
                mode="contained"
                containerColor={theme.colors.errorContainer}
                iconColor={theme.colors.onErrorContainer}
                size={24}
                onPress={clearPolygon}
                disabled={currentPolygon.length === 0}
              />
            </View>
          </Surface>
        </View>
      )}

      {/* Bot√≥n de centrar cuando no se est√° editando */}
      {!isEditing && currentPolygon.length > 0 && (
        <View style={styles.centerButtonContainer}>
          <IconButton
            icon="crosshairs-gps"
            mode="contained"
            containerColor={theme.colors.primaryContainer}
            iconColor={theme.colors.onPrimaryContainer}
            size={24}
            onPress={centerOnPolygon}
            style={styles.floatingCenterButton}
          />
        </View>
      )}
    </View>
  );
};

const createStyles = (theme: AppTheme, width: number, height: number) =>
  StyleSheet.create({
    container: {
      height: Math.min(height * 0.6, 500),
      width: '100%',
      borderRadius: 16,
      overflow: 'hidden',
      backgroundColor: theme.colors.surfaceVariant,
    },
    map: {
      ...StyleSheet.absoluteFillObject,
    },
    controls: {
      position: 'absolute',
      top: theme.spacing.m,
      right: theme.spacing.m,
    },
    controlsCard: {
      borderRadius: 12,
      padding: theme.spacing.s,
      backgroundColor: theme.colors.surface,
      alignItems: 'center',
      gap: theme.spacing.xs,
    },
    controlsRow: {
      flexDirection: 'row',
      gap: theme.spacing.xs,
    },
    statusText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginTop: theme.spacing.xs,
    },
    centerButtonContainer: {
      position: 'absolute',
      bottom: theme.spacing.m,
      right: theme.spacing.m,
    },
    floatingCenterButton: {
      elevation: 4,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
    },
    loadingContainer: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      justifyContent: 'center',
      alignItems: 'center',
      backgroundColor: 'rgba(0, 0, 0, 0.3)',
    },
    loadingCard: {
      padding: theme.spacing.xl,
      borderRadius: 16,
      alignItems: 'center',
      backgroundColor: theme.colors.surface,
    },
    loadingText: {
      marginTop: theme.spacing.m,
      fontSize: 16,
      color: theme.colors.onSurface,
      fontWeight: '500',
    },
  });

export default WebViewDeliveryCoverageMap;

================
File: app/src/modules/shiftAudit/screens/ShiftsListScreen.tsx
================
import React, { useState, useMemo } from 'react';
import {
  View,
  StyleSheet,
  RefreshControl,
  TouchableOpacity,
  Modal,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import {
  Text,
  Chip,
  Card,
  Divider,
  Button,
  Menu,
  Avatar,
  ActivityIndicator,
  IconButton,
  Surface,
} from 'react-native-paper';
import { FlashList } from '@shopify/flash-list';
import { format, parseISO, subDays, startOfDay, endOfDay } from 'date-fns';
import { es } from 'date-fns/locale';
import { useAppTheme } from '@/app/styles/theme';
import { useShifts } from '../hooks/useShifts';
import { formatCurrency } from '@/app/lib/formatters';
import type { Shift } from '../types';
import { ShiftOrdersModal, ShiftSalesSummaryView } from '../components';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';
import DateTimePicker from '@react-native-community/datetimepicker';

export function ShiftsListScreen() {
  const theme = useAppTheme();
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [dateFilter, setDateFilter] = useState<
    'today' | 'yesterday' | 'last7' | 'custom'
  >('last7');
  const [showDateMenu, setShowDateMenu] = useState(false);
  const [showDateRangePicker, setShowDateRangePicker] = useState(false);
  const [customDateRange, setCustomDateRange] = useState<{
    start: Date;
    end: Date;
  }>({
    start: subDays(new Date(), 7),
    end: new Date(),
  });
  const [datePickerMode, setDatePickerMode] = useState<'start' | 'end'>(
    'start',
  );
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [selectedShiftId, setSelectedShiftId] = useState<string | null>(null);
  const [selectedShiftNumber, setSelectedShiftNumber] = useState<
    number | undefined
  >();
  const [showOrdersModal, setShowOrdersModal] = useState(false);
  const [showSalesSummaryView, setShowSalesSummaryView] = useState(false);

  const dateParams = useMemo(() => {
    const now = new Date();

    switch (dateFilter) {
      case 'today':
        return {
          startDate: format(startOfDay(now), 'yyyy-MM-dd'),
          endDate: format(endOfDay(now), 'yyyy-MM-dd'),
        };
      case 'yesterday': {
        const yesterday = subDays(now, 1);
        return {
          startDate: format(startOfDay(yesterday), 'yyyy-MM-dd'),
          endDate: format(endOfDay(yesterday), 'yyyy-MM-dd'),
        };
      }
      case 'last7':
        return {
          startDate: format(startOfDay(subDays(now, 7)), 'yyyy-MM-dd'),
          endDate: format(endOfDay(now), 'yyyy-MM-dd'),
        };
      case 'custom':
        return {
          startDate: format(startOfDay(customDateRange.start), 'yyyy-MM-dd'),
          endDate: format(endOfDay(customDateRange.end), 'yyyy-MM-dd'),
        };
      default:
        return {
          startDate: format(startOfDay(subDays(now, 7)), 'yyyy-MM-dd'),
          endDate: format(endOfDay(now), 'yyyy-MM-dd'),
        };
    }
  }, [dateFilter, customDateRange]);

  const {
    data: shifts,
    isLoading,
    error,
    refetch,
    isRefetching,
  } = useShifts(dateParams);

  useRefreshModuleOnFocus('shifts');

  const handleRefresh = async () => {
    setIsRefreshing(true);
    await refetch();
    setIsRefreshing(false);
  };

  const filteredShifts = useMemo(() => {
    if (!shifts || !Array.isArray(shifts)) {
      return [];
    }

    return shifts.filter((shift) => {
      if (!shift.openedAt) return false;

      try {
        const shiftDate = parseISO(shift.openedAt);
        const shiftDateOnly = format(shiftDate, 'yyyy-MM-dd');

        switch (dateFilter) {
          case 'today':
            return shiftDateOnly === format(new Date(), 'yyyy-MM-dd');
          case 'yesterday':
            return (
              shiftDateOnly === format(subDays(new Date(), 1), 'yyyy-MM-dd')
            );
          case 'last7': {
            const sevenDaysAgo = format(subDays(new Date(), 7), 'yyyy-MM-dd');
            const today = format(new Date(), 'yyyy-MM-dd');
            return shiftDateOnly >= sevenDaysAgo && shiftDateOnly <= today;
          }
          case 'custom': {
            const customStart = format(customDateRange.start, 'yyyy-MM-dd');
            const customEnd = format(customDateRange.end, 'yyyy-MM-dd');
            return shiftDateOnly >= customStart && shiftDateOnly <= customEnd;
          }
          default:
            return true;
        }
      } catch (e) {
        return false;
      }
    });
  }, [shifts, dateFilter, customDateRange]);

  const getDateFilterLabel = () => {
    switch (dateFilter) {
      case 'today':
        return 'Hoy';
      case 'yesterday':
        return 'Ayer';
      case 'last7':
        return '√öltimos 7 d√≠as';
      case 'custom':
        return `${format(customDateRange.start, 'dd/MM')} - ${format(customDateRange.end, 'dd/MM')}`;
      default:
        return '√öltimos 7 d√≠as';
    }
  };

  const handleDateChange = (event: any, selectedDate?: Date) => {
    setShowDatePicker(false);
    if (selectedDate) {
      if (datePickerMode === 'start') {
        setCustomDateRange({ ...customDateRange, start: selectedDate });
      } else {
        setCustomDateRange({ ...customDateRange, end: selectedDate });
      }
    }
  };

  const handleCustomDateRange = () => {
    setDateFilter('custom');
    setShowDateMenu(false);
    setShowDateRangePicker(true);
  };

  const handleViewOrders = (shift: Shift) => {
    setSelectedShiftId(String(shift.id));
    setSelectedShiftNumber(shift.globalShiftNumber || shift.shiftNumber);
    setShowOrdersModal(true);
  };

  const handleViewSalesSummary = (shift: Shift) => {
    setSelectedShiftId(String(shift.id));
    setSelectedShiftNumber(shift.globalShiftNumber || shift.shiftNumber);
    setShowSalesSummaryView(true);
  };

  const formatShiftDate = (dateString: string) => {
    try {
      const date = parseISO(dateString);
      return format(date, "d 'de' MMMM, yyyy", { locale: es });
    } catch {
      return dateString;
    }
  };

  const formatShiftTime = (dateString: string) => {
    try {
      const date = parseISO(dateString);
      return format(date, 'HH:mm', { locale: es });
    } catch {
      return dateString;
    }
  };

  const getShiftDuration = (openedAt: string, closedAt: string | null) => {
    if (!closedAt) return 'En curso';
    try {
      const start = parseISO(openedAt);
      const end = parseISO(closedAt);
      const diffInMinutes = Math.round(
        (end.getTime() - start.getTime()) / (1000 * 60),
      );
      const hours = Math.floor(diffInMinutes / 60);
      const minutes = diffInMinutes % 60;
      return `${hours}h ${minutes}m`;
    } catch {
      return 'N/A';
    }
  };

  const renderShiftItem = ({ item: shift }: { item: Shift }) => {
    const isOpen = shift.status === 'open';

    return (
      <Card
        style={[styles.shiftCard, isOpen && styles.openShiftCard]}
        mode="contained"
      >
        <Card.Content>
          <View style={styles.shiftHeader}>
            <View style={styles.shiftTitleRow}>
              <Text style={styles.shiftNumber}>
                Turno #{shift.globalShiftNumber || shift.shiftNumber || 'N/A'}
              </Text>
              <Chip
                mode="flat"
                icon={isOpen ? 'lock-open' : 'lock'}
                style={[
                  styles.statusChip,
                  {
                    backgroundColor: isOpen
                      ? theme.colors.primaryContainer
                      : theme.colors.surfaceVariant,
                  },
                ]}
                textStyle={[
                  styles.statusChipText,
                  {
                    color: isOpen
                      ? theme.colors.onPrimaryContainer
                      : theme.colors.onSurfaceVariant,
                  },
                ]}
                compact
              >
                {isOpen ? 'Abierto' : 'Cerrado'}
              </Chip>
            </View>
            <Text style={styles.shiftDate}>
              {shift.openedAt
                ? formatShiftDate(shift.openedAt)
                : 'Fecha no disponible'}
            </Text>
          </View>

          <Divider style={styles.divider} />

          <View style={styles.shiftDetails}>
            {/* Secci√≥n de tiempo y estad√≠sticas en una sola l√≠nea */}
            <View style={styles.timeSection}>
              <View style={{ flex: 1 }}>
                <Text style={styles.timeText}>
                  {shift.openedAt ? formatShiftTime(shift.openedAt) : 'N/A'} -{' '}
                  {shift.closedAt
                    ? formatShiftTime(shift.closedAt)
                    : 'En curso'}
                </Text>
                <Text style={styles.durationText}>
                  {shift.openedAt
                    ? getShiftDuration(shift.openedAt, shift.closedAt)
                    : 'N/A'}
                </Text>
              </View>
            </View>

            {/* Estad√≠sticas m√°s compactas */}
            <View style={styles.statsSection}>
              <Surface style={styles.statCard} elevation={0}>
                <Text style={styles.statLabel}>VENTAS</Text>
                <Text style={styles.statValue}>
                  {formatCurrency(shift.totalSales)}
                </Text>
              </Surface>

              <Surface style={styles.statCard} elevation={0}>
                <Text style={styles.statLabel}>√ìRDENES</Text>
                <Text style={styles.statValue}>{shift.totalOrders || 0}</Text>
              </Surface>
            </View>

            {/* Secci√≥n de efectivo m√°s compacta */}
            <View style={styles.cashSection}>
              <View style={styles.cashRow}>
                <Text style={styles.cashLabel}>Inicial</Text>
                <Text style={styles.cashValue}>
                  {formatCurrency(shift.initialCash)}
                </Text>
              </View>
              {shift.finalCash !== null && (
                <>
                  <View style={styles.cashRow}>
                    <Text style={styles.cashLabel}>Final</Text>
                    <Text style={styles.cashValue}>
                      {formatCurrency(shift.finalCash)}
                    </Text>
                  </View>
                  <View style={styles.cashRow}>
                    <Text style={[styles.cashLabel, styles.differenceLabel]}>
                      Diferencia
                    </Text>
                    <Text
                      style={[
                        styles.cashValue,
                        styles.differenceValue,
                        {
                          color:
                            shift.finalCash - shift.initialCash >= 0
                              ? theme.colors.tertiary
                              : theme.colors.error,
                        },
                      ]}
                    >
                      {formatCurrency(shift.finalCash - shift.initialCash)}
                    </Text>
                  </View>
                </>
              )}
            </View>

            {/* Usuarios en una l√≠nea */}
            <View style={styles.userSection}>
              <Text style={styles.userText}>
                üë§ {shift.openedBy?.firstName || 'N/A'}{' '}
                {shift.openedBy?.lastName || ''}
              </Text>
              {shift.closedBy && (
                <Text style={styles.userText}>
                  üîí {shift.closedBy.firstName || 'N/A'}{' '}
                  {shift.closedBy.lastName || ''}
                </Text>
              )}
            </View>

            {/* Botones de acciones */}
            <View style={styles.actionButtonsContainer}>
              <Button
                mode="contained-tonal"
                onPress={() => handleViewOrders(shift)}
                icon="receipt"
                style={[styles.actionButton, styles.ordersButton]}
                labelStyle={styles.actionButtonLabel}
                contentStyle={styles.actionButtonContent}
                compact
              >
                √ìrdenes ({shift.totalOrders || 0})
              </Button>
              <Button
                mode="contained-tonal"
                onPress={() => handleViewSalesSummary(shift)}
                icon="chart-bar"
                style={[styles.actionButton, styles.summaryButton]}
                labelStyle={styles.actionButtonLabel}
                contentStyle={styles.actionButtonContent}
                compact
              >
                Resumen
              </Button>
            </View>
          </View>
        </Card.Content>
      </Card>
    );
  };

  const renderFilters = () => (
    <Surface style={styles.filterContainer} elevation={1}>
      <View style={styles.filterContent}>
        <Menu
          visible={showDateMenu}
          onDismiss={() => setShowDateMenu(false)}
          anchor={
            <TouchableOpacity
              style={styles.filterButton}
              onPress={() => setShowDateMenu(true)}
              activeOpacity={0.8}
            >
              <Avatar.Icon
                icon="calendar-range"
                size={32}
                style={styles.filterIcon}
                color={theme.colors.primary}
              />
              <View style={styles.filterTextContainer}>
                <Text style={styles.filterLabel}>Filtrar por fecha</Text>
                <Text style={styles.filterValue}>{getDateFilterLabel()}</Text>
              </View>
              <Avatar.Icon
                icon="chevron-down"
                size={24}
                style={styles.filterArrow}
                color={theme.colors.onSurfaceVariant}
              />
            </TouchableOpacity>
          }
          contentStyle={styles.menuContent}
        >
          <Menu.Item
            onPress={() => {
              setDateFilter('today');
              setShowDateMenu(false);
            }}
            title="Hoy"
            leadingIcon="calendar-today"
            style={dateFilter === 'today' && styles.selectedMenuItem}
          />
          <Menu.Item
            onPress={() => {
              setDateFilter('yesterday');
              setShowDateMenu(false);
            }}
            title="Ayer"
            leadingIcon="calendar-minus"
            style={dateFilter === 'yesterday' && styles.selectedMenuItem}
          />
          <Menu.Item
            onPress={() => {
              setDateFilter('last7');
              setShowDateMenu(false);
            }}
            title="√öltimos 7 d√≠as"
            leadingIcon="calendar-week"
            style={dateFilter === 'last7' && styles.selectedMenuItem}
          />
          <Divider />
          <Menu.Item
            onPress={handleCustomDateRange}
            title="Rango personalizado"
            leadingIcon="calendar-range"
            style={dateFilter === 'custom' && styles.selectedMenuItem}
          />
        </Menu>
      </View>

      {/* Modal para selecci√≥n de rango de fechas */}
      <Modal
        visible={showDateRangePicker}
        transparent
        animationType="fade"
        onRequestClose={() => setShowDateRangePicker(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            {/* Header del modal */}
            <View style={styles.modalHeader}>
              <Avatar.Icon
                icon="calendar-range"
                size={48}
                style={styles.modalIcon}
                color={theme.colors.primary}
              />
              <Text style={styles.modalTitle}>Seleccionar rango</Text>
              <IconButton
                icon="close"
                onPress={() => setShowDateRangePicker(false)}
                size={20}
                style={styles.modalCloseButton}
                iconColor={theme.colors.onSurfaceVariant}
              />
            </View>

            {/* Selecci√≥n de fechas */}
            <View style={styles.dateRangeContainer}>
              <TouchableOpacity
                style={styles.dateButton}
                onPress={() => {
                  setDatePickerMode('start');
                  setShowDatePicker(true);
                }}
                activeOpacity={0.8}
              >
                <View style={styles.dateButtonContent}>
                  <Avatar.Icon
                    icon="calendar-start"
                    size={36}
                    style={styles.dateButtonIcon}
                    color={theme.colors.primary}
                  />
                  <View style={styles.dateButtonTextContainer}>
                    <Text style={styles.dateButtonLabel}>DESDE</Text>
                    <Text style={styles.dateButtonValue}>
                      {format(customDateRange.start, 'd MMM yyyy', {
                        locale: es,
                      })}
                    </Text>
                  </View>
                </View>
              </TouchableOpacity>

              <View style={styles.dateArrowContainer}>
                <Avatar.Icon
                  icon="arrow-right"
                  size={20}
                  style={styles.dateArrow}
                  color={theme.colors.primary}
                />
              </View>

              <TouchableOpacity
                style={styles.dateButton}
                onPress={() => {
                  setDatePickerMode('end');
                  setShowDatePicker(true);
                }}
                activeOpacity={0.8}
              >
                <View style={styles.dateButtonContent}>
                  <Avatar.Icon
                    icon="calendar-end"
                    size={36}
                    style={styles.dateButtonIcon}
                    color={theme.colors.primary}
                  />
                  <View style={styles.dateButtonTextContainer}>
                    <Text style={styles.dateButtonLabel}>HASTA</Text>
                    <Text style={styles.dateButtonValue}>
                      {format(customDateRange.end, 'd MMM yyyy', {
                        locale: es,
                      })}
                    </Text>
                  </View>
                </View>
              </TouchableOpacity>
            </View>

            {/* Botones de acci√≥n */}
            <View style={styles.modalActions}>
              <Button
                mode="outlined"
                onPress={() => setShowDateRangePicker(false)}
                style={styles.modalButton}
                labelStyle={styles.modalButtonLabel}
              >
                Cancelar
              </Button>
              <Button
                mode="contained"
                onPress={() => {
                  setDateFilter('custom');
                  setShowDateRangePicker(false);
                }}
                style={[styles.modalButton, styles.modalButtonPrimary]}
                labelStyle={styles.modalButtonLabel}
              >
                Aplicar filtro
              </Button>
            </View>
          </View>
        </View>
      </Modal>

      {showDatePicker && (
        <DateTimePicker
          value={
            datePickerMode === 'start'
              ? customDateRange.start
              : customDateRange.end
          }
          mode="date"
          display="default"
          onChange={handleDateChange}
          maximumDate={new Date()}
        />
      )}
    </Surface>
  );

  const renderEmpty = () => (
    <View style={styles.emptyContainer}>
      <Avatar.Icon
        icon="history"
        size={80}
        style={{ backgroundColor: theme.colors.surfaceVariant }}
        color={theme.colors.onSurfaceVariant}
      />
      <Text style={styles.emptyTitle}>No se encontraron turnos</Text>
      <Text style={styles.emptyMessage}>
        {dateFilter === 'custom'
          ? 'No hay turnos en el rango seleccionado'
          : 'Prueba seleccionando otro rango de fechas'}
      </Text>
    </View>
  );

  const renderError = () => (
    <View style={styles.errorContainer}>
      <Avatar.Icon
        icon="alert-circle-outline"
        size={80}
        style={{ backgroundColor: theme.colors.errorContainer }}
        color={theme.colors.error}
      />
      <Text style={styles.errorTitle}>Error al cargar turnos</Text>
      <Text style={styles.errorMessage}>
        {error?.message || 'No se pudieron cargar los turnos'}
      </Text>
      <Button mode="contained" onPress={refetch} style={styles.retryButton}>
        Reintentar
      </Button>
    </View>
  );

  const renderLoading = () => (
    <View style={styles.loadingContainer}>
      <ActivityIndicator size="large" />
      <Text style={styles.loadingText}>Cargando turnos...</Text>
    </View>
  );

  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    filterContainer: {
      backgroundColor: theme.colors.surface,
      marginHorizontal: theme.spacing.m,
      marginVertical: theme.spacing.s,
      borderRadius: theme.roundness * 2,
      elevation: 1,
    },
    filterContent: {
      padding: theme.spacing.s,
    },
    filterButton: {
      flexDirection: 'row',
      alignItems: 'center',
      padding: theme.spacing.s,
      borderRadius: theme.roundness,
    },
    filterIcon: {
      backgroundColor: theme.colors.primaryContainer,
      marginRight: theme.spacing.m,
    },
    filterTextContainer: {
      flex: 1,
    },
    filterLabel: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 2,
    },
    filterValue: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    filterArrow: {
      backgroundColor: 'transparent',
    },
    menuContent: {
      backgroundColor: theme.colors.surface,
      marginTop: 40,
      minWidth: 200,
    },
    selectedMenuItem: {
      backgroundColor: theme.colors.primaryContainer,
    },
    modalOverlay: {
      flex: 1,
      backgroundColor: 'rgba(0, 0, 0, 0.4)',
      justifyContent: 'center',
      alignItems: 'center',
    },
    modalContent: {
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness * 4,
      marginHorizontal: theme.spacing.xl,
      width: '90%',
      maxWidth: 380,
      elevation: 8,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 4 },
      shadowOpacity: 0.15,
      shadowRadius: 12,
      borderWidth: 2,
      borderColor: theme.colors.outline,
    },
    modalHeader: {
      alignItems: 'center',
      paddingTop: theme.spacing.xl,
      paddingHorizontal: theme.spacing.l,
      paddingBottom: theme.spacing.m,
      position: 'relative',
    },
    modalIcon: {
      backgroundColor: theme.colors.primaryContainer,
      marginBottom: theme.spacing.m,
    },
    modalTitle: {
      fontSize: 22,
      fontWeight: '600',
      color: theme.colors.onSurface,
      textAlign: 'center',
    },
    modalCloseButton: {
      position: 'absolute',
      top: theme.spacing.s,
      right: theme.spacing.s,
    },
    dateRangeContainer: {
      paddingHorizontal: theme.spacing.l,
      paddingVertical: theme.spacing.l,
      flexDirection: 'column',
      gap: theme.spacing.m,
    },
    dateButton: {
      backgroundColor: theme.colors.background,
      borderRadius: theme.roundness * 2,
      borderWidth: 1.5,
      borderColor: theme.colors.outline,
      overflow: 'hidden',
      elevation: 1,
    },
    dateButtonContent: {
      flexDirection: 'row',
      alignItems: 'center',
      padding: theme.spacing.m,
      gap: theme.spacing.m,
    },
    dateButtonIcon: {
      backgroundColor: theme.colors.primaryContainer,
    },
    dateButtonTextContainer: {
      flex: 1,
    },
    dateButtonLabel: {
      fontSize: 10,
      fontWeight: '700',
      color: theme.colors.onSurfaceVariant,
      letterSpacing: 1,
      marginBottom: 2,
    },
    dateButtonValue: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    dateArrowContainer: {
      alignSelf: 'center',
      paddingVertical: theme.spacing.xs,
    },
    dateArrow: {
      backgroundColor: theme.colors.surfaceVariant,
    },
    modalActions: {
      flexDirection: 'row',
      padding: theme.spacing.l,
      paddingTop: theme.spacing.m,
      gap: theme.spacing.m,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
    },
    modalButton: {
      flex: 1,
      borderRadius: theme.roundness * 2,
    },
    modalButtonPrimary: {
      elevation: 0,
    },
    modalButtonLabel: {
      fontSize: 14,
      fontWeight: '600',
      paddingVertical: 4,
    },
    listContent: {
      paddingBottom: theme.spacing.m,
    },
    shiftCard: {
      marginHorizontal: theme.spacing.m,
      marginVertical: theme.spacing.xs,
      backgroundColor: theme.colors.surface,
    },
    openShiftCard: {
      backgroundColor: theme.colors.primaryContainer,
    },
    shiftHeader: {
      marginBottom: theme.spacing.s,
    },
    shiftTitleRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
      marginBottom: 2,
    },
    shiftNumber: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
      flex: 1,
    },
    shiftDate: {
      fontSize: 13,
      color: theme.colors.onSurfaceVariant,
    },
    statusChip: {
      marginLeft: 'auto',
    },
    statusChipText: {
      fontWeight: '600',
      fontSize: 11,
    },
    divider: {
      marginVertical: theme.spacing.s,
    },
    shiftDetails: {
      gap: theme.spacing.s,
    },
    timeSection: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    label: {
      fontSize: 11,
      color: theme.colors.onSurfaceVariant,
      fontWeight: '500',
      textTransform: 'uppercase',
    },
    timeText: {
      fontSize: 14,
      color: theme.colors.onSurface,
    },
    durationText: {
      fontSize: 13,
      color: theme.colors.onSurfaceVariant,
    },
    statsSection: {
      flexDirection: 'row',
      gap: theme.spacing.s,
    },
    statCard: {
      flex: 1,
      padding: theme.spacing.s,
      borderRadius: theme.roundness,
      backgroundColor: theme.colors.surfaceVariant,
      alignItems: 'center',
      gap: 2,
    },
    statLabel: {
      fontSize: 10,
      color: theme.colors.onSurfaceVariant,
      textTransform: 'uppercase',
      letterSpacing: 0.3,
    },
    statValue: {
      fontSize: 15,
      fontWeight: '700',
      color: theme.colors.onSurface,
    },
    cashSection: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      padding: theme.spacing.s,
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: theme.roundness,
    },
    cashRow: {
      alignItems: 'center',
    },
    cashLabel: {
      fontSize: 11,
      color: theme.colors.onSurfaceVariant,
    },
    cashValue: {
      fontSize: 14,
      fontWeight: '600',
      color: theme.colors.onSurface,
      marginTop: 2,
    },
    differenceLabel: {
      fontWeight: '600',
    },
    differenceValue: {
      fontWeight: '700',
    },
    userSection: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      marginTop: theme.spacing.xs,
    },
    userText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
    },
    actionButtonsContainer: {
      flexDirection: 'row',
      marginTop: theme.spacing.s,
      gap: theme.spacing.s,
    },
    actionButton: {
      flex: 1,
      borderRadius: theme.roundness,
    },
    ordersButton: {
      // Estilo espec√≠fico para el bot√≥n de √≥rdenes si es necesario
    },
    summaryButton: {
      // Estilo espec√≠fico para el bot√≥n de resumen si es necesario
    },
    actionButtonLabel: {
      fontSize: 12,
      fontWeight: '600',
    },
    actionButtonContent: {
      paddingHorizontal: theme.spacing.xs,
    },
    emptyContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.xl,
      gap: theme.spacing.l,
    },
    emptyTitle: {
      fontSize: 20,
      fontWeight: '600',
      color: theme.colors.onSurface,
      textAlign: 'center',
    },
    emptyMessage: {
      fontSize: 16,
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
    },
    errorContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.xl,
      gap: theme.spacing.l,
    },
    errorTitle: {
      fontSize: 20,
      fontWeight: '600',
      color: theme.colors.error,
      textAlign: 'center',
    },
    errorMessage: {
      fontSize: 16,
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
    },
    retryButton: {
      marginTop: theme.spacing.m,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      gap: theme.spacing.m,
    },
    loadingText: {
      fontSize: 16,
      color: theme.colors.onSurfaceVariant,
    },
  });

  // Renderizado principal
  if ((isLoading || isRefetching) && !shifts) {
    return (
      <SafeAreaView style={styles.container} edges={['bottom']}>
        {renderLoading()}
      </SafeAreaView>
    );
  }

  if (error && !shifts) {
    return (
      <SafeAreaView style={styles.container} edges={['bottom']}>
        {renderError()}
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView style={styles.container} edges={['bottom']}>
      <View style={styles.container}>
        {/* Filtros */}
        {renderFilters()}

        {/* Lista de turnos */}
        {filteredShifts.length === 0 ? (
          renderEmpty()
        ) : (
          <FlashList
            data={filteredShifts}
            renderItem={renderShiftItem}
            keyExtractor={(item) => item.id}
            estimatedItemSize={200}
            contentContainerStyle={styles.listContent}
            refreshControl={
              <RefreshControl
                refreshing={isRefreshing}
                onRefresh={handleRefresh}
                colors={[theme.colors.primary]}
              />
            }
          />
        )}

        {/* Modal de √≥rdenes del turno */}
        {selectedShiftId && !showSalesSummaryView && (
          <ShiftOrdersModal
            visible={showOrdersModal}
            onClose={() => {
              setShowOrdersModal(false);
              setSelectedShiftId(null);
              setSelectedShiftNumber(undefined);
            }}
            shiftId={selectedShiftId}
          />
        )}

        {/* Vista de resumen de ventas */}
        {showSalesSummaryView && selectedShiftId && (
          <Modal
            visible={showSalesSummaryView}
            animationType="slide"
            presentationStyle="fullScreen"
          >
            <ShiftSalesSummaryView
              shiftId={selectedShiftId}
              shiftNumber={selectedShiftNumber}
              onBack={() => {
                setShowSalesSummaryView(false);
                setSelectedShiftId(null);
                setSelectedShiftNumber(undefined);
              }}
            />
          </Modal>
        )}
      </View>
    </SafeAreaView>
  );
}

================
File: app/src/modules/users/components/UserFormModal.tsx
================
import React, { useEffect, useState } from 'react';
import { View, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';
import {
  Portal,
  Modal,
  Text,
  TextInput,
  Button,
  Switch,
  HelperText,
  Surface,
  IconButton,
  Chip,
  Avatar,
  Divider,
  Icon,
} from 'react-native-paper';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { z } from 'zod';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useCreateUser, useUpdateUser } from '../hooks';
import type { User } from '../types';

const createUserSchema = z.object({
  username: z
    .string()
    .min(3, 'El nombre de usuario debe tener al menos 3 caracteres')
    .max(20, 'El nombre de usuario no puede exceder 20 caracteres')
    .regex(/^[a-zA-Z0-9_]+$/, 'Solo se permiten letras, n√∫meros y gui√≥n bajo'),
  email: z
    .union([z.string().email('Email inv√°lido'), z.literal('')])
    .optional(),
  password: z.string().min(6, 'La contrase√±a debe tener al menos 6 caracteres'),
  firstName: z
    .string()
    .min(2, 'El nombre debe tener al menos 2 caracteres')
    .max(50, 'El nombre no puede exceder 50 caracteres'),
  lastName: z
    .string()
    .min(2, 'El apellido debe tener al menos 2 caracteres')
    .max(50, 'El apellido no puede exceder 50 caracteres'),
  phoneNumber: z
    .union([
      z.string().regex(/^\+?[0-9\s-]+$/, 'N√∫mero de tel√©fono inv√°lido'),
      z.literal(''),
    ])
    .optional(),
  gender: z.enum(['male', 'female', 'other']).nullable().optional(),
  address: z.string().optional(),
  city: z.string().optional(),
  state: z.string().optional(),
  country: z.string().optional(),
  zipCode: z.string().optional(),
  role: z.number(),
  isActive: z.boolean(),
});

const updateUserSchema = createUserSchema.omit({ password: true }).extend({
  password: z
    .union([
      z.string().min(6, 'La contrase√±a debe tener al menos 6 caracteres'),
      z.literal(''),
    ])
    .optional(),
});

type CreateUserFormInputs = z.infer<typeof createUserSchema>;
type UpdateUserFormInputs = z.infer<typeof updateUserSchema>;
type UserFormInputs = CreateUserFormInputs | UpdateUserFormInputs;

interface UserFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  user?: User | null;
}

export function UserFormModal({
  visible,
  onDismiss,
  user,
}: UserFormModalProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = getStyles(theme, responsive);
  const [showPassword, setShowPassword] = useState(false);

  const createUserMutation = useCreateUser();
  const updateUserMutation = useUpdateUser();

  const {
    control,
    handleSubmit,
    formState: { errors },
    reset,
  } = useForm<UserFormInputs>({
    resolver: zodResolver(user ? updateUserSchema : createUserSchema) as any,
    defaultValues: {
      username: '',
      email: '',
      password: '',
      firstName: '',
      lastName: '',
      phoneNumber: '',
      gender: undefined,
      address: '',
      city: '',
      state: '',
      country: '',
      zipCode: '',
      role: 2, // Default to MANAGER role
      isActive: true,
    },
  });

  useEffect(() => {
    if (user) {
      reset({
        username: user.username,
        email: user.email || '',
        password: '', // Never pre-fill password
        firstName: user.firstName || '',
        lastName: user.lastName || '',
        phoneNumber: user.phoneNumber || '',
        gender: user.gender || undefined, // Convert null to undefined
        address: user.address || '',
        city: user.city || '',
        state: user.state || '',
        country: user.country || '',
        zipCode: user.zipCode || '',
        role: user.role?.id || 2,
        isActive: user.isActive,
      });
    } else {
      reset({
        username: '',
        email: '',
        password: '',
        firstName: '',
        lastName: '',
        phoneNumber: '',
        gender: undefined,
        address: '',
        city: '',
        state: '',
        country: '',
        zipCode: '',
        role: 2,
        isActive: true,
      });
    }
  }, [user, reset]);

  const onSubmit = async (data: UserFormInputs) => {
    try {
      // Clean empty strings to undefined
      const cleanData = {
        username: data.username,
        email: data.email || undefined,
        password: data.password || undefined,
        firstName: data.firstName,
        lastName: data.lastName,
        phoneNumber: data.phoneNumber || undefined,
        gender: data.gender || undefined,
        address: data.address || undefined,
        city: data.city || undefined,
        state: data.state || undefined,
        country: data.country || undefined,
        zipCode: data.zipCode || undefined,
        role: { id: data.role },
        isActive: data.isActive,
      };

      if (user) {
        // For update, remove password if empty and remove username (can't be changed)
        const { username, password, ...updateData } = cleanData;
        const finalUpdateData = password
          ? { ...updateData, password }
          : updateData;

        await updateUserMutation.mutateAsync({
          id: user.id,
          data: finalUpdateData as any,
        });
      } else {
        // For create, password is required
        if (!data.password) {
          return; // Should be caught by validation
        }
        await createUserMutation.mutateAsync(cleanData as any);
      }
      onDismiss();
    } catch (error) {
      // Error handling is done in the mutation hooks
    }
  };

  const isSubmitting =
    createUserMutation.isPending || updateUserMutation.isPending;

  const genderOptions = [
    {
      value: 'male',
      label: 'Masculino',
      icon: 'gender-male',
      color: '#3498db',
    },
    {
      value: 'female',
      label: 'Femenino',
      icon: 'gender-female',
      color: '#e74c3c',
    },
    {
      value: 'other',
      label: 'Otro',
      icon: 'gender-transgender',
      color: '#9b59b6',
    },
  ];

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalContainer}
      >
        <Surface style={styles.modalContent} elevation={5}>
          <View
            style={[
              styles.headerContainer,
              { backgroundColor: theme.colors.primary },
            ]}
          >
            <View style={styles.headerLeft}>
              <Avatar.Icon
                size={32}
                icon={user ? 'account-edit' : 'account-plus'}
                style={[
                  styles.headerIcon,
                  { backgroundColor: theme.colors.onPrimary + '20' },
                ]}
                color={theme.colors.onPrimary}
              />
              <View style={styles.headerTextContainer}>
                <Text
                  style={[styles.modalTitle, { color: theme.colors.onPrimary }]}
                  variant="titleMedium"
                >
                  {user ? 'Editar Usuario' : 'Nuevo Usuario'}
                </Text>
              </View>
            </View>
            <IconButton
              icon="close"
              size={24}
              onPress={onDismiss}
              disabled={isSubmitting}
              iconColor={theme.colors.onPrimary}
            />
          </View>

          <ScrollView
            style={styles.formContainer}
            showsVerticalScrollIndicator={false}
            keyboardShouldPersistTaps="handled"
          >
            {/* Informaci√≥n de Cuenta */}
            <View style={styles.sectionContainer}>
              <View style={styles.sectionHeader}>
                <Icon
                  source="account-key"
                  size={20}
                  color={theme.colors.primary}
                />
                <Text style={styles.sectionTitle} variant="titleMedium">
                  Informaci√≥n de Cuenta
                </Text>
                <Chip
                  mode="flat"
                  compact
                  icon="check"
                  style={styles.requiredChip}
                  textStyle={styles.requiredChipText}
                >
                  Requerido
                </Chip>
              </View>

              <Controller
                control={control}
                name="username"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Nombre de usuario"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.username}
                      mode="outlined"
                      placeholder="usuario123"
                      left={<TextInput.Icon icon="account" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                      disabled={!!user} // Username can't be changed
                    />
                    {errors.username && (
                      <HelperText type="error" visible={!!errors.username}>
                        {errors.username.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />

              <Controller
                control={control}
                name="email"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Email (opcional)"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.email}
                      mode="outlined"
                      placeholder="usuario@ejemplo.com"
                      keyboardType="email-address"
                      autoCapitalize="none"
                      left={<TextInput.Icon icon="email" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.email && (
                      <HelperText type="error" visible={!!errors.email}>
                        {errors.email.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />

              <Controller
                control={control}
                name="password"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label={
                        user
                          ? 'Nueva contrase√±a (dejar vac√≠o para no cambiar)'
                          : 'Contrase√±a'
                      }
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.password}
                      mode="outlined"
                      placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                      secureTextEntry={!showPassword}
                      left={<TextInput.Icon icon="lock" />}
                      right={
                        <TextInput.Icon
                          icon={showPassword ? 'eye-off' : 'eye'}
                          onPress={() => setShowPassword(!showPassword)}
                        />
                      }
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.password && (
                      <HelperText type="error" visible={!!errors.password}>
                        {errors.password.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />

              <Controller
                control={control}
                name="role"
                render={({ field: { onChange, value } }) => (
                  <View style={styles.inputContainer}>
                    <View style={styles.fieldLabelContainer}>
                      <Icon
                        source="badge-account"
                        size={20}
                        color={theme.colors.primary}
                      />
                      <Text style={styles.sectionTitle} variant="titleMedium">
                        Rol del usuario
                      </Text>
                    </View>
                    <ScrollView
                      horizontal
                      showsHorizontalScrollIndicator={false}
                      style={{ marginTop: theme.spacing.s }}
                    >
                      <View style={styles.rolesContainer}>
                        {[
                          {
                            value: 1,
                            label: 'Admin',
                            icon: 'shield-account',
                            description: 'Acceso completo',
                          },
                          {
                            value: 2,
                            label: 'Gerente',
                            icon: 'account-tie',
                            description: 'Gesti√≥n general',
                          },
                          {
                            value: 3,
                            label: 'Cajero',
                            icon: 'cash-register',
                            description: 'Ventas',
                          },
                          {
                            value: 4,
                            label: 'Mesero',
                            icon: 'room-service',
                            description: '√ìrdenes',
                          },
                          {
                            value: 5,
                            label: 'Cocina',
                            icon: 'chef-hat',
                            description: 'Preparaci√≥n',
                          },
                          {
                            value: 6,
                            label: 'Repartidor',
                            icon: 'moped',
                            description: 'Entregas',
                          },
                        ].map((role) => (
                          <Surface
                            key={role.value}
                            style={[
                              styles.roleCard,
                              value === role.value && styles.roleCardActive,
                            ]}
                            elevation={value === role.value ? 2 : 0}
                          >
                            <TouchableOpacity
                              onPress={() => onChange(role.value)}
                              style={styles.roleCardContent}
                            >
                              <Icon
                                source={role.icon}
                                size={24}
                                color={
                                  value === role.value
                                    ? theme.colors.primary
                                    : theme.colors.onSurfaceVariant
                                }
                              />
                              <Text
                                style={[
                                  styles.roleLabel,
                                  value === role.value &&
                                    styles.roleLabelActive,
                                ]}
                                variant="labelMedium"
                              >
                                {role.label}
                              </Text>
                              <Text
                                style={styles.roleDescription}
                                variant="bodySmall"
                                numberOfLines={1}
                              >
                                {role.description}
                              </Text>
                            </TouchableOpacity>
                          </Surface>
                        ))}
                      </View>
                    </ScrollView>
                  </View>
                )}
              />
            </View>

            <Divider style={styles.divider} />

            {/* Informaci√≥n Personal */}
            <View style={styles.sectionContainer}>
              <View style={styles.sectionHeader}>
                <Icon
                  source="account-circle"
                  size={20}
                  color={theme.colors.primary}
                />
                <Text style={styles.sectionTitle} variant="titleMedium">
                  Informaci√≥n Personal
                </Text>
                <Chip
                  mode="flat"
                  compact
                  icon="check"
                  style={styles.requiredChip}
                  textStyle={styles.requiredChipText}
                >
                  Requerido
                </Chip>
              </View>

              <Controller
                control={control}
                name="firstName"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Nombre"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.firstName}
                      mode="outlined"
                      placeholder="Juan"
                      left={<TextInput.Icon icon="account" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.firstName && (
                      <HelperText type="error" visible={!!errors.firstName}>
                        {errors.firstName.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />

              <Controller
                control={control}
                name="lastName"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Apellido"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.lastName}
                      mode="outlined"
                      placeholder="P√©rez"
                      left={<TextInput.Icon icon="account" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.lastName && (
                      <HelperText type="error" visible={!!errors.lastName}>
                        {errors.lastName.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />

              <Controller
                control={control}
                name="gender"
                render={({ field: { onChange, value } }) => (
                  <View style={styles.inputContainer}>
                    <View style={styles.fieldLabelContainer}>
                      <Icon
                        source="gender-transgender"
                        size={20}
                        color={theme.colors.primary}
                      />
                      <Text style={styles.sectionTitle} variant="titleMedium">
                        G√©nero
                      </Text>
                    </View>
                    <View
                      style={[
                        styles.genderContainer,
                        { marginTop: theme.spacing.s },
                      ]}
                    >
                      {genderOptions.map((option) => (
                        <TouchableOpacity
                          key={option.value}
                          onPress={() => onChange(option.value)}
                          activeOpacity={0.7}
                        >
                          <Surface
                            style={[
                              styles.genderOption,
                              value === option.value &&
                                styles.genderOptionActive,
                            ]}
                            elevation={value === option.value ? 3 : 1}
                          >
                            <View
                              style={[
                                styles.genderIconContainer,
                                value === option.value && {
                                  backgroundColor: option.color + '20',
                                },
                              ]}
                            >
                              <Icon
                                source={option.icon}
                                size={20}
                                color={
                                  value === option.value
                                    ? option.color
                                    : theme.colors.onSurfaceVariant
                                }
                              />
                            </View>
                            <Text
                              style={[
                                styles.genderLabel,
                                value === option.value &&
                                  styles.genderLabelActive,
                              ]}
                              variant="labelMedium"
                            >
                              {option.label}
                            </Text>
                          </Surface>
                        </TouchableOpacity>
                      ))}
                    </View>
                  </View>
                )}
              />
            </View>

            <Divider style={styles.divider} />

            {/* Informaci√≥n de Contacto */}
            <View style={styles.sectionContainer}>
              <View style={styles.sectionHeader}>
                <Icon
                  source="phone-in-talk"
                  size={20}
                  color={theme.colors.primary}
                />
                <Text style={styles.sectionTitle} variant="titleMedium">
                  Informaci√≥n de Contacto
                </Text>
                <Chip
                  mode="flat"
                  compact
                  icon="information"
                  style={styles.optionalChip}
                  textStyle={styles.optionalChipText}
                >
                  Opcional
                </Chip>
              </View>

              <Controller
                control={control}
                name="phoneNumber"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Tel√©fono"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.phoneNumber}
                      mode="outlined"
                      placeholder="+52 55 1234 5678"
                      keyboardType="phone-pad"
                      left={<TextInput.Icon icon="phone" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.phoneNumber && (
                      <HelperText type="error" visible={!!errors.phoneNumber}>
                        {errors.phoneNumber.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />

              <Controller
                control={control}
                name="address"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Direcci√≥n"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      mode="outlined"
                      placeholder="Calle Principal #123"
                      left={<TextInput.Icon icon="map-marker" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                  </View>
                )}
              />

              <View style={styles.rowContainer}>
                <Controller
                  control={control}
                  name="city"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={[styles.inputContainer, styles.halfInput]}>
                      <TextInput
                        label="Ciudad"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        mode="outlined"
                        placeholder="Ciudad"
                        outlineStyle={styles.inputOutline}
                      />
                    </View>
                  )}
                />

                <Controller
                  control={control}
                  name="state"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={[styles.inputContainer, styles.halfInput]}>
                      <TextInput
                        label="Estado"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        mode="outlined"
                        placeholder="Estado"
                        outlineStyle={styles.inputOutline}
                      />
                    </View>
                  )}
                />
              </View>

              <View style={styles.rowContainer}>
                <Controller
                  control={control}
                  name="country"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={[styles.inputContainer, styles.halfInput]}>
                      <TextInput
                        label="Pa√≠s"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        mode="outlined"
                        placeholder="M√©xico"
                        outlineStyle={styles.inputOutline}
                      />
                    </View>
                  )}
                />

                <Controller
                  control={control}
                  name="zipCode"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={[styles.inputContainer, styles.halfInput]}>
                      <TextInput
                        label="C√≥digo Postal"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        mode="outlined"
                        placeholder="12345"
                        keyboardType="number-pad"
                        outlineStyle={styles.inputOutline}
                      />
                    </View>
                  )}
                />
              </View>
            </View>

            <Divider style={styles.divider} />

            {/* Estado de la cuenta */}
            <View style={styles.sectionContainer}>
              <View style={styles.sectionHeader}>
                <Icon
                  source="shield-check"
                  size={20}
                  color={theme.colors.primary}
                />
                <Text style={styles.sectionTitle} variant="titleMedium">
                  Estado de la cuenta
                </Text>
              </View>

              <Controller
                control={control}
                name="isActive"
                render={({ field: { onChange, value } }) => (
                  <Surface style={styles.switchContainer} elevation={1}>
                    <View style={styles.switchContent}>
                      <View style={styles.switchTextContainer}>
                        <Text style={styles.switchLabel} variant="bodyLarge">
                          Usuario activo
                        </Text>
                        <Text
                          style={styles.switchDescription}
                          variant="bodySmall"
                        >
                          Los usuarios inactivos no pueden iniciar sesi√≥n
                        </Text>
                      </View>
                      <Switch
                        value={value}
                        onValueChange={onChange}
                        color={theme.colors.primary}
                      />
                    </View>
                  </Surface>
                )}
              />
            </View>

            {/* Espacio adicional para el teclado */}
            <View style={{ height: 10 }} />
          </ScrollView>

          <Surface style={styles.buttonContainer} elevation={2}>
            <Button
              onPress={onDismiss}
              disabled={isSubmitting}
              style={[styles.button, styles.cancelButton]}
              textColor={theme.colors.onSecondaryContainer}
            >
              Cancelar
            </Button>
            <Button
              mode="contained"
              onPress={handleSubmit(onSubmit as any)}
              disabled={isSubmitting}
              loading={isSubmitting}
              style={[styles.button, styles.confirmButton]}
              buttonColor={theme.colors.primary}
            >
              {user ? 'Guardar' : 'Crear'}
            </Button>
          </Surface>
        </Surface>
      </Modal>
    </Portal>
  );
}

const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    modalContainer: {
      margin: responsive.isTablet ? theme.spacing.xl : theme.spacing.m,
      maxWidth: responsive.isTablet ? 700 : 420,
      alignSelf: 'center',
      width: responsive.isTablet ? '85%' : '92%',
      paddingHorizontal: 0,
      height: responsive.isTablet ? '85%' : '80%',
      maxHeight: responsive.isTablet ? '90%' : '85%',
      justifyContent: 'center',
    },
    modalContent: {
      borderRadius: theme.roundness * 3,
      backgroundColor: theme.colors.surface,
      height: '100%',
      flex: 1,
      overflow: 'hidden',
      elevation: 5,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
    },
    headerContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingHorizontal: responsive.isTablet
        ? theme.spacing.l
        : theme.spacing.m,
      paddingVertical: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
      borderTopLeftRadius: theme.roundness * 3,
      borderTopRightRadius: theme.roundness * 3,
    },
    headerLeft: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
    },
    headerIcon: {
      marginRight: theme.spacing.s,
    },
    headerTextContainer: {
      flex: 1,
    },
    modalTitle: {
      fontWeight: '700',
    },
    formContainer: {
      flex: 1,
      paddingHorizontal: responsive.isTablet
        ? theme.spacing.l
        : theme.spacing.m,
      paddingTop: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
      paddingBottom: responsive.isTablet ? theme.spacing.l : theme.spacing.s,
    },
    sectionContainer: {
      marginBottom: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
    },
    sectionHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: theme.spacing.xs,
      gap: theme.spacing.xs,
    },
    sectionTitle: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: 14,
      flex: 1,
    },
    requiredChip: {
      backgroundColor: theme.colors.primary + '20',
      borderWidth: 1,
      borderColor: theme.colors.primary + '40',
    },
    requiredChipText: {
      color: theme.colors.primary,
      fontSize: 11,
      fontWeight: '600',
    },
    optionalChip: {
      backgroundColor: theme.colors.surfaceVariant,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
    },
    optionalChipText: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 11,
    },
    inputContainer: {
      marginBottom: theme.spacing.xs,
    },
    inputOutline: {
      borderRadius: theme.roundness * 2,
      borderWidth: 1,
    },
    input: {
      fontSize: 14,
      backgroundColor: theme.colors.surface,
      height: 48,
    },
    inputContent: {
      paddingVertical: 4,
      fontSize: 14,
      fontFamily: 'System',
    },
    fieldLabel: {
      color: theme.colors.onSurfaceVariant,
      marginBottom: theme.spacing.xs,
      fontWeight: '600',
      fontSize: 12,
      letterSpacing: 0.4,
      textTransform: 'uppercase',
      fontFamily: 'System',
    },
    fieldLabelContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
      marginBottom: theme.spacing.s,
    },
    segmentedButtons: {
      marginTop: theme.spacing.xs,
    },
    genderContainer: {
      flexDirection: 'row',
      gap: theme.spacing.s,
      flexWrap: 'wrap',
    },
    genderOption: {
      borderRadius: theme.roundness * 2,
      padding: theme.spacing.s,
      alignItems: 'center',
      backgroundColor: theme.colors.surface,
      minWidth: 85,
      borderWidth: 1.5,
      borderColor: theme.colors.outlineVariant,
    },
    genderOptionActive: {
      backgroundColor: theme.colors.primaryContainer,
      borderColor: theme.colors.primary,
    },
    genderIconContainer: {
      width: 36,
      height: 36,
      borderRadius: 18,
      alignItems: 'center',
      justifyContent: 'center',
      marginBottom: theme.spacing.xs,
    },
    genderLabel: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 11,
      textAlign: 'center',
    },
    genderLabelActive: {
      color: theme.colors.onPrimaryContainer,
      fontWeight: '600',
    },
    rowContainer: {
      flexDirection: 'row',
      gap: theme.spacing.s,
    },
    halfInput: {
      flex: 1,
    },
    switchContainer: {
      borderRadius: theme.roundness * 2,
      padding: theme.spacing.s,
      backgroundColor: theme.colors.primaryContainer + '20',
      borderWidth: 1,
      borderColor: theme.colors.primary + '30',
    },
    switchContent: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    switchTextContainer: {
      flex: 1,
      marginRight: theme.spacing.m,
    },
    switchLabel: {
      color: theme.colors.onSurface,
      fontWeight: '500',
    },
    switchDescription: {
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
    },
    divider: {
      marginVertical: theme.spacing.s,
      marginHorizontal: -theme.spacing.m,
    },
    buttonContainer: {
      flexDirection: 'row',
      justifyContent: 'center',
      padding: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      gap: theme.spacing.s,
    },
    button: {
      flex: 1,
      maxWidth: responsive.isTablet ? 180 : 150,
    },
    cancelButton: {
      backgroundColor: theme.colors.secondaryContainer,
    },
    confirmButton: {},
    rolesContainer: {
      flexDirection: 'row',
      gap: theme.spacing.s,
      paddingVertical: theme.spacing.xs,
    },
    roleCard: {
      borderRadius: theme.roundness * 2,
      padding: theme.spacing.s,
      backgroundColor: theme.colors.surface,
      marginRight: theme.spacing.xs,
      minWidth: 90,
      borderWidth: 1.5,
      borderColor: theme.colors.outlineVariant,
      elevation: 1,
    },
    roleCardActive: {
      backgroundColor: theme.colors.primaryContainer,
      borderColor: theme.colors.primary,
      elevation: 3,
    },
    roleCardContent: {
      alignItems: 'center',
    },
    roleLabel: {
      color: theme.colors.onSurfaceVariant,
      marginTop: theme.spacing.xs,
      fontWeight: '500',
    },
    roleLabelActive: {
      color: theme.colors.onPrimaryContainer,
      fontWeight: '700',
    },
    roleDescription: {
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
      fontSize: 10,
      textAlign: 'center',
    },
  });

================
File: app/src/services/healthMonitoringService.ts
================
import axios from 'axios';
import { discoveryService } from '@/app/services/discoveryService';
import EventEmitter from 'eventemitter3';
import { NETWORK_CONFIG } from '@/app/constants/network';
import { API_PATHS } from '@/app/constants/apiPaths';

export type HealthStatus = 'ok' | 'error' | 'checking';

export interface HealthState {
  status: HealthStatus;
  isAvailable: boolean;
  message?: string;
}

class HealthMonitoringService extends EventEmitter {
  private state: HealthState = {
    status: 'checking',
    isAvailable: false,
  };

  private checkInterval: NodeJS.Timeout | null = null;
  private retryTimeout: NodeJS.Timeout | null = null;
  private isChecking = false;
  private retryCount = 0;

  constructor() {
    super();
  }

  // Obtener estado actual
  getState(): HealthState {
    return { ...this.state };
  }

  // Verificar si est√° monitoreando
  isMonitoring(): boolean {
    return this.checkInterval !== null;
  }

  // Iniciar monitoreo peri√≥dico
  startMonitoring() {
    this.stopMonitoring(); // Detener cualquier monitoreo previo

    // Reset retry count al iniciar monitoreo nuevo
    this.retryCount = 0;

    // Verificar inmediatamente
    this.checkHealth();

    // Configurar intervalo normal
    this.checkInterval = setInterval(() => {
      this.checkHealth();
    }, NETWORK_CONFIG.HEALTH_CHECK_INTERVAL);
  }

  // Detener monitoreo
  stopMonitoring() {
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
    }

    if (this.retryTimeout) {
      clearTimeout(this.retryTimeout);
      this.retryTimeout = null;
    }
  }

  // Verificar salud del backend
  async checkHealth(): Promise<boolean> {
    if (this.isChecking) {
      return this.state.isAvailable;
    }

    this.isChecking = true;

    try {
      let apiUrl: string;
      try {
        // Usar getLastKnownUrl que NO hace verificaci√≥n con discovery
        const lastKnownUrl = await discoveryService.getLastKnownUrl();
        if (!lastKnownUrl) {
          throw new Error('No hay servidor configurado');
        }
        apiUrl = lastKnownUrl;
      } catch (error) {
        // Si no hay URL configurada, marcar como no disponible
        this.updateState({
          status: 'error',
          isAvailable: false,
          message: 'Servidor no configurado',
        });
        this.isChecking = false;
        return false;
      }

      // Asegurar que la URL NO termine con /
      const baseUrl = apiUrl.endsWith('/') ? apiUrl.slice(0, -1) : apiUrl;
      const healthUrl = `${baseUrl}${API_PATHS.HEALTH}`;

      const response = await axios.get(healthUrl, {
        timeout: NETWORK_CONFIG.HEALTH_CHECK_TIMEOUT,
      });

      if (response.data.status === 'ok') {
        // Backend est√° saludable
        const wasUnavailable = !this.state.isAvailable;

        this.updateState({
          status: 'ok',
          isAvailable: true,
          message: 'Conectado al servidor',
        });

        // Si pasamos de no disponible a disponible, emitir evento adicional
        if (wasUnavailable) {
          // Emitir evento de recuperaci√≥n despu√©s de un peque√±o delay
          setTimeout(() => {
            this.emit('recovered');
          }, 100);
        }

        // Reset retry count en conexi√≥n exitosa
        this.retryCount = 0;

        // Limpiar retry timeout si existe
        if (this.retryTimeout) {
          clearTimeout(this.retryTimeout);
          this.retryTimeout = null;
        }

        this.isChecking = false; // Importante: marcar como no checking antes de retornar
        return true;
      } else {
        throw new Error('Backend returned unhealthy status');
      }
    } catch (error: any) {
      // Solo marcar como error si no es un problema temporal
      const isTemporaryError = this.isTemporaryError(error);

      this.updateState({
        status: 'error',
        isAvailable: false,
        message: this.getErrorMessage(error),
      });

      // Si es un error temporal y tenemos menos de 3 reintentos, programar reintento r√°pido
      if (isTemporaryError && this.retryCount < 3) {
        this.scheduleRetry();
      }

      this.isChecking = false;
      return false;
    }
  }

  // Programar reintento con backoff
  private scheduleRetry() {
    // Limpiar timeout existente
    if (this.retryTimeout) {
      clearTimeout(this.retryTimeout);
    }

    // Obtener intervalo de reintento
    const retryInterval =
      NETWORK_CONFIG.HEALTH_RETRY_INTERVALS[
        Math.min(
          this.retryCount,
          NETWORK_CONFIG.HEALTH_RETRY_INTERVALS.length - 1,
        )
      ];

    this.retryTimeout = setTimeout(() => {
      this.retryCount++;
      this.checkHealth();
    }, retryInterval);
  }

  private updateState(newState: HealthState) {
    this.state = newState;
    this.emit('stateChange', this.state);
  }

  // Detectar si es un error temporal
  private isTemporaryError(error: any): boolean {
    return (
      error.code === 'ECONNABORTED' ||
      error.code === 'ETIMEDOUT' ||
      error.message?.includes('timeout') ||
      error.code === 'ECONNRESET'
    );
  }

  // Obtener mensaje de error amigable
  private getErrorMessage(error: any): string {
    if (error.code === 'ECONNABORTED' || error.message?.includes('timeout')) {
      return 'Tiempo de espera agotado';
    }
    if (error.code === 'ENOTFOUND' || error.code === 'ECONNREFUSED') {
      return 'No se puede conectar al servidor';
    }
    if (error.message?.includes('No API URL')) {
      return 'Servidor no encontrado';
    }
    if (error.message?.includes('Servidor no configurado')) {
      return 'Servidor no configurado';
    }
    return 'Error de conexi√≥n';
  }

  // Suscribirse a cambios
  subscribe(callback: (state: HealthState) => void): () => void {
    this.on('stateChange', callback);

    // Llamar inmediatamente con el estado actual
    callback(this.state);

    // Retornar funci√≥n para desuscribirse
    return () => {
      this.off('stateChange', callback);
    };
  }

  // Verificar salud con URL espec√≠fica (sin actualizar estado interno)
  async checkHealthWithUrl(apiUrl: string): Promise<boolean> {
    try {
      // Asegurar que la URL NO termine con /
      const baseUrl = apiUrl.endsWith('/') ? apiUrl.slice(0, -1) : apiUrl;
      const healthUrl = `${baseUrl}${API_PATHS.HEALTH}`;

      const response = await axios.get(healthUrl, {
        timeout: NETWORK_CONFIG.HEALTH_CHECK_TIMEOUT,
      });

      return response.data.status === 'ok';
    } catch (error) {
      return false;
    }
  }

  // Forzar verificaci√≥n inmediata
  async forceCheck(): Promise<boolean> {
    this.retryCount = 0; // Reset retry count
    const result = await this.checkHealth();

    // Forzar emisi√≥n del estado actual despu√©s del check
    // Esto asegura que todos los componentes se actualicen
    this.emit('stateChange', this.state);

    return result;
  }
}

// Singleton
export const healthMonitoringService = new HealthMonitoringService();

================
File: app/src/app/components/ShiftIndicator.tsx
================
import React, { useState } from 'react';
import { TouchableOpacity, StyleSheet, Text } from 'react-native';
import { Icon, Badge } from 'react-native-paper';
import { useAppTheme } from '../styles/theme';
import { useAuthStore } from '../store/authStore';
import { canOpenShift } from '../utils/roleUtils';
import { OpenShiftModal } from '@/modules/orders/components/OpenShiftModal';
import { ShiftStatusModal } from '@/modules/orders/components/ShiftStatusModal';
import { CloseShiftModal } from '@/modules/orders/components/CloseShiftModal';
import { useGlobalShift } from '../hooks/useGlobalShift';
import { useQueryClient } from '@tanstack/react-query';

export const ShiftIndicator: React.FC = () => {
  const theme = useAppTheme();
  const user = useAuthStore((state) => state.user);
  const queryClient = useQueryClient();

  const { data: shift, isLoading: loading, refetch } = useGlobalShift();

  const [statusModalVisible, setStatusModalVisible] = useState(false);
  const [openShiftModalVisible, setOpenShiftModalVisible] = useState(false);
  const [closeShiftModalVisible, setCloseShiftModalVisible] = useState(false);

  const userCanOpenShift = canOpenShift(user);
  const isShiftOpen = shift && shift.status === 'OPEN';

  const handlePress = () => {
    // No refrescamos aqu√≠ porque ya se actualiza autom√°ticamente
    setStatusModalVisible(true);
  };

  const handleOpenShift = () => {
    setStatusModalVisible(false);
    setOpenShiftModalVisible(true);
  };

  const handleCloseShift = () => {
    setStatusModalVisible(false);
    setCloseShiftModalVisible(true);
  };

  const getIconColor = () => {
    if (loading) return theme.colors.onPrimary;
    return '#FFFFFF';
  };

  const getIconName = () => {
    if (loading) return 'clock-outline';
    if (isShiftOpen) return 'store-check';
    return 'store-alert';
  };

  return (
    <>
      <TouchableOpacity
        style={[
          styles.container,
          {
            backgroundColor: loading
              ? 'rgba(255, 255, 255, 0.2)'
              : isShiftOpen
                ? '#2E7D32' // Verde oscuro s√≥lido
                : '#F57C00', // Naranja oscuro s√≥lido
            borderWidth: 2,
            borderColor: loading
              ? 'rgba(255, 255, 255, 0.3)'
              : isShiftOpen
                ? '#4CAF50' // Verde m√°s claro para el borde
                : '#FF9800', // Naranja m√°s claro para el borde
          },
        ]}
        onPress={handlePress}
        disabled={loading}
        hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
      >
        <Icon source={getIconName()} size={22} color={getIconColor()} />
        <Text style={[styles.statusText, { color: getIconColor() }]}>
          {loading ? 'Cargando' : isShiftOpen ? 'ABIERTO' : 'CERRADO'}
        </Text>
        {!isShiftOpen && !loading && (
          <Badge
            style={[styles.badge, { backgroundColor: '#FF1744' }]}
            size={8}
          />
        )}
      </TouchableOpacity>

      <ShiftStatusModal
        visible={statusModalVisible}
        onDismiss={() => setStatusModalVisible(false)}
        shift={shift}
        onOpenShift={handleOpenShift}
        onCloseShift={handleCloseShift}
        canOpenShift={userCanOpenShift}
        loading={loading}
      />

      <OpenShiftModal
        visible={openShiftModalVisible}
        onDismiss={() => setOpenShiftModalVisible(false)}
        onShiftOpened={() => {
          queryClient.invalidateQueries(['global', 'shift', 'current']);
          setOpenShiftModalVisible(false);
        }}
      />

      <CloseShiftModal
        visible={closeShiftModalVisible}
        onDismiss={() => setCloseShiftModalVisible(false)}
        onShiftClosed={() => {
          queryClient.invalidateQueries(['global', 'shift', 'current']);
          setCloseShiftModalVisible(false);
        }}
        shift={shift}
      />
    </>
  );
};

const styles = StyleSheet.create({
  container: {
    position: 'relative',
    flexDirection: 'row',
    paddingHorizontal: 14,
    paddingVertical: 8,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 8,
    borderRadius: 24,
    gap: 6,
    elevation: 4,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
  },
  statusText: {
    fontSize: 14,
    fontWeight: '700',
    letterSpacing: 0.5,
  },
  badge: {
    position: 'absolute',
    top: -4,
    right: -4,
  },
});

================
File: app/src/app/lib/imageCache.ts
================
import * as FileSystem from 'expo-file-system';
import * as Crypto from 'expo-crypto';
import { Platform } from 'react-native';
import { API_PATHS } from '@/app/constants/apiPaths';

const CACHE_DIR = `${FileSystem.cacheDirectory}image-cache/`;
const MAX_CACHE_SIZE_MB = 500;
const MAX_CACHE_AGE_DAYS = 7;
const MAX_RETRIES = 3;
const BASE_RETRY_DELAY = 1000; // 1 segundo

// Logging utility para operaciones de cache (solo errores y operaciones cr√≠ticas)
const logCacheOperation = (operation: string, details: any) => {
  // Solo loggear errores y operaciones de limpieza
  if (
    operation.includes('ERROR') ||
    operation.includes('FAILED') ||
    operation === 'CACHE_CLEANED'
  ) {
    // [ImageCache] operation: details
  }
};

// Funci√≥n para realizar descargas con retry y backoff exponencial
async function downloadWithRetry(
  remoteUrl: string,
  localUri: string,
  maxRetries: number = MAX_RETRIES,
  baseDelay: number = BASE_RETRY_DELAY,
): Promise<string | null> {
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      const { uri: downloadedUri } = await FileSystem.downloadAsync(
        remoteUrl,
        localUri,
      );

      // Solo loggear si hubo m√∫ltiples intentos y fall√≥ al final
      // √âxito despu√©s de reintentos no necesita log

      return downloadedUri;
    } catch (error) {
      if (attempt === maxRetries) {
        // √öltimo intento fallido
        logCacheOperation('DOWNLOAD_FAILED_ALL_RETRIES', {
          url: remoteUrl,
          totalAttempts: maxRetries + 1,
          error: error.message,
        });
        break;
      }

      // Calcular el delay con backoff exponencial
      const delay = baseDelay * Math.pow(2, attempt);

      // No loggear cada reintento, solo el fallo final

      // Esperar antes del siguiente intento
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
  }

  return null;
}

async function ensureCacheDirExists() {
  // En web, el sistema de archivos no est√° disponible
  if (Platform.OS === 'web') {
    return;
  }

  const dirInfo = await FileSystem.getInfoAsync(CACHE_DIR);
  if (!dirInfo.exists) {
    await FileSystem.makeDirectoryAsync(CACHE_DIR, { intermediates: true });
  }
}

async function getCacheFilename(remoteUrl: string): Promise<string> {
  let urlToHash = remoteUrl;

  // Si la URL es de nuestra API, incluir el host en el hash para evitar conflictos
  // cuando cambia la IP del servidor
  if (remoteUrl.includes(API_PATHS.FILES_CHECK)) {
    try {
      const parsedUrl = new URL(remoteUrl);
      // Incluir host + pathname para diferenciar entre diferentes servidores
      urlToHash = `${parsedUrl.host}${parsedUrl.pathname}`;
    } catch (e) {
      // Si falla el parseo, usar la URL completa
      urlToHash = remoteUrl;
    }
  }

  const digest = await Crypto.digestStringAsync(
    Crypto.CryptoDigestAlgorithm.SHA256,
    urlToHash,
    { encoding: Crypto.CryptoEncoding.HEX },
  );
  const extensionMatch = remoteUrl.match(/\.([a-zA-Z0-9]+)(?:[?#]|$)/);
  const extension = extensionMatch ? extensionMatch[1] : 'jpg';
  return `${digest}.${extension}`;
}

interface ExistingFileInfo {
  uri: string;
  size: number;
  modificationTime: number;
  exists: true;
}

async function cleanCache() {
  await ensureCacheDirExists();

  try {
    const files = await FileSystem.readDirectoryAsync(CACHE_DIR);

    if (files.length === 0) {
      return;
    }

    const fileInfosPromises = files.map(
      async (
        file,
      ): Promise<ExistingFileInfo | { exists: false; uri: string }> => {
        const info = await FileSystem.getInfoAsync(`${CACHE_DIR}${file}`, {
          size: true,
        });
        if (info.exists) {
          return {
            uri: info.uri,
            size: info.size,
            modificationTime: info.modificationTime,
            exists: true,
          };
        } else {
          return {
            exists: false,
            uri: info.uri,
          };
        }
      },
    );

    const allFileInfos = await Promise.all(fileInfosPromises);
    const existingFileInfos: ExistingFileInfo[] = allFileInfos.filter(
      (f): f is ExistingFileInfo => f.exists,
    );

    let totalSize = existingFileInfos.reduce((sum, file) => sum + file.size, 0);
    const originalTotalSize = totalSize;

    const now = Date.now();
    const maxAgeMillis = MAX_CACHE_AGE_DAYS * 24 * 60 * 60 * 1000;
    const maxSizeInBytes = MAX_CACHE_SIZE_MB * 1024 * 1024;

    let filesDeletedCount = 0;
    let sizeDeleted = 0;

    // Fase 1: Eliminar archivos por edad (m√°s eficiente)
    const filesToDeleteByAge = existingFileInfos.filter((file) => {
      const fileAgeMillis = now - Math.floor(file.modificationTime) * 1000;
      return fileAgeMillis > maxAgeMillis;
    });

    for (const file of filesToDeleteByAge) {
      try {
        await FileSystem.deleteAsync(file.uri, { idempotent: true });
        totalSize -= file.size;
        sizeDeleted += file.size;
        filesDeletedCount++;
      } catch (delError) {
        // Ignorar errores de archivos que no se pueden eliminar
      }
    }

    // Fase 2: Eliminar archivos por tama√±o si es necesario (LRU)
    if (totalSize > maxSizeInBytes) {
      const remainingFiles = existingFileInfos
        .filter((file) => {
          const fileAgeMillis = now - Math.floor(file.modificationTime) * 1000;
          return fileAgeMillis <= maxAgeMillis;
        })
        .sort((a, b) => {
          // Ordenar por tiempo de modificaci√≥n (m√°s antiguos primero)
          return a.modificationTime < b.modificationTime
            ? -1
            : a.modificationTime > b.modificationTime
              ? 1
              : 0;
        });

      // Eliminar archivos m√°s antiguos hasta llegar al l√≠mite de tama√±o
      // Dejamos un margen del 10% para evitar limpiezas frecuentes
      const targetSize = maxSizeInBytes * 0.9;

      for (const file of remainingFiles) {
        if (totalSize <= targetSize) break;

        try {
          await FileSystem.deleteAsync(file.uri, { idempotent: true });
          totalSize -= file.size;
          sizeDeleted += file.size;
          filesDeletedCount++;
        } catch (delError) {
          // Ignorar errores de archivos que no se pueden eliminar
        }
      }
    }

    // Logging detallado
    if (filesDeletedCount > 0) {
      logCacheOperation('CACHE_CLEANED', {
        filesDeleted: filesDeletedCount,
        sizeCleaned: `${(sizeDeleted / 1024 / 1024).toFixed(2)}MB`,
        totalFilesRemaining: files.length - filesDeletedCount,
        totalSizeRemaining: `${(totalSize / 1024 / 1024).toFixed(2)}MB`,
        originalSize: `${(originalTotalSize / 1024 / 1024).toFixed(2)}MB`,
        spaceFreed: `${(sizeDeleted / 1024 / 1024).toFixed(2)}MB`,
        cacheUtilization: `${((totalSize / maxSizeInBytes) * 100).toFixed(1)}%`,
      });
    }
    // No necesitamos loggear cuando no se limpia nada
  } catch (error) {
    logCacheOperation('CACHE_CLEAN_ERROR', { error: error.message });
  }
}

export async function getCachedImageUri(
  remoteUrl: string,
): Promise<string | null> {
  if (
    !remoteUrl ||
    typeof remoteUrl !== 'string' ||
    (!remoteUrl.startsWith('http://') && !remoteUrl.startsWith('https://'))
  ) {
    return remoteUrl;
  }

  // En web, no usar cache - devolver URL directamente
  if (Platform.OS === 'web') {
    return remoteUrl;
  }

  await ensureCacheDirExists();
  const filename = await getCacheFilename(remoteUrl);
  const localUri = `${CACHE_DIR}${filename}`;
  const fileInfo = await FileSystem.getInfoAsync(localUri);

  if (fileInfo.exists) {
    return localUri;
  } else {
    // Usar downloadWithRetry en lugar de descarga directa
    const downloadedUri = await downloadWithRetry(remoteUrl, localUri);

    if (downloadedUri) {
      // Descarga exitosa - no necesita log en producci√≥n

      return downloadedUri;
    } else {
      // Limpiar archivos parciales si los hay
      const partialFileInfo = await FileSystem.getInfoAsync(localUri);
      if (partialFileInfo.exists) {
        await FileSystem.deleteAsync(localUri, { idempotent: true });
      }

      logCacheOperation('CACHE_MISS_FAILED', {
        url: remoteUrl,
        filename,
        error: 'Download failed after all retries',
      });

      return null;
    }
  }
}

export async function initImageCache() {
  // En web, no inicializar cache
  if (Platform.OS === 'web') {
    return;
  }

  await ensureCacheDirExists();

  cleanCache().catch((error) => {
    logCacheOperation('CACHE_CLEAN_ERROR', { error: error.message });
  });
}

export async function removeImageFromCache(remoteUrl: string) {
  if (!remoteUrl || typeof remoteUrl !== 'string') return;

  // En web, no hay cache que limpiar
  if (Platform.OS === 'web') {
    return;
  }

  try {
    const filename = await getCacheFilename(remoteUrl);
    const localUri = `${CACHE_DIR}${filename}`;
    await FileSystem.deleteAsync(localUri, { idempotent: true });

    // Item removido exitosamente - no necesita log
  } catch (error) {
    logCacheOperation('CACHE_ITEM_REMOVE_FAILED', {
      url: remoteUrl,
      error: error.message,
    });
  }
}

export async function clearImageCache() {
  try {
    await FileSystem.deleteAsync(CACHE_DIR, { idempotent: true });
    await ensureCacheDirExists();

    // Cache limpiado exitosamente - no necesita log
  } catch (error) {
    logCacheOperation('CACHE_CLEAR_FAILED', {
      error: error.message,
    });
  }
}

// Prefetching inteligente para optimizar la carga de im√°genes
export async function prefetchImages(
  imagePaths: string[],
  options: {
    maxConcurrent?: number;
    skipExisting?: boolean;
    onProgress?: (completed: number, total: number) => void;
  } = {},
) {
  const { maxConcurrent = 5, skipExisting = true, onProgress } = options;

  if (!imagePaths || imagePaths.length === 0) {
    return;
  }

  let completed = 0;
  let failed = 0;

  // Funci√≥n para procesar una imagen
  const processSingleImage = async (imagePath: string) => {
    try {
      // Construir la URL completa usando getImageUrl
      const { getImageUrl } = await import('./imageUtils');
      const fullUrl = await getImageUrl(imagePath);

      if (!fullUrl) {
        failed++;
        return;
      }

      // Verificar si ya existe en cache
      if (skipExisting) {
        const filename = await getCacheFilename(fullUrl);
        const localUri = `${CACHE_DIR}${filename}`;
        const fileInfo = await FileSystem.getInfoAsync(localUri);

        if (fileInfo.exists) {
          return;
        }
      }

      // Descargar la imagen usando el m√©todo con retry
      const result = await getCachedImageUri(fullUrl);
      if (!result) {
        failed++;
      }
    } catch (error) {
      failed++;
    } finally {
      completed++;
      onProgress?.(completed, imagePaths.length);
    }
  };

  // Procesar im√°genes en lotes concurrentes
  const batches = [];
  for (let i = 0; i < imagePaths.length; i += maxConcurrent) {
    const batch = imagePaths.slice(i, i + maxConcurrent);
    batches.push(batch);
  }

  for (const batch of batches) {
    await Promise.all(batch.map(processSingleImage));
  }

  // Solo loggear si hubo errores
  if (failed > 0) {
    logCacheOperation('PREFETCH_FAILED', {
      totalImages: imagePaths.length,
      failed,
      successRate: `${((1 - failed / imagePaths.length) * 100).toFixed(1)}%`,
    });
  }
}

// Prefetching espec√≠fico para men√∫s
export async function prefetchMenuImages(
  menuData: any[],
  options?: {
    maxConcurrent?: number;
    onProgress?: (completed: number, total: number) => void;
  },
) {
  const imagePaths: string[] = [];

  // Extraer paths de im√°genes del men√∫
  menuData.forEach((category) => {
    if (category.photo?.path) {
      imagePaths.push(category.photo.path);
    }

    if (category.subcategories) {
      category.subcategories.forEach((subcategory) => {
        if (subcategory.photo?.path) {
          imagePaths.push(subcategory.photo.path);
        }

        if (subcategory.products) {
          subcategory.products.forEach((product) => {
            if (product.photo?.path) {
              imagePaths.push(product.photo.path);
            }
          });
        }
      });
    }
  });

  if (imagePaths.length > 0) {
    await prefetchImages(imagePaths, {
      ...options,
      skipExisting: true,
    });
  }
}

================
File: app/src/app/store/authStore.ts
================
import { create } from 'zustand';
import EncryptedStorage from '@/app/services/secureStorageService';
import type { User } from '../../modules/auth/schema/auth.schema'; // Corregida ruta de importaci√≥n
import * as ScreenOrientation from 'expo-screen-orientation';

const AUTH_TOKEN_KEY = 'auth_token';
const REFRESH_TOKEN_KEY = 'refresh_token';
const USER_INFO_KEY = 'user_info';

export interface AuthState {
  isAuthenticated: boolean;
  accessToken: string | null;
  refreshToken: string | null;
  user: User | null;
  setTokens: (
    accessToken: string,
    refreshToken: string,
    user: User | null,
  ) => Promise<void>;
  setAccessToken: (accessToken: string) => Promise<void>;
  setRefreshToken: (refreshToken: string) => Promise<void>;
  setUser: (user: User | null) => Promise<void>;
  logout: () => Promise<void>;
}

export const useAuthStore = create<AuthState>((set) => ({
  isAuthenticated: false,
  accessToken: null,
  refreshToken: null,
  user: null,

  setTokens: async (
    accessToken: string,
    refreshToken: string,
    user: User | null,
  ) => {
    // Verificar si el usuario est√° activo antes de guardar los tokens
    if (user && 'isActive' in user && !user.isActive) {
      throw new Error('Usuario inactivo');
    }

    await EncryptedStorage.setItem(AUTH_TOKEN_KEY, accessToken);
    await EncryptedStorage.setItem(REFRESH_TOKEN_KEY, refreshToken);
    if (user) {
      await EncryptedStorage.setItem(USER_INFO_KEY, JSON.stringify(user));
    } else {
      await EncryptedStorage.removeItem(USER_INFO_KEY);
    }
    set({
      accessToken,
      refreshToken,
      user: user ?? null,
      isAuthenticated: true,
    });
  },

  setAccessToken: async (accessToken: string) => {
    try {
      await EncryptedStorage.setItem(AUTH_TOKEN_KEY, accessToken);
      set({ accessToken, isAuthenticated: true });
    } catch (error) {
      // Error al guardar access token
    }
  },

  setRefreshToken: async (refreshToken: string) => {
    try {
      await EncryptedStorage.setItem(REFRESH_TOKEN_KEY, refreshToken);
      set({ refreshToken });
    } catch (error) {
      // Error al guardar refresh token
    }
  },

  setUser: async (user: User | null) => {
    try {
      if (user) {
        // Si el usuario se actualiza y est√° inactivo, cerrar sesi√≥n
        if ('isActive' in user && !user.isActive) {
          await useAuthStore.getState().logout();
          return;
        }
        await EncryptedStorage.setItem(USER_INFO_KEY, JSON.stringify(user));
      } else {
        await EncryptedStorage.removeItem(USER_INFO_KEY);
      }
      set({ user });
    } catch (error) {
      // Error al guardar informaci√≥n del usuario
    }
  },

  logout: async () => {
    const ORIENTATION_DELAYS = {
      UNLOCK: 100,
      LOCK: 200,
    };

    const clearAuthData = async () => {
      await EncryptedStorage.removeItem(AUTH_TOKEN_KEY);
      await EncryptedStorage.removeItem(REFRESH_TOKEN_KEY);
      await EncryptedStorage.removeItem(USER_INFO_KEY);
      set({
        accessToken: null,
        refreshToken: null,
        user: null,
        isAuthenticated: false,
      });
    };

    try {
      await ScreenOrientation.unlockAsync();
      await new Promise((resolve) =>
        setTimeout(resolve, ORIENTATION_DELAYS.UNLOCK),
      );
      await ScreenOrientation.lockAsync(
        ScreenOrientation.OrientationLock.PORTRAIT_UP,
      );
      await new Promise((resolve) =>
        setTimeout(resolve, ORIENTATION_DELAYS.LOCK),
      );
      await clearAuthData();
    } catch (error) {
      try {
        await clearAuthData();
      } catch (fallbackError) {
        // Silently handle critical error
      }
    }
  },
}));

export const initializeAuthStore = async () => {
  try {
    const accessToken = await EncryptedStorage.getItem(AUTH_TOKEN_KEY);
    const refreshToken = await EncryptedStorage.getItem(REFRESH_TOKEN_KEY);
    const userInfoString = await EncryptedStorage.getItem(USER_INFO_KEY);
    let user: User | null = null;
    if (userInfoString) {
      try {
        user = JSON.parse(userInfoString);
      } catch (parseError) {
        await EncryptedStorage.removeItem(USER_INFO_KEY);
      }
    }

    if (accessToken && refreshToken) {
      // Verificar si el usuario est√° activo antes de restaurar la sesi√≥n
      if (user && 'isActive' in user && !user.isActive) {
        await EncryptedStorage.removeItem(AUTH_TOKEN_KEY);
        await EncryptedStorage.removeItem(REFRESH_TOKEN_KEY);
        await EncryptedStorage.removeItem(USER_INFO_KEY);
        useAuthStore.setState({
          accessToken: null,
          refreshToken: null,
          user: null,
          isAuthenticated: false,
        });
        return;
      }

      // Primero establecemos el token en el estado para que el apiClient pueda usarlo
      useAuthStore.setState({
        accessToken,
        refreshToken,
        user,
        isAuthenticated: true,
      });

      // La verificaci√≥n del token se har√° de manera lazy cuando sea necesario
      // Esto evita el ciclo de dependencias con authService
    } else {
      useAuthStore.setState({
        accessToken: null,
        refreshToken: null,
        user: null,
        isAuthenticated: false,
      });
    }
  } catch (error) {
    useAuthStore.setState({
      accessToken: null,
      refreshToken: null,
      user: null,
      isAuthenticated: false,
    });
  }
};

================
File: app/src/components/AudioRecorderWidget.tsx
================
import React, { useEffect, useRef, useState } from 'react';
import {
  View,
  TouchableOpacity,
  StyleSheet,
  Animated,
  Easing,
  Text,
  Platform,
} from 'react-native';
import { MaterialIcons, MaterialCommunityIcons } from '@expo/vector-icons';
import { useTheme } from 'react-native-paper';
import { useAudioRecorder } from '@/hooks/useAudioRecorder';
import {
  audioServiceHealth,
  type AudioServiceHealthStatus,
} from '@/services/audioServiceHealth';
import { serverConnectionService } from '@/services/serverConnectionService';

interface AudioRecorderWidgetProps {
  onRecordingComplete: (audioUri: string, transcription: string) => void;
  onError: (error: string) => void;
}

export const AudioRecorderWidget: React.FC<AudioRecorderWidgetProps> = ({
  onRecordingComplete,
  onError,
}) => {
  const theme = useTheme();
  const {
    isRecording,
    isPreparing,
    isProcessing,
    audioUri,
    transcription,
    startRecording,
    stopRecording,
    resetRecording,
    error,
  } = useAudioRecorder();

  // Estado para el tiempo de grabaci√≥n
  const [recordingTime, setRecordingTime] = useState(0);
  const recordingInterval = useRef<NodeJS.Timeout | null>(null);

  // Estado de disponibilidad del servicio
  const [serviceHealth, setServiceHealth] = useState<AudioServiceHealthStatus>(
    audioServiceHealth.getStatus(),
  );
  const [isServiceAvailable, setIsServiceAvailable] = useState(false);
  const [isServerReady, setIsServerReady] = useState(false);

  // Animaciones
  const scaleAnim = useRef(new Animated.Value(1)).current;
  const rotateAnim = useRef(new Animated.Value(0)).current;
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const waveAnim1 = useRef(new Animated.Value(0.8)).current;
  const waveAnim2 = useRef(new Animated.Value(0.8)).current;
  const waveAnim3 = useRef(new Animated.Value(0.8)).current;
  const bounceAnim = useRef(new Animated.Value(0)).current;
  const glowAnim = useRef(new Animated.Value(0)).current;

  // Verificar estado del servidor primero
  useEffect(() => {
    const checkServerConnection = () => {
      const connectionState = serverConnectionService.getState();
      const ready = connectionState.isConnected && !!connectionState.currentUrl;
      setIsServerReady(ready);
    };

    // Verificaci√≥n inicial
    checkServerConnection();

    // Suscribirse a cambios en el estado del servidor
    const unsubscribeServer = serverConnectionService.subscribe(
      checkServerConnection,
    );

    return unsubscribeServer;
  }, []);

  // Suscribirse a cambios en el estado del servicio solo cuando el servidor est√© listo
  useEffect(() => {
    if (!isServerReady) return;

    const unsubscribe = audioServiceHealth.subscribe((status) => {
      setServiceHealth(status);
      setIsServiceAvailable(status.isAvailable);
    });

    // Iniciar verificaci√≥n peri√≥dica solo cuando el servidor est√© conectado
    audioServiceHealth.startPeriodicCheck();

    return () => {
      unsubscribe();
      // IMPORTANTE: Detener verificaciones peri√≥dicas cuando el componente se desmonte
      audioServiceHealth.stopPeriodicCheck();
    };
  }, [isServerReady]);

  // Animaci√≥n de entrada del widget (siempre visible)
  useEffect(() => {
    Animated.spring(bounceAnim, {
      toValue: 1,
      friction: 4,
      tension: 40,
      useNativeDriver: true,
    }).start();
  }, []);

  // Animaci√≥n de ondas cuando est√° grabando
  useEffect(() => {
    if (isRecording) {
      // Iniciar contador de tiempo
      recordingInterval.current = setInterval(() => {
        setRecordingTime((prev) => prev + 1);
      }, 1000);

      // Animaciones de onda
      const wave1 = Animated.loop(
        Animated.sequence([
          Animated.timing(waveAnim1, {
            toValue: 1.5,
            duration: 2000,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
          Animated.timing(waveAnim1, {
            toValue: 0.8,
            duration: 2000,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
        ]),
      );

      const wave2 = Animated.loop(
        Animated.sequence([
          Animated.timing(waveAnim2, {
            toValue: 1.8,
            duration: 2500,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
          Animated.timing(waveAnim2, {
            toValue: 0.8,
            duration: 2500,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
        ]),
      );

      const wave3 = Animated.loop(
        Animated.sequence([
          Animated.timing(waveAnim3, {
            toValue: 2.1,
            duration: 3000,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
          Animated.timing(waveAnim3, {
            toValue: 0.8,
            duration: 3000,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
        ]),
      );

      // Animaci√≥n de brillo
      const glow = Animated.loop(
        Animated.sequence([
          Animated.timing(glowAnim, {
            toValue: 1,
            duration: 1500,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
          Animated.timing(glowAnim, {
            toValue: 0,
            duration: 1500,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
        ]),
      );

      wave1.start();
      wave2.start();
      wave3.start();
      glow.start();

      // Fade in de las ondas
      Animated.timing(fadeAnim, {
        toValue: 1,
        duration: 300,
        useNativeDriver: true,
      }).start();

      return () => {
        wave1.stop();
        wave2.stop();
        wave3.stop();
        glow.stop();
        if (recordingInterval.current) {
          clearInterval(recordingInterval.current);
        }
        setRecordingTime(0);
      };
    } else {
      // Fade out de las ondas
      Animated.timing(fadeAnim, {
        toValue: 0,
        duration: 300,
        useNativeDriver: true,
      }).start();
      waveAnim1.setValue(0.8);
      waveAnim2.setValue(0.8);
      waveAnim3.setValue(0.8);
      glowAnim.setValue(0);
    }
  }, [isRecording]);

  // Animaci√≥n de procesamiento
  useEffect(() => {
    if (isProcessing || isPreparing) {
      const spin = Animated.loop(
        Animated.timing(rotateAnim, {
          toValue: 1,
          duration: 1500,
          easing: Easing.bezier(0.645, 0.045, 0.355, 1),
          useNativeDriver: true,
        }),
      );
      spin.start();
      return () => {
        spin.stop();
        rotateAnim.setValue(0);
      };
    }
  }, [isProcessing, isPreparing]);

  // Estado para evitar llamadas duplicadas
  const hasCompletedRef = useRef(false);

  // Efecto cuando se completa la grabaci√≥n
  useEffect(() => {
    if (
      audioUri &&
      transcription &&
      !isProcessing &&
      !hasCompletedRef.current
    ) {
      hasCompletedRef.current = true;

      // Reset primero para evitar loops
      resetRecording();

      // Luego llamar a onRecordingComplete
      onRecordingComplete(audioUri, transcription);

      // Resetear el flag despu√©s de un tiempo
      setTimeout(() => {
        hasCompletedRef.current = false;
      }, 1000);
    }
  }, [
    audioUri,
    transcription,
    isProcessing,
    onRecordingComplete,
    resetRecording,
  ]);

  // Efecto para manejar errores
  useEffect(() => {
    if (error) {
      onError(error);
    }
  }, [error, onError]);

  const handlePress = async () => {
    // Verificar disponibilidad del servicio
    if (!isServiceAvailable) {
      // Animaci√≥n de "shake" para indicar que no est√° disponible
      Animated.sequence([
        Animated.timing(scaleAnim, {
          toValue: 1.1,
          duration: 100,
          useNativeDriver: true,
        }),
        Animated.timing(scaleAnim, {
          toValue: 0.9,
          duration: 100,
          useNativeDriver: true,
        }),
        Animated.timing(scaleAnim, {
          toValue: 1.1,
          duration: 100,
          useNativeDriver: true,
        }),
        Animated.timing(scaleAnim, {
          toValue: 1,
          duration: 100,
          useNativeDriver: true,
        }),
      ]).start();

      onError(serviceHealth.message || 'Servicio de voz no disponible');
      return;
    }

    // Prevenir m√∫ltiples clics mientras procesa
    if (isProcessing || isPreparing) {
      return;
    }

    // Animaci√≥n de presi√≥n m√°s suave
    Animated.sequence([
      Animated.spring(scaleAnim, {
        toValue: 0.85,
        friction: 3,
        tension: 40,
        useNativeDriver: true,
      }),
      Animated.spring(scaleAnim, {
        toValue: 1,
        friction: 3,
        tension: 40,
        useNativeDriver: true,
      }),
    ]).start();

    try {
      if (isRecording) {
        await stopRecording();
      } else {
        await startRecording();
      }
    } catch (err) {}
  };

  const rotateInterpolate = rotateAnim.interpolate({
    inputRange: [0, 1],
    outputRange: ['0deg', '360deg'],
  });

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
  };

  const getIcon = () => {
    if (isRecording) {
      return <MaterialIcons name="stop" size={30} color="white" />;
    }
    return <MaterialIcons name="mic" size={30} color="white" />;
  };

  const getBackgroundColor = () => {
    if (!isServiceAvailable) return '#B0B0B0'; // Gris m√°s suave
    if (isProcessing || isPreparing) return theme.colors.secondary;
    if (isRecording) return '#FF3B30'; // Rojo vibrante
    return theme.colors.primary;
  };

  return (
    <Animated.View
      style={[
        styles.container,
        {
          transform: [
            {
              translateY: bounceAnim.interpolate({
                inputRange: [0, 1],
                outputRange: [100, 0],
              }),
            },
            { scale: bounceAnim },
          ],
          opacity: bounceAnim.interpolate({
            inputRange: [0, 1],
            outputRange: [0, isServiceAvailable ? 1 : 0.8],
          }),
        },
      ]}
    >
      {/* Ondas animadas de fondo */}
      {isRecording && (
        <View style={styles.wavesContainer}>
          <Animated.View
            style={[
              styles.wave,
              {
                transform: [{ scale: waveAnim1 }],
                opacity: fadeAnim.interpolate({
                  inputRange: [0, 1],
                  outputRange: [0, 0.1],
                }),
                backgroundColor: theme.colors.primary,
              },
            ]}
          />
          <Animated.View
            style={[
              styles.wave,
              {
                transform: [{ scale: waveAnim2 }],
                opacity: fadeAnim.interpolate({
                  inputRange: [0, 1],
                  outputRange: [0, 0.15],
                }),
                backgroundColor: theme.colors.primary,
              },
            ]}
          />
          <Animated.View
            style={[
              styles.wave,
              {
                transform: [{ scale: waveAnim3 }],
                opacity: fadeAnim.interpolate({
                  inputRange: [0, 1],
                  outputRange: [0, 0.2],
                }),
                backgroundColor: theme.colors.primary,
              },
            ]}
          />
        </View>
      )}

      {/* Contador de tiempo */}
      {isRecording && (
        <Animated.View
          style={[
            styles.timerContainer,
            {
              opacity: fadeAnim,
              transform: [
                {
                  translateY: fadeAnim.interpolate({
                    inputRange: [0, 1],
                    outputRange: [-10, 0],
                  }),
                },
              ],
            },
          ]}
        >
          <View style={[styles.timerBadge, { backgroundColor: '#FF3B30' }]}>
            <View style={styles.recordingDot} />
            <Text style={styles.timerText}>{formatTime(recordingTime)}</Text>
          </View>
        </Animated.View>
      )}

      {/* Indicador de servicio no disponible */}
      {!isServiceAvailable && (
        <View
          style={[
            styles.disabledIndicator,
            { backgroundColor: theme.colors.error },
          ]}
        >
          <MaterialIcons name="cloud-off" size={14} color="white" />
        </View>
      )}

      <TouchableOpacity
        onPress={handlePress}
        disabled={isProcessing || isPreparing || !isServiceAvailable}
        activeOpacity={0.9}
      >
        <Animated.View
          style={[
            styles.buttonContainer,
            {
              transform: [{ scale: scaleAnim }],
            },
          ]}
        >
          {/* Brillo de fondo cuando graba */}
          {isRecording && (
            <Animated.View
              style={[
                styles.glowEffect,
                {
                  backgroundColor: '#FF3B30',
                  opacity: glowAnim.interpolate({
                    inputRange: [0, 1],
                    outputRange: [0.3, 0.6],
                  }),
                  transform: [
                    {
                      scale: glowAnim.interpolate({
                        inputRange: [0, 1],
                        outputRange: [1, 1.2],
                      }),
                    },
                  ],
                },
              ]}
            />
          )}

          <View
            style={[
              styles.button,
              {
                backgroundColor: getBackgroundColor(),
                ...Platform.select({
                  web: {
                    boxShadow: !isServiceAvailable
                      ? 'none'
                      : isRecording
                        ? '0px 2px 8px rgba(255, 59, 48, 0.4)'
                        : `0px 2px 8px ${theme.colors.primary}40`,
                  },
                  default: {
                    shadowColor: !isServiceAvailable
                      ? 'transparent'
                      : isRecording
                        ? '#FF3B30'
                        : theme.colors.primary,
                    shadowOpacity: !isServiceAvailable
                      ? 0
                      : isRecording
                        ? 0.4
                        : 0.25,
                  },
                }),
              },
            ]}
          >
            {isProcessing || isPreparing ? (
              <Animated.View
                style={{
                  transform: [{ rotate: rotateInterpolate }],
                }}
              >
                <MaterialCommunityIcons name="brain" size={30} color="white" />
              </Animated.View>
            ) : (
              getIcon()
            )}
          </View>
        </Animated.View>
      </TouchableOpacity>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    position: 'absolute',
    bottom: 30,
    right: 20,
    alignItems: 'center',
    justifyContent: 'center',
  },
  wavesContainer: {
    position: 'absolute',
    alignItems: 'center',
    justifyContent: 'center',
  },
  wave: {
    position: 'absolute',
    width: 120,
    height: 120,
    borderRadius: 60,
  },
  buttonContainer: {
    alignItems: 'center',
    justifyContent: 'center',
  },
  button: {
    width: 72,
    height: 72,
    borderRadius: 36,
    alignItems: 'center',
    justifyContent: 'center',
    elevation: 8,
    ...Platform.select({
      web: {
        boxShadow: '0px 2px 8px rgba(0, 0, 0, 0.25)',
      },
      default: {
        shadowOffset: { width: 0, height: 2 },
        shadowRadius: 8,
      },
    }),
    zIndex: 10,
  },
  glowEffect: {
    position: 'absolute',
    width: 80,
    height: 80,
    borderRadius: 40,
    zIndex: 5,
  },
  timerContainer: {
    position: 'absolute',
    top: -45,
    alignItems: 'center',
  },
  timerBadge: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 20,
    gap: 6,
  },
  recordingDot: {
    width: 6,
    height: 6,
    borderRadius: 3,
    backgroundColor: 'white',
    opacity: 0.9,
  },
  timerText: {
    color: 'white',
    fontSize: 12,
    fontWeight: '600',
  },
  disabledIndicator: {
    position: 'absolute',
    top: 0,
    right: 0,
    width: 26,
    height: 26,
    borderRadius: 13,
    alignItems: 'center',
    justifyContent: 'center',
    zIndex: 20,
    elevation: 12,
    borderWidth: 2,
    borderColor: 'white',
  },
});

================
File: app/src/modules/customers/components/CustomerFormModal.tsx
================
import React, { useEffect, useState } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Portal,
  Modal,
  Text,
  TextInput,
  Button,
  Switch,
  HelperText,
  Surface,
  IconButton,
  Chip,
  Avatar,
  Icon,
} from 'react-native-paper';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { Customer, Address } from '../types/customer.types';
import {
  CustomerFormInputs,
  customerFormSchema,
} from '../schema/customer.schema';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import AnimatedLabelSelector from '@/app/components/common/AnimatedLabelSelector';
import { DateTimePickerSafe } from '@/app/components/DateTimePickerSafe';
import PhoneNumberInput from '@/app/components/common/PhoneNumberInput';
import { useGetAddressesByCustomer } from '../hooks/useCustomersQueries';
import AddressFormModal from './AddressFormModal';
import { addressesService } from '../services/addressesService';
import { useSnackbarStore } from '@/app/store/snackbarStore';

interface CustomerFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSubmit: (data: CustomerFormInputs) => Promise<void>;
  editingItem: Customer | null;
  isSubmitting: boolean;
}

export default function CustomerFormModal({
  visible,
  onDismiss,
  onSubmit,
  editingItem,
  isSubmitting,
}: CustomerFormModalProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = getStyles(theme, responsive);
  const [showAddressModal, setShowAddressModal] = useState(false);
  const [editingAddress, setEditingAddress] = useState<Address | null>(null);
  const [isSubmittingAddress, setIsSubmittingAddress] = useState(false);
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [tempDate, setTempDate] = useState<Date>(new Date());
  const [dateOnChange, setDateOnChange] = useState<
    ((value: string) => void) | null
  >(null);
  const { showSnackbar } = useSnackbarStore();

  // Query para obtener direcciones del cliente
  const { data: addresses = [], refetch: refetchAddresses } =
    useGetAddressesByCustomer(editingItem?.id || '', {
      enabled: !!editingItem?.id,
    });

  const {
    control,
    handleSubmit,
    formState: { errors },
    reset,
    watch,
  } = useForm<CustomerFormInputs>({
    resolver: zodResolver(customerFormSchema),
    defaultValues: {
      firstName: '',
      lastName: '',
      whatsappPhoneNumber: '',
      email: '',
      birthDate: '',
      isActive: true,
      isBanned: false,
      banReason: '',
    },
  });

  useEffect(() => {
    if (editingItem) {
      reset({
        firstName: editingItem.firstName,
        lastName: editingItem.lastName,
        whatsappPhoneNumber: editingItem.whatsappPhoneNumber || '',
        email: editingItem.email || '',
        birthDate: editingItem.birthDate
          ? new Date(editingItem.birthDate).toISOString().split('T')[0]
          : '',
        isActive: editingItem.isActive,
        isBanned: editingItem.isBanned || false,
        banReason: editingItem.banReason || '',
      });
    } else {
      reset({
        firstName: '',
        lastName: '',
        whatsappPhoneNumber: '',
        email: '',
        birthDate: '',
        isActive: true,
        isBanned: false,
        banReason: '',
      });
    }
  }, [editingItem, reset]);

  const isBanned = watch('isBanned');

  const handleAddressSubmit = async (data: any) => {
    try {
      setIsSubmittingAddress(true);
      if (editingAddress) {
        await addressesService.update(editingAddress.id, data);
        showSnackbar({ message: 'Direcci√≥n actualizada', type: 'success' });
      } else if (editingItem) {
        await addressesService.create(editingItem.id, data);
        showSnackbar({ message: 'Direcci√≥n agregada', type: 'success' });
      }
      await refetchAddresses();
      setShowAddressModal(false);
      setEditingAddress(null);
    } catch (error) {
      showSnackbar({ message: 'Error al guardar la direcci√≥n', type: 'error' });
    } finally {
      setIsSubmittingAddress(false);
    }
  };

  const handleFormSubmit = async (data: CustomerFormInputs) => {
    // Limpiar campos vac√≠os antes de enviar
    const cleanedData = {
      ...data,
      email: data.email || undefined,
      birthDate: data.birthDate || undefined,
      banReason: data.banReason || undefined,
    };

    // El n√∫mero ya viene completo desde nuestro componente
    await onSubmit(cleanedData);
  };

  return (
    <>
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onDismiss}
          contentContainerStyle={styles.modalContainer}
        >
          <Surface style={styles.modalContent} elevation={5}>
            <View
              style={[
                styles.headerContainer,
                { backgroundColor: theme.colors.primary },
              ]}
            >
              <View style={styles.headerLeft}>
                <Avatar.Icon
                  size={32}
                  icon={editingItem ? 'account-edit' : 'account-plus'}
                  style={[
                    styles.headerIcon,
                    { backgroundColor: theme.colors.onPrimary + '20' },
                  ]}
                  color={theme.colors.onPrimary}
                />
                <View style={styles.headerTextContainer}>
                  <Text
                    style={[
                      styles.modalTitle,
                      { color: theme.colors.onPrimary },
                    ]}
                    variant="titleMedium"
                  >
                    {editingItem ? 'Editar Cliente' : 'Nuevo Cliente'}
                  </Text>
                </View>
              </View>
              <IconButton
                icon="close"
                size={24}
                onPress={onDismiss}
                disabled={isSubmitting}
                iconColor={theme.colors.onPrimary}
              />
            </View>

            <ScrollView
              style={styles.formContainer}
              showsVerticalScrollIndicator={false}
              keyboardShouldPersistTaps="handled"
            >
              <View style={styles.sectionContainer}>
                <View style={styles.sectionHeader}>
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Informaci√≥n Personal
                  </Text>
                  <Chip
                    mode="flat"
                    compact
                    style={styles.requiredChip}
                    textStyle={styles.requiredChipText}
                  >
                    Requerido
                  </Chip>
                </View>

                <Controller
                  control={control}
                  name="firstName"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="Nombre"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.firstName}
                        mode="outlined"
                        placeholder="Ej: Juan"
                        left={<TextInput.Icon icon="account" />}
                        outlineStyle={styles.inputOutline}
                      />
                      {errors.firstName && (
                        <HelperText type="error" visible={!!errors.firstName}>
                          {errors.firstName.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />

                <Controller
                  control={control}
                  name="lastName"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="Apellido"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.lastName}
                        mode="outlined"
                        placeholder="Ej: P√©rez"
                        left={<TextInput.Icon icon="account" />}
                        outlineStyle={styles.inputOutline}
                      />
                      {errors.lastName && (
                        <HelperText type="error" visible={!!errors.lastName}>
                          {errors.lastName.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />
              </View>

              <View style={styles.sectionContainer}>
                <View style={styles.sectionHeader}>
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Informaci√≥n de Contacto
                  </Text>
                  <Chip
                    mode="flat"
                    compact
                    style={styles.optionalChip}
                    textStyle={styles.optionalChipText}
                  >
                    Opcional
                  </Chip>
                </View>

                <Controller
                  control={control}
                  name="whatsappPhoneNumber"
                  render={({ field: { onChange, value } }) => (
                    <View style={styles.inputContainer}>
                      <PhoneNumberInput
                        value={value || ''}
                        onChange={onChange}
                        error={!!errors.whatsappPhoneNumber}
                        helperText={errors.whatsappPhoneNumber?.message}
                        placeholder="Tel√©fono"
                      />
                    </View>
                  )}
                />

                <Controller
                  control={control}
                  name="email"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="Correo electr√≥nico"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.email}
                        mode="outlined"
                        placeholder="juan@example.com"
                        keyboardType="email-address"
                        autoCapitalize="none"
                        left={<TextInput.Icon icon="email" />}
                        outlineStyle={styles.inputOutline}
                      />
                      {errors.email && (
                        <HelperText type="error" visible={!!errors.email}>
                          {errors.email.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />

                <Controller
                  control={control}
                  name="birthDate"
                  render={({ field: { onChange, value } }) => (
                    <View style={styles.inputContainer}>
                      <AnimatedLabelSelector
                        label="Fecha de nacimiento"
                        value={
                          value
                            ? format(new Date(value), "d 'de' MMMM 'de' yyyy", {
                                locale: es,
                              })
                            : ''
                        }
                        onPress={() => {
                          setTempDate(value ? new Date(value) : new Date());
                          setDateOnChange(() => onChange);
                          setShowDatePicker(true);
                        }}
                        error={!!errors.birthDate}
                      />
                      {errors.birthDate && (
                        <HelperText type="error" visible={!!errors.birthDate}>
                          {errors.birthDate.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />
              </View>

              <View style={styles.sectionContainer}>
                <View style={styles.sectionHeader}>
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Estado
                  </Text>
                </View>

                <Controller
                  control={control}
                  name="isActive"
                  render={({ field: { onChange, value } }) => (
                    <Surface style={styles.switchContainer} elevation={1}>
                      <View style={styles.switchContent}>
                        <View style={styles.switchTextContainer}>
                          <Text style={styles.switchLabel} variant="bodyLarge">
                            Cliente activo
                          </Text>
                        </View>
                        <Switch
                          value={value}
                          onValueChange={onChange}
                          color={theme.colors.primary}
                        />
                      </View>
                    </Surface>
                  )}
                />

                <Controller
                  control={control}
                  name="isBanned"
                  render={({ field: { onChange, value } }) => (
                    <Surface
                      style={[styles.switchContainer, styles.bannedContainer]}
                      elevation={1}
                    >
                      <View style={styles.switchContent}>
                        <View style={styles.switchTextContainer}>
                          <Text style={styles.switchLabel} variant="bodyLarge">
                            Cliente baneado
                          </Text>
                          <Text
                            style={styles.switchDescription}
                            variant="bodySmall"
                          >
                            Los clientes baneados no pueden realizar pedidos
                          </Text>
                        </View>
                        <Switch
                          value={value}
                          onValueChange={onChange}
                          color={theme.colors.error}
                        />
                      </View>
                    </Surface>
                  )}
                />

                {isBanned && (
                  <>
                    <Controller
                      control={control}
                      name="banReason"
                      render={({ field: { onChange, onBlur, value } }) => (
                        <View
                          style={[
                            styles.inputContainer,
                            styles.banReasonContainer,
                          ]}
                        >
                          <TextInput
                            label="Raz√≥n del baneo"
                            value={value}
                            onChangeText={onChange}
                            onBlur={onBlur}
                            mode="outlined"
                            placeholder="Ej: Comportamiento inapropiado"
                            multiline
                            numberOfLines={2}
                            left={<TextInput.Icon icon="alert-circle" />}
                            outlineStyle={styles.inputOutline}
                            outlineColor={theme.colors.error}
                            activeOutlineColor={theme.colors.error}
                          />
                        </View>
                      )}
                    />

                    {editingItem?.bannedAt && (
                      <Surface style={styles.infoCard} elevation={1}>
                        <View style={styles.infoCardContent}>
                          <IconButton
                            icon="calendar-clock"
                            size={20}
                            iconColor={theme.colors.error}
                          />
                          <View style={styles.infoText}>
                            <Text
                              variant="labelMedium"
                              style={styles.infoLabel}
                            >
                              Fecha de baneo
                            </Text>
                            <Text variant="bodyMedium" style={styles.infoValue}>
                              {new Date(editingItem.bannedAt).toLocaleString()}
                            </Text>
                          </View>
                        </View>
                      </Surface>
                    )}
                  </>
                )}
              </View>

              {/* Secci√≥n de WhatsApp - Solo en modo edici√≥n */}
              {editingItem && (
                <View style={styles.sectionContainer}>
                  <View style={styles.sectionHeader}>
                    <Text style={styles.sectionTitle} variant="titleMedium">
                      Informaci√≥n de WhatsApp
                    </Text>
                  </View>

                  <Surface style={styles.whatsappCard} elevation={1}>
                    <View style={styles.whatsappRow}>
                      <View style={styles.whatsappStat}>
                        <Icon
                          source="message-text"
                          size={20}
                          color={theme.colors.primary}
                        />
                        <View style={styles.whatsappStatContent}>
                          <Text
                            variant="bodySmall"
                            style={styles.whatsappLabel}
                          >
                            Mensajes totales
                          </Text>
                          <Text
                            variant="titleMedium"
                            style={styles.whatsappValue}
                          >
                            {editingItem.whatsappMessageCount || 0}
                          </Text>
                        </View>
                      </View>

                      <View style={styles.whatsappDivider} />

                      <View style={styles.whatsappStat}>
                        <Icon
                          source="clock-outline"
                          size={20}
                          color={theme.colors.primary}
                        />
                        <View style={styles.whatsappStatContent}>
                          <Text
                            variant="bodySmall"
                            style={styles.whatsappLabel}
                          >
                            √öltimo mensaje
                          </Text>
                          <Text
                            variant="bodyMedium"
                            style={styles.whatsappValue}
                          >
                            {editingItem.lastWhatsappMessageTime
                              ? new Date(
                                  editingItem.lastWhatsappMessageTime,
                                ).toLocaleDateString()
                              : 'Sin mensajes'}
                          </Text>
                        </View>
                      </View>
                    </View>
                  </Surface>
                </View>
              )}

              {/* Secci√≥n de Stripe - Solo en modo edici√≥n */}
              {editingItem?.stripeCustomerId && (
                <View style={styles.sectionContainer}>
                  <View style={styles.sectionHeader}>
                    <Text style={styles.sectionTitle} variant="titleMedium">
                      Informaci√≥n de Pago
                    </Text>
                  </View>

                  <Surface style={styles.stripeCard} elevation={1}>
                    <View style={styles.stripeContent}>
                      <Icon
                        source="credit-card"
                        size={24}
                        color={theme.colors.primary}
                      />
                      <View style={styles.stripeInfo}>
                        <Text variant="bodySmall" style={styles.stripeLabel}>
                          Stripe Customer ID
                        </Text>
                        <Text
                          variant="bodyMedium"
                          style={styles.stripeValue}
                          selectable
                        >
                          {editingItem.stripeCustomerId}
                        </Text>
                      </View>
                    </View>
                  </Surface>
                </View>
              )}

              {/* Secci√≥n de Direcciones - Solo en modo edici√≥n */}
              {editingItem && (
                <View style={styles.sectionContainer}>
                  <View style={styles.sectionHeader}>
                    <Text style={styles.sectionTitle} variant="titleMedium">
                      Direcciones
                    </Text>
                    <Button
                      mode="text"
                      onPress={() => {
                        setEditingAddress(null);
                        setShowAddressModal(true);
                      }}
                      icon="plus"
                      compact
                    >
                      Agregar
                    </Button>
                  </View>

                  {addresses.length === 0 ? (
                    <Surface style={styles.emptyAddressContainer} elevation={0}>
                      <Text
                        style={styles.emptyAddressText}
                        variant="bodyMedium"
                      >
                        No hay direcciones registradas
                      </Text>
                    </Surface>
                  ) : (
                    <View style={styles.addressList}>
                      {addresses.map((address: Address) => (
                        <Surface
                          key={address.id}
                          style={styles.addressCard}
                          elevation={1}
                        >
                          <View style={styles.addressContent}>
                            <View style={styles.addressHeader}>
                              <IconButton
                                icon="map-marker"
                                size={20}
                                iconColor={theme.colors.primary}
                              />
                              <View style={styles.addressInfo}>
                                <Text
                                  style={styles.addressName}
                                  variant="titleSmall"
                                >
                                  {address.name}
                                </Text>
                                <Text
                                  style={styles.addressStreet}
                                  variant="bodyMedium"
                                >
                                  {address.street} {address.number}
                                  {address.interiorNumber &&
                                    `, ${address.interiorNumber}`}
                                </Text>
                                <Text
                                  style={styles.addressDetails}
                                  variant="bodySmall"
                                >
                                  {address.neighborhood}, {address.city},{' '}
                                  {address.state}
                                </Text>
                                {address.isDefault && (
                                  <Chip
                                    mode="flat"
                                    compact
                                    style={styles.defaultChip}
                                    textStyle={styles.defaultChipText}
                                  >
                                    Predeterminada
                                  </Chip>
                                )}
                              </View>
                            </View>
                            <View style={styles.addressActions}>
                              <IconButton
                                icon="pencil"
                                size={20}
                                onPress={() => {
                                  setEditingAddress(address);
                                  setShowAddressModal(true);
                                }}
                              />
                              <IconButton
                                icon="delete"
                                size={20}
                                iconColor={theme.colors.error}
                                onPress={async () => {
                                  try {
                                    await addressesService.remove(address.id);
                                    await refetchAddresses();
                                    showSnackbar({
                                      message: 'Direcci√≥n eliminada',
                                      type: 'success',
                                    });
                                  } catch (error) {
                                    showSnackbar({
                                      message: 'Error al eliminar la direcci√≥n',
                                      type: 'error',
                                    });
                                  }
                                }}
                              />
                            </View>
                          </View>
                        </Surface>
                      ))}
                    </View>
                  )}
                </View>
              )}

              {/* Espacio adicional para el teclado */}
              <View style={{ height: 10 }} />
            </ScrollView>

            <Surface style={styles.buttonContainer} elevation={2}>
              <Button
                onPress={onDismiss}
                disabled={isSubmitting}
                style={[styles.button, styles.cancelButton]}
                textColor={theme.colors.onSecondaryContainer}
              >
                Cancelar
              </Button>
              <Button
                mode="contained"
                onPress={handleSubmit(handleFormSubmit)}
                disabled={isSubmitting}
                loading={isSubmitting}
                style={[styles.button, styles.confirmButton]}
                buttonColor={theme.colors.primary}
              >
                {editingItem ? 'Guardar' : 'Crear'}
              </Button>
            </Surface>
          </Surface>
        </Modal>
      </Portal>

      {/* Modal de Direcci√≥n */}
      {editingItem && (
        <AddressFormModal
          visible={showAddressModal}
          onDismiss={() => {
            setShowAddressModal(false);
            setEditingAddress(null);
          }}
          onSubmit={handleAddressSubmit}
          editingItem={editingAddress}
          isSubmitting={isSubmittingAddress}
          customerId={editingItem.id}
        />
      )}

      {/* Date Picker */}
      <DateTimePickerSafe
        visible={showDatePicker}
        mode="date"
        value={tempDate}
        onConfirm={(date) => {
          if (dateOnChange) {
            dateOnChange(date.toISOString().split('T')[0]);
          }
          setShowDatePicker(false);
        }}
        onCancel={() => setShowDatePicker(false)}
        title="Fecha de nacimiento"
        maximumDate={new Date()}
      />
    </>
  );
}

const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    modalContainer: {
      margin: responsive.isTablet ? 20 : 10,
      justifyContent: 'center',
      alignItems: 'center',
    },
    modalContent: {
      borderRadius: theme.roundness * 2,
      backgroundColor: theme.colors.surface,
      maxHeight: '95%',
      minHeight: responsive.isTablet ? 600 : '80%',
      width: responsive.isTablet ? '85%' : '100%',
      maxWidth: responsive.isTablet ? 800 : undefined,
      overflow: 'hidden',
    },
    headerContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingHorizontal: responsive.isTablet
        ? theme.spacing.m * 0.7
        : theme.spacing.m,
      paddingVertical: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    headerLeft: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
    },
    headerIcon: {
      marginRight: responsive.isTablet
        ? theme.spacing.s * 0.7
        : theme.spacing.s,
    },
    headerTextContainer: {
      flex: 1,
    },
    modalTitle: {
      fontWeight: '700',
      fontSize: responsive.isTablet ? 16 : 18,
    },
    formContainer: {
      flex: 1,
      paddingHorizontal: responsive.isTablet
        ? theme.spacing.m * 0.7
        : theme.spacing.m,
      paddingTop: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    sectionContainer: {
      marginBottom: responsive.isTablet
        ? theme.spacing.s * 0.7
        : theme.spacing.s,
    },
    sectionHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    sectionTitle: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: responsive.isTablet ? 13 : 14,
    },
    requiredChip: {
      backgroundColor: theme.colors.errorContainer,
    },
    requiredChipText: {
      color: theme.colors.onErrorContainer,
      fontSize: responsive.isTablet ? 10 : 11,
    },
    optionalChip: {
      backgroundColor: theme.colors.surfaceVariant,
    },
    optionalChipText: {
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 10 : 11,
    },
    inputContainer: {
      marginBottom: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    inputOutline: {
      borderRadius: theme.roundness * 2,
    },
    switchContainer: {
      borderRadius: theme.roundness * 2,
      padding: responsive.isTablet ? theme.spacing.xs * 0.7 : theme.spacing.xs,
    },
    switchContent: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    switchTextContainer: {
      flex: 1,
      marginRight: responsive.isTablet
        ? theme.spacing.m * 0.7
        : theme.spacing.m,
    },
    switchLabel: {
      color: theme.colors.onSurface,
      fontWeight: '500',
      fontSize: responsive.isTablet ? 14 : 16,
    },
    switchDescription: {
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
      fontSize: responsive.isTablet ? 12 : 14,
    },
    bannedContainer: {
      marginTop: responsive.isTablet ? theme.spacing.s * 0.7 : theme.spacing.s,
    },
    banReasonContainer: {
      marginTop: responsive.isTablet ? theme.spacing.s * 0.7 : theme.spacing.s,
    },
    infoCard: {
      borderRadius: theme.roundness * 2,
      padding: responsive.isTablet ? theme.spacing.m * 0.7 : theme.spacing.m,
      marginTop: responsive.isTablet ? theme.spacing.s * 0.7 : theme.spacing.s,
      backgroundColor: theme.colors.errorContainer,
    },
    infoCardContent: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    infoText: {
      flex: 1,
      marginLeft: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    infoLabel: {
      color: theme.colors.onErrorContainer,
      opacity: 0.8,
      fontSize: responsive.isTablet ? 11 : 12,
    },
    infoValue: {
      color: theme.colors.onErrorContainer,
      fontWeight: '500',
      fontSize: responsive.isTablet ? 13 : 14,
    },
    whatsappCard: {
      borderRadius: theme.roundness * 2,
      padding: responsive.isTablet ? theme.spacing.m * 0.7 : theme.spacing.m,
      backgroundColor: theme.colors.primaryContainer + '20',
    },
    whatsappRow: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    whatsappStat: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.isTablet ? theme.spacing.s * 0.7 : theme.spacing.s,
    },
    whatsappStatContent: {
      flex: 1,
    },
    whatsappLabel: {
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 11 : 12,
    },
    whatsappValue: {
      color: theme.colors.onSurface,
      fontWeight: '600',
      marginTop: 2,
      fontSize: responsive.isTablet ? 13 : 14,
    },
    whatsappDivider: {
      width: 1,
      height: responsive.isTablet ? 35 : 40,
      backgroundColor: theme.colors.outlineVariant,
      marginHorizontal: responsive.isTablet
        ? theme.spacing.m * 0.7
        : theme.spacing.m,
    },
    stripeCard: {
      borderRadius: theme.roundness * 2,
      padding: responsive.isTablet ? theme.spacing.m * 0.7 : theme.spacing.m,
      backgroundColor: theme.colors.surfaceVariant,
    },
    stripeContent: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.isTablet ? theme.spacing.m * 0.7 : theme.spacing.m,
    },
    stripeInfo: {
      flex: 1,
    },
    stripeLabel: {
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 11 : 12,
      marginBottom: responsive.isTablet ? 3 : 4,
    },
    stripeValue: {
      color: theme.colors.onSurface,
      fontWeight: '500',
      fontFamily: 'monospace',
      fontSize: responsive.isTablet ? 13 : 14,
    },
    buttonContainer: {
      flexDirection: 'row',
      justifyContent: 'center',
      padding: responsive.isTablet ? theme.spacing.s * 0.7 : theme.spacing.s,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      gap: responsive.isTablet ? theme.spacing.s * 0.7 : theme.spacing.s,
      borderBottomLeftRadius: theme.roundness * 2,
      borderBottomRightRadius: theme.roundness * 2,
    },
    button: {
      flex: 1,
      maxWidth: 150,
    },
    cancelButton: {
      backgroundColor: theme.colors.secondaryContainer,
    },
    confirmButton: {},
    addressList: {
      gap: responsive.isTablet ? theme.spacing.s * 0.7 : theme.spacing.s,
    },
    addressCard: {
      borderRadius: theme.roundness * 2,
      padding: responsive.isTablet ? theme.spacing.s * 0.7 : theme.spacing.s,
      marginBottom: responsive.isTablet
        ? theme.spacing.xs * 0.65
        : theme.spacing.xs,
    },
    addressContent: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
    },
    addressHeader: {
      flexDirection: 'row',
      flex: 1,
    },
    addressInfo: {
      flex: 1,
      marginLeft: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    addressName: {
      fontWeight: '600',
      color: theme.colors.primary,
      fontSize: responsive.isTablet ? 13 : 14,
    },
    addressStreet: {
      fontWeight: '500',
      color: theme.colors.onSurface,
      fontSize: responsive.isTablet ? 13 : 14,
    },
    addressDetails: {
      color: theme.colors.onSurfaceVariant,
      marginTop: responsive.isTablet
        ? theme.spacing.xs * 0.65
        : theme.spacing.xs,
      fontSize: responsive.isTablet ? 12 : 13,
    },
    addressActions: {
      flexDirection: 'row',
    },
    defaultChip: {
      marginTop: responsive.isTablet
        ? theme.spacing.xs * 0.65
        : theme.spacing.xs,
      backgroundColor: theme.colors.primaryContainer,
    },
    defaultChipText: {
      color: theme.colors.onPrimaryContainer,
      fontSize: responsive.isTablet ? 9 : 10,
    },
    emptyAddressContainer: {
      padding: responsive.isTablet ? theme.spacing.l * 0.7 : theme.spacing.l,
      borderRadius: theme.roundness * 2,
      backgroundColor: theme.colors.surfaceVariant,
      alignItems: 'center',
    },
    emptyAddressText: {
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 13 : 14,
    },
  });

================
File: app/src/modules/menu/components/ProductFormModal.tsx
================
import React, { useEffect, useMemo, useState, useCallback } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Button,
  TextInput,
  Text,
  ActivityIndicator,
  Switch,
  HelperText,
  Divider,
  IconButton,
  Card,
  Checkbox,
  TouchableRipple,
} from 'react-native-paper';
import {
  useForm,
  Controller,
  useFieldArray,
  SubmitHandler,
} from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';

import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import {
  ProductFormInputs,
  productSchema,
  updateProductSchema,
  ProductVariant,
  Product,
} from '../schema/products.schema';
import { ModifierGroup } from '../../modifiers/schema/modifierGroup.schema';
import { getApiErrorMessage } from '@/app/lib/errorMapping';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import VariantFormModal from './VariantFormModal';
import CustomImagePicker, {
  FileObject,
} from '@/app/components/common/CustomImagePicker';
import { ImageUploadService } from '@/app/lib/imageUploadService';
import { getImageUrl } from '@/app/lib/imageUtils';
import { useModifierGroupsQuery } from '../../modifiers/hooks/useModifierGroupsQuery';
import { modifierService } from '../../modifiers/services/modifierService';
import { useGetPreparationScreens } from '../../preparationScreens/hooks/usePreparationScreensQueries';
import { Menu } from 'react-native-paper';

interface ProductFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSubmit: (
    data: ProductFormInputs,
    photoId: string | null | undefined,
    file?: FileObject | null,
  ) => Promise<void>;
  initialData?: Product | null;
  isSubmitting: boolean;
  productId?: string | null;
  subcategoryId: string;
}

function ProductFormModal({
  visible,
  onDismiss,
  onSubmit,
  initialData,
  isSubmitting,
  productId,
  subcategoryId,
}: ProductFormModalProps): React.ReactElement {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const isEditing = !!productId && !!initialData;

  const [isVariantModalVisible, setIsVariantModalVisible] = useState(false);
  const [editingVariantIndex, setEditingVariantIndex] = useState<number | null>(
    null,
  );
  const [localSelectedFile, setLocalSelectedFile] = useState<FileObject | null>(
    null,
  );
  const [isInternalImageUploading, setIsInternalImageUploading] =
    useState(false);
  const [groupModifiers, setGroupModifiers] = useState<Record<string, any[]>>(
    {},
  );
  const [priceInputValue, setPriceInputValue] = useState<string>('');
  const [preparationScreenMenuVisible, setPreparationScreenMenuVisible] =
    useState(false);

  const defaultValues = useMemo(
    (): ProductFormInputs => ({
      name: '',
      description: null,
      price: null,
      hasVariants: false,
      isActive: true,
      isPizza: false,
      subcategoryId: subcategoryId,
      photoId: null,
      estimatedPrepTime: 10,
      preparationScreenId: null,
      sortOrder: 0,
      variants: [],
      variantsToDelete: [],
      imageUri: null,
      modifierGroupIds: [],
    }),
    [subcategoryId],
  );

  const {
    control,
    handleSubmit,
    reset,
    watch,
    setValue,
    formState: { errors },
  } = useForm<ProductFormInputs>({
    resolver: zodResolver(initialData ? updateProductSchema : productSchema),
    defaultValues: defaultValues,
  });

  const {
    fields: variantFields,
    append: appendVariant,
    remove: removeVariant,
    update: updateVariant,
  } = useFieldArray({
    control,
    name: 'variants',
  });

  useEffect(() => {
    const loadInitialData = async () => {
      if (visible) {
        if (isEditing && initialData) {
          const initialPrice = initialData.price;
          const parsedPrice =
            initialPrice !== null &&
            initialPrice !== undefined &&
            !isNaN(parseFloat(String(initialPrice)))
              ? parseFloat(String(initialPrice))
              : null;

          // Procesar la URL de la imagen si existe
          let imageUrl = null;
          if (initialData.photo?.path) {
            try {
              imageUrl = await getImageUrl(initialData.photo.path);
            } catch (error) {
              imageUrl = initialData.photo.path; // Fallback al path original
            }
          }

          reset({
            name: initialData.name,
            description: initialData.description || null,
            price: parsedPrice,
            hasVariants: initialData.hasVariants,
            isActive: initialData.isActive,
            isPizza: initialData.isPizza ?? false,
            subcategoryId: initialData.subcategoryId,
            photoId: initialData.photo?.id ?? null,
            estimatedPrepTime: initialData.estimatedPrepTime,
            preparationScreenId: initialData.preparationScreenId || null,
            sortOrder: initialData.sortOrder ?? 0,
            variants: initialData.variants || [],
            variantsToDelete: [],
            imageUri: imageUrl,
            modifierGroupIds: [],
          });
          setLocalSelectedFile(null);
        } else {
          reset(defaultValues);
          setLocalSelectedFile(null);
        }
      }
    };

    loadInitialData();
  }, [visible, isEditing, initialData, reset, defaultValues, subcategoryId]);

  const hasVariants = watch('hasVariants');
  const currentImageUri = watch('imageUri');
  const priceValue = watch('price');

  useEffect(() => {
    setPriceInputValue(
      priceValue !== null && priceValue !== undefined
        ? priceValue.toString()
        : '',
    );
  }, [priceValue]);

  const { data: modifierGroupsResponse, isLoading: isLoadingGroups } =
    useModifierGroupsQuery({ isActive: true });

  const { data: preparationScreensResponse } = useGetPreparationScreens(
    {},
    { page: 1, limit: 50 },
  );
  const preparationScreens = preparationScreensResponse?.data || [];

  const allModifierGroups = modifierGroupsResponse?.data || [];

  useEffect(() => {
    const loadModifiers = async () => {
      const modifiersMap: Record<string, any[]> = {};

      for (const group of allModifierGroups) {
        try {
          const modifiers = await modifierService.findByGroupId(group.id);
          modifiersMap[group.id] = modifiers.filter((mod) => mod.isActive);
        } catch (error) {
          modifiersMap[group.id] = [];
        }
      }

      setGroupModifiers(modifiersMap);
    };

    if (allModifierGroups.length > 0) {
      loadModifiers();
    }
  }, [allModifierGroups]);

  useEffect(() => {
    if (visible) {
      if (isEditing && initialData?.modifierGroups) {
        if (Array.isArray(initialData.modifierGroups)) {
          const assignedIds = initialData.modifierGroups.map(
            (group: ModifierGroup) => group.id,
          );
          setValue('modifierGroupIds', assignedIds);
        } else {
          setValue('modifierGroupIds', []);
        }
      } else if (!isEditing) {
        setValue('modifierGroupIds', []);
      } else if (isEditing && !initialData?.modifierGroups) {
        setValue('modifierGroupIds', []);
      }
    }
  }, [visible, isEditing, initialData, setValue, reset, defaultValues]);

  const handleImageSelected = useCallback(
    (uri: string, file: FileObject) => {
      setValue('imageUri', uri, { shouldValidate: true, shouldDirty: true });
      setLocalSelectedFile(file);
    },
    [setValue],
  );

  const handleImageRemoved = useCallback(() => {
    setValue('imageUri', null, { shouldValidate: true, shouldDirty: true });
    setLocalSelectedFile(null);
  }, [setValue]);

  const processSubmit: SubmitHandler<ProductFormInputs> = async (formData) => {
    if (isSubmitting || isInternalImageUploading) return;

    let finalPhotoId: string | null | undefined = undefined;

    if (localSelectedFile) {
      setIsInternalImageUploading(true);
      try {
        const uploadResult =
          await ImageUploadService.uploadImage(localSelectedFile);
        if (uploadResult.success && uploadResult.photoId) {
          finalPhotoId = uploadResult.photoId;
        } else {
          throw new Error(
            uploadResult.error || 'La subida de la imagen fall√≥.',
          );
        }
      } catch (error) {
        showSnackbar({
          message: `Error al subir imagen: ${getApiErrorMessage(error)}`,
          type: 'error',
        });
        setIsInternalImageUploading(false);
        return;
      } finally {
        setIsInternalImageUploading(false);
      }
    } else {
      finalPhotoId = await ImageUploadService.determinePhotoId(
        currentImageUri,
        initialData ?? undefined,
      );
    }

    const finalData = {
      ...formData,
      price: hasVariants ? null : formData.price,
      variants: hasVariants ? formData.variants : [],
    };

    await onSubmit(finalData, finalPhotoId, localSelectedFile);
    setLocalSelectedFile(null);
  };

  const showVariantModal = (index: number | null = null) => {
    setEditingVariantIndex(index);
    setIsVariantModalVisible(true);
  };

  const handleVariantSubmit = (variantData: ProductVariant) => {
    if (editingVariantIndex !== null) {
      const originalVariantId =
        initialData?.variants?.[editingVariantIndex]?.id;

      const priceAsNumber = Number(variantData.price);

      const dataToUpdate = {
        ...variantData,
        price: isNaN(priceAsNumber) ? 0 : priceAsNumber,
        ...(originalVariantId && { id: originalVariantId }),
      };

      const finalDataToUpdate =
        !originalVariantId && 'id' in dataToUpdate
          ? (({ id, ...rest }) => rest)(dataToUpdate)
          : dataToUpdate;

      updateVariant(editingVariantIndex, finalDataToUpdate as ProductVariant);
    } else {
      const { id, price, ...restNewVariantData } = variantData;
      const newPriceAsNumber = Number(price);
      const newVariantData = {
        ...restNewVariantData,
        price: isNaN(newPriceAsNumber) ? 0 : newPriceAsNumber,
      };
      appendVariant(newVariantData as ProductVariant);
    }
    setIsVariantModalVisible(false);
    setEditingVariantIndex(null);
  };

  const handleRemoveVariant = (index: number) => {
    const variantToRemove = variantFields[index];
    if (variantToRemove.id) {
      const currentToDelete = watch('variantsToDelete') || [];
      setValue('variantsToDelete', [...currentToDelete, variantToRemove.id]);
    }
    removeVariant(index);
  };

  const variantInitialData =
    editingVariantIndex !== null
      ? (variantFields[editingVariantIndex] as ProductVariant)
      : undefined;

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalSurface}
        dismissable={!isSubmitting && !isInternalImageUploading}
      >
        <View style={styles.modalHeader}>
          <Text variant="titleLarge" style={styles.modalTitle}>
            {isEditing ? 'Editar Producto' : 'Nuevo Producto'}
          </Text>
        </View>

        <ScrollView contentContainerStyle={styles.scrollContent}>
          <Card style={styles.card}>
            <Card.Content>
              <View style={styles.imagePickerContainer}>
                <CustomImagePicker
                  value={currentImageUri}
                  onImageSelected={handleImageSelected}
                  onImageRemoved={handleImageRemoved}
                  isLoading={isInternalImageUploading}
                  disabled={isSubmitting}
                  size={150}
                  placeholderIcon="food-outline"
                  placeholderText="Imagen del producto"
                />
                {errors.imageUri && (
                  <HelperText type="error">
                    {errors.imageUri.message}
                  </HelperText>
                )}
              </View>

              <Controller
                control={control}
                name="name"
                render={({ field: { onChange, onBlur, value } }) => (
                  <TextInput
                    label="Nombre del Producto *"
                    value={value}
                    onChangeText={onChange}
                    onBlur={onBlur}
                    error={!!errors.name}
                    style={styles.input}
                    disabled={isSubmitting}
                  />
                )}
              />
              {errors.name && (
                <HelperText type="error" visible={!!errors.name}>
                  {errors.name.message}
                </HelperText>
              )}

              <Controller
                control={control}
                name="description"
                render={({ field: { onChange, onBlur, value } }) => (
                  <TextInput
                    label="Descripci√≥n"
                    value={value || ''}
                    onChangeText={onChange}
                    onBlur={onBlur}
                    error={!!errors.description}
                    style={styles.input}
                    disabled={isSubmitting}
                    multiline
                    numberOfLines={3}
                  />
                )}
              />
              {errors.description && (
                <HelperText type="error" visible={!!errors.description}>
                  {errors.description.message}
                </HelperText>
              )}

              <View style={styles.switchContainer}>
                <Text style={styles.label}>¬øTiene Variantes?</Text>
                <Controller
                  control={control}
                  name="hasVariants"
                  render={({ field: { onChange, value } }) => (
                    <Switch
                      value={value}
                      onValueChange={(newValue) => {
                        onChange(newValue);
                        if (newValue) {
                          setValue('price', null, { shouldValidate: true });
                        }
                      }}
                      disabled={isSubmitting}
                    />
                  )}
                />
              </View>

              {hasVariants && errors.price && (
                <HelperText type="error" visible={!!errors.price}>
                  {errors.price.message}
                </HelperText>
              )}

              {!hasVariants && (
                <>
                  <Controller
                    control={control}
                    name="price"
                    render={({ field }) => (
                      <TextInput
                        mode="outlined"
                        label="Precio *"
                        keyboardType="decimal-pad"
                        value={priceInputValue}
                        onChangeText={(text) => {
                          const formattedText = text.replace(/,/g, '.');

                          if (/^(\d*\.?\d*)$/.test(formattedText)) {
                            setPriceInputValue(formattedText);
                            if (formattedText === '') {
                              field.onChange(null);
                            } else if (formattedText !== '.') {
                              field.onChange(parseFloat(formattedText));
                            }
                          }
                        }}
                        error={!!errors.price}
                        disabled={isSubmitting || hasVariants}
                        style={styles.input}
                      />
                    )}
                  />
                  {errors.price && (
                    <HelperText type="error" visible={!!errors.price}>
                      {errors.price?.message || 'Precio inv√°lido'}
                    </HelperText>
                  )}
                </>
              )}

              {hasVariants && (
                <View style={styles.variantsSection}>
                  <Divider style={styles.divider} />
                  <View style={styles.variantsHeader}>
                    <Text variant="titleMedium">Variantes</Text>
                    <Button
                      mode="contained-tonal"
                      icon="plus"
                      onPress={() => showVariantModal()}
                      disabled={isSubmitting}
                    >
                      A√±adir
                    </Button>
                  </View>
                  {variantFields.length === 0 && (
                    <Text style={styles.noVariantsText}>
                      A√∫n no hay variantes a√±adidas.
                    </Text>
                  )}
                  {variantFields.map((field, index) => (
                    <Card
                      key={field.id || `new-${index}`}
                      style={[
                        styles.variantCard,
                        field.isActive === false && styles.variantCardInactive,
                      ]}
                    >
                      <View style={styles.variantContent}>
                        <View style={styles.variantInfo}>
                          <View style={styles.variantHeader}>
                            <Text
                              style={[
                                styles.variantName,
                                field.isActive === false &&
                                  styles.variantNameInactive,
                              ]}
                              numberOfLines={1}
                              ellipsizeMode="tail"
                            >
                              {field.name || 'Nueva Variante'}
                            </Text>
                            {field.isActive === false && (
                              <View style={styles.inactiveBadge}>
                                <Text style={styles.inactiveBadgeText}>
                                  Inactiva
                                </Text>
                              </View>
                            )}
                          </View>
                          <Text style={styles.variantPrice}>
                            $
                            {!isNaN(Number(field.price))
                              ? Number(field.price).toFixed(2)
                              : '0.00'}
                          </Text>
                        </View>
                        <View style={styles.variantActions}>
                          <IconButton
                            icon="pencil"
                            size={24}
                            onPress={() => showVariantModal(index)}
                            disabled={isSubmitting}
                            style={styles.variantActionButton}
                          />
                          <IconButton
                            icon="delete"
                            size={24}
                            onPress={() => handleRemoveVariant(index)}
                            iconColor={theme.colors.error}
                            disabled={isSubmitting}
                            style={styles.variantActionButton}
                          />
                        </View>
                      </View>
                    </Card>
                  ))}
                  {/* Mostrar error si hasVariants es true pero no hay variantes */}
                  {errors.variants?.message && (
                    <HelperText
                      type="error"
                      visible={!!errors.variants.message}
                    >
                      {errors.variants.message as string}
                    </HelperText>
                  )}
                  {/* Tambi√©n podr√≠a estar en root para errores de array */}
                  {errors.variants?.root?.message && (
                    <HelperText
                      type="error"
                      visible={!!errors.variants.root.message}
                    >
                      {errors.variants.root.message as string}
                    </HelperText>
                  )}
                </View>
              )}

              <Divider style={styles.divider} />

              <Controller
                control={control}
                name="estimatedPrepTime"
                render={({ field: { onChange, onBlur, value } }) => (
                  <TextInput
                    label="Tiempo Prep. Estimado (min)"
                    value={
                      value !== null && value !== undefined ? String(value) : ''
                    }
                    onChangeText={(text) =>
                      onChange(text ? parseInt(text, 10) : 0)
                    }
                    onBlur={onBlur}
                    error={!!errors.estimatedPrepTime}
                    style={styles.input}
                    keyboardType="numeric"
                    disabled={isSubmitting}
                  />
                )}
              />
              {errors.estimatedPrepTime && (
                <HelperText type="error" visible={!!errors.estimatedPrepTime}>
                  {errors.estimatedPrepTime.message}
                </HelperText>
              )}

              {/* Campo de Pantalla de Preparaci√≥n */}
              <Controller
                control={control}
                name="preparationScreenId"
                render={({ field: { onChange, value } }) => (
                  <View>
                    <Menu
                      visible={preparationScreenMenuVisible}
                      onDismiss={() => setPreparationScreenMenuVisible(false)}
                      anchor={
                        <TextInput
                          label="Pantalla de Preparaci√≥n"
                          value={
                            preparationScreens.find(
                              (screen) => screen.id === value,
                            )?.name || ''
                          }
                          onPress={() => setPreparationScreenMenuVisible(true)}
                          right={
                            value ? (
                              <TextInput.Icon
                                icon="close"
                                onPress={() => {
                                  onChange(null);
                                }}
                              />
                            ) : (
                              <TextInput.Icon
                                icon="chevron-down"
                                onPress={() =>
                                  setPreparationScreenMenuVisible(true)
                                }
                              />
                            )
                          }
                          editable={false}
                          error={!!errors.preparationScreenId}
                          style={styles.input}
                          disabled={isSubmitting}
                        />
                      }
                    >
                      {preparationScreens.map((screen) => (
                        <Menu.Item
                          key={screen.id}
                          onPress={() => {
                            onChange(screen.id);
                            setPreparationScreenMenuVisible(false);
                          }}
                          title={screen.name}
                        />
                      ))}
                    </Menu>
                  </View>
                )}
              />
              {errors.preparationScreenId && (
                <HelperText type="error" visible={!!errors.preparationScreenId}>
                  {errors.preparationScreenId.message}
                </HelperText>
              )}

              <Controller
                control={control}
                name="sortOrder"
                render={({ field: { onChange, onBlur, value } }) => (
                  <TextInput
                    label="Orden de visualizaci√≥n"
                    value={
                      value !== null && value !== undefined ? String(value) : ''
                    }
                    onChangeText={(text) =>
                      onChange(text ? parseInt(text, 10) : 0)
                    }
                    onBlur={onBlur}
                    error={!!errors.sortOrder}
                    style={styles.input}
                    keyboardType="numeric"
                    disabled={isSubmitting}
                  />
                )}
              />
              {errors.sortOrder && (
                <HelperText type="error" visible={!!errors.sortOrder}>
                  {errors.sortOrder.message}
                </HelperText>
              )}

              <View style={styles.switchContainer}>
                <Text style={styles.label}>Activo</Text>
                <Controller
                  control={control}
                  name="isActive"
                  render={({ field: { onChange, value } }) => (
                    <Switch
                      value={value}
                      onValueChange={onChange}
                      disabled={isSubmitting}
                    />
                  )}
                />
              </View>

              <View style={styles.switchContainer}>
                <Text style={styles.label}>Es Pizza</Text>
                <Controller
                  control={control}
                  name="isPizza"
                  render={({ field: { onChange, value } }) => (
                    <Switch
                      value={value}
                      onValueChange={onChange}
                      disabled={isSubmitting}
                    />
                  )}
                />
              </View>

              <Divider style={styles.divider} />

              <View style={styles.modifierGroupSection}>
                <Text variant="titleMedium" style={styles.sectionTitle}>
                  Grupos de Modificadores
                </Text>
                {isLoadingGroups ? (
                  <ActivityIndicator
                    animating={true}
                    style={{
                      marginVertical: responsive.spacing(theme.spacing.m),
                    }}
                  />
                ) : allModifierGroups.length === 0 ? (
                  <Text style={styles.noItemsText}>
                    No hay grupos de modificadores disponibles.
                  </Text>
                ) : (
                  <Controller
                    control={control}
                    name="modifierGroupIds"
                    render={({ field: { onChange, value } }) => {
                      const currentIds = Array.isArray(value) ? value : []; // Asegurar que sea array
                      const availableGroups = allModifierGroups; // Ya es un array de ModifierGroup

                      return (
                        <>
                          {availableGroups.map((group: ModifierGroup) => {
                            const isSelected = currentIds.includes(group.id);
                            const modifiers = groupModifiers[group.id] || [];

                            return (
                              <TouchableRipple
                                key={group.id}
                                onPress={() => {
                                  const newIds = isSelected
                                    ? currentIds.filter((id) => id !== group.id)
                                    : [...currentIds, group.id];
                                  onChange(newIds);
                                }}
                                disabled={isSubmitting}
                                style={styles.modifierGroupTouchable}
                              >
                                <View style={styles.modifierGroupContent}>
                                  <Checkbox
                                    status={
                                      isSelected ? 'checked' : 'unchecked'
                                    }
                                    disabled={isSubmitting}
                                  />
                                  <View
                                    style={styles.modifierGroupTextContainer}
                                  >
                                    <Text style={styles.modifierGroupName}>
                                      {group.name}
                                    </Text>
                                    {modifiers.length > 0 && (
                                      <View
                                        style={styles.modifiersListContainer}
                                      >
                                        {modifiers.map((modifier, index) => (
                                          <Text
                                            key={modifier.id}
                                            style={styles.modifierItem}
                                          >
                                            {modifier.isDefault && '‚úì '}
                                            {modifier.name}
                                            {index < modifiers.length - 1 &&
                                              ', '}
                                          </Text>
                                        ))}
                                      </View>
                                    )}
                                    {modifiers.length === 0 && (
                                      <Text style={styles.noModifiersText}>
                                        Sin modificadores activos
                                      </Text>
                                    )}
                                  </View>
                                </View>
                              </TouchableRipple>
                            );
                          })}
                        </>
                      );
                    }}
                  />
                )}
                {errors.modifierGroupIds && (
                  <HelperText type="error" visible={!!errors.modifierGroupIds}>
                    {errors.modifierGroupIds.message as string}
                  </HelperText>
                )}
              </View>
            </Card.Content>
          </Card>
        </ScrollView>

        {(isSubmitting || isInternalImageUploading) && (
          <View style={styles.loadingOverlay}>
            <ActivityIndicator
              animating={true}
              size="large"
              color={theme.colors.primary}
            />
          </View>
        )}

        <View style={styles.modalActions}>
          <Button
            mode="outlined"
            onPress={onDismiss}
            style={[styles.formButton, styles.cancelButton]}
            disabled={isSubmitting || isInternalImageUploading}
          >
            Cancelar
          </Button>
          <Button
            mode="contained"
            onPress={handleSubmit(processSubmit)}
            loading={isSubmitting || isInternalImageUploading}
            disabled={isSubmitting || isInternalImageUploading}
            style={styles.formButton}
          >
            {isEditing ? 'Guardar' : 'Crear'}
          </Button>
        </View>
      </Modal>

      <VariantFormModal
        visible={isVariantModalVisible}
        onDismiss={() => setIsVariantModalVisible(false)}
        onSubmit={handleVariantSubmit}
        initialData={variantInitialData}
      />
    </Portal>
  );
}

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    modalSurface: {
      padding: 0,
      margin: responsive.spacing(20),
      marginHorizontal: responsive.isTablet
        ? responsive.spacing(40)
        : responsive.spacing(20),
      borderRadius: theme.roundness * 2,
      elevation: 4,
      backgroundColor: theme.colors.background,
      maxHeight: responsive.isTablet ? '92%' : '90%',
      minHeight: responsive.isTablet ? 650 : undefined,
      maxWidth: responsive.isTablet ? 700 : 500,
      alignSelf: 'center',
      width: responsive.isTablet ? '85%' : '90%',
      overflow: 'hidden',
    },
    modalHeader: {
      backgroundColor: theme.colors.primary,
      paddingVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      paddingHorizontal: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
      borderTopLeftRadius: theme.roundness * 2,
      borderTopRightRadius: theme.roundness * 2,
    },
    modalTitle: {
      color: theme.colors.onPrimary,
      fontWeight: 'bold',
      textAlign: 'center',
      fontSize: responsive.isTablet ? 20 : 22,
    },
    scrollContent: {
      padding: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
      paddingBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.l)
        : responsive.spacing(theme.spacing.xl),
    },
    card: {
      backgroundColor: theme.colors.surface,
      elevation: 1,
    },
    input: {
      marginBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surfaceVariant,
    },
    switchContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
    },
    label: {
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 14 : 16,
      marginRight: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
    },
    divider: {
      marginVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
    },
    variantsSection: {
      marginTop: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
    },
    variantsHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
    },
    variantCard: {
      marginBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
      backgroundColor: theme.colors.elevation.level1,
      paddingVertical: responsive.isTablet
        ? 6
        : responsive.spacing(theme.spacing.xs),
      paddingLeft: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      paddingRight: responsive.isTablet
        ? 4
        : responsive.spacing(theme.spacing.xs),
    },
    variantCardInactive: {
      opacity: 0.7,
      backgroundColor: theme.colors.surfaceVariant,
    },
    variantContent: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
    },
    variantInfo: {
      flex: 1,
      marginRight: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
    },
    variantHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: responsive.isTablet ? 1 : 2,
    },
    variantName: {
      fontSize: responsive.isTablet ? 13 : 15,
      fontWeight: '500',
      color: theme.colors.onSurface,
      flex: 1,
    },
    variantNameInactive: {
      color: theme.colors.onSurfaceVariant,
    },
    variantPrice: {
      fontSize: responsive.isTablet ? 12 : 14,
      color: theme.colors.primary,
      fontWeight: '600',
    },
    inactiveBadge: {
      backgroundColor: theme.colors.errorContainer,
      paddingHorizontal: responsive.isTablet
        ? 6
        : responsive.spacing(theme.spacing.xs),
      paddingVertical: responsive.isTablet ? 1 : 2,
      borderRadius: 4,
      marginLeft: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.xs),
    },
    inactiveBadgeText: {
      fontSize: responsive.isTablet ? 9 : 10,
      color: theme.colors.onErrorContainer,
      fontWeight: '600',
    },
    variantActions: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.isTablet ? 4 : 8,
    },
    variantActionButton: {
      margin: 0,
    },
    noVariantsText: {
      textAlign: 'center',
      color: theme.colors.onSurfaceVariant,
      marginVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
      fontStyle: 'italic',
      fontSize: responsive.isTablet ? 13 : 14,
    },
    imagePickerContainer: {
      alignItems: 'center',
      marginBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
    },
    modifierGroupSection: {
      marginTop: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
    },
    sectionTitle: {
      marginBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
      marginLeft: responsive.isTablet
        ? 4
        : responsive.spacing(theme.spacing.xs),
      fontSize: responsive.isTablet ? 16 : 18,
    },
    noItemsText: {
      textAlign: 'center',
      color: theme.colors.onSurfaceVariant,
      marginVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
      fontStyle: 'italic',
      fontSize: responsive.isTablet ? 13 : 14,
    },
    modifierGroupTouchable: {
      paddingVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
      paddingHorizontal: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      marginHorizontal: responsive.isTablet
        ? -responsive.spacing(theme.spacing.s)
        : -responsive.spacing(theme.spacing.m),
    },
    modifierGroupContent: {
      flexDirection: 'row',
      alignItems: 'flex-start',
    },
    modifierGroupTextContainer: {
      flex: 1,
      marginLeft: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
    },
    modifierGroupName: {
      fontSize: responsive.isTablet ? 13 : 15,
      color: theme.colors.onSurface,
    },
    modifiersList: {
      fontSize: responsive.isTablet ? 11 : 12,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      marginTop: responsive.isTablet ? 1 : 2,
    },
    modifiersListContainer: {
      marginTop: responsive.isTablet ? 2 : 4,
      flexDirection: 'row',
      flexWrap: 'wrap',
      gap: responsive.isTablet ? 2 : 4,
    },
    modifierItem: {
      fontSize: responsive.isTablet ? 11 : 13,
      color: theme.colors.onSurfaceVariant,
      lineHeight: responsive.isTablet ? 15 : 18,
    },
    noModifiersText: {
      fontSize: responsive.isTablet ? 11 : 12,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      marginTop: responsive.isTablet ? 2 : 4,
      opacity: 0.7,
    },
    modalActions: {
      flexDirection: 'row',
      justifyContent: 'center',
      paddingVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      paddingHorizontal: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
      gap: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
    },
    formButton: {
      borderRadius: theme.roundness * 2,
      paddingHorizontal: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
      minWidth: responsive.isTablet ? 100 : 120,
    },
    cancelButton: {
      marginRight: 0,
    },
    loadingOverlay: {
      ...StyleSheet.absoluteFillObject,
      backgroundColor: 'rgba(0, 0, 0, 0.3)',
      justifyContent: 'center',
      alignItems: 'center',
      zIndex: 10,
      borderRadius: theme.roundness * 2,
    },
  });

export default ProductFormModal;

================
File: app/src/modules/orderFinalization/services/orderFinalizationService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import {
  OrderForFinalization,
  OrderForFinalizationList,
  FinalizeOrdersPayload,
} from '../types/orderFinalization.types';

export const orderFinalizationService = {
  async getOrdersForFinalizationList(): Promise<OrderForFinalizationList[]> {
    const response = await apiClient.get(
      API_PATHS.ORDERS_FOR_FINALIZATION_LIST,
    );
    return response.data;
  },

  async getOrderForFinalizationDetail(
    orderId: string,
  ): Promise<OrderForFinalization> {
    const response = await apiClient.get(
      API_PATHS.ORDERS_FOR_FINALIZATION_DETAIL.replace(':id', orderId),
    );
    return response.data;
  },

  async finalizeOrders(payload: FinalizeOrdersPayload): Promise<void> {
    await apiClient.patch(API_PATHS.ORDERS_FINALIZE_MULTIPLE, payload);
  },

  async quickFinalizeMultipleOrders(
    orderIds: string[],
  ): Promise<{ message: string; ordersWithWarnings: string[] }> {
    const response = await apiClient.post(
      API_PATHS.ORDERS_QUICK_FINALIZE_MULTIPLE,
      { orderIds },
    );
    return response.data;
  },

  async printTicket(
    orderId: string,
    params: { printerId: string; ticketType: 'GENERAL' | 'BILLING' },
  ): Promise<void> {
    await apiClient.post(
      API_PATHS.ORDERS_PRINT_TICKET.replace(':orderId', orderId),
      params,
    );
  },
};

================
File: app/src/modules/orders/screens/OrdersScreen.tsx
================
import React from 'react';
import { StyleSheet, View, ScrollView, RefreshControl } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Button, ActivityIndicator, Text } from 'react-native-paper';
import { useNavigation } from '@react-navigation/native';
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { useAppTheme } from '@/app/styles/theme';
import type { OrdersStackParamList } from '@/app/navigation/types';
import { useGlobalShift } from '@/app/hooks/useGlobalShift';
import { NAVIGATION_PATHS } from '@/app/constants/navigationPaths';

function OrdersScreen() {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);
  const navigation =
    useNavigation<NativeStackNavigationProp<OrdersStackParamList>>();

  const { data: shift, isLoading, isFetching, refetch } = useGlobalShift();
  const [isManualRefreshing, setIsManualRefreshing] = React.useState(false);

  // Manejar el pull to refresh
  const handleRefresh = React.useCallback(async () => {
    setIsManualRefreshing(true);
    await refetch();
    setIsManualRefreshing(false);
  }, [refetch]);

  const handleOpenOrders = () => {
    if (shift && shift.status === 'OPEN') {
      navigation.navigate(NAVIGATION_PATHS.OPEN_ORDERS);
    }
  };

  const handleCreateOrder = () => {
    if (shift && shift.status === 'OPEN') {
      navigation.navigate(NAVIGATION_PATHS.CREATE_ORDER);
    }
  };

  const isShiftOpen = shift && shift.status === 'OPEN';

  return (
    <SafeAreaView style={styles.container}>
      <ScrollView
        style={styles.scrollView}
        refreshControl={
          <RefreshControl
            refreshing={isManualRefreshing}
            onRefresh={handleRefresh}
            colors={[theme.colors.primary]}
            tintColor={theme.colors.primary}
          />
        }
        contentContainerStyle={styles.scrollContent}
      >
        <View style={styles.content}>
          {/* Indicador de carga */}
          {(isLoading || (isFetching && !isManualRefreshing)) && (
            <View style={styles.loadingIndicator}>
              <ActivityIndicator size="small" color={theme.colors.primary} />
              <Text variant="bodySmall" style={styles.loadingText}>
                Actualizando estado del turno...
              </Text>
            </View>
          )}
          {/* Bot√≥n Crear Orden */}
          <Button
            mode="contained"
            onPress={handleCreateOrder}
            style={[styles.button, !isShiftOpen && styles.buttonDisabled]}
            contentStyle={styles.buttonContent}
            icon="plus-circle-outline"
            disabled={!isShiftOpen}
          >
            Crear Orden
          </Button>

          {/* Bot√≥n √ìrdenes Abiertas */}
          <Button
            mode="contained"
            onPress={handleOpenOrders}
            style={[styles.button, !isShiftOpen && styles.buttonDisabled]}
            contentStyle={styles.buttonContent}
            icon="folder-open-outline"
            disabled={!isShiftOpen}
          >
            √ìrdenes Abiertas
          </Button>
        </View>
      </ScrollView>
    </SafeAreaView>
  );
}

const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    scrollView: {
      flex: 1,
    },
    scrollContent: {
      flexGrow: 1,
    },
    content: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.l,
    },
    loadingIndicator: {
      position: 'absolute',
      top: theme.spacing.m,
      alignSelf: 'center',
      flexDirection: 'row',
      alignItems: 'center',
      backgroundColor: theme.colors.surfaceVariant,
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.s,
      borderRadius: theme.roundness * 2,
      gap: theme.spacing.s,
    },
    loadingText: {
      color: theme.colors.onSurfaceVariant,
    },
    title: {
      marginBottom: theme.spacing.l,
      color: theme.colors.onBackground,
    },
    button: {
      width: '90%',
      marginVertical: theme.spacing.l,
    },
    buttonDisabled: {
      opacity: 0.6,
    },
    buttonContent: {
      paddingVertical: theme.spacing.m,
    },
  });

export default OrdersScreen;

================
File: app/src/modules/preparationScreens/screens/PreparationScreensScreen.tsx
================
import React, { useCallback, useMemo, useState } from 'react';
import { StyleSheet } from 'react-native';
import { IconButton, Text } from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useDrawerStatus } from '@react-navigation/drawer';
import { discoveryService } from '@/app/services/discoveryService';

import GenericList, {
  FilterOption,
} from '../../../app/components/crud/GenericList';
import PreparationScreenDetailModalSimple from '../components/PreparationScreenDetailModalSimple';
import PreparationScreenListItem from '../components/PreparationScreenListItem';
import { useCrudScreenLogic } from '../../../app/hooks/useCrudScreenLogic';
import PreparationScreenFormModal from '../components/PreparationScreenFormModal';
import { ProductSelectionModal } from '../components/ProductSelectionModal';
import {
  useGetPreparationScreens,
  useGetPreparationScreenById,
  useDeletePreparationScreen,
  useGetMenuWithAssociations,
  useAssociateProducts,
} from '../hooks/usePreparationScreensQueries';
import {
  PreparationScreen,
  FindAllPreparationScreensDto as FindAllPreparationScreensFilter,
} from '../schema/preparationScreen.schema';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { BaseListQuery } from '../../../app/types/query.types';
import { useListState } from '@/app/hooks/useListState';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';

const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
  });

const PreparationScreensScreen = () => {
  const theme = useAppTheme();
  const styles = useMemo(() => getStyles(theme), [theme]);
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';

  const [filters, setFilters] = useState<FindAllPreparationScreensFilter>({});
  const [pagination, setPagination] = useState<BaseListQuery>({
    page: 1,
    limit: 15,
  });
  const [searchTerm, setSearchTerm] = useState('');
  const [isProductModalVisible, setIsProductModalVisible] = useState(false);
  const [productModalScreenId, setProductModalScreenId] = useState<
    string | null
  >(null);

  const {
    data: screensData,
    isLoading: isLoadingList,
    isFetching: isFetchingList,
    refetch: refetchList,
    error: errorList,
  } = useGetPreparationScreens(filters, pagination);

  const { mutate: deleteScreenMutate } = useDeletePreparationScreen();
  const associateProductsMutation = useAssociateProducts();

  const deleteScreenWrapper = useCallback(
    async (id: string): Promise<void> => {
      return new Promise((resolve, reject) => {
        deleteScreenMutate(id, {
          onSuccess: () => resolve(),
          onError: (error) => reject(error),
        });
      });
    },
    [deleteScreenMutate],
  );

  // Hooks para el modal de productos
  const { data: menuData, isLoading: isLoadingMenu } =
    useGetMenuWithAssociations(productModalScreenId, {
      enabled: !!productModalScreenId && isProductModalVisible,
    });

  // Recargar autom√°ticamente cuando la pantalla recibe foco
  useRefreshModuleOnFocus('preparation-screens');

  // Enriquecer menuData con informaci√≥n de pantallas
  const enrichedMenuData = React.useMemo(() => {
    if (!menuData || !screensData?.data) return menuData;

    // Crear un mapa de productId a nombre de pantalla
    const screenAssignments: Record<string, string> = {};

    screensData.data.forEach((screen) => {
      if (screen.products) {
        screen.products.forEach((product) => {
          screenAssignments[product.id] = screen.name;
        });
      }
    });

    return {
      ...menuData,
      screenAssignments,
    };
  }, [menuData, screensData]);

  const handleOpenProductModal = useCallback((screen: PreparationScreen) => {
    setProductModalScreenId(screen.id);
    setIsProductModalVisible(true);
  }, []);

  const handleCloseProductModal = useCallback(() => {
    setIsProductModalVisible(false);
    setProductModalScreenId(null);
  }, []);

  const handleSaveProducts = useCallback(
    (productIds: string[]) => {
      if (productModalScreenId) {
        associateProductsMutation.mutate(
          { id: productModalScreenId, productIds },
          {
            onSuccess: () => {
              handleCloseProductModal();
              refetchList();
            },
          },
        );
      }
    },
    [
      productModalScreenId,
      associateProductsMutation,
      handleCloseProductModal,
      refetchList,
    ],
  );

  const {
    isFormModalVisible,
    isDetailModalVisible,
    editingItem,
    selectedItem,
    isDeleting,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
    deleteConfirmation,
  } = useCrudScreenLogic<PreparationScreen>({
    entityName: 'Pantalla de Preparaci√≥n',
    queryKey: ['preparationScreens', filters, pagination],
    deleteMutationFn: deleteScreenWrapper,
  });

  const selectedScreenId = selectedItem?.id ?? null;

  const { data: selectedScreenData } = useGetPreparationScreenById(
    selectedScreenId,
    {
      enabled: !!selectedScreenId && isDetailModalVisible,
    },
  );

  const handleRefresh = useCallback(async () => {
    // Si hay error de conexi√≥n, intentar redescubrir el servidor
    if (
      errorList &&
      (errorList.message?.includes('conexi√≥n') ||
        errorList.message?.includes('network'))
    ) {
      try {
        await discoveryService.forceRediscovery();
        // Dar tiempo para que se reinicialice el cliente
        await new Promise((resolve) => setTimeout(resolve, 500));
      } catch (error) {
        // No es cr√≠tico, el usuario puede intentar manualmente
      }
    }
    refetchList();
  }, [refetchList, errorList]);

  const handleSearchChange = useCallback((query: string) => {
    setSearchTerm(query);
    const timerId = setTimeout(() => {
      setFilters((prev: FindAllPreparationScreensFilter) => ({
        ...prev,
        name: query || undefined,
      }));
      setPagination((prev) => ({ ...prev, page: 1 }));
    }, 500);
    return () => clearTimeout(timerId);
  }, []);

  const handleFilterChange = useCallback((value: string | number) => {
    const strValue = String(value);
    let newIsActive: boolean | undefined;
    if (strValue === 'true') newIsActive = true;
    else if (strValue === 'false') newIsActive = false;
    else newIsActive = undefined;
    setFilters((prev: FindAllPreparationScreensFilter) => ({
      ...prev,
      isActive: newIsActive,
    }));
    setPagination((prev) => ({ ...prev, page: 1 }));
  }, []);

  const listRenderConfig = {
    titleField: 'name' as keyof PreparationScreen,
    descriptionField: 'description' as keyof PreparationScreen,
    statusConfig: {
      field: 'isActive' as keyof PreparationScreen,
      activeValue: true,
      activeLabel: 'Activa',
      inactiveLabel: 'Inactiva',
    },
    renderDescription: (item: PreparationScreen) => {
      const parts: string[] = [];

      if (item.description) {
        parts.push(item.description);
      }

      if (item.users && item.users.length > 0) {
        const userNames = item.users
          .map((user) => {
            const fullName =
              `${user.firstName || ''} ${user.lastName || ''}`.trim();
            return fullName || user.username;
          })
          .join(', ');
        parts.push(`Usuarios: ${userNames}`);
      }

      const text = parts.join(' ‚Ä¢ ');
      if (!text) return null;

      return (
        <Text variant="bodyMedium" numberOfLines={2} ellipsizeMode="tail">
          {text}
        </Text>
      );
    },
  };

  const filterOptions: FilterOption<string>[] = [
    { value: '', label: 'Todas' },
    { value: 'true', label: 'Activas' },
    { value: 'false', label: 'Inactivas' },
  ];

  const { ListEmptyComponent } = useListState({
    isLoading: isLoadingList,
    isError: !!errorList,
    data: screensData?.data,
    emptyConfig: {
      title: searchTerm
        ? 'No se encontraron pantallas'
        : 'No hay pantallas de preparaci√≥n',
      message: searchTerm
        ? `No se encontraron pantallas para "${searchTerm}"`
        : 'No hay pantallas de preparaci√≥n creadas. Presiona el bot√≥n + para crear la primera.',
      icon: 'monitor-dashboard',
    },
    errorConfig: {
      title: 'Error al cargar pantallas',
      message: errorList?.message?.includes('encontrar el servidor')
        ? 'No se pudo encontrar el servidor. Verifica que el servidor est√© encendido y en la misma red.'
        : 'No se pudieron cargar las pantallas de preparaci√≥n. Verifica tu conexi√≥n.',
      icon: 'alert-circle-outline',
      actionText: 'Reintentar',
      onAction: handleRefresh,
    },
  });

  const renderItem = useCallback(
    ({ item }: { item: PreparationScreen }) => (
      <PreparationScreenListItem
        item={item}
        onPress={handleOpenDetailModal}
        onManageProducts={handleOpenProductModal}
      />
    ),
    [handleOpenDetailModal, handleOpenProductModal],
  );

  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      <GenericList<PreparationScreen>
        showImagePlaceholder={false}
        items={screensData?.data ?? []}
        renderConfig={listRenderConfig}
        onItemPress={handleOpenDetailModal}
        onRefresh={handleRefresh}
        isRefreshing={isFetchingList && !isLoadingList}
        ListEmptyComponent={ListEmptyComponent}
        enableSearch={true}
        searchQuery={searchTerm}
        onSearchChange={handleSearchChange}
        searchPlaceholder="Buscar por nombre..."
        filterOptions={filterOptions}
        filterValue={
          filters.isActive === true
            ? 'true'
            : filters.isActive === false
              ? 'false'
              : ''
        }
        onFilterChange={handleFilterChange}
        showFab={true}
        onFabPress={handleOpenCreateModal}
        isModalOpen={
          isDetailModalVisible || isFormModalVisible || isProductModalVisible
        }
        isDrawerOpen={isDrawerOpen}
        renderItemActions={(item) => (
          <IconButton
            icon="link"
            size={20}
            onPress={() => handleOpenProductModal(item)}
          />
        )}
        renderItem={renderItem}
      />

      <PreparationScreenDetailModalSimple
        visible={isDetailModalVisible}
        onDismiss={handleCloseModals}
        item={selectedScreenData ?? selectedItem ?? null}
        onEdit={() => {
          const itemToEdit = selectedScreenData ?? selectedItem;
          if (itemToEdit) {
            handleOpenEditModal(itemToEdit);
          }
        }}
        deleteConfirmation={deleteConfirmation}
        onManageProducts={handleOpenProductModal}
        isDeleting={isDeleting}
      />

      <PreparationScreenFormModal
        visible={isFormModalVisible}
        onDismiss={handleCloseModals}
        editingItem={editingItem}
        onSubmitSuccess={() => {}}
      />

      <ProductSelectionModal
        visible={isProductModalVisible}
        onDismiss={handleCloseProductModal}
        onSave={handleSaveProducts}
        screenId={productModalScreenId || ''}
        menuData={enrichedMenuData}
        loading={isLoadingMenu}
      />
    </SafeAreaView>
  );
};

export default PreparationScreensScreen;

================
File: app/src/modules/printers/screens/PrintersScreen.tsx
================
import React, { useState, useMemo, useCallback } from 'react';
import { View, StyleSheet, FlatList } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Portal, ActivityIndicator, IconButton, FAB } from 'react-native-paper';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { useResponsive } from '../../../app/hooks/useResponsive';
import PrinterDiscoveryModal from '../components/PrinterDiscoveryModal';
import PrinterFormModal from '../components/PrinterFormModal';
import PrinterListItem from '../components/PrinterListItem';
import PrinterDetailModal from '../components/PrinterDetailModal';
import {
  DiscoveredPrinter,
  ThermalPrinter,
  CreateThermalPrinterDto,
} from '../types/printer.types';
import { useListState } from '../../../app/hooks/useListState';
import {
  usePrintersQuery,
  useDeletePrinterMutation,
  usePingPrinterMutation, // <-- Importar hook de ping
  useTestPrintPrinter, // <-- Importar hook de test print
} from '../hooks/usePrintersQueries';
import { useCrudScreenLogic } from '../../../app/hooks/useCrudScreenLogic'; // Importar hook CRUD
import { useDrawerStatus } from '@react-navigation/drawer';
import { useRefreshModuleOnFocus } from '../../../app/hooks/useRefreshOnFocus';

const PrintersScreen: React.FC = () => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';

  const [isDiscoveryModalVisible, setIsDiscoveryModalVisible] = useState(false);
  const [discoveredPrinterData, setDiscoveredPrinterData] =
    useState<Partial<CreateThermalPrinterDto> | null>(null);
  const [pingingPrinterId, setPingingPrinterId] = useState<string | null>(null);
  const [testPrintingPrinterId, setTestPrintingPrinterId] = useState<
    string | null
  >(null);
  const [fabOpen, setFabOpen] = useState(false); // Estado para el FAB.Group

  // --- L√≥gica CRUD ---
  const queryParams = useMemo(
    () => ({
      isActive: undefined,
      // A√±adir otros filtros si son necesarios (ej. name, connectionType)
      page: 1, // O manejar paginaci√≥n si es necesario
      limit: 50, // Ajustar l√≠mite seg√∫n necesidad
    }),
    [],
  );

  const {
    data: printersResponse,
    isLoading: isLoadingList,
    isFetching: isFetchingList,
    refetch: refetchList,
    error: listError,
  } = usePrintersQuery(queryParams);

  const { mutateAsync: deletePrinter } = useDeletePrinterMutation();
  const pingPrinterMutation = usePingPrinterMutation(); // Instanciar la mutaci√≥n de ping
  const testPrintMutation = useTestPrintPrinter(); // Instanciar la mutaci√≥n de test print

  // Refrescar impresoras cuando la pantalla recibe foco
  useRefreshModuleOnFocus('thermalPrinters');

  const {
    isFormModalVisible,
    isDetailModalVisible,
    editingItem,
    selectedItem,
    isDeleting,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
    deleteConfirmation,
  } = useCrudScreenLogic<ThermalPrinter>({
    entityName: 'Impresora',
    queryKey: ['thermalPrinters', queryParams], // Usar queryKey consistente
    deleteMutationFn: deletePrinter,
  });
  // --- Fin L√≥gica CRUD ---

  // Handler para imprimir ticket de prueba
  const handleTestPrint = useCallback(
    async (printerId: string) => {
      setTestPrintingPrinterId(printerId);
      try {
        await testPrintMutation.mutateAsync(printerId);
      } catch (error) {
        // El error ya se maneja en el hook con un snackbar
      } finally {
        setTestPrintingPrinterId(null);
      }
    },
    [testPrintMutation],
  );

  const handleOpenAddModal = () => {
    setDiscoveredPrinterData(null); // Limpiar datos de descubrimiento
    handleOpenCreateModal(); // Abrir modal de formulario vac√≠o
  };

  const handleOpenDiscoveryModal = () => {
    setIsDiscoveryModalVisible(true);
  };

  const handleDismissDiscoveryModal = () => {
    setIsDiscoveryModalVisible(false);
  };

  const handlePrinterSelectedFromDiscovery = (printer: DiscoveredPrinter) => {
    // Pre-rellenar datos para el formulario
    setDiscoveredPrinterData({
      name: printer.name || `Impresora ${printer.ip}`,
      connectionType: 'NETWORK', // Asumir NETWORK
      ipAddress: printer.ip,
      port: printer.port,
      macAddress: printer.mac || undefined,
    });
    setIsDiscoveryModalVisible(false); // Cerrar modal de descubrimiento
    handleOpenCreateModal(); // Abrir modal de formulario con datos pre-rellenados
  };

  // Funci√≥n para renderizar cada impresora
  const renderPrinter = useCallback(
    ({ item }: { item: ThermalPrinter }) => {
      const isPingingThis = pingingPrinterId === item.id;
      const canPing = item.connectionType === 'NETWORK';

      return (
        <PrinterListItem
          printer={item}
          onPress={() => handleOpenDetailModal(item)}
          renderActions={
            <View style={styles.itemActionsContainer}>
              {isPingingThis ? (
                <ActivityIndicator size={32} style={styles.pingIndicator} />
              ) : (
                <IconButton
                  icon="radar"
                  size={32}
                  onPress={() => handlePingPrinter(item.id)}
                  disabled={!canPing || pingPrinterMutation.isPending}
                  iconColor={
                    canPing
                      ? theme.colors.primary
                      : theme.colors.onSurfaceDisabled
                  }
                  style={styles.actionButton}
                />
              )}
            </View>
          }
        />
      );
    },
    [
      pingingPrinterId,
      pingPrinterMutation.isPending,
      handlePingPrinter,
      handleOpenDetailModal,
      theme.colors,
      styles,
    ],
  );

  // Filtrar datos seg√∫n el estado seleccionado
  const filteredData = useMemo(() => {
    if (!printersResponse?.data) return [];
    return printersResponse.data;
  }, [printersResponse?.data]);

  const { ListEmptyComponent } = useListState({
    isLoading: isLoadingList,
    isError: !!listError,
    data: printersResponse?.data,
    emptyConfig: {
      title: 'No hay impresoras',
      message:
        'No hay impresoras configuradas. Presiona el bot√≥n + para agregar una nueva o descubrir impresoras en la red.',
      icon: 'printer-outline',
    },
    errorConfig: {
      title: 'Error al cargar impresoras',
      message: 'No se pudieron cargar las impresoras. Verifica tu conexi√≥n.',
      icon: 'alert-circle-outline',
      onRetry: refetchList,
    },
  });

  // --- Funcionalidad de Ping ---
  const handlePingPrinter = useCallback(
    async (printerId: string) => {
      setPingingPrinterId(printerId);
      try {
        await pingPrinterMutation.mutateAsync(printerId);
      } catch (error) {
        // El error ya se maneja en el hook con un snackbar
      } finally {
        setPingingPrinterId(null);
      }
    },
    [pingPrinterMutation],
  );

  // Funci√≥n para renderizar cuando no hay datos
  const renderEmptyList = () => {
    if (isLoadingList) {
      return (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
        </View>
      );
    }

    return ListEmptyComponent;
  };

  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      {/* Eliminar la View de headerButtons */}

      <FlatList
        data={filteredData}
        renderItem={renderPrinter}
        keyExtractor={(item) => item.id}
        onRefresh={refetchList}
        refreshing={isFetchingList && !isLoadingList}
        ListEmptyComponent={renderEmptyList()}
        contentContainerStyle={[
          styles.listPadding,
          filteredData.length === 0 && styles.emptyListContainer,
        ]}
      />

      <Portal>
        {/* Modal de Descubrimiento */}
        <PrinterDiscoveryModal
          visible={isDiscoveryModalVisible}
          onDismiss={handleDismissDiscoveryModal}
          onPrinterSelect={handlePrinterSelectedFromDiscovery}
        />
        {/* Modal de Formulario */}
        <PrinterFormModal
          visible={isFormModalVisible}
          onDismiss={handleCloseModals}
          editingItem={editingItem}
          // Pasar datos descubiertos al crear, usar undefined en lugar de null
          initialDataFromDiscovery={
            !editingItem ? (discoveredPrinterData ?? undefined) : undefined
          }
        />
        {/* Modal de Detalle Personalizado */}
        <PrinterDetailModal
          visible={isDetailModalVisible}
          onDismiss={handleCloseModals}
          printer={selectedItem}
          onEdit={() => selectedItem && handleOpenEditModal(selectedItem)}
          deleteConfirmation={deleteConfirmation}
          onTestPrint={() => selectedItem && handleTestPrint(selectedItem.id)}
          isDeleting={isDeleting}
          isTestPrinting={testPrintingPrinterId === selectedItem?.id}
        />
        {/* A√±adir FAB.Group dentro del Portal */}
        <FAB.Group
          open={fabOpen}
          visible={
            !isFormModalVisible &&
            !isDetailModalVisible &&
            !isDiscoveryModalVisible &&
            !isDrawerOpen
          } // Ocultar si hay modales abiertos o drawer
          icon={fabOpen ? 'close' : 'plus'}
          actions={[
            {
              icon: 'magnify-scan',
              label: 'Descubrir en Red',
              onPress: handleOpenDiscoveryModal,
              style: { backgroundColor: theme.colors.tertiaryContainer }, // Color diferente
              color: theme.colors.onTertiaryContainer,
              labelTextColor: theme.colors.onTertiaryContainer,
              size: 'small',
            },
            {
              icon: 'plus',
              label: 'A√±adir Manual',
              onPress: handleOpenAddModal,
              style: { backgroundColor: theme.colors.secondaryContainer }, // Color diferente
              color: theme.colors.onSecondaryContainer,
              labelTextColor: theme.colors.onSecondaryContainer,
              size: 'small',
            },
          ]}
          onStateChange={({ open }) => setFabOpen(open)}
          onPress={() => {
            if (fabOpen) {
              // Acci√≥n opcional al cerrar el FAB principal
            }
          }}
          fabStyle={{ backgroundColor: theme.colors.primary }} // Color principal para el FAB
          color={theme.colors.onPrimary} // Color del icono principal
        />
      </Portal>
    </SafeAreaView>
  );
};

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    // Eliminar estilos de headerButtons
    listPadding: {
      paddingBottom: 80, // Espacio para que el FAB no tape el √∫ltimo item
      paddingTop: responsive.spacing(theme.spacing.s),
    },
    emptyListContainer: {
      flex: 1,
      minHeight: responsive.isTablet ? 350 : 400,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.spacing(theme.spacing.xl),
    },
    itemActionsContainer: {
      // Contenedor para los botones de acci√≥n de cada item
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'flex-end',
    },
    actionButton: {
      // Estilo base para botones de acci√≥n en la lista
      margin: 0,
      padding: 0,
      width: responsive.isTablet ? 44 : 52, // M√°s peque√±o en tablet
      height: responsive.isTablet ? 44 : 52, // M√°s peque√±o en tablet
      borderRadius: responsive.isTablet ? 22 : 26, // Redondeado perfecto
      backgroundColor: theme.colors.surfaceVariant, // Fondo para hacerlo m√°s atractivo
      elevation: 2, // Sombra sutil para darle profundidad
    },
    pingIndicator: {
      // Estilo para el indicador de carga del ping
      width: responsive.isTablet ? 44 : 52, // Mismo ancho que el bot√≥n
      height: responsive.isTablet ? 44 : 52, // Mismo alto
      justifyContent: 'center',
      alignItems: 'center',
      borderRadius: responsive.isTablet ? 22 : 26, // Redondeado perfecto
      backgroundColor: theme.colors.primaryContainer, // Fondo de color primario
      elevation: 2, // Sombra sutil
    },
    errorText: {
      color: theme.colors.error,
      textAlign: 'center',
      fontSize: responsive.fontSize(14),
    },
  });

export default PrintersScreen;

================
File: app/src/modules/receipts/services/receiptService.ts
================
import apiClient from '@/app/services/apiClient';
import type { QueryOptions } from '@tanstack/react-query';
import { API_PATHS } from '@/app/constants/apiPaths';
import { ApiError } from '@/app/lib/errors';
import type {
  Receipt,
  ReceiptsListResponse,
  ReceiptFilters,
} from '../types/receipt.types';
import type { Order } from '@/modules/orders/types/orders.types';

export const receiptService = {
  getReceiptsList: async (
    params: ReceiptFilters = {},
  ): Promise<ReceiptsListResponse> => {
    const { startDate, endDate, orderType } = params;

    const queryParams: Record<string, any> = {};

    if (startDate) {
      queryParams.startDate = startDate;
    }
    if (endDate) {
      queryParams.endDate = endDate;
    }
    if (orderType) {
      queryParams.orderType = orderType;
    }

    const response = await apiClient.get<ReceiptsListResponse>(
      API_PATHS.ORDERS_RECEIPTS_LIST,
      queryParams,
    );

    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status);
    }

    return response.data;
  },

  getReceiptById: async (id: string): Promise<Receipt> => {
    const response = await apiClient.get<Receipt>(
      API_PATHS.ORDERS_RECEIPTS_BY_ID.replace(':id', id),
    );

    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status);
    }

    return response.data;
  },

  recoverOrder: async (id: string): Promise<Order> => {
    const response = await apiClient.post<Order>(
      API_PATHS.ORDERS_RECOVER.replace(':id', id),
      {},
    );

    if (!response.ok || !response.data) {
      throw ApiError.fromApiResponse(response.data, response.status);
    }

    return response.data;
  },
};

export const receiptQueryOptions = {
  receipts: (
    params: ReceiptFilters = {},
  ): QueryOptions<ReceiptsListResponse, Error> => ({
    queryKey: ['receipts', params],
    queryFn: () => receiptService.getReceiptsList(params),
    refetchOnWindowFocus: true,
    refetchOnMount: true,
  }),

  receipt: (id: string): QueryOptions<Receipt, Error> => ({
    queryKey: ['receipt', id],
    queryFn: () => receiptService.getReceiptById(id),
  }),
};

================
File: app/src/services/autoReconnectService.ts
================
import EventEmitter from 'eventemitter3';
import { healthMonitoringService } from './healthMonitoringService';
import { discoveryService } from '@/app/services/discoveryService';
import NetInfo from '@react-native-community/netinfo';
import { NETWORK_CONFIG } from '@/app/constants/network';

export type ReconnectStatus =
  | 'idle'
  | 'checking-network'
  | 'checking-health'
  | 'running-discovery'
  | 'connected'
  | 'no-wifi'
  | 'failed';

export interface ReconnectState {
  status: ReconnectStatus;
  isReconnecting: boolean;
  attempts: number;
  lastError: string | null;
  logs: string[];
}

class AutoReconnectService extends EventEmitter {
  private state: ReconnectState = {
    status: 'idle',
    isReconnecting: false,
    attempts: 0,
    lastError: null,
    logs: [],
  };

  private reconnectTimer: NodeJS.Timeout | null = null;
  private isRunning = false;
  private readonly MAX_LOGS = 50;

  constructor() {
    super();
  }

  // Obtener estado actual
  getState(): ReconnectState {
    return { ...this.state };
  }

  // Agregar log con timestamp
  private addLog(message: string, type: 'info' | 'error' | 'success' = 'info') {
    const timestamp = new Date().toLocaleTimeString();
    const logEntry = `[${timestamp}] ${type.toUpperCase()}: ${message}`;

    // Crear nueva array para asegurar actualizaci√≥n
    const newLogs = [logEntry, ...this.state.logs].slice(0, this.MAX_LOGS);
    this.state.logs = newLogs;

    // Emitir cambio completo del estado
    this.emit('stateChange', { ...this.state, logs: [...newLogs] });
  }

  // Actualizar estado y notificar
  private updateState(updates: Partial<ReconnectState>) {
    this.state = { ...this.state, ...updates };
    this.emit('stateChange', this.state);
  }

  // Iniciar proceso de reconexi√≥n autom√°tica
  async startAutoReconnect() {
    if (this.isRunning) {
      return;
    }

    this.isRunning = true;
    this.updateState({
      isReconnecting: true,
      attempts: 0,
      logs: [], // Limpiar logs anteriores
      lastError: null,
      status: 'idle', // Resetear estado
    });

    this.addLog('Iniciando proceso de reconexi√≥n autom√°tica', 'info');

    // Peque√±o delay para asegurar que el estado se propague
    await this.delay(100);

    await this.reconnectCycle();
  }

  // Detener reconexi√≥n
  stopAutoReconnect() {
    if (!this.isRunning) return;

    this.addLog('Deteniendo proceso de reconexi√≥n', 'info');
    this.isRunning = false;

    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }

    this.updateState({
      isReconnecting: false,
      status: 'idle',
    });
  }

  // Ciclo principal de reconexi√≥n
  private async reconnectCycle() {
    while (this.isRunning) {
      this.updateState({ attempts: this.state.attempts + 1 });
      this.addLog(`CICLO DE RECONEXI√ìN #${this.state.attempts}`, 'info');

      const hasNetwork = await this.checkNetwork();
      if (!hasNetwork) {
        this.addLog('‚ùå Sin conexi√≥n WiFi. Esperando...', 'error');
        this.updateState({
          status: 'no-wifi',
          lastError: 'No hay conexi√≥n WiFi activa',
        });

        // Esperar antes de reintentar
        await this.delay(NETWORK_CONFIG.RECONNECT_CYCLE_DELAY);
        continue;
      }
      this.addLog('‚úÖ WiFi conectado', 'success');

      this.addLog('Verificando servidor con health checks...', 'info');
      const healthOk = await this.tryHealthChecks();

      if (healthOk) {
        this.addLog('üéâ ¬°SERVIDOR CONECTADO!', 'success');
        this.updateState({
          status: 'connected',
          isReconnecting: false,
          lastError: null,
        });
        this.isRunning = false;

        // Asegurar que el servicio de conexi√≥n actualice su estado
        // Peque√±o delay para asegurar que el estado se propague correctamente
        setTimeout(() => {
          this.emit('reconnected');
        }, 100);

        break;
      }

      this.addLog(
        'Health checks fallaron. Buscando servidor en red...',
        'info',
      );
      const discoveryOk = await this.tryDiscovery();

      if (discoveryOk) {
        // Verificar con health check despu√©s del discovery
        this.addLog('üìç Servidor encontrado. Verificando...', 'info');
        const postDiscoveryHealth = await this.tryHealthChecks(1); // Solo 1 intento

        if (postDiscoveryHealth) {
          this.addLog('üéâ ¬°RECONEXI√ìN EXITOSA!', 'success');
          this.updateState({
            status: 'connected',
            isReconnecting: false,
            lastError: null,
          });
          this.isRunning = false;

          // Asegurar que el servicio de conexi√≥n actualice su estado
          // Peque√±o delay para asegurar que el estado se propague correctamente
          setTimeout(() => {
            this.emit('reconnected');
          }, 100);

          break;
        } else {
          this.addLog('‚ùå Servidor encontrado pero no responde', 'error');
        }
      }

      this.addLog(
        `‚ùå Ciclo fallido. Esperando ${NETWORK_CONFIG.RECONNECT_CYCLE_DELAY / 1000}s...`,
        'error',
      );
      this.updateState({
        status: 'failed',
        lastError: 'No se pudo establecer conexi√≥n con el servidor',
      });

      await this.delay(NETWORK_CONFIG.RECONNECT_CYCLE_DELAY);
    }
  }

  // Verificar estado de red
  private async checkNetwork(): Promise<boolean> {
    this.updateState({ status: 'checking-network' });

    try {
      const netInfo = await NetInfo.fetch();
      const hasWifi =
        !!netInfo.isConnected &&
        (netInfo.type === 'wifi' || netInfo.type === 'ethernet');

      return hasWifi;
    } catch (error) {
      this.addLog('Error al verificar estado de red', 'error');
      return false;
    }
  }

  // Intentar health checks m√∫ltiples veces
  private async tryHealthChecks(
    maxAttempts = NETWORK_CONFIG.HEALTH_CHECK_ATTEMPTS,
  ): Promise<boolean> {
    this.updateState({ status: 'checking-health' });

    for (let i = 1; i <= maxAttempts; i++) {
      this.addLog(`  ‚Üí Health check ${i}/${maxAttempts}...`, 'info');

      try {
        const isHealthy = await healthMonitoringService.forceCheck();

        if (isHealthy) {
          this.addLog('  ‚úì Health check exitoso', 'success');
          return true;
        } else {
          this.addLog('  ‚úó Health check fall√≥', 'error');
        }
      } catch (error: any) {
        this.addLog('  ‚úó Health check fall√≥', 'error');
      }

      // Esperar antes del siguiente intento (excepto el √∫ltimo)
      if (i < maxAttempts) {
        this.addLog(`  ‚è≥ Esperando 2s...`, 'info');
        await this.delay(2000);
      }
    }

    this.addLog('  ‚ùå Todos los health checks fallaron', 'error');
    return false;
  }

  // Intentar discovery
  private async tryDiscovery(): Promise<boolean> {
    this.updateState({ status: 'running-discovery' });

    discoveryService.setLogCallback((message: string) => {
      this.addLog(`  ${message}`, 'info');
    });

    try {
      this.addLog('  ‚Üí Iniciando escaneo de red...', 'info');
      this.addLog('  ‚Üí Buscando servidor en puerto 3737...', 'info');
      const url = await discoveryService.forceRediscovery();

      if (url) {
        this.addLog(`  ‚úì ¬°Servidor encontrado!`, 'success');
        this.addLog(`  üìç URL: ${url}`, 'success');
        return true;
      } else {
        this.addLog('  ‚úó No se encontr√≥ servidor en la red', 'error');
        return false;
      }
    } catch (error: any) {
      this.addLog(
        `  ‚úó Error: ${error.message || 'Error al buscar servidor'}`,
        'error',
      );
      return false;
    } finally {
      discoveryService.setLogCallback(null);
    }
  }

  // Utilidad para delay
  private delay(ms: number): Promise<void> {
    return new Promise((resolve) => {
      this.reconnectTimer = setTimeout(resolve, ms);
    });
  }

  // Suscribirse a cambios
  subscribe(callback: (state: ReconnectState) => void): () => void {
    this.on('stateChange', callback);

    // Llamar inmediatamente con el estado actual
    callback(this.state);

    // Retornar funci√≥n para desuscribirse
    return () => {
      this.off('stateChange', callback);
    };
  }
}

// Singleton
export const autoReconnectService = new AutoReconnectService();

================
File: app/src/app/components/ConnectionErrorModal.tsx
================
import React, { useEffect, useState, useRef } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  Dimensions,
  Platform,
} from 'react-native';
import {
  Text,
  Modal,
  Portal,
  Surface,
  Icon,
  IconButton,
  useTheme,
  ProgressBar,
  Button,
} from 'react-native-paper';
import { ServerConfigModal } from './ServerConfigModal';
import {
  autoReconnectService,
  ReconnectState,
} from '@/services/autoReconnectService';
import { useServerConnection } from '../hooks/useServerConnection';
import { useAuthStore } from '../store/authStore';
import { serverConnectionService } from '@/services/serverConnectionService';

const { width: screenWidth, height: screenHeight } = Dimensions.get('window');

export function ConnectionErrorModal() {
  const theme = useTheme();
  const { isConnected } = useServerConnection();
  const isLoggedIn = useAuthStore((state) => !!state.user);
  const [visible, setVisible] = useState(false);
  const [reconnectState, setReconnectState] = useState<ReconnectState>(
    autoReconnectService.getState(),
  );
  const [isPaused, setIsPaused] = useState(false);
  const [pausedLogs, setPausedLogs] = useState<string[]>([]);
  const scrollViewRef = useRef<ScrollView>(null);
  const [showConfigModal, setShowConfigModal] = useState(false);

  useEffect(() => {
    // En web, mostrar directamente el modal de configuraci√≥n
    if (Platform.OS === 'web' && !isConnected && !isLoggedIn) {
      setVisible(true);
      return;
    }

    const unsubscribe = autoReconnectService.subscribe((state) => {
      setReconnectState(state);

      if (!isLoggedIn && state.isReconnecting) {
        setVisible(true);
      }

      if (state.status === 'connected') {
        setVisible(false);
      }
    });

    return () => {
      unsubscribe();
    };
  }, [isLoggedIn, isConnected]);

  useEffect(() => {
    if (Platform.OS === 'web' && isConnected && visible) {
      setVisible(false);
      setShowConfigModal(false);
    }
  }, [isConnected, visible]);

  useEffect(() => {
    if (isPaused && pausedLogs.length === 0) {
      setPausedLogs([...reconnectState.logs]);
    } else if (!isPaused) {
      setPausedLogs([]);
    }
  }, [isPaused, reconnectState.logs]);

  useEffect(() => {
    if (Platform.OS === 'web') {
      return;
    }

    if (!isConnected && !autoReconnectService.getState().isReconnecting) {
      setTimeout(() => {
        if (!isConnected) {
          autoReconnectService.startAutoReconnect();
        }
      }, 500);
    }
  }, [isConnected]);

  const getStatusInfo = () => {
    switch (reconnectState.status) {
      case 'checking-network':
        return {
          icon: 'wifi',
          title: 'Verificando red...',
          color: theme.colors.primary,
        };
      case 'checking-health':
        return {
          icon: 'server-network',
          title: 'Verificando servidor...',
          color: theme.colors.primary,
        };
      case 'running-discovery':
        return {
          icon: 'magnify-scan',
          title: 'Buscando servidor en la red...',
          color: theme.colors.tertiary,
        };
      case 'no-wifi':
        return {
          icon: 'wifi-off',
          title: 'Sin conexi√≥n WiFi',
          color: theme.colors.error,
        };
      case 'failed':
        return {
          icon: 'server-off',
          title: 'No se puede conectar',
          color: theme.colors.error,
        };
      case 'connected':
        return {
          icon: 'check-circle',
          title: '¬°Conexi√≥n establecida!',
          color: theme.colors.primary,
        };
      default:
        return {
          icon: 'alert-circle',
          title: 'Conectando...',
          color: theme.colors.tertiary,
        };
    }
  };

  const statusInfo = getStatusInfo();

  const styles = StyleSheet.create({
    modal: {
      justifyContent: 'center',
      alignItems: 'center',
      margin: 20,
    },
    container: {
      width: screenWidth - 40,
      minHeight: 400,
      maxHeight: screenHeight * 0.85,
      backgroundColor: theme.colors.surface,
      borderRadius: 24,
      overflow: 'hidden',
      elevation: 8,
    },
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: 20,
      paddingVertical: 16,
      backgroundColor: theme.colors.elevation.level2,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    headerTitle: {
      fontSize: 18,
      fontWeight: '600',
      color: theme.colors.onSurface,
      flex: 1,
      marginLeft: 12,
    },
    statusSection: {
      paddingTop: 12,
      paddingBottom: 8,
      paddingHorizontal: 16,
      alignItems: 'center',
    },
    title: {
      fontSize: 18,
      fontWeight: '600',
      color: theme.colors.onSurface,
      textAlign: 'center',
      marginBottom: 6,
    },
    subtitle: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
    },
    attemptBadge: {
      backgroundColor: theme.colors.primaryContainer,
      paddingHorizontal: 12,
      paddingVertical: 6,
      borderRadius: 16,
      marginTop: 8,
    },
    attemptText: {
      fontSize: 13,
      fontWeight: '500',
      color: theme.colors.onPrimaryContainer,
    },
    logsContainer: {
      backgroundColor: theme.colors.surfaceVariant,
      marginHorizontal: 16,
      marginBottom: 16,
      borderRadius: 16,
      overflow: 'hidden',
      minHeight: 200,
      maxHeight: 350,
    },
    logsHeader: {
      backgroundColor: theme.colors.elevation.level1,
      paddingHorizontal: 16,
      paddingVertical: 12,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    logsTitle: {
      fontSize: 12,
      fontWeight: '600',
      color: theme.colors.onSurfaceVariant,
      letterSpacing: 1,
      textTransform: 'uppercase',
    },
    logsList: {
      padding: 16,
    },
    logEntry: {
      fontSize: 13,
      lineHeight: 20,
      color: theme.colors.onSurface,
      marginBottom: 6,
      fontFamily: 'monospace',
    },
    logInfo: {
      color: theme.colors.onSurface,
    },
    logError: {
      color: theme.colors.error,
      fontWeight: '600',
    },
    logSuccess: {
      color: theme.colors.primary,
      fontWeight: '600',
    },
    progressContainer: {
      paddingHorizontal: 24,
      paddingBottom: 12,
    },
    actionContainer: {
      paddingHorizontal: 16,
      paddingBottom: 16,
      paddingTop: 8,
    },
    actionButton: {
      marginTop: 8,
    },
  });

  if (!visible) return null;

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={() => {
          if (
            Platform.OS === 'web' ||
            reconnectState.status === 'connected' ||
            reconnectState.status === 'no-wifi'
          ) {
            setVisible(false);
          }
        }}
        contentContainerStyle={styles.modal}
        dismissable={
          Platform.OS === 'web' ||
          reconnectState.status === 'connected' ||
          reconnectState.status === 'no-wifi'
        }
      >
        <Surface style={styles.container}>
          <View style={styles.header}>
            <Icon source="wifi-sync" size={24} color={theme.colors.primary} />
            <Text style={styles.headerTitle}>Estado de Conexi√≥n</Text>
            {(Platform.OS === 'web' ||
              reconnectState.status === 'connected' ||
              reconnectState.status === 'no-wifi') && (
              <IconButton
                icon="close"
                size={24}
                onPress={() => setVisible(false)}
                iconColor={theme.colors.onSurfaceVariant}
              />
            )}
          </View>

          <View style={styles.statusSection}>
            {Platform.OS === 'web' ? (
              <>
                <Icon
                  source="server-network"
                  size={64}
                  color={theme.colors.tertiary}
                  style={{ marginBottom: 16 }}
                />
                <Text style={styles.title}>Configuraci√≥n Requerida</Text>
                <Text style={styles.subtitle}>
                  En la versi√≥n web, debes configurar manualmente la URL del
                  servidor
                </Text>
              </>
            ) : (
              <>
                <Text style={styles.title}>{statusInfo.title}</Text>
                {reconnectState.lastError &&
                  reconnectState.status !== 'connected' && (
                    <Text style={styles.subtitle}>
                      {reconnectState.lastError}
                    </Text>
                  )}
              </>
            )}

            {reconnectState.attempts > 0 &&
              reconnectState.status !== 'connected' &&
              Platform.OS !== 'web' && (
                <View style={styles.attemptBadge}>
                  <Text style={styles.attemptText}>
                    Intento #{reconnectState.attempts}
                  </Text>
                </View>
              )}
          </View>

          {reconnectState.isReconnecting &&
            reconnectState.status !== 'connected' &&
            Platform.OS !== 'web' && (
              <View style={styles.progressContainer}>
                <ProgressBar
                  indeterminate
                  color={statusInfo.color}
                  style={{ height: 4, borderRadius: 2 }}
                />
              </View>
            )}

          {reconnectState.logs.length > 0 && Platform.OS !== 'web' && (
            <View style={styles.logsContainer}>
              <View style={styles.logsHeader}>
                <View
                  style={{
                    flexDirection: 'row',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                  }}
                >
                  <Text style={styles.logsTitle}>
                    DETALLES DEL PROCESO {isPaused ? '(PAUSADO)' : ''}
                  </Text>
                  <IconButton
                    icon={isPaused ? 'play' : 'pause'}
                    size={32}
                    onPress={() => setIsPaused(!isPaused)}
                    iconColor={theme.colors.primary}
                    style={{ margin: -4 }}
                  />
                </View>
              </View>
              <ScrollView
                ref={scrollViewRef}
                style={styles.logsList}
                showsVerticalScrollIndicator={true}
                nestedScrollEnabled={true}
              >
                {(isPaused ? pausedLogs : reconnectState.logs).map(
                  (log, index) => {
                    let logStyle = [styles.logEntry, styles.logInfo];

                    if (
                      log.includes('ERROR:') ||
                      log.includes('‚ùå') ||
                      log.includes('‚úó')
                    ) {
                      logStyle = [styles.logEntry, styles.logError];
                    } else if (
                      log.includes('SUCCESS:') ||
                      log.includes('‚úÖ') ||
                      log.includes('‚úì') ||
                      log.includes('üéâ')
                    ) {
                      logStyle = [styles.logEntry, styles.logSuccess];
                    }

                    return (
                      <Text key={index} style={logStyle}>
                        {log}
                      </Text>
                    );
                  },
                )}
                <View style={{ height: 10 }} />
              </ScrollView>
            </View>
          )}

          {Platform.OS === 'web' ||
          reconnectState.status === 'failed' ||
          reconnectState.status === 'no-wifi' ||
          (reconnectState.attempts > 2 &&
            reconnectState.status !== 'connected') ? (
            <View style={styles.actionContainer}>
              <Button
                mode="contained"
                onPress={() => {
                  setShowConfigModal(true);
                }}
                icon="server-network"
                style={styles.actionButton}
              >
                Configurar Servidor Manualmente
              </Button>
            </View>
          ) : null}
        </Surface>
      </Modal>

      <ServerConfigModal
        visible={showConfigModal}
        onDismiss={() => setShowConfigModal(false)}
        onSuccess={() => {
          setShowConfigModal(false);
          if (Platform.OS === 'web') {
            setVisible(false);
          } else {
            setTimeout(() => {
              autoReconnectService.startAutoReconnect();
            }, 1000);
          }
        }}
      />
    </Portal>
  );
}

================
File: app/src/app/constants/apiPaths.ts
================
export const API_PATHS = {
  SUBCATEGORIES: '/api/v1/subcategories',
  SUBCATEGORIES_BY_ID: '/api/v1/subcategories/:id',
  PRODUCTS: '/api/v1/products',
  PRODUCTS_BY_ID: '/api/v1/products/:id',
  PRODUCTS_MODIFIER_GROUPS: '/api/v1/products/:productId/modifier-groups',
  PRODUCTS_PIZZA_CUSTOMIZATIONS:
    '/api/v1/products/:productId/pizza-customizations',
  PRODUCTS_PIZZAS_CUSTOMIZATIONS_BULK:
    '/api/v1/products/pizzas/customizations/bulk',
  CATEGORIES: '/api/v1/categories',
  CATEGORIES_BY_ID: '/api/v1/categories/:id',
  CATEGORIES_ORDER_MENU: '/api/v1/categories/order-menu',
  FILES_UPLOAD: '/api/v1/files/upload',

  PREPARATION_SCREENS: '/api/v1/preparation-screens',
  PREPARATION_SCREENS_BY_ID: '/api/v1/preparation-screens/:id',
  PREPARATION_SCREENS_PRODUCTS: '/api/v1/preparation-screens/:id/products',
  PREPARATION_SCREENS_MENU_WITH_ASSOCIATIONS:
    '/api/v1/preparation-screens/:id/menu-with-associations',

  AUTH_EMAIL_LOGIN: '/api/v1/auth/email/login',
  AUTH_EMAIL_REGISTER: '/api/v1/auth/email/register',
  AUTH_ME: '/api/v1/auth/me',
  AUTH_REFRESH: '/api/v1/auth/refresh',

  AREAS: '/api/v1/areas',
  AREAS_BY_ID: '/api/v1/areas/:id',
  TABLES: '/api/v1/tables',
  TABLES_BY_ID: '/api/v1/tables/:id',
  TABLES_BY_AREA: '/api/v1/tables/area/:areaId',

  MODIFIERS: '/api/v1/product-modifiers',
  MODIFIERS_BY_ID: '/api/v1/product-modifiers/:id',
  MODIFIERS_BY_GROUP: '/api/v1/product-modifiers/by-group/:modifierGroupId',
  MODIFIER_GROUPS: '/api/v1/modifier-groups',
  MODIFIER_GROUPS_BY_ID: '/api/v1/modifier-groups/:id',

  ORDERS: '/api/v1/orders',
  ORDERS_BY_ID: '/api/v1/orders/:orderId',
  ORDERS_OPEN_CURRENT_SHIFT: '/api/v1/orders/open-current-shift',
  ORDERS_OPEN_ORDERS_LIST: '/api/v1/orders/open-orders-list',
  ORDERS_FOR_FINALIZATION_LIST: '/api/v1/orders/for-finalization/list',
  ORDERS_FOR_FINALIZATION_DETAIL: '/api/v1/orders/for-finalization/:id',
  ORDERS_FINALIZE_MULTIPLE: '/api/v1/orders/finalize-multiple',
  ORDERS_DETAIL: '/api/v1/orders/:orderId/detail',
  ORDERS_RECEIPTS_LIST: '/api/v1/orders/receipts-list',
  ORDERS_RECEIPTS_BY_ID: '/api/v1/orders/receipts/:id',
  ORDERS_RECOVER: '/api/v1/orders/:id/recover',
  PRINT_ORDER_TICKET: '/api/v1/print/order',

  THERMAL_PRINTERS: '/api/v1/thermal-printers',
  THERMAL_PRINTERS_BY_ID: '/api/v1/thermal-printers/:id',
  THERMAL_PRINTERS_DISCOVER: '/api/v1/thermal-printers/discover',
  THERMAL_PRINTERS_PING: '/api/v1/thermal-printers/:id/ping',
  THERMAL_PRINTERS_TEST_PRINT: '/api/v1/thermal-printers/test-print',

  ADJUSTMENTS: '/api/v1/adjustments',
  ADJUSTMENTS_BY_ID: '/api/v1/adjustments/:id',

  RESTAURANT_CONFIG: '/api/v1/restaurant-config',

  AVAILABILITY_MENU: '/api/v1/availability/menu',
  AVAILABILITY_MODIFIER_GROUPS: '/api/v1/availability/modifier-groups',
  AVAILABILITY_PIZZA_CUSTOMIZATIONS:
    '/api/v1/availability/pizza-customizations',
  AVAILABILITY_UPDATE: '/api/v1/availability/update',
  AVAILABILITY_BULK_UPDATE: '/api/v1/availability/bulk-update',

  PAYMENTS: '/api/v1/payments',
  PAYMENTS_BY_ID: '/api/v1/payments/:paymentId',
  PAYMENTS_BY_ORDER: '/api/v1/payments/order/:orderId',
  PAYMENTS_PREPAYMENT: '/api/v1/payments/prepayment',
  PAYMENTS_ASSOCIATE: '/api/v1/payments/:paymentId/associate/:orderId',

  PIZZA_CUSTOMIZATIONS: '/api/v1/pizza-customizations',
  PIZZA_CUSTOMIZATIONS_BY_ID: '/api/v1/pizza-customizations/:id',
  PIZZA_CUSTOMIZATIONS_SORT_ORDER: '/api/v1/pizza-customizations/sort-order',
  PIZZA_CONFIGURATIONS: '/api/v1/pizza-configurations',
  PIZZA_CONFIGURATIONS_BY_ID: '/api/v1/pizza-configurations/:id',
  PRODUCTS_PIZZAS: '/api/v1/products/pizzas/all',

  CUSTOMERS: '/api/v1/customers',
  CUSTOMERS_BY_ID: '/api/v1/customers/:id',
  CUSTOMERS_CHAT_MESSAGE: '/api/v1/customers/:customerId/chat-message',
  CUSTOMERS_CHAT_HISTORY: '/api/v1/customers/:customerId/relevant-chat-history',
  CUSTOMERS_STATS: '/api/v1/customers/:customerId/stats',
  CUSTOMERS_ACTIVE_RECENT: '/api/v1/customers/active/recent',
  ADDRESSES: '/api/v1/addresses',
  ADDRESSES_BY_ID: '/api/v1/addresses/:id',
  ADDRESSES_BY_CUSTOMER: '/api/v1/customers/:customerId/addresses',

  KITCHEN_ORDERS: '/api/v1/kitchen/orders',
  KITCHEN_ORDERS_START_PREPARATION:
    '/api/v1/kitchen/orders/:orderId/start-preparation',
  KITCHEN_ORDERS_CANCEL_PREPARATION:
    '/api/v1/kitchen/orders/:orderId/cancel-preparation',
  KITCHEN_ORDERS_COMPLETE_PREPARATION:
    '/api/v1/kitchen/orders/:orderId/complete-preparation',
  KITCHEN_MARK_PREPARED: '/api/v1/kitchen/order-items/:itemId/prepare',
  KITCHEN_MARK_UNPREPARED: '/api/v1/kitchen/order-items/:itemId/unprepare',
  KITCHEN_MY_SCREEN: '/api/v1/kitchen/my-screen',

  SHIFTS: '/api/v1/shifts',
  SHIFTS_OPEN: '/api/v1/shifts/open',
  SHIFTS_CLOSE: '/api/v1/shifts/close',
  SHIFTS_CURRENT: '/api/v1/shifts/current',
  SHIFTS_HISTORY: '/api/v1/shifts/history',
  SHIFTS_DETAIL: '/api/v1/shifts/:id',
  ORDERS_BY_SHIFT: '/api/v1/orders/shift/:shiftId',
  ORDERS_BY_SHIFT_SALES_SUMMARY: '/api/v1/orders/shift/:shiftId/sales-summary',

  USERS: '/api/v1/users',
  USERS_BY_ID: '/api/v1/users/:id',

  APP_CONFIG: '/api/v1/app-config',

  SYNC_STATUS: '/api/v1/sync-local/status',
  SYNC_ACTIVITY: '/api/v1/sync-local/activity',

  ORDERS_HISTORY: '/api/v1/orders/:orderId/history',
  ORDERS_QUICK_FINALIZE_MULTIPLE: '/api/v1/orders/quick-finalize-multiple',
  ORDERS_PRINT_TICKET: '/api/v1/orders/:orderId/print-ticket',

  FILES_CHECK: '/api/v1/files/',

  AUDIO_ORDERS_PROCESS: '/api/v1/audio-orders/process',
  AUDIO_ORDERS_HEALTH: '/api/v1/audio-orders/health',

  HEALTH: '/api/v1/health',
  DISCOVERY: '/api/v1/discovery',
} as const;

================
File: app/src/modules/areasTables/screens/AreasScreen.tsx
================
import React, { useMemo, useCallback } from 'react';
import { StyleSheet } from 'react-native';
import { IconButton } from 'react-native-paper';
import { useDrawerStatus } from '@react-navigation/drawer';
import { SafeAreaView } from 'react-native-safe-area-context';
import GenericList, {
  RenderItemConfig,
  FilterOption,
} from '../../../app/components/crud/GenericList';
import GenericDetailModal, {
  DisplayFieldConfig,
} from '../../../app/components/crud/GenericDetailModal';
import AreaFormModal from '../components/AreaFormModal';
import {
  useGetAreas,
  useCreateArea,
  useUpdateArea,
  useDeleteArea,
} from '../hooks/useAreasQueries';
import { Area, CreateAreaDto, UpdateAreaDto } from '../schema/area.schema';
import { AreasListScreenProps } from '../navigation/types';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { useResponsive } from '../../../app/hooks/useResponsive';
import { useCrudScreenLogic } from '../../../app/hooks/useCrudScreenLogic';
import { useListState } from '../../../app/hooks/useListState';
import { useRefreshModuleOnFocus } from '../../../app/hooks/useRefreshOnFocus';
import { NAVIGATION_PATHS } from '@/app/constants/navigationPaths';

const AreasScreen: React.FC<AreasListScreenProps> = ({ navigation }) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => getStyles(theme, responsive),
    [theme, responsive],
  );
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';

  const [searchQuery, setSearchQuery] = React.useState('');
  const [filterStatus, setFilterStatus] = React.useState<string>('all');

  const {
    data: areasData = [],
    isLoading: isLoadingAreas,
    isError: isErrorAreas,
    refetch: refetchAreas,
    isRefetching,
  } = useGetAreas(
    {
      name: searchQuery || undefined,
      isActive: filterStatus === 'all' ? undefined : filterStatus === 'true',
    },
    { page: 1, limit: 100 },
  );

  const createAreaMutation = useCreateArea();
  const updateAreaMutation = useUpdateArea();
  const { mutateAsync: deleteArea } = useDeleteArea();

  // Refrescar √°reas cuando la pantalla recibe foco
  useRefreshModuleOnFocus('areas');

  const {
    isFormModalVisible,
    isDetailModalVisible,
    editingItem,
    selectedItem,
    isDeleting,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
    deleteConfirmation,
  } = useCrudScreenLogic<Area>({
    entityName: '√Årea',
    queryKey: [
      'areas',
      {
        name: searchQuery || undefined,
        isActive: filterStatus === 'all' ? undefined : filterStatus === 'true',
      },
    ],
    deleteMutationFn: deleteArea,
  });

  const isSubmitting =
    createAreaMutation.isPending || updateAreaMutation.isPending;

  const handleFormSubmit = async (data: CreateAreaDto | UpdateAreaDto) => {
    try {
      if (editingItem) {
        await updateAreaMutation.mutateAsync({
          id: editingItem.id,
          data: data as UpdateAreaDto,
        });
      } else {
        await createAreaMutation.mutateAsync(data as CreateAreaDto);
      }
      handleCloseModals();
    } catch (error) {}
  };

  const handleNavigateToTables = (area: Area) => {
    navigation.navigate(NAVIGATION_PATHS.TABLES_LIST, {
      areaId: area.id,
      areaName: area.name,
    });
  };

  const listRenderConfig: RenderItemConfig<Area> = {
    titleField: 'name',
    descriptionField: 'description',
    statusConfig: {
      field: 'isActive',
      activeValue: true,
      activeLabel: 'Activa',
      inactiveLabel: 'Inactiva',
    },
  };

  const areaDetailFields: DisplayFieldConfig<Area>[] = [
    { field: 'description', label: 'Descripci√≥n' },
  ];
  const areaDetailStatusConfig = listRenderConfig.statusConfig;

  const filterOptions: FilterOption<string>[] = useMemo(
    () => [
      { label: 'Todas', value: 'all' },
      { label: 'Activas', value: 'true' },
      { label: 'Inactivas', value: 'false' },
    ],
    [],
  );

  const handleFilterChange = (value: string | number) => {
    setFilterStatus(String(value));
  };

  const handleSearchChange = (query: string) => {
    setSearchQuery(query);
  };

  const handleRefresh = useCallback(() => {
    setSearchQuery('');
    setFilterStatus('all');
    refetchAreas();
  }, [refetchAreas]);

  const renderItemActions = (item: Area) => (
    <IconButton
      icon="format-list-bulleted"
      size={responsive.isTablet ? 24 : 28}
      onPress={() => handleNavigateToTables(item)}
      iconColor={theme.colors.primary}
    />
  );

  const { ListEmptyComponent } = useListState({
    isLoading: isLoadingAreas,
    isError: isErrorAreas,
    data: areasData,
    emptyConfig: {
      title: 'No hay √°reas',
      message:
        'No hay √°reas registradas. Presiona el bot√≥n + para crear la primera.',
      icon: 'map-marker-outline',
    },
    errorConfig: {
      title: 'Error al cargar √°reas',
      message: 'No se pudieron cargar las √°reas. Verifica tu conexi√≥n.',
      icon: 'alert-circle-outline',
      onRetry: refetchAreas,
    },
  });

  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      <GenericList<Area>
        items={areasData}
        renderConfig={listRenderConfig}
        onItemPress={handleOpenDetailModal}
        onRefresh={handleRefresh}
        isRefreshing={isRefetching}
        ListEmptyComponent={ListEmptyComponent}
        enableSearch={true}
        searchQuery={searchQuery}
        onSearchChange={handleSearchChange}
        filterOptions={filterOptions}
        filterValue={filterStatus}
        onFilterChange={handleFilterChange}
        showFab={true}
        onFabPress={handleOpenCreateModal}
        renderItemActions={renderItemActions}
        isModalOpen={isFormModalVisible || isDetailModalVisible}
        isDrawerOpen={isDrawerOpen}
        showImagePlaceholder={false}
      />

      <AreaFormModal
        visible={isFormModalVisible}
        onDismiss={handleCloseModals}
        onSubmit={handleFormSubmit}
        editingItem={editingItem}
        isSubmitting={isSubmitting}
      />

      <GenericDetailModal<Area>
        visible={isDetailModalVisible}
        onDismiss={handleCloseModals}
        item={selectedItem}
        titleField="name"
        statusConfig={areaDetailStatusConfig}
        fieldsToDisplay={areaDetailFields}
        onEdit={() => {
          if (selectedItem) {
            handleOpenEditModal(selectedItem);
          }
        }}
        deleteConfirmation={deleteConfirmation}
        isDeleting={isDeleting}
        showImage={false}
      />
    </SafeAreaView>
  );
};

const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    centered: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.spacing(theme.spacing.l),
    },
  });

export default AreasScreen;

================
File: app/src/modules/areasTables/screens/TablesScreen.tsx
================
import React, { useMemo, useCallback } from 'react';
import { StyleSheet } from 'react-native';
import { Text } from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useDrawerStatus } from '@react-navigation/drawer';
import GenericList, {
  RenderItemConfig,
  FilterOption,
} from '../../../app/components/crud/GenericList';
import GenericDetailModal, {
  DisplayFieldConfig,
} from '../../../app/components/crud/GenericDetailModal';
import TableFormModal from '../components/TableFormModal';
import {
  useGetTablesByAreaId,
  useCreateTable,
  useUpdateTable,
  useDeleteTable,
} from '../hooks/useTablesQueries';
import { Table, CreateTableDto, UpdateTableDto } from '../schema/table.schema';
import { TablesListScreenProps } from '../navigation/types';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { useResponsive } from '../../../app/hooks/useResponsive';
import { useCrudScreenLogic } from '../../../app/hooks/useCrudScreenLogic';
import { useListState } from '../../../app/hooks/useListState';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';

const TablesScreen: React.FC<TablesListScreenProps> = ({ route }) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => getStyles(theme, responsive),
    [theme, responsive],
  );
  const { areaId, areaName } = route.params;
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';

  const [searchQuery, setSearchQuery] = React.useState('');
  const [filterStatus, setFilterStatus] = React.useState<string>('all');

  const {
    data: tablesData = [],
    isLoading: isLoadingTables,
    isError: isErrorTables,
    refetch: refetchTables,
    isRefetching,
  } = useGetTablesByAreaId(areaId, { enabled: !!areaId });

  // Recargar autom√°ticamente cuando la pantalla recibe foco
  useRefreshModuleOnFocus('tables');

  const createTableMutation = useCreateTable();
  const updateTableMutation = useUpdateTable();
  const { mutateAsync: deleteTable } = useDeleteTable();

  const {
    isFormModalVisible,
    isDetailModalVisible,
    editingItem,
    selectedItem,
    isDeleting,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
    deleteConfirmation,
  } = useCrudScreenLogic<Table>({
    entityName: 'Mesa',
    queryKey: ['tables', areaId],
    deleteMutationFn: deleteTable,
  });

  const isSubmitting =
    createTableMutation.isPending || updateTableMutation.isPending;

  const handleFormSubmit = async (data: CreateTableDto | UpdateTableDto) => {
    try {
      const dataWithAreaId = { ...data, areaId: areaId };

      if (editingItem) {
        await updateTableMutation.mutateAsync({
          id: editingItem.id,
          data: dataWithAreaId as UpdateTableDto,
        });
      } else {
        await createTableMutation.mutateAsync(dataWithAreaId as CreateTableDto);
      }
      handleCloseModals();
    } catch (error) {}
  };

  const listRenderConfig: RenderItemConfig<Table> = useMemo(
    () => ({
      titleField: 'name',
      descriptionField: 'capacity',
      descriptionFormatter: (capacity) =>
        capacity
          ? `Capacidad: ${capacity} ${capacity === 1 ? 'persona' : 'personas'}`
          : undefined,
      descriptionMaxLength: 30,
      statusConfig: {
        field: 'isActive',
        activeValue: true,
        activeLabel: 'Activa',
        inactiveLabel: 'Inactiva',
      },
    }),
    [],
  );

  const tableDetailFields: DisplayFieldConfig<Table>[] = useMemo(
    () => [
      {
        field: 'capacity',
        label: 'Capacidad',
        render: (value) => (
          <Text style={styles.fieldValueText}>
            {value !== null && value !== undefined
              ? String(value)
              : 'No especificada'}
          </Text>
        ),
      },
    ],
    [styles.fieldValueText],
  );

  const tableDetailStatusConfig = listRenderConfig.statusConfig;

  const filterOptions: FilterOption<string>[] = useMemo(
    () => [
      { label: 'Todas', value: 'all' },
      { label: 'Activas', value: 'true' },
      { label: 'Inactivas', value: 'false' },
    ],
    [],
  );

  const handleFilterChange = (value: string | number) => {
    setFilterStatus(String(value));
  };

  const handleSearchChange = (query: string) => {
    setSearchQuery(query);
  };

  const handleRefresh = useCallback(() => {
    setSearchQuery('');
    setFilterStatus('all');
    refetchTables();
  }, [refetchTables]);

  const filteredAndSearchedTables = useMemo(() => {
    let processed = [...tablesData];

    const isActiveFilter =
      filterStatus === 'all' ? undefined : filterStatus === 'true';
    if (isActiveFilter !== undefined) {
      processed = processed.filter(
        (table) => table.isActive === isActiveFilter,
      );
    }

    if (searchQuery.trim()) {
      const lowerCaseQuery = searchQuery.toLowerCase();
      processed = processed.filter((table) =>
        table.name.toLowerCase().includes(lowerCaseQuery),
      );
    }

    return processed;
  }, [tablesData, filterStatus, searchQuery]);

  const { ListEmptyComponent } = useListState({
    isLoading: isLoadingTables,
    isError: isErrorTables,
    data: filteredAndSearchedTables,
    emptyConfig: {
      title: 'No hay mesas',
      message: `No hay mesas registradas en ${areaName}. Presiona el bot√≥n + para crear la primera.`,
      icon: 'table-furniture',
    },
    errorConfig: {
      title: 'Error al cargar mesas',
      message: 'No se pudieron cargar las mesas. Verifica tu conexi√≥n.',
      icon: 'alert-circle-outline',
      onRetry: refetchTables,
    },
  });

  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      <GenericList<Table>
        items={filteredAndSearchedTables}
        renderConfig={listRenderConfig}
        onItemPress={handleOpenDetailModal}
        onRefresh={handleRefresh}
        isRefreshing={isRefetching}
        ListEmptyComponent={ListEmptyComponent}
        enableSearch={true}
        searchQuery={searchQuery}
        onSearchChange={handleSearchChange}
        filterOptions={filterOptions}
        filterValue={filterStatus}
        onFilterChange={handleFilterChange}
        showFab={true}
        onFabPress={handleOpenCreateModal}
        isModalOpen={isFormModalVisible || isDetailModalVisible}
        showImagePlaceholder={false}
        isDrawerOpen={isDrawerOpen}
      />

      <TableFormModal
        visible={isFormModalVisible}
        onDismiss={handleCloseModals}
        onSubmit={handleFormSubmit}
        editingItem={editingItem}
        isSubmitting={isSubmitting}
      />

      <GenericDetailModal<Table>
        visible={isDetailModalVisible}
        onDismiss={handleCloseModals}
        item={selectedItem}
        titleField="name"
        statusConfig={tableDetailStatusConfig}
        fieldsToDisplay={tableDetailFields}
        onEdit={() => {
          if (selectedItem) {
            handleOpenEditModal(selectedItem);
          }
        }}
        deleteConfirmation={deleteConfirmation}
        isDeleting={isDeleting}
        showImage={false}
      />
    </SafeAreaView>
  );
};

const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    centered: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.spacing(theme.spacing.l),
    },
    fieldValueText: {
      flexShrink: 1,
      textAlign: 'right',
      color: theme.colors.onSurface,
      fontSize: responsive.fontSize(14),
    },
  });

export default TablesScreen;

================
File: app/src/modules/menu/screens/CategoriesScreen.tsx
================
import React, { useState, useMemo, useCallback, useEffect } from 'react';
import { StyleSheet } from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { useDrawerStatus } from '@react-navigation/drawer';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Portal, IconButton } from 'react-native-paper';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
import { useAppTheme } from '../../../app/styles/theme';
import { useSnackbarStore } from '../../../app/store/snackbarStore';
import { getApiErrorMessage } from '../../../app/lib/errorMapping';
import { useListState } from '../../../app/hooks/useListState';
import GenericList from '../../../app/components/crud/GenericList';
import { FilterOption } from '../../../app/components/crud/GenericList';
import GenericDetailModal from '../../../app/components/crud/GenericDetailModal';
import GenericFormModal, {
  FormFieldConfig,
  ImagePickerConfig,
} from '../../../app/components/crud/GenericFormModal';
import {
  ImageUploadService,
  FileObject,
} from '../../../app/lib/imageUploadService';
import categoryService from '../services/categoryService';
import {
  Category,
  CategoryFormData,
  CreateCategoryDto,
  UpdateCategoryDto,
  categoryFormSchema,
} from '../schema/category.schema';
import { useRefreshModuleOnFocus } from '../../../app/hooks/useRefreshOnFocus';

type RootStackParamList = {
  Categories: undefined;
  SubcategoriesScreen: { categoryId: string; categoryName?: string };
};
type CategoriesScreenNavigationProp = NativeStackNavigationProp<
  RootStackParamList,
  'Categories'
>;

const CategoriesScreen: React.FC = () => {
  const theme = useAppTheme();
  const queryClient = useQueryClient();
  const navigation = useNavigation<CategoriesScreenNavigationProp>();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';

  const [modalVisible, setModalVisible] = useState(false);
  const [detailModalVisible, setDetailModalVisible] = useState(false);
  const [editingCategory, setEditingCategory] = useState<Category | null>(null);
  const [selectedCategory, setSelectedCategory] = useState<Category | null>(
    null,
  );
  const [activeFilter, setActiveFilter] = useState<string | number>('all');
  const [isUploadingImage, setIsUploadingImage] = useState(false);
  const [showDeleteConfirmation, setShowDeleteConfirmation] = useState(false);
  const [categoryToDelete, setCategoryToDelete] = useState<string | null>(null);

  const {
    data: categoriesResponse,
    isLoading: isLoadingCategories,
    isError: isErrorCategories,
    refetch: refetchCategories,
    isFetching: isFetchingCategories,
  } = useQuery({
    queryKey: ['categories', { filter: activeFilter }],
    queryFn: () =>
      categoryService.getCategories({
        isActive:
          activeFilter === 'all' ? undefined : activeFilter === 'active',
      }),
  });

  // Refrescar categor√≠as cuando la pantalla recibe foco

  useRefreshModuleOnFocus('categories');

  const { ListEmptyComponent } = useListState({
    isLoading: isLoadingCategories,
    isError: isErrorCategories,
    data: categoriesResponse?.data,
    emptyConfig: {
      title: 'No hay categor√≠as',
      message:
        activeFilter !== 'all'
          ? `No hay categor√≠as ${activeFilter === 'active' ? 'activas' : 'inactivas'} registradas.`
          : 'No hay categor√≠as registradas. Presiona el bot√≥n + para crear la primera.',
      icon: 'folder-outline',
    },
    errorConfig: {
      title: 'Error al cargar categor√≠as',
      message: 'No se pudieron cargar las categor√≠as. Verifica tu conexi√≥n.',
      icon: 'alert-circle-outline',
      onRetry: refetchCategories,
    },
  });

  const commonMutationOptions = {
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['categories'] });
      closeModals();
    },
    onError: (error: unknown) => {
      const message = getApiErrorMessage(error);
      showSnackbar({ message, type: 'error' });
      setIsUploadingImage(false);
    },
  };

  const createCategoryMutation = useMutation({
    mutationFn: (data: CreateCategoryDto) =>
      categoryService.createCategory(data),
    ...commonMutationOptions,
    onSuccess: () => {
      commonMutationOptions.onSuccess();
      showSnackbar({
        message: 'Categor√≠a creada exitosamente',
        type: 'success',
      });
    },
  });

  const updateCategoryMutation = useMutation({
    mutationFn: ({ id, data }: { id: string; data: UpdateCategoryDto }) =>
      categoryService.updateCategory(id, data),
    ...commonMutationOptions,
    onSuccess: () => {
      commonMutationOptions.onSuccess();
      showSnackbar({
        message: 'Categor√≠a actualizada exitosamente',
        type: 'success',
      });
    },
  });

  const deleteCategoryMutation = useMutation({
    mutationFn: (id: string) => categoryService.deleteCategory(id),
    ...commonMutationOptions,
    onSuccess: () => {
      commonMutationOptions.onSuccess();
      showSnackbar({ message: 'Categor√≠a eliminada', type: 'success' });
    },
  });
  const openAddModal = useCallback(() => {
    setEditingCategory(null);
    setModalVisible(true);
  }, []);

  const openEditModal = useCallback((category: Category) => {
    setEditingCategory(category);
    setDetailModalVisible(false);
    setModalVisible(true);
  }, []);

  const openDetailModal = useCallback((category: Category) => {
    setSelectedCategory(category);
    setDetailModalVisible(true);
  }, []);

  const closeModals = useCallback(() => {
    setModalVisible(false);
    setDetailModalVisible(false);
    setEditingCategory(null);
    setSelectedCategory(null);
    setIsUploadingImage(false);
  }, []);

  const handleFilterChange = (value: string | number) => {
    setActiveFilter(value);
  };

  const handleFormSubmit = async (
    formData: CategoryFormData,
    photoId: string | null | undefined,
  ) => {
    const { imageUri, ...dataToSubmit } = formData;
    const finalData: any = {
      ...dataToSubmit,
    };

    // Solo incluir photoId si tiene un valor definido (string o null)
    if (photoId !== undefined) {
      finalData.photoId = photoId;
    }

    if (editingCategory) {
      updateCategoryMutation.mutate({
        id: editingCategory.id,
        data: finalData as UpdateCategoryDto,
      });
    } else {
      createCategoryMutation.mutate(finalData as CreateCategoryDto);
    }
  };

  const handleDelete = (id: string) => {
    setCategoryToDelete(id);
    setShowDeleteConfirmation(true);
  };

  const handleConfirmDelete = () => {
    if (categoryToDelete) {
      deleteCategoryMutation.mutate(categoryToDelete);
      setShowDeleteConfirmation(false);
      setCategoryToDelete(null);
    }
  };

  const categories = useMemo(() => {
    return categoriesResponse?.data ?? [];
  }, [categoriesResponse?.data]);

  const styles = useMemo(
    () =>
      StyleSheet.create({
        container: { flex: 1, backgroundColor: theme.colors.background },
      }),
    [theme],
  );

  const [formInitialValues, setFormInitialValues] = useState<CategoryFormData>({
    name: '',
    description: null,
    isActive: true,
    sortOrder: 0,
    imageUri: null,
  });

  useEffect(() => {
    const loadFormData = async () => {
      if (editingCategory) {
        let imageUrl = null;
        if (editingCategory.photo?.path) {
          try {
            const { getImageUrl } = await import('@/app/lib/imageUtils');
            imageUrl = await getImageUrl(editingCategory.photo.path);
          } catch (error) {
            imageUrl = editingCategory.photo.path;
          }
        }

        setFormInitialValues({
          name: editingCategory.name,
          description: editingCategory.description ?? null,
          isActive: editingCategory.isActive,
          sortOrder: editingCategory.sortOrder ?? 0,
          imageUri: imageUrl,
        });
      } else {
        setFormInitialValues({
          name: '',
          description: null,
          isActive: true,
          sortOrder: 0,
          imageUri: null,
        });
      }
    };

    loadFormData();
  }, [editingCategory]);

  const selectedCategoryMapped = useMemo(() => {
    if (!selectedCategory) return null;
    return selectedCategory;
  }, [selectedCategory]);

  const filterOptions: FilterOption<string | number>[] = [
    { value: 'all', label: 'Todas' },
    { value: 'active', label: 'Activas' },
    { value: 'inactive', label: 'Inactivas' },
  ];

  const listRenderConfig = {
    titleField: 'name' as keyof Category,
    descriptionField: 'description' as keyof Category,
    descriptionMaxLength: 60,
    imageField: 'photo' as keyof Category,
    sortOrderField: 'sortOrder' as keyof Category,
    statusConfig: {
      field: 'isActive' as keyof Category,
      activeValue: true,
      activeLabel: 'Activa',
      inactiveLabel: 'Inactiva',
    },
  };

  const formFieldsConfig: FormFieldConfig<CategoryFormData>[] = [
    { name: 'name', label: 'Nombre', type: 'text', required: true },
    {
      name: 'description',
      label: 'Descripci√≥n',
      type: 'textarea',
      numberOfLines: 3,
    },
    {
      name: 'sortOrder',
      label: 'Orden de visualizaci√≥n',
      type: 'number',
      placeholder: '0',
    },
    {
      name: 'isActive',
      label: 'Estado',
      type: 'switch',
      switchLabel: 'Activa',
    },
  ];

  const imagePickerConfig: ImagePickerConfig<CategoryFormData> = {
    imageUriField: 'imageUri',
    onImageUpload: async (file: FileObject) => {
      setIsUploadingImage(true);
      try {
        const result = await ImageUploadService.uploadImage(file);
        if (result.success && result.photoId) {
          return { id: result.photoId };
        }
        throw new Error(result.error || 'Error desconocido al subir imagen');
      } finally {
        setIsUploadingImage(false);
      }
    },
    determineFinalPhotoId: ImageUploadService.determinePhotoId,
    imagePickerSize: 150,
    placeholderIcon: 'folder-outline',
    placeholderText: 'Imagen de categor√≠a',
  };

  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      <GenericList
        items={categories}
        enableSort={true}
        enableSearch={true}
        searchPlaceholder="Buscar categor√≠as..."
        filterValue={activeFilter}
        onFilterChange={handleFilterChange}
        filterOptions={filterOptions}
        renderItemActions={(item: Category) => (
          <IconButton
            icon="format-list-bulleted"
            size={28}
            onPress={() =>
              navigation.navigate('SubcategoriesScreen', {
                categoryId: item.id,
                categoryName: item.name,
              })
            }
            style={{ margin: 0 }}
          />
        )}
        renderConfig={listRenderConfig}
        onItemPress={openDetailModal}
        onRefresh={refetchCategories}
        isRefreshing={isFetchingCategories && !isLoadingCategories}
        ListEmptyComponent={ListEmptyComponent}
        showFab={true}
        onFabPress={openAddModal}
        isModalOpen={modalVisible || detailModalVisible}
        showImagePlaceholder={true}
        placeholderIcon="folder-outline"
        isDrawerOpen={isDrawerOpen} // Pasar estado del drawer
      />

      <Portal>
        <GenericFormModal
          visible={modalVisible}
          onDismiss={closeModals}
          onSubmit={handleFormSubmit}
          formSchema={categoryFormSchema}
          formFields={formFieldsConfig}
          imagePickerConfig={imagePickerConfig}
          initialValues={formInitialValues}
          editingItem={editingCategory}
          isSubmitting={
            createCategoryMutation.isPending ||
            updateCategoryMutation.isPending ||
            isUploadingImage
          }
          modalTitle={(isEditing) =>
            isEditing ? 'Editar Categor√≠a' : 'Nueva Categor√≠a'
          }
          submitButtonLabel={(isEditing) => (isEditing ? 'Guardar' : 'Crear')}
        />

        <GenericDetailModal
          visible={detailModalVisible}
          onDismiss={closeModals}
          item={selectedCategoryMapped}
          titleField="name"
          imageField="photo"
          descriptionField="description"
          statusConfig={listRenderConfig.statusConfig}
          fieldsToDisplay={[
            {
              field: 'sortOrder',
              label: 'Orden de visualizaci√≥n',
              render: (value) => value ?? '0',
            },
            {
              field: 'createdAt',
              label: 'Fecha de creaci√≥n',
              render: (value) => {
                if (!value) return 'N/A';
                const date = new Date(value as string);
                return date.toLocaleDateString('es-ES', {
                  year: 'numeric',
                  month: 'long',
                  day: 'numeric',
                  hour: '2-digit',
                  minute: '2-digit',
                });
              },
            },
            {
              field: 'updatedAt',
              label: '√öltima actualizaci√≥n',
              render: (value) => {
                if (!value) return 'N/A';
                const date = new Date(value as string);
                return date.toLocaleDateString('es-ES', {
                  year: 'numeric',
                  month: 'long',
                  day: 'numeric',
                  hour: '2-digit',
                  minute: '2-digit',
                });
              },
            },
          ]}
          onEdit={openEditModal as (item: any) => void}
          onDelete={handleDelete}
          isDeleting={deleteCategoryMutation.isPending}
          showImage={true}
        />

        <ConfirmationModal
          visible={showDeleteConfirmation}
          title="Confirmar Eliminaci√≥n"
          message="¬øEst√°s seguro de que quieres eliminar esta categor√≠a? Esta acci√≥n no se puede deshacer."
          confirmText="Eliminar"
          cancelText="Cancelar"
          confirmButtonColor={theme.colors.error}
          onConfirm={handleConfirmDelete}
          onCancel={() => {
            setShowDeleteConfirmation(false);
            setCategoryToDelete(null);
          }}
          onDismiss={() => {
            setShowDeleteConfirmation(false);
            setCategoryToDelete(null);
          }}
        />
      </Portal>
    </SafeAreaView>
  );
};

export default CategoriesScreen;

================
File: app/src/modules/orders/hooks/useOrdersQueries.ts
================
import { useMemo } from 'react';

import {
  useMutation,
  useQuery,
  useQueryClient,
  UseQueryResult,
} from '@tanstack/react-query';
import { orderService } from '../services/orderService';
import type { Order } from '../../../app/schemas/domain/order.schema';
import type { OrderDetailsForBackend } from '../components/OrderCartDetail';
import type { FindAllOrdersDto, OrderOpenList } from '../types/orders.types';
import { ApiError } from '@/app/lib/errors';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { getApiErrorMessage } from '@/app/lib/errorMapping';
import type { UpdateOrderPayload } from '../types/update-order.types';

// Query Keys
const orderKeys = {
  all: ['orders'] as const,
  lists: () => [...orderKeys.all, 'list'] as const,
  list: (filters: FindAllOrdersDto) => [...orderKeys.lists(), filters] as const,
  openOrdersList: () => [...orderKeys.all, 'list', 'open-orders-list'] as const,
  details: () => [...orderKeys.all, 'detail'] as const,
  detail: (id: string) => [...orderKeys.details(), id] as const,
};

/**
 * Hook para crear una nueva orden.
 */
export const useCreateOrderMutation = () => {
  const queryClient = useQueryClient();

  return useMutation<Order, ApiError, OrderDetailsForBackend>({
    mutationFn: orderService.createOrder,
    onSuccess: () => {
      // Invalidar queries relevantes si es necesario (ej. lista de √≥rdenes)
      queryClient.invalidateQueries({ queryKey: orderKeys.lists() });
      // Invalidar queries de mesas para reflejar cambios de disponibilidad
      queryClient.invalidateQueries({ queryKey: ['tables'] });
      // El mensaje de √©xito se maneja en el componente que llama a la mutaci√≥n
    },
    onError: (_error) => {
      // El mensaje de error se maneja en el componente que llama a la mutaci√≥n
    },
  });
};

/**
 * Hook para actualizar una orden existente.
 */
export const useUpdateOrderMutation = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  // Definir el tipo de las variables de la mutaci√≥n
  type UpdateVariables = { orderId: string; payload: UpdateOrderPayload };

  return useMutation<Order, ApiError, UpdateVariables>({
    mutationFn: ({ orderId, payload }) =>
      orderService.updateOrder(orderId, payload),
    onSuccess: (updatedOrder, variables) => {
      // Invalidar queries relevantes para refrescar datos
      queryClient.invalidateQueries({ queryKey: orderKeys.lists() });
      queryClient.invalidateQueries({ queryKey: orderKeys.openOrdersList() });
      queryClient.invalidateQueries({
        queryKey: [...orderKeys.details(), variables.orderId],
      });

      // Invalidar queries de mesas para reflejar cambios de disponibilidad
      queryClient.invalidateQueries({ queryKey: ['tables'] });

      showSnackbar({
        message: `Orden #${updatedOrder.shiftOrderNumber} actualizada`,
        type: 'success',
      });
    },
    onError: (error, variables) => {
      const message = getApiErrorMessage(error);
      showSnackbar({
        message: `Error al actualizar orden #${variables.orderId}: ${message}`,
        type: 'error',
      });
    },
  });
};

/**
 * Hook para cancelar una orden.
 */
export const useCancelOrderMutation = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<Order, ApiError, string>({
    mutationFn: (orderId) => orderService.cancelOrder(orderId),
    onSuccess: (cancelledOrder, orderId) => {
      // Invalidar queries relevantes
      queryClient.invalidateQueries({ queryKey: orderKeys.lists() });
      queryClient.invalidateQueries({ queryKey: orderKeys.openOrdersList() });
      queryClient.invalidateQueries({
        queryKey: [...orderKeys.details(), orderId],
      });
      // Invalidar queries de mesas para reflejar cambios de disponibilidad
      queryClient.invalidateQueries({ queryKey: ['tables'] });

      showSnackbar({
        message: `Orden #${cancelledOrder.shiftOrderNumber} cancelada`,
        type: 'info',
      });
    },
    onError: (error) => {
      const message = getApiErrorMessage(error);
      showSnackbar({
        message: `Error al cancelar orden: ${message}`,
        type: 'error',
      });
    },
  });
};

/**
 * Hook para completar una orden (cambiar estado a COMPLETED).
 */
export const useCompleteOrderMutation = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<Order, ApiError, string>({
    mutationFn: (orderId) =>
      orderService.updateOrder(orderId, { orderStatus: 'COMPLETED' }),
    onSuccess: (completedOrder, orderId) => {
      // Invalidar queries relevantes
      queryClient.invalidateQueries({ queryKey: orderKeys.lists() });
      queryClient.invalidateQueries({ queryKey: orderKeys.openOrdersList() });
      queryClient.invalidateQueries({
        queryKey: [...orderKeys.details(), orderId],
      });

      showSnackbar({
        message: `Orden #${completedOrder.shiftOrderNumber} finalizada exitosamente`,
        type: 'success',
      });
    },
    onError: (error) => {
      const message = getApiErrorMessage(error);
      showSnackbar({
        message: `Error al finalizar orden: ${message}`,
        type: 'error',
      });
    },
  });
};

/**
 * Hook optimizado para obtener las √≥rdenes abiertas con campos m√≠nimos.
 */
export const useGetOpenOrdersListQuery = (options?: {
  enabled?: boolean;
}): UseQueryResult<OrderOpenList[], ApiError> => {
  const queryKey = orderKeys.openOrdersList();

  return useQuery<OrderOpenList[], ApiError>({
    queryKey: queryKey,
    queryFn: () => orderService.getOpenOrdersList(),
    enabled: options?.enabled ?? true,
    refetchInterval: 10000, // Actualizar cada 10 segundos
    refetchIntervalInBackground: false,
    refetchOnWindowFocus: true,
    refetchOnMount: true,
    staleTime: 5000,
    gcTime: 10 * 60 * 1000,
    placeholderData: (previousData) => previousData,
  });
};

/**
 * Hook para obtener los detalles completos de una orden por su ID.
 */
export const useGetOrderByIdQuery = (
  orderId: string | null | undefined,
  options?: { enabled?: boolean },
): UseQueryResult<Order, ApiError> => {
  // Definir la clave de detalle usando el orderId
  const detailQueryKey = useMemo(
    () =>
      orderId ? [...orderKeys.details(), orderId] : [...orderKeys.details()],
    [orderId],
  );

  return useQuery<Order, ApiError>({
    queryKey: detailQueryKey,
    queryFn: async () => {
      if (!orderId) {
        // Si no hay orderId, no intentar hacer fetch y devolver un error o estado inicial
        return Promise.reject(new Error('Order ID no proporcionado'));
      }
      const order = await orderService.getOrderById(orderId);
      return order;
    },
    enabled: !!orderId && (options?.enabled ?? true), // Habilitar solo si hay orderId y est√° habilitado externamente
    staleTime: 0, // Los datos del detalle de la orden siempre deben estar frescos
    gcTime: 0, // No mantener en cach√© - siempre refetchear cuando se necesite
    refetchOnMount: 'always', // Siempre refetchear cuando el componente se monta
    refetchOnWindowFocus: true, // Refetchear cuando la ventana recupera el foco
  });
};

================
File: app/src/services/shifts.ts
================
import apiClient from '@/app/services/apiClient';
import { handleApiResponse } from '@/app/lib/apiHelpers';
import { API_PATHS } from '@/app/constants/apiPaths';
import type { ShiftSummary, ShiftOrder } from '@/modules/shiftAudit/types';
import type { Order } from '@/app/schemas/domain/order.schema';

export interface ShiftStatus {
  OPEN: 'OPEN';
  CLOSED: 'CLOSED';
}

export interface Shift {
  id: string;
  date: string;
  globalShiftNumber: number;
  shiftNumber: number;
  status: keyof ShiftStatus;
  openedAt: string;
  closedAt: string | null;
  openedBy: {
    id: string;
    firstName: string;
    lastName: string;
  };
  closedBy: {
    id: string;
    firstName: string;
    lastName: string;
  } | null;
  initialCash: number;
  finalCash: number | null;
  totalSales: number | null;
  totalOrders: number | null;
  cashDifference: number | null;
  expectedCash?: number | null;
  notes: string | null;
  closeNotes: string | null;
}

export interface OpenShiftDto {
  initialCash: number;
  notes?: string;
  date?: string;
}

export interface CloseShiftDto {
  finalCash: number;
  closeNotes?: string;
}

class ShiftsService {
  /**
   * Obtener el turno actual
   */
  async getCurrentShift(): Promise<Shift | null> {
    try {
      const response = await apiClient.get(API_PATHS.SHIFTS_CURRENT);
      return response.data;
    } catch (error: any) {
      if (error.response?.status === 404) {
        return null;
      }
      throw error;
    }
  }

  /**
   * Abrir un nuevo turno
   */
  async openShift(data: OpenShiftDto): Promise<Shift> {
    const response = await apiClient.post(API_PATHS.SHIFTS_OPEN, data);

    if (!response.ok) {
      throw (
        response.data ||
        response.originalError ||
        new Error('Error al abrir el turno')
      );
    }

    return response.data;
  }

  /**
   * Cerrar el turno actual
   */
  async closeShift(data: CloseShiftDto): Promise<Shift> {
    const response = await apiClient.post(API_PATHS.SHIFTS_CLOSE, data);

    if (!response.ok) {
      throw (
        response.data ||
        response.originalError ||
        new Error('Error al cerrar el turno')
      );
    }

    return response.data;
  }

  /**
   * Obtener historial de turnos
   */
  async getHistory(params?: {
    startDate?: string;
    endDate?: string;
  }): Promise<Shift[]> {
    const queryParams = new URLSearchParams();

    if (params?.startDate) {
      queryParams.append('startDate', params.startDate);
    }
    if (params?.endDate) {
      queryParams.append('endDate', params.endDate);
    }

    const url = queryParams.toString()
      ? `${API_PATHS.SHIFTS_HISTORY}?${queryParams.toString()}`
      : API_PATHS.SHIFTS_HISTORY;

    const response = await apiClient.get(url);
    return response.data;
  }

  /**
   * Obtener un turno por ID
   */
  async getById(id: string): Promise<Shift> {
    const response = await apiClient.get(
      API_PATHS.SHIFTS_DETAIL.replace(':id', id),
    );
    return response.data;
  }

  /**
   * Verificar si hay un turno abierto
   */
  async isShiftOpen(): Promise<boolean> {
    const currentShift = await this.getCurrentShift();
    return currentShift !== null && currentShift.status === 'OPEN';
  }

  /**
   * Obtiene todas las √≥rdenes de un turno espec√≠fico
   */
  async getOrdersByShift(shiftId: string): Promise<Order[]> {
    const url = API_PATHS.ORDERS_BY_SHIFT.replace(':shiftId', shiftId);
    const response = await apiClient.get<any>(url);
    const data = handleApiResponse(response);

    // Asegurar que siempre devuelva un array
    return Array.isArray(data) ? data : data?.data || [];
  }

  /**
   * Calcula el resumen de un turno con estad√≠sticas
   */
  calculateShiftSummary(shift: Shift, orders: Order[]): ShiftSummary {
    // Normalizar el shift para que sea compatible con el tipo ShiftSummary
    const normalizedShift = {
      ...shift,
      status: shift.status === 'OPEN' ? ('open' as const) : ('closed' as const),
    };
    const paymentMethodsSummary = new Map<
      string,
      { count: number; total: number }
    >();
    const productsSummary = new Map<
      string,
      { quantity: number; total: number }
    >();

    if (!Array.isArray(orders)) {
      // Orders no es un array en calculateShiftSummary
      return {
        shift,
        ordersCount: 0,
        totalSales: 0,
        paymentMethodsSummary: [],
        productsSummary: [],
      };
    }

    orders.forEach((order) => {
      // Calcular el total de la orden
      const orderTotal =
        typeof order.total === 'number'
          ? order.total
          : typeof order.total === 'string'
            ? parseFloat(order.total)
            : 0;

      // Resumen por m√©todo de pago
      let paymentMethod = 'Sin pagar';
      if (order.payments && order.payments.length > 0) {
        paymentMethod = order.payments[0].paymentMethod || 'Efectivo';
      }

      const current = paymentMethodsSummary.get(paymentMethod) || {
        count: 0,
        total: 0,
      };
      paymentMethodsSummary.set(paymentMethod, {
        count: current.count + 1,
        total: current.total + orderTotal,
      });

      // Resumen por productos
      order.orderItems?.forEach((item: any) => {
        const productName =
          item.product?.name || item.productName || 'Producto';
        const itemTotal = item.total || item.quantity * item.unitPrice || 0;
        const current = productsSummary.get(productName) || {
          quantity: 0,
          total: 0,
        };
        productsSummary.set(productName, {
          quantity: current.quantity + (item.quantity || 1),
          total: current.total + itemTotal,
        });
      });
    });

    // Calcular el total de ventas correctamente
    const totalSales = orders.reduce((sum, order) => {
      const orderTotal =
        typeof order.total === 'number'
          ? order.total
          : typeof order.total === 'string'
            ? parseFloat(order.total)
            : 0;
      return sum + orderTotal;
    }, 0);

    return {
      shift: normalizedShift,
      ordersCount: orders.length,
      totalSales: totalSales,
      paymentMethodsSummary: Array.from(paymentMethodsSummary.entries()).map(
        ([method, data]) => ({
          method,
          count: data.count,
          total: data.total,
        }),
      ),
      productsSummary: Array.from(productsSummary.entries())
        .map(([productName, data]) => ({
          productName,
          quantity: data.quantity,
          total: data.total,
        }))
        .sort((a, b) => b.total - a.total)
        .slice(0, 10), // Top 10 productos
    };
  }

  /**
   * Formatea las √≥rdenes para mostrar en la vista de detalle
   */
  formatOrdersForDetail(orders: Order[]): ShiftOrder[] {
    if (!Array.isArray(orders)) {
      // Orders no es un array
      return [];
    }

    return orders.map((order) => {
      // Calcular el total si no est√° definido
      const total =
        typeof order.total === 'number'
          ? order.total
          : typeof order.total === 'string'
            ? parseFloat(order.total)
            : 0;

      // Determinar el m√©todo de pago
      let paymentMethod = 'Sin pagar';
      if (order.payments && order.payments.length > 0) {
        paymentMethod = order.payments[0].paymentMethod || 'Efectivo';
      }

      return {
        id: order.id,
        orderNumber:
          order.orderNumber || `#${order.shiftOrderNumber || order.id}`,
        total: total,
        status: order.orderStatus || 'COMPLETED',
        paymentMethod: paymentMethod,
        customerName: (order.deliveryInfo as any)?.customerName || null,
        createdAt:
          typeof order.createdAt === 'string'
            ? order.createdAt
            : order.createdAt.toISOString(),
        items:
          order.orderItems?.map((item: any) => ({
            id: item.id || String(Math.random()),
            productName: item.product?.name || item.productName || 'Producto',
            quantity: item.quantity || 1,
            unitPrice: item.unitPrice || 0,
            total: item.total || item.quantity * item.unitPrice || 0,
            modifiers:
              item.productModifiers?.map(
                (mod: any) => mod.modifierName || mod.name,
              ) || [],
          })) || [],
      };
    });
  }
}

export const shiftsService = new ShiftsService();

================
File: app/src/modules/auth/screens/LoginScreen.tsx
================
import React, { useState, useEffect } from 'react';
import {
  Image,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  StyleSheet,
  View,
  ActivityIndicator,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Text, IconButton, Surface, TouchableRipple } from 'react-native-paper';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import EncryptedStorage from '@/app/services/secureStorageService';
import { STORAGE_KEYS } from '../../../app/constants/storageKeys';
import { useAppTheme } from '../../../app/styles/theme';
import { useSnackbarStore } from '../../../app/store/snackbarStore';
import { getApiErrorMessage } from '../../../app/lib/errorMapping';
import { useThemeStore } from '../../../app/store/themeStore';
import { useAuthStore } from '../../../app/store/authStore';
import { LoginFormInputs, LoginResponseDto } from '../schema/auth.schema';
import { authService } from '../services/authService';
import LoginForm from '../components/LoginForm';
import { ConnectionIndicator } from '../../../app/components/ConnectionIndicator';
import { useResponsive } from '../../../app/hooks/useResponsive';
import { ConnectionErrorModal } from '../../../app/components/ConnectionErrorModal';
import { useServerConnection } from '../../../app/hooks/useServerConnection';
import { RegisterModal } from '../components/RegisterForm';
import { OrientationTransition } from '../../../app/components/OrientationTransition';
import * as ScreenOrientation from 'expo-screen-orientation';

const LoginScreen = () => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const queryClient = useQueryClient();
  const { showSnackbar } = useSnackbarStore();
  const { setThemePreference } = useThemeStore();
  const setTokens = useAuthStore((state) => state.setTokens);
  const { isConnected, serverUrl } = useServerConnection();

  const [initialEmailOrUsername, setInitialEmailOrUsername] = useState<
    string | undefined
  >(undefined);
  const [initialPassword, setInitialPassword] = useState<string | undefined>(
    undefined,
  );
  const [initialRememberMe, setInitialRememberMe] = useState(false);
  const [isLoadingCredentials, setIsLoadingCredentials] = useState(true);
  const [showRegisterModal, setShowRegisterModal] = useState(false);

  type LoginMutationVariables = LoginFormInputs & { rememberMe: boolean };

  const loginMutation = useMutation<
    LoginResponseDto,
    Error,
    LoginMutationVariables
  >({
    mutationFn: (variables) =>
      authService.login({
        emailOrUsername: variables.emailOrUsername,
        password: variables.password,
      }),
    onSuccess: async (data, variables) => {
      try {
        // Verificar si el usuario est√° activo antes de guardar los tokens
        if (data.user && !data.user.isActive) {
          showSnackbar({
            message: 'Tu cuenta est√° inactiva. Contacta al administrador.',
            type: 'error',
          });
          return;
        }

        await setTokens(data.token, data.refreshToken, data.user ?? null);
        const { emailOrUsername, password, rememberMe } = variables;

        if (rememberMe) {
          const credentialsToSave = JSON.stringify({
            emailOrUsername,
            password,
          });
          await EncryptedStorage.setItem(
            STORAGE_KEYS.REMEMBERED_CREDENTIALS,
            credentialsToSave,
          );
          await EncryptedStorage.setItem(
            STORAGE_KEYS.REMEMBER_ME_ENABLED,
            'true',
          );
        } else {
          await EncryptedStorage.removeItem(
            STORAGE_KEYS.REMEMBERED_CREDENTIALS,
          );
          await EncryptedStorage.removeItem(STORAGE_KEYS.REMEMBER_ME_ENABLED);
        }

        showSnackbar({
          message: `¬°Bienvenido!`,
          type: 'success',
        });
        queryClient.invalidateQueries({ queryKey: ['user', 'me'] });
      } catch (error: any) {
        if (error.message === 'Usuario inactivo') {
          showSnackbar({
            message: 'Tu cuenta est√° inactiva. Contacta al administrador.',
            type: 'error',
          });
        }

        try {
          await EncryptedStorage.removeItem(
            STORAGE_KEYS.REMEMBERED_CREDENTIALS,
          );
          await EncryptedStorage.removeItem(STORAGE_KEYS.REMEMBER_ME_ENABLED);
        } catch (cleanupError) {}

        showSnackbar({
          message: 'Error procesando el inicio de sesi√≥n.',
          type: 'error',
        });
      }
    },
    onError: (error: any) => {
      const errorMessage = getApiErrorMessage(error);

      if (
        errorMessage.includes('credenciales') ||
        errorMessage.includes('contrase√±a') ||
        errorMessage.includes('usuario') ||
        error.response?.status === 401
      ) {
        showSnackbar({
          message: errorMessage,
          type: 'error',
          duration: 5000,
        });
      }
    },
  });

  const handleLoginSubmit = (data: LoginFormInputs, rememberMe: boolean) => {
    loginMutation.mutate({ ...data, rememberMe });
  };

  useEffect(() => {
    const loadCredentials = async () => {
      setIsLoadingCredentials(true);
      try {
        const rememberEnabled = await EncryptedStorage.getItem(
          STORAGE_KEYS.REMEMBER_ME_ENABLED,
        );
        if (rememberEnabled === 'true') {
          const storedCredentialsJson = await EncryptedStorage.getItem(
            STORAGE_KEYS.REMEMBERED_CREDENTIALS,
          );
          if (storedCredentialsJson) {
            const storedCredentials = JSON.parse(storedCredentialsJson);
            setInitialEmailOrUsername(storedCredentials.emailOrUsername);
            setInitialPassword(storedCredentials.password);
            setInitialRememberMe(true);
          } else {
            setInitialRememberMe(false);
            setInitialEmailOrUsername('');
            setInitialPassword('');
            await EncryptedStorage.removeItem(STORAGE_KEYS.REMEMBER_ME_ENABLED);
          }
        } else {
          setInitialRememberMe(false);
          setInitialEmailOrUsername('');
          setInitialPassword('');
        }
      } catch (error) {
        setInitialRememberMe(false);
        setInitialEmailOrUsername('');
        setInitialPassword('');
        try {
          await EncryptedStorage.removeItem(
            STORAGE_KEYS.REMEMBERED_CREDENTIALS,
          );
          await EncryptedStorage.removeItem(STORAGE_KEYS.REMEMBER_ME_ENABLED);
        } catch (cleanupError) {}
      } finally {
        setIsLoadingCredentials(false);
      }
    };

    loadCredentials();
  }, []);

  const toggleTheme = () => {
    setThemePreference(theme.dark ? 'light' : 'dark');
  };

  const handleRegisterSuccess = (username: string, password: string) => {
    setInitialEmailOrUsername(username);
    setInitialPassword(password);
    setInitialRememberMe(false);
  };

  const isWeb = Platform.OS === 'web';
  const isDesktop = isWeb && responsive.dimensions.width >= 1024;
  const isTablet =
    isWeb &&
    responsive.dimensions.width >= 768 &&
    responsive.dimensions.width < 1024;

  const styles = React.useMemo(
    () =>
      StyleSheet.create({
        safeArea: {
          flex: 1,
          backgroundColor: theme.colors.background,
        },
        scrollView: {
          flexGrow: 1,
        },
        webContainer: {
          flex: 1,
          flexDirection: isDesktop ? 'row' : 'column',
          minHeight: '100vh',
          width: '100%',
        },
        webLeftPanel: {
          flex: isDesktop ? 1 : undefined,
          backgroundColor: theme.dark
            ? theme.colors.primaryContainer
            : theme.colors.primary,
          justifyContent: 'center',
          alignItems: 'center',
          padding: responsive.spacingPreset.xl,
          ...(isTablet && {
            paddingVertical: responsive.spacingPreset.xxl,
          }),
        },
        webRightPanel: {
          flex: isDesktop ? 1 : undefined,
          justifyContent: 'center',
          alignItems: 'center',
          padding: responsive.spacingPreset.xl,
          backgroundColor: theme.colors.background,
          minHeight: isDesktop ? '100vh' : undefined,
          width: '100%',
        },
        webBrandingContainer: {
          alignItems: 'center',
          marginBottom: responsive.spacingPreset.xl,
        },
        webBrandingLogo: {
          width: isDesktop ? 200 : 150,
          height: isDesktop ? 200 : 150,
          marginBottom: responsive.spacingPreset.l,
          borderRadius: isDesktop ? 100 : 75,
          backgroundColor: theme.colors.surface,
          overflow: 'hidden',
          borderWidth: theme.dark ? 2 : 0,
          borderColor: theme.dark ? theme.colors.outline : 'transparent',
        },
        webBrandingTitle: {
          fontSize: isDesktop ? 48 : 36,
          fontWeight: 'bold',
          color: theme.dark
            ? theme.colors.onPrimaryContainer
            : theme.colors.onPrimary,
          marginBottom: responsive.spacingPreset.m,
          textAlign: 'center',
        },
        webBrandingSubtitle: {
          fontSize: isDesktop ? 20 : 18,
          color: theme.dark
            ? theme.colors.onPrimaryContainer
            : theme.colors.onPrimary,
          opacity: theme.dark ? 0.8 : 0.9,
          textAlign: 'center',
          maxWidth: 400,
          lineHeight: 28,
        },
        webFormWrapper: {
          width: '100%',
          maxWidth: isDesktop ? 450 : 400,
          alignItems: 'center',
        },
        container: {
          flex: 1,
          padding: responsive.spacingPreset.l,
          justifyContent: 'space-between',
        },
        logoContainer: {
          alignItems: 'center',
          marginTop: responsive.spacingPreset.xl,
          marginBottom: responsive.spacingPreset.m,
        },
        logo: {
          width: 160,
          height: 160,
          marginBottom: 16,
          borderRadius: 80,
          backgroundColor: 'transparent',
          overflow: 'hidden',
        },
        title: {
          fontSize: 32,
          fontWeight: 'bold',
          color: theme.colors.primary,
          marginBottom: 8,
          textAlign: 'center',
        },
        subtitle: {
          fontSize: responsive.fontSizePreset.m,
          color: theme.colors.onSurfaceVariant,
          marginBottom: responsive.spacingPreset.xl,
          textAlign: 'center',
          paddingHorizontal: responsive.spacingPreset.l,
        },
        formContainer: {
          backgroundColor: theme.colors.surface,
          borderRadius: 16,
          padding: responsive.spacingPreset.m,
          elevation: 2,
          marginBottom: responsive.spacingPreset.m,
          paddingVertical: responsive.spacingPreset.l,
          ...(isWeb && {
            width: '100%',
            shadowColor: theme.dark
              ? 'rgba(255,255,255,0.1)'
              : 'rgba(0,0,0,0.1)',
            shadowOffset: { width: 0, height: 2 },
            shadowOpacity: 1,
            shadowRadius: 8,
            borderWidth: theme.dark ? 1 : 0,
            borderColor: theme.dark
              ? theme.colors.surfaceVariant
              : 'transparent',
          }),
        },
        registerContainer: {
          flexDirection: 'row',
          justifyContent: 'center',
          alignItems: 'center',
          marginTop: responsive.spacingPreset.xl,
        },
        registerText: {
          color: theme.colors.onSurfaceVariant,
          marginRight: 8,
        },
        registerLink: {
          color: theme.colors.primary,
          fontWeight: 'bold',
        },
        bottomThemeToggleContainer: {
          alignItems: 'center',
          marginTop: 20,
          marginBottom: 16,
        },
        webThemeToggle: {
          position: 'absolute',
          top: responsive.spacingPreset.l,
          right: responsive.spacingPreset.l,
          zIndex: 10,
        },
      }),
    [theme, isDesktop, isTablet],
  );

  if (isLoadingCredentials) {
    return (
      <SafeAreaView
        style={[
          styles.safeArea,
          { justifyContent: 'center', alignItems: 'center' },
        ]}
      >
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </SafeAreaView>
    );
  }

  const webContent = (
    <View
      style={{
        flex: 1,
        height: '100vh',
        backgroundColor: theme.colors.background,
      }}
    >
      <ConnectionErrorModal />
      <RegisterModal
        visible={showRegisterModal}
        onDismiss={() => setShowRegisterModal(false)}
        onRegisterSuccess={handleRegisterSuccess}
      />

      {/* Theme toggle button */}
      <View style={{ position: 'absolute', top: 20, right: 20, zIndex: 10 }}>
        <IconButton
          icon={theme.dark ? 'weather-night' : 'weather-sunny'}
          size={30}
          onPress={toggleTheme}
          iconColor={theme.colors.onSurfaceVariant}
        />
      </View>

      <ScrollView
        contentContainerStyle={{
          flexGrow: 1,
          justifyContent: 'center',
          alignItems: 'center',
          padding: 20,
        }}
      >
        <View
          style={{
            width: '100%',
            maxWidth: 380,
            alignItems: 'center',
          }}
        >
          {/* Logo */}
          <Image
            source={require('../../../../assets/icon.png')}
            style={{
              width: 200,
              height: 200,
              borderRadius: 100,
              marginBottom: 30,
            }}
            resizeMode="cover"
          />

          {/* Login form card */}
          <View
            style={{
              width: '100%',
              backgroundColor: theme.colors.surface,
              borderRadius: 16,
              padding: 24,
              shadowColor: theme.dark
                ? 'rgba(255,255,255,0.1)'
                : 'rgba(0,0,0,0.1)',
              shadowOffset: { width: 0, height: 4 },
              shadowOpacity: 1,
              shadowRadius: 12,
              elevation: 4,
              borderWidth: theme.dark ? 1 : 0,
              borderColor: theme.dark ? 'rgba(255,255,255,0.1)' : 'transparent',
            }}
          >
            <Text
              style={{
                fontSize: 24,
                fontWeight: 'bold',
                color: theme.colors.onSurface,
                marginBottom: 8,
                textAlign: 'center',
              }}
            >
              Iniciar Sesi√≥n
            </Text>
            <Text
              style={{
                fontSize: 14,
                color: theme.colors.onSurfaceVariant,
                marginBottom: 20,
                textAlign: 'center',
              }}
            >
              Ingresa tus credenciales para continuar
            </Text>

            <LoginForm
              onSubmit={handleLoginSubmit}
              isLoading={loginMutation.isPending}
              initialEmailOrUsername={initialEmailOrUsername}
              initialPassword={initialPassword}
              initialRememberMe={initialRememberMe}
            />

            <View
              style={{
                flexDirection: 'row',
                justifyContent: 'center',
                alignItems: 'center',
                marginTop: 16,
              }}
            >
              <Text
                style={{
                  color: theme.colors.onSurfaceVariant,
                  fontSize: 14,
                }}
              >
                ¬øNo tienes una cuenta?
              </Text>
              <TouchableRipple
                onPress={() => setShowRegisterModal(true)}
                style={{ marginLeft: 5 }}
              >
                <Text
                  style={{
                    color: theme.colors.primary,
                    fontWeight: 'bold',
                    fontSize: 14,
                  }}
                >
                  Reg√≠strate
                </Text>
              </TouchableRipple>
            </View>
          </View>
        </View>
      </ScrollView>
    </View>
  );

  const mobileContent = (
    <SafeAreaView style={styles.safeArea}>
      <ConnectionErrorModal />
      <RegisterModal
        visible={showRegisterModal}
        onDismiss={() => setShowRegisterModal(false)}
        onRegisterSuccess={handleRegisterSuccess}
      />
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={{ flex: 1 }}
      >
        <ScrollView
          contentContainerStyle={styles.scrollView}
          keyboardShouldPersistTaps="handled"
        >
          <View style={styles.container}>
            <View>
              <View
                style={{
                  position: 'absolute',
                  top: -responsive.spacing.s,
                  right: -responsive.spacing.s,
                  zIndex: 1,
                }}
              >
                <ConnectionIndicator />
              </View>
              <View style={styles.logoContainer}>
                <Image
                  source={require('../../../../assets/icon.png')}
                  style={styles.logo}
                  resizeMode="cover"
                />
                <Text style={styles.title}>¬°Bienvenido!</Text>
                <Text style={styles.subtitle}>
                  Inicia sesi√≥n para gestionar tus pedidos
                </Text>
              </View>

              <Surface style={styles.formContainer}>
                <LoginForm
                  onSubmit={handleLoginSubmit}
                  isLoading={loginMutation.isPending}
                  initialEmailOrUsername={initialEmailOrUsername}
                  initialPassword={initialPassword}
                  initialRememberMe={initialRememberMe}
                />
              </Surface>
            </View>

            <View>
              <View style={styles.registerContainer}>
                <Text style={styles.registerText}>¬øNo tienes una cuenta?</Text>
                <TouchableRipple onPress={() => setShowRegisterModal(true)}>
                  <Text style={styles.registerLink}>Reg√≠strate</Text>
                </TouchableRipple>
              </View>
              <View style={styles.bottomThemeToggleContainer}>
                <IconButton
                  icon={theme.dark ? 'weather-night' : 'weather-sunny'}
                  size={responsive.dimensions.iconSize.large}
                  onPress={toggleTheme}
                  iconColor={theme.colors.onSurfaceVariant}
                />
              </View>
            </View>
          </View>
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );

  const content = isWeb ? webContent : mobileContent;

  return Platform.OS === 'web' ? (
    content
  ) : (
    <OrientationTransition
      targetOrientation={ScreenOrientation.OrientationLock.PORTRAIT_UP}
    >
      {content}
    </OrientationTransition>
  );
};

export default LoginScreen;

================
File: app/src/modules/customers/components/AddressFormModal.tsx
================
import React, { useState, useEffect, useRef } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  TextInput,
  Button,
  Switch,
  HelperText,
  Surface,
  Chip,
  Avatar,
  IconButton,
  Icon,
  ActivityIndicator,
} from 'react-native-paper';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { Address, CreateAddressDto } from '../types/customer.types';
import { addressSchema, AddressFormInputs } from '../schema/customer.schema';
import { WebView } from 'react-native-webview';
import { GOOGLE_MAPS_CONFIG } from '../constants/maps.config';
import { useGoogleMapsConfig } from '@/hooks/useGoogleMapsConfig';
import { useSnackbarStore } from '@/app/store/snackbarStore';

interface AddressFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSubmit: (data: CreateAddressDto) => Promise<void>;
  editingItem: Address | null;
  isSubmitting: boolean;
  customerId: string;
}

export default function AddressFormModal({
  visible,
  onDismiss,
  onSubmit,
  editingItem,
  isSubmitting,
}: AddressFormModalProps) {
  const theme = useAppTheme();
  const styles = getStyles(theme);
  const showSnackbar = useSnackbarStore((state) => state.show);
  const { config: mapsConfig, loading: isLoadingApiKey } =
    useGoogleMapsConfig();
  const apiKey = mapsConfig?.apiKey;
  const [mapReady, setMapReady] = useState(false);
  const [isMapLoading, setIsMapLoading] = useState(true);
  const [isMapFullscreen, setIsMapFullscreen] = useState(false);
  const webViewRef = useRef<WebView>(null);
  const scrollViewRef = useRef<ScrollView>(null);

  const {
    control,
    handleSubmit,
    formState: { errors },
    reset,
    setValue,
    watch,
    trigger,
  } = useForm<AddressFormInputs>({
    resolver: zodResolver(addressSchema),
    defaultValues: {
      name: '',
      street: '',
      number: '',
      interiorNumber: '',
      neighborhood: '',
      city: '',
      state: '',
      zipCode: '',
      country: 'M√©xico',
      deliveryInstructions: '',
      isDefault: false,
    },
  });

  const latitude = watch('latitude');
  const longitude = watch('longitude');

  useEffect(() => {
    if (editingItem) {
      reset({
        name: editingItem.name,
        street: editingItem.street,
        number: editingItem.number,
        interiorNumber: editingItem.interiorNumber || '',
        neighborhood: editingItem.neighborhood,
        city: editingItem.city,
        state: editingItem.state,
        zipCode: editingItem.zipCode,
        country: editingItem.country || 'M√©xico',
        deliveryInstructions: editingItem.deliveryInstructions || '',
        // Convertir a n√∫mero si existe, undefined si no
        latitude: editingItem.latitude
          ? Number(editingItem.latitude)
          : undefined,
        longitude: editingItem.longitude
          ? Number(editingItem.longitude)
          : undefined,
        isDefault: editingItem.isDefault,
      });
    } else {
      reset({
        name: '',
        street: '',
        number: '',
        interiorNumber: '',
        neighborhood: '',
        city: '',
        state: '',
        zipCode: '',
        country: 'M√©xico',
        deliveryInstructions: '',
        isDefault: false,
      });
    }
  }, [editingItem, reset]);

  // HTML del mapa con Google Maps API - Memoizado para evitar recrearlo en cada render
  const mapHtml = React.useMemo(
    () =>
      apiKey
        ? `
<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes" />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      height: 100%;
      width: 100%;
      overflow: hidden;
      touch-action: manipulation;
    }
    #map {
      height: 100%;
      width: 100%;
      touch-action: manipulation;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <script>
    let map;
    let marker;
    let currentLocation = null;

    function initMap() {
      // Inicializar el mapa
      const initialLocation = ${
        latitude && longitude
          ? `{ lat: ${latitude}, lng: ${longitude} }`
          : 'null'
      };
      
      // Configurar centro del mapa
      const mapCenter = initialLocation || { lat: ${GOOGLE_MAPS_CONFIG.defaultCenter.lat}, lng: ${GOOGLE_MAPS_CONFIG.defaultCenter.lng} };
      
      map = new google.maps.Map(document.getElementById('map'), {
        center: mapCenter,
        zoom: initialLocation ? ${GOOGLE_MAPS_CONFIG.locationZoom} : ${GOOGLE_MAPS_CONFIG.defaultZoom},
        ...${JSON.stringify(GOOGLE_MAPS_CONFIG.mapOptions)},
        gestureHandling: ${isMapFullscreen ? "'greedy'" : "'cooperative'"}, // Greedy en pantalla completa, cooperative en el modal
      });

      // Solo crear marcador si hay ubicaci√≥n inicial
      if (initialLocation) {
        marker = new google.maps.Marker({
          position: initialLocation,
          map: map,
          draggable: true,
          animation: google.maps.Animation.DROP,
          title: "Ubicaci√≥n de la direcci√≥n"
        });
        
        currentLocation = initialLocation;
        
        // Actualizar ubicaci√≥n cuando se arrastra el marcador
        marker.addListener('dragend', function() {
          currentLocation = {
            lat: marker.getPosition().lat(),
            lng: marker.getPosition().lng()
          };
          sendMessage('locationUpdated', {
            latitude: currentLocation.lat,
            longitude: currentLocation.lng
          });
        });
      }

      // Actualizar ubicaci√≥n al hacer click en el mapa
      map.addListener('click', function(event) {
        if (!marker) {
          // Crear marcador si no existe
          marker = new google.maps.Marker({
            position: event.latLng,
            map: map,
            draggable: true,
            animation: google.maps.Animation.DROP,
            title: "Ubicaci√≥n de la direcci√≥n"
          });
          
          // Agregar listener para arrastrar
          marker.addListener('dragend', function() {
            currentLocation = {
              lat: marker.getPosition().lat(),
              lng: marker.getPosition().lng()
            };
            sendMessage('locationUpdated', {
              latitude: currentLocation.lat,
              longitude: currentLocation.lng
            });
          });
        } else {
          // Mover marcador existente
          marker.setPosition(event.latLng);
        }
        
        currentLocation = {
          lat: event.latLng.lat(),
          lng: event.latLng.lng()
        };
        sendMessage('locationUpdated', {
          latitude: currentLocation.lat,
          longitude: currentLocation.lng
        });
      });

      // Escuchar mensajes desde React Native
      window.addEventListener('message', handleMessage);
      
      // Notificar que el mapa est√° listo
      sendMessage('mapReady', {});
    }

    function handleMessage(event) {
      try {
        const data = JSON.parse(event.data);
        
        switch(data.type) {
          case 'setLocation':
            setLocation(data.latitude, data.longitude);
            break;
          case 'centerOnLocation':
            centerOnLocation();
            break;
        }
      } catch (e) {
      }
    }

    function setLocation(lat, lng) {
      const position = new google.maps.LatLng(lat, lng);
      
      if (!marker) {
        // Crear marcador si no existe
        marker = new google.maps.Marker({
          position: position,
          map: map,
          draggable: true,
          animation: google.maps.Animation.DROP,
          title: "Ubicaci√≥n de la direcci√≥n"
        });
        
        // Agregar listener para arrastrar
        marker.addListener('dragend', function() {
          currentLocation = {
            lat: marker.getPosition().lat(),
            lng: marker.getPosition().lng()
          };
          sendMessage('locationUpdated', {
            latitude: currentLocation.lat,
            longitude: currentLocation.lng
          });
        });
      } else {
        marker.setPosition(position);
      }
      
      map.setCenter(position);
      currentLocation = { lat, lng };
    }

    function centerOnLocation() {
      if (currentLocation) {
        map.setCenter(currentLocation);
        map.setZoom(16);
      }
    }

    function sendMessage(type, data) {
      try {
        if (window.ReactNativeWebView) {
          window.ReactNativeWebView.postMessage(JSON.stringify({
            type: type,
            ...data
          }));
        }
      } catch (e) {
      }
    }
  </script>
  <script async defer
    src="https://maps.googleapis.com/maps/api/js?key=${apiKey}&callback=initMap">
  </script>
</body>
</html>
  `
        : '',
    [latitude, longitude, isMapFullscreen, apiKey],
  );

  // Manejar mensajes del WebView
  const handleWebViewMessage = React.useCallback(
    (event: any) => {
      try {
        const data = JSON.parse(event.nativeEvent.data);

        switch (data.type) {
          case 'mapReady':
            setMapReady(true);
            setIsMapLoading(false);
            break;
          case 'locationUpdated':
            // Convertir a n√∫mero antes de guardar
            setValue('latitude', Number(data.latitude));
            setValue('longitude', Number(data.longitude));
            break;
        }
      } catch (e) {
      }
    },
    [setValue],
  );

  // Enviar mensaje al WebView
  const sendMessageToWebView = React.useCallback((type: string, data: any) => {
    if (webViewRef.current) {
      const message = JSON.stringify({ type, ...data });
      webViewRef.current.postMessage(message);
    }
  }, []);

  // Actualizar la ubicaci√≥n en el mapa cuando cambie
  useEffect(() => {
    if (mapReady && latitude !== undefined && longitude !== undefined) {
      sendMessageToWebView('setLocation', {
        latitude,
        longitude,
      });
    }
  }, [latitude, longitude, mapReady]);

  // Resetear estados cuando el componente se monta
  useEffect(() => {
    if (visible) {
      setIsMapLoading(true);
      setMapReady(false);
    }
  }, [visible]);

  const handleFormSubmit = React.useCallback(
    async (data: AddressFormInputs) => {
      const formattedData: CreateAddressDto = {
        name: data.name,
        street: data.street,
        number: data.number,
        interiorNumber: data.interiorNumber || undefined,
        neighborhood: data.neighborhood,
        city: data.city,
        state: data.state,
        zipCode: data.zipCode,
        country: data.country,
        deliveryInstructions: data.deliveryInstructions || undefined,
        latitude: data.latitude !== undefined ? data.latitude : undefined,
        longitude: data.longitude !== undefined ? data.longitude : undefined,
        isDefault: data.isDefault || false,
      };
      await onSubmit(formattedData);
    },
    [onSubmit],
  );

  const hasValidCoordinates = React.useMemo(() => {
    return (
      latitude !== undefined &&
      longitude !== undefined &&
      !isNaN(Number(latitude)) &&
      !isNaN(Number(longitude)) &&
      Number(latitude) !== 0 &&
      Number(longitude) !== 0
    );
  }, [latitude, longitude]);

  return (
    <>
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onDismiss}
          contentContainerStyle={styles.modalContainer}
        >
          <Surface style={styles.modalContent} elevation={5}>
            <View
              style={[
                styles.headerContainer,
                { backgroundColor: theme.colors.primary },
              ]}
            >
              <View style={styles.headerLeft}>
                <Avatar.Icon
                  size={28}
                  icon={editingItem ? 'map-marker-radius' : 'map-marker-plus'}
                  style={[
                    styles.headerIcon,
                    { backgroundColor: theme.colors.onPrimary + '20' },
                  ]}
                  color={theme.colors.onPrimary}
                />
                <View style={styles.headerTextContainer}>
                  <Text
                    style={[
                      styles.modalTitle,
                      { color: theme.colors.onPrimary },
                    ]}
                    variant="titleMedium"
                  >
                    {editingItem ? 'Editar Direcci√≥n' : 'Nueva Direcci√≥n'}
                  </Text>
                </View>
              </View>
              <IconButton
                icon="close"
                size={24}
                onPress={onDismiss}
                disabled={isSubmitting}
                iconColor={theme.colors.onPrimary}
              />
            </View>

            <ScrollView
              ref={scrollViewRef}
              style={styles.formContainer}
              showsVerticalScrollIndicator={false}
              keyboardShouldPersistTaps="handled"
            >
              {/* Switch de direcci√≥n predeterminada al inicio */}
              <Controller
                control={control}
                name="isDefault"
                render={({ field: { onChange, value } }) => (
                  <Surface
                    style={[
                      styles.switchContainer,
                      { marginBottom: theme.spacing.m },
                    ]}
                    elevation={1}
                  >
                    <View style={styles.switchContent}>
                      <View style={styles.switchTextContainer}>
                        <Text style={styles.switchLabel} variant="bodyLarge">
                          Direcci√≥n predeterminada
                        </Text>
                        <Text
                          style={styles.switchDescription}
                          variant="bodySmall"
                        >
                          Esta ser√° la direcci√≥n principal para los pedidos
                        </Text>
                      </View>
                      <Switch
                        value={value}
                        onValueChange={onChange}
                        color={theme.colors.primary}
                      />
                    </View>
                  </Surface>
                )}
              />

              <View style={styles.sectionContainer}>
                <View style={styles.sectionHeader}>
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Informaci√≥n de la Direcci√≥n
                  </Text>
                  <Chip
                    mode="flat"
                    compact
                    style={styles.requiredChip}
                    textStyle={styles.requiredChipText}
                  >
                    Requerido
                  </Chip>
                </View>

                <Controller
                  control={control}
                  name="name"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="Nombre de la direcci√≥n"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.name}
                        mode="outlined"
                        placeholder="Ej: Casa, Oficina, Casa de mam√°"
                        left={<TextInput.Icon icon="tag" />}
                        outlineStyle={styles.inputOutline}
                      />
                      {errors.name && (
                        <HelperText type="error" visible={!!errors.name}>
                          {errors.name.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />

                <Controller
                  control={control}
                  name="street"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="Calle"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.street}
                        mode="outlined"
                        placeholder="Ej: Av. Insurgentes"
                        left={<TextInput.Icon icon="road" />}
                        outlineStyle={styles.inputOutline}
                      />
                      {errors.street && (
                        <HelperText type="error" visible={!!errors.street}>
                          {errors.street.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />

                <View style={styles.row}>
                  <View style={styles.halfInput}>
                    <Controller
                      control={control}
                      name="number"
                      render={({ field: { onChange, onBlur, value } }) => (
                        <View style={styles.inputContainer}>
                          <TextInput
                            label="N√∫mero"
                            value={value}
                            onChangeText={onChange}
                            onBlur={onBlur}
                            error={!!errors.number}
                            mode="outlined"
                            placeholder="123"
                            left={<TextInput.Icon icon="numeric" />}
                            outlineStyle={styles.inputOutline}
                          />
                          {errors.number && (
                            <HelperText type="error" visible={!!errors.number}>
                              {errors.number.message}
                            </HelperText>
                          )}
                        </View>
                      )}
                    />
                  </View>

                  <View style={styles.halfInput}>
                    <Controller
                      control={control}
                      name="interiorNumber"
                      render={({ field: { onChange, onBlur, value } }) => (
                        <View style={styles.inputContainer}>
                          <TextInput
                            label="Interior"
                            value={value}
                            onChangeText={onChange}
                            onBlur={onBlur}
                            mode="outlined"
                            placeholder="Depto 4B"
                            left={<TextInput.Icon icon="home-variant" />}
                            outlineStyle={styles.inputOutline}
                          />
                        </View>
                      )}
                    />
                  </View>
                </View>

                <Controller
                  control={control}
                  name="neighborhood"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="Colonia"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.neighborhood}
                        mode="outlined"
                        placeholder="Ej: Roma Norte"
                        left={<TextInput.Icon icon="map" />}
                        outlineStyle={styles.inputOutline}
                      />
                      {errors.neighborhood && (
                        <HelperText
                          type="error"
                          visible={!!errors.neighborhood}
                        >
                          {errors.neighborhood.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />

                <Controller
                  control={control}
                  name="city"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="Ciudad"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.city}
                        mode="outlined"
                        placeholder="Ej: Ciudad de M√©xico"
                        left={<TextInput.Icon icon="city" />}
                        outlineStyle={styles.inputOutline}
                      />
                      {errors.city && (
                        <HelperText type="error" visible={!!errors.city}>
                          {errors.city.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />

                <View style={styles.row}>
                  <View style={styles.halfInput}>
                    <Controller
                      control={control}
                      name="state"
                      render={({ field: { onChange, onBlur, value } }) => (
                        <View style={styles.inputContainer}>
                          <TextInput
                            label="Estado"
                            value={value}
                            onChangeText={onChange}
                            onBlur={onBlur}
                            error={!!errors.state}
                            mode="outlined"
                            placeholder="Ej: CDMX"
                            left={<TextInput.Icon icon="map-marker" />}
                            outlineStyle={styles.inputOutline}
                          />
                          {errors.state && (
                            <HelperText type="error" visible={!!errors.state}>
                              {errors.state.message}
                            </HelperText>
                          )}
                        </View>
                      )}
                    />
                  </View>

                  <View style={styles.halfInput}>
                    <Controller
                      control={control}
                      name="zipCode"
                      render={({ field: { onChange, onBlur, value } }) => (
                        <View style={styles.inputContainer}>
                          <TextInput
                            label="C.P."
                            value={value}
                            onChangeText={onChange}
                            onBlur={onBlur}
                            error={!!errors.zipCode}
                            mode="outlined"
                            placeholder="06700"
                            keyboardType="numeric"
                            maxLength={5}
                            left={<TextInput.Icon icon="mailbox" />}
                            outlineStyle={styles.inputOutline}
                          />
                          {errors.zipCode && (
                            <HelperText type="error" visible={!!errors.zipCode}>
                              {errors.zipCode.message}
                            </HelperText>
                          )}
                        </View>
                      )}
                    />
                  </View>
                </View>

                <Controller
                  control={control}
                  name="country"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="Pa√≠s"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.country}
                        mode="outlined"
                        placeholder="M√©xico"
                        left={<TextInput.Icon icon="earth" />}
                        outlineStyle={styles.inputOutline}
                      />
                      {errors.country && (
                        <HelperText type="error" visible={!!errors.country}>
                          {errors.country.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />
              </View>

              <View style={styles.sectionContainer}>
                <View style={styles.sectionHeader}>
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Informaci√≥n Adicional
                  </Text>
                  <Chip
                    mode="flat"
                    compact
                    style={styles.optionalChip}
                    textStyle={styles.optionalChipText}
                  >
                    Opcional
                  </Chip>
                </View>

                <Controller
                  control={control}
                  name="deliveryInstructions"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="Instrucciones de entrega"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        mode="outlined"
                        placeholder="Entre calles, color de fachada, etc."
                        multiline
                        numberOfLines={2}
                        left={<TextInput.Icon icon="sign-direction" />}
                        outlineStyle={styles.inputOutline}
                      />
                    </View>
                  )}
                />

                {/* Secci√≥n de Ubicaci√≥n con Mapa Integrado */}
                <View style={styles.locationWrapper}>
                  <View style={styles.locationHeader}>
                    <Text style={styles.locationLabel} variant="bodyMedium">
                      Ubicaci√≥n en el mapa
                    </Text>
                    {hasValidCoordinates && (
                      <Button
                        mode="text"
                        onPress={() => {
                          setValue('latitude', undefined);
                          setValue('longitude', undefined);
                          // Forzar la validaci√≥n del formulario
                          trigger(['latitude', 'longitude']);
                        }}
                        icon="close"
                        compact
                        style={styles.clearLocationBtn}
                      >
                        Limpiar
                      </Button>
                    )}
                  </View>

                  <Surface style={styles.mapContainer} elevation={1}>
                    <View style={styles.mapInstructions}>
                      <Icon
                        source="gesture-two-double-tap"
                        size={20}
                        color={theme.colors.primary}
                      />
                      <Text
                        style={styles.mapInstructionText}
                        variant="bodySmall"
                      >
                        Usa dos dedos para mover el mapa ‚Ä¢ Toca para marcar
                        ubicaci√≥n
                      </Text>
                    </View>

                    <View style={styles.mapView}>
                      {isLoadingApiKey || !mapHtml ? (
                        <View style={[styles.map, styles.mapLoadingContainer]}>
                          <ActivityIndicator
                            size="large"
                            color={theme.colors.primary}
                          />
                          <Text style={styles.mapLoadingText}>
                            Cargando mapa...
                          </Text>
                        </View>
                      ) : (
                        <WebView
                          ref={webViewRef}
                          source={{ html: mapHtml }}
                          style={styles.map}
                          onMessage={handleWebViewMessage}
                          onError={(_error) => {}}
                          javaScriptEnabled={true}
                          domStorageEnabled={true}
                          startInLoadingState={true}
                          mixedContentMode="compatibility"
                          allowsInlineMediaPlayback={true}
                          originWhitelist={['*']}
                          scalesPageToFit={false}
                          bounces={false}
                          scrollEnabled={false}
                          nestedScrollEnabled={false}
                        />
                      )}

                      {/* Indicador de carga */}
                      {isMapLoading && (
                        <View style={styles.mapLoadingContainer}>
                          <Surface style={styles.mapLoadingCard} elevation={3}>
                            <ActivityIndicator
                              size="large"
                              color={theme.colors.primary}
                            />
                            <Text style={styles.mapLoadingText}>
                              Cargando mapa...
                            </Text>
                          </Surface>
                        </View>
                      )}

                      {/* Botones flotantes */}
                      {mapReady && (
                        <>
                          {/* Bot√≥n de expandir */}
                          <View style={styles.expandButtonContainer}>
                            <Button
                              mode="contained"
                              icon={
                                isMapFullscreen
                                  ? 'fullscreen-exit'
                                  : 'fullscreen'
                              }
                              onPress={() =>
                                setIsMapFullscreen(!isMapFullscreen)
                              }
                              style={styles.expandButton}
                              labelStyle={styles.expandButtonLabel}
                            >
                              {isMapFullscreen ? 'Cerrar' : 'Expandir mapa'}
                            </Button>
                          </View>

                          {/* Bot√≥n de centrar */}
                          {hasValidCoordinates && (
                            <View style={styles.centerButtonContainer}>
                              <IconButton
                                icon="crosshairs-gps"
                                mode="contained"
                                containerColor={theme.colors.primaryContainer}
                                iconColor={theme.colors.onPrimaryContainer}
                                size={20}
                                onPress={() =>
                                  sendMessageToWebView('centerOnLocation', {})
                                }
                                style={styles.floatingButton}
                              />
                            </View>
                          )}
                        </>
                      )}
                    </View>

                    {/* Mostrar coordenadas */}
                    {hasValidCoordinates && (
                      <View style={styles.coordinatesContainer}>
                        <Text
                          variant="labelSmall"
                          style={styles.coordinatesLabel}
                        >
                          Coordenadas:
                        </Text>
                        <Text
                          variant="bodySmall"
                          style={styles.coordinatesText}
                        >
                          {Number(latitude).toFixed(6)},{' '}
                          {Number(longitude).toFixed(6)}
                        </Text>
                      </View>
                    )}
                  </Surface>
                </View>
              </View>

              {/* Espacio adicional para el teclado */}
              <View style={{ height: 10 }} />
            </ScrollView>

            <Surface style={styles.buttonContainer} elevation={2}>
              <Button
                onPress={onDismiss}
                disabled={isSubmitting}
                style={[styles.button, styles.cancelButton]}
                textColor={theme.colors.onSecondaryContainer}
              >
                Cancelar
              </Button>
              <Button
                mode="contained"
                onPress={() => {
                  handleSubmit(handleFormSubmit, (validationErrors) => {
                    const errorMessages = Object.entries(validationErrors)
                      .map(([field, error]) => {
                        if (error && 'message' in error) {
                          const fieldNames: Record<string, string> = {
                            name: 'Nombre de la direcci√≥n',
                            street: 'Calle',
                            number: 'N√∫mero',
                            neighborhood: 'Colonia',
                            city: 'Ciudad',
                            state: 'Estado',
                            zipCode: 'C√≥digo postal',
                            country: 'Pa√≠s',
                          };
                          const fieldName = fieldNames[field] || field;
                          return `${fieldName}: ${error.message}`;
                        }
                        return null;
                      })
                      .filter(Boolean);

                    if (errorMessages.length > 0) {
                      showSnackbar({
                        message: errorMessages[0],
                        type: 'error',
                      });

                      scrollViewRef.current?.scrollTo({
                        x: 0,
                        y: 0,
                        animated: true,
                      });
                    }
                  })();
                }}
                disabled={isSubmitting}
                loading={isSubmitting}
                style={[styles.button, styles.confirmButton]}
                buttonColor={theme.colors.primary}
              >
                {editingItem ? 'Guardar' : 'Crear'}
              </Button>
            </Surface>
          </Surface>
        </Modal>
      </Portal>

      {/* Modal de mapa en pantalla completa */}
      <Portal>
        <Modal
          visible={isMapFullscreen}
          onDismiss={() => setIsMapFullscreen(false)}
          contentContainerStyle={styles.fullscreenModalContainer}
        >
          <Surface style={styles.fullscreenModalContent} elevation={5}>
            <View style={styles.fullscreenHeader}>
              <Text variant="titleLarge" style={styles.fullscreenTitle}>
                Ubicaci√≥n
              </Text>
              <IconButton
                icon="close"
                size={28}
                onPress={() => setIsMapFullscreen(false)}
                style={styles.fullscreenCloseButton}
              />
            </View>

            <View style={styles.fullscreenMapContainer}>
              <WebView
                source={{ html: mapHtml }}
                style={styles.map}
                onMessage={handleWebViewMessage}
                javaScriptEnabled={true}
                domStorageEnabled={true}
                startInLoadingState={false}
                mixedContentMode="compatibility"
                allowsInlineMediaPlayback={true}
                originWhitelist={['*']}
                scalesPageToFit={false}
              />

              {hasValidCoordinates && (
                <View style={styles.fullscreenCoordinates}>
                  <Surface style={styles.coordinatesBadge} elevation={3}>
                    <Icon
                      source="map-marker"
                      size={20}
                      color={theme.colors.primary}
                    />
                    <Text variant="bodyLarge" style={styles.coordinatesText}>
                      {Number(latitude).toFixed(6)},{' '}
                      {Number(longitude).toFixed(6)}
                    </Text>
                  </Surface>
                </View>
              )}
            </View>
          </Surface>
        </Modal>
      </Portal>
    </>
  );
}

const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    modalContainer: {
      margin: 10,
      justifyContent: 'center',
    },
    modalContent: {
      borderRadius: theme.roundness * 3,
      backgroundColor: theme.colors.surface,
      maxHeight: '95%',
      minHeight: '80%',
      overflow: 'hidden',
    },
    headerContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.xs,
      borderTopLeftRadius: theme.roundness * 3,
      borderTopRightRadius: theme.roundness * 3,
    },
    headerLeft: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
    },
    headerIcon: {
      marginRight: theme.spacing.s,
    },
    headerTextContainer: {
      flex: 1,
    },
    modalTitle: {
      fontWeight: '700',
    },
    formContainer: {
      flex: 1,
      paddingHorizontal: theme.spacing.m,
      paddingTop: theme.spacing.xs,
    },
    sectionContainer: {
      marginBottom: theme.spacing.s,
    },
    sectionHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.xs,
    },
    sectionTitle: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: 14,
    },
    requiredChip: {
      backgroundColor: theme.colors.errorContainer,
    },
    requiredChipText: {
      color: theme.colors.onErrorContainer,
      fontSize: 11,
    },
    optionalChip: {
      backgroundColor: theme.colors.surfaceVariant,
    },
    optionalChipText: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 11,
    },
    inputContainer: {
      marginBottom: theme.spacing.xs,
    },
    inputOutline: {
      borderRadius: theme.roundness * 2,
    },
    row: {
      flexDirection: 'row',
      gap: theme.spacing.s,
    },
    halfInput: {
      flex: 1,
    },
    locationWrapper: {
      marginTop: theme.spacing.m,
    },
    locationHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.s,
    },
    locationLabel: {
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    clearLocationBtn: {
      marginRight: -theme.spacing.s,
    },
    mapContainer: {
      borderRadius: theme.roundness * 2,
      overflow: 'hidden',
      backgroundColor: theme.colors.surface,
    },
    mapInstructions: {
      flexDirection: 'row',
      alignItems: 'center',
      padding: theme.spacing.s,
      backgroundColor: theme.colors.primaryContainer,
      gap: theme.spacing.s,
    },
    mapInstructionText: {
      flex: 1,
      color: theme.colors.onPrimaryContainer,
    },
    mapView: {
      height: 300,
      position: 'relative',
    },
    map: {
      ...StyleSheet.absoluteFillObject,
    },
    mapLoadingContainer: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      justifyContent: 'center',
      alignItems: 'center',
      backgroundColor: 'rgba(0, 0, 0, 0.3)',
    },
    mapLoadingCard: {
      padding: theme.spacing.xl,
      borderRadius: 16,
      alignItems: 'center',
      backgroundColor: theme.colors.surface,
    },
    mapLoadingText: {
      marginTop: theme.spacing.m,
      fontSize: 14,
      color: theme.colors.onSurface,
      fontWeight: '500',
    },
    expandButtonContainer: {
      position: 'absolute',
      top: theme.spacing.s,
      right: theme.spacing.s,
      zIndex: 10,
    },
    expandButton: {
      elevation: 4,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
    },
    expandButtonLabel: {
      fontSize: 14,
      fontWeight: '600',
    },
    centerButtonContainer: {
      position: 'absolute',
      bottom: theme.spacing.s,
      right: theme.spacing.s,
    },
    floatingButton: {
      elevation: 4,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
    },
    coordinatesContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      padding: theme.spacing.s,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      gap: theme.spacing.xs,
    },
    coordinatesLabel: {
      color: theme.colors.onSurfaceVariant,
    },
    coordinatesText: {
      fontWeight: '500',
      color: theme.colors.onSurface,
      fontFamily: 'monospace',
    },
    switchContainer: {
      borderRadius: theme.roundness * 2,
      padding: theme.spacing.xs,
      marginTop: theme.spacing.xs,
    },
    switchContent: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    switchTextContainer: {
      flex: 1,
      marginRight: theme.spacing.m,
    },
    switchLabel: {
      color: theme.colors.onSurface,
      fontWeight: '500',
    },
    switchDescription: {
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
      fontSize: 12,
    },
    buttonContainer: {
      flexDirection: 'row',
      justifyContent: 'center',
      padding: theme.spacing.s,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      gap: theme.spacing.s,
    },
    button: {
      flex: 1,
      maxWidth: 150,
    },
    cancelButton: {
      backgroundColor: theme.colors.secondaryContainer,
    },
    confirmButton: {},
    fullscreenModalContainer: {
      flex: 1,
      margin: 0,
    },
    fullscreenModalContent: {
      flex: 1,
      backgroundColor: theme.colors.surface,
    },
    fullscreenHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingLeft: theme.spacing.l,
      paddingRight: theme.spacing.s,
      paddingVertical: theme.spacing.s,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
      height: 56,
    },
    fullscreenTitle: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      flex: 1,
    },
    fullscreenCloseButton: {
      margin: 0,
    },
    fullscreenMapContainer: {
      flex: 1,
      position: 'relative',
    },
    fullscreenCoordinates: {
      position: 'absolute',
      bottom: theme.spacing.m,
      left: theme.spacing.m,
    },
    coordinatesBadge: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.s,
      borderRadius: theme.roundness * 2,
      backgroundColor: theme.colors.surface,
      gap: theme.spacing.s,
    },
    coordinatesText: {
      fontFamily: 'monospace',
      color: theme.colors.onSurface,
      fontWeight: '500',
    },
  });

================
File: app/src/modules/kitchen/screens/KitchenOrdersScreen.tsx
================
import React, {
  useEffect,
  useRef,
  useState,
  useMemo,
  useCallback,
} from 'react';
import { View, StyleSheet, ScrollView, Animated, Platform } from 'react-native';
import { Text, ActivityIndicator, Surface } from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import {
  useKitchenOrders,
  useStartOrderPreparation,
  useCancelOrderPreparation,
  useCompleteOrderPreparation,
} from '../hooks/useKitchenOrders';
import { useKitchenStore } from '../store/kitchenStore';
import { OrderCard } from '../components/OrderCard';
import * as ScreenOrientation from 'expo-screen-orientation';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useKitchenContext } from '../context/KitchenContext';
import { OrderType } from '../types/kitchen.types';

export default function KitchenOrdersScreen() {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const { filters } = useKitchenStore();
  const pulseAnim = useRef(new Animated.Value(1)).current;
  const [isSwipingCard, setIsSwipingCard] = useState(false);
  const { refetchRef } = useKitchenContext();

  const { data: orders, isLoading, refetch } = useKitchenOrders(filters);
  const startOrderPreparation = useStartOrderPreparation();
  const cancelOrderPreparation = useCancelOrderPreparation();
  const completeOrderPreparation = useCompleteOrderPreparation();

  useEffect(() => {
    refetchRef.current = refetch;
  }, [refetch, refetchRef]);

  const hasOrders = !!orders?.length;

  const styles = useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );

  const cardWidth = useMemo(() => {
    if (responsive.isDesktop) {
      // En desktop, las tarjetas son m√°s grandes
      return responsive.getResponsiveDimension(340, 380);
    }
    if (responsive.isWeb && responsive.isTablet) {
      // En web tablet, tama√±o intermedio
      return responsive.getResponsiveDimension(300, 340);
    }
    return responsive.isTablet
      ? responsive.getResponsiveDimension(280, 320)
      : responsive.getResponsiveDimension(240, 280);
  }, [responsive.isTablet, responsive.isDesktop, responsive.isWeb]);

  const handleStartPreparation = useCallback(
    (orderId: string) => {
      startOrderPreparation.mutate(orderId);
    },
    [startOrderPreparation],
  );

  const handleCancelPreparation = useCallback(
    (orderId: string) => {
      cancelOrderPreparation.mutate(orderId);
    },
    [cancelOrderPreparation],
  );

  const handleCompletePreparation = useCallback(
    (orderId: string) => {
      completeOrderPreparation.mutate(orderId);
    },
    [completeOrderPreparation],
  );

  useEffect(() => {
    if (Platform.OS !== 'web') {
      const setLandscape = async () => {
        await ScreenOrientation.lockAsync(
          ScreenOrientation.OrientationLock.LANDSCAPE,
        );
      };
      setLandscape();

      return () => {
        ScreenOrientation.unlockAsync();
      };
    }
  }, []);

  useEffect(() => {
    if (!hasOrders) {
      const animation = Animated.loop(
        Animated.sequence([
          Animated.timing(pulseAnim, {
            toValue: 1.2,
            duration: 1500,
            useNativeDriver: true,
          }),
          Animated.timing(pulseAnim, {
            toValue: 1,
            duration: 1500,
            useNativeDriver: true,
          }),
        ]),
      );
      animation.start();
      return () => animation.stop();
    }
  }, [hasOrders, pulseAnim]);

  const emptyMessage = useMemo(() => {
    const activeFilters = [];

    if (filters.orderType) {
      const typeLabels = {
        [OrderType.DINE_IN]: 'Para Mesa',
        [OrderType.TAKE_AWAY]: 'Para Llevar',
        [OrderType.DELIVERY]: 'Delivery',
      };
      activeFilters.push(`Tipo: ${typeLabels[filters.orderType]}`);
    }

    if (filters.showPrepared) {
      activeFilters.push('Solo √≥rdenes listas');
    }

    if (!filters.showAllProducts && filters.screenId) {
      activeFilters.push('Solo productos de esta pantalla');
    }

    if (activeFilters.length > 0) {
      return {
        title: 'No hay pedidos con los filtros activos',
        subtitle: `Filtros: ${activeFilters.join(', ')}`,
        hint: 'Ajusta los filtros o espera nuevos pedidos',
      };
    }

    return {
      title: 'No hay pedidos pendientes',
      subtitle: 'Los nuevos pedidos aparecer√°n aqu√≠ autom√°ticamente',
      hint: 'Presiona el bot√≥n de recargar para verificar nuevos pedidos',
    };
  }, [filters]);

  const handleSwipeStart = useCallback(() => setIsSwipingCard(true), []);
  const handleSwipeEnd = useCallback(() => {
    setTimeout(() => setIsSwipingCard(false), 100);
  }, []);

  if (isLoading) {
    return (
      <View style={styles.centerContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
        <Text variant="bodyLarge" style={styles.loadingText}>
          Cargando pedidos...
        </Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      {hasOrders ? (
        <ScrollView
          horizontal={!responsive.isWeb || responsive.width < 1200}
          scrollEnabled={!isSwipingCard}
          showsHorizontalScrollIndicator={false}
          pagingEnabled={false}
          contentContainerStyle={[
            styles.horizontalListContainer,
            responsive.isWeb &&
              responsive.width >= 1200 &&
              styles.gridContainer,
          ]}
          snapToInterval={
            responsive.isWeb ? undefined : cardWidth + responsive.spacing.m
          }
          decelerationRate="fast"
          snapToAlignment={responsive.isWeb ? undefined : 'start'}
        >
          {orders.map((item, index) => (
            <View
              key={item.id}
              style={[
                styles.cardContainer,
                {
                  width: cardWidth,
                  marginRight:
                    index === orders.length - 1 ? 0 : responsive.spacing.xxs,
                },
                responsive.isWeb &&
                  responsive.width >= 1200 &&
                  styles.cardContainerWeb,
              ]}
            >
              <OrderCard
                order={item}
                onStartPreparation={handleStartPreparation}
                onCancelPreparation={handleCancelPreparation}
                onCompletePreparation={handleCompletePreparation}
                onSwipeStart={handleSwipeStart}
                onSwipeEnd={handleSwipeEnd}
              />
            </View>
          ))}
        </ScrollView>
      ) : (
        <View style={styles.emptyStateContainer}>
          <Surface style={styles.emptyCard} elevation={4}>
            <Animated.View
              style={[
                styles.emptyIconContainer,
                { transform: [{ scale: pulseAnim }] },
              ]}
            >
              <Icon
                name={
                  filters.orderType ||
                  filters.showPrepared ||
                  !filters.showAllProducts
                    ? 'filter-remove'
                    : 'chef-hat'
                }
                size={
                  responsive.isWeb
                    ? 64
                    : responsive.getResponsiveDimension(32, 40)
                }
                color={theme.colors.primary}
              />
            </Animated.View>
            <Text
              variant="titleMedium"
              style={[styles.emptyText, { color: theme.colors.onSurface }]}
              numberOfLines={2}
              adjustsFontSizeToFit
            >
              {emptyMessage.title}
            </Text>
            <Text
              variant="bodyMedium"
              style={[
                styles.emptySubtext,
                { color: theme.colors.onSurfaceVariant },
              ]}
              numberOfLines={2}
              adjustsFontSizeToFit
            >
              {emptyMessage.subtitle}
            </Text>
            <Text
              variant="bodySmall"
              style={[
                styles.emptyHint,
                { color: theme.colors.onSurfaceVariant },
              ]}
              numberOfLines={2}
              adjustsFontSizeToFit
            >
              {emptyMessage.hint}
            </Text>
          </Surface>
        </View>
      )}
    </View>
  );
}

const createStyles = (theme: any, responsive: any) =>
  StyleSheet.create({
    container: {
      flex: 1,
      position: 'relative',
      backgroundColor: theme.colors.background,
    },
    centerContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      backgroundColor: theme.colors.background,
    },
    horizontalListContainer: {
      paddingLeft: responsive.isWeb
        ? responsive.spacing.m
        : responsive.spacing.xxs,
      paddingRight: responsive.isWeb
        ? responsive.spacing.m
        : responsive.spacing.xs,
      paddingVertical: responsive.isWeb
        ? responsive.spacing.s
        : responsive.spacing.xxs,
      minHeight: '100%',
      alignItems:
        responsive.isWeb && responsive.width >= 1200 ? 'flex-start' : 'center',
    },
    gridContainer: {
      flexDirection: 'row',
      flexWrap: 'wrap',
      justifyContent: 'flex-start',
      alignItems: 'flex-start',
      paddingHorizontal: responsive.spacing.l,
      paddingVertical: responsive.spacing.m,
    },
    emptyStateContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      paddingHorizontal: responsive.spacing.m,
      paddingVertical: responsive.spacing.xs,
      backgroundColor: theme.colors.background,
    },
    emptyCard: {
      paddingHorizontal: responsive.isWeb
        ? responsive.spacing.xl
        : responsive.spacing.m,
      paddingVertical: responsive.isWeb
        ? responsive.spacing.xl
        : responsive.spacing.m,
      borderRadius: theme.roundness * 2,
      alignItems: 'center',
      maxHeight: '70%',
      width: responsive.isWeb
        ? responsive.getResponsiveDimension(400, 480)
        : responsive.getResponsiveDimension(280, 320),
      backgroundColor: theme.colors.surface,
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 2,
      },
      shadowOpacity: 0.1,
      shadowRadius: 4,
      elevation: 3,
    },
    emptyIconContainer: {
      marginBottom: responsive.spacing.s,
      padding: responsive.spacing.s,
      backgroundColor: theme.colors.primaryContainer,
      borderRadius: theme.roundness,
    },
    emptyText: {
      textAlign: 'center',
      marginBottom: responsive.spacing.xs,
      fontWeight: '600',
      fontSize: responsive.fontSize.s,
      paddingHorizontal: responsive.spacing.xs,
      maxWidth: '100%',
      color: theme.colors.onSurface,
    },
    emptySubtext: {
      textAlign: 'center',
      lineHeight: responsive.getResponsiveDimension(16, 18),
      opacity: 0.7,
      marginBottom: responsive.spacing.s,
      fontSize: responsive.fontSize.xs,
      paddingHorizontal: responsive.spacing.xs,
      maxWidth: '100%',
      fontWeight: '400',
      color: theme.colors.onSurfaceVariant,
    },
    emptyHint: {
      textAlign: 'center',
      opacity: 0.5,
      fontStyle: 'italic',
      fontSize: responsive.fontSize.xs - 1,
      paddingHorizontal: responsive.spacing.xs,
      maxWidth: '100%',
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      paddingTop: responsive.spacing.s,
      marginTop: responsive.spacing.xs,
      width: '80%',
      fontWeight: '400',
      color: theme.colors.onSurfaceVariant,
    },
    // Estilos adicionales para eliminar inline styles
    loadingText: {
      marginTop: theme.spacing.m,
      color: theme.colors.onBackground,
    },
    cardContainer: {
      height: '100%',
      paddingVertical: responsive.spacing.xxxs,
    },
    cardContainerWeb: {
      marginRight: responsive.spacing.s,
      marginBottom: responsive.spacing.s,
      height: 'auto',
    },
  });

================
File: app/src/services/audioServiceHealth.ts
================
import axios from 'axios';
import { serverConnectionService } from '@/services/serverConnectionService';
import { useAuthStore } from '@/app/store/authStore';
import NetInfo from '@react-native-community/netinfo';
import { API_PATHS } from '@/app/constants/apiPaths';

export interface AudioServiceHealthStatus {
  isAvailable: boolean;
  hasInternet: boolean;
  serviceStatus: 'ok' | 'error' | 'disabled' | 'misconfigured' | 'checking';
  message?: string;
  lastChecked: Date;
}

class AudioServiceHealthChecker {
  private static instance: AudioServiceHealthChecker;
  private healthStatus: AudioServiceHealthStatus = {
    isAvailable: false,
    hasInternet: false,
    serviceStatus: 'checking',
    lastChecked: new Date(),
  };
  private listeners: ((status: AudioServiceHealthStatus) => void)[] = [];
  private checkInterval: NodeJS.Timeout | null = null;
  private lastCheckTime: number = 0;
  private readonly CHECK_INTERVAL = 30000; // 30 segundos
  private readonly MIN_CHECK_INTERVAL = 5000; // 5 segundos m√≠nimo entre checks
  private isActive: boolean = false;
  private networkListener: (() => void) | null = null;

  private constructor() {
    // NO iniciar verificaci√≥n autom√°tica
    // Solo escuchar cambios de conectividad cuando el servicio est√© activo
  }

  static getInstance(): AudioServiceHealthChecker {
    if (!AudioServiceHealthChecker.instance) {
      AudioServiceHealthChecker.instance = new AudioServiceHealthChecker();
    }
    return AudioServiceHealthChecker.instance;
  }

  async checkHealth(force: boolean = false): Promise<AudioServiceHealthStatus> {
    const now = Date.now();

    // Evitar checks muy frecuentes
    if (!force && now - this.lastCheckTime < this.MIN_CHECK_INTERVAL) {
      return this.healthStatus;
    }

    this.lastCheckTime = now;

    try {
      // Primero verificar conexi√≥n a internet
      const netInfo = await NetInfo.fetch();
      const hasInternet =
        netInfo.isConnected && netInfo.isInternetReachable !== false;

      if (!hasInternet) {
        this.updateStatus({
          isAvailable: false,
          hasInternet: false,
          serviceStatus: 'error',
          message: 'Sin conexi√≥n a internet',
          lastChecked: new Date(),
        });
        return this.healthStatus;
      }

      // Luego verificar el servicio
      const accessToken = useAuthStore.getState().accessToken;
      if (!accessToken) {
        this.updateStatus({
          isAvailable: false,
          hasInternet: true,
          serviceStatus: 'error',
          message: 'Usuario no autenticado',
          lastChecked: new Date(),
        });
        return this.healthStatus;
      }

      // Obtener la URL del servicio de conexi√≥n sin provocar discovery
      const connectionState = serverConnectionService.getState();
      if (!connectionState.currentUrl || !connectionState.isConnected) {
        this.updateStatus({
          isAvailable: false,
          hasInternet: true,
          serviceStatus: 'error',
          message: 'Servidor no conectado',
          lastChecked: new Date(),
        });
        return this.healthStatus;
      }

      const apiUrl = connectionState.currentUrl.endsWith('/')
        ? connectionState.currentUrl.slice(0, -1)
        : connectionState.currentUrl;
      const response = await axios.get(
        `${apiUrl}${API_PATHS.AUDIO_ORDERS_HEALTH}`,
        {
          headers: {
            Authorization: `Bearer ${accessToken}`,
          },
          timeout: 5000,
        },
      );

      const { available, status, message } = response.data;

      this.updateStatus({
        isAvailable: available,
        hasInternet: true,
        serviceStatus: status,
        message,
        lastChecked: new Date(),
      });
    } catch (error) {
      // Error al verificar servicio de audio en modo desarrollo

      let errorMessage = 'Servicio de voz no disponible';
      if (axios.isAxiosError(error)) {
        if (error.code === 'ECONNABORTED') {
          errorMessage = 'Tiempo de espera agotado';
        } else if (error.response?.status === 503) {
          errorMessage = 'Servicio temporalmente no disponible';
        } else if (error.response?.status === 404) {
          errorMessage = 'Servicio de voz no configurado';
        }
      }

      this.updateStatus({
        isAvailable: false,
        hasInternet: true,
        serviceStatus: 'error',
        message: errorMessage,
        lastChecked: new Date(),
      });
    }

    return this.healthStatus;
  }

  private updateStatus(status: AudioServiceHealthStatus) {
    this.healthStatus = status;
    this.notifyListeners();
  }

  private notifyListeners() {
    this.listeners.forEach((listener) => listener(this.healthStatus));
  }

  subscribe(listener: (status: AudioServiceHealthStatus) => void): () => void {
    this.listeners.push(listener);

    // Notificar inmediatamente con el estado actual
    listener(this.healthStatus);

    // Retornar funci√≥n para desuscribirse
    return () => {
      const index = this.listeners.indexOf(listener);
      if (index > -1) {
        this.listeners.splice(index, 1);
      }
    };
  }

  startPeriodicCheck() {
    if (this.checkInterval || !this.listeners.length) {
      return;
    }

    // Activar el servicio
    this.isActive = true;

    // Configurar listener de red si no existe
    if (!this.networkListener) {
      this.networkListener = NetInfo.addEventListener((state) => {
        if (
          this.isActive &&
          state.isConnected !== this.healthStatus.hasInternet
        ) {
          this.checkHealth();
        }
      });
    }

    // Hacer verificaci√≥n inicial
    this.checkHealth();

    // Configurar verificaciones peri√≥dicas
    this.checkInterval = setInterval(() => {
      if (this.isActive) {
        this.checkHealth();
      }
    }, this.CHECK_INTERVAL);
  }

  stopPeriodicCheck() {
    // Desactivar el servicio
    this.isActive = false;

    // Limpiar intervalo
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
    }

    // Limpiar listener de red
    if (this.networkListener) {
      this.networkListener();
      this.networkListener = null;
    }

    // Resetear estado
    this.updateStatus({
      isAvailable: false,
      hasInternet: false,
      serviceStatus: 'checking',
      message: undefined,
      lastChecked: new Date(),
    });
  }

  getStatus(): AudioServiceHealthStatus {
    return this.healthStatus;
  }
}

export const audioServiceHealth = AudioServiceHealthChecker.getInstance();

================
File: app/src/app/components/crud/GenericDetailModal.tsx
================
import React, { useMemo } from 'react';
import {
  View,
  StyleSheet,
  StyleProp,
  ViewStyle,
  TextStyle,
} from 'react-native';
import {
  Text,
  Button,
  Chip,
  ActivityIndicator,
  IconButton,
} from 'react-native-paper';
import AutoImage from '../common/AutoImage';
import { useAppTheme, AppTheme } from '../../styles/theme';
import { ResponsiveModal } from '../responsive/ResponsiveModal';
import { useResponsive } from '../../hooks/useResponsive';
import ConfirmationModal from '../common/ConfirmationModal';

export interface DisplayFieldConfig<TItem> {
  field: keyof TItem;
  label: string;
  render?: (value: TItem[keyof TItem], item: TItem) => React.ReactNode;
}

interface StatusConfig<TItem> {
  field: keyof TItem;
  activeValue: TItem[keyof TItem];
  activeLabel: string;
  inactiveLabel: string;
}

interface DeleteConfirmation {
  visible: boolean;
  title: string;
  message: string;
  onConfirm: () => void;
  onCancel: () => void;
  show: (id: string) => void;
}

interface GenericDetailModalProps<TItem extends { id: string }> {
  visible: boolean;
  onDismiss: () => void;
  item: TItem | null;
  titleField: keyof TItem;
  imageField?: keyof TItem;
  descriptionField?: keyof TItem;
  statusConfig?: StatusConfig<TItem>;
  fieldsToDisplay?: DisplayFieldConfig<TItem>[];
  onEdit?: (item: TItem) => void;
  onDelete?: (id: string) => void;
  deleteConfirmation?: DeleteConfirmation;
  isDeleting?: boolean;
  editButtonLabel?: string;
  deleteButtonLabel?: string;
  closeButtonLabel?: string;
  modalStyle?: StyleProp<ViewStyle>;
  titleStyle?: StyleProp<TextStyle>;
  imageStyle?: StyleProp<ViewStyle>;
  descriptionStyle?: StyleProp<TextStyle>;
  fieldLabelStyle?: StyleProp<TextStyle>;
  fieldValueStyle?: StyleProp<TextStyle>;
  actionsContainerStyle?: StyleProp<ViewStyle>;
  showImage?: boolean;
  children?: React.ReactNode;
}

const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) => {
  return StyleSheet.create({
    modalSurface: {
      backgroundColor: theme.colors.elevation.level2,
      borderWidth: 2,
      borderColor: theme.colors.outline,
      borderRadius: theme.roundness * 2,
      elevation: 4,
      shadowColor: theme.colors.shadow,
      shadowOffset: {
        width: 0,
        height: 2,
      },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
    },
    modalTitle: {
      marginTop: responsive.spacing(theme.spacing.l),
      marginBottom: responsive.spacing(theme.spacing.m),
      textAlign: 'center',
      fontWeight: '700',
      fontSize: responsive.isTablet ? 22 : 20,
      paddingHorizontal: responsive.spacing(theme.spacing.m),
    },
    detailContent: {
      alignItems: 'center',
      marginBottom: responsive.spacing(theme.spacing.m),
      width: '100%',
      paddingHorizontal: responsive.spacing(theme.spacing.m),
    },
    detailImage: {
      width: responsive.isTablet
        ? responsive.getResponsiveDimension(120, 150)
        : responsive.getResponsiveDimension(150, 180),
      height: responsive.isTablet
        ? responsive.getResponsiveDimension(120, 150)
        : responsive.getResponsiveDimension(150, 180),
      borderRadius: theme.roundness * 2,
      marginBottom: responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surfaceDisabled,
      elevation: 2,
    },
    detailDescription: {
      marginBottom: responsive.spacing(theme.spacing.m),
      textAlign: 'center',
      lineHeight: responsive.isTablet ? 20 : 18,
      fontSize: responsive.isTablet ? 14 : 13,
      paddingHorizontal: responsive.spacing(theme.spacing.xs),
      flexWrap: 'wrap',
      width: '100%',
    },
    statusChipContainer: {
      marginBottom: responsive.spacing(theme.spacing.s),
      marginTop: responsive.spacing(theme.spacing.s),
    },
    statusChip: {
      paddingHorizontal: responsive.spacing(theme.spacing.s),
      height: responsive.isTablet ? 36 : 32,
    },
    fieldsContainer: {
      width: '100%',
      marginBottom: responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: theme.roundness * 1.5,
      padding: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      marginHorizontal: responsive.spacing(theme.spacing.m),
      alignSelf: 'center',
      maxWidth: '90%',
    },
    fieldRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
      marginBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
      paddingVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.xxs)
        : responsive.spacing(theme.spacing.xs),
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
      flexWrap: 'wrap',
    },
    lastFieldRow: {
      marginBottom: 0,
      borderBottomWidth: 0,
    },
    fieldLabel: {
      fontWeight: '600',
      marginRight: responsive.spacing(theme.spacing.s),
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 14 : 13,
      flexBasis: '35%',
      minWidth: 100,
    },
    fieldValue: {
      flex: 1,
      textAlign: 'right',
      color: theme.colors.onSurface,
      fontSize: responsive.isTablet ? 14 : 13,
      flexWrap: 'wrap',
      maxWidth: '65%',
    },
    detailActions: {
      flexDirection: 'row',
      justifyContent: 'center',
      alignItems: 'center',
      gap: responsive.spacing(theme.spacing.s),
      marginBottom: responsive.spacing(theme.spacing.m),
      width: '100%',
      paddingHorizontal: responsive.spacing(theme.spacing.m),
    },
    closeButton: {
      alignSelf: 'center',
      borderRadius: theme.roundness,
      backgroundColor: theme.colors.surfaceVariant,
      minWidth: responsive.isTablet ? 150 : 100,
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      marginBottom: responsive.spacing(theme.spacing.l),
    },
    loadingContainer: {
      justifyContent: 'center',
      alignItems: 'center',
      minHeight: 300,
      flex: 1,
    },
    actionButton: {
      borderRadius: theme.roundness,
      paddingHorizontal: responsive.spacing(theme.spacing.s),
      flex: 1,
      maxWidth: responsive.isTablet ? 180 : '48%',
      minHeight: responsive.isTablet ? 48 : 40,
      minWidth: 100,
    },
    buttonContainer: {
      backgroundColor: theme.colors.surface,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.m),
      paddingBottom: responsive.spacing(theme.spacing.l),
    },
    closeIconButton: {
      position: 'absolute',
      top: responsive.spacing(theme.spacing.xs),
      right: responsive.spacing(theme.spacing.xs),
      zIndex: 1,
    },
  });
};

function GenericDetailModal<TItem extends { id: string }>({
  visible,
  onDismiss,
  item,
  titleField,
  imageField,
  descriptionField,
  statusConfig,
  fieldsToDisplay = [],
  onEdit,
  onDelete,
  deleteConfirmation,
  isDeleting = false,
  editButtonLabel = 'Editar',
  deleteButtonLabel = 'Eliminar',
  closeButtonLabel = 'Cerrar',
  modalStyle,
  titleStyle,
  imageStyle,
  descriptionStyle,
  fieldLabelStyle,
  fieldValueStyle,
  actionsContainerStyle,
  showImage = false,
  children,
}: GenericDetailModalProps<TItem>) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = useMemo(
    () => getStyles(theme, responsive),
    [theme, responsive],
  );
  const imageSource = useMemo(() => {
    if (item && imageField && item.hasOwnProperty(imageField)) {
      const imageFieldValue = item[imageField];
      if (
        typeof imageFieldValue === 'object' &&
        imageFieldValue !== null &&
        'path' in imageFieldValue &&
        typeof imageFieldValue.path === 'string'
      ) {
        return imageFieldValue.path;
      } else if (typeof imageFieldValue === 'string') {
        return imageFieldValue;
      }
    }
    return null;
  }, [item, imageField]);

  const handleEdit = () => {
    if (onEdit && item) {
      onEdit(item);
    }
  };

  const handleDelete = () => {
    if (item) {
      if (deleteConfirmation) {
        deleteConfirmation.show(item.id);
      } else if (onDelete) {
        onDelete(item.id);
      }
    }
  };

  const renderContent = () => {
    if (!item) {
      return (
        <View style={styles.loadingContainer}>
          <ActivityIndicator animating={true} size="large" />
        </View>
      );
    }

    const title = String(item[titleField] ?? 'Detalle');
    const description =
      descriptionField && item.hasOwnProperty(descriptionField)
        ? String(item[descriptionField] ?? '')
        : null;

    let statusChip = null;
    if (statusConfig && item.hasOwnProperty(statusConfig.field)) {
      const { field, activeValue, activeLabel, inactiveLabel } = statusConfig;
      const isActive = item[field] === activeValue;
      statusChip = (
        <View style={styles.statusChipContainer}>
          <Chip
            mode="flat"
            selectedColor={
              isActive ? theme.colors.success : theme.colors.onSurfaceVariant
            }
            style={[
              styles.statusChip,
              {
                backgroundColor: isActive
                  ? theme.colors.successContainer
                  : theme.colors.surfaceVariant,
              },
            ]}
          >
            {isActive ? activeLabel : inactiveLabel}
          </Chip>
        </View>
      );
    }

    return (
      <>
        <IconButton
          icon="close"
          size={24}
          style={styles.closeIconButton}
          onPress={onDismiss}
          mode="contained-tonal"
        />
        <Text variant="headlineSmall" style={[styles.modalTitle, titleStyle]}>
          {title}
        </Text>
        <View style={styles.detailContent}>
          {showImage && (
            <AutoImage
              source={imageSource}
              placeholderIcon="image-outline"
              style={[styles.detailImage, imageStyle]}
              contentFit="contain"
              transition={300}
            />
          )}
          {statusChip}
          {description && (
            <Text
              style={[styles.detailDescription, descriptionStyle]}
              numberOfLines={4}
              ellipsizeMode="tail"
            >
              {description}
            </Text>
          )}
        </View>

        {fieldsToDisplay.length > 0 && (
          <View style={styles.fieldsContainer}>
            {fieldsToDisplay.map(({ field, label, render }, index) => {
              if (!item || !item.hasOwnProperty(field)) return null;
              const value = item[field];
              const isLastItem = index === fieldsToDisplay.length - 1;

              return (
                <View
                  key={String(field)}
                  style={[styles.fieldRow, isLastItem && styles.lastFieldRow]}
                >
                  <Text style={[styles.fieldLabel, fieldLabelStyle]}>
                    {label}
                  </Text>
                  {render ? (
                    <View
                      style={{
                        flex: 1,
                        flexDirection: 'row',
                        justifyContent: 'flex-end',
                      }}
                    >
                      {(() => {
                        const rendered = render(value, item);
                        // Si el render devuelve un string o n√∫mero, lo envolvemos en Text
                        if (
                          typeof rendered === 'string' ||
                          typeof rendered === 'number'
                        ) {
                          return (
                            <Text
                              style={[styles.fieldValue, fieldValueStyle]}
                              numberOfLines={3}
                              ellipsizeMode="tail"
                            >
                              {rendered}
                            </Text>
                          );
                        }
                        // Si ya es un elemento React, lo devolvemos tal cual
                        return rendered;
                      })()}
                    </View>
                  ) : (
                    <Text
                      style={[styles.fieldValue, fieldValueStyle]}
                      numberOfLines={3}
                      ellipsizeMode="tail"
                    >
                      {typeof value === 'boolean'
                        ? value
                          ? 'S√≠'
                          : 'No'
                        : String(value ?? 'N/A')}
                    </Text>
                  )}
                </View>
              );
            })}
          </View>
        )}

        {children}
      </>
    );
  };

  const renderFooter = () => {
    if (!item) return null;

    return (
      <>
        {(onEdit || onDelete) && (
          <View style={[styles.detailActions, actionsContainerStyle]}>
            {onEdit && (
              <Button
                icon="pencil"
                mode="contained-tonal"
                onPress={handleEdit}
                disabled={isDeleting}
                style={styles.actionButton}
                buttonColor={theme.colors.secondaryContainer}
                textColor={theme.colors.onSecondaryContainer}
                contentStyle={{ flexDirection: 'row' }}
                labelStyle={{ fontSize: responsive.isTablet ? 13 : 12 }}
                compact={!responsive.isTablet}
              >
                {editButtonLabel}
              </Button>
            )}
            {onDelete && (
              <Button
                icon="delete"
                mode="contained-tonal"
                buttonColor={theme.colors.errorContainer}
                textColor={theme.colors.error}
                onPress={handleDelete}
                loading={isDeleting}
                disabled={isDeleting}
                style={styles.actionButton}
                contentStyle={{ flexDirection: 'row' }}
                labelStyle={{ fontSize: responsive.isTablet ? 13 : 12 }}
                compact={!responsive.isTablet}
              >
                {deleteButtonLabel}
              </Button>
            )}
          </View>
        )}

        <Button
          mode="contained-tonal"
          onPress={onDismiss}
          style={styles.closeButton}
          disabled={isDeleting}
          buttonColor={theme.colors.surfaceVariant}
          textColor={theme.colors.onSurfaceVariant}
          labelStyle={{ fontSize: responsive.isTablet ? 14 : 13 }}
          contentStyle={{
            paddingHorizontal: responsive.spacing(theme.spacing.s),
          }}
        >
          {closeButtonLabel}
        </Button>
      </>
    );
  };

  return (
    <>
      <ResponsiveModal
        visible={visible}
        onDismiss={onDismiss}
        dismissable={!isDeleting}
        dismissableBackButton={!isDeleting}
        scrollable={true}
        maxWidth={responsive.isTablet ? 480 : 400}
        maxHeight={'85%'}
        footer={renderFooter()}
        stickyFooter={true}
        contentContainerStyle={[styles.modalSurface, modalStyle]}
      >
        {renderContent()}
      </ResponsiveModal>

      {deleteConfirmation && (
        <ConfirmationModal
          visible={deleteConfirmation.visible}
          title={deleteConfirmation.title}
          message={deleteConfirmation.message}
          onConfirm={deleteConfirmation.onConfirm}
          onCancel={deleteConfirmation.onCancel}
          confirmText="Eliminar"
          cancelText="Cancelar"
          confirmButtonColor={theme.colors.error}
        />
      )}
    </>
  );
}

export default GenericDetailModal;

================
File: app/src/modules/orderFinalization/components/OrderDetailsModal.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';
import {
  Modal,
  Portal,
  Surface,
  Text,
  Divider,
  IconButton,
  Chip,
  ActivityIndicator,
} from 'react-native-paper';
import {
  OrderForFinalization,
  OrderItemForFinalization,
} from '../types/orderFinalization.types';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import {
  CustomizationType,
  PizzaHalf,
  CustomizationAction,
} from '@/modules/pizzaCustomizations/types/pizzaCustomization.types';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';

interface OrderDetailsModalProps {
  visible: boolean;
  onDismiss: () => void;
  order: OrderForFinalization | null;
  isLoading?: boolean;
  onPrintPress: (order: OrderForFinalization) => void;
}

const formatPizzaCustomizations = (customizations: any[]): string => {
  if (!customizations || customizations.length === 0) return '';

  const groupedByHalf = customizations.reduce(
    (acc, curr) => {
      const half =
        curr.half === PizzaHalf.HALF_1
          ? 'HALF_1'
          : curr.half === PizzaHalf.HALF_2
            ? 'HALF_2'
            : 'FULL';

      if (!acc[half]) {
        acc[half] = {
          flavors: [],
          addedIngredients: [],
          removedIngredients: [],
        };
      }

      const name = curr.pizzaCustomization?.name || curr.pizzaCustomizationId;
      const type = curr.pizzaCustomization?.type;

      if (type === 'FLAVOR' || type === CustomizationType.FLAVOR) {
        acc[half].flavors.push(name);
      } else if (
        type === 'INGREDIENT' ||
        type === CustomizationType.INGREDIENT
      ) {
        if (curr.action === CustomizationAction.ADD) {
          acc[half].addedIngredients.push(name);
        } else {
          acc[half].removedIngredients.push(name);
        }
      }

      return acc;
    },
    {} as Record<
      string,
      {
        flavors: string[];
        addedIngredients: string[];
        removedIngredients: string[];
      }
    >,
  );

  if (groupedByHalf.FULL) {
    const parts: string[] = [];
    if (groupedByHalf.FULL.flavors.length > 0) {
      parts.push(groupedByHalf.FULL.flavors.join(', '));
    }
    if (groupedByHalf.FULL.addedIngredients.length > 0) {
      parts.push(`con: ${groupedByHalf.FULL.addedIngredients.join(', ')}`);
    }
    if (groupedByHalf.FULL.removedIngredients.length > 0) {
      parts.push(`sin: ${groupedByHalf.FULL.removedIngredients.join(', ')}`);
    }
    return parts.join(' - ');
  } else if (groupedByHalf.HALF_1 || groupedByHalf.HALF_2) {
    const formatHalf = (halfData: {
      flavors: string[];
      addedIngredients: string[];
      removedIngredients: string[];
    }) => {
      const parts: string[] = [];
      if (halfData.flavors.length > 0) {
        parts.push(halfData.flavors.join(', '));
      }
      if (halfData.addedIngredients.length > 0) {
        parts.push(`con: ${halfData.addedIngredients.join(', ')}`);
      }
      if (halfData.removedIngredients.length > 0) {
        parts.push(`sin: ${halfData.removedIngredients.join(', ')}`);
      }
      return parts.join(' - ');
    };

    const half1 = groupedByHalf.HALF_1 ? formatHalf(groupedByHalf.HALF_1) : '';
    const half2 = groupedByHalf.HALF_2 ? formatHalf(groupedByHalf.HALF_2) : '';

    return half1 && half2 ? `(${half1} / ${half2})` : half1 || half2;
  }

  return '';
};

export const OrderDetailsModal: React.FC<OrderDetailsModalProps> = ({
  visible,
  onDismiss,
  order,
  isLoading = false,
  onPrintPress,
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const [showPrintHistory, setShowPrintHistory] = useState(false);

  if (!order && !isLoading) return null;

  const getOrderTypeLabel = (type: string) => {
    switch (type) {
      case 'DINE_IN':
        return 'üçΩÔ∏è Local';
      case 'TAKE_AWAY':
        return 'ü•° Llevar';
      case 'DELIVERY':
        return 'üöö Env√≠o';
      default:
        return type;
    }
  };

  const getOrderStatusLabel = (status: string) => {
    switch (status) {
      case 'PENDING':
        return 'Pendiente';
      case 'IN_PROGRESS':
        return 'En preparaci√≥n';
      case 'READY':
        return 'Listo';
      case 'DELIVERED':
        return 'Entregado';
      default:
        return status;
    }
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'PENDING':
        return '#FFA726';
      case 'IN_PROGRESS':
        return theme.colors.primary;
      case 'READY':
        return '#66BB6A';
      case 'DELIVERED':
        return '#9C27B0'; // Purple - better contrast
      default:
        return theme.colors.onSurfaceVariant;
    }
  };

  const getPaymentStatus = () => {
    if (order?.payments && order.payments.length > 0) {
      const totalPaid = order.payments.reduce((sum, p) => sum + p.amount, 0);
      const totalAmount =
        typeof order.total === 'string' ? parseFloat(order.total) : order.total;

      if (totalPaid >= totalAmount) {
        return { label: 'Pagado', color: '#10B981' };
      } else if (totalPaid > 0) {
        return { label: 'Parcial', color: '#F59E0B' };
      }
    }
    return { label: 'Pendiente', color: '#EF4444' };
  };

  const paymentStatus = order
    ? getPaymentStatus()
    : { label: 'Pendiente', color: '#EF4444' };

  const renderItem = (item: OrderItemForFinalization) => {
    const unitPrice = parseFloat(item.finalPrice);
    const totalPrice = unitPrice * item.quantity;
    const preparationStatusColors = {
      PENDING: '#FFA726',
      IN_PROGRESS: '#42A5F5',
      READY: '#66BB6A',
      DELIVERED: '#26A69A',
      CANCELLED: '#EF5350',
    };
    const statusColor =
      preparationStatusColors[
        item.preparationStatus as keyof typeof preparationStatusColors
      ] || theme.colors.onSurfaceVariant;

    return (
      <Surface
        key={`${item.product.id}-${item.productVariant?.id || ''}-${item.preparationStatus || ''}`}
        style={[
          styles.itemCard,
          { backgroundColor: theme.colors.elevation.level1, marginBottom: 8 },
        ]}
        elevation={1}
      >
        <View style={styles.itemContent}>
          <View style={styles.itemHeader}>
            <View style={styles.nameContainer}>
              <Text
                style={[styles.itemQuantity, { color: theme.colors.primary }]}
              >
                {item.quantity}x
              </Text>
              <Text
                style={[styles.itemName, { color: theme.colors.onSurface }]}
                numberOfLines={1}
              >
                {item.productVariant?.name || item.product.name}
              </Text>
            </View>
            {item.preparationStatus && (
              <View
                style={[styles.statusChip, { backgroundColor: statusColor }]}
              >
                <Text style={styles.statusChipText}>
                  {item.preparationStatus === 'PENDING' && 'Pendiente'}
                  {item.preparationStatus === 'IN_PROGRESS' && 'Preparando'}
                  {item.preparationStatus === 'READY' && 'Listo'}
                  {item.preparationStatus === 'DELIVERED' && 'Entregado'}
                  {item.preparationStatus === 'CANCELLED' && 'Cancelado'}
                </Text>
              </View>
            )}
          </View>

          <View style={styles.itemDetailsContainer}>
            {item.selectedPizzaCustomizations &&
              item.selectedPizzaCustomizations.length > 0 && (
                <View style={styles.customizationContainer}>
                  <Text
                    style={[
                      styles.pizzaCustomizationText,
                      { color: theme.colors.onSurfaceVariant },
                    ]}
                  >
                    {formatPizzaCustomizations(
                      item.selectedPizzaCustomizations,
                    )}
                  </Text>
                </View>
              )}

            {item.modifiers && item.modifiers.length > 0 && (
              <View style={styles.modifiersContainer}>
                {item.modifiers.map((modifier) => (
                  <View key={modifier.id} style={styles.modifierRow}>
                    <Text
                      style={[
                        styles.modifierText,
                        { color: theme.colors.onSurfaceVariant },
                      ]}
                    >
                      ‚Ä¢ {modifier.name}
                    </Text>
                    {modifier.price && Number(modifier.price) > 0 && (
                      <Text
                        style={[
                          styles.modifierPrice,
                          { color: theme.colors.tertiary },
                        ]}
                      >
                        +${Number(modifier.price).toFixed(2)}
                      </Text>
                    )}
                  </View>
                ))}
              </View>
            )}

            {item.preparationNotes && (
              <View style={styles.notesContainer}>
                <Text
                  style={[
                    styles.notesText,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                  üìù {item.preparationNotes}
                </Text>
              </View>
            )}
          </View>

          <View style={styles.priceContainer}>
            <View style={styles.priceRow}>
              <Text
                style={[
                  styles.priceLabel,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                P. unitario:
              </Text>
              <Text
                style={[styles.priceValue, { color: theme.colors.onSurface }]}
              >
                ${unitPrice.toFixed(2)}
              </Text>
            </View>
            {item.quantity > 1 && (
              <View style={styles.priceRow}>
                <Text
                  style={[
                    styles.priceLabel,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                  Total √ó{item.quantity}:
                </Text>
                <Text
                  style={[styles.totalPrice, { color: theme.colors.primary }]}
                >
                  ${totalPrice.toFixed(2)}
                </Text>
              </View>
            )}
          </View>
        </View>
      </Surface>
    );
  };

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={[
          styles.modalContent,
          { backgroundColor: theme.colors.background },
        ]}
      >
        {isLoading || !order ? (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
            <Text
              style={[
                styles.loadingText,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Cargando detalles de la orden...
            </Text>
          </View>
        ) : (
          <>
            <View style={styles.header}>
              <View style={styles.headerInfo}>
                <View style={styles.headerTopRow}>
                  <View style={styles.headerLeft}>
                    <Text
                      style={[styles.title, { color: theme.colors.onSurface }]}
                    >
                      Orden #{order?.shiftOrderNumber || ''}
                    </Text>
                    <Text
                      style={[
                        styles.headerSeparator,
                        { color: theme.colors.onSurfaceVariant },
                      ]}
                    >
                      ‚Ä¢
                    </Text>
                    <Text
                      style={[
                        styles.orderType,
                        { color: theme.colors.primary },
                      ]}
                    >
                      {order ? getOrderTypeLabel(order.orderType) : ''}
                    </Text>
                    <Text
                      style={[
                        styles.headerSeparator,
                        { color: theme.colors.onSurfaceVariant },
                      ]}
                    >
                      ‚Ä¢
                    </Text>
                    <Text
                      style={[
                        styles.headerDate,
                        { color: theme.colors.onSurfaceVariant },
                      ]}
                    >
                      {order?.createdAt
                        ? format(new Date(order.createdAt), 'dd/MM HH:mm', {
                            locale: es,
                          })
                        : ''}
                    </Text>
                  </View>
                  <View style={styles.headerActions}>
                    <IconButton
                      icon="close"
                      size={24}
                      onPress={onDismiss}
                      style={styles.closeButton}
                    />
                  </View>
                </View>
                <View style={styles.headerBottomRow}>
                  <View style={styles.chipsRow}>
                    <View
                      style={[
                        styles.headerStatusChip,
                        {
                          backgroundColor: order
                            ? getStatusColor(order.orderStatus, theme)
                            : theme.colors.surfaceVariant,
                        },
                      ]}
                    >
                      <Text style={styles.headerStatusChipText}>
                        {order ? getOrderStatusLabel(order.orderStatus) : ''}
                      </Text>
                    </View>
                    {order?.preparationScreens &&
                      order.preparationScreens.map((screen, index) => (
                        <Chip
                          key={index}
                          mode="outlined"
                          compact
                          style={styles.screenChip}
                          textStyle={styles.screenChipText}
                        >
                          üç≥ {screen}
                        </Chip>
                      ))}
                  </View>
                </View>
              </View>
            </View>

            <ScrollView
              style={styles.scrollView}
              showsVerticalScrollIndicator={false}
              contentContainerStyle={styles.scrollContent}
            >
              <View style={styles.infoSection}>
                {order?.deliveryInfo?.recipientName && (
                  <View style={styles.infoRow}>
                    <Text
                      style={[
                        styles.contactText,
                        { color: theme.colors.onSurface },
                      ]}
                    >
                      üë§ Nombre del Cliente: {order.deliveryInfo.recipientName}
                    </Text>
                  </View>
                )}

                {order?.deliveryInfo?.recipientPhone && (
                  <View style={styles.infoRow}>
                    <Text
                      style={[
                        styles.contactText,
                        { color: theme.colors.onSurface },
                      ]}
                    >
                      üìû Tel√©fono: {order.deliveryInfo.recipientPhone}
                    </Text>
                  </View>
                )}

                {order?.orderType === 'DELIVERY' &&
                  order?.deliveryInfo?.fullAddress && (
                    <View style={styles.infoRow}>
                      <Text
                        style={[
                          styles.addressText,
                          { color: theme.colors.onSurfaceVariant },
                        ]}
                      >
                        üì¶ Direcci√≥n de Entrega:{' '}
                        {order.deliveryInfo.fullAddress}
                      </Text>
                    </View>
                  )}

                {order?.orderType === 'DINE_IN' && order?.table && (
                  <View style={styles.infoRow}>
                    <Text
                      style={[
                        styles.tableText,
                        { color: theme.colors.onSurface },
                      ]}
                    >
                      üèõÔ∏è Mesa: {order.table.area?.name || 'Sin √°rea'} -{' '}
                      {order.table.number}
                    </Text>
                  </View>
                )}

                {order?.scheduledAt && (
                  <View style={styles.infoRow}>
                    <Text
                      style={[
                        styles.contactText,
                        { color: theme.colors.primary, fontWeight: '600' },
                      ]}
                    >
                      ‚è∞ Hora de Entrega Programada:{' '}
                      {format(new Date(order.scheduledAt), 'HH:mm', {
                        locale: es,
                      })}
                    </Text>
                  </View>
                )}
              </View>

              <Divider style={styles.divider} />

              <View style={styles.itemsList}>
                {order?.orderItems?.map((item) => renderItem(item)) || []}
              </View>

              <Divider style={styles.divider} />

              {order?.payments && order.payments.length > 0 && (
                <>
                  <View style={styles.paymentsSection}>
                    <View style={styles.paymentSummaryCompact}>
                      <View style={styles.summaryCompactRow}>
                        <Text
                          style={[
                            styles.summaryCompactLabel,
                            { color: theme.colors.onSurfaceVariant },
                          ]}
                        >
                          Total: $
                          {typeof order.total === 'string'
                            ? parseFloat(order.total).toFixed(2)
                            : order.total.toFixed(2)}
                        </Text>
                        <Text
                          style={[
                            styles.summaryCompactLabel,
                            { color: '#10B981' },
                          ]}
                        >
                          Pagado: $
                          {order.payments
                            .reduce((sum, p) => sum + p.amount, 0)
                            .toFixed(2)}
                        </Text>
                        {(() => {
                          const totalOrder =
                            typeof order.total === 'string'
                              ? parseFloat(order.total)
                              : order.total;
                          const totalPaid = order.payments.reduce(
                            (sum, p) => sum + p.amount,
                            0,
                          );
                          const remaining = totalOrder - totalPaid;
                          if (remaining > 0) {
                            return (
                              <Text
                                style={[
                                  styles.summaryCompactLabel,
                                  {
                                    color: theme.colors.error,
                                    fontWeight: '600',
                                  },
                                ]}
                              >
                                Resta: ${remaining.toFixed(2)}
                              </Text>
                            );
                          }
                          return null;
                        })()}
                      </View>
                    </View>

                    {order.payments.map((payment, index) => {
                      const getPaymentMethodLabel = (method: string) => {
                        switch (method) {
                          case 'CASH':
                            return 'Efectivo';
                          case 'CREDIT_CARD':
                            return 'Tarjeta de Cr√©dito';
                          case 'DEBIT_CARD':
                            return 'Tarjeta de D√©bito';
                          case 'TRANSFER':
                            return 'Transferencia';
                          case 'OTHER':
                            return 'Otro';
                          default:
                            return method;
                        }
                      };

                      const getPaymentStatusColor = (status: string) => {
                        switch (status) {
                          case 'COMPLETED':
                            return '#10B981';
                          case 'PENDING':
                            return '#F59E0B';
                          case 'FAILED':
                            return theme.colors.error;
                          case 'REFUNDED':
                            return '#6B7280';
                          case 'CANCELLED':
                            return theme.colors.error;
                          default:
                            return theme.colors.onSurfaceVariant;
                        }
                      };

                      const getPaymentStatusLabel = (status: string) => {
                        switch (status) {
                          case 'COMPLETED':
                            return 'Completado';
                          case 'PENDING':
                            return 'Pendiente';
                          case 'FAILED':
                            return 'Fallido';
                          case 'REFUNDED':
                            return 'Reembolsado';
                          case 'CANCELLED':
                            return 'Cancelado';
                          default:
                            return status;
                        }
                      };

                      return (
                        <View
                          key={payment.id || index}
                          style={styles.paymentRowCompact}
                        >
                          <Text
                            style={[
                              styles.paymentMethodCompact,
                              { color: theme.colors.onSurface },
                            ]}
                          >
                            üí≥ {getPaymentMethodLabel(payment.paymentMethod)}
                          </Text>
                          <Text
                            style={[
                              styles.paymentDateCompact,
                              { color: theme.colors.onSurfaceVariant },
                            ]}
                          >
                            {format(new Date(payment.createdAt), 'HH:mm', {
                              locale: es,
                            })}
                          </Text>
                          <View
                            style={[
                              styles.paymentStatusBadgeCompact,
                              {
                                backgroundColor:
                                  getPaymentStatusColor(payment.paymentStatus) +
                                  '20',
                              },
                            ]}
                          >
                            <Text
                              style={[
                                styles.paymentStatusTextCompact,
                                {
                                  color: getPaymentStatusColor(
                                    payment.paymentStatus,
                                  ),
                                },
                              ]}
                            >
                              {getPaymentStatusLabel(payment.paymentStatus)}
                            </Text>
                          </View>
                          <Text
                            style={[
                              styles.paymentAmountCompact,
                              { color: theme.colors.primary },
                            ]}
                          >
                            ${payment.amount.toFixed(2)}
                          </Text>
                        </View>
                      );
                    })}
                  </View>
                  <Divider style={styles.divider} />
                </>
              )}

              {order?.ticketImpressions &&
                order.ticketImpressions.length > 0 && (
                  <>
                    <View style={styles.ticketImpressionsSection}>
                      <TouchableOpacity
                        style={styles.collapsibleHeader}
                        onPress={() => setShowPrintHistory(!showPrintHistory)}
                        activeOpacity={0.7}
                      >
                        <Text
                          style={[
                            styles.sectionTitle,
                            { color: theme.colors.primary },
                          ]}
                        >
                          üñ®Ô∏è Historial de Impresiones (
                          {order.ticketImpressions.length})
                        </Text>
                        <IconButton
                          icon={
                            showPrintHistory ? 'chevron-up' : 'chevron-down'
                          }
                          size={20}
                          style={styles.collapseIcon}
                        />
                      </TouchableOpacity>

                      {showPrintHistory && (
                        <View style={styles.collapsibleContent}>
                          {order.ticketImpressions.map((impression, index) => {
                            const getTicketTypeLabel = (type: string) => {
                              switch (type) {
                                case 'KITCHEN':
                                  return 'üç≥ Cocina';
                                case 'BAR':
                                  return 'üç∫ Barra';
                                case 'BILLING':
                                  return 'üíµ Cuenta';
                                case 'CUSTOMER_COPY':
                                  return 'üìÑ Copia Cliente';
                                case 'GENERAL':
                                  return 'üìã General';
                                default:
                                  return type;
                              }
                            };

                            return (
                              <View
                                key={impression.id || index}
                                style={styles.impressionRow}
                              >
                                <View style={styles.impressionLeft}>
                                  <Text
                                    style={[
                                      styles.impressionType,
                                      { color: theme.colors.onSurface },
                                    ]}
                                  >
                                    {getTicketTypeLabel(impression.ticketType)}
                                  </Text>
                                  <View style={styles.impressionDetails}>
                                    {impression.user && (
                                      <Text
                                        style={[
                                          styles.impressionUser,
                                          {
                                            color:
                                              theme.colors.onSurfaceVariant,
                                          },
                                        ]}
                                      >
                                        por {impression.user.firstName || ''}{' '}
                                        {impression.user.lastName || ''}
                                      </Text>
                                    )}
                                    {impression.printer && (
                                      <Text
                                        style={[
                                          styles.impressionPrinter,
                                          {
                                            color:
                                              theme.colors.onSurfaceVariant,
                                          },
                                        ]}
                                      >
                                        üñ®Ô∏è {impression.printer.name}
                                      </Text>
                                    )}
                                  </View>
                                </View>
                                <Text
                                  style={[
                                    styles.impressionTime,
                                    { color: theme.colors.onSurfaceVariant },
                                  ]}
                                >
                                  {format(
                                    new Date(impression.impressionTime),
                                    'HH:mm:ss',
                                    { locale: es },
                                  )}
                                </Text>
                              </View>
                            );
                          })}
                        </View>
                      )}
                    </View>
                  </>
                )}
            </ScrollView>

            <Divider style={styles.divider} />

            <View style={styles.footer}>
              <View style={styles.footerLeft}>
                <Text
                  style={[
                    styles.totalLabel,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                  Por pagar:
                </Text>
                <Text
                  style={[
                    styles.totalAmount,
                    {
                      color: (() => {
                        const totalOrder =
                          typeof order.total === 'string'
                            ? parseFloat(order.total)
                            : order.total;
                        const totalPaid =
                          order.payments?.reduce(
                            (sum, p) => sum + p.amount,
                            0,
                          ) || 0;
                        const remaining = totalOrder - totalPaid;
                        return remaining > 0 ? theme.colors.error : '#10B981';
                      })(),
                    },
                  ]}
                >
                  $
                  {(() => {
                    if (!order) return '0.00';
                    const totalOrder =
                      typeof order.total === 'string'
                        ? parseFloat(order.total)
                        : order.total;
                    const totalPaid =
                      order.payments?.reduce((sum, p) => sum + p.amount, 0) ||
                      0;
                    const remaining = totalOrder - totalPaid;
                    return remaining > 0 ? remaining.toFixed(2) : '0.00';
                  })()}
                </Text>
              </View>
              <View
                style={[
                  styles.paymentBadge,
                  { backgroundColor: paymentStatus.color },
                ]}
              >
                <Text style={styles.paymentBadgeText}>
                  üíµ {paymentStatus.label}
                </Text>
              </View>
            </View>
          </>
        )}
      </Modal>
    </Portal>
  );
};

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    modalContent: {
      margin: 12,
      borderRadius: 12,
      maxHeight: '90%',
      elevation: 4,
      overflow: 'hidden',
    },
    header: {
      paddingHorizontal: 16,
      paddingTop: 10,
      paddingBottom: 6,
    },
    headerTopRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 6,
    },
    headerLeft: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      flexWrap: 'wrap',
    },
    headerBottomRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    chipsRow: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      gap: 6,
      flexWrap: 'wrap',
    },
    headerSeparator: {
      fontSize: responsive.fontSize(11),
      marginHorizontal: 6,
    },
    orderType: {
      fontSize: responsive.fontSize(12),
      fontWeight: '600',
    },
    headerDate: {
      fontSize: responsive.fontSize(11),
    },
    infoSection: {
      paddingHorizontal: 16,
      paddingTop: 4,
      paddingBottom: 6,
      gap: 4,
    },
    infoRow: {
      marginVertical: 2,
    },
    contactText: {
      fontSize: responsive.fontSize(12),
    },
    addressText: {
      fontSize: responsive.fontSize(12),
      lineHeight: 16,
    },
    tableText: {
      fontSize: responsive.fontSize(12),
    },
    screenChip: {
      height: 20,
    },
    screenChipText: {
      fontSize: responsive.fontSize(10),
      marginVertical: -2,
    },
    paymentBadge: {
      paddingHorizontal: 10,
      paddingVertical: 4,
      borderRadius: 12,
    },
    paymentBadgeText: {
      color: 'white',
      fontSize: responsive.fontSize(12),
      fontWeight: '600',
    },
    totalAmount: {
      fontSize: responsive.fontSize(16),
      fontWeight: '700',
    },
    footer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingHorizontal: 16,
      paddingVertical: 12,
      borderTopWidth: 1,
      borderTopColor: 'rgba(0,0,0,0.08)',
      backgroundColor: 'inherit',
    },
    footerLeft: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 8,
    },
    totalLabel: {
      fontSize: responsive.fontSize(14),
      fontWeight: '600',
    },
    divider: {
      marginVertical: 2,
    },
    closeButton: {
      margin: -8,
    },
    headerActions: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 16,
    },
    headerStatusChip: {
      paddingHorizontal: 8,
      paddingVertical: 2,
      borderRadius: 10,
    },
    headerStatusChipText: {
      color: 'white',
      fontSize: responsive.fontSize(11),
      fontWeight: '600',
    },
    title: {
      fontSize: responsive.fontSize(20),
      fontWeight: '700',
    },
    scrollView: {
      flexGrow: 0,
      flexShrink: 1,
      maxHeight: '70%',
    },
    scrollContent: {
      paddingBottom: 8,
    },
    itemsList: {
      padding: 12,
      paddingBottom: 16,
    },
    itemCard: {
      borderRadius: 8,
      overflow: 'hidden',
    },
    itemContent: {
      padding: 10,
    },
    itemHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 6,
    },
    nameContainer: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      marginRight: 8,
    },
    itemQuantity: {
      fontSize: responsive.fontSize(14),
      fontWeight: '700',
      marginRight: 6,
    },
    itemName: {
      fontSize: responsive.fontSize(13),
      fontWeight: '600',
      flex: 1,
      lineHeight: 16,
    },
    statusChip: {
      paddingHorizontal: 8,
      paddingVertical: 2,
      borderRadius: 12,
    },
    statusChipText: {
      color: 'white',
      fontSize: responsive.fontSize(10),
      fontWeight: '600',
    },
    itemDetailsContainer: {
      marginBottom: 6,
    },
    customizationContainer: {
      marginBottom: 4,
    },
    pizzaCustomizationText: {
      fontSize: responsive.fontSize(11),
      fontStyle: 'italic',
      lineHeight: 14,
    },
    modifiersContainer: {
      marginTop: 2,
    },
    modifierRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 1,
    },
    modifierText: {
      fontSize: responsive.fontSize(11),
      flex: 1,
      lineHeight: 14,
    },
    modifierPrice: {
      fontSize: responsive.fontSize(11),
      fontWeight: '500',
      marginLeft: 4,
    },
    notesContainer: {
      marginTop: 4,
      paddingTop: 4,
      borderTopWidth: 1,
      borderTopColor: 'rgba(0,0,0,0.06)',
    },
    notesText: {
      fontSize: responsive.fontSize(11),
      fontStyle: 'italic',
      lineHeight: 14,
    },
    priceContainer: {
      marginTop: 6,
      paddingTop: 6,
      borderTopWidth: 1,
      borderTopColor: 'rgba(0,0,0,0.06)',
    },
    priceRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 2,
    },
    priceLabel: {
      fontSize: responsive.fontSize(11),
      opacity: 0.7,
    },
    priceValue: {
      fontSize: responsive.fontSize(12),
      fontWeight: '600',
    },
    totalPrice: {
      fontSize: responsive.fontSize(14),
      fontWeight: '700',
    },
    paymentsSection: {
      paddingHorizontal: 16,
      paddingVertical: 8,
    },
    paymentSummaryCompact: {
      marginBottom: 8,
    },
    summaryCompactRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    summaryCompactLabel: {
      fontSize: responsive.fontSize(12),
      fontWeight: '500',
    },
    paymentRowCompact: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: 6,
      gap: 8,
    },
    paymentMethodCompact: {
      fontSize: responsive.fontSize(11),
      fontWeight: '500',
      flex: 1,
    },
    paymentDateCompact: {
      fontSize: responsive.fontSize(10),
    },
    paymentAmountCompact: {
      fontSize: responsive.fontSize(12),
      fontWeight: '600',
      minWidth: 50,
      textAlign: 'right',
    },
    paymentStatusBadgeCompact: {
      paddingHorizontal: 6,
      paddingVertical: 1,
      borderRadius: 10,
    },
    paymentStatusTextCompact: {
      fontSize: responsive.fontSize(9),
      fontWeight: '600',
    },
    ticketImpressionsSection: {
      paddingHorizontal: 16,
      paddingVertical: 8,
    },
    collapsibleHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingRight: 4,
    },
    collapseIcon: {
      margin: -8,
    },
    collapsibleContent: {
      marginTop: 8,
    },
    sectionTitle: {
      fontSize: responsive.fontSize(14),
      fontWeight: '600',
      marginBottom: 0,
    },
    impressionRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 8,
      paddingLeft: 8,
    },
    impressionLeft: {
      flex: 1,
      gap: 2,
    },
    impressionType: {
      fontSize: responsive.fontSize(12),
      fontWeight: '500',
    },
    impressionDetails: {
      gap: 2,
    },
    impressionUser: {
      fontSize: responsive.fontSize(11),
      opacity: 0.7,
    },
    impressionPrinter: {
      fontSize: responsive.fontSize(11),
      opacity: 0.7,
      fontStyle: 'italic',
    },
    impressionTime: {
      fontSize: responsive.fontSize(11),
      opacity: 0.7,
    },
    loadingContainer: {
      minHeight: 200,
      justifyContent: 'center',
      alignItems: 'center',
      paddingVertical: 40,
    },
    loadingText: {
      marginTop: 16,
      fontSize: responsive.fontSize(14),
    },
  });

export default OrderDetailsModal;

================
File: app/src/modules/orderFinalization/types/orderFinalization.types.ts
================
import type { DeliveryInfo } from '../../../app/schemas/domain/delivery-info.schema';

// Tipo ligero para la lista de √≥rdenes (optimizado)
export interface OrderForFinalizationList {
  id: string;
  shiftOrderNumber: number;
  orderType: 'TAKE_AWAY' | 'DELIVERY' | 'DINE_IN';
  orderStatus:
    | 'PENDING'
    | 'IN_PROGRESS'
    | 'READY'
    | 'DELIVERED'
    | 'COMPLETED'
    | 'CANCELLED';
  total: string | number;
  createdAt: string;
  scheduledAt?: string;
  paymentsSummary?: {
    totalPaid: number;
  };
  deliveryInfo?: {
    recipientName?: string;
    recipientPhone?: string;
    fullAddress?: string;
  };
  preparationScreens?: string[];
  preparationScreenStatuses?: Array<{
    name: string;
    status: 'PENDING' | 'IN_PROGRESS' | 'READY';
  }>;
  ticketImpressionCount?: number;
  notes?: string;
  table?: {
    number: string;
    name: string;
    isTemporary: boolean;
    area?: {
      name: string;
    };
  };
  createdBy?: {
    username: string;
    firstName?: string | null;
    lastName?: string | null;
  };
  isFromWhatsApp?: boolean;
}

// Tipo completo para el detalle de orden
export interface OrderForFinalization {
  id: string;
  shiftOrderNumber: number;
  deliveryInfo: DeliveryInfo;
  orderType: 'TAKE_AWAY' | 'DELIVERY' | 'DINE_IN';
  orderStatus:
    | 'PENDING'
    | 'IN_PROGRESS'
    | 'READY'
    | 'DELIVERED'
    | 'COMPLETED'
    | 'CANCELLED';
  total: string | number;
  orderItems: OrderItemForFinalization[];
  createdAt: string;
  updatedAt: string;
  scheduledAt?: string;
  tableId?: string;
  user?: {
    id: string;
    firstName?: string;
    lastName?: string;
  };
  table?: {
    id: string;
    number: string;
    area?: {
      name: string;
    };
  } | null;
  isFromWhatsApp?: boolean;
  preparationScreens?: string[];
  payments?: {
    id: string;
    amount: number;
    paymentMethod: string;
    paymentStatus: string;
    createdAt: string;
    updatedAt: string;
  }[];
  notes?: string;
  ticketImpressions?: {
    id: string;
    ticketType: string;
    impressionTime: string;
    user?: {
      id: string;
      firstName?: string;
      lastName?: string;
    };
    printer?: {
      id: string;
      name: string;
    };
  }[];
}

export interface OrderItemForFinalization {
  id: string;
  quantity: number;
  basePrice: string;
  finalPrice: string;
  preparationNotes?: string;
  preparationStatus?: string;
  product: {
    id: string;
    name: string;
    description?: string;
  };
  productVariant?: {
    id: string;
    name: string;
  } | null;
  modifiers: OrderItemModifierForFinalization[];
  selectedPizzaCustomizations?: any[];
}

export interface OrderItemModifierForFinalization {
  id: string;
  name: string;
  price: number | string;
}

export interface OrderSelectionState {
  selectedOrders: Set<string>;
  totalAmount: number;
}

export interface FinalizeOrdersPayload {
  orderIds: string[];
  paymentMethod?: string;
  notes?: string;
}

export type OrderFinalizationFilter = 'delivery' | 'take_away' | 'dine_in';

================
File: app/src/modules/orders/screens/CreateOrderScreen.tsx
================
import React, {
  useState,
  useMemo,
  useRef,
  useCallback,
  useEffect,
} from 'react';
import { StyleSheet, View, FlatList } from 'react-native';
import {
  Text,
  Portal,
  ActivityIndicator,
  Card,
  Title,
  Appbar,
  IconButton,
} from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useNavigation } from '@react-navigation/native';
import { useGetOrderMenu } from '../hooks/useMenuQueries';
import { useCreateOrderMutation } from '@/modules/orders/hooks/useOrdersQueries';
import { useCartStore, useIsCartEmpty, useCartItemsCount, useClearAll, CartItem, CartItemModifier } from '../stores/useCartStore';
import { useOrderFormStore } from '../stores/useOrderFormStore';
import { Product, Category, SubCategory } from '../types/orders.types';
import { AutoImage } from '@/app/components/common/AutoImage';
import { MaterialCommunityIcons } from '@expo/vector-icons';

import OrderCartDetail from '../components/OrderCartDetail';
import ProductCustomizationModal from '../components/ProductCustomizationModal';
import SimpleProductDescriptionModal from '../components/SimpleProductDescriptionModal';
import CartButton from '../components/CartButton';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { getApiErrorMessage } from '@/app/lib/errorMapping';
import { AudioRecorderWidget } from '@/components/AudioRecorderWidget';
import { AudioOrderModal } from '@/components/AudioOrderModal';
import {
  audioOrderService,
  type AIOrderItem,
} from '@/services/audioOrderService';
import { useAuthStore } from '@/app/store/authStore';
import { canOpenShift } from '@/app/utils/roleUtils';
import { useGlobalShift } from '@/app/hooks/useGlobalShift';

import { useAppTheme } from '@/app/styles/theme';
import type { OrderDetailsForBackend } from '../components/OrderCartDetail';
import type { SelectedPizzaCustomization } from '@/app/schemas/domain/order.schema';
import { useResponsive } from '@/app/hooks/useResponsive';

interface CartButtonHandle {
  animate: () => void;
}

const CreateOrderScreen = () => {
  const theme = useAppTheme();
  const { colors, fonts } = theme;
  const responsive = useResponsive();
  const navigation = useNavigation();
  const {
    addItem: originalAddItem,
    updateItem,
    isCartVisible,
    showCart,
    hideCart,
  } = useCartStore();
  
  const isCartEmpty = useIsCartEmpty();
  const totalItemsCount = useCartItemsCount();
  const clearAll = useClearAll();
  
  const { setOrderType, setDeliveryInfo } = useOrderFormStore();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const user = useAuthStore((state) => state.user);
  const { data: shift, isLoading: shiftLoading } = useGlobalShift();
  const userCanOpenShift = canOpenShift(user);

  const createOrderMutation = useCreateOrderMutation();

  const cartButtonRef = useRef<CartButtonHandle>(null);

  const [navigationLevel, setNavigationLevel] = useState<
    'categories' | 'subcategories' | 'products'
  >('categories');
  const [selectedCategoryId, setSelectedCategoryId] = useState<string | null>(
    null,
  );
  const [selectedSubcategoryId, setSelectedSubcategoryId] = useState<
    string | null
  >(null);
  const [selectedProduct, setSelectedProduct] = useState<Product | null>(null);
  const [editingItem, setEditingItem] = useState<CartItem | null>(null);
  const [showExitConfirmationModal, setShowExitConfirmationModal] =
    useState(false);
  const [pendingNavigationAction, setPendingNavigationAction] = useState<
    (() => void) | null
  >(null);
  const [isProcessingOrder, setIsProcessingOrder] = useState(false);
  const isProcessingOrderRef = useRef(false);
  const [selectedProductForDescription, setSelectedProductForDescription] =
    useState<Product | null>(null);
  const [isDescriptionModalVisible, setIsDescriptionModalVisible] =
    useState(false);

  // Estados para el widget de audio
  const [showAudioModal, setShowAudioModal] = useState(false);
  const [audioOrderData, setAudioOrderData] = useState<any>(null);
  const [isProcessingAudio, setIsProcessingAudio] = useState(false);
  const [audioError, setAudioError] = useState<string | undefined>();

  const { data: menu, isLoading } = useGetOrderMenu();

  // Calcular n√∫mero de columnas din√°micamente
  const numColumns = useMemo(() => {
    // Para tablets (ancho >= 600px)
    if (responsive.width >= 600) {
      if (responsive.width >= 1200) return 6; // Tablets muy grandes
      if (responsive.width >= 900) return 5; // Tablets grandes
      if (responsive.width >= 768) return 4; // Tablets medianas
      return 3; // Tablets peque√±as (600-768px)
    }
    // Para m√≥viles (ancho < 600px)
    if (responsive.width >= 480) return 3; // M√≥viles grandes
    if (responsive.width >= 360) return 2; // M√≥viles est√°ndar
    return 2; // M√≥viles peque√±os
  }, [responsive.width]);

  // Calcular ancho de items basado en columnas
  const itemWidth = useMemo(() => {
    const padding = responsive.spacing(theme.spacing.m);
    const totalPadding = padding * 2;
    const gap = responsive.spacing(8);
    const totalGaps = gap * (numColumns - 1);
    const availableWidth = responsive.width - totalPadding - totalGaps;
    return Math.floor(availableWidth / numColumns);
  }, [responsive.width, numColumns, theme.spacing.m, responsive]);

  const handleCategorySelect = useCallback((categoryId: string) => {
    setSelectedCategoryId(categoryId);
    setSelectedSubcategoryId(null);
    setNavigationLevel('subcategories');
  }, []);

  const handleSubCategorySelect = useCallback((subcategoryId: string) => {
    setSelectedSubcategoryId(subcategoryId);
    setNavigationLevel('products');
  }, []);

  const productNeedsCustomization = useCallback((product: Product): boolean => {
    if (!product) return false;
    const hasVariants =
      product.hasVariants &&
      product.variants &&
      Array.isArray(product.variants) &&
      product.variants.length > 0;
    const hasModifiers =
      product.modifierGroups &&
      Array.isArray(product.modifierGroups) &&
      product.modifierGroups.length > 0;
    return hasVariants || hasModifiers;
  }, []);

  const handleProductSelect = useCallback(
    (product: Product) => {
      if (productNeedsCustomization(product)) {
        setSelectedProduct(product);
      } else {
        handleAddItem(product, 1);
      }
    },
    [handleAddItem],
  );

  const handleCloseProductModal = useCallback(() => {
    setSelectedProduct(null);
    setEditingItem(null);
    // Si est√°bamos editando y hay items en el carrito, volver a mostrar el carrito
    if (editingItem && !isCartEmpty) {
      showCart();
    }
  }, [editingItem, isCartEmpty, showCart]);

  const handleEditItem = useCallback(
    (item: CartItem) => {
      // Encontrar el producto completo desde el men√∫
      if (!menu || !Array.isArray(menu)) {
        showSnackbar({
          message:
            'El men√∫ a√∫n se est√° cargando. Por favor, intenta nuevamente.',
          type: 'info',
        });
        return;
      }

      // Buscar el producto en la estructura anidada
      let product: Product | undefined;

      for (const category of menu) {
        if (category.subcategories && Array.isArray(category.subcategories)) {
          for (const subcategory of category.subcategories) {
            if (subcategory.products && Array.isArray(subcategory.products)) {
              product = subcategory.products.find(
                (p) => p.id === item.productId,
              );
              if (product) break;
            }
          }
        }
        if (product) break;
      }

      if (product) {
        setEditingItem(item);
        setSelectedProduct(product);
        hideCart(); // Cerrar el carrito para mostrar el modal de personalizaci√≥n
      } else {
        showSnackbar({
          message:
            'No se pudo encontrar el producto. Por favor, recarga la pantalla.',
          type: 'error',
        });
      }
    },
    [menu, showSnackbar, hideCart],
  );

  const handleGoBackInternal = () => {
    if (navigationLevel === 'products') {
      setNavigationLevel('subcategories');
      setSelectedSubcategoryId(null);
    } else if (navigationLevel === 'subcategories') {
      setNavigationLevel('categories');
      setSelectedCategoryId(null);
    }
  };

  const handleAttemptExit = (goBackAction: () => void) => {
    if (isCartEmpty) {
      goBackAction();
    } else {
      setPendingNavigationAction(() => goBackAction);
      setShowExitConfirmationModal(true);
    }
  };

  useEffect(() => {
    const unsubscribe = navigation.addListener('beforeRemove', (e) => {
      // Don't do anything if cart is empty, modal is already showing, or we're processing an order
      if (isCartEmpty || showExitConfirmationModal || isProcessingOrder) {
        return;
      }

      // Prevent default for any navigation away when cart has items
      // This includes back navigation and drawer navigation
      e.preventDefault();
      setPendingNavigationAction(
        () => () => navigation.dispatch(e.data.action),
      );
      setShowExitConfirmationModal(true);
    });

    return unsubscribe;
  }, [navigation, isCartEmpty, showExitConfirmationModal, isProcessingOrder]);

  const handleViewCart = useCallback(() => {
    showCart();
  }, [showCart]);

  const handleCloseCart = useCallback(() => {
    hideCart();
  }, [hideCart]);

  // Actualizar handleConfirmOrder para usar la mutaci√≥n
  const handleConfirmOrder = async (details: OrderDetailsForBackend) => {
    // Verificaci√≥n at√≥mica usando ref
    if (isProcessingOrderRef.current) return;
    isProcessingOrderRef.current = true;
    setIsProcessingOrder(true);

    try {
      // Llamar a la mutaci√≥n para enviar la orden al backend
      const createdOrder = await createOrderMutation.mutateAsync(details);

      // Usar 'shiftOrderNumber' que es lo que devuelve el backend
      showSnackbar({
        message: `Orden #${createdOrder.shiftOrderNumber} creada con √©xito`,
        type: 'success',
      });
      hideCart();
      clearAll(); // Limpiar carrito y formulario ANTES de navegar

      // Peque√±o delay para asegurar que el estado se actualice antes de navegar
      setTimeout(() => {
        navigation.goBack();
      }, 100);
    } catch (error) {
      // El manejo de errores con snackbar ya deber√≠a estar en el hook useCreateOrderMutation
      const message = getApiErrorMessage(error as Error);
      showSnackbar({
        message: `Error al crear orden: ${message}`,
        type: 'error',
      });
    } finally {
      setIsProcessingOrder(false);
      isProcessingOrderRef.current = false;
    }
  };

  const handleAddItem = (
    product: Product,
    quantity: number,
    selectedVariantId?: string,
    selectedModifiers?: CartItemModifier[],
    preparationNotes?: string,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost?: number,
  ) => {
    originalAddItem(
      product,
      quantity,
      selectedVariantId,
      selectedModifiers,
      preparationNotes,
      selectedPizzaCustomizations,
      pizzaExtraCost,
    );
    cartButtonRef.current?.animate();
  };

  // Handlers para el widget de audio
  const handleAudioRecordingComplete = useCallback(
    async (audioUri: string, transcription: string) => {
      setIsProcessingAudio(true);
      setShowAudioModal(true);
      setAudioError(undefined);

      try {
        const response = await audioOrderService.processAudioOrder(
          audioUri,
          transcription,
        );

        if (response.success && response.data) {
          setAudioOrderData(response.data);
        } else {
          setAudioError(response.error?.message || 'Error procesando la orden');
        }
      } catch (error) {
        setAudioError('Error al procesar la orden por voz');
      } finally {
        setIsProcessingAudio(false);
      }
    },
    [],
  );

  const handleAudioError = useCallback(
    (error: string) => {
      showSnackbar({
        message: error,
        type: 'error',
      });
    },
    [showSnackbar],
  );

  const handleConfirmAudioOrder = async (
    items: AIOrderItem[],
    deliveryInfo?: any,
    scheduledDelivery?: any,
    orderType?: 'DELIVERY' | 'TAKE_AWAY' | 'DINE_IN',
  ) => {
    // Procesamos los items detectados por voz y los agregamos al carrito
    try {
      if (!menu) {
        throw new Error('El men√∫ no est√° disponible');
      }

      let addedCount = 0;
      let failedCount = 0;

      // Procesar cada item detectado
      for (const item of items) {
        let foundProduct: Product | null = null;

        // Buscar el producto en el men√∫
        outer: for (const category of menu) {
          for (const subcategory of category.subcategories || []) {
            for (const product of subcategory.products || []) {
              if (product.id === item.productId) {
                foundProduct = product;
                break outer;
              }
            }
          }
        }

        if (foundProduct) {
          // Preparar modificadores
          const selectedModifiers: CartItemModifier[] = [];
          if (item.modifiers && item.modifiers.length > 0) {
            for (const modName of item.modifiers) {
              // Buscar el modificador en el producto
              for (const modGroup of foundProduct.modifierGroups || []) {
                const modifier = modGroup.productModifiers?.find(
                  (m) => m.name === modName,
                );
                if (modifier) {
                  selectedModifiers.push({
                    id: modifier.id,
                    modifierGroupId: modGroup.id,
                    name: modifier.name,
                    price: modifier.price || 0,
                  });
                  break;
                }
              }
            }
          }

          // Preparar personalizaciones de pizza
          const pizzaCustomizations = item.pizzaCustomizations?.map((pc) => ({
            pizzaCustomizationId: pc.customizationId,
            half: pc.half as any,
            action: pc.action as any,
          }));

          // Agregar al carrito
          handleAddItem(
            foundProduct,
            item.quantity,
            item.variantId,
            selectedModifiers,
            undefined, // preparationNotes
            pizzaCustomizations,
            0, // pizzaExtraCost (se calcular√° en el modal si es necesario)
          );

          addedCount++;
        } else {
          failedCount++;
        }
      }

      // Mostrar resultado
      if (addedCount > 0 && failedCount === 0) {
        showSnackbar({
          message: `Se agregaron ${addedCount} producto${addedCount > 1 ? 's' : ''} al carrito`,
          type: 'success',
        });
      } else if (addedCount > 0 && failedCount > 0) {
        showSnackbar({
          message: `Se agregaron ${addedCount} producto${addedCount > 1 ? 's' : ''}, ${failedCount} no se encontraron`,
          type: 'warning',
        });
      } else {
        showSnackbar({
          message: 'No se pudieron agregar los productos al carrito',
          type: 'error',
        });
      }

      // Si hay informaci√≥n de entrega, guardarla en el contexto del carrito
      if (deliveryInfo && Object.keys(deliveryInfo).length > 0) {
        setDeliveryInfo(deliveryInfo);
      }

      // Si se detect√≥ un tipo de orden, actualizarlo en el contexto del carrito

      if (orderType) {
        setOrderType(orderType);
      } else {
        // Order type not changed, keep current value
      }

      setShowAudioModal(false);
      setAudioOrderData(null);

      // Animar el bot√≥n del carrito si se agregaron productos
      if (addedCount > 0) {
        cartButtonRef.current?.animate();
      }
    } catch (error) {
      showSnackbar({
        message: 'Error al agregar los productos al carrito',
        type: 'error',
      });
    }
  };

  const getCategories = () => {
    if (!menu || !Array.isArray(menu)) return [];
    return menu;
  };

  const getSubcategories = () => {
    if (!selectedCategory || !Array.isArray(selectedCategory.subcategories))
      return [];
    return selectedCategory.subcategories;
  };

  const getProducts = () => {
    if (!selectedSubCategory || !Array.isArray(selectedSubCategory.products))
      return [];
    return selectedSubCategory.products;
  };

  const selectedCategory =
    menu && Array.isArray(menu)
      ? menu.find((cat: Category) => cat.id === selectedCategoryId)
      : null;

  const selectedSubCategory =
    selectedCategory && Array.isArray(selectedCategory.subcategories) // Corregido a lowercase
      ? selectedCategory.subcategories.find(
          // Corregido a lowercase
          (sub: SubCategory) => sub.id === selectedSubcategoryId,
        )
      : null;

  const getNavTitle = useCallback(() => {
    if (selectedProduct) {
      return selectedProduct.name;
    }
    switch (navigationLevel) {
      case 'categories':
        return 'Categor√≠as';
      case 'subcategories':
        return selectedCategory?.name
          ? `Categor√≠a: ${selectedCategory.name}`
          : 'Subcategor√≠as';
      case 'products':
        return selectedSubCategory?.name
          ? `Subcategor√≠a: ${selectedSubCategory.name}`
          : 'Productos';
      default:
        return 'Categor√≠as';
    }
  }, [navigationLevel, selectedCategory, selectedSubCategory, selectedProduct]);

  const styles = useMemo(
    () =>
      StyleSheet.create({
        safeArea: {
          flex: 1,
          backgroundColor: colors.background,
        },
        container: {
          flex: 1,
        },
        content: {
          flex: 1,
        },
        gridContainer: {
          padding: responsive.spacing(theme.spacing.m),
          paddingBottom: 60,
        },
        row: {
          justifyContent: 'flex-start',
          paddingHorizontal: 0,
          marginBottom: responsive.spacing(8),
          gap: responsive.spacing(8),
        },
        cardItem: {
          width: itemWidth,
          marginHorizontal: 0,
          marginVertical: 0,
          overflow: 'hidden',
          borderRadius: theme.roundness * 2,
          elevation: 2,
          backgroundColor: colors.surface,
          aspectRatio: 0.85,
        },
        cardItemInactive: {
          opacity: 0.5,
        },
        itemImage: {
          width: '100%',
          height: itemWidth * 0.65,
        },
        imageInactive: {
          opacity: 0.6,
        },
        cardContent: {
          paddingHorizontal: responsive.spacing(theme.spacing.s),
          paddingVertical: responsive.spacing(theme.spacing.xs),
          height: itemWidth * 0.35,
          justifyContent: 'center',
        },
        cardTitle: {
          fontSize: responsive.fontSize(responsive.width >= 600 ? 16 : 15),
          fontWeight: '600',
          lineHeight:
            responsive.fontSize(responsive.width >= 600 ? 16 : 15) * 1.2,
          marginBottom: responsive.spacing(2),
        },
        cardHeader: {
          flexDirection: 'row',
          justifyContent: 'space-between',
          alignItems: 'flex-start',
        },
        infoButton: {
          margin: -8,
          marginTop: -12,
          marginRight: -12,
        },
        priceText: {
          color: theme.colors.primary,
          fontWeight: '600',
          fontSize: responsive.fontSize(responsive.width >= 600 ? 14 : 13),
          marginTop: 2,
        },
        noItemsText: {
          textAlign: 'center',
          marginTop: 40,
          fontSize: 16,
          color: '#666',
        },
        loadingContainer: {
          flex: 1,
          justifyContent: 'center',
          alignItems: 'center',
        },
        appBar: {
          backgroundColor: colors.elevation.level2,
          alignItems: 'center',
        },
        appBarTitle: {
          ...fonts.titleMedium,
          color: colors.onSurface,
          fontWeight: 'bold',
          textAlign: 'center',
        },
        appBarContent: {},
        spacer: {
          width: 48,
        },
        inactiveBadge: {
          position: 'absolute',
          top: 8,
          right: 8,
          backgroundColor: colors.errorContainer,
          paddingHorizontal: 8,
          paddingVertical: 4,
          borderRadius: 4,
        },
        inactiveBadgeText: {
          fontSize: 12,
          color: colors.onErrorContainer,
          fontWeight: '600',
        },
        emptyStateContainer: {
          flex: 1,
          justifyContent: 'center',
          alignItems: 'center',
          padding: responsive.spacing.l,
        },
        emptyStateTitle: {
          marginTop: responsive.spacing.l,
          marginBottom: responsive.spacing.m,
          textAlign: 'center',
          color: colors.onSurface,
          fontWeight: '600',
        },
        emptyStateText: {
          textAlign: 'center',
          color: colors.onSurfaceVariant,
          maxWidth: 320,
          lineHeight: 24,
        },
      }),
    [colors, fonts, theme, responsive, itemWidth],
  );

  const handleConfirmExit = () => {
    setShowExitConfirmationModal(false);

    // Store the navigation action before clearing the cart
    const navigationAction =
      pendingNavigationAction || (() => navigation.goBack());

    // Clear the pending action
    setPendingNavigationAction(null);

    // Execute navigation first
    navigationAction();

    // Clear cart after navigation to avoid the beforeRemove check
    setTimeout(() => {
      clearAll();
    }, 100);
  };

  const handleCancelExit = () => {
    setShowExitConfirmationModal(false);
    setPendingNavigationAction(null);
  };

  const handleShowProductDescription = (product: Product) => {
    setSelectedProductForDescription(product);
    setIsDescriptionModalVisible(true);
  };

  const handleCloseDescriptionModal = () => {
    setIsDescriptionModalVisible(false);
    setSelectedProductForDescription(null);
  };

  const blurhash =
    '|rF?hV%2WCj[ayj[a|j[az_NaeWBj@ayfRayfQfQM{M|azj[azf6fQfQfQIpWXofj[ayj[j[fQayWCoeoeaya}j[ayfQa{oLj?j[WVj[ayayj[fQoff7azayj[ayj[j[ayofayayayj[fQj[ayayj[ayfjj[j[ayjuayj[';

  const renderItem = useCallback(
    ({ item }: { item: Category | SubCategory | Product }) => {
      const imageSource = item.photo ? item.photo.path : null;
      const isActive = item.isActive !== false; // Por defecto true si no existe la propiedad

      // Verificar si es un producto sin pantalla de preparaci√≥n
      const isProductWithoutScreen =
        navigationLevel === 'products' &&
        'preparationScreenId' in item &&
        !item.preparationScreenId;

      const handlePress = () => {
        // No hacer nada si el elemento est√° inactivo o es un producto sin pantalla
        if (!isActive || isProductWithoutScreen) return;

        if (navigationLevel === 'categories') {
          handleCategorySelect(item.id);
        } else if (navigationLevel === 'subcategories') {
          handleSubCategorySelect(item.id);
        } else if ('price' in item) {
          handleProductSelect(item as Product);
        }
      };

      const renderPrice = () => {
        if (
          navigationLevel === 'products' &&
          'price' in item &&
          'hasVariants' in item
        ) {
          const productItem = item as Product;
          if (
            !productItem.hasVariants &&
            productItem.price !== null &&
            productItem.price !== undefined
          ) {
            return (
              <Text style={styles.priceText}>
                ${Number(productItem.price).toFixed(2)}
              </Text>
            );
          }
        }
        return null;
      };

      return (
        <Card
          style={[
            styles.cardItem,
            (!isActive || isProductWithoutScreen) && styles.cardItemInactive,
          ]}
          onPress={handlePress}
          disabled={!isActive || isProductWithoutScreen}
        >
          <AutoImage
            source={imageSource}
            style={[
              styles.itemImage,
              (!isActive || isProductWithoutScreen) && styles.imageInactive,
            ]}
            contentFit="cover"
            placeholder={blurhash}
            transition={300}
            placeholderIcon="image-outline"
          />
          {!isActive && (
            <View style={styles.inactiveBadge}>
              <Text style={styles.inactiveBadgeText}>INACTIVO</Text>
            </View>
          )}
          {isProductWithoutScreen && (
            <View style={styles.inactiveBadge}>
              <Text style={styles.inactiveBadgeText}>SIN PANTALLA</Text>
            </View>
          )}
          <View style={styles.cardContent}>
            {navigationLevel === 'products' &&
            'price' in item &&
            (item as Product).description ? (
              <View style={styles.cardHeader}>
                <Title
                  style={[styles.cardTitle, { flex: 1 }]}
                  numberOfLines={2}
                  ellipsizeMode="tail"
                >
                  {item.name}
                </Title>
                <IconButton
                  icon="information-outline"
                  size={20}
                  onPress={() => handleShowProductDescription(item as Product)}
                  style={styles.infoButton}
                />
              </View>
            ) : (
              <Title
                style={styles.cardTitle}
                numberOfLines={2}
                ellipsizeMode="tail"
              >
                {item.name}
              </Title>
            )}
            {renderPrice()}
          </View>
        </Card>
      );
    },
    [
      navigationLevel,
      handleCategorySelect,
      handleSubCategorySelect,
      handleProductSelect,
      handleShowProductDescription,
      styles,
      blurhash,
    ],
  );

  const getItemsToDisplay = () => {
    switch (navigationLevel) {
      case 'categories':
        return getCategories();
      case 'subcategories':
        return getSubcategories();
      case 'products':
        return getProducts();
      default:
        return [];
    }
  };

  const itemsToDisplay = getItemsToDisplay();
  const showCartButton = !isCartVisible && !selectedProduct;

  const backAction = selectedProduct
    ? handleCloseProductModal
    : navigationLevel === 'categories'
      ? () => handleAttemptExit(() => navigation.goBack())
      : handleGoBackInternal;

  const renderContent = () => {
    if (isCartVisible) {
      return (
        <SafeAreaView
          style={styles.safeArea}
          edges={['left', 'right', 'bottom']}
        >
          <Appbar.Header style={styles.appBar}>
            <Appbar.BackAction onPress={handleCloseCart} />
            <Appbar.Content
              title="Carrito de Compras"
              titleStyle={styles.appBarTitle}
              style={styles.appBarContent}
            />
            <View style={styles.spacer} />
          </Appbar.Header>
          <OrderCartDetail
            visible={isCartVisible}
            onClose={handleCloseCart}
            onConfirmOrder={handleConfirmOrder}
            onEditItem={handleEditItem}
            isEditMode={false}
          />
        </SafeAreaView>
      );
    }

    // Verificar turno antes de renderizar
    if (!shiftLoading && (!shift || shift.status !== 'OPEN')) {
      return (
        <SafeAreaView
          style={styles.safeArea}
          edges={['left', 'right', 'bottom']}
        >
          <Appbar.Header style={styles.appBar} elevated>
            <Appbar.BackAction onPress={() => navigation.goBack()} />
            <Appbar.Content
              title="Crear Orden"
              titleStyle={styles.appBarTitle}
              style={styles.appBarContent}
            />
          </Appbar.Header>
          <View style={styles.emptyStateContainer}>
            <MaterialCommunityIcons
              name="store-alert"
              size={64}
              color={theme.colors.onSurfaceVariant}
            />
            <Text variant="headlineSmall" style={styles.emptyStateTitle}>
              Turno Cerrado
            </Text>
            <Text variant="bodyLarge" style={styles.emptyStateText}>
              {userCanOpenShift
                ? 'Para crear √≥rdenes, primero debes abrir el turno usando el indicador en la barra superior.'
                : 'El turno debe estar abierto para crear √≥rdenes. Contacta a un administrador.'}
            </Text>
          </View>
        </SafeAreaView>
      );
    }

    return (
      <SafeAreaView style={styles.safeArea} edges={['left', 'right', 'bottom']}>
        <Appbar.Header style={styles.appBar} elevated>
          <Appbar.BackAction onPress={backAction} />
          <Appbar.Content
            title={getNavTitle()}
            titleStyle={styles.appBarTitle}
            style={styles.appBarContent}
          />
          {showCartButton ? (
            <CartButton
              ref={cartButtonRef}
              itemCount={totalItemsCount}
              onPress={handleViewCart}
            />
          ) : (
            <View style={styles.spacer} />
          )}
        </Appbar.Header>

        <View style={styles.content}>
          {isLoading ? (
            <View style={styles.loadingContainer}>
              <ActivityIndicator size="large" color="#2e7d32" />
              <Text>Cargando...</Text>
            </View>
          ) : itemsToDisplay.length > 0 ? (
            <FlatList
              data={itemsToDisplay}
              renderItem={renderItem}
              keyExtractor={(item) => item.id}
              numColumns={numColumns}
              key={numColumns}
              contentContainerStyle={styles.gridContainer}
              columnWrapperStyle={numColumns > 1 ? styles.row : undefined}
              showsVerticalScrollIndicator={false}
            />
          ) : (
            <Text style={styles.noItemsText}>
              {navigationLevel === 'products'
                ? 'No hay productos disponibles'
                : navigationLevel === 'subcategories'
                  ? 'No hay subcategor√≠as disponibles'
                  : 'No hay categor√≠as disponibles'}
            </Text>
          )}
        </View>

        <ConfirmationModal
          visible={showExitConfirmationModal}
          title="¬øDescartar Orden?"
          message="Tienes art√≠culos en el carrito. Si sales, se perder√°n. ¬øEst√°s seguro?"
          confirmText="Salir y Descartar"
          cancelText="Cancelar"
          onConfirm={handleConfirmExit}
          onCancel={handleCancelExit}
        />

        <Portal>
          {selectedProduct && productNeedsCustomization(selectedProduct) && (
            <ProductCustomizationModal
              visible={true}
              product={selectedProduct}
              editingItem={editingItem}
              onAddToCart={handleAddItem}
              onUpdateItem={updateItem}
              onDismiss={handleCloseProductModal}
            />
          )}

          <SimpleProductDescriptionModal
            visible={isDescriptionModalVisible}
            product={selectedProductForDescription}
            onDismiss={handleCloseDescriptionModal}
          />
          <AudioOrderModal
            visible={showAudioModal}
            onDismiss={() => {
              setShowAudioModal(false);
              setAudioOrderData(null);
              setAudioError(undefined);
            }}
            onConfirm={handleConfirmAudioOrder}
            isProcessing={isProcessingAudio}
            orderData={audioOrderData}
            error={audioError}
          />
        </Portal>

        {/* Widget de grabaci√≥n de audio */}
        {!isCartVisible && !selectedProduct && (
          <AudioRecorderWidget
            onRecordingComplete={handleAudioRecordingComplete}
            onError={handleAudioError}
          />
        )}
      </SafeAreaView>
    );
  };

  return renderContent();
};

export default CreateOrderScreen;

================
File: app/src/modules/restaurantConfig/screens/RestaurantConfigScreen.tsx
================
import React, { useState } from 'react';
import { Portal } from 'react-native-paper';
import {
  View,
  StyleSheet,
  useWindowDimensions,
  BackHandler,
  Pressable,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import {
  Text,
  Switch,
  TextInput,
  Button,
  ActivityIndicator,
  Dialog,
  Surface,
  Chip,
  Icon,
} from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useRestaurantConfigQueries } from '../hooks/useRestaurantConfigQueries';
import {
  UpdateRestaurantConfigDto,
  CreateBusinessHoursDto,
} from '../types/restaurantConfig.types';
import BusinessHoursForm from '../components/BusinessHoursForm';
import TimeZoneSelector from '../components/TimeZoneSelector';
import { WebViewDeliveryCoverageMap } from '../components/WebViewDeliveryCoverageMap';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
import { useNavigation } from '@react-navigation/native';
import { useFocusEffect } from '@react-navigation/native';
import { useRefreshOnFocus } from '@/app/hooks/useRefreshOnFocus';

type TabType = 'basic' | 'operation' | 'schedule';

const RestaurantConfigScreen: React.FC = () => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const { width, height } = useWindowDimensions();
  const navigation = useNavigation();
  const styles = React.useMemo(
    () => createStyles(theme, responsive, width, height),
    [theme, responsive, width, height],
  );

  const { useGetConfig, useUpdateConfig } = useRestaurantConfigQueries();
  const { data: config, isLoading, error } = useGetConfig();
  const updateConfigMutation = useUpdateConfig();
  const updateDeliveryAreaMutation = useUpdateConfig({
    successMessage: '√Årea de cobertura actualizada exitosamente',
  });

  const [activeTab, setActiveTab] = useState<TabType>('basic');
  const [pendingTab, setPendingTab] = useState<TabType | null>(null);
  const [formData, setFormData] = useState<UpdateRestaurantConfigDto>({});
  const [isEditing, setIsEditing] = useState(false);
  const [showDiscardDialog, setShowDiscardDialog] = useState(false);
  const [showDeliveryModal, setShowDeliveryModal] = useState(false);
  const [isEditingDelivery, setIsEditingDelivery] = useState(false);
  const [isNavigatingAway, setIsNavigatingAway] = useState(false);
  const [businessHoursModified, setBusinessHoursModified] = useState(false);
  const [originalDeliveryArea, setOriginalDeliveryArea] = useState<any>(null);
  const [showAreaValidationModal, setShowAreaValidationModal] = useState(false);
  const [showScheduleConflictModal, setShowScheduleConflictModal] =
    useState(false);

  // Refrescar configuraci√≥n cuando la pantalla recibe foco
  useRefreshOnFocus([['restaurantConfig']]);

  // Funci√≥n para validar conflictos de horarios
  const hasScheduleConflicts = React.useCallback(() => {
    if (!formData.businessHours) return false;

    for (let i = 0; i < formData.businessHours.length; i++) {
      const currentDay = formData.businessHours[i];
      if (currentDay.isClosed || !currentDay.openingTime) continue;

      // Verificar si el d√≠a anterior cierra despu√©s de medianoche
      const previousDayIndex = i === 0 ? 6 : i - 1;
      const previousDay = formData.businessHours.find(
        (h) => h.dayOfWeek === previousDayIndex,
      );

      if (
        !previousDay ||
        previousDay.isClosed ||
        !previousDay.closesNextDay ||
        !previousDay.closingTime
      ) {
        continue;
      }

      // Comparar horarios
      const [currentOpenHour, currentOpenMin] = currentDay.openingTime
        .split(':')
        .map(Number);
      const [prevCloseHour, prevCloseMin] = previousDay.closingTime
        .split(':')
        .map(Number);

      const currentOpenMinutes = currentOpenHour * 60 + currentOpenMin;
      const prevCloseMinutes = prevCloseHour * 60 + prevCloseMin;

      // Si el d√≠a actual abre antes o exactamente cuando cierre el d√≠a anterior
      if (currentOpenMinutes <= prevCloseMinutes) {
        return true;
      }
    }

    return false;
  }, [formData.businessHours]);

  // Funci√≥n para verificar si hay cambios sin guardar
  const hasChanges = React.useCallback(() => {
    if (!config) return false;

    // Comparaci√≥n simple de campos individuales
    const simpleFieldsChanged =
      formData.restaurantName !== config.restaurantName ||
      formData.phoneMain !== config.phoneMain ||
      formData.phoneSecondary !== config.phoneSecondary ||
      formData.address !== config.address ||
      formData.city !== config.city ||
      formData.state !== config.state ||
      formData.postalCode !== config.postalCode ||
      formData.country !== config.country ||
      formData.acceptingOrders !== config.acceptingOrders ||
      formData.estimatedPickupTime !== config.estimatedPickupTime ||
      formData.estimatedDeliveryTime !== config.estimatedDeliveryTime ||
      formData.estimatedDineInTime !== config.estimatedDineInTime ||
      formData.openingGracePeriod !== config.openingGracePeriod ||
      formData.closingGracePeriod !== config.closingGracePeriod ||
      formData.timeZone !== config.timeZone ||
      formData.scheduledOrdersLeadTime !== config.scheduledOrdersLeadTime ||
      formData.minimumOrderValueForDelivery !==
        config.minimumOrderValueForDelivery;

    // Comparar √°rea de cobertura
    const deliveryAreaChanged =
      JSON.stringify(formData.deliveryCoverageArea) !==
      JSON.stringify(config.deliveryCoverageArea);

    return simpleFieldsChanged || deliveryAreaChanged || businessHoursModified;
  }, [config, formData, businessHoursModified]);

  // Interceptar navegaci√≥n cuando hay cambios sin guardar
  useFocusEffect(
    React.useCallback(() => {
      const unsubscribe = navigation.addListener('beforeRemove', (e) => {
        if (!isEditing || !hasChanges()) {
          // Si no est√° editando o no hay cambios, permitir navegaci√≥n
          return;
        }

        // Prevenir la navegaci√≥n por defecto
        e.preventDefault();

        // Mostrar el di√°logo de confirmaci√≥n
        setIsNavigatingAway(true);
        setShowDiscardDialog(true);
      });

      return unsubscribe;
    }, [navigation, isEditing, hasChanges]),
  );

  // Manejar bot√≥n de retroceso de Android
  useFocusEffect(
    React.useCallback(() => {
      const onBackPress = () => {
        if (isEditing && hasChanges()) {
          setIsNavigatingAway(true);
          setShowDiscardDialog(true);
          return true; // Prevenir el comportamiento por defecto
        }
        return false;
      };

      const subscription = BackHandler.addEventListener(
        'hardwareBackPress',
        onBackPress,
      );

      return () => subscription.remove();
    }, [isEditing, hasChanges]),
  );

  React.useEffect(() => {
    if (config && !isEditing) {
      // Solo actualizar formData si no estamos editando
      // Si no hay businessHours, inicializar con valores por defecto
      const initialBusinessHours =
        config.businessHours && config.businessHours.length > 0
          ? config.businessHours.map((hour) => ({
              ...hour,
              // Normalizar el formato de tiempo a HH:MM
              openingTime: hour.openingTime
                ? hour.openingTime.substring(0, 5)
                : null,
              closingTime: hour.closingTime
                ? hour.closingTime.substring(0, 5)
                : null,
            }))
          : [0, 1, 2, 3, 4, 5, 6].map((dayOfWeek) => ({
              dayOfWeek,
              openingTime: '09:00',
              closingTime: '22:00',
              isClosed: false,
            }));

      setFormData({
        // Informaci√≥n b√°sica
        restaurantName: config.restaurantName,
        phoneMain: config.phoneMain,
        phoneSecondary: config.phoneSecondary,
        address: config.address,
        city: config.city,
        state: config.state,
        postalCode: config.postalCode,
        country: config.country,
        // Configuraci√≥n de operaci√≥n
        acceptingOrders: config.acceptingOrders,
        estimatedPickupTime: config.estimatedPickupTime,
        estimatedDeliveryTime: config.estimatedDeliveryTime,
        estimatedDineInTime: config.estimatedDineInTime,
        openingGracePeriod: config.openingGracePeriod,
        closingGracePeriod: config.closingGracePeriod,
        timeZone: config.timeZone || 'America/Mexico_City',
        scheduledOrdersLeadTime: config.scheduledOrdersLeadTime,
        // Configuraci√≥n de delivery
        deliveryCoverageArea: config.deliveryCoverageArea,
        minimumOrderValueForDelivery:
          typeof config.minimumOrderValueForDelivery === 'string'
            ? parseFloat(config.minimumOrderValueForDelivery)
            : config.minimumOrderValueForDelivery,
        // Horarios
        businessHours: initialBusinessHours,
      });
    }
  }, [config, isEditing]);

  const handleSubmit = async () => {
    // Validar conflictos de horarios antes de guardar
    if (hasScheduleConflicts()) {
      setShowScheduleConflictModal(true);
      return;
    }

    try {
      // Formatear los datos antes de enviarlos
      const dataToSubmit = {
        ...formData,
        // Formatear businessHours para quitar los segundos
        businessHours: formData.businessHours?.map((hour) => ({
          ...hour,
          openingTime: hour.openingTime
            ? hour.openingTime.substring(0, 5)
            : null,
          closingTime: hour.closingTime
            ? hour.closingTime.substring(0, 5)
            : null,
        })),
        // deliveryCoverageArea se env√≠a tal como est√° (array de coordenadas)
      };

      await updateConfigMutation.mutateAsync(dataToSubmit);
      setIsEditing(false);
      setBusinessHoursModified(false);
    } catch (error) {
      // Error handling is done in the mutation hook
    }
  };

  const handleSaveDeliveryArea = async () => {
    try {
      // Guardar solo el √°rea de cobertura
      await updateDeliveryAreaMutation.mutateAsync({
        deliveryCoverageArea: formData.deliveryCoverageArea,
      });

      // Actualizar el estado del config con la nueva √°rea
      if (config) {
        // Esto asegura que el estado local se mantenga sincronizado
        setFormData((prev) => ({
          ...prev,
          deliveryCoverageArea: formData.deliveryCoverageArea,
        }));
      }
    } catch (error) {
      // Error handling is done in the mutation hook
    }
  };

  const handleCancel = () => {
    if (hasChanges()) {
      setShowDiscardDialog(true);
    } else {
      resetForm();
    }
  };

  const resetForm = () => {
    if (config) {
      // Usar la misma l√≥gica de inicializaci√≥n que en useEffect
      const initialBusinessHours =
        config.businessHours && config.businessHours.length > 0
          ? config.businessHours.map((hour) => ({
              ...hour,
              // Normalizar el formato de tiempo a HH:MM
              openingTime: hour.openingTime
                ? hour.openingTime.substring(0, 5)
                : null,
              closingTime: hour.closingTime
                ? hour.closingTime.substring(0, 5)
                : null,
            }))
          : [0, 1, 2, 3, 4, 5, 6].map((dayOfWeek) => ({
              dayOfWeek,
              openingTime: '09:00',
              closingTime: '22:00',
              isClosed: false,
            }));

      setFormData({
        restaurantName: config.restaurantName,
        phoneMain: config.phoneMain,
        phoneSecondary: config.phoneSecondary,
        address: config.address,
        city: config.city,
        state: config.state,
        postalCode: config.postalCode,
        country: config.country,
        acceptingOrders: config.acceptingOrders,
        estimatedPickupTime: config.estimatedPickupTime,
        estimatedDeliveryTime: config.estimatedDeliveryTime,
        estimatedDineInTime: config.estimatedDineInTime,
        openingGracePeriod: config.openingGracePeriod,
        closingGracePeriod: config.closingGracePeriod,
        timeZone: config.timeZone || 'America/Mexico_City',
        scheduledOrdersLeadTime: config.scheduledOrdersLeadTime,
        deliveryCoverageArea: config.deliveryCoverageArea,
        minimumOrderValueForDelivery:
          typeof config.minimumOrderValueForDelivery === 'string'
            ? parseFloat(config.minimumOrderValueForDelivery)
            : config.minimumOrderValueForDelivery,
        businessHours: initialBusinessHours,
      });
    }
    setIsEditing(false);
    setBusinessHoursModified(false);
  };

  const confirmDiscard = () => {
    resetForm();
    setShowDiscardDialog(false);

    // Si estaba navegando fuera de la pantalla
    if (isNavigatingAway) {
      setIsNavigatingAway(false);
      navigation.goBack();
      return;
    }

    // Si hay una pesta√±a pendiente, cambiar a ella
    if (pendingTab) {
      setActiveTab(pendingTab);
      setPendingTab(null);
    }
  };

  const handleTabChange = (newTab: TabType) => {
    // Permitir cambio libre de tabs, sin importar si est√° editando
    setActiveTab(newTab);
  };

  const renderBasicInfo = () => (
    <View style={styles.tabContent}>
      <Surface style={styles.section} elevation={1}>
        <View style={styles.sectionHeader}>
          <MaterialCommunityIcons
            name="store-outline"
            size={24}
            color={theme.colors.primary}
          />
          <Text style={styles.sectionTitle}>Informaci√≥n del Restaurante</Text>
        </View>

        <View style={styles.sectionContent}>
          <TextInput
            label="Nombre del restaurante"
            value={formData.restaurantName || ''}
            onChangeText={(text) =>
              setFormData({ ...formData, restaurantName: text })
            }
            mode="outlined"
            disabled={!isEditing}
            style={styles.input}
            outlineStyle={styles.inputOutline}
          />

          <TextInput
            label="Tel√©fono principal"
            value={formData.phoneMain || ''}
            onChangeText={(text) =>
              setFormData({ ...formData, phoneMain: text })
            }
            mode="outlined"
            disabled={!isEditing}
            style={styles.input}
            outlineStyle={styles.inputOutline}
            keyboardType="phone-pad"
            left={<TextInput.Icon icon="phone" />}
          />

          <TextInput
            label="Tel√©fono secundario"
            value={formData.phoneSecondary || ''}
            onChangeText={(text) =>
              setFormData({ ...formData, phoneSecondary: text })
            }
            mode="outlined"
            disabled={!isEditing}
            style={styles.input}
            outlineStyle={styles.inputOutline}
            keyboardType="phone-pad"
            left={<TextInput.Icon icon="cellphone" />}
          />

          <TextInput
            label="Direcci√≥n"
            value={formData.address || ''}
            onChangeText={(text) => setFormData({ ...formData, address: text })}
            mode="outlined"
            disabled={!isEditing}
            style={styles.input}
            outlineStyle={styles.inputOutline}
            multiline
            numberOfLines={2}
            left={<TextInput.Icon icon="map-marker" />}
          />

          <View style={styles.row}>
            <TextInput
              label="Ciudad"
              value={formData.city || ''}
              onChangeText={(text) => setFormData({ ...formData, city: text })}
              mode="outlined"
              disabled={!isEditing}
              style={[styles.input, styles.halfInput]}
              outlineStyle={styles.inputOutline}
            />
            <TextInput
              label="Estado"
              value={formData.state || ''}
              onChangeText={(text) => setFormData({ ...formData, state: text })}
              mode="outlined"
              disabled={!isEditing}
              style={[styles.input, styles.halfInput]}
              outlineStyle={styles.inputOutline}
            />
          </View>

          <View style={styles.row}>
            <TextInput
              label="C√≥digo postal"
              value={formData.postalCode || ''}
              onChangeText={(text) =>
                setFormData({ ...formData, postalCode: text })
              }
              mode="outlined"
              disabled={!isEditing}
              style={[styles.input, styles.halfInput]}
              outlineStyle={styles.inputOutline}
              keyboardType="numeric"
            />
            <TextInput
              label="Pa√≠s"
              value={formData.country || ''}
              onChangeText={(text) =>
                setFormData({ ...formData, country: text })
              }
              mode="outlined"
              disabled={!isEditing}
              style={[styles.input, styles.halfInput]}
              outlineStyle={styles.inputOutline}
            />
          </View>

          {/* Bot√≥n para √°rea de cobertura */}
          <View style={styles.deliveryButtonContainer}>
            <Button
              mode="contained-tonal"
              onPress={() => setShowDeliveryModal(true)}
              icon="map-marker-radius"
              style={styles.deliveryButton}
              contentStyle={styles.deliveryButtonContent}
              labelStyle={styles.deliveryButtonLabel}
            >
              √Årea de Cobertura
            </Button>
            {formData.deliveryCoverageArea &&
            formData.deliveryCoverageArea.length > 0 ? (
              <Text style={styles.deliveryStatusText}>
                √Årea de cobertura definida
              </Text>
            ) : (
              <Text
                style={[
                  styles.deliveryStatusText,
                  styles.deliveryStatusWarning,
                ]}
              >
                Sin √°rea de cobertura definida
              </Text>
            )}
          </View>
        </View>
      </Surface>
    </View>
  );

  const renderOperationConfig = () => (
    <View style={styles.tabContent}>
      {/* Service Status Card */}
      <Surface style={styles.section} elevation={1}>
        <View style={styles.sectionHeader}>
          <MaterialCommunityIcons
            name="store-check"
            size={24}
            color={theme.colors.primary}
          />
          <Text style={styles.sectionTitle}>Estado del Servicio</Text>
        </View>

        <View style={styles.sectionContent}>
          <View style={styles.statusRow}>
            <View style={styles.statusInfo}>
              <Text style={styles.statusLabel}>Recepci√≥n de √ìrdenes</Text>
              <Text style={styles.statusDescription}>
                {formData.acceptingOrders
                  ? 'Las √≥rdenes est√°n siendo aceptadas'
                  : 'No se est√°n aceptando √≥rdenes nuevas'}
              </Text>
            </View>
            <Switch
              value={formData.acceptingOrders}
              onValueChange={(value) =>
                setFormData({ ...formData, acceptingOrders: value })
              }
              disabled={!isEditing}
              color={theme.colors.primary}
            />
          </View>
        </View>
      </Surface>

      {/* Delivery Times Card */}
      <Surface style={styles.section} elevation={1}>
        <View style={styles.sectionHeader}>
          <MaterialCommunityIcons
            name="clock-time-four"
            size={24}
            color={theme.colors.primary}
          />
          <Text style={styles.sectionTitle}>Tiempos de Servicio</Text>
        </View>

        <View style={styles.sectionContent}>
          <View style={styles.timeInputContainer}>
            <View style={styles.timeIconWrapper}>
              <MaterialCommunityIcons
                name="walk"
                size={20}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <TextInput
              label="Para recoger en tienda"
              value={formData.estimatedPickupTime?.toString() || ''}
              onChangeText={(text) =>
                setFormData({
                  ...formData,
                  estimatedPickupTime: parseInt(text) || 0,
                })
              }
              keyboardType="numeric"
              mode="outlined"
              disabled={!isEditing}
              style={styles.timeInput}
              right={<TextInput.Affix text="min" />}
              outlineStyle={styles.inputOutline}
            />
          </View>

          <View style={styles.timeInputContainer}>
            <View style={styles.timeIconWrapper}>
              <MaterialCommunityIcons
                name="moped"
                size={20}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <TextInput
              label="Entrega a domicilio"
              value={formData.estimatedDeliveryTime?.toString() || ''}
              onChangeText={(text) =>
                setFormData({
                  ...formData,
                  estimatedDeliveryTime: parseInt(text) || 0,
                })
              }
              keyboardType="numeric"
              mode="outlined"
              disabled={!isEditing}
              style={styles.timeInput}
              right={<TextInput.Affix text="min" />}
              outlineStyle={styles.inputOutline}
            />
          </View>

          <View style={styles.timeInputContainer}>
            <View style={styles.timeIconWrapper}>
              <MaterialCommunityIcons
                name="currency-usd"
                size={20}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <TextInput
              label="Valor m√≠nimo para delivery"
              value={formData.minimumOrderValueForDelivery?.toString() || ''}
              onChangeText={(text) => {
                const value = parseFloat(text);
                setFormData({
                  ...formData,
                  minimumOrderValueForDelivery: isNaN(value) ? 0 : value,
                });
              }}
              keyboardType="numeric"
              mode="outlined"
              disabled={!isEditing}
              style={styles.timeInput}
              right={<TextInput.Affix text="$" />}
              outlineStyle={styles.inputOutline}
            />
          </View>

          <View style={styles.timeInputContainer}>
            <View style={styles.timeIconWrapper}>
              <MaterialCommunityIcons
                name="silverware-fork-knife"
                size={20}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <TextInput
              label="Para comer en el local"
              value={formData.estimatedDineInTime?.toString() || ''}
              onChangeText={(text) =>
                setFormData({
                  ...formData,
                  estimatedDineInTime: parseInt(text) || 0,
                })
              }
              keyboardType="numeric"
              mode="outlined"
              disabled={!isEditing}
              style={styles.timeInput}
              right={<TextInput.Affix text="min" />}
              outlineStyle={styles.inputOutline}
            />
          </View>

          <View style={styles.timeInputContainer}>
            <View style={styles.timeIconWrapper}>
              <MaterialCommunityIcons
                name="timer"
                size={20}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <TextInput
              label="Periodo de gracia al abrir"
              value={formData.openingGracePeriod?.toString() || ''}
              onChangeText={(text) =>
                setFormData({
                  ...formData,
                  openingGracePeriod: parseInt(text) || 0,
                })
              }
              keyboardType="numeric"
              mode="outlined"
              disabled={!isEditing}
              style={styles.timeInput}
              right={<TextInput.Affix text="min" />}
              outlineStyle={styles.inputOutline}
            />
          </View>

          <View style={styles.timeInputContainer}>
            <View style={styles.timeIconWrapper}>
              <MaterialCommunityIcons
                name="timer-off-outline"
                size={20}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <TextInput
              label="Periodo de gracia al cerrar"
              value={formData.closingGracePeriod?.toString() || ''}
              onChangeText={(text) =>
                setFormData({
                  ...formData,
                  closingGracePeriod: parseInt(text) || 0,
                })
              }
              keyboardType="numeric"
              mode="outlined"
              disabled={!isEditing}
              style={styles.timeInput}
              right={<TextInput.Affix text="min" />}
              outlineStyle={styles.inputOutline}
            />
          </View>

          <View style={styles.timeInputContainer}>
            <View style={styles.timeIconWrapper}>
              <MaterialCommunityIcons
                name="calendar-clock"
                size={20}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <TextInput
              label="Anticipaci√≥n √≥rdenes programadas"
              value={formData.scheduledOrdersLeadTime?.toString() || ''}
              onChangeText={(text) =>
                setFormData({
                  ...formData,
                  scheduledOrdersLeadTime: parseInt(text) || 0,
                })
              }
              keyboardType="numeric"
              mode="outlined"
              disabled={!isEditing}
              style={styles.timeInput}
              right={<TextInput.Affix text="min" />}
              outlineStyle={styles.inputOutline}
            />
          </View>

          <View style={styles.infoChip}>
            <Chip
              icon="information"
              mode="flat"
              style={styles.chip}
              textStyle={styles.chipText}
            >
              Los tiempos son estimados y pueden variar
            </Chip>
          </View>
        </View>
      </Surface>

      {/* Time Zone */}
      <Surface style={styles.section} elevation={1}>
        <View style={styles.sectionHeader}>
          <MaterialCommunityIcons
            name="earth"
            size={24}
            color={theme.colors.primary}
          />
          <Text style={styles.sectionTitle}>Zona Horaria</Text>
        </View>

        <View style={styles.sectionContent}>
          <TimeZoneSelector
            value={formData.timeZone || 'America/Mexico_City'}
            onChange={(timezone) => {
              setFormData({ ...formData, timeZone: timezone });
            }}
            disabled={!isEditing}
          />
        </View>
      </Surface>
    </View>
  );

  const renderSchedule = () => (
    <View style={styles.tabContent}>
      <Surface style={styles.section} elevation={1}>
        <View style={styles.sectionHeader}>
          <MaterialCommunityIcons
            name="calendar-clock"
            size={24}
            color={theme.colors.primary}
          />
          <Text style={styles.sectionTitle}>Horario de Operaci√≥n</Text>
        </View>

        <View style={styles.sectionContent}>
          <BusinessHoursForm
            businessHours={formData.businessHours || []}
            isEditing={isEditing}
            onChange={(hours: CreateBusinessHoursDto[]) => {
              setFormData((prev) => ({ ...prev, businessHours: hours }));
              setBusinessHoursModified(true);
            }}
          />
        </View>
      </Surface>
    </View>
  );

  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </View>
    );
  }

  if (error) {
    return (
      <View style={styles.errorContainer}>
        <Text style={styles.errorText}>Error al cargar la configuraci√≥n</Text>
      </View>
    );
  }

  return (
    <SafeAreaView style={styles.container} edges={['bottom']}>
      {/* Tabs */}
      <View style={styles.header}>
        <View style={styles.tabsContainer}>
          <Pressable
            style={[styles.tab, activeTab === 'basic' && styles.tabActive]}
            onPress={() => handleTabChange('basic')}
          >
            <Icon
              source="store"
              size={20}
              color={
                activeTab === 'basic'
                  ? theme.colors.primary
                  : theme.colors.onSurfaceVariant
              }
            />
            <Text
              style={[
                styles.tabText,
                activeTab === 'basic' && styles.tabTextActive,
              ]}
            >
              Informaci√≥n
            </Text>
          </Pressable>

          <Pressable
            style={[styles.tab, activeTab === 'operation' && styles.tabActive]}
            onPress={() => handleTabChange('operation')}
          >
            <Icon
              source="cog"
              size={20}
              color={
                activeTab === 'operation'
                  ? theme.colors.primary
                  : theme.colors.onSurfaceVariant
              }
            />
            <Text
              style={[
                styles.tabText,
                activeTab === 'operation' && styles.tabTextActive,
              ]}
            >
              Operaci√≥n
            </Text>
          </Pressable>

          <Pressable
            style={[styles.tab, activeTab === 'schedule' && styles.tabActive]}
            onPress={() => handleTabChange('schedule')}
          >
            <Icon
              source="calendar"
              size={20}
              color={
                activeTab === 'schedule'
                  ? theme.colors.primary
                  : theme.colors.onSurfaceVariant
              }
            />
            <Text
              style={[
                styles.tabText,
                activeTab === 'schedule' && styles.tabTextActive,
              ]}
            >
              Horarios
            </Text>
          </Pressable>
        </View>
      </View>

      {/* Content */}
      <KeyboardAvoidingView
        style={{ flex: 1 }}
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        keyboardVerticalOffset={Platform.OS === 'ios' ? 64 : 0}
      >
        <ScrollView
          contentContainerStyle={styles.scrollContent}
          showsVerticalScrollIndicator={false}
          keyboardShouldPersistTaps="handled"
        >
          {activeTab === 'basic' && renderBasicInfo()}
          {activeTab === 'operation' && renderOperationConfig()}
          {activeTab === 'schedule' && renderSchedule()}
        </ScrollView>
      </KeyboardAvoidingView>

      {/* Action Buttons */}
      <View style={styles.actionContainer}>
        {!isEditing ? (
          <Button
            mode="contained"
            onPress={() => {
              setIsEditing(true);
              setBusinessHoursModified(false);
            }}
            style={[
              styles.editButton,
              { backgroundColor: theme.colors.tertiary },
            ]}
            contentStyle={styles.editButtonContent}
            labelStyle={styles.editButtonLabel}
            icon="pencil"
            textColor={theme.colors.onTertiary}
          >
            Editar Configuraci√≥n
          </Button>
        ) : (
          <View style={styles.editActions}>
            <Button
              mode="outlined"
              onPress={handleCancel}
              style={styles.cancelButton}
              contentStyle={styles.buttonContent}
            >
              Cancelar
            </Button>
            <Button
              mode="contained"
              onPress={handleSubmit}
              loading={updateConfigMutation.isPending}
              disabled={updateConfigMutation.isPending}
              style={styles.saveButton}
              contentStyle={styles.buttonContent}
              icon="check"
            >
              Guardar
            </Button>
          </View>
        )}
      </View>

      {/* System Info Card */}
      {config && (
        <Surface style={styles.infoCard} elevation={1}>
          <View style={styles.infoContent}>
            <MaterialCommunityIcons
              name="information-outline"
              size={20}
              color={theme.colors.onSurfaceVariant}
            />
            <View style={styles.infoTextContainer}>
              <Text style={styles.infoTitle}>√öltima actualizaci√≥n</Text>
              <Text style={styles.infoText}>
                {new Date(config.updatedAt).toLocaleString('es-MX', {
                  dateStyle: 'medium',
                  timeStyle: 'short',
                  timeZone: config.timeZone || 'America/Mexico_City',
                })}
              </Text>
            </View>
          </View>
        </Surface>
      )}

      <ConfirmationModal
        visible={showDiscardDialog}
        title="Descartar cambios"
        message="¬øEst√°s seguro de que deseas descartar los cambios realizados?"
        onConfirm={confirmDiscard}
        onCancel={() => {
          setShowDiscardDialog(false);
          setIsNavigatingAway(false);
          setPendingTab(null);
        }}
        confirmText="Descartar"
        cancelText="Continuar editando"
        confirmButtonColor={theme.colors.error}
      />

      {/* Modal de √Årea de Cobertura */}
      <Portal>
        <Dialog
          visible={showDeliveryModal}
          onDismiss={() => {
            if (!updateDeliveryAreaMutation.isPending) {
              if (isEditingDelivery) {
                setFormData({
                  ...formData,
                  deliveryCoverageArea: originalDeliveryArea,
                });
              }
              setShowDeliveryModal(false);
              setIsEditingDelivery(false);
            }
          }}
          style={styles.deliveryDialog}
        >
          <Dialog.Content style={styles.deliveryDialogContent}>
            <Surface style={styles.deliveryMapWrapper} elevation={1}>
              <View style={styles.deliveryMapContainer}>
                <WebViewDeliveryCoverageMap
                  key={`coverage-map-${isEditingDelivery}`}
                  initialPolygon={formData.deliveryCoverageArea}
                  isEditing={isEditingDelivery}
                  onChange={(polygon) =>
                    setFormData({ ...formData, deliveryCoverageArea: polygon })
                  }
                  restaurantLocation={{
                    latitude: 20.5425,
                    longitude: -102.7935,
                  }}
                />
              </View>
            </Surface>
          </Dialog.Content>
          <View style={styles.deliveryDialogActions}>
            <View style={styles.deliveryDialogButtonsContainer}>
              {!isEditingDelivery ? (
                <>
                  <Button
                    onPress={() => setShowDeliveryModal(false)}
                    mode="outlined"
                    style={styles.deliveryDialogButton}
                    contentStyle={styles.deliveryButtonContent}
                    labelStyle={styles.cancelButtonLabel}
                  >
                    Cerrar
                  </Button>
                  <Button
                    onPress={() => {
                      setOriginalDeliveryArea(formData.deliveryCoverageArea);
                      setIsEditingDelivery(true);
                    }}
                    icon="pencil"
                    mode="contained"
                    style={styles.deliveryDialogButton}
                    contentStyle={styles.deliveryButtonContent}
                    labelStyle={styles.deliveryButtonLabel}
                  >
                    Editar
                  </Button>
                </>
              ) : (
                <>
                  <Button
                    onPress={() => {
                      setFormData({
                        ...formData,
                        deliveryCoverageArea: originalDeliveryArea,
                      });
                      setIsEditingDelivery(false);
                    }}
                    mode="outlined"
                    style={styles.deliveryDialogButton}
                    contentStyle={styles.deliveryButtonContent}
                    labelStyle={styles.cancelButtonLabel}
                    disabled={updateDeliveryAreaMutation.isPending}
                  >
                    Cancelar
                  </Button>
                  <Button
                    onPress={async () => {
                      // Validar que haya al menos 3 puntos
                      if (
                        !formData.deliveryCoverageArea ||
                        formData.deliveryCoverageArea.length < 3
                      ) {
                        setShowAreaValidationModal(true);
                        return;
                      }

                      setIsEditingDelivery(false);
                      // Guardar el √°rea de cobertura inmediatamente
                      await handleSaveDeliveryArea();
                      setShowDeliveryModal(false);
                    }}
                    mode="contained"
                    icon="check"
                    style={styles.deliveryDialogButton}
                    contentStyle={styles.deliveryButtonContent}
                    labelStyle={styles.deliveryButtonLabel}
                    loading={updateDeliveryAreaMutation.isPending}
                    disabled={updateDeliveryAreaMutation.isPending}
                  >
                    Guardar
                  </Button>
                </>
              )}
            </View>
          </View>
        </Dialog>
      </Portal>

      {/* Modal de validaci√≥n de √°rea */}
      <Portal>
        <Dialog
          visible={showAreaValidationModal}
          onDismiss={() => setShowAreaValidationModal(false)}
          style={styles.validationDialog}
        >
          <View style={styles.validationIconContainer}>
            <Surface style={styles.validationIconWrapper} elevation={0}>
              <MaterialCommunityIcons
                name="map-marker-alert"
                size={36}
                color={theme.colors.error}
              />
            </Surface>
          </View>
          <Dialog.Title style={styles.validationTitle}>
            √Årea incompleta
          </Dialog.Title>
          <Dialog.Content>
            <Text style={styles.validationMessage}>
              Se requieren al menos 3 puntos para definir un √°rea de cobertura
              v√°lida.
            </Text>
            <Text style={styles.validationHint}>
              Haz clic en el mapa para agregar m√°s puntos o usa el bot√≥n de
              dibujar.
            </Text>
          </Dialog.Content>
          <Dialog.Actions style={styles.validationActions}>
            <Button
              onPress={() => setShowAreaValidationModal(false)}
              mode="contained"
              style={styles.validationButton}
              contentStyle={styles.validationButtonContent}
              labelStyle={styles.validationButtonLabel}
            >
              Entendido
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>

      {/* Modal de conflicto de horarios */}
      <Portal>
        <Dialog
          visible={showScheduleConflictModal}
          onDismiss={() => setShowScheduleConflictModal(false)}
          style={styles.validationDialog}
        >
          <View style={styles.validationIconContainer}>
            <Surface style={styles.validationIconWrapper} elevation={0}>
              <MaterialCommunityIcons
                name="clock-alert"
                size={36}
                color={theme.colors.error}
              />
            </Surface>
          </View>
          <Dialog.Title style={styles.validationTitle}>
            Conflicto de horarios
          </Dialog.Title>
          <Dialog.Content>
            <Text style={styles.validationMessage}>
              Hay conflictos en los horarios de operaci√≥n. Un d√≠a no puede abrir
              antes o al mismo tiempo que cierre el d√≠a anterior.
            </Text>
            <Text style={styles.validationHint}>
              Debe haber al menos 1 minuto de diferencia entre el cierre y la
              siguiente apertura. Revisa los horarios marcados con advertencia.
            </Text>
          </Dialog.Content>
          <Dialog.Actions style={styles.validationActions}>
            <Button
              onPress={() => setShowScheduleConflictModal(false)}
              mode="contained"
              style={styles.validationButton}
              contentStyle={styles.validationButtonContent}
              labelStyle={styles.validationButtonLabel}
            >
              Revisar horarios
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </SafeAreaView>
  );
};

const createStyles = (
  theme: AppTheme,
  responsive: any,
  width: number,
  height: number,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    scrollContent: {
      paddingBottom: responsive.spacing(theme.spacing.xl),
    },
    deliveryContent: {
      flex: 1,
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.m),
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
    errorContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.spacing(theme.spacing.xl),
    },
    errorText: {
      fontSize: responsive.fontSize(16),
      color: theme.colors.error,
      textAlign: 'center',
    },
    // Header y Tabs
    header: {
      backgroundColor: theme.colors.elevation.level2,
      elevation: 0,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    tabsContainer: {
      flexDirection: 'row',
      height: responsive.scaleHeight(48),
    },
    tab: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      gap: responsive.spacing(theme.spacing.xs),
    },
    tabActive: {
      borderBottomWidth: 2,
      borderBottomColor: theme.colors.primary,
    },
    tabText: {
      fontSize: responsive.fontSize(14),
      fontWeight: '500',
      color: theme.colors.onSurfaceVariant,
    },
    tabTextActive: {
      color: theme.colors.primary,
      fontWeight: '600',
    },
    tabContent: {
      padding: responsive.spacing(theme.spacing.m),
      gap: responsive.spacing(theme.spacing.m),
    },
    // Section styles
    section: {
      borderRadius: 16,
      padding: responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surface,
    },
    sectionHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: responsive.spacing(theme.spacing.m),
    },
    sectionTitle: {
      fontSize: responsive.fontSize(18),
      fontWeight: '600',
      color: theme.colors.onSurface,
      marginLeft: responsive.spacing(theme.spacing.s),
    },
    sectionContent: {
      gap: responsive.spacing(theme.spacing.m),
    },
    deliveryInfo: {
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      marginBottom: responsive.spacing(theme.spacing.s),
    },
    // Input styles
    input: {
      backgroundColor: theme.colors.surface,
    },
    inputOutline: {
      borderRadius: 12,
    },
    row: {
      flexDirection: 'row',
      gap: responsive.spacing(theme.spacing.s),
    },
    halfInput: {
      flex: 1,
    },
    // Status styles
    statusRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    statusInfo: {
      flex: 1,
      marginRight: responsive.spacing(theme.spacing.m),
    },
    statusLabel: {
      fontSize: responsive.fontSize(16),
      fontWeight: '500',
      color: theme.colors.onSurface,
      marginBottom: responsive.spacing(theme.spacing.xs),
    },
    statusDescription: {
      fontSize: responsive.fontSize(14),
      color: theme.colors.onSurfaceVariant,
    },
    // Time input styles
    timeInputContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.spacing(theme.spacing.s),
    },
    timeIconWrapper: {
      width: responsive.scaleWidth(40),
      height: responsive.scaleWidth(40),
      borderRadius: responsive.scaleWidth(20),
      backgroundColor: theme.colors.surfaceVariant,
      justifyContent: 'center',
      alignItems: 'center',
    },
    timeInput: {
      flex: 1,
      backgroundColor: theme.colors.surface,
    },
    infoChip: {
      marginTop: responsive.spacing(theme.spacing.xs),
    },
    chip: {
      backgroundColor: theme.colors.secondaryContainer,
    },
    chipText: {
      fontSize: responsive.fontSize(12),
    },
    // Delivery styles
    deliveryInfo: {
      marginTop: responsive.spacing(theme.spacing.m),
      alignItems: 'center',
    },
    // Action styles
    actionContainer: {
      marginHorizontal: responsive.spacing(theme.spacing.m),
      marginTop: responsive.spacing(theme.spacing.l),
      alignItems: 'center',
    },
    editButton: {
      borderRadius: 12,
      elevation: 2,
      alignSelf: 'stretch',
    },
    editButtonContent: {
      paddingVertical: responsive.spacing(theme.spacing.xs),
    },
    editButtonLabel: {
      fontSize: responsive.fontSize(16),
      fontWeight: '600',
    },
    editActions: {
      flexDirection: 'row',
      gap: responsive.spacing(theme.spacing.l),
      width: '100%',
      justifyContent: 'center',
      paddingHorizontal: responsive.spacing(theme.spacing.m),
    },
    cancelButton: {
      flex: 1,
      borderRadius: 12,
    },
    saveButton: {
      flex: 1,
      borderRadius: 12,
      elevation: 2,
    },
    buttonContent: {
      paddingVertical: responsive.spacing(theme.spacing.xs),
    },
    // Info Card styles
    infoCard: {
      marginHorizontal: responsive.spacing(theme.spacing.m),
      marginTop: responsive.spacing(theme.spacing.m),
      borderRadius: 12,
      padding: responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surfaceVariant,
    },
    infoContent: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.spacing(theme.spacing.s),
    },
    infoTextContainer: {
      flex: 1,
    },
    infoTitle: {
      fontSize: responsive.fontSize(12),
      color: theme.colors.onSurfaceVariant,
      opacity: 0.7,
    },
    infoText: {
      fontSize: responsive.fontSize(14),
      fontWeight: '500',
      color: theme.colors.onSurfaceVariant,
    },
    deliveryContainer: {
      flex: 1,
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.m),
    },
    deliveryActions: {
      position: 'absolute',
      bottom: 16,
      right: 16,
    },
    deliveryFab: {
      position: 'absolute',
      bottom: 0,
      right: 0,
    },
    deliveryFabSmall: {
      position: 'absolute',
      right: 0,
    },
    mapSection: {
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingBottom: responsive.spacing(theme.spacing.m),
    },
    // Estilos para el bot√≥n de √°rea de cobertura
    deliveryButtonContainer: {
      marginTop: responsive.spacing(theme.spacing.l),
      alignItems: 'center',
    },
    deliveryButton: {
      borderRadius: 12,
      width: '100%',
    },
    deliveryButtonContent: {
      paddingVertical: responsive.spacing(theme.spacing.s),
    },
    deliveryButtonLabel: {
      fontSize: responsive.fontSize(16),
      fontWeight: '500',
    },
    deliveryStatusText: {
      fontSize: responsive.fontSize(12),
      color: theme.colors.onSurfaceVariant,
      marginTop: responsive.spacing(theme.spacing.xs),
      fontStyle: 'italic',
    },
    deliveryStatusWarning: {
      color: theme.colors.error,
    },
    // Estilos para el modal
    deliveryDialog: {
      maxWidth: width * 0.95,
      width: width * 0.95,
      maxHeight: height * 0.9,
      alignSelf: 'center',
      borderRadius: 20,
      backgroundColor: theme.colors.surface,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
      elevation: 8,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 4 },
      shadowOpacity: 0.15,
      shadowRadius: 12,
    },
    deliveryDialogContent: {
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.m),
      paddingBottom: responsive.spacing(theme.spacing.m),
    },
    deliveryMapWrapper: {
      borderRadius: 12,
      padding: responsive.spacing(theme.spacing.xs),
      backgroundColor: theme.colors.surfaceVariant,
    },
    deliveryMapContainer: {
      height: height * 0.65,
      width: '100%',
      borderRadius: 8,
      overflow: 'hidden',
    },
    deliveryDialogActions: {
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingVertical: responsive.spacing(theme.spacing.m),
      paddingBottom: responsive.spacing(theme.spacing.l),
    },
    deliveryDialogButtonsContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      gap: responsive.spacing(theme.spacing.m),
    },
    deliveryDialogButton: {
      flex: 1,
      borderRadius: 12,
    },
    deliveryButtonContent: {
      paddingVertical: responsive.spacing(theme.spacing.s),
    },
    deliveryButtonLabel: {
      fontSize: responsive.fontSize(16),
      fontWeight: '600',
    },
    cancelButtonLabel: {
      fontSize: responsive.fontSize(16),
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    // Estilos para el modal de validaci√≥n
    validationDialog: {
      borderRadius: 24,
      backgroundColor: theme.colors.surface,
      maxWidth: 340,
      width: '85%',
      alignSelf: 'center',
      paddingVertical: 0,
    },
    validationIconContainer: {
      alignItems: 'center',
      marginTop: responsive.spacing(theme.spacing.m),
      marginBottom: responsive.spacing(theme.spacing.s),
    },
    validationIconWrapper: {
      width: responsive.scaleWidth(64),
      height: responsive.scaleWidth(64),
      borderRadius: responsive.scaleWidth(32),
      backgroundColor: theme.colors.errorContainer,
      justifyContent: 'center',
      alignItems: 'center',
    },
    validationTitle: {
      textAlign: 'center',
      fontSize: responsive.fontSize(18),
      fontWeight: '600',
      color: theme.colors.onSurface,
      marginBottom: responsive.spacing(theme.spacing.xs),
      paddingHorizontal: responsive.spacing(theme.spacing.m),
    },
    validationMessage: {
      textAlign: 'center',
      fontSize: responsive.fontSize(15),
      color: theme.colors.onSurface,
      marginBottom: responsive.spacing(theme.spacing.s),
      lineHeight: responsive.fontSize(21),
      paddingHorizontal: responsive.spacing(theme.spacing.s),
    },
    validationHint: {
      textAlign: 'center',
      fontSize: responsive.fontSize(13),
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      lineHeight: responsive.fontSize(18),
      paddingHorizontal: responsive.spacing(theme.spacing.s),
    },
    validationActions: {
      paddingBottom: responsive.spacing(theme.spacing.m),
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.xs),
    },
    validationButton: {
      borderRadius: 12,
      minWidth: 120,
    },
    validationButtonContent: {
      paddingVertical: responsive.spacing(theme.spacing.s),
    },
    validationButtonLabel: {
      fontSize: responsive.fontSize(16),
      fontWeight: '600',
    },
  });

export default RestaurantConfigScreen;

================
File: app/app.config.js
================
export default {
  expo: {
    name: "CloudBite",
    slug: "cloudbite",
    version: "1.0.0",
    orientation: "default",
    icon: "./assets/icon.png",
    userInterfaceStyle: "automatic",
    splash: {
      image: "./assets/splash.png",
      resizeMode: "cover",
      backgroundColor: "#ffffff"
    },
    web: {
      favicon: "./assets/favicon.png"
    },
    assetBundlePatterns: [
      "**/*"
    ],
    extra: {
      eas: {
        projectId: "556b2536-af8e-4b1c-8013-20f9e876d57e"
      }
    },
    plugins: [
      "expo-speech-recognition",
      "expo-audio",
      [
        "expo-build-properties",
        {
          android: {
            compileSdkVersion: 35,
            targetSdkVersion: 34,
            buildToolsVersion: "35.0.0",
            usesCleartextTraffic: process.env.EAS_BUILD_PROFILE !== 'production',
            newArchEnabled: true
          },
          ios: {
            newArchEnabled: true
          }
        }
      ],
      "./plugins/withCustomIcons"
    ],
    android: {
      permissions: [
        "android.permission.INTERNET",
        "android.permission.ACCESS_NETWORK_STATE",
        "android.permission.ACCESS_WIFI_STATE",
        "android.permission.RECORD_AUDIO",
        "android.permission.MODIFY_AUDIO_SETTINGS"
      ],
      package: "com.viefmoon.cloudbite",
      icon: "./assets/icon.png",
      supportsTablet: true,
      googleServicesFile: process.env.GOOGLE_SERVICES_JSON ? "./google-services.json" : undefined,
      networkSecurityConfig: "./android/app/src/main/res/xml/network_security_config.xml"
    },
    ios: {
      infoPlist: {
        NSSpeechRecognitionUsageDescription: "Allow CloudBite to use speech recognition for voice orders.",
        NSMicrophoneUsageDescription: "Allow CloudBite to use the microphone for voice orders."
      },
      bundleIdentifier: "com.viefmoon.cloudbite",
      supportsTablet: true,
      icon: "./assets/icon.png"
    },
    web: {
      favicon: "./assets/favicon.png"
    },
    owner: "viefmoon"
  }
};

================
File: app/src/app/services/apiClient.ts
================
import axios, {
  AxiosError,
  InternalAxiosRequestConfig,
  AxiosResponse,
} from 'axios';
import { create as createApisauceInstance } from 'apisauce';
import EncryptedStorage from '@/app/services/secureStorageService';
import { useAuthStore } from '../store/authStore';
import { ApiError } from '../lib/errors';
import axiosRetry from 'axios-retry';
import { discoveryService } from './discoveryService';
import { useSnackbarStore } from '../store/snackbarStore';
import { API_PATHS } from '../constants/apiPaths';
import { certificateValidator } from './certificateValidator';

const REFRESH_TOKEN_KEY = 'refresh_token';

// Variables para manejar la inicializaci√≥n del cliente
let axiosInstance: any = null;
let apiClient: any = null;
let initializationPromise: Promise<void> | null = null;
let currentBaseURL: string | null = null;

// Funci√≥n para inicializar el cliente con la URL descubierta
async function initializeApiClient(providedUrl?: string) {
  // Si ya est√° inicializado con la misma URL, no reinicializar
  if (apiClient && currentBaseURL && currentBaseURL === providedUrl) {
    return;
  }

  if (initializationPromise && !providedUrl) {
    return initializationPromise;
  }

  initializationPromise = (async () => {
    try {
      const baseURL = providedUrl || (await discoveryService.getApiUrl());

      if (!baseURL) {
        throw new Error('No se pudo obtener la URL del servidor');
      }

      currentBaseURL = baseURL;

      // Validar la seguridad de la conexi√≥n
      try {
        certificateValidator.validateConnection(baseURL);
      } catch (error) {
        console.warn('Advertencia de seguridad:', error.message);
      }

      // Obtener configuraci√≥n de seguridad
      const securityConfig = certificateValidator.getAxiosSecurityConfig();

      // Crear instancia de Axios
      axiosInstance = axios.create({
        baseURL,
        headers: {
          'Cache-Control': 'no-cache',
          Accept: 'application/json',
          'Content-Type': 'application/json',
        },
        timeout: 5000, // Reducido a 5 segundos por defecto
        ...securityConfig, // Aplicar configuraci√≥n de seguridad
      });

      // Configurar retry autom√°tico
      configureAxiosRetry();

      // Configurar interceptores
      configureInterceptors();

      // Crear cliente Apisauce
      apiClient = createApisauceInstance({
        baseURL,
        axiosInstance: axiosInstance as any,
      });

      // Agregar transforms
      addResponseTransforms(apiClient);
    } catch (error) {
      // Limpiar la promesa para permitir reintentos manuales
      initializationPromise = null;
      throw error;
    }
  })();

  return initializationPromise;
}

// Funci√≥n para obtener el cliente inicializado
export async function getApiClient(url?: string) {
  if (!apiClient || (url && url !== currentBaseURL)) {
    await initializeApiClient(url);
  }
  return apiClient;
}

// Funci√≥n para obtener el axios instance directamente (para debugging)
export async function getAxiosInstance() {
  if (!axiosInstance) {
    await initializeApiClient();
  }
  return axiosInstance;
}

// Funci√≥n para reinicializar el cliente (√∫til si cambia la IP del servidor)
export async function reinitializeApiClient(url?: string) {
  axiosInstance = null;
  apiClient = null;
  initializationPromise = null;
  currentBaseURL = null;
  cachedClient = null; // Limpiar tambi√©n el cache del wrapper
  return initializeApiClient(url);
}

// Configurar retry autom√°tico para errores de red
function configureAxiosRetry() {
  if (!axiosInstance) return;

  axiosRetry(axiosInstance, {
    retries: 1,
    retryDelay: () => 500,
    retryCondition: (error: AxiosError) => {
      if (error.code === 'ECONNABORTED' || error.code === 'ETIMEDOUT') {
        return false;
      }
      return (
        error.code === 'ENOTFOUND' ||
        error.code === 'ECONNREFUSED' ||
        error.code === 'ECONNRESET'
      );
    },
    shouldResetTimeout: false,
  });
}

// --- L√≥gica de Refresco de Token (igual que antes) ---
let isRefreshing = false;
let failedQueue: Array<{
  resolve: (token: string) => void;
  reject: (error: Error) => void;
}> = [];

const processQueue = (error: Error | null, token: string | null = null) => {
  const queue = [...failedQueue];
  failedQueue = [];

  queue.forEach((prom) => {
    error ? prom.reject(error) : prom.resolve(token!);
  });
};

async function refreshToken(): Promise<string> {
  try {
    const [currentRefreshToken, authStore] = await Promise.all([
      EncryptedStorage.getItem(REFRESH_TOKEN_KEY),
      Promise.resolve(useAuthStore.getState()),
    ]);

    if (!currentRefreshToken) {
      throw new Error('No refresh token available.');
    }

    // Obtener base URL del cliente o discovery
    const baseURL =
      axiosInstance?.defaults?.baseURL ||
      (await discoveryService.getApiUrl()) ||
      (await initializeApiClient().then(
        () => axiosInstance?.defaults?.baseURL,
      ));

    if (!baseURL) {
      throw new Error('No base URL available');
    }

    const { data } = await axios.post<{ token: string; refreshToken?: string }>(
      `${baseURL}${API_PATHS.AUTH_REFRESH}`,
      {},
      { headers: { Authorization: `Bearer ${currentRefreshToken}` } },
    );

    // Actualizar tokens en paralelo si es necesario
    const updates = [authStore.setAccessToken(data.token)];

    if (data.refreshToken && data.refreshToken !== currentRefreshToken) {
      updates.push(authStore.setRefreshToken(data.refreshToken));
    }

    await Promise.all(updates);

    return data.token;
  } catch (error: any) {
    if (error.response?.status === 401 || error.response?.status === 404) {
      await useAuthStore.getState().logout();
    }
    throw error;
  }
}

// --- Interceptores de Axios ---
function configureInterceptors() {
  if (!axiosInstance) return;

  // 1. Interceptor de Peticiones
  axiosInstance.interceptors.request.use(
    (config: InternalAxiosRequestConfig) => {
      const accessToken = useAuthStore.getState().accessToken;
      if (accessToken && config.url !== API_PATHS.AUTH_REFRESH) {
        config.headers['Authorization'] = `Bearer ${accessToken}`;
      }

      // Configurar timeouts espec√≠ficos seg√∫n el tipo de operaci√≥n
      // Si ya se especific√≥ un timeout en la config, respetarlo
      if (!config.timeout) {
        const timeouts = {
          get: 5000,
          post: config.url?.includes('/files/upload') ? 30000 : 5000,
          put: 5000,
          patch: 5000,
          delete: 5000,
        };

        config.timeout =
          timeouts[config.method as keyof typeof timeouts] || 5000;
      }

      return config;
    },
    (error: any) => Promise.reject(error),
  );

  // 2. Interceptor de Respuestas
  axiosInstance.interceptors.response.use(
    (response: AxiosResponse) => response, // Pasa respuestas exitosas
    async (error: AxiosError) => {
      // Maneja errores
      const originalRequest = error.config as InternalAxiosRequestConfig & {
        _retry?: boolean;
        _skipQueue?: boolean;
      };

      // Detectar errores de red
      if (!error.response) {
        // Crear error m√°s espec√≠fico
        let specificError: Error;

        if (error.code === 'ECONNABORTED' || error.code === 'ETIMEDOUT') {
          // Error de timeout - el servidor existe pero no responde
          specificError = new Error('El servidor no responde');
          (specificError as any).code = 'SERVER_TIMEOUT';
        } else if (error.code === 'ECONNREFUSED') {
          // Conexi√≥n rechazada - el servidor est√° apagado
          specificError = new Error('El servidor est√° apagado o no accesible');
          (specificError as any).code = 'SERVER_DOWN';
        } else if (
          error.message === 'Network Error' ||
          error.code === 'ENETUNREACH'
        ) {
          // Error de red - no se puede alcanzar el servidor
          specificError = new Error(
            'No se pudo encontrar el servidor CloudBite',
          );
          (specificError as any).code = 'SERVER_NOT_FOUND';
        } else {
          // Error gen√©rico de red
          specificError = new Error('Error de conexi√≥n de red');
          (specificError as any).code = 'NETWORK_ERROR';
        }

        // Asignar el error espec√≠fico al error original
        (error as any).specificError = specificError;

        // No mostrar snackbar aqu√≠, dejar que el componente lo maneje
        return Promise.reject(error);
      }

      // No intentar renovar si:
      // 1. No es un error 401
      // 2. Es la propia petici√≥n de refresh
      // 3. Es la petici√≥n de verificaci√≥n de token (/auth/me)
      // 4. Ya se intent√≥ renovar antes
      if (
        error.response?.status !== 401 ||
        originalRequest.url === API_PATHS.AUTH_REFRESH ||
        originalRequest.url?.includes('/auth/me') ||
        originalRequest._retry
      ) {
        const apiError = ApiError.fromAxiosError(error);
        return Promise.reject(apiError);
      }

      // --- Manejo del 401 ---
      if (isRefreshing) {
        // Encolar petici√≥n para reintentar despu√©s del refresh
        return new Promise((resolve, reject) => {
          failedQueue.push({
            resolve: async (token) => {
              originalRequest.headers['Authorization'] = `Bearer ${token}`;
              originalRequest._retry = true;
              try {
                const response = await axiosInstance(originalRequest);
                resolve(response);
              } catch (err) {
                reject(ApiError.fromAxiosError(err as AxiosError));
              }
            },
            reject,
          });
        });
      }

      isRefreshing = true;
      originalRequest._retry = true;

      try {
        const newAccessToken = await refreshToken();
        processQueue(null, newAccessToken);
        originalRequest.headers['Authorization'] = `Bearer ${newAccessToken}`;
        return axiosInstance(originalRequest);
      } catch (refreshError: any) {
        processQueue(refreshError, null);

        // Si el error es 401 o 404, ya se habr√° cerrado la sesi√≥n en refreshToken()
        // Solo necesitamos rechazar la promesa
        return Promise.reject(ApiError.fromRefreshError(refreshError));
      } finally {
        isRefreshing = false;
      }
    },
  );
}

// Funci√≥n para agregar transforms al cliente
function addResponseTransforms(client: any) {
  client.addResponseTransform((response: any) => {
    // Solo mostrar snackbar para errores de red reales (no errores HTTP)
    const isNetworkError =
      response.problem === 'NETWORK_ERROR' ||
      response.problem === 'TIMEOUT_ERROR' ||
      response.problem === 'CONNECTION_ERROR';

    const isHttpError = response.status && response.status >= 400;

    if (isNetworkError && !isHttpError) {
      const showSnackbar = useSnackbarStore.getState().showSnackbar;

      let errorMessage = 'Sin conexi√≥n al servidor';
      const method =
        response.config?.method || response.originalError?.config?.method;

      if (method === 'POST') {
        errorMessage = 'No se puede guardar sin conexi√≥n';
      } else if (method === 'PUT') {
        errorMessage = 'No se puede actualizar sin conexi√≥n';
      } else if (method === 'DELETE') {
        errorMessage = 'No se puede eliminar sin conexi√≥n';
      } else if (method === 'GET') {
        errorMessage = 'No se pueden cargar los datos sin conexi√≥n';
      }

      // Usar setTimeout para asegurar que se muestre
      setTimeout(() => {
        showSnackbar({
          message: errorMessage,
          type: 'error',
          duration: 5000,
        });
      }, 100);
    }

    // Si la respuesta no es ok y tenemos un error original del interceptor
    if (!response.ok && response.originalError instanceof ApiError) {
      // Preservar el ApiError original
      (response as any).apiError = response.originalError;
    }
  });
}

// Cache para el cliente inicializado
let cachedClient: any = null;

// Funci√≥n wrapper que devuelve el cliente real
const createApiClientWrapper = () => {
  const handler = {
    get(_target: any, prop: string) {
      // Retornar una funci√≥n que inicializa el cliente cuando se necesita
      return async (...args: any[]) => {
        if (!cachedClient) {
          cachedClient = await getApiClient();
        }

        const method = cachedClient[prop];
        if (typeof method === 'function') {
          return method.apply(cachedClient, args);
        }

        return method;
      };
    },
  };

  return new Proxy({}, handler);
};

const apiClientProxy = createApiClientWrapper();

export default apiClientProxy;

================
File: app/src/modules/kitchen/components/OrderCard.tsx
================
import React, { useRef, useState, useEffect } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  Animated,
  Pressable,
  Vibration,
  Platform,
} from 'react-native';
import { Card, Text, Divider, Surface, IconButton } from 'react-native-paper';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';
import { useAppTheme } from '@/app/styles/theme';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import {
  KitchenOrder,
  OrderType,
  PreparationStatus,
  PreparationScreenStatus,
} from '../types/kitchen.types';
import { OrderItemRow } from './OrderItemRow';
import { useResponsive } from '@/app/hooks/useResponsive';
import { Swipeable } from 'react-native-gesture-handler';
import { OrderHistoryModal } from '@/modules/shared/components/OrderHistoryModal';
import { useMarkItemPrepared } from '../hooks/useKitchenOrders';

interface OrderCardProps {
  order: KitchenOrder;
  onStartPreparation?: (orderId: string) => void;
  onCancelPreparation?: (orderId: string) => void;
  onCompletePreparation?: (orderId: string) => void;
  onSwipeStart?: () => void;
  onSwipeEnd?: () => void;
}

export const OrderCard: React.FC<OrderCardProps> = ({
  order,
  onStartPreparation,
  onCancelPreparation,
  onCompletePreparation,
  onSwipeStart,
  onSwipeEnd,
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = createStyles(responsive, theme);
  const [isSwipeable, setIsSwipeable] = React.useState(false);
  const [showHistory, setShowHistory] = useState(false);
  const swipeableRef = useRef<Swipeable>(null);
  const [isPressing, setIsPressing] = useState(false);
  const longPressTimer = useRef<NodeJS.Timeout | null>(null);
  const animatedValue = useRef(new Animated.Value(0)).current;
  const markItemPrepared = useMarkItemPrepared();

  const getOrderTypeColor = () => {
    switch (order.orderType) {
      case OrderType.DELIVERY:
        return theme.colors.error;
      case OrderType.TAKE_AWAY:
        return '#00ACC1'; // Cyan/Turquesa
      case OrderType.DINE_IN:
        return theme.colors.primary;
      default:
        return theme.colors.surface;
    }
  };

  const getOrderTypeLabel = () => {
    switch (order.orderType) {
      case OrderType.DELIVERY:
        return 'DOMICILIO';
      case OrderType.TAKE_AWAY:
        return 'PARA LLEVAR';
      case OrderType.DINE_IN:
        return 'MESA';
      default:
        return '';
    }
  };

  const getOrderTypeBackgroundColor = () => {
    switch (order.orderType) {
      case OrderType.DELIVERY:
        return '#FFEBEE'; // Rojo muy claro
      case OrderType.TAKE_AWAY:
        return '#E0F2F1'; // Cyan/Turquesa muy claro
      case OrderType.DINE_IN:
        return '#E3F2FD'; // Azul muy claro
      default:
        return theme.colors.surfaceVariant;
    }
  };

  const getOrderTypeTextColor = () => {
    switch (order.orderType) {
      case OrderType.DELIVERY:
        return '#C62828'; // Rojo oscuro
      case OrderType.TAKE_AWAY:
        return '#00838F'; // Cyan/Turquesa oscuro
      case OrderType.DINE_IN:
        return '#1565C0'; // Azul oscuro
      default:
        return theme.colors.onSurfaceVariant;
    }
  };

  const getScreenStatusColor = (status: PreparationScreenStatus) => {
    switch (status) {
      case PreparationScreenStatus.READY:
        return theme.colors.success;
      case PreparationScreenStatus.IN_PREPARATION:
        return '#FF6B35';
      default:
        return '#9C27B0';
    }
  };

  const getOrderTypeIcon = () => {
    switch (order.orderType) {
      case OrderType.DELIVERY:
        return 'moped'; // O 'bike', 'motorbike'
      case OrderType.TAKE_AWAY:
        return 'shopping-outline'; // O 'bag-checked', 'package-variant'
      case OrderType.DINE_IN:
        return 'silverware-fork-knife'; // O 'food', 'table-chair'
      default:
        return 'help-circle-outline';
    }
  };

  // Calcular el estado de preparaci√≥n basado en myScreenStatus
  const getOrderPreparationStatus = () => {
    // Primero verificar si hay items
    if (!order.items || order.items.length === 0) {
      return {
        label: 'Sin items',
        color: '#E0E0E0',
        textColor: '#424242',
        borderColor: '#BDBDBD',
      };
    }

    const myItems = order.items.filter((item) => item.belongsToMyScreen);
    if (myItems.length === 0) {
      return {
        label: 'Sin items asignados',
        color: '#E0E0E0',
        textColor: '#424242',
        borderColor: '#BDBDBD',
      };
    }

    // Usar el estado de mi pantalla espec√≠fica
    switch (order.myScreenStatus) {
      case PreparationScreenStatus.READY:
        return {
          label: 'Lista',
          color: '#4CAF50', // Verde
          textColor: '#FFFFFF',
          borderColor: null,
        };

      case PreparationScreenStatus.IN_PREPARATION:
        return {
          label: 'En preparaci√≥n',
          color: '#FF6B35', // Naranja
          textColor: '#FFFFFF',
          borderColor: null,
        };

      case PreparationScreenStatus.PENDING:
      default:
        return {
          label: 'Pendiente',
          color: '#9C27B0', // P√∫rpura
          textColor: '#FFFFFF',
          borderColor: null,
        };
    }
  };

  const hasOrderDetails = () => {
    switch (order.orderType) {
      case OrderType.DELIVERY:
        return !!order.deliveryAddress;
      case OrderType.TAKE_AWAY:
        return !!order.receiptName;
      case OrderType.DINE_IN:
        return !!(order.areaName || order.tableName);
      default:
        return false;
    }
  };

  const orderStatus = getOrderPreparationStatus();

  // Verificar si mi pantalla est√° en preparaci√≥n
  const isOrderInPreparation =
    order.myScreenStatus === PreparationScreenStatus.IN_PREPARATION;

  const handleToggleItemPrepared = (itemId: string, currentStatus: boolean) => {
    markItemPrepared.mutate({
      itemId,
      isPrepared: !currentStatus,
    });
  };

  // Determinar qu√© acciones de swipe est√°n disponibles basado en myScreenStatus
  const getSwipeActions = () => {
    const rightAction = (() => {
      // Solo permitir iniciar preparaci√≥n si mi pantalla est√° PENDING
      if (order.myScreenStatus === PreparationScreenStatus.PENDING) {
        return {
          type: 'start',
          color: '#FF6B35', // Naranja
          textColor: '#FFFFFF',
          icon: 'chef-hat',
          text: 'En Preparaci√≥n',
        };
      }
      return null;
    })();

    const leftAction = (() => {
      // Permitir regresar si mi pantalla est√° en preparaci√≥n o lista
      if (
        order.myScreenStatus === PreparationScreenStatus.IN_PREPARATION ||
        order.myScreenStatus === PreparationScreenStatus.READY
      ) {
        return {
          type: 'cancel',
          color: '#9C27B0', // P√∫rpura
          textColor: '#FFFFFF',
          icon: 'arrow-left',
          text: 'Regresar',
        };
      }
      return null;
    })();

    return { rightAction, leftAction };
  };

  const swipeActions = getSwipeActions();

  // Verificar si la orden puede hacer swipe
  React.useEffect(() => {
    setIsSwipeable(!!swipeActions.rightAction || !!swipeActions.leftAction);
  }, [swipeActions.rightAction, swipeActions.leftAction]);

  // Renderizar las acciones del swipe hacia la derecha (lo que aparece detr√°s)
  const renderRightActions = () => {
    if (!swipeActions.rightAction) return null;

    return (
      <View
        style={[
          styles.swipeAction,
          { backgroundColor: swipeActions.rightAction.color },
        ]}
      >
        <Icon
          name={swipeActions.rightAction.icon}
          size={24}
          color={swipeActions.rightAction.textColor}
        />
        <Text
          style={[
            styles.swipeText,
            { color: swipeActions.rightAction.textColor },
          ]}
        >
          {swipeActions.rightAction.text}
        </Text>
      </View>
    );
  };

  // Renderizar las acciones del swipe hacia la izquierda
  const renderLeftActions = () => {
    if (!swipeActions.leftAction) return null;

    return (
      <View
        style={[
          styles.swipeAction,
          { backgroundColor: swipeActions.leftAction.color },
        ]}
      >
        <Text
          style={[
            styles.swipeText,
            { color: swipeActions.leftAction.textColor },
          ]}
        >
          {swipeActions.leftAction.text}
        </Text>
        <Icon
          name={swipeActions.leftAction.icon}
          size={24}
          color={swipeActions.leftAction.textColor}
        />
      </View>
    );
  };

  // Verificar si la orden puede ser marcada como lista con long press
  const canMarkAsReady = () => {
    // Solo se puede marcar como lista si mi pantalla est√° en preparaci√≥n
    return (
      order.myScreenStatus === PreparationScreenStatus.IN_PREPARATION &&
      onCompletePreparation
    );
  };

  // Verificar si la orden puede regresar a en preparaci√≥n con long press
  const canReturnToInProgress = () => {
    // Solo permitir long press para regresar si mi pantalla est√° EN PREPARACI√ìN (no READY)
    // Si est√° READY, debe usar el swipe
    return (
      order.myScreenStatus === PreparationScreenStatus.IN_PREPARATION &&
      onCancelPreparation
    );
  };

  // Manejar el inicio del long press
  const handlePressIn = () => {
    const canComplete = canMarkAsReady();
    const canReturn = canReturnToInProgress();

    if (!canComplete && !canReturn) return;

    // Limpiar cualquier timer o animaci√≥n previa
    if (longPressTimer.current) {
      clearTimeout(longPressTimer.current);
      if ((longPressTimer.current as any).interval) {
        clearInterval((longPressTimer.current as any).interval);
      }
      longPressTimer.current = null;
    }

    // Detener cualquier animaci√≥n en curso y resetear
    animatedValue.stopAnimation();
    animatedValue.setValue(0);

    // Vibraci√≥n suave al iniciar
    Vibration.vibrate(10);

    setIsPressing(true);

    // Iniciar animaci√≥n
    Animated.timing(animatedValue, {
      toValue: 1,
      duration: 2000,
      useNativeDriver: false,
    }).start();

    // Timer para completar despu√©s de 2 segundos
    longPressTimer.current = setTimeout(() => {
      // Vibraci√≥n de √©xito
      Vibration.vibrate([0, 50, 100, 50]);

      if (canComplete && onCompletePreparation) {
        onCompletePreparation(order.id);
      } else if (canReturn && onCancelPreparation) {
        onCancelPreparation(order.id);
      }

      setIsPressing(false);
      Animated.timing(animatedValue, {
        toValue: 0,
        duration: 200,
        useNativeDriver: false,
      }).start();
    }, 2000);
  };

  // Manejar cuando se suelta la presi√≥n
  const handlePressOut = () => {
    if (longPressTimer.current) {
      clearTimeout(longPressTimer.current);
      longPressTimer.current = null;
    }

    setIsPressing(false);

    // Detener cualquier animaci√≥n en curso
    animatedValue.stopAnimation();

    // Resetear el valor animado a 0
    animatedValue.setValue(0);
  };

  // Limpiar timer al desmontar
  useEffect(() => {
    return () => {
      if (longPressTimer.current) {
        clearTimeout(longPressTimer.current);
      }
    };
  }, []);

  // Manejar cuando se completa el swipe hacia la derecha
  const handleRightSwipeComplete = () => {
    if (!swipeActions.rightAction) return;

    switch (swipeActions.rightAction.type) {
      case 'start':
        if (onStartPreparation) onStartPreparation(order.id);
        break;
    }

    // Cerrar el swipeable despu√©s de ejecutar la acci√≥n
    swipeableRef.current?.close();
  };

  // Manejar cuando se completa el swipe hacia la izquierda
  const handleLeftSwipeComplete = () => {
    if (!swipeActions.leftAction) return;

    if (swipeActions.leftAction.type === 'cancel') {
      if (onCancelPreparation) onCancelPreparation(order.id);
    }

    // Cerrar el swipeable despu√©s de ejecutar la acci√≥n
    swipeableRef.current?.close();
  };

  return (
    <Surface
      style={[styles.card, { backgroundColor: theme.colors.surface }]}
      elevation={1}
    >
      <View style={styles.cardContent}>
        {/* Header */}
        {isSwipeable ? (
          <Swipeable
            ref={swipeableRef}
            renderRightActions={renderRightActions}
            renderLeftActions={renderLeftActions}
            onSwipeableWillOpen={() => onSwipeStart && onSwipeStart()}
            onSwipeableWillClose={() => onSwipeEnd && onSwipeEnd()}
            onSwipeableRightOpen={handleRightSwipeComplete}
            onSwipeableLeftOpen={handleLeftSwipeComplete}
            overshootRight={false}
            overshootLeft={false}
            friction={1.2}
            rightThreshold={50}
            leftThreshold={50}
            activationDistance={15}
          >
            <Pressable
              onPressIn={handlePressIn}
              onPressOut={handlePressOut}
              delayLongPress={0}
            >
              <View
                style={[
                  styles.header,
                  styles.headerSwipeable,
                  { backgroundColor: getOrderTypeColor() },
                ]}
              >
                <View style={styles.headerLeft}>
                  <Text style={[styles.orderNumber, styles.headerText]}>
                    #{order.shiftOrderNumber}
                  </Text>
                  {hasOrderDetails() && (
                    <Text
                      style={[styles.headerDetails, styles.headerText]}
                      numberOfLines={2}
                    >
                      {(() => {
                        switch (order.orderType) {
                          case OrderType.DELIVERY:
                            return `üìç ${order.deliveryAddress}${order.deliveryPhone ? `\nüì± ${order.deliveryPhone}` : ''}`;
                          case OrderType.TAKE_AWAY:
                            return `üë§ ${order.receiptName}${order.customerPhone ? `\nüì± ${order.customerPhone}` : ''}`;
                          case OrderType.DINE_IN:
                            return `ü™ë ${order.areaName} - ${order.tableName}`;
                          default:
                            return '';
                        }
                      })()}
                    </Text>
                  )}

                  {/* Badge de WhatsApp */}
                  {order.isFromWhatsApp && (
                    <View style={styles.whatsappBadgeContainer}>
                      <View style={styles.whatsappBadge}>
                        <Icon
                          source="whatsapp"
                          size={12}
                          color={theme.colors.surface}
                        />
                      </View>
                    </View>
                  )}
                </View>
                <View style={[styles.headerRight, styles.headerRightSwipeable]}>
                  <View style={[styles.typeChip, styles.typeChipSwipeable]}>
                    <Icon
                      name={getOrderTypeIcon()}
                      size={responsive.isWeb ? 18 : 14}
                      color={theme.colors.surface}
                      style={styles.typeChipIcon}
                    />
                    <Text style={[styles.typeChipText, styles.headerText]}>
                      {getOrderTypeLabel()}
                    </Text>
                  </View>
                  <View
                    style={[
                      styles.statusChip,
                      styles.statusChipSwipeable,
                      {
                        backgroundColor: orderStatus.color,
                        borderWidth:
                          orderStatus.label === 'En progreso' ? 1 : 0,
                        borderColor: theme.colors.outline,
                      },
                    ]}
                  >
                    <Text
                      style={[
                        styles.statusChipText,
                        {
                          color:
                            orderStatus.label === 'En progreso'
                              ? theme.colors.onSurface
                              : theme.colors.surface,
                        },
                      ]}
                    >
                      {orderStatus.label}
                    </Text>
                  </View>
                  <Text style={[styles.headerTime, styles.headerText]}>
                    {format(new Date(order.createdAt), 'HH:mm', { locale: es })}
                  </Text>
                </View>
              </View>
              {/* Indicador de progreso del long press */}
              {isPressing && (canMarkAsReady() || canReturnToInProgress()) && (
                <View style={styles.progressBarContainer}>
                  <Animated.View
                    style={[
                      styles.progressBar,
                      {
                        width: animatedValue.interpolate({
                          inputRange: [0, 1],
                          outputRange: ['0%', '100%'],
                        }),
                        backgroundColor: canMarkAsReady()
                          ? theme.colors.success
                          : '#FF6B35',
                      },
                    ]}
                  />
                </View>
              )}
            </Pressable>
          </Swipeable>
        ) : (
          <View
            style={[
              styles.header,
              styles.headerSwipeable,
              { backgroundColor: getOrderTypeColor() },
            ]}
          >
            <View style={styles.headerLeft}>
              <Text style={[styles.orderNumber, styles.headerText]}>
                #{order.shiftOrderNumber}
              </Text>
              {hasOrderDetails() && (
                <Text
                  style={[styles.headerDetails, styles.headerText]}
                  numberOfLines={2}
                >
                  {(() => {
                    switch (order.orderType) {
                      case OrderType.DELIVERY:
                        return `üìç ${order.deliveryAddress}${order.deliveryPhone ? `\nüì± ${order.deliveryPhone}` : ''}`;
                      case OrderType.TAKE_AWAY:
                        return `üë§ ${order.receiptName}${order.customerPhone ? `\nüì± ${order.customerPhone}` : ''}`;
                      case OrderType.DINE_IN:
                        return `ü™ë ${order.areaName} - ${order.tableName}`;
                      default:
                        return '';
                    }
                  })()}
                </Text>
              )}
            </View>
            <View style={[styles.headerRight, styles.headerRightNormal]}>
              <View
                style={[
                  styles.typeChip,
                  styles.typeChipNormal,
                  { backgroundColor: getOrderTypeBackgroundColor() },
                ]}
              >
                <Icon
                  name={getOrderTypeIcon()}
                  size={responsive.isTablet ? 13 : 14}
                  color={getOrderTypeTextColor()}
                  style={styles.typeChipIcon}
                />
                <Text
                  style={[
                    styles.typeChipText,
                    { color: getOrderTypeTextColor() },
                  ]}
                >
                  {getOrderTypeLabel()}
                </Text>
              </View>
              <View
                style={[
                  styles.statusChip,
                  {
                    backgroundColor: orderStatus.color,
                    borderWidth: orderStatus.borderColor ? 1 : 0,
                    borderColor: orderStatus.borderColor || 'transparent',
                    marginBottom: 2,
                  },
                ]}
              >
                <Text
                  style={[
                    styles.statusChipText,
                    { color: orderStatus.textColor },
                  ]}
                >
                  {orderStatus.label}
                </Text>
              </View>
              <Text
                style={[styles.headerTime, { color: theme.colors.surface }]}
              >
                {format(new Date(order.createdAt), 'HH:mm', { locale: es })}
              </Text>
            </View>
          </View>
        )}

        {/* Order Notes - Solo mostrar si hay notas */}
        {order.orderNotes && (
          <>
            <View
              style={[
                styles.details,
                { backgroundColor: theme.colors.errorContainer },
              ]}
            >
              <Text
                variant="bodyMedium"
                style={[styles.notes, { color: theme.colors.onErrorContainer }]}
              >
                üìù {order.orderNotes}
              </Text>
            </View>
            <Divider style={styles.divider} />
          </>
        )}

        {/* Screen Statuses - Mostrar el estado de otras pantallas */}
        {order.screenStatuses && order.screenStatuses.length > 1 && (
          <>
            <View
              style={[
                styles.screenStatusContainer,
                {
                  backgroundColor: theme.colors.surfaceVariant,
                  paddingVertical: 8,
                  paddingHorizontal: 8,
                },
              ]}
            >
              <ScrollView horizontal showsHorizontalScrollIndicator={false}>
                <View style={[styles.screenStatusList, { gap: 8 }]}>
                  {order.screenStatuses.map((screenStatus) => (
                    <View
                      key={screenStatus.screenId}
                      style={[
                        styles.screenStatusItem,
                        {
                          backgroundColor: (() => {
                            switch (screenStatus.status) {
                              case PreparationScreenStatus.READY:
                                return '#4CAF50';
                              case PreparationScreenStatus.IN_PREPARATION:
                                return '#FF6B35';
                              default:
                                return '#9C27B0';
                            }
                          })(),
                        },
                      ]}
                    >
                      <Text style={styles.screenStatusText}>
                        {screenStatus.screenName}
                      </Text>
                    </View>
                  ))}
                </View>
              </ScrollView>
            </View>
            <Divider style={styles.divider} />
          </>
        )}

        {/* Items */}
        <View style={styles.itemsWrapper}>
          {order.items && order.items.length > 0 ? (
            <ScrollView
              style={styles.itemsContainer}
              showsVerticalScrollIndicator={true}
              nestedScrollEnabled={true}
            >
              {(() => {
                // Separar items en grupos
                const myScreenItems = order.items
                  .map((item, originalIndex) => ({ item, originalIndex }))
                  .filter(({ item }) => item.belongsToMyScreen);

                const otherScreenItems = order.items
                  .map((item, originalIndex) => ({ item, originalIndex }))
                  .filter(({ item }) => !item.belongsToMyScreen);

                // Ordenar items de mi pantalla
                const sortedMyScreenItems = myScreenItems.sort((a, b) => {
                  // Los items preparados mantienen su posici√≥n relativa
                  const aIsPrepared =
                    a.item.preparationStatus === PreparationStatus.READY;
                  const bIsPrepared =
                    b.item.preparationStatus === PreparationStatus.READY;

                  // Si ambos est√°n preparados o ambos no lo est√°n, mantener orden original
                  if (aIsPrepared === bIsPrepared) {
                    return a.originalIndex - b.originalIndex;
                  }

                  // Si uno est√° preparado y el otro no, mantener el orden original
                  return a.originalIndex - b.originalIndex;
                });

                // Mantener orden original para items de otras pantallas
                const sortedOtherScreenItems = otherScreenItems;

                // Combinar: primero los de mi pantalla, luego los de otras
                return [...sortedMyScreenItems, ...sortedOtherScreenItems];
              })().map(({ item }, index) => (
                <OrderItemRow
                  key={`${item.id}-${index}`}
                  item={item}
                  onTogglePrepared={handleToggleItemPrepared}
                  isOrderInPreparation={isOrderInPreparation}
                />
              ))}
            </ScrollView>
          ) : (
            <View style={styles.emptyItemsContainer}>
              <Text variant="bodyLarge" style={styles.emptyItemsText}>
                No hay productos para mostrar
              </Text>
            </View>
          )}
        </View>

        {/* Bot√≥n flotante con posicionamiento fijo */}
        <View style={styles.floatingButtonContainer}>
          <IconButton
            icon="file-document-multiple-outline"
            size={responsive.isWeb ? 32 : 28}
            iconColor={theme.colors.surface}
            style={[
              styles.floatingButton,
              {
                backgroundColor: theme.colors.primary,
                width: responsive.isWeb ? 56 : 48,
                height: responsive.isWeb ? 56 : 48,
                borderRadius: responsive.isWeb ? 28 : 24,
              },
            ]}
            onPress={() => setShowHistory(true)}
          />
        </View>
      </View>

      {/* Modal de historial */}
      <OrderHistoryModal
        visible={showHistory}
        onDismiss={() => setShowHistory(false)}
        orderId={order.id}
        orderNumber={order.shiftOrderNumber}
        orderData={order}
      />
    </Surface>
  );
};

// Crear estilos responsive
const createStyles = (responsive: any, theme: any) =>
  StyleSheet.create({
    card: {
      width: '100%',
      height: '100%',
      maxHeight:
        responsive.height -
        responsive.dimensions.headerHeight -
        responsive.spacing.s,
      borderRadius: theme.roundness / 2,
      borderWidth: 0.5,
      borderColor: 'rgba(0,0,0,0.05)',
    },
    cardContent: {
      flex: 1,
      display: 'flex',
      flexDirection: 'column',
      position: 'relative',
    },
    header: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
      paddingHorizontal: responsive.isWeb
        ? responsive.spacing.l
        : responsive.spacing.m,
      paddingVertical: responsive.isWeb
        ? responsive.spacing.m
        : responsive.spacing.s,
      borderTopLeftRadius: theme.roundness,
      borderTopRightRadius: theme.roundness,
      minHeight: responsive.isWeb
        ? 80
        : responsive.getResponsiveDimension(50, 60),
    },
    headerLeft: {
      flex: 1,
      flexDirection: 'column',
      gap: responsive.spacing.xxxs,
    },
    headerTopRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.spacing.xs,
    },
    headerDetails: {
      fontSize: responsive.isWeb ? 16 : responsive.isTablet ? 12 : 13,
      lineHeight: responsive.isWeb ? 22 : responsive.isTablet ? 16 : 18,
      opacity: 0.95,
      marginTop: responsive.spacing.xxxs,
      fontWeight: '500',
    },
    headerRight: {
      alignItems: 'flex-end',
      gap: responsive.spacing.xs,
      marginLeft: responsive.spacing.xs,
    },
    orderNumber: {
      fontWeight: 'bold',
      fontSize: responsive.isWeb ? 24 : responsive.isTablet ? 18 : 20,
      lineHeight: responsive.isWeb ? 32 : responsive.isTablet ? 24 : 28,
    },
    typeChip: {
      paddingHorizontal: responsive.isWeb
        ? responsive.spacing.m
        : responsive.spacing.s,
      paddingVertical: responsive.isWeb ? 6 : 4,
      minHeight: responsive.isWeb ? 36 : 28,
      borderRadius: theme.roundness / 2,
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      alignSelf: 'flex-end',
      marginBottom: responsive.spacing.xxxs,
    },
    typeChipText: {
      fontSize: responsive.isWeb ? 14 : responsive.isTablet ? 11 : 12,
      fontWeight: '700',
      letterSpacing: 0.4,
      textAlign: 'center',
      textAlignVertical: 'center',
      lineHeight: responsive.isTablet ? 16 : 18,
      includeFontPadding: false,
    },
    headerTime: {
      fontWeight: '500',
      fontSize: responsive.isWeb ? 16 : responsive.isTablet ? 12 : 13,
    },
    statusChip: {
      paddingHorizontal: responsive.isWeb
        ? responsive.spacing.m
        : responsive.spacing.xs,
      paddingVertical: responsive.isWeb ? 6 : 4,
      minHeight: responsive.isWeb ? 36 : 28,
      borderRadius: theme.roundness / 2,
      alignItems: 'center',
      justifyContent: 'center',
      alignSelf: 'flex-end',
      marginBottom: responsive.spacing.xxxs,
    },
    statusChipText: {
      fontSize: responsive.isWeb ? 15 : responsive.isTablet ? 12 : 13,
      fontWeight: '600',
      letterSpacing: 0.3,
      textAlign: 'center',
      textAlignVertical: 'center',
      lineHeight: responsive.isWeb ? 22 : responsive.isTablet ? 18 : 20,
      includeFontPadding: false,
    },
    details: {
      paddingHorizontal: responsive.isWeb
        ? responsive.spacing.m
        : responsive.spacing.s,
      paddingVertical: responsive.isWeb
        ? responsive.spacing.s
        : responsive.spacing.xs,
    },
    detailText: {
      marginBottom: 0,
      fontSize: responsive.isWeb ? 15 : responsive.isTablet ? 11 : 12,
      lineHeight: responsive.isWeb ? 20 : responsive.isTablet ? 16 : 14,
    },
    notesContainer: {
      marginTop: responsive.spacing.xxs,
      padding: responsive.spacing.xxs,
      borderRadius: theme.roundness / 2,
    },
    notes: {
      fontStyle: 'italic',
      fontSize: responsive.isTablet ? 11 : 12,
      lineHeight: responsive.isTablet ? 16 : 14,
    },
    itemsWrapper: {
      flex: 1,
      minHeight: responsive.isTablet ? 100 : 60,
    },
    itemsContainer: {
      flex: 1,
    },
    emptyItemsContainer: {
      padding: responsive.spacing.s,
      alignItems: 'center',
      justifyContent: 'center',
      minHeight: responsive.getResponsiveDimension(60, 80),
    },
    swipeAction: {
      width: 120,
      height: '100%',
      justifyContent: 'center',
      alignItems: 'center',
      flexDirection: 'row',
      gap: responsive.spacing.xs,
      paddingHorizontal: responsive.spacing.s,
    },
    swipeText: {
      fontWeight: 'bold',
      fontSize: responsive.fontSize.s,
    },
    screenStatusContainer: {
      paddingVertical: responsive.spacing.s,
      paddingHorizontal: responsive.spacing.s,
      paddingRight: responsive.spacing.m,
    },
    screenStatusList: {
      flexDirection: 'row',
      gap: responsive.spacing.s,
      paddingHorizontal: responsive.spacing.xs,
    },
    screenStatusItem: {
      paddingHorizontal: responsive.spacing.s,
      paddingVertical: responsive.spacing.xs,
      borderRadius: theme.roundness / 2,
      minHeight: 24,
      justifyContent: 'center',
    },
    screenStatusText: {
      fontSize: responsive.fontSize.xs,
      fontWeight: '600',
      color: '#FFFFFF',
    },
    whatsappBadgeContainer: {
      marginTop: 4,
      alignItems: 'flex-start',
    },
    whatsappBadge: {
      width: 24,
      height: 24,
      borderRadius: 12,
      alignItems: 'center',
      justifyContent: 'center',
      elevation: 2,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 1 },
      shadowOpacity: 0.2,
      shadowRadius: 2,
      backgroundColor: '#25D366',
    },
    // Estilos adicionales para eliminar inline styles
    headerText: {
      color: theme.colors.surface,
    },
    headerSwipeable: {
      paddingHorizontal: responsive.spacing.s,
    },
    headerRightSwipeable: {
      marginLeft: responsive.spacing.xs,
    },
    headerRightNormal: {
      marginLeft: responsive.spacing.m,
    },
    typeChipSwipeable: {
      backgroundColor: 'rgba(255, 255, 255, 0.2)',
      marginTop: 2,
      marginBottom: 3,
    },
    typeChipNormal: {
      marginTop: 2,
      marginBottom: 3,
    },
    typeChipIcon: {
      marginRight: 4,
    },
    statusChipSwipeable: {
      marginBottom: 2,
    },
    statusChipNormal: {
      marginBottom: 2,
    },
    progressBarContainer: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      height: 20,
      backgroundColor: 'rgba(0, 0, 0, 0.2)',
      overflow: 'hidden',
    },
    progressBar: {
      height: '100%',
    },
    notesContainer: {
      backgroundColor: theme.colors.errorContainer,
    },
    notesText: {
      color: theme.colors.onErrorContainer,
    },
    divider: {
      backgroundColor: theme.colors.outlineVariant,
      height: 0.5,
    },
    screenStatusContainerStyle: {
      backgroundColor: theme.colors.surfaceVariant,
      paddingVertical: responsive.spacing.s,
      paddingHorizontal: responsive.spacing.s,
    },
    emptyItemsText: {
      color: theme.colors.onSurfaceVariant,
      opacity: 0.6,
    },
    floatingButtonContainer: {
      position: 'absolute',
      bottom: 10,
      right: 10,
      width: 48,
      height: 48,
    },
    floatingButton: {
      elevation: 6,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 3 },
      shadowOpacity: 0.3,
      shadowRadius: 4.65,
      margin: 0,
      opacity: 0.7,
    },
  });

================
File: app/src/app/navigation/AppDrawerNavigator.tsx
================
import React from 'react';
import {
  StyleSheet,
  StatusBar,
  TouchableOpacity,
  View,
  Text,
} from 'react-native';
import { createDrawerNavigator } from '@react-navigation/drawer';
import { MenuStackNavigator } from '../../modules/menu/navigation/MenuStackNavigator';
import ModifiersStackNavigator from '../../modules/modifiers/navigation/ModifiersStackNavigator';
import PreparationScreensStackNavigator from '../../modules/preparationScreens/navigation/PreparationScreensStackNavigator';
import AreasTablesStackNavigator from '../../modules/areasTables/navigation/AreasTablesStackNavigator';
import OrdersStackNavigator from './OrdersStackNavigator';
import PrintersStackNavigator from '../../modules/printers/navigation/PrintersStackNavigator';
import { ReceiptsStackNavigator } from '../../modules/receipts/navigation/ReceiptsStackNavigator';
import { AvailabilityStackNavigator } from '../../modules/availability/navigation/AvailabilityStackNavigator';
import { OrderFinalizationStackNavigator } from '../../modules/orderFinalization/navigation/OrderFinalizationStackNavigator';
import { RestaurantConfigStackNavigator } from '../../modules/restaurantConfig/navigation/RestaurantConfigStackNavigator';
import { CustomersStackNavigator } from '../../modules/customers/navigation/CustomersStackNavigator';
import { PizzaCustomizationsStackNavigator } from '../../modules/pizzaCustomizations/navigation/PizzaCustomizationsStackNavigator';
import { SyncStackNavigator } from '../../modules/sync/navigation/SyncStackNavigator';
import { UsersStackNavigator } from '../../modules/users/navigation/UsersStackNavigator';
import KitchenNavigator from '../../modules/kitchen/navigation/KitchenNavigator';
import { ShiftAuditStackNavigator } from '../../modules/shiftAudit/navigation/ShiftAuditStackNavigator';
import { SettingsStackNavigator } from '../../modules/settings/navigation/SettingsStackNavigator';
import { ServerSettingsScreen } from '../../modules/settings/screens/ServerSettingsScreen';

import { CustomDrawerContent } from './components/CustomDrawerContent';
import { useAppTheme } from '../styles/theme';
import { Icon, Surface, Checkbox, Text as PaperText } from 'react-native-paper';
import type { AppDrawerParamList } from './types';
import { useResponsive } from '../hooks/useResponsive';
import { ConnectionIndicator } from '../components/ConnectionIndicator';
import { ShiftIndicator } from '../components/ShiftIndicator';
import { useAuthStore } from '../store/authStore';
import { KitchenFilterButton } from '../../modules/kitchen/components/KitchenFilterButton';
import { useKitchenStore } from '../../modules/kitchen/store/kitchenStore';
import { OrderType } from '../../modules/kitchen/types/kitchen.types';

const Drawer = createDrawerNavigator<AppDrawerParamList>();

export function AppDrawerNavigator() {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const user = useAuthStore((state) => state.user);
  const { filters, setFilters } = useKitchenStore();
  const kitchenScreenName =
    user?.preparationScreen?.name || 'Pantalla de Preparaci√≥n';

  // Obtener el texto del filtro activo
  const getFilterText = () => {
    switch (filters.orderType) {
      case OrderType.DINE_IN:
        return ' ‚Ä¢ Mesa';
      case OrderType.TAKE_AWAY:
        return ' ‚Ä¢ Llevar';
      case OrderType.DELIVERY:
        return ' ‚Ä¢ Domicilio';
      default:
        return '';
    }
  };

  // Ruta inicial por defecto (no-kitchen users)
  const initialRouteName = 'OrdersStack';

  const styles = React.useMemo(
    () =>
      StyleSheet.create({
        drawerButtonContainer: {
          width: 56,
          height: 56,
          justifyContent: 'center',
          alignItems: 'center',
          marginLeft: 0,
          borderRadius: 28,
        },
        headerStyle: {
          backgroundColor: theme.colors.primary,
          height: responsive.dimensions.headerHeight,
          elevation: 2,
        },
        headerTitleStyle: {
          ...theme.fonts.titleLarge,
          color: theme.colors.onPrimary,
          fontWeight: 'bold',
          fontSize: responsive.isTablet ? 20 : 22,
        },
        drawerStyle: {
          backgroundColor: theme.colors.surface,
          width: responsive.dimensions.drawerWidth,
          borderTopRightRadius: theme.roundness * 2,
          borderBottomRightRadius: theme.roundness * 2,
        },
      }),
    [theme, responsive],
  );

  return (
    <>
      <StatusBar
        backgroundColor={theme.colors.primary}
        barStyle={theme.dark ? 'light-content' : 'dark-content'}
      />
      <Drawer.Navigator
        initialRouteName={initialRouteName}
        drawerContent={(props) => <CustomDrawerContent {...props} />}
        screenOptions={({ navigation, route }) => ({
          headerStyle: styles.headerStyle,
          headerTintColor: theme.colors.onPrimary,
          headerTitleStyle: styles.headerTitleStyle,
          drawerStyle: styles.drawerStyle,
          drawerActiveTintColor: theme.colors.primary,
          drawerInactiveTintColor: theme.colors.onSurfaceVariant,
          drawerLabelStyle: {
            ...theme.fonts.labelLarge,
            fontSize: responsive.fontSize.m,
          },
          drawerItemStyle: {
            marginVertical: responsive.spacing.xxs,
            borderRadius: theme.roundness * 2,
            paddingVertical: responsive.spacing.xxs,
            paddingHorizontal: responsive.spacing.xs,
          },
          headerShown: true,
          drawerType: 'front',
          drawerPosition: 'left',
          headerShadowVisible: false,
          swipeEdgeWidth: 100,
          headerLeft: () => (
            <TouchableOpacity
              style={styles.drawerButtonContainer}
              onPress={() => navigation.openDrawer()}
              hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
            >
              <Icon source="menu" size={32} color={theme.colors.onPrimary} />
            </TouchableOpacity>
          ),
          headerTitle: ({ children }) => {
            let title = '';
            switch (children) {
              case 'MenuStack':
                title = 'Men√∫';
                break;
              case 'ModifiersStack':
                title = 'Modificadores';
                break;
              case 'PreparationScreensStack':
                title = 'Pantallas Preparaci√≥n';
                break;
              case 'AreasTablesStack':
                title = '√Åreas y Mesas';
                break;
              case 'OrdersStack':
                title = '√ìrdenes';
                break;
              case 'PrintersStack':
                title = 'Impresoras';
                break;
              case 'ReceiptsStack':
                title = 'Recibos';
                break;
              case 'AvailabilityStack':
                title = 'Disponibilidad';
                break;
              case 'OrderFinalizationStack':
                title = 'Finalizaci√≥n';
                break;
              case 'RestaurantConfigStack':
                title = 'Configuraci√≥n';
                break;
              case 'CustomersStack':
                title = 'Clientes';
                break;
              case 'PizzaCustomizationsStack':
                title = 'Personalizaciones';
                break;
              case 'SyncStack':
                title = 'Sincronizaci√≥n';
                break;
              case 'UsersStack':
                title = 'Usuarios';
                break;
              case 'KitchenStack':
                title =
                  kitchenScreenName +
                  (filters.orderType ? getFilterText() : '');
                break;
              case 'ShiftAuditStack':
                title = 'Historial de Turnos';
                break;
              case 'ServerSettings':
                title = 'Configuraci√≥n del Servidor';
                break;
              default:
                title = children?.toString() || '';
            }
            return (
              <Surface
                elevation={0}
                style={{
                  backgroundColor: 'transparent',
                }}
              >
                <Text style={styles.headerTitleStyle}>{title}</Text>
              </Surface>
            );
          },
          headerRight: () => {
            // Solo mostrar ShiftIndicator en las secciones de ventas
            const salesScreens = [
              'OrdersStack',
              'ReceiptsStack',
              'OrderFinalizationStack',
            ];
            const showShiftIndicator = salesScreens.includes(route.name);

            return (
              <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                {showShiftIndicator && <ShiftIndicator />}
                <ConnectionIndicator />
              </View>
            );
          },
        })}
      >
        <Drawer.Screen
          name="OrdersStack"
          component={OrdersStackNavigator}
          options={{
            title: '√ìrdenes',
            drawerIcon: ({ color }) => (
              <Icon
                source="clipboard-list-outline"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="ReceiptsStack"
          component={ReceiptsStackNavigator}
          options={{
            title: 'Recibos',
            drawerIcon: ({ color }) => (
              <Icon
                source="receipt"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="OrderFinalizationStack"
          component={OrderFinalizationStackNavigator}
          options={{
            title: 'Finalizaci√≥n',
            drawerIcon: ({ color }) => (
              <Icon
                source="clipboard-check-outline"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="MenuStack"
          component={MenuStackNavigator}
          options={{
            title: 'Men√∫',
            drawerIcon: ({ color }) => (
              <Icon
                source="menu"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="AvailabilityStack"
          component={AvailabilityStackNavigator}
          options={{
            title: 'Disponibilidad',
            drawerIcon: ({ color }) => (
              <Icon
                source="eye-off-outline"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="ModifiersStack"
          component={ModifiersStackNavigator}
          options={{
            title: 'Modificadores',
            drawerIcon: ({ color }) => (
              <Icon
                source="tune"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="PizzaCustomizationsStack"
          component={PizzaCustomizationsStackNavigator}
          options={{
            title: 'Gesti√≥n de Pizzas',
            drawerIcon: ({ color }) => (
              <Icon
                source="pizza"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="PreparationScreensStack"
          component={PreparationScreensStackNavigator}
          options={{
            title: 'Pantallas Preparaci√≥n',
            drawerIcon: ({ color }) => (
              <Icon
                source="monitor-dashboard"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="AreasTablesStack"
          component={AreasTablesStackNavigator}
          options={{
            title: '√Åreas y Mesas',
            drawerIcon: ({ color }) => (
              <Icon
                source="map-marker-radius-outline"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />

        <Drawer.Screen
          name="PrintersStack"
          component={PrintersStackNavigator}
          options={{
            title: 'Impresoras',
            drawerIcon: ({ color }) => (
              <Icon
                source="printer"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="RestaurantConfigStack"
          component={RestaurantConfigStackNavigator}
          options={{
            title: 'Configuraci√≥n',
            drawerIcon: ({ color }) => (
              <Icon
                source="cog-outline"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="CustomersStack"
          component={CustomersStackNavigator}
          options={{
            title: 'Clientes',
            drawerIcon: ({ color }) => (
              <Icon
                source="account-group-outline"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="SyncStack"
          component={SyncStackNavigator}
          options={{
            title: 'Sincronizaci√≥n',
            drawerIcon: ({ color }) => (
              <Icon
                source="sync"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="UsersStack"
          component={UsersStackNavigator}
          options={{
            title: 'Usuarios',
            drawerIcon: ({ color }) => (
              <Icon
                source="account-multiple"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="ShiftAuditStack"
          component={ShiftAuditStackNavigator}
          options={{
            title: 'Historial de Turnos',
            drawerIcon: ({ color }) => (
              <Icon
                source="history"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="KitchenStack"
          component={KitchenNavigator}
          options={{
            title: kitchenScreenName,
            drawerIcon: ({ color }) => (
              <Icon
                source="chef-hat"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
            headerRight: () => (
              <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                {/* Checkbox para mostrar/ocultar ordenes listas */}
                <TouchableOpacity
                  style={{
                    flexDirection: 'row',
                    alignItems: 'center',
                    paddingHorizontal: 12,
                    paddingVertical: 8,
                    marginRight: 8,
                    backgroundColor: filters.showPrepared
                      ? 'rgba(255,255,255,0.2)'
                      : 'transparent',
                    borderRadius: 20,
                  }}
                  onPress={() =>
                    setFilters({
                      ...filters,
                      showPrepared: !filters.showPrepared,
                    })
                  }
                >
                  <Checkbox
                    status={filters.showPrepared ? 'checked' : 'unchecked'}
                    onPress={() =>
                      setFilters({
                        ...filters,
                        showPrepared: !filters.showPrepared,
                      })
                    }
                    color={theme.colors.onPrimary}
                    uncheckedColor={theme.colors.onPrimary}
                  />
                  <PaperText
                    style={{
                      color: theme.colors.onPrimary,
                      fontSize: 14,
                      marginLeft: 4,
                      fontWeight: filters.showPrepared ? 'bold' : 'normal',
                    }}
                  >
                    Mostrar Listas
                  </PaperText>
                </TouchableOpacity>
                <KitchenFilterButton />
                <ConnectionIndicator />
              </View>
            ),
          }}
        />
        <Drawer.Screen
          name="ServerSettings"
          component={ServerSettingsScreen}
          options={{
            title: 'Configuraci√≥n del Servidor',
            drawerItemStyle: { display: 'none' }, // Oculto del drawer, solo accesible desde el bot√≥n
          }}
        />
      </Drawer.Navigator>
    </>
  );
}

================
File: app/src/modules/receipts/screens/ReceiptsScreen.tsx
================
import React, { useState, useCallback, useMemo } from 'react';
import {
  View,
  FlatList,
  RefreshControl,
  StyleSheet,
  TouchableOpacity,
} from 'react-native';
import {
  Text,
  Searchbar,
  Chip,
  Surface,
  ActivityIndicator,
  Menu,
  IconButton,
  Divider,
  Badge,
  Icon,
} from 'react-native-paper';
import OrderSummaryCard from '@/modules/shared/components/OrderSummaryCard';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useReceipts, useRecoverOrder } from '../hooks/useReceiptsQueries';
import type { Receipt, ReceiptList } from '../types/receipt.types';
import { getPaymentStatus } from '@/app/utils/orderFormatters';
import { receiptService } from '../services/receiptService';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';
import EmptyState from '@/app/components/common/EmptyState';
import { ReceiptDetailsModal } from '../components/ReceiptDetailsModal';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import { DatePickerModal } from 'react-native-paper-dates';
import { OrderTypeEnum } from '@/modules/orders/types/orders.types';
import { formatOrderTypeShort } from '@/app/utils/orderFormatters';

type StatusFilter = 'all' | 'COMPLETED' | 'CANCELLED';

export const ReceiptsScreen: React.FC = () => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);

  // Estados para filtros
  const [searchQuery, setSearchQuery] = useState('');
  const [statusFilter, setStatusFilter] = useState<StatusFilter>('all');
  const [startDate, setStartDate] = useState<Date | undefined>(undefined);
  const [endDate, setEndDate] = useState<Date | undefined>(undefined);
  const [showDateRangePicker, setShowDateRangePicker] = useState(false);
  const [showFilterMenu, setShowFilterMenu] = useState(false);

  // Estado para el modal de detalle
  const [selectedReceipt, setSelectedReceipt] = useState<Receipt | null>(null);
  const [showDetailModal, setShowDetailModal] = useState(false);

  // Estado para recuperaci√≥n de orden
  const [orderToRecover, setOrderToRecover] = useState<any>(null);
  const [showRecoverConfirm, setShowRecoverConfirm] = useState(false);

  // Mutation para recuperar orden
  const recoverOrderMutation = useRecoverOrder();

  // Preparar filtros para la query
  const filters = useMemo(() => {
    const baseFilters: any = {};

    if (startDate) {
      baseFilters.startDate = startDate.toISOString();
    }

    if (endDate) {
      baseFilters.endDate = endDate.toISOString();
    }

    return baseFilters;
  }, [startDate, endDate]);

  // Query para obtener recibos
  const {
    data: allReceipts,
    isLoading,
    refetch,
    isRefetching,
  } = useReceipts(filters);

  // Recargar autom√°ticamente cuando la pantalla recibe foco
  useRefreshModuleOnFocus('receipts');

  // Filtrar recibos localmente
  const receipts = useMemo(() => {
    if (!allReceipts) return [];

    let filtered = [...allReceipts];

    // Filtro por estado
    if (statusFilter !== 'all') {
      filtered = filtered.filter(
        (receipt) => receipt.orderStatus === statusFilter,
      );
    }

    // Filtro por b√∫squeda
    if (searchQuery.trim()) {
      const search = searchQuery.toLowerCase().trim();
      filtered = filtered.filter((receipt) => {
        // Buscar por n√∫mero de orden
        if (receipt.shiftOrderNumber.toString().includes(search)) return true;

        // Buscar en informaci√≥n de entrega
        if (receipt.deliveryInfo) {
          const { recipientName, recipientPhone, fullAddress } =
            receipt.deliveryInfo;
          if (recipientName?.toLowerCase().includes(search)) return true;
          if (recipientPhone?.includes(search)) return true;
          if (fullAddress?.toLowerCase().includes(search)) return true;
        }

        // Buscar en notas
        if (receipt.notes?.toLowerCase().includes(search)) return true;

        return false;
      });
    }

    return filtered;
  }, [allReceipts, statusFilter, searchQuery]);

  // Handlers
  const handleReceiptPress = useCallback((receipt: ReceiptList) => {
    receiptService.getReceiptById(receipt.id).then((fullOrder) => {
      setSelectedReceipt(fullOrder);
      setShowDetailModal(true);
    });
  }, []);

  const handleClearFilters = useCallback(() => {
    setSearchQuery('');
    setStatusFilter('all');
    setStartDate(undefined);
    setEndDate(undefined);
  }, []);

  const handleRecoverPress = useCallback((receipt: ReceiptList) => {
    receiptService.getReceiptById(receipt.id).then((fullOrder) => {
      setOrderToRecover(fullOrder as any);
      setShowRecoverConfirm(true);
    });
  }, []);

  const handleConfirmRecover = useCallback(async () => {
    if (!orderToRecover) return;

    try {
      await recoverOrderMutation.mutateAsync(orderToRecover.id);
      setShowRecoverConfirm(false);
      setOrderToRecover(null);
    } catch (error) {
      // Error ya manejado por el mutation hook
    }
  }, [orderToRecover, recoverOrderMutation]);

  // Funci√≥n espec√≠fica para el color de estado en recibos
  const getReceiptStatusColor = (status: string) => {
    switch (status) {
      case 'COMPLETED':
        return theme.colors.primary;
      case 'CANCELLED':
        return theme.colors.error;
      default:
        return theme.colors.onSurfaceDisabled;
    }
  };

  const getStatusLabel = (status: string) => {
    switch (status) {
      case 'COMPLETED':
        return 'Completada';
      case 'CANCELLED':
        return 'Cancelada';
      default:
        return status;
    }
  };

  const hasActiveFilters = statusFilter !== 'all' || startDate || endDate;

  // Renderizar bot√≥n de restaurar
  const renderRestoreAction = (item: ReceiptList) => (
    <TouchableOpacity
      style={styles.restoreContainer}
      onPress={() => handleRecoverPress(item)}
      activeOpacity={0.7}
    >
      <Surface style={styles.restoreButtonSurface} elevation={2}>
        <IconButton
          icon="restore"
          size={36}
          iconColor={theme.colors.primary}
          style={styles.restoreButton}
        />
      </Surface>
    </TouchableOpacity>
  );

  // Renderizar item de recibo usando el componente compartido
  const renderReceiptItem = ({ item }: { item: ReceiptList }) => (
    <OrderSummaryCard
      item={item}
      onPress={() => handleReceiptPress(item)}
      renderActions={renderRestoreAction}
      getStatusColor={getReceiptStatusColor}
      getStatusLabel={getStatusLabel}
    />
  );

  // Renderizar lista vac√≠a

  // Renderizar lista vac√≠a
  const renderEmptyComponent = () => {
    if (isLoading) {
      return (
        <View style={styles.centerContainer}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
        </View>
      );
    }

    return (
      <EmptyState
        icon="receipt"
        title="No hay recibos"
        message={
          hasActiveFilters
            ? 'No se encontraron recibos con los filtros seleccionados'
            : 'Los recibos de √≥rdenes completadas o canceladas aparecer√°n aqu√≠'
        }
        actionLabel={hasActiveFilters ? 'Limpiar filtros' : undefined}
        onAction={hasActiveFilters ? handleClearFilters : undefined}
      />
    );
  };

  return (
    <View style={styles.container}>
      {/* Header con b√∫squeda y filtros */}
      <Surface style={styles.header} elevation={2}>
        <Surface style={styles.shiftIndicator} elevation={1}>
          <Icon source="cash-register" size={20} color={theme.colors.primary} />
          <Text style={styles.shiftText}>Recibos del turno actual</Text>
          <View style={styles.shiftBadge}>
            <Text style={styles.shiftBadgeText}>ACTIVO</Text>
          </View>
        </Surface>
        <View style={styles.searchContainer}>
          <Searchbar
            placeholder="Buscar por nombre, tel√©fono o direcci√≥n..."
            onChangeText={setSearchQuery}
            value={searchQuery}
            style={styles.searchbar}
            elevation={0}
          />
          <View style={styles.filterButton}>
            <Menu
              visible={showFilterMenu}
              onDismiss={() => setShowFilterMenu(false)}
              anchor={
                <IconButton
                  icon="filter-variant"
                  onPress={() => setShowFilterMenu(true)}
                  style={[
                    styles.filterIconButton,
                    hasActiveFilters && styles.filterIconButtonActive,
                  ]}
                />
              }
            >
              <Menu.Item
                title="Todos los estados"
                onPress={() => {
                  setStatusFilter('all');
                  setShowFilterMenu(false);
                }}
                leadingIcon={statusFilter === 'all' ? 'check' : undefined}
              />
              <Menu.Item
                title="Completadas"
                onPress={() => {
                  setStatusFilter('COMPLETED');
                  setShowFilterMenu(false);
                }}
                leadingIcon={statusFilter === 'COMPLETED' ? 'check' : undefined}
              />
              <Menu.Item
                title="Canceladas"
                onPress={() => {
                  setStatusFilter('CANCELLED');
                  setShowFilterMenu(false);
                }}
                leadingIcon={statusFilter === 'CANCELLED' ? 'check' : undefined}
              />
              <Divider />
              <Menu.Item
                title={
                  startDate && endDate
                    ? `${format(startDate, 'd/M/yyyy')} - ${format(endDate, 'd/M/yyyy')}`
                    : 'Seleccionar rango de fechas'
                }
                onPress={() => {
                  setShowDateRangePicker(true);
                  setShowFilterMenu(false);
                }}
                leadingIcon="calendar-range"
              />
              {hasActiveFilters && (
                <>
                  <Divider />
                  <Menu.Item
                    title="Limpiar filtros"
                    onPress={() => {
                      handleClearFilters();
                      setShowFilterMenu(false);
                    }}
                    leadingIcon="filter-remove"
                  />
                </>
              )}
            </Menu>
            {hasActiveFilters && <Badge size={8} style={styles.filterBadge} />}
          </View>
        </View>

        {/* Chips de filtros activos */}
        {hasActiveFilters && (
          <View style={styles.activeFilters}>
            {statusFilter !== 'all' && (
              <Chip
                mode="outlined"
                compact
                onClose={() => setStatusFilter('all')}
                style={styles.filterChip}
              >
                {statusFilter === 'COMPLETED' ? 'Completadas' : 'Canceladas'}
              </Chip>
            )}
            {startDate && (
              <Chip
                mode="outlined"
                compact
                onClose={() => setStartDate(undefined)}
                style={styles.filterChip}
              >
                Desde: {format(startDate, 'd/M')}
              </Chip>
            )}
            {endDate && (
              <Chip
                mode="outlined"
                compact
                onClose={() => setEndDate(undefined)}
                style={styles.filterChip}
              >
                Hasta: {format(endDate, 'd/M')}
              </Chip>
            )}
          </View>
        )}
      </Surface>

      {/* Lista de recibos */}
      <FlatList
        data={receipts}
        renderItem={renderReceiptItem}
        keyExtractor={(item) => item.id}
        contentContainerStyle={styles.listContent}
        refreshControl={
          <RefreshControl
            refreshing={isRefetching}
            onRefresh={refetch}
            colors={[theme.colors.primary]}
          />
        }
        ListEmptyComponent={renderEmptyComponent}
      />

      {/* Modal de detalle */}
      <ReceiptDetailsModal
        visible={showDetailModal}
        onDismiss={() => {
          setShowDetailModal(false);
          setSelectedReceipt(null);
        }}
        receipt={selectedReceipt}
      />

      {/* Modal de confirmaci√≥n de recuperaci√≥n */}
      <ConfirmationModal
        visible={showRecoverConfirm}
        title="Recuperar Orden"
        message={`¬øEst√°s seguro de que deseas recuperar la orden #${orderToRecover?.shiftOrderNumber}?\n\nLa orden se marcar√° como entregada y volver√° a estar visible en las √≥rdenes activas.`}
        onConfirm={handleConfirmRecover}
        onCancel={() => {
          setShowRecoverConfirm(false);
          setOrderToRecover(null);
        }}
        confirmText="Confirmar"
        cancelText="Cancelar"
      />

      {/* Date range picker */}
      <DatePickerModal
        visible={showDateRangePicker}
        mode="range"
        onDismiss={() => setShowDateRangePicker(false)}
        startDate={startDate}
        endDate={endDate}
        onConfirm={(params) => {
          setStartDate(params.startDate);
          setEndDate(params.endDate);
          setShowDateRangePicker(false);
        }}
        validRange={{
          endDate: new Date(),
        }}
        locale="es"
        saveLabel="Confirmar"
        startLabel="Desde"
        endLabel="Hasta"
        label="Seleccionar rango de fechas"
      />
    </View>
  );
};

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      flex: 1,
    },
    header: {
      paddingHorizontal: 16,
      paddingVertical: 12,
    },
    searchContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 8,
    },
    searchbar: {
      flex: 1,
    },
    filterButton: {
      position: 'relative',
    },
    filterIconButton: {
      margin: 0,
    },
    filterIconButtonActive: {
      backgroundColor: 'rgba(0, 0, 0, 0.08)',
    },
    filterBadge: {
      position: 'absolute',
      top: 8,
      right: 8,
    },
    activeFilters: {
      flexDirection: 'row',
      flexWrap: 'wrap',
      gap: 8,
      marginTop: 12,
    },
    filterChip: {
      height: 32,
    },
    listContent: {
      padding: theme.spacing.s,
      paddingBottom: theme.spacing.l * 2,
      flexGrow: 1,
    },
    orderCard: {
      marginBottom: 8,
    },
    cardContent: {
      paddingBottom: 8,
    },
    mainContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
    },
    leftContainer: {
      flex: 1,
      paddingRight: 12,
      flexShrink: 1,
    },
    rightContainer: {
      alignItems: 'flex-end',
      justifyContent: 'space-between',
      minWidth: 120,
      gap: 8,
      flexShrink: 0,
    },
    orderNumber: {
      fontSize: 16,
      fontWeight: 'bold',
      lineHeight: 22,
      marginBottom: 4,
    },
    orderPrice: {
      fontSize: 15,
      fontWeight: '700',
    },
    orderTime: {
      fontSize: 16,
      fontWeight: '600',
    },
    estimatedTime: {
      fontSize: 14,
      marginLeft: 4,
    },
    timeAndPaymentRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 0,
    },
    paymentBadge: {
      paddingHorizontal: 8,
      paddingVertical: 2,
      borderRadius: 12,
      alignItems: 'center',
      justifyContent: 'center',
    },
    paymentBadgeText: {
      fontSize: 11,
      fontWeight: '600',
      lineHeight: 14,
    },
    statusChip: {
      minHeight: 24,
      alignSelf: 'flex-end',
      paddingVertical: 2,
    },
    statusChipText: {
      fontSize: 12,
      fontWeight: '600',
      color: 'white',
      lineHeight: 14,
      marginVertical: 0,
      paddingVertical: 0,
    },
    actionsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'flex-end',
      gap: 8,
      marginTop: 4,
    },
    restoreContainer: {
      position: 'relative',
      alignItems: 'center',
      justifyContent: 'center',
    },
    restoreButtonSurface: {
      borderRadius: 20,
      backgroundColor: theme.colors.primaryContainer,
      overflow: 'hidden',
    },
    restoreButton: {
      margin: 0,
      width: 44,
      height: 44,
    },
    notesInline: {
      fontSize: 12,
      fontStyle: 'italic',
    },
    inlinePreparationBadge: {
      paddingHorizontal: 6,
      paddingVertical: 2,
      borderRadius: 10,
      borderWidth: 0.5,
    },
    inlinePreparationText: {
      fontSize: 10,
      fontWeight: '500',
    },
    centerContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: 32,
    },
    shiftIndicator: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      gap: 8,
      paddingVertical: 8,
      paddingHorizontal: 16,
      marginBottom: 8,
      borderRadius: 20,
      backgroundColor: theme.colors.primaryContainer,
    },
    shiftText: {
      ...theme.fonts.bodyMedium,
      color: theme.colors.onPrimaryContainer,
      fontWeight: '600',
    },
    shiftBadge: {
      backgroundColor: theme.colors.primary,
      paddingHorizontal: 8,
      paddingVertical: 2,
      borderRadius: 10,
    },
    shiftBadgeText: {
      fontSize: 10,
      fontWeight: 'bold',
      color: theme.colors.onPrimary,
    },
    miniPaymentBadge: {
      width: 20,
      height: 20,
      borderRadius: 10,
      alignItems: 'center',
      justifyContent: 'center',
      marginLeft: 6,
    },
    miniPaymentText: {
      fontSize: 10,
      fontWeight: 'bold',
      color: '#FFFFFF',
    },
    miniPreparationBadge: {
      width: 20,
      height: 20,
      borderRadius: 10,
      alignItems: 'center',
      justifyContent: 'center',
      marginLeft: 4,
    },
    miniPreparationText: {
      fontSize: 10,
      fontWeight: '600',
      color: '#FFFFFF',
    },
    moreIndicator: {
      fontSize: 10,
      color: theme.colors.onSurfaceVariant,
      marginLeft: 4,
    },
    createdByText: {
      fontSize: 10,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 4,
      textAlign: 'right',
    },
  });

================
File: app/src/modules/orderFinalization/screens/OrderFinalizationScreen.tsx
================
import React, { useState, useMemo, useCallback, useEffect } from 'react';
import { View, StyleSheet, Pressable } from 'react-native';
import { FlashList } from '@shopify/flash-list';
import {
  Surface,
  Text,
  ActivityIndicator,
  Icon,
  Button,
  IconButton,
} from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { OrderCard } from '../components/OrderCard';
import { OrderDetailsModal } from '../components/OrderDetailsModal';
import { PrintTicketModal } from '@/modules/shared/components/PrintTicketModal';
import {
  useOrdersForFinalizationList,
  useOrderForFinalizationDetail,
} from '../hooks/useOrderFinalizationQueries';
import {
  OrderFinalizationFilter,
  OrderSelectionState,
  OrderForFinalizationList,
} from '../types/orderFinalization.types';
import EmptyState from '@/app/components/common/EmptyState';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { orderFinalizationService } from '../services/orderFinalizationService';

export const OrderFinalizationScreen: React.FC = () => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const styles = useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const [filter, setFilter] = useState<OrderFinalizationFilter>('delivery');
  const [selectionState, setSelectionState] = useState<OrderSelectionState>({
    selectedOrders: new Set(),
    totalAmount: 0,
  });
  const [selectedOrderIdForDetails, setSelectedOrderIdForDetails] = useState<
    string | null
  >(null);
  const [showConfirmationModal, setShowConfirmationModal] = useState(false);
  const [isFinalizingOrders, setIsFinalizingOrders] = useState(false);
  const [showPrintModal, setShowPrintModal] = useState(false);
  const [selectedOrderForPrint, setSelectedOrderForPrint] =
    useState<OrderForFinalizationList | null>(null);

  const {
    data: orders = [],
    isLoading,
    refetch,
  } = useOrdersForFinalizationList();

  const { data: selectedOrderDetails, isLoading: isLoadingDetails } =
    useOrderForFinalizationDetail(selectedOrderIdForDetails);

  const { data: orderForPrint } = useOrderForFinalizationDetail(
    selectedOrderForPrint?.id || null,
  );

  const filteredOrders = useMemo(() => {
    if (!orders || !Array.isArray(orders)) return [];

    return orders.filter((order) => {
      switch (filter) {
        case 'delivery':
          return order.orderType === 'DELIVERY';
        case 'take_away':
          return order.orderType === 'TAKE_AWAY';
        case 'dine_in':
          return order.orderType === 'DINE_IN';
        default:
          return false;
      }
    });
  }, [orders, filter]);

  const orderCounts = useMemo(() => {
    if (!orders || !Array.isArray(orders)) {
      return {
        delivery: 0,
        take_away: 0,
        dine_in: 0,
      };
    }

    return orders.reduce(
      (counts, order) => {
        switch (order.orderType) {
          case 'DELIVERY':
            counts.delivery++;
            break;
          case 'TAKE_AWAY':
            counts.take_away++;
            break;
          case 'DINE_IN':
            counts.dine_in++;
            break;
        }
        return counts;
      },
      { delivery: 0, take_away: 0, dine_in: 0 },
    );
  }, [orders]);

  useEffect(() => {
    setSelectionState({
      selectedOrders: new Set(),
      totalAmount: 0,
    });
  }, [filter]);

  const handleToggleOrderSelection = useCallback(
    (orderId: string) => {
      if (!orders || !Array.isArray(orders)) return;

      const order = orders.find((o) => o.id === orderId);
      if (!order) return;

      setSelectionState((prevState) => {
        const newSelectedOrders = new Set(prevState.selectedOrders);
        let newTotalAmount = prevState.totalAmount;
        const orderTotal =
          typeof order.total === 'string'
            ? parseFloat(order.total)
            : order.total;
        const paymentsSummary = order.paymentsSummary;
        const paid = paymentsSummary?.totalPaid || 0;
        const pendingAmount = orderTotal - paid;

        if (newSelectedOrders.has(orderId)) {
          newSelectedOrders.delete(orderId);
          newTotalAmount -= pendingAmount;
        } else {
          newSelectedOrders.add(orderId);
          newTotalAmount += pendingAmount;
        }

        return {
          selectedOrders: newSelectedOrders,
          totalAmount: newTotalAmount,
        };
      });
    },
    [orders],
  );

  const ordersNotReady = useMemo(() => {
    if (selectionState.selectedOrders.size === 0) return [];

    const selectedOrdersList = Array.from(selectionState.selectedOrders)
      .map((id) => orders.find((o) => o.id === id))
      .filter(Boolean) as OrderForFinalizationList[];

    return selectedOrdersList.filter((order) => order.orderStatus !== 'READY');
  }, [selectionState.selectedOrders, orders]);

  const confirmationMessage = useMemo(() => {
    let message = `¬øDesea finalizar ${selectionState.selectedOrders.size} ${
      selectionState.selectedOrders.size === 1 ? 'orden' : '√≥rdenes'
    }?\n\nTotal a cobrar: $${selectionState.totalAmount.toFixed(2)}`;

    if (ordersNotReady.length > 0) {
      message += `\n\n‚ö†Ô∏è ADVERTENCIA: ${ordersNotReady.length} ${
        ordersNotReady.length === 1 ? 'orden no est√°' : '√≥rdenes no est√°n'
      } en estado "Listo"`;
    }

    return message;
  }, [selectionState, ordersNotReady]);

  const handleQuickFinalizeOrders = useCallback(() => {
    if (selectionState.selectedOrders.size === 0) return;
    setShowConfirmationModal(true);
  }, [selectionState.selectedOrders.size]);

  const handleConfirmFinalization = useCallback(async () => {
    setIsFinalizingOrders(true);
    try {
      await orderFinalizationService.quickFinalizeMultipleOrders(
        Array.from(selectionState.selectedOrders),
      );

      showSnackbar({
        message: '√ìrdenes finalizadas exitosamente',
        type: 'success',
      });

      setSelectionState({
        selectedOrders: new Set(),
        totalAmount: 0,
      });

      setShowConfirmationModal(false);
      refetch();
    } catch (error) {
      showSnackbar({
        message: 'Error al finalizar las √≥rdenes',
        type: 'error',
      });
    } finally {
      setIsFinalizingOrders(false);
    }
  }, [selectionState.selectedOrders, showSnackbar, refetch]);

  const handleShowOrderDetails = useCallback(
    (order: OrderForFinalizationList) => {
      setSelectedOrderIdForDetails(null);
      setTimeout(() => {
        setSelectedOrderIdForDetails(order.id);
      }, 50);
    },
    [],
  );

  const handlePrintPress = useCallback(() => {
    setShowPrintModal(true);
  }, []);

  const handlePrintFromList = useCallback(
    async (order: OrderForFinalizationList) => {
      setSelectedOrderForPrint(order);
      setShowPrintModal(true);
    },
    [],
  );

  const handlePrint = useCallback(
    async (printerId: string, ticketType: 'GENERAL' | 'BILLING') => {
      const orderToUse = orderForPrint || selectedOrderDetails;
      if (!orderToUse) return;

      try {
        await orderFinalizationService.printTicket(orderToUse.id, {
          printerId,
          ticketType,
        });

        showSnackbar({
          message: 'Ticket impreso exitosamente',
          type: 'success',
        });

        await refetch();
        setSelectedOrderForPrint(null);
      } catch (error) {
        showSnackbar({
          message: 'Error al imprimir el ticket',
          type: 'error',
        });
      }
    },
    [orderForPrint, selectedOrderDetails, showSnackbar, refetch],
  );

  const renderOrderCard = useCallback(
    ({ item }) => (
      <OrderCard
        order={item}
        isSelected={selectionState.selectedOrders.has(item.id)}
        onToggleSelection={handleToggleOrderSelection}
        onShowDetails={handleShowOrderDetails}
        onPrintPress={handlePrintFromList}
      />
    ),
    [
      selectionState.selectedOrders,
      handleToggleOrderSelection,
      handleShowOrderDetails,
      handlePrintFromList,
    ],
  );

  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
        <Text
          style={[styles.loadingText, { color: theme.colors.onSurfaceVariant }]}
        >
          Cargando √≥rdenes...
        </Text>
      </View>
    );
  }

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.colors.background }]}
      edges={['top']}
    >
      <Surface style={styles.header}>
        <View style={styles.headerContent}>
          <View style={styles.filterContainer}>
            <Pressable
              style={[
                styles.filterButton,
                filter === 'delivery' && styles.filterButtonActive,
                {
                  backgroundColor:
                    filter === 'delivery'
                      ? theme.colors.primaryContainer
                      : theme.colors.surface,
                },
              ]}
              onPress={() => setFilter('delivery')}
            >
              <Icon
                source="moped"
                size={responsive.isTablet ? 22 : 26}
                color={
                  filter === 'delivery'
                    ? theme.colors.primary
                    : theme.colors.onSurfaceVariant
                }
              />
              {orderCounts.delivery > 0 && (
                <View
                  style={[
                    styles.countBadge,
                    {
                      backgroundColor:
                        filter === 'delivery'
                          ? theme.colors.error
                          : theme.colors.errorContainer,
                      borderColor:
                        filter === 'delivery'
                          ? theme.colors.error
                          : theme.colors.outline,
                    },
                  ]}
                >
                  <Text
                    style={[
                      styles.countBadgeText,
                      {
                        color:
                          filter === 'delivery'
                            ? theme.colors.onError
                            : theme.colors.onErrorContainer,
                      },
                    ]}
                  >
                    {orderCounts.delivery}
                  </Text>
                </View>
              )}
            </Pressable>
            <Pressable
              style={[
                styles.filterButton,
                filter === 'take_away' && styles.filterButtonActive,
                {
                  backgroundColor:
                    filter === 'take_away'
                      ? theme.colors.primaryContainer
                      : theme.colors.surface,
                },
              ]}
              onPress={() => setFilter('take_away')}
            >
              <Icon
                source="bag-personal"
                size={responsive.isTablet ? 22 : 26}
                color={
                  filter === 'take_away'
                    ? theme.colors.primary
                    : theme.colors.onSurfaceVariant
                }
              />
              {orderCounts.take_away > 0 && (
                <View
                  style={[
                    styles.countBadge,
                    {
                      backgroundColor:
                        filter === 'take_away'
                          ? theme.colors.error
                          : theme.colors.errorContainer,
                      borderColor:
                        filter === 'take_away'
                          ? theme.colors.error
                          : theme.colors.outline,
                    },
                  ]}
                >
                  <Text
                    style={[
                      styles.countBadgeText,
                      {
                        color:
                          filter === 'take_away'
                            ? theme.colors.onError
                            : theme.colors.onErrorContainer,
                      },
                    ]}
                  >
                    {orderCounts.take_away}
                  </Text>
                </View>
              )}
            </Pressable>
            <Pressable
              style={[
                styles.filterButton,
                filter === 'dine_in' && styles.filterButtonActive,
                {
                  backgroundColor:
                    filter === 'dine_in'
                      ? theme.colors.primaryContainer
                      : theme.colors.surface,
                },
              ]}
              onPress={() => setFilter('dine_in')}
            >
              <Icon
                source="silverware-fork-knife"
                size={responsive.isTablet ? 22 : 26}
                color={
                  filter === 'dine_in'
                    ? theme.colors.primary
                    : theme.colors.onSurfaceVariant
                }
              />
              {orderCounts.dine_in > 0 && (
                <View
                  style={[
                    styles.countBadge,
                    {
                      backgroundColor:
                        filter === 'dine_in'
                          ? theme.colors.error
                          : theme.colors.errorContainer,
                      borderColor:
                        filter === 'dine_in'
                          ? theme.colors.error
                          : theme.colors.outline,
                    },
                  ]}
                >
                  <Text
                    style={[
                      styles.countBadgeText,
                      {
                        color:
                          filter === 'dine_in'
                            ? theme.colors.onError
                            : theme.colors.onErrorContainer,
                      },
                    ]}
                  >
                    {orderCounts.dine_in}
                  </Text>
                </View>
              )}
            </Pressable>
          </View>
          <View style={styles.refreshButtonContainer}>
            <IconButton
              icon="refresh"
              size={responsive.isTablet ? 20 : 24}
              mode="contained"
              containerColor={theme.colors.surfaceVariant}
              iconColor={theme.colors.onSurfaceVariant}
              onPress={() => refetch()}
              style={styles.refreshButton}
            />
          </View>
        </View>
      </Surface>

      <View style={styles.content}>
        {filteredOrders.length === 0 ? (
          <EmptyState
            title="No hay √≥rdenes para finalizar"
            description="Las √≥rdenes aparecer√°n aqu√≠ cuando est√©n listas para finalizar"
            icon="clipboard-check-outline"
          />
        ) : (
          <FlashList
            data={filteredOrders}
            keyExtractor={(item) => item.id}
            renderItem={renderOrderCard}
            contentContainerStyle={styles.listContent}
            showsVerticalScrollIndicator={false}
            ItemSeparatorComponent={() => null}
            onRefresh={refetch}
            refreshing={isLoading}
            estimatedItemSize={150}
            removeClippedSubviews={true}
          />
        )}
      </View>

      {selectionState.selectedOrders.size > 0 && (
        <Surface style={styles.floatingButton} elevation={8}>
          <Button
            mode="contained"
            onPress={handleQuickFinalizeOrders}
            style={styles.finalizeButton}
            labelStyle={styles.finalizeButtonLabel}
            disabled={isFinalizingOrders}
          >
            Finalizar ({selectionState.selectedOrders.size}) - $
            {(selectionState.totalAmount || 0).toFixed(2)}
          </Button>
        </Surface>
      )}

      <OrderDetailsModal
        visible={selectedOrderIdForDetails !== null}
        onDismiss={() => setSelectedOrderIdForDetails(null)}
        order={selectedOrderDetails}
        isLoading={isLoadingDetails}
        onPrintPress={handlePrintPress}
      />

      <PrintTicketModal
        visible={showPrintModal}
        onDismiss={() => {
          setShowPrintModal(false);
          setSelectedOrderForPrint(null);
        }}
        order={orderForPrint || selectedOrderDetails}
        onPrint={handlePrint}
      />

      <ConfirmationModal
        visible={showConfirmationModal}
        title="Finalizar √ìrdenes"
        message={confirmationMessage}
        onConfirm={handleConfirmFinalization}
        onCancel={() => setShowConfirmationModal(false)}
        onDismiss={() => setShowConfirmationModal(false)}
        confirmText={isFinalizingOrders ? 'Finalizando...' : 'Finalizar'}
        confirmButtonColor={
          ordersNotReady.length > 0 ? theme.colors.error : theme.colors.primary
        }
      />
    </SafeAreaView>
  );
};

const createStyles = (
  theme: typeof useAppTheme,
  responsive: typeof useResponsive,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
    },
    header: {
      paddingHorizontal: 0,
      paddingVertical: 0,
      backgroundColor: 'transparent',
      elevation: 0,
    },
    headerContent: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 0,
    },
    filterContainer: {
      flex: 1,
      flexDirection: 'row',
      gap: 0,
    },
    refreshButtonContainer: {
      paddingHorizontal: responsive.isTablet ? 6 : 8,
    },
    refreshButton: {
      margin: 0,
    },
    filterButton: {
      flex: 1,
      height: responsive.isTablet ? 44 : 52,
      justifyContent: 'center',
      alignItems: 'center',
      borderRadius: 0,
      elevation: 1,
      position: 'relative',
    },
    filterButtonActive: {
      elevation: 3,
    },
    countBadge: {
      position: 'absolute',
      top: responsive.isTablet ? 4 : 6,
      right: responsive.isTablet ? 4 : 6,
      minWidth: responsive.isTablet ? 18 : 22,
      height: responsive.isTablet ? 18 : 22,
      borderRadius: responsive.isTablet ? 9 : 11,
      justifyContent: 'center',
      alignItems: 'center',
      paddingHorizontal: responsive.isTablet ? 4 : 6,
      borderWidth: 1,
      elevation: 2,
    },
    countBadgeText: {
      fontSize: responsive.isTablet ? 10 : 12,
      fontWeight: '700',
    },
    floatingButton: {
      position: 'absolute',
      bottom: responsive.isTablet ? 12 : 16,
      left: responsive.isTablet ? 12 : 16,
      right: responsive.isTablet ? 12 : 16,
      borderRadius: responsive.isTablet ? 12 : 16,
      padding: responsive.isTablet ? 6 : 8,
      elevation: 8,
    },
    finalizeButton: {
      borderRadius: responsive.isTablet ? 10 : 12,
      paddingVertical: responsive.isTablet ? 3 : 4,
    },
    finalizeButtonLabel: {
      fontSize: responsive.isTablet ? 14 : 16,
      fontWeight: '700',
      letterSpacing: 0.5,
    },
    content: {
      flex: 1,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
    loadingText: {
      marginTop: responsive.isTablet ? 8 : 12,
      fontSize: responsive.isTablet ? 12 : 14,
    },
    listContent: {
      padding: responsive.isTablet ? 6 : 8,
      paddingBottom: responsive.isTablet ? 80 : 100,
    },
  });

================
File: app/src/modules/orders/components/OrderCartDetail.tsx
================
import React, { useState, useMemo, useEffect, useCallback } from 'react';
import { Portal } from 'react-native-paper';
import {
  View,
  ScrollView,
  StyleSheet,
  TouchableOpacity,
  ActivityIndicator,
  TouchableWithoutFeedback,
  Keyboard,
  Animated,
} from 'react-native';
import {
  Swipeable,
  GestureHandlerRootView,
} from 'react-native-gesture-handler';
import {
  Text,
  Divider,
  List,
  Button,
  RadioButton,
  HelperText,
  Menu,
  IconButton,
  Modal,
  Checkbox,
} from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { OrderTypeEnum, type OrderType } from '../types/orders.types'; // Importar OrderTypeEnum y el tipo OrderType
import { useGetAreas } from '@/modules/areasTables/services/areaService';
import type { DeliveryInfo } from '../../../app/schemas/domain/delivery-info.schema';
import OrderHeader from './OrderHeader';
import AnimatedLabelSelector from '@/app/components/common/AnimatedLabelSelector';
import SpeechRecognitionInput from '@/app/components/common/SpeechRecognitionInput';
import DateTimePickerSafe from '@/app/components/DateTimePickerSafe';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import ProductCustomizationModal from './ProductCustomizationModal';
import type { FullMenuProduct as Product } from '../types/orders.types';
import { useGetTablesByArea } from '@/modules/areasTables/services/tableService';
import type { Table } from '@/modules/areasTables/types/areasTables.types';
import { canRegisterPayments as checkCanRegisterPayments } from '@/app/utils/roleUtils';
import { useCartStore, CartItem, CartItemModifier } from '../stores/useCartStore'; // Importar CartItem y CartItemModifier
import { useOrderFormStore } from '../stores/useOrderFormStore';
import { useAuthStore } from '@/app/store/authStore'; // Importar authStore
import { useSnackbarStore } from '@/app/store/snackbarStore'; // Importar snackbar store
import { useGetOrderByIdQuery } from '../hooks/useOrdersQueries'; // Para cargar datos en modo edici√≥n
import { useGetOrderMenu } from '../hooks/useMenuQueries'; // Para obtener productos completos
import type { FullMenuCategory } from '../types/orders.types'; // Tipo con subcategor√≠as
import OrderHistoryModal from '@/modules/shared/components/OrderHistoryModal'; // Modal de historial
import { OrderDetailModal } from './OrderDetailModal'; // Modal de detalles
import PaymentModal from './PaymentModal'; // Modal de pagos
import { FAB } from 'react-native-paper'; // Para el floating action button
import { AdjustmentFormModal } from './AdjustmentFormModal'; // Modal de ajustes
import type { OrderAdjustment } from '../types/adjustments.types'; // Tipo para ajustes
import { useGetPaymentsByOrderIdQuery } from '../hooks/usePaymentQueries'; // Para consultar pagos existentes
import { PaymentStatusEnum } from '../types/payment.types'; // Para verificar estados de pago
import type { SelectedPizzaCustomization } from '@/app/schemas/domain/order.schema'; // Para personalizaciones de pizza
import { prepaymentService } from '@/modules/payments/services/prepaymentService'; // Servicio de prepagos
import {
  CustomizationType,
  PizzaHalf,
  CustomizationAction,
} from '@/modules/pizzaCustomizations/types/pizzaCustomization.types';

// Importar tipos desde update-order.types.ts
import type {
  OrderItemDtoForBackend,
  OrderItemModifierDto,
} from '../types/update-order.types';

// Definir la estructura completa del payload para onConfirmOrder (y exportarla)
export interface OrderDetailsForBackend {
  userId?: string;
  orderType: OrderType;
  subtotal: number;
  total: number;
  items: OrderItemDtoForBackend[];
  tableId?: string;
  isTemporaryTable?: boolean;
  temporaryTableName?: string;
  temporaryTableAreaId?: string;
  scheduledAt?: Date;
  deliveryInfo: DeliveryInfo;
  notes?: string;
  payment?: {
    amount: number;
    method: 'CASH' | 'CARD' | 'TRANSFER';
  };
  adjustments?: {
    orderId?: string;
    name: string;
    description?: string;
    isPercentage: boolean;
    value?: number;
    amount?: number;
  }[];
  customerId?: string;
  isFromWhatsApp?: boolean;
  prepaymentId?: string;
}

// Helper para formatear el estado de la orden
const formatOrderStatus = (status: string): string => {
  switch (status) {
    case 'PENDING':
      return 'Pendiente';
    case 'IN_PROGRESS':
      return 'En Progreso';
    case 'IN_PREPARATION':
      return 'En Preparaci√≥n';
    case 'READY':
      return 'Lista';
    case 'DELIVERED':
      return 'Entregada';
    case 'COMPLETED':
      return 'Completada';
    case 'CANCELLED':
      return 'Cancelada';
    default:
      return status;
  }
};

// Helper para obtener el color del estado de preparaci√≥n
const getPreparationStatusColor = (status: string | undefined, theme: any) => {
  switch (status) {
    case 'NEW':
      return '#2196F3'; // Azul brillante para nuevo
    case 'PENDING':
      return theme.colors.error; // Rojo para pendiente
    case 'IN_PROGRESS':
      return '#FFA000'; // Naranja para en progreso
    case 'READY':
      return '#4CAF50'; // Verde para listo
    case 'DELIVERED':
      return theme.colors.tertiary; // Color terciario para entregado
    case 'CANCELLED':
      return theme.colors.onSurfaceDisabled; // Gris para cancelado
    default:
      return theme.colors.onSurfaceVariant;
  }
};

// Helper para obtener el texto del estado de preparaci√≥n
const getPreparationStatusText = (status: string | undefined): string => {
  switch (status) {
    case 'NEW':
      return 'Nuevo';
    case 'PENDING':
      return 'Pendiente';
    case 'IN_PROGRESS':
      return 'En Preparaci√≥n';
    case 'READY':
      return 'Listo';
    case 'DELIVERED':
      return 'Entregado';
    case 'CANCELLED':
      return 'Cancelado';
    default:
      return '';
  }
};

interface OrderCartDetailProps {
  visible: boolean;
  onConfirmOrder: (details: OrderDetailsForBackend) => void;
  onClose?: () => void;
  onEditItem?: (item: CartItem) => void;
  isEditMode?: boolean;
  orderId?: string | null;
  orderNumber?: number;
  orderDate?: Date;
  onCancelOrder?: () => void; // Funci√≥n para cancelar la orden
  navigation?: any; // Prop de navegaci√≥n opcional para a√±adir productos
  onAddProducts?: () => void; // Callback para a√±adir productos
  pendingProductsToAdd?: CartItem[]; // Productos pendientes de a√±adir
  onItemsCountChanged?: (count: number) => void; // Callback cuando cambia el conteo de items
}

// Helper para obtener el color del estado de la orden
const getOrderStatusColor = (status: string, theme: any) => {
  switch (status) {
    case 'PENDING':
      return '#FFA000'; // Orange
    case 'IN_PROGRESS':
      return theme.colors.primary;
    case 'IN_PREPARATION':
      return '#FF6B35'; // Orange m√°s oscuro
    case 'READY':
      return '#4CAF50'; // Green
    case 'DELIVERED':
      return theme.colors.tertiary;
    case 'COMPLETED':
      return '#10B981'; // Verde m√°s brillante
    case 'CANCELLED':
      return theme.colors.error;
    default:
      return theme.colors.onSurfaceVariant;
  }
};

const OrderCartDetail: React.FC<OrderCartDetailProps> = ({
  visible,
  onConfirmOrder,
  onClose,
  onEditItem,
  isEditMode = false,
  orderId,
  orderNumber,
  orderDate,
  onCancelOrder,
  navigation,
  onAddProducts,
  pendingProductsToAdd = [],
  onItemsCountChanged,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);

  // Query para cargar datos de la orden en modo edici√≥n
  const {
    data: orderData,
    isLoading: isLoadingOrder,
    isError: isErrorOrder,
    isSuccess: _isSuccessOrder,
    refetch: _refetchOrder,
  } = useGetOrderByIdQuery(orderId, {
    enabled: isEditMode && !!orderId && visible,
  });

  // Query para obtener el men√∫ completo (para poder editar productos)
  const { data: menu } = useGetOrderMenu();

  // Query para obtener los pagos de la orden (solo en modo edici√≥n)
  const { data: payments = [] } = useGetPaymentsByOrderIdQuery(orderId || '', {
    enabled: isEditMode && !!orderId && visible,
  });

  // Estados locales para modo edici√≥n (cuando no usamos el contexto del carrito)
  const [editItems, setEditItems] = useState<CartItem[]>([]);
  const [editOrderType, setEditOrderType] = useState<OrderType>(
    OrderTypeEnum.DINE_IN,
  );
  const [editSelectedAreaId, setEditSelectedAreaId] = useState<string | null>(
    null,
  );
  const [editSelectedTableId, setEditSelectedTableId] = useState<string | null>(
    null,
  );
  const [editScheduledTime, setEditScheduledTime] = useState<Date | null>(null);
  const [editDeliveryInfo, setEditDeliveryInfo] = useState<DeliveryInfo>({});
  const [editOrderNotes, setEditOrderNotes] = useState<string>('');
  const [editAdjustments, setEditAdjustments] = useState<OrderAdjustment[]>([]);
  const [editIsTemporaryTable, setEditIsTemporaryTable] =
    useState<boolean>(false);
  const [editTemporaryTableName, setEditTemporaryTableName] =
    useState<string>('');

  // Estados para controlar si ya procesamos los productos pendientes y si los datos de la orden ya se cargaron
  const [processedPendingProductsIds, setProcessedPendingProductsIds] =
    useState<string[]>([]);
  const [orderDataLoaded, setOrderDataLoaded] = useState(false);

  // Usar los stores separados en lugar del contexto unificado
  const cartStore = useCartStore();
  const orderFormStore = useOrderFormStore();

  const cartItems = !isEditMode ? cartStore.items : [];
  const removeCartItem = !isEditMode ? cartStore.removeItem : () => {};
  const updateCartItemQuantity = !isEditMode ? cartStore.updateItemQuantity : () => {};
  const isCartVisible = !isEditMode ? cartStore.isCartVisible : false;
  
  const cartOrderType = !isEditMode ? orderFormStore.orderType : OrderTypeEnum.DINE_IN;
  const setCartOrderType = !isEditMode ? orderFormStore.setOrderType : () => {};
  const cartSelectedAreaId = !isEditMode ? orderFormStore.selectedAreaId : null;
  const setCartSelectedAreaId = !isEditMode ? orderFormStore.setSelectedAreaId : () => {};
  const cartSelectedTableId = !isEditMode ? orderFormStore.selectedTableId : null;
  const setCartSelectedTableId = !isEditMode ? orderFormStore.setSelectedTableId : () => {};
  const cartIsTemporaryTable = !isEditMode ? orderFormStore.isTemporaryTable : false;
  const setCartIsTemporaryTable = !isEditMode ? orderFormStore.setIsTemporaryTable : () => {};
  const cartTemporaryTableName = !isEditMode ? orderFormStore.temporaryTableName : '';
  const setCartTemporaryTableName = !isEditMode ? orderFormStore.setTemporaryTableName : () => {};
  const cartScheduledTime = !isEditMode ? orderFormStore.scheduledTime : null;
  const setCartScheduledTime = !isEditMode ? orderFormStore.setScheduledTime : () => {};
  const cartDeliveryInfo = !isEditMode ? orderFormStore.deliveryInfo : {};
  const setCartDeliveryInfo = orderFormStore.setDeliveryInfo;
  const cartOrderNotes = orderFormStore.orderNotes;
  const setCartOrderNotes = orderFormStore.setOrderNotes;

  // Usar valores del contexto o locales seg√∫n el modo
  const items = isEditMode ? editItems : cartItems;
  const orderType = isEditMode ? editOrderType : cartOrderType;
  const selectedAreaId = isEditMode ? editSelectedAreaId : cartSelectedAreaId;
  const selectedTableId = isEditMode
    ? editSelectedTableId
    : cartSelectedTableId;
  const isTemporaryTable = isEditMode
    ? editIsTemporaryTable
    : cartIsTemporaryTable;
  const temporaryTableName = isEditMode
    ? editTemporaryTableName
    : cartTemporaryTableName;
  const scheduledTime = isEditMode ? editScheduledTime : cartScheduledTime;
  const deliveryInfo = isEditMode ? editDeliveryInfo : cartDeliveryInfo;
  const orderNotes = isEditMode ? editOrderNotes : cartOrderNotes;
  const adjustments = isEditMode ? editAdjustments : [];

  const setOrderType = isEditMode ? setEditOrderType : setCartOrderType;
  const setSelectedAreaId = isEditMode
    ? setEditSelectedAreaId
    : setCartSelectedAreaId;
  const setSelectedTableId = isEditMode
    ? setEditSelectedTableId
    : setCartSelectedTableId;
  const setIsTemporaryTable = isEditMode
    ? setEditIsTemporaryTable
    : setCartIsTemporaryTable;
  const setTemporaryTableName = isEditMode
    ? setEditTemporaryTableName
    : setCartTemporaryTableName;
  const setScheduledTime = isEditMode
    ? setEditScheduledTime
    : setCartScheduledTime;
  const setDeliveryInfo = isEditMode
    ? setEditDeliveryInfo
    : setCartDeliveryInfo;
  const setOrderNotes = isEditMode ? setEditOrderNotes : setCartOrderNotes;

  const removeItem = useCallback(
    (itemId: string) => {
      if (isEditMode) {
        const item = editItems.find((i) => i.id === itemId);
        if (!item) return;

        // Verificar el estado del item
        if (
          item.preparationStatus === 'READY' ||
          item.preparationStatus === 'DELIVERED'
        ) {
          // No permitir eliminar items listos o entregados
          showSnackbar({
            message: `No se puede eliminar un producto ${getPreparationStatusText(item.preparationStatus).toLowerCase()}`,
            type: 'error',
          });
          return;
        }

        if (item.preparationStatus === 'IN_PROGRESS') {
          // Pedir confirmaci√≥n para items en preparaci√≥n
          setModifyingItemName(item.productName);
          setPendingModifyAction(() => () => {
            setEditItems((prev) => prev.filter((i) => i.id !== itemId));
          });
          setShowModifyInProgressConfirmation(true);
        } else {
          // Permitir eliminar items pendientes o cancelados sin confirmaci√≥n
          setEditItems((prev) => prev.filter((i) => i.id !== itemId));
        }
      } else {
        removeCartItem(itemId);
      }
    },
    [isEditMode, editItems, showSnackbar, removeCartItem],
  );

  const updateItemQuantity = useCallback(
    (itemId: string, quantity: number) => {
      if (isEditMode) {
        if (quantity <= 0) {
          removeItem(itemId);
          return;
        }

        const item = editItems.find((i) => i.id === itemId);
        if (!item) return;

        // Verificar el estado del item
        if (
          item.preparationStatus === 'READY' ||
          item.preparationStatus === 'DELIVERED'
        ) {
          // No permitir modificar items listos o entregados
          showSnackbar({
            message: `No se puede modificar un producto ${getPreparationStatusText(item.preparationStatus).toLowerCase()}`,
            type: 'error',
          });
          return;
        }

        const updateQuantity = () => {
          setEditItems((prev) =>
            prev.map((item) => {
              if (item.id === itemId) {
                const modifiersPrice = item.modifiers.reduce(
                  (sum, mod) => sum + Number(mod.price || 0),
                  0,
                );
                const newTotalPrice =
                  (item.unitPrice + modifiersPrice) * quantity;
                return {
                  ...item,
                  quantity,
                  totalPrice: newTotalPrice,
                };
              }
              return item;
            }),
          );
        };

        if (item.preparationStatus === 'IN_PROGRESS') {
          // Pedir confirmaci√≥n para items en preparaci√≥n
          setModifyingItemName(item.productName);
          setPendingModifyAction(() => updateQuantity);
          setShowModifyInProgressConfirmation(true);
        } else {
          // Permitir modificar items pendientes o cancelados sin confirmaci√≥n
          updateQuantity();
        }
      } else {
        updateCartItemQuantity(itemId, quantity);
      }
    },
    [isEditMode, editItems, removeItem, showSnackbar, updateCartItemQuantity],
  );

  // Calcular totales
  const subtotal = useMemo(() => {
    if (!items || !Array.isArray(items)) return 0;
    return items.reduce((sum, item) => sum + (item.totalPrice || 0), 0);
  }, [items]);

  // Calcular total de ajustes
  const totalAdjustments = useMemo(() => {
    if (!isEditMode) return 0;
    return editAdjustments
      .filter((adj) => !adj.isDeleted)
      .reduce((sum, adj) => sum + (adj.amount || 0), 0);
  }, [isEditMode, editAdjustments]);

  const total = useMemo(() => {
    return subtotal + totalAdjustments;
  }, [subtotal, totalAdjustments]);

  const totalItemsCount = useMemo(() => {
    return items.reduce((sum, item) => sum + item.quantity, 0);
  }, [items]);

  // Calcular conteo de items existentes (no temporales)
  const existingItemsCount = useMemo(() => {
    if (!isEditMode) return 0;
    return editItems
      .filter((item) => !item.id.startsWith('new-'))
      .reduce((sum, item) => sum + item.quantity, 0);
  }, [isEditMode, editItems]);

  // Notificar cambios en el conteo de items (solo en modo edici√≥n)
  const [lastNotifiedCount, setLastNotifiedCount] = useState<number | null>(
    null,
  );

  useEffect(() => {
    if (isEditMode && onItemsCountChanged && visible && orderDataLoaded) {
      // Solo notificar si el conteo realmente cambi√≥
      if (existingItemsCount !== lastNotifiedCount) {
        onItemsCountChanged(existingItemsCount);
        setLastNotifiedCount(existingItemsCount);
      }
    }
  }, [
    isEditMode,
    existingItemsCount,
    visible,
    orderDataLoaded,
    lastNotifiedCount,
    onItemsCountChanged,
  ]);

  // Calcular total pagado
  const totalPaid = useMemo(() => {
    if (!isEditMode || !payments) return 0;
    return payments
      .filter((p) => p.paymentStatus === PaymentStatusEnum.COMPLETED)
      .reduce((sum, payment) => sum + (Number(payment.amount) || 0), 0);
  }, [payments, isEditMode]);

  const pendingAmount = useMemo(() => {
    return Math.max(0, total - totalPaid);
  }, [total, totalPaid]);

  const { user } = useAuthStore(); // Obtener usuario autenticado
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar); // Hook para snackbar

  // Verificar si el usuario puede registrar pagos usando la utilidad centralizada
  const canRegisterPayments = useMemo(() => {
    return checkCanRegisterPayments(user);
  }, [user]);

  // Estados locales solo para UI (errores, visibilidad de men√∫s/modales)
  const [areaMenuVisible, setAreaMenuVisible] = useState(false);
  const [tableMenuVisible, setTableMenuVisible] = useState(false);
  const [areaError, setAreaError] = useState<string | null>(null);
  const [tableError, setTableError] = useState<string | null>(null);
  const [recipientNameError, setRecipientNameError] = useState<string | null>(
    null,
  );
  const [recipientPhoneError, setRecipientPhoneError] = useState<string | null>(
    null,
  );
  const [addressError, setAddressError] = useState<string | null>(null);
  const [isTimePickerVisible, setTimePickerVisible] = useState(false);
  const [isTimeAlertVisible, setTimeAlertVisible] = useState(false);
  const [isConfirming, setIsConfirming] = useState(false);
  const [showExitConfirmation, setShowExitConfirmation] = useState(false);
  const [editingItemFromList, setEditingItemFromList] =
    useState<CartItem | null>(null);
  const [editingProduct, setEditingProduct] = useState<Product | null>(null);
  const [isModalReady, setIsModalReady] = useState(false);
  const [showOptionsMenu, setShowOptionsMenu] = useState(false);
  const [showCancelConfirmation, setShowCancelConfirmation] = useState(false);
  const [
    showModifyInProgressConfirmation,
    setShowModifyInProgressConfirmation,
  ] = useState(false);
  const [pendingModifyAction, setPendingModifyAction] = useState<
    (() => void) | null
  >(null);
  const [modifyingItemName, setModifyingItemName] = useState<string>('');
  const [showHistoryModal, setShowHistoryModal] = useState(false);
  const [showDetailModal, setShowDetailModal] = useState(false);
  const [showPaymentModal, setShowPaymentModal] = useState(false);
  const [showAdjustmentModal, setShowAdjustmentModal] = useState(false);
  const [adjustmentToEdit, setAdjustmentToEdit] =
    useState<OrderAdjustment | null>(null);
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  const [paymentAmount, setPaymentAmount] = useState<string>('');
  const [_paymentMethod, _setPaymentMethod] = useState<
    'CASH' | 'CARD' | 'TRANSFER' | null
  >('CASH');
  const [prepaymentId, setPrepaymentId] = useState<string | null>(null);
  const [showPrepaymentModal, setShowPrepaymentModal] = useState(false);
  const [showDeletePrepaymentConfirm, setShowDeletePrepaymentConfirm] =
    useState(false);

  // Estado original de la orden para detectar cambios
  const [originalOrderState, setOriginalOrderState] = useState<{
    items: CartItem[];
    orderType: OrderType;
    tableId: string | null;
    isTemporaryTable: boolean;
    temporaryTableName: string;
    deliveryInfo: DeliveryInfo;
    notes: string;
    scheduledAt: Date | null;
    adjustments: OrderAdjustment[];
  } | null>(null);

  // --- Queries para √Åreas y Mesas (sin cambios) ---
  const {
    data: areasData,
    isLoading: isLoadingAreas,
    error: errorAreas,
  } = useGetAreas();
  const {
    data: tablesData,
    isLoading: isLoadingTables,
    error: errorTables,
  } = useGetTablesByArea(selectedAreaId);

  // Funci√≥n helper para buscar informaci√≥n de un modifier por su ID
  const findModifierById = useCallback(
    (modifierId: string): CartItemModifier | null => {
      if (!menu) return null;

      for (const category of menu) {
        for (const subcategory of category.subcategories || []) {
          for (const product of subcategory.products || []) {
            for (const modifierGroup of product.modifierGroups || []) {
              const modifier = modifierGroup.productModifiers?.find(
                (mod) => mod.id === modifierId,
              );
              if (modifier) {
                return {
                  id: modifier.id,
                  modifierGroupId: modifierGroup.id,
                  name: modifier.name,
                  price: modifier.price,
                };
              }
            }
          }
        }
      }
      return null;
    },
    [menu],
  );

  // Cargar datos de la orden cuando est√© en modo edici√≥n
  useEffect(() => {
    if (!isEditMode || !orderData || !visible) return;

    // Establecer los valores del formulario
    setEditOrderType(orderData.orderType);
    setEditSelectedTableId(orderData.tableId ?? null);
    setEditScheduledTime(
      orderData.scheduledAt ? new Date(orderData.scheduledAt) : null,
    );
    // Cargar deliveryInfo
    setEditDeliveryInfo(orderData.deliveryInfo || {});
    setEditOrderNotes(orderData.notes ?? '');

    // Cargar ajustes si existen
    if (orderData.adjustments && Array.isArray(orderData.adjustments)) {
      const mappedAdjustments = orderData.adjustments.map((adj) => ({
        id: adj.id,
        name: adj.name,
        description: adj.description || '',
        isPercentage: adj.isPercentage,
        value: adj.value,
        amount: adj.amount,
        isDeleted: false, // Importante: establecer como no eliminado
        isNew: false, // No es nuevo, viene del backend
      }));
      setEditAdjustments(mappedAdjustments);
    } else {
      setEditAdjustments([]);
    }

    // Si hay una mesa, necesitamos encontrar el √°rea
    if (orderData.tableId && orderData.table) {
      // Intentar obtener el areaId de diferentes formas
      const areaId = orderData.table.areaId || orderData.table.area?.id;
      if (areaId) {
        setEditSelectedAreaId(areaId);
      }

      // Verificar si es una mesa temporal
      if (orderData.table.isTemporary) {
        setEditIsTemporaryTable(true);
        setEditTemporaryTableName(orderData.table.name || '');
      } else {
        setEditIsTemporaryTable(false);
        setEditTemporaryTableName('');
      }
    } else {
      setEditIsTemporaryTable(false);
      setEditTemporaryTableName('');
    }

    // Mapa para agrupar items id√©nticos
    const groupedItemsMap = new Map<string, CartItem>();

    // Mapear y agrupar los items de la orden
    if (orderData.orderItems && Array.isArray(orderData.orderItems)) {
      orderData.orderItems.forEach((item: any) => {
        // Mapear los modificadores desde el nuevo formato (productModifiers)
        const modifiers: CartItemModifier[] = [];

        // Si vienen en el formato antiguo (item.modifiers con objetos)
        if (item.modifiers && Array.isArray(item.modifiers)) {
          item.modifiers.forEach((mod: any) => {
            modifiers.push({
              id: mod.productModifierId,
              modifierGroupId: mod.productModifier?.modifierGroupId || '',
              name: mod.productModifier?.name || 'Modificador',
              price: parseFloat(mod.price) || 0,
            });
          });
        }
        // Si vienen en el nuevo formato (item.productModifiers como array de entidades)
        else if (
          item.productModifiers &&
          Array.isArray(item.productModifiers)
        ) {
          item.productModifiers.forEach((mod: any) => {
            const modifierInfo = findModifierById(mod.id) || {
              id: mod.id,
              modifierGroupId: mod.modifierGroupId || '',
              name: mod.name || 'Modificador',
              price: parseFloat(mod.price) || 0,
            };
            modifiers.push(modifierInfo);
          });
        }

        const modifiersPrice = modifiers.reduce(
          (sum: number, mod: any) => sum + (parseFloat(mod.price) || 0),
          0,
        );
        const unitPrice = parseFloat(item.basePrice || '0');

        // Crear una clave √∫nica para agrupar items id√©nticos (incluye estado de preparaci√≥n)
        const modifierIds = modifiers
          .map((m) => m.id)
          .sort()
          .join(',');
        const pizzaCustomizationIds = item.selectedPizzaCustomizations
          ? item.selectedPizzaCustomizations
              .map((c) => `${c.pizzaCustomizationId}-${c.half}-${c.action}`)
              .sort()
              .join(',')
          : '';
        const groupKey = `${item.productId}-${item.productVariantId || 'null'}-${modifierIds}-${pizzaCustomizationIds}-${item.preparationNotes || ''}-${item.preparationStatus || 'PENDING'}`;

        const existingItem = groupedItemsMap.get(groupKey);

        if (
          existingItem &&
          existingItem.preparationStatus === item.preparationStatus
        ) {
          // Si ya existe un item id√©ntico con el mismo estado, incrementar la cantidad
          existingItem.quantity += 1;
          existingItem.totalPrice =
            (unitPrice + modifiersPrice) * existingItem.quantity;
          existingItem.id = `${existingItem.id},${item.id}`;
        } else {
          // Si es un nuevo item, agregarlo al mapa

          const cartItem: CartItem = {
            id: item.id,
            productId: item.productId,
            productName: item.product?.name || 'Producto desconocido',
            quantity: 1, // Empezar con 1, el backend ya no env√≠a quantity
            unitPrice,
            totalPrice: unitPrice + modifiersPrice,
            modifiers,
            variantId: item.productVariantId || undefined,
            variantName: item.productVariant?.name || undefined,
            preparationNotes: item.preparationNotes || undefined,
            preparationStatus: item.preparationStatus || 'PENDING', // Incluir estado de preparaci√≥n
            selectedPizzaCustomizations:
              item.selectedPizzaCustomizations || undefined, // Incluir personalizaciones de pizza
          };
          groupedItemsMap.set(groupKey, cartItem);
        }
      });

      // Convertir el mapa a array
      const mappedItems = Array.from(groupedItemsMap.values());

      setEditItems(mappedItems);
    }

    // Marcar que los datos de la orden ya se cargaron
    setOrderDataLoaded(true);

    // Guardar el estado original de la orden para detectar cambios
    const originalItems = Array.from(groupedItemsMap.values());
    const originalAdjustments =
      orderData.adjustments?.map((adj) => ({
        id: adj.id,
        name: adj.name,
        // description: adj.description, // No existe en el tipo Adjustment
        isPercentage: adj.isPercentage,
        value: adj.value,
        amount: adj.amount,
      })) || [];

    setOriginalOrderState({
      items: originalItems,
      orderType: orderData.orderType,
      tableId: orderData.tableId ?? null,
      isTemporaryTable: orderData.table?.isTemporary || false,
      temporaryTableName: orderData.table?.isTemporary
        ? orderData.table.name
        : '',
      deliveryInfo: orderData.deliveryInfo || {},
      notes: orderData.notes ?? '',
      scheduledAt: orderData.scheduledAt
        ? new Date(orderData.scheduledAt)
        : null,
      adjustments: originalAdjustments,
    });

    // Resetear el flag de cambios no guardados
    setHasUnsavedChanges(false);
  }, [isEditMode, orderData, visible]);

  // Funci√≥n para formatear las personalizaciones de pizza
  const formatPizzaCustomizations = (
    customizations: SelectedPizzaCustomization[],
  ): string => {
    if (!customizations || customizations.length === 0) return '';

    // Agrupar por mitad y tipo
    const groupedByHalf = customizations.reduce(
      (acc, curr) => {
        const half =
          curr.half === PizzaHalf.HALF_1
            ? 'HALF_1'
            : curr.half === PizzaHalf.HALF_2
              ? 'HALF_2'
              : 'FULL';

        if (!acc[half]) {
          acc[half] = {
            flavors: [],
            addedIngredients: [],
            removedIngredients: [],
          };
        }

        // Primero intentar obtener la informaci√≥n de pizzaCustomization si est√° disponible
        let name = '';
        let type = null;

        if (curr.pizzaCustomization) {
          // Si viene la informaci√≥n completa del backend
          name = curr.pizzaCustomization.name;
          type = curr.pizzaCustomization.type;
        } else if (menu) {
          // Si no viene la informaci√≥n completa, buscarla en el men√∫
          outer: for (const category of menu) {
            for (const subcategory of category.subcategories || []) {
              for (const product of subcategory.products || []) {
                if (product.pizzaCustomizations) {
                  const customization = product.pizzaCustomizations.find(
                    (pc) => pc.id === curr.pizzaCustomizationId,
                  );
                  if (customization) {
                    name = customization.name;
                    type = customization.type;
                    break outer;
                  }
                }
              }
            }
          }
        }

        // Si a√∫n no tenemos el nombre, usar el ID como fallback
        if (!name) {
          name = curr.pizzaCustomizationId;
        }

        if (type === 'FLAVOR' || type === CustomizationType.FLAVOR) {
          acc[half].flavors.push(name);
        } else if (
          type === 'INGREDIENT' ||
          type === CustomizationType.INGREDIENT
        ) {
          if (curr.action === CustomizationAction.ADD) {
            acc[half].addedIngredients.push(name);
          } else {
            acc[half].removedIngredients.push(name);
          }
        }

        return acc;
      },
      {} as Record<
        string,
        {
          flavors: string[];
          addedIngredients: string[];
          removedIngredients: string[];
        }
      >,
    );

    // Formatear seg√∫n el tipo de pizza
    if (groupedByHalf.FULL) {
      // Pizza completa
      const parts: string[] = [];
      if (groupedByHalf.FULL.flavors.length > 0) {
        parts.push(groupedByHalf.FULL.flavors.join(', '));
      }
      if (groupedByHalf.FULL.addedIngredients.length > 0) {
        parts.push(`con: ${groupedByHalf.FULL.addedIngredients.join(', ')}`);
      }
      if (groupedByHalf.FULL.removedIngredients.length > 0) {
        parts.push(`sin: ${groupedByHalf.FULL.removedIngredients.join(', ')}`);
      }
      return parts.join(' - ');
    } else if (groupedByHalf.HALF_1 || groupedByHalf.HALF_2) {
      // Pizza mitad y mitad
      const formatHalf = (halfData: {
        flavors: string[];
        addedIngredients: string[];
        removedIngredients: string[];
      }) => {
        const parts: string[] = [];
        if (halfData.flavors.length > 0) {
          parts.push(halfData.flavors.join(', '));
        }
        if (halfData.addedIngredients.length > 0) {
          parts.push(`con: ${halfData.addedIngredients.join(', ')}`);
        }
        if (halfData.removedIngredients.length > 0) {
          parts.push(`sin: ${halfData.removedIngredients.join(', ')}`);
        }
        return parts.join(' - ');
      };

      const half1 = groupedByHalf.HALF_1
        ? formatHalf(groupedByHalf.HALF_1)
        : '';
      const half2 = groupedByHalf.HALF_2
        ? formatHalf(groupedByHalf.HALF_2)
        : '';

      return half1 && half2 ? `(${half1} / ${half2})` : half1 || half2;
    }

    return '';
  };

  // Funci√≥n para agrupar items id√©nticos
  const groupIdenticalItems = useCallback((items: CartItem[]): CartItem[] => {
    const groupedMap = new Map<string, CartItem>();

    items.forEach((item) => {
      // Crear una clave √∫nica basada en todas las propiedades que deben ser id√©nticas
      const modifierIds = item.modifiers
        .map((m) => m.id)
        .sort()
        .join(',');

      // Incluir personalizaciones de pizza en la clave
      const pizzaCustomizationIds = item.selectedPizzaCustomizations
        ? item.selectedPizzaCustomizations
            .map((pc) => `${pc.pizzaCustomizationId}-${pc.half}-${pc.action}`)
            .sort()
            .join(',')
        : '';

      const groupKey = `${item.productId}-${item.variantId || 'null'}-${modifierIds}-${pizzaCustomizationIds}-${item.preparationNotes || ''}-${item.preparationStatus || 'PENDING'}`;

      const existingItem = groupedMap.get(groupKey);

      if (existingItem) {
        // Si ya existe un item id√©ntico, incrementar la cantidad
        existingItem.quantity += item.quantity;
        // Recalcular el precio total considerando modificadores
        const modifiersPrice = existingItem.modifiers.reduce(
          (sum, mod) => sum + (mod.price || 0),
          0,
        );
        existingItem.totalPrice =
          (existingItem.unitPrice + modifiersPrice) * existingItem.quantity;

        // Concatenar IDs si ambos items tienen IDs reales (no temporales)
        if (
          !existingItem.id.startsWith('new-') &&
          !item.id.startsWith('new-')
        ) {
          const existingIds = existingItem.id.split(',');
          const newIds = item.id.split(',');
          const allIds = [...new Set([...existingIds, ...newIds])];
          existingItem.id = allIds.join(',');
        }
      } else {
        // Si es nuevo, agregarlo al mapa con una copia completa
        groupedMap.set(groupKey, { ...item });
      }
    });

    const result = Array.from(groupedMap.values());

    return result;
  }, []);

  // Estado para controlar si ya procesamos los productos pendientes (declarado arriba)
  // const [processedPendingProductsIds, setProcessedPendingProductsIds] =
  //   useState<string[]>([]);
  // Estado para controlar si los datos de la orden ya se cargaron (declarado arriba)
  // const [orderDataLoaded, setOrderDataLoaded] = useState(false);

  // Manejar productos pendientes de a√±adir
  useEffect(() => {
    // Solo procesar cuando:
    // 1. Hay productos pendientes
    // 2. Estamos en modo edici√≥n
    // 3. El modal es visible
    // 4. Los datos de la orden ya se cargaron
    if (
      pendingProductsToAdd.length > 0 &&
      isEditMode &&
      visible &&
      orderDataLoaded
    ) {
      // Filtrar productos que no han sido procesados a√∫n
      const unprocessedProducts = pendingProductsToAdd.filter((item) => {
        // Usar una clave √∫nica para cada producto basada en sus propiedades
        const productKey = `${item.productId}-${item.variantId || 'null'}-${JSON.stringify(item.modifiers.map((m) => m.id).sort())}-${item.preparationNotes || ''}`;
        return !processedPendingProductsIds.includes(productKey);
      });

      if (unprocessedProducts.length > 0) {
        // Marcar los nuevos productos con estado "NEW" temporal
        const newProductsWithStatus = unprocessedProducts.map((item) => ({
          ...item,
          preparationStatus: 'NEW' as const,
          id: `new-${Date.now()}-${Math.floor(Math.random() * 1000000)}`,
        }));

        // Combinar con items existentes y agrupar
        setEditItems((prevItems) => {
          const allItems = [...prevItems, ...newProductsWithStatus];
          const grouped = groupIdenticalItems(allItems);

          return grouped;
        });

        // Marcar estos productos como procesados
        const newProcessedIds = unprocessedProducts.map(
          (item) =>
            `${item.productId}-${item.variantId || 'null'}-${JSON.stringify(item.modifiers.map((m) => m.id).sort())}-${item.preparationNotes || ''}`,
        );
        setProcessedPendingProductsIds((prev) => [...prev, ...newProcessedIds]);

        // Calcular cu√°ntos items √∫nicos se a√±adieron
        const uniqueNewItems = newProductsWithStatus.length;
        showSnackbar({
          message: `${uniqueNewItems} producto${uniqueNewItems > 1 ? 's' : ''} a√±adido${uniqueNewItems > 1 ? 's' : ''}`,
          type: 'success',
        });
      }
    }
  }, [
    pendingProductsToAdd,
    isEditMode,
    visible,
    orderDataLoaded,
    processedPendingProductsIds,
    groupIdenticalItems,
    showSnackbar,
  ]);

  // Resetear los IDs procesados cuando el modal se cierre o cambie de orden
  // (esto se maneja en el useEffect de reseteo de estados)

  // Limpiar errores locales al cambiar tipo de orden (m√°s simple)
  useEffect(() => {
    setAreaError(null);
    setTableError(null);
    setRecipientNameError(null);
    setRecipientPhoneError(null);
    setAddressError(null);
  }, [orderType]);

  // Detectar cambios sin guardar
  useEffect(() => {
    if (!isEditMode || !originalOrderState || !visible) {
      setHasUnsavedChanges(false);
      return;
    }

    // Comparar el estado actual con el original
    const hasChanges =
      // Cambios en items
      JSON.stringify(editItems) !== JSON.stringify(originalOrderState.items) ||
      // Cambios en tipo de orden
      editOrderType !== originalOrderState.orderType ||
      // Cambios en mesa
      editSelectedTableId !== originalOrderState.tableId ||
      // Cambios en mesa temporal
      editIsTemporaryTable !== originalOrderState.isTemporaryTable ||
      editTemporaryTableName !== originalOrderState.temporaryTableName ||
      // Cambios en datos del cliente
      JSON.stringify(editDeliveryInfo) !==
        JSON.stringify(originalOrderState.deliveryInfo) ||
      editOrderNotes !== originalOrderState.notes ||
      // Cambios en hora programada (comparar valores de tiempo, no referencias)
      (editScheduledTime?.getTime() ?? null) !==
        (originalOrderState.scheduledAt?.getTime() ?? null) ||
      // Cambios en ajustes
      JSON.stringify(editAdjustments) !==
        JSON.stringify(originalOrderState.adjustments);

    setHasUnsavedChanges(hasChanges);
  }, [
    isEditMode,
    originalOrderState,
    visible,
    editItems,
    editOrderType,
    editSelectedTableId,
    editIsTemporaryTable,
    editTemporaryTableName,
    editDeliveryInfo,
    editOrderNotes,
    editScheduledTime,
    editAdjustments,
  ]);

  // Resetear estados cuando el modal se cierre
  useEffect(() => {
    if (!visible && isEditMode) {
      // Resetear estados de edici√≥n cuando el modal se cierre
      setEditOrderType(OrderTypeEnum.DINE_IN);
      setEditSelectedAreaId(null);
      setEditSelectedTableId(null);
      setEditScheduledTime(null);
      setEditDeliveryInfo({});
      setEditOrderNotes('');
      setEditItems([]);
      setShowExitConfirmation(false);
      setEditingItemFromList(null);
      setEditingProduct(null);
      setIsModalReady(false);
      setOrderDataLoaded(false); // Resetear el flag de datos cargados
      setProcessedPendingProductsIds([]); // Resetear los IDs de productos procesados
      setLastNotifiedCount(null); // Resetear el conteo notificado
      setOriginalOrderState(null); // Resetear el estado original
      setHasUnsavedChanges(false); // Resetear el flag de cambios
    }
  }, [visible, isEditMode]);

  // Manejar la preparaci√≥n del modal con un peque√±o delay
  useEffect(() => {
    if (visible && !isModalReady) {
      const timer = setTimeout(() => {
        setIsModalReady(true);
      }, 100); // 100ms delay para evitar conflictos de focus
      return () => clearTimeout(timer);
    }
  }, [visible, isModalReady]);

  // Funciones para manejar ajustes
  const handleAddAdjustment = useCallback(
    (adjustment: OrderAdjustment) => {
      if (isEditMode) {
        // Asegurar que el ajuste tenga un ID √∫nico
        const newAdjustment = {
          ...adjustment,
          id:
            adjustment.id ||
            `new-adjustment-${Date.now()}-${Math.floor(Math.random() * 1000000)}`,
          isNew: true,
        };
        setEditAdjustments((prev) => [...prev, newAdjustment]);
      }
    },
    [isEditMode],
  );

  const handleUpdateAdjustment = useCallback(
    (id: string, updatedAdjustment: OrderAdjustment) => {
      if (isEditMode) {
        setEditAdjustments((prev) =>
          prev.map((adj) =>
            adj.id === id ? { ...adj, ...updatedAdjustment, id } : adj,
          ),
        );
      }
    },
    [isEditMode],
  );

  const handleRemoveAdjustment = useCallback(
    (id: string) => {
      if (isEditMode) {
        setEditAdjustments((prev) => prev.filter((adj) => adj.id !== id));
      }
    },
    [isEditMode],
  );

  // Funci√≥n para limpiar datos seg√∫n el tipo de orden (solo se ejecuta al guardar)
  const cleanOrderDataForSubmission = useCallback(
    (
      orderType: OrderType,
      deliveryInfo: DeliveryInfo,
      selectedTableId: string | null,
      selectedAreaId: string | null,
      isTemporaryTable: boolean,
      temporaryTableName: string,
    ) => {
      const cleanedData: {
        deliveryInfo: DeliveryInfo;
        tableId?: string;
        isTemporaryTable?: boolean;
        temporaryTableName?: string;
        temporaryTableAreaId?: string;
      } = {
        deliveryInfo: {},
      };

      // Limpiar deliveryInfo seg√∫n el tipo de orden
      if (orderType === OrderTypeEnum.DINE_IN) {
        // DINE_IN: No necesita deliveryInfo, pero s√≠ mesa
        cleanedData.deliveryInfo = {};
        if (isTemporaryTable) {
          cleanedData.isTemporaryTable = true;
          cleanedData.temporaryTableName = temporaryTableName;
          cleanedData.temporaryTableAreaId = selectedAreaId || undefined;
        } else {
          cleanedData.tableId = selectedTableId || undefined;
        }
      } else if (orderType === OrderTypeEnum.TAKE_AWAY) {
        // TAKE_AWAY: Solo recipientName, recipientPhone y deliveryInstructions
        cleanedData.deliveryInfo = {
          recipientName: deliveryInfo.recipientName,
          recipientPhone: deliveryInfo.recipientPhone,
          deliveryInstructions: deliveryInfo.deliveryInstructions,
        };
        // No necesita mesa ni √°rea
      } else if (orderType === OrderTypeEnum.DELIVERY) {
        // DELIVERY: Solo campos de direcci√≥n y recipientPhone
        cleanedData.deliveryInfo = {
          fullAddress: deliveryInfo.fullAddress,
          street: deliveryInfo.street,
          number: deliveryInfo.number,
          interiorNumber: deliveryInfo.interiorNumber,
          neighborhood: deliveryInfo.neighborhood,
          city: deliveryInfo.city,
          state: deliveryInfo.state,
          zipCode: deliveryInfo.zipCode,
          country: deliveryInfo.country,
          latitude: deliveryInfo.latitude,
          longitude: deliveryInfo.longitude,
          recipientPhone: deliveryInfo.recipientPhone,
          deliveryInstructions: deliveryInfo.deliveryInstructions,
        };
        // No necesita mesa ni √°rea
      }

      return cleanedData;
    },
    [],
  );

  const handleConfirm = async () => {
    if (isConfirming) return; // Prevenir m√∫ltiples clics

    // Resetear errores
    setAreaError(null);
    setTableError(null);
    setRecipientNameError(null);
    setRecipientPhoneError(null);
    setAddressError(null);

    if (items.length === 0) {
      return;
    }

    let isValid = true;

    // Validaciones seg√∫n el tipo de orden
    if (orderType === OrderTypeEnum.DINE_IN) {
      if (!selectedAreaId) {
        setAreaError('Debe seleccionar un √°rea');
        isValid = false;
      }
      if (isTemporaryTable) {
        if (!temporaryTableName || temporaryTableName.trim() === '') {
          setTableError('Debe ingresar un nombre para la mesa temporal');
          isValid = false;
        }
      } else {
        if (!selectedTableId) {
          setTableError('Debe seleccionar una mesa');
          isValid = false;
        }
      }
    } else if (orderType === OrderTypeEnum.TAKE_AWAY) {
      if (
        !deliveryInfo.recipientName ||
        deliveryInfo.recipientName.trim() === ''
      ) {
        setRecipientNameError('El nombre del cliente es obligatorio');
        isValid = false;
      }
      // Si se proporciona tel√©fono, validar que tenga al menos 10 d√≠gitos
      if (
        deliveryInfo.recipientPhone &&
        deliveryInfo.recipientPhone.trim() !== ''
      ) {
        const phoneDigits = deliveryInfo.recipientPhone.replace(/\D/g, '');
        if (phoneDigits.length < 10) {
          setRecipientPhoneError('El tel√©fono debe tener al menos 10 d√≠gitos');
          isValid = false;
        }
      }
    } else if (orderType === OrderTypeEnum.DELIVERY) {
      if (!deliveryInfo.fullAddress || deliveryInfo.fullAddress.trim() === '') {
        setAddressError('La direcci√≥n es obligatoria para Domicilio');
        isValid = false;
      }
      if (
        !deliveryInfo.recipientPhone ||
        deliveryInfo.recipientPhone.trim() === ''
      ) {
        setRecipientPhoneError('El tel√©fono es obligatorio para Domicilio');
        isValid = false;
      } else {
        // Validar que tenga al menos 10 d√≠gitos
        const phoneDigits = deliveryInfo.recipientPhone.replace(/\D/g, '');
        if (phoneDigits.length < 10) {
          setRecipientPhoneError('El tel√©fono debe tener al menos 10 d√≠gitos');
          isValid = false;
        }
      }
    }

    if (!isValid) {
      return;
    }

    // Limpiar datos seg√∫n el tipo de orden SOLO AL GUARDAR
    const cleanedData = cleanOrderDataForSubmission(
      orderType,
      deliveryInfo,
      selectedTableId,
      selectedAreaId,
      isTemporaryTable,
      temporaryTableName,
    );

    // Mapear items del carrito al formato esperado por el DTO del backend
    const itemsForBackend: OrderItemDtoForBackend[] = [];

    // Mapear items seg√∫n el modo (creaci√≥n o edici√≥n)
    items.forEach((item: CartItem) => {
      if (isEditMode && item.id && !item.id.startsWith('new-')) {
        // En modo edici√≥n, expandir items con ID real seg√∫n la cantidad
        const existingIds = item.id
          .split(',')
          .filter((id) => id.trim() && !id.startsWith('new-'));
        const requiredQuantity = item.quantity;

        // Enviar cada item individualmente
        for (let i = 0; i < requiredQuantity; i++) {
          const isExistingItem = i < existingIds.length;

          itemsForBackend.push({
            id: isExistingItem ? existingIds[i] : undefined,
            productId: item.productId,
            productVariantId: item.variantId || null,
            basePrice: Number(item.unitPrice),
            finalPrice: Number(item.totalPrice / item.quantity),
            preparationNotes: item.preparationNotes || null,
            productModifiers:
              item.modifiers && item.modifiers.length > 0
                ? item.modifiers.map((mod) => ({
                    modifierId: mod.id,
                  }))
                : undefined,
            selectedPizzaCustomizations:
              item.selectedPizzaCustomizations || undefined,
          });
        }
      } else {
        // Items nuevos se expanden seg√∫n cantidad
        for (let i = 0; i < item.quantity; i++) {
          itemsForBackend.push({
            productId: item.productId,
            productVariantId: item.variantId || null,
            basePrice: Number(item.unitPrice),
            finalPrice: Number(item.totalPrice / item.quantity),
            preparationNotes: item.preparationNotes || null,
            productModifiers:
              item.modifiers && item.modifiers.length > 0
                ? item.modifiers.map((mod) => ({
                    modifierId: mod.id,
                  }))
                : undefined,
            selectedPizzaCustomizations:
              item.selectedPizzaCustomizations || undefined,
          });
        }
      }
    });

    // Formatear el n√∫mero de tel√©fono para el backend
    let formattedPhone: string | undefined = undefined;
    if (
      cleanedData.deliveryInfo.recipientPhone &&
      cleanedData.deliveryInfo.recipientPhone.trim() !== ''
    ) {
      formattedPhone = cleanedData.deliveryInfo.recipientPhone.trim();
    }

    const orderDetails: OrderDetailsForBackend = {
      userId: user?.id,
      orderType,
      subtotal,
      total,
      items: itemsForBackend,
      tableId: cleanedData.tableId,
      isTemporaryTable: cleanedData.isTemporaryTable,
      temporaryTableName: cleanedData.temporaryTableName,
      temporaryTableAreaId: cleanedData.temporaryTableAreaId,
      scheduledAt: scheduledTime ? scheduledTime : undefined,
      deliveryInfo: {
        ...cleanedData.deliveryInfo,
        recipientPhone: formattedPhone,
      },
      notes: orderNotes || undefined,
      adjustments: isEditMode
        ? editAdjustments
            .filter((adj) => !adj.isDeleted)
            .map((adj) => {
              return {
                orderId: orderId || undefined,
                name: adj.name,
                isPercentage: adj.isPercentage,
                value: adj.value,
                amount: adj.amount,
              };
            })
        : undefined,
    };

    if (!orderDetails.userId) {
      // Usuario no autenticado
      return;
    }

    setIsConfirming(true);

    // Si hay un pre-pago creado, incluir su ID
    if (!isEditMode && prepaymentId) {
      orderDetails.prepaymentId = prepaymentId;
    }

    try {
      await onConfirmOrder(orderDetails);
      setIsConfirming(false);

      if (isEditMode) {
        setOriginalOrderState({
          items: [...editItems],
          orderType: editOrderType,
          tableId: editSelectedTableId,
          isTemporaryTable: editIsTemporaryTable,
          temporaryTableName: editTemporaryTableName,
          deliveryInfo: editDeliveryInfo,
          notes: editOrderNotes,
          scheduledAt: editScheduledTime,
          adjustments: editAdjustments,
        });
        setHasUnsavedChanges(false);

        showSnackbar({
          message: 'Cambios guardados exitosamente',
          type: 'success',
        });

        onClose?.();
      }
    } catch (error) {
      setIsConfirming(false);
      // Error manejado por el componente padre
    }
  };

  const selectedAreaName = useMemo(
    () => areasData?.find((a: any) => a.id === selectedAreaId)?.name,
    [areasData, selectedAreaId],
  );
  const selectedTableName = useMemo(() => {
    return tablesData?.find((t) => t.id === selectedTableId)?.name;
  }, [tablesData, selectedTableId]);

  const showTimePicker = () => {
    setTimePickerVisible(true);
  };

  const hideTimePicker = () => setTimePickerVisible(false);

  const handlePrepaymentCreated = async (
    prepaymentIdCreated: string,
    amount: number,
    method: 'CASH' | 'CARD' | 'TRANSFER',
  ) => {
    const isUpdate = prepaymentId === prepaymentIdCreated;

    setPrepaymentId(prepaymentIdCreated);
    setPaymentAmount(amount.toFixed(2));
    setPaymentMethod(method);
    setShowPrepaymentModal(false);

    showSnackbar({
      message: isUpdate
        ? 'Pago actualizado correctamente'
        : 'Pago registrado correctamente',
      type: 'success',
    });
  };

  const handleDeletePrepayment = () => {
    if (!prepaymentId) return;

    setShowDeletePrepaymentConfirm(true);
  };

  const confirmDeletePrepayment = async () => {
    if (!prepaymentId) return;

    try {
      await prepaymentService.deletePrepayment(prepaymentId);
      setPrepaymentId(null);
      setPaymentAmount('');
      setPaymentMethod(null);

      showSnackbar({
        message: 'Prepago eliminado correctamente',
        type: 'success',
      });
    } catch (error: any) {
      let errorMessage = 'Error al eliminar el prepago';

      // Manejar espec√≠ficamente el error 404
      if (error?.response?.status === 404) {
        errorMessage = 'El prepago ya no existe o fue eliminado previamente';
        // Limpiar el estado local si el prepago ya no existe
        setPrepaymentId(null);
        setPaymentAmount('');
        setPaymentMethod(null);
      } else if (error?.response?.data?.message) {
        errorMessage = error.response.data.message;
      }

      showSnackbar({
        message: errorMessage,
        type: 'error',
      });
    } finally {
      setShowDeletePrepaymentConfirm(false);
    }
  };

  const handlePrepaymentDeleted = () => {
    setPrepaymentId(null);
    setPaymentAmount('');
    setPaymentMethod('CASH');
    setShowPrepaymentModal(false);

    showSnackbar({
      message: 'Pago eliminado correctamente',
      type: 'success',
    });
  };

  const handleTimeConfirm = (date: Date) => {
    const now = new Date();
    now.setSeconds(0, 0);

    if (date < now) {
      hideTimePicker();
      setTimeAlertVisible(true);
    } else {
      if (isEditMode) {
        setEditScheduledTime(date);
      } else {
        setScheduledTime(date);
      }
      hideTimePicker();
    }
  };

  const formattedScheduledTime = useMemo(() => {
    if (!scheduledTime) return null;
    try {
      return format(scheduledTime, 'h:mm a').toLowerCase(); // Formato 12 horas con am/pm
    } catch (error) {
      // Error al formatear fecha
      return 'Hora inv√°lida';
    }
  }, [scheduledTime]);

  // [HELPER MOVIDO A dateTimeHelpers.ts para evitar problemas con Hermes]

  // Funci√≥n para manejar la edici√≥n de un item del carrito
  const handleEditCartItem = useCallback(
    (item: CartItem) => {
      if (!isEditMode) {
        // En modo creaci√≥n, usar la funci√≥n pasada por props
        if (onEditItem) {
          onEditItem(item);
        }
      } else {
        // Verificar el estado del item antes de permitir edici√≥n
        if (
          item.preparationStatus === 'READY' ||
          item.preparationStatus === 'DELIVERED'
        ) {
          // No permitir editar items listos o entregados
          showSnackbar({
            message: `No se puede editar un producto ${getPreparationStatusText(item.preparationStatus).toLowerCase()}`,
            type: 'error',
          });
          return;
        }

        const proceedWithEdit = () => {
          // En modo edici√≥n, buscar el producto real del men√∫
          if (!menu || !Array.isArray(menu)) {
            return;
          }

          // Buscar el producto en la estructura anidada del men√∫
          let product: Product | undefined;

          for (const category of menu as FullMenuCategory[]) {
            if (
              category.subcategories &&
              Array.isArray(category.subcategories)
            ) {
              for (const subcategory of category.subcategories) {
                if (
                  subcategory.products &&
                  Array.isArray(subcategory.products)
                ) {
                  product = subcategory.products.find(
                    (p: Product) => p.id === item.productId,
                  );
                  if (product) break;
                }
              }
            }
            if (product) break;
          }

          if (product) {
            setEditingItemFromList(item);
            setEditingProduct(product);
          } else {
            // Si no encontramos el producto en el men√∫, crear uno temporal
            setEditingItemFromList(item);

            const tempProduct: Product = {
              id: item.productId,
              name: item.productName,
              price: item.unitPrice,
              hasVariants: !!item.variantId,
              variants: item.variantId
                ? [
                    {
                      id: item.variantId,
                      name: item.variantName || '',
                      price: item.unitPrice,
                    },
                  ]
                : [],
              modifierGroups: [], // Sin grupos de modificadores
              photo: null,
              subcategoryId: '',
              createdAt: new Date(),
              updatedAt: new Date(),
            };

            setEditingProduct(tempProduct);
          }
        };

        if (item.preparationStatus === 'IN_PROGRESS') {
          // Pedir confirmaci√≥n para items en preparaci√≥n
          setModifyingItemName(item.productName);
          setPendingModifyAction(() => proceedWithEdit);
          setShowModifyInProgressConfirmation(true);
        } else {
          // Permitir editar items pendientes o cancelados sin confirmaci√≥n
          proceedWithEdit();
        }
      }
    },
    [isEditMode, onEditItem, menu, showSnackbar],
  );

  // Funci√≥n para actualizar un item editado
  const handleUpdateEditedItem = useCallback(
    (
      itemId: string,
      quantity: number,
      modifiers: CartItemModifier[],
      preparationNotes?: string,
      variantId?: string,
      variantName?: string,
      unitPrice?: number,
      selectedPizzaCustomizations?: SelectedPizzaCustomization[],
      pizzaExtraCost?: number,
    ) => {
      if (!isEditMode) return;

      setEditItems((prev) =>
        prev.map((item) => {
          if (item.id === itemId) {
            const modifiersPrice = modifiers.reduce(
              (sum, mod) => sum + Number(mod.price || 0),
              0,
            );
            const finalUnitPrice =
              unitPrice !== undefined ? unitPrice : item.unitPrice;
            const extraCost = pizzaExtraCost || 0;
            const newTotalPrice =
              (finalUnitPrice + modifiersPrice + extraCost) * quantity;

            return {
              ...item,
              quantity,
              modifiers,
              preparationNotes:
                preparationNotes !== undefined
                  ? preparationNotes
                  : item.preparationNotes,
              variantId: variantId !== undefined ? variantId : item.variantId,
              variantName:
                variantName !== undefined ? variantName : item.variantName,
              unitPrice: finalUnitPrice,
              totalPrice: newTotalPrice,
              selectedPizzaCustomizations:
                selectedPizzaCustomizations !== undefined
                  ? selectedPizzaCustomizations
                  : item.selectedPizzaCustomizations,
            };
          }
          return item;
        }),
      );

      // Cerrar el modal de edici√≥n
      setEditingItemFromList(null);
      setEditingProduct(null);
    },
    [isEditMode],
  );

  // Helper function to render fields in order
  const renderFields = () => {
    switch (orderType) {
      case OrderTypeEnum.DINE_IN: // Usar Enum
        return (
          <>
            {/* 1. √Årea */}
            <View style={styles.dineInSelectorsRow}>
              <View style={styles.dineInSelectorContainer}>
                <Menu
                  visible={areaMenuVisible}
                  onDismiss={() => setAreaMenuVisible(false)}
                  anchor={
                    <AnimatedLabelSelector
                      label="√Årea *"
                      value={selectedAreaName}
                      onPress={() => setAreaMenuVisible(true)}
                      isLoading={isLoadingAreas}
                      error={!!areaError || !!errorAreas}
                      disabled={isLoadingAreas}
                    />
                  }
                >
                  {areasData?.map((area: any) => (
                    <Menu.Item
                      key={area.id}
                      onPress={() => {
                        setSelectedAreaId(area.id);
                        setSelectedTableId(null);
                        setAreaMenuVisible(false);
                        setAreaError(null);
                      }}
                      title={area.name}
                    />
                  ))}
                  {errorAreas && (
                    <Menu.Item title="Error al cargar √°reas" disabled />
                  )}
                </Menu>
                {areaError && !errorAreas && (
                  <HelperText
                    type="error"
                    visible={true}
                    style={styles.helperTextFix}
                  >
                    {areaError}
                  </HelperText>
                )}
                {errorAreas && (
                  <HelperText
                    type="error"
                    visible={true}
                    style={styles.helperTextFix}
                  >
                    Error al cargar √°reas
                  </HelperText>
                )}
              </View>

              {/* 2. Mesa */}
              <View style={styles.dineInSelectorContainer}>
                <Menu
                  visible={tableMenuVisible}
                  onDismiss={() => setTableMenuVisible(false)}
                  anchor={
                    <AnimatedLabelSelector
                      label="Mesa *"
                      value={selectedTableName}
                      onPress={() => setTableMenuVisible(true)}
                      isLoading={isLoadingTables}
                      error={!!tableError || !!errorTables}
                      disabled={
                        !selectedAreaId ||
                        isLoadingTables ||
                        isLoadingAreas ||
                        isTemporaryTable
                      }
                    />
                  }
                >
                  {tablesData?.map((table: Table) => {
                    // En modo edici√≥n, permitir seleccionar la mesa actual aunque est√© ocupada
                    const isCurrentTable =
                      isEditMode && orderData?.tableId === table.id;
                    const canSelect = table.isAvailable || isCurrentTable;

                    return (
                      <Menu.Item
                        key={table.id}
                        onPress={() => {
                          if (canSelect) {
                            setSelectedTableId(table.id);
                            setTableMenuVisible(false);
                            setTableError(null);
                          }
                        }}
                        title={`${table.name}${!table.isAvailable && !isCurrentTable ? ' (Ocupada)' : ''}`}
                        disabled={!canSelect}
                        titleStyle={
                          !canSelect ? { color: theme.colors.error } : undefined
                        }
                      />
                    );
                  })}
                  {selectedAreaId &&
                    tablesData?.length === 0 &&
                    !isLoadingTables &&
                    !errorTables && <Menu.Item title="No hay mesas" disabled />}
                  {errorTables && (
                    <Menu.Item title="Error al cargar mesas" disabled />
                  )}
                </Menu>
                {tableError && !errorTables && !isTemporaryTable && (
                  <HelperText
                    type="error"
                    visible={true}
                    style={styles.helperTextFix}
                  >
                    {tableError}
                  </HelperText>
                )}
                {errorTables && (
                  <HelperText
                    type="error"
                    visible={true}
                    style={styles.helperTextFix}
                  >
                    Error al cargar mesas
                  </HelperText>
                )}
              </View>
            </View>

            {/* Opci√≥n de mesa temporal */}
            <View style={[styles.sectionCompact, styles.fieldContainer]}>
              <TouchableOpacity
                onPress={() => {
                  setIsTemporaryTable(!isTemporaryTable);
                  if (!isTemporaryTable) {
                    // Si activamos mesa temporal, limpiar la selecci√≥n de mesa
                    setSelectedTableId(null);
                    setTableError(null);
                  } else {
                    // Si desactivamos mesa temporal, limpiar el nombre
                    setTemporaryTableName('');
                  }
                }}
                style={styles.checkboxContainer}
              >
                <Checkbox.Android
                  status={isTemporaryTable ? 'checked' : 'unchecked'}
                  onPress={() => {
                    setIsTemporaryTable(!isTemporaryTable);
                    if (!isTemporaryTable) {
                      // Si activamos mesa temporal, limpiar la selecci√≥n de mesa
                      setSelectedTableId(null);
                      setTableError(null);
                    } else {
                      // Si desactivamos mesa temporal, limpiar el nombre
                      setTemporaryTableName('');
                    }
                  }}
                  color={theme.colors.primary}
                />
                <Text style={styles.checkboxLabel}>
                  {isEditMode && isTemporaryTable
                    ? 'Mesa temporal'
                    : 'Crear mesa temporal'}
                </Text>
              </TouchableOpacity>

              {/* Campo para nombre de mesa temporal */}
              {(isTemporaryTable || (isEditMode && editIsTemporaryTable)) && (
                <View style={styles.temporaryTableInputContainer}>
                  <SpeechRecognitionInput
                    key={`temporary-table-name-${isEditMode ? 'edit' : 'create'}`}
                    label="Nombre de la Mesa Temporal *"
                    value={temporaryTableName}
                    onChangeText={(text) => {
                      setTemporaryTableName(text);
                      if (tableError) setTableError(null);
                    }}
                    error={!!tableError && isTemporaryTable}
                    speechLang="es-MX"
                    autoCapitalize="words"
                    autoCorrect={false}
                    placeholder="Ej: Mesa Terraza 1"
                    editable={true} // Editable tanto en creaci√≥n como en edici√≥n
                  />
                  {tableError && isTemporaryTable && (
                    <HelperText
                      type="error"
                      visible={true}
                      style={styles.helperTextFix}
                    >
                      {tableError}
                    </HelperText>
                  )}
                </View>
              )}
            </View>

            {/* 3. Notas */}
            <View style={[styles.sectionCompact, styles.fieldContainer]}>
              <SpeechRecognitionInput
                key="notes-input-dine-in"
                label="Notas de la Orden (Opcional)"
                value={orderNotes}
                onChangeText={setOrderNotes}
                multiline
                speechLang="es-MX"
              />
            </View>

            {/* 4. Programar Hora */}
            <View style={[styles.sectionCompact, styles.fieldContainer]}>
              <AnimatedLabelSelector
                label="Programar Hora (Opcional)"
                value={formattedScheduledTime}
                onPress={showTimePicker}
                onClear={() => setScheduledTime(null)}
              />
            </View>
          </>
        );
      case OrderTypeEnum.TAKE_AWAY: // Usar Enum
        return (
          <>
            {/* 1. Nombre Cliente */}
            <View style={[styles.sectionCompact, styles.fieldContainer]}>
              <SpeechRecognitionInput
                key={`customer-name-input-${orderType}`}
                label="Nombre del Cliente *"
                value={deliveryInfo.recipientName || ''}
                onChangeText={(text) => {
                  setDeliveryInfo({ ...deliveryInfo, recipientName: text });
                  if (recipientNameError) setRecipientNameError(null);
                }}
                error={!!recipientNameError}
                speechLang="es-MX"
                autoCapitalize="words"
                autoCorrect={false}
              />
              {recipientNameError && (
                <HelperText
                  type="error"
                  visible={true}
                  style={styles.helperTextFix}
                >
                  {recipientNameError}
                </HelperText>
              )}
            </View>

            {/* 2. Tel√©fono */}
            <View style={[styles.sectionCompact, styles.fieldContainer]}>
              <View style={styles.phoneInputWrapper}>
                <SpeechRecognitionInput
                  key={`phone-input-takeaway-${orderType}`}
                  label="Tel√©fono (Opcional)"
                  value={deliveryInfo.recipientPhone || ''}
                  onChangeText={(text) => {
                    setDeliveryInfo({ ...deliveryInfo, recipientPhone: text });
                    if (recipientPhoneError) setRecipientPhoneError(null);
                  }}
                  keyboardType="phone-pad"
                  error={!!recipientPhoneError} // Aunque opcional, puede tener errores de formato si se ingresa
                  speechLang="es-MX"
                  autoCorrect={false}
                />
                {(deliveryInfo.recipientPhone || '').length > 0 &&
                  !recipientPhoneError && (
                    <Text style={styles.digitCounterAbsolute}>
                      {
                        (deliveryInfo.recipientPhone || '').replace(/\D/g, '')
                          .length
                      }{' '}
                      d√≠gitos
                    </Text>
                  )}
              </View>
              {recipientPhoneError && (
                <HelperText
                  type="error"
                  visible={true}
                  style={styles.helperTextFix}
                >
                  {recipientPhoneError}
                </HelperText>
              )}
            </View>

            {/* 3. Notas */}
            <View style={[styles.sectionCompact, styles.fieldContainer]}>
              <SpeechRecognitionInput
                key="notes-input-takeaway"
                label="Notas de la Orden (Opcional)"
                value={orderNotes}
                onChangeText={setOrderNotes}
                multiline
                speechLang="es-MX"
              />
            </View>

            {/* 4. Programar Hora */}
            <View style={[styles.sectionCompact, styles.fieldContainer]}>
              <AnimatedLabelSelector
                label="Programar Hora Recolecci√≥n (Opcional)"
                value={formattedScheduledTime}
                onPress={showTimePicker}
                onClear={() => setScheduledTime(null)}
              />
            </View>
          </>
        );
      case OrderTypeEnum.DELIVERY: // Usar Enum
        return (
          <>
            {/* 1. Direcci√≥n */}
            <View style={[styles.sectionCompact, styles.fieldContainer]}>
              <SpeechRecognitionInput
                key="address-input-delivery"
                label="Direcci√≥n de Entrega *"
                value={deliveryInfo.fullAddress || ''}
                onChangeText={(text) => {
                  setDeliveryInfo({ ...deliveryInfo, fullAddress: text });
                  if (addressError) setAddressError(null);
                }}
                error={!!addressError}
                speechLang="es-MX"
                multiline
                isInModal={true}
              />
              {addressError && (
                <HelperText
                  type="error"
                  visible={true}
                  style={styles.helperTextFix}
                >
                  {addressError}
                </HelperText>
              )}
            </View>

            {/* 2. Tel√©fono */}
            <View style={[styles.sectionCompact, styles.fieldContainer]}>
              <SpeechRecognitionInput
                key={`phone-input-delivery-${orderType}`} // Key √∫nica y espec√≠fica
                label="Tel√©fono *"
                value={deliveryInfo.recipientPhone || ''}
                onChangeText={(text) => {
                  // Asegurar que la funci√≥n est√© bien definida aqu√≠
                  setDeliveryInfo({ ...deliveryInfo, recipientPhone: text });
                  if (recipientPhoneError) {
                    setRecipientPhoneError(null);
                  }
                }}
                keyboardType="phone-pad"
                error={!!recipientPhoneError}
                speechLang="es-MX"
                autoCorrect={false}
              />
              <View style={styles.phoneHelperContainer}>
                {recipientPhoneError ? (
                  <HelperText
                    type="error"
                    visible={true}
                    style={[styles.helperTextFix, styles.recipientPhoneError]}
                  >
                    {recipientPhoneError}
                  </HelperText>
                ) : (
                  (deliveryInfo.recipientPhone || '').length > 0 && (
                    <Text style={styles.digitCounter}>
                      {
                        (deliveryInfo.recipientPhone || '').replace(/\D/g, '')
                          .length
                      }{' '}
                      d√≠gitos
                    </Text>
                  )
                )}
              </View>
            </View>

            {/* 3. Notas */}
            <View style={[styles.sectionCompact, styles.fieldContainer]}>
              <SpeechRecognitionInput
                key="notes-input-delivery" // Key √∫nica y espec√≠fica
                label="Notas de la Orden (Opcional)"
                value={orderNotes}
                onChangeText={setOrderNotes}
                multiline
                speechLang="es-MX"
              />
            </View>

            {/* 4. Programar Hora */}
            <View style={[styles.sectionCompact, styles.fieldContainer]}>
              <AnimatedLabelSelector
                label="Programar Hora Entrega (Opcional)"
                value={formattedScheduledTime}
                onPress={showTimePicker}
                onClear={() => setScheduledTime(null)}
              />
            </View>
          </>
        );
      default:
        return null;
    }
  };

  // Mostrar loading si estamos en modo edici√≥n y a√∫n cargando
  if (isEditMode && isLoadingOrder) {
    return (
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onClose}
          contentContainerStyle={styles.modalContent}
        >
          <View style={[styles.container, styles.loadingContainer]}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
            <Text style={styles.loadingText}>Cargando orden...</Text>
          </View>
        </Modal>
      </Portal>
    );
  }

  // Mostrar error si fall√≥ la carga en modo edici√≥n
  if (isEditMode && isErrorOrder) {
    return (
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onClose}
          contentContainerStyle={styles.errorModalContent}
        >
          <View style={styles.errorModalContainer}>
            {/* Icono de error */}
            <View
              style={[
                styles.errorIconContainer,
                { backgroundColor: theme.colors.errorContainer },
              ]}
            >
              <IconButton
                icon="alert-circle-outline"
                size={48}
                iconColor={theme.colors.error}
                style={styles.iconButtonNoMargin}
              />
            </View>

            {/* T√≠tulo del error */}
            <Text
              style={[
                styles.errorModalTitle,
                { color: theme.colors.onSurface },
              ]}
            >
              No se pudo cargar la orden
            </Text>

            {/* Mensaje descriptivo */}
            <Text
              style={[
                styles.errorModalMessage,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Ha ocurrido un error al intentar cargar los datos de la orden. Por
              favor, intenta nuevamente m√°s tarde.
            </Text>

            {/* Bot√≥n de cerrar */}
            <Button
              mode="contained"
              onPress={onClose}
              style={styles.errorModalButton}
              contentStyle={styles.errorModalButtonContent}
              labelStyle={styles.errorModalButtonLabel}
            >
              Entendido
            </Button>
          </View>
        </Modal>
      </Portal>
    );
  }

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={() => {
          if (isEditMode && hasUnsavedChanges) {
            setShowExitConfirmation(true);
          } else {
            onClose?.();
          }
        }}
        contentContainerStyle={styles.modalContent}
        dismissable={true}
        dismissableBackButton={false}
      >
        <GestureHandlerRootView style={styles.container}>
          <TouchableWithoutFeedback
            onPress={Keyboard.dismiss}
            accessible={false}
          >
            <View>
              {isEditMode ? (
                <View style={styles.customHeader}>
                  <IconButton
                    icon="arrow-left"
                    size={24}
                    onPress={() => {
                      if (hasUnsavedChanges) {
                        setShowExitConfirmation(true);
                      } else {
                        onClose?.();
                      }
                    }}
                    iconColor={theme.colors.onSurface}
                  />

                  <View style={styles.headerTitleContainer}>
                    <Text style={styles.headerTitle}>
                      {orderNumber && orderDate
                        ? `Editar Orden #${orderNumber} - ${format(orderDate, 'dd/MM/yyyy', { locale: es })}`
                        : orderNumber
                          ? `Editando Orden #${orderNumber}`
                          : 'Editar Orden'}
                    </Text>
                    {orderData?.orderStatus && (
                      <View
                        style={[
                          styles.orderStatusBadge,
                          {
                            backgroundColor: getOrderStatusColor(
                              orderData.orderStatus,
                              theme,
                            ),
                          },
                        ]}
                      >
                        <Text style={styles.orderStatusText}>
                          {formatOrderStatus(orderData.orderStatus)}
                        </Text>
                      </View>
                    )}
                  </View>

                  <Menu
                    visible={showOptionsMenu}
                    onDismiss={() => setShowOptionsMenu(false)}
                    anchor={
                      <IconButton
                        icon="dots-vertical"
                        size={24}
                        onPress={() => setShowOptionsMenu(true)}
                        iconColor={theme.colors.onSurface}
                      />
                    }
                  >
                    <Menu.Item
                      onPress={() => {
                        setShowOptionsMenu(false);
                        setShowDetailModal(true);
                      }}
                      title="Ver Detalles"
                      leadingIcon="file-document-outline"
                    />
                    <Menu.Item
                      onPress={() => {
                        setShowOptionsMenu(false);
                        setShowHistoryModal(true);
                      }}
                      title="Ver Historial"
                      leadingIcon="history"
                    />
                    <Menu.Item
                      onPress={() => {
                        setShowOptionsMenu(false);
                        setShowCancelConfirmation(true);
                      }}
                      title="Cancelar Orden"
                      leadingIcon="cancel"
                    />
                  </Menu>
                </View>
              ) : (
                <OrderHeader
                  title={
                    orderNumber ? `Orden #${orderNumber}` : 'Resumen de Orden'
                  }
                  onBackPress={() => onClose?.()}
                  itemCount={totalItemsCount}
                  onCartPress={() => {}}
                  isCartVisible={isCartVisible}
                />
              )}
            </View>
          </TouchableWithoutFeedback>

          <ScrollView
            style={styles.scrollView}
            keyboardShouldPersistTaps="handled"
            keyboardDismissMode="on-drag"
          >
            {/* Order Type Selection */}
            <View style={styles.sectionCompact}>
              <RadioButton.Group
                onValueChange={(newValue) =>
                  setOrderType(newValue as OrderType)
                }
                value={orderType}
              >
                <View style={styles.radioGroupHorizontal}>
                  <RadioButton.Item
                    label="COMER AQU√ç"
                    value={OrderTypeEnum.DINE_IN} // Usar Enum
                    style={styles.radioButtonItem}
                    labelStyle={styles.radioLabel}
                    position="leading"
                  />
                  <RadioButton.Item
                    label="PARA LLEVAR"
                    value={OrderTypeEnum.TAKE_AWAY} // Usar Enum
                    style={styles.radioButtonItem}
                    labelStyle={styles.radioLabel}
                    position="leading"
                  />
                  <RadioButton.Item
                    label="DOMICILIO"
                    value={OrderTypeEnum.DELIVERY} // Usar Enum
                    style={styles.radioButtonItem}
                    labelStyle={styles.radioLabel}
                    position="leading"
                  />
                </View>
              </RadioButton.Group>
            </View>

            {/* Render fields based on order type */}
            {renderFields()}

            <Divider style={styles.divider} />

            {/* Cart Items */}
            <List.Section>
              {items.map((item) => {
                // Crear funci√≥n de renderizado de acci√≥n de eliminar
                const renderRightActions = (progress, dragX) => {
                  const translateX = dragX.interpolate({
                    inputRange: [-100, 0],
                    outputRange: [0, 100],
                    extrapolate: 'clamp',
                  });

                  const scale = dragX.interpolate({
                    inputRange: [-100, -50, 0],
                    outputRange: [1, 0.8, 0.5],
                    extrapolate: 'clamp',
                  });

                  const opacity = dragX.interpolate({
                    inputRange: [-100, -20, 0],
                    outputRange: [1, 0.5, 0],
                    extrapolate: 'clamp',
                  });

                  return (
                    <Animated.View
                      style={[
                        styles.deleteActionContainer,
                        {
                          opacity,
                          transform: [{ translateX }],
                        },
                      ]}
                    >
                      <Animated.View
                        style={[
                          styles.deleteAction,
                          {
                            backgroundColor: theme.colors.error,
                            transform: [{ scale }],
                          },
                        ]}
                      >
                        <View style={styles.deleteIconContainer}>
                          <IconButton
                            icon="delete-sweep"
                            size={28}
                            iconColor="white"
                            style={styles.deleteIcon}
                          />
                        </View>
                        <Text style={styles.deleteActionText}>ELIMINAR</Text>
                      </Animated.View>
                    </Animated.View>
                  );
                };

                return (
                  <Swipeable
                    key={item.id}
                    renderRightActions={renderRightActions}
                    overshootRight={false}
                    friction={2}
                    rightThreshold={90}
                    leftThreshold={100}
                    onSwipeableOpen={(direction) => {
                      if (direction === 'right') {
                        // Peque√±o delay para que se vea la animaci√≥n completa
                        setTimeout(() => {
                          removeItem(item.id);
                        }, 150);
                      }
                    }}
                  >
                    <TouchableOpacity
                      onPress={() => handleEditCartItem(item)}
                      disabled={!onEditItem && !isEditMode}
                      activeOpacity={0.7}
                    >
                      <List.Item
                        // Mover title y description a un View contenedor para controlar el ancho
                        title={() => (
                          <View style={styles.itemTextContainer}>
                            <View>
                              <Text style={styles.itemTitleText}>
                                {`${item.quantity}x ${item.variantName ? String(item.variantName ?? '') : String(item.productName ?? '')}`}
                              </Text>
                              {/* Mostrar estado de preparaci√≥n solo en modo edici√≥n - siempre en nueva l√≠nea */}
                              {isEditMode && item.preparationStatus && (
                                <View style={styles.statusContainer}>
                                  <View
                                    style={[
                                      styles.statusBadge,
                                      {
                                        backgroundColor:
                                          getPreparationStatusColor(
                                            item.preparationStatus,
                                            theme,
                                          ) + '20',
                                      },
                                    ]}
                                  >
                                    <View
                                      style={[
                                        styles.statusDot,
                                        {
                                          backgroundColor:
                                            getPreparationStatusColor(
                                              item.preparationStatus,
                                              theme,
                                            ),
                                        },
                                      ]}
                                    />
                                    <Text
                                      style={[
                                        styles.statusText,
                                        {
                                          color: getPreparationStatusColor(
                                            item.preparationStatus,
                                            theme,
                                          ),
                                        },
                                      ]}
                                    >
                                      {getPreparationStatusText(
                                        item.preparationStatus,
                                      )}
                                    </Text>
                                  </View>
                                </View>
                              )}
                            </View>
                            {(() => {
                              // Render description condicionalmente
                              const hasModifiers =
                                item.modifiers && item.modifiers.length > 0;
                              const hasNotes =
                                item.preparationNotes &&
                                item.preparationNotes.trim() !== '';
                              const hasPizzaCustomizations =
                                item.selectedPizzaCustomizations &&
                                item.selectedPizzaCustomizations.length > 0;

                              return (
                                <View>
                                  {/* Renderizar personalizaciones de pizza */}
                                  {hasPizzaCustomizations && (
                                    <Text style={styles.itemDescription}>
                                      {formatPizzaCustomizations(
                                        item.selectedPizzaCustomizations,
                                      )}
                                    </Text>
                                  )}

                                  {/* Renderizar modificadores */}
                                  {hasModifiers &&
                                    item.modifiers.map(
                                      (mod: any, index: number) => (
                                        <Text
                                          key={mod.id || index}
                                          style={styles.itemDescription}
                                        >
                                          ‚Ä¢ {mod.name}{' '}
                                          {mod.price && Number(mod.price) > 0
                                            ? `(+$${Number(mod.price).toFixed(2)})`
                                            : ''}
                                        </Text>
                                      ),
                                    )}

                                  {/* Renderizar notas */}
                                  {hasNotes && (
                                    <Text
                                      style={[
                                        styles.itemDescription,
                                        styles.notesText,
                                      ]}
                                    >
                                      Notas: {item.preparationNotes}
                                    </Text>
                                  )}
                                </View>
                              );
                            })()}
                          </View>
                        )}
                        // titleNumberOfLines y description ya no se usan directamente aqu√≠
                        right={() => (
                          // Usar par√©ntesis para retorno impl√≠cito si es una sola expresi√≥n
                          <View style={styles.itemActionsContainer}>
                            <View style={styles.quantityActions}>
                              <IconButton
                                icon="minus-circle-outline"
                                size={20} // Reducir tama√±o de icono
                                onPress={() =>
                                  updateItemQuantity(item.id, item.quantity - 1)
                                }
                                style={styles.quantityButton}
                                disabled={item.quantity <= 1} // Deshabilitar si es 1
                              />
                              <Text style={styles.quantityText}>
                                {item.quantity}
                              </Text>
                              <IconButton
                                icon="plus-circle-outline"
                                size={20} // Reducir tama√±o de icono
                                onPress={() =>
                                  updateItemQuantity(item.id, item.quantity + 1)
                                }
                                style={styles.quantityButton}
                              />
                            </View>
                            <View style={styles.priceContainer}>
                              <Text style={styles.itemPrice}>
                                ${Number(item.totalPrice || 0).toFixed(2)}
                              </Text>
                              {item.quantity > 1 && (
                                <Text style={styles.unitPriceText}>
                                  ($
                                  {(
                                    Number(item.unitPrice || 0) +
                                    (item.modifiers || []).reduce(
                                      (sum, mod) =>
                                        sum + Number(mod.price || 0),
                                      0,
                                    )
                                  ).toFixed(2)}{' '}
                                  c/u)
                                </Text>
                              )}
                            </View>
                          </View>
                        )}
                        style={styles.listItem}
                      />
                    </TouchableOpacity>
                  </Swipeable>
                );
              })}

              {/* Renderizar ajustes como OrderItems - dentro del mismo List.Section */}
              {isEditMode &&
                adjustments
                  .filter((adj) => !adj.isDeleted)
                  .map((adjustment, index) => {
                    const renderRightActions = (progress, dragX) => {
                      const translateX = dragX.interpolate({
                        inputRange: [-100, 0],
                        outputRange: [0, 100],
                        extrapolate: 'clamp',
                      });

                      const scale = dragX.interpolate({
                        inputRange: [-100, -50, 0],
                        outputRange: [1, 0.8, 0.5],
                        extrapolate: 'clamp',
                      });

                      const opacity = dragX.interpolate({
                        inputRange: [-100, -20, 0],
                        outputRange: [1, 0.5, 0],
                        extrapolate: 'clamp',
                      });

                      return (
                        <Animated.View
                          style={[
                            styles.deleteActionContainer,
                            {
                              opacity,
                              transform: [{ translateX }],
                            },
                          ]}
                        >
                          <Animated.View
                            style={[
                              styles.deleteAction,
                              {
                                backgroundColor: theme.colors.error,
                                transform: [{ scale }],
                              },
                            ]}
                          >
                            <View style={styles.deleteIconContainer}>
                              <IconButton
                                icon="delete-sweep"
                                size={28}
                                iconColor="white"
                                style={styles.deleteIcon}
                              />
                            </View>
                            <Text style={styles.deleteActionText}>
                              ELIMINAR
                            </Text>
                          </Animated.View>
                        </Animated.View>
                      );
                    };

                    return (
                      <Swipeable
                        key={adjustment.id || `new-${index}`}
                        renderRightActions={renderRightActions}
                        overshootRight={false}
                        friction={2}
                        rightThreshold={90}
                        leftThreshold={100}
                        onSwipeableOpen={(direction) => {
                          if (direction === 'right') {
                            setTimeout(() => {
                              if (adjustment.id) {
                                handleRemoveAdjustment(adjustment.id);
                              }
                            }, 150);
                          }
                        }}
                      >
                        <TouchableOpacity
                          onPress={() => {
                            setAdjustmentToEdit(adjustment);
                            setShowAdjustmentModal(true);
                          }}
                          activeOpacity={0.7}
                        >
                          <List.Item
                            title={() => (
                              <View style={styles.itemTextContainer}>
                                <Text
                                  style={[
                                    styles.itemTitleText,
                                    {
                                      color:
                                        adjustment.amount < 0
                                          ? theme.colors.error
                                          : theme.colors.primary,
                                    },
                                  ]}
                                >
                                  {adjustment.name}
                                  {adjustment.isPercentage
                                    ? ` (${adjustment.value}%)`
                                    : ''}
                                </Text>
                              </View>
                            )}
                            right={() => (
                              <View style={styles.itemActionsContainer}>
                                <View style={styles.priceContainer}>
                                  <Text
                                    style={[
                                      styles.itemPrice,
                                      {
                                        color:
                                          adjustment.amount < 0
                                            ? theme.colors.error
                                            : theme.colors.primary,
                                      },
                                    ]}
                                  >
                                    {adjustment.amount < 0 ? '-' : '+'}$
                                    {Math.abs(adjustment.amount || 0).toFixed(
                                      2,
                                    )}
                                  </Text>
                                </View>
                              </View>
                            )}
                            style={styles.listItem}
                          />
                        </TouchableOpacity>
                      </Swipeable>
                    );
                  })}
            </List.Section>

            {/* Bot√≥n de ajustes - Solo en modo edici√≥n */}
            {isEditMode && (
              <Button
                onPress={() => setShowAdjustmentModal(true)}
                mode="outlined"
                style={styles.adjustmentButton}
                icon="calculator-variant"
              >
                Ajustes
              </Button>
            )}

            {/* Bot√≥n para a√±adir productos en modo edici√≥n */}
            {isEditMode && (
              <Button
                onPress={() => {
                  if (onAddProducts) {
                    // Si tenemos un callback personalizado, usarlo
                    onAddProducts();
                  } else if (navigation && orderId && orderNumber) {
                    // Si no, usar navegaci√≥n directa
                    try {
                      navigation.navigate('AddProductsToOrder', {
                        orderId,
                        orderNumber,
                        // Pasar el conteo de items existentes (no incluir los temporales "NEW")
                        existingOrderItemsCount: editItems
                          .filter((item) => !item.id.startsWith('new-'))
                          .reduce((sum, item) => sum + item.quantity, 0),
                        onProductsAdded: (newProducts: CartItem[]) => {
                          // Marcar los nuevos productos con estado "NEW"
                          const newProductsWithStatus = newProducts.map(
                            (item) => ({
                              ...item,
                              preparationStatus: 'NEW' as const,
                              id: `new-${Date.now()}-${Math.floor(Math.random() * 1000000)}`,
                            }),
                          );

                          // Combinar con items existentes y agrupar
                          const allItems = [
                            ...editItems,
                            ...newProductsWithStatus,
                          ];
                          const groupedItems = groupIdenticalItems(allItems);

                          setEditItems(groupedItems);
                          showSnackbar({
                            message: `${newProducts.length} producto${newProducts.length > 1 ? 's' : ''} a√±adido${newProducts.length > 1 ? 's' : ''}`,
                            type: 'success',
                          });
                        },
                      });
                    } catch (error) {
                      // Error al navegar
                    }
                  }
                }}
                mode="outlined"
                style={styles.addProductsButton}
                icon="plus-circle-outline"
              >
                A√±adir Productos
              </Button>
            )}

            <Divider style={styles.divider} />

            {/* Totals */}
            <View style={styles.totalsContainer}>
              <Text style={styles.totalsText}>Subtotal:</Text>
              <Text style={styles.totalsValue}>
                ${(subtotal || 0).toFixed(2)}
              </Text>
            </View>
            {isEditMode && totalAdjustments !== 0 && (
              <View style={styles.totalsContainer}>
                <Text style={styles.totalsText}>Ajustes:</Text>
                <Text
                  style={[
                    styles.totalsValue,
                    {
                      color:
                        totalAdjustments < 0
                          ? theme.colors.error
                          : theme.colors.primary,
                    },
                  ]}
                >
                  {totalAdjustments < 0 ? '-' : '+'}$
                  {Math.abs(totalAdjustments || 0).toFixed(2)}
                </Text>
              </View>
            )}
            <View style={styles.totalsContainer}>
              <Text style={[styles.totalsText, styles.totalLabel]}>Total:</Text>
              <Text style={[styles.totalsValue, styles.totalValue]}>
                ${(total || 0).toFixed(2)}
              </Text>
            </View>

            {/* Mostrar desglose de pago cuando hay pre-pago registrado */}
            {!isEditMode && prepaymentId && (
              <>
                <View style={styles.prepaymentSection}>
                  <View style={styles.prepaymentHeader}>
                    <Text style={styles.prepaymentTitle}>
                      Prepago registrado
                    </Text>
                    <View style={styles.prepaymentActions}>
                      <IconButton
                        icon="pencil"
                        size={28}
                        iconColor={theme.colors.primary}
                        onPress={() => setShowPrepaymentModal(true)}
                        style={styles.prepaymentIconButton}
                      />
                      <IconButton
                        icon="delete"
                        size={28}
                        iconColor={theme.colors.error}
                        onPress={handleDeletePrepayment}
                        style={styles.prepaymentIconButton}
                      />
                    </View>
                  </View>
                  <View style={styles.totalsContainer}>
                    <Text style={styles.totalsText}>Monto pagado:</Text>
                    <Text style={[styles.totalsValue, { color: '#4CAF50' }]}>
                      ${parseFloat(paymentAmount || '0').toFixed(2)}
                    </Text>
                  </View>
                  {/* Mostrar advertencia si el prepago excede el total */}
                  {parseFloat(paymentAmount || '0') > total && (
                    <View style={styles.prepaymentWarning}>
                      <IconButton
                        icon="alert-circle"
                        size={16}
                        iconColor={theme.colors.error}
                        style={styles.iconButtonNoMargin}
                      />
                      <Text style={styles.prepaymentWarningText}>
                        El prepago excede el total de la orden. Edite el pago
                        antes de continuar.
                      </Text>
                    </View>
                  )}
                </View>
                <View style={styles.totalsContainer}>
                  <Text style={[styles.totalsText, { fontWeight: '600' }]}>
                    Restante:
                  </Text>
                  <Text
                    style={[
                      styles.totalsValue,
                      {
                        fontWeight: 'bold',
                        color:
                          total - parseFloat(paymentAmount || '0') <= 0
                            ? '#4CAF50'
                            : theme.colors.error,
                      },
                    ]}
                  >
                    $
                    {Math.max(
                      0,
                      total - parseFloat(paymentAmount || '0'),
                    ).toFixed(2)}
                  </Text>
                </View>
              </>
            )}

            {/* Mostrar informaci√≥n de pagos solo en modo edici√≥n */}
            {isEditMode && (
              <>
                <View style={styles.totalsContainer}>
                  <Text style={styles.totalsText}>Pagado:</Text>
                  <Text style={[styles.totalsValue, { color: '#4CAF50' }]}>
                    ${(totalPaid || 0).toFixed(2)}
                  </Text>
                </View>
                <View style={styles.totalsContainer}>
                  <Text style={[styles.totalsText, { fontWeight: 'bold' }]}>
                    Restante:
                  </Text>
                  <Text
                    style={[
                      styles.totalsValue,
                      {
                        fontWeight: 'bold',
                        color:
                          pendingAmount > 0 ? theme.colors.error : '#4CAF50',
                      },
                    ]}
                  >
                    ${(pendingAmount || 0).toFixed(2)}
                  </Text>
                </View>
              </>
            )}
          </ScrollView>

          {/* Bot√≥n de pago - solo mostrar si es creaci√≥n y el usuario tiene permisos y no hay pre-pago */}
          {!isEditMode && canRegisterPayments && !prepaymentId && (
            <View style={styles.paymentButtonContainer}>
              <Button
                mode="outlined"
                onPress={() => setShowPrepaymentModal(true)}
                style={styles.paymentButton}
                icon="credit-card"
              >
                üíµ Registrar pago con la orden
              </Button>
            </View>
          )}

          <View style={styles.footer}>
            <Button
              mode="contained"
              onPress={handleConfirm}
              disabled={
                isConfirming || // Deshabilitar mientras se procesa
                items.length === 0 ||
                (isEditMode && !hasUnsavedChanges) || // Deshabilitar si estamos en modo edici√≥n y no hay cambios
                (orderType === OrderTypeEnum.DINE_IN &&
                  (!selectedAreaId ||
                    (isTemporaryTable
                      ? !temporaryTableName || temporaryTableName.trim() === ''
                      : !selectedTableId))) || // Usar Enum
                (orderType === OrderTypeEnum.TAKE_AWAY &&
                  (!deliveryInfo.recipientName ||
                    deliveryInfo.recipientName.trim() === '')) || // Usar Enum
                (orderType === OrderTypeEnum.DELIVERY &&
                  (!deliveryInfo.fullAddress ||
                    deliveryInfo.fullAddress.trim() === '')) || // Usar Enum
                (orderType === OrderTypeEnum.DELIVERY &&
                  (!deliveryInfo.recipientPhone ||
                    deliveryInfo.recipientPhone.trim() === '')) // Usar Enum
              }
              style={[
                styles.confirmButton,
                isEditMode &&
                  hasUnsavedChanges && {
                    backgroundColor: '#FF6B35', // Naranja vibrante para indicar acci√≥n requerida
                  },
              ]}
              loading={isConfirming} // Mostrar indicador de carga
            >
              {isConfirming
                ? isEditMode
                  ? 'Guardando...'
                  : 'Enviando...'
                : isEditMode
                  ? hasUnsavedChanges
                    ? '‚ö†Ô∏è Guardar Cambios'
                    : 'Guardar Cambios'
                  : 'Enviar Orden'}
            </Button>
          </View>

          {/* Modals */}
          <Portal>
            <DateTimePickerSafe
              visible={isTimePickerVisible}
              mode="time"
              value={scheduledTime}
              onConfirm={handleTimeConfirm}
              onCancel={hideTimePicker}
              minimumDate={new Date()}
              minuteInterval={5}
              title={
                orderType === OrderTypeEnum.DELIVERY
                  ? 'Seleccionar Hora de Entrega'
                  : orderType === OrderTypeEnum.TAKE_AWAY
                    ? 'Seleccionar Hora de Recolecci√≥n'
                    : 'Seleccionar Hora'
              }
              allowManualInput={true} // Habilita entrada manual en Android
            />
          </Portal>

          <ConfirmationModal
            visible={isTimeAlertVisible}
            title="Hora Inv√°lida"
            message="No puedes seleccionar una hora que ya ha pasado. Por favor, elige una hora futura."
            confirmText="Entendido"
            onConfirm={() => setTimeAlertVisible(false)}
          />

          {/* Modal de confirmaci√≥n para descartar cambios */}
          <ConfirmationModal
            visible={showExitConfirmation}
            title="¬øDescartar cambios?"
            message="Tienes cambios sin guardar. ¬øEst√°s seguro de que quieres salir?"
            confirmText="Descartar"
            cancelText="Cancelar"
            onConfirm={() => {
              setShowExitConfirmation(false);
              onClose?.();
            }}
            onCancel={() => setShowExitConfirmation(false)}
          />

          {/* Modal de confirmaci√≥n para cancelar la orden */}
          <ConfirmationModal
            visible={showCancelConfirmation}
            title="¬øCancelar orden?"
            message={`¬øEst√°s seguro de que quieres cancelar la orden #${orderNumber}? Esta acci√≥n no se puede deshacer.`}
            confirmText="Cancelar Orden"
            cancelText="No, mantener"
            onConfirm={() => {
              setShowCancelConfirmation(false);
              if (onCancelOrder) {
                onCancelOrder();
              }
            }}
            onCancel={() => setShowCancelConfirmation(false)}
          />

          {/* Modal de confirmaci√≥n para modificar items en preparaci√≥n */}
          <ConfirmationModal
            visible={showModifyInProgressConfirmation}
            title="¬øModificar producto en preparaci√≥n?"
            message={`El producto "${modifyingItemName}" est√° actualmente en preparaci√≥n. ¬øEst√°s seguro de que quieres modificarlo?`}
            confirmText="S√≠, modificar"
            cancelText="No, cancelar"
            onConfirm={() => {
              setShowModifyInProgressConfirmation(false);
              if (pendingModifyAction) {
                pendingModifyAction();
                setPendingModifyAction(null);
              }
              setModifyingItemName('');
            }}
            onCancel={() => {
              setShowModifyInProgressConfirmation(false);
              setPendingModifyAction(null);
              setModifyingItemName('');
            }}
          />

          {/* Modal de personalizaci√≥n de producto para edici√≥n */}
          {isEditMode && editingProduct && editingItemFromList && (
            <ProductCustomizationModal
              visible={true}
              product={editingProduct}
              editingItem={editingItemFromList}
              onDismiss={() => {
                setEditingItemFromList(null);
                setEditingProduct(null);
              }}
              onAddToCart={() => {}} // No usado en modo edici√≥n
              onUpdateItem={handleUpdateEditedItem}
            />
          )}

          {/* Modal de detalles de orden */}
          {isEditMode && (
            <OrderDetailModal
              visible={showDetailModal}
              onDismiss={() => setShowDetailModal(false)}
              orderId={orderId}
              orderNumber={orderNumber}
              orderData={orderData}
            />
          )}

          {/* Modal de historial de cambios */}
          {isEditMode && (
            <OrderHistoryModal
              visible={showHistoryModal}
              onDismiss={() => setShowHistoryModal(false)}
              orderId={orderId}
              orderNumber={orderNumber}
            />
          )}

          {/* FAB para pagos - solo en modo edici√≥n */}
          {isEditMode && orderId && visible && (
            <FAB
              icon="cash-multiple"
              style={[
                styles.paymentFab,
                {
                  backgroundColor: hasUnsavedChanges
                    ? '#9CA3AF' // Gris s√≥lido pero visible
                    : pendingAmount <= 0
                      ? '#4CAF50'
                      : theme.colors.primary,
                },
              ]}
              color="white"
              onPress={() => {
                if (hasUnsavedChanges) {
                  showSnackbar({
                    message:
                      'Debes guardar los cambios antes de registrar pagos',
                    type: 'warning',
                  });
                } else {
                  setShowPaymentModal(true);
                }
              }}
              visible={true}
            />
          )}

          {/* Modal de pagos */}
          {showPaymentModal && isEditMode && orderId && (
            <PaymentModal
              visible={showPaymentModal}
              onDismiss={() => setShowPaymentModal(false)}
              orderId={orderId}
              orderTotal={total}
              orderNumber={orderNumber}
              orderStatus={orderData?.orderStatus}
              onOrderCompleted={() => {
                // Cerrar el modal de pagos
                setShowPaymentModal(false);
                // Cerrar el modal de edici√≥n de orden
                onClose?.();
              }}
            />
          )}

          {/* Modal de ajustes */}
          {showAdjustmentModal && isEditMode && (
            <AdjustmentFormModal
              visible={showAdjustmentModal}
              onDismiss={() => {
                setShowAdjustmentModal(false);
                setAdjustmentToEdit(null);
              }}
              onSave={(adjustment: OrderAdjustment) => {
                if (adjustmentToEdit) {
                  handleUpdateAdjustment(adjustmentToEdit.id!, adjustment);
                } else {
                  handleAddAdjustment(adjustment);
                }
                setShowAdjustmentModal(false);
                setAdjustmentToEdit(null);
              }}
              adjustment={adjustmentToEdit}
              orderSubtotal={subtotal}
            />
          )}

          {/* Modal de pago para pre-pagos */}
          <PaymentModal
            visible={showPrepaymentModal}
            onDismiss={() => setShowPrepaymentModal(false)}
            orderTotal={total}
            mode="prepayment"
            onPrepaymentCreated={handlePrepaymentCreated}
            existingPrepaymentId={prepaymentId || undefined}
            onPrepaymentDeleted={handlePrepaymentDeleted}
          />

          {/* Modal de confirmaci√≥n para eliminar prepago */}
          <ConfirmationModal
            visible={showDeletePrepaymentConfirm}
            onDismiss={() => setShowDeletePrepaymentConfirm(false)}
            title="¬øEliminar prepago?"
            message="¬øEst√°s seguro de que deseas eliminar este prepago? Esta acci√≥n no se puede deshacer."
            confirmText="Eliminar"
            cancelText="Cancelar"
            onConfirm={confirmDeletePrepayment}
            onCancel={() => setShowDeletePrepaymentConfirm(false)}
          />
        </GestureHandlerRootView>
      </Modal>
    </Portal>
  );
};

const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    modalContent: {
      backgroundColor: theme.colors.background,
      width: '100%',
      height: '100%',
      margin: 0,
      padding: 0,
      position: 'absolute',
      top: 0,
      left: 0,
    },
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    scrollView: {
      flex: 1,
      paddingHorizontal: theme.spacing.s, // Restaurar padding peque√±o
    },
    divider: {
      marginVertical: theme.spacing.s,
    },
    // List Item Styles
    listItem: {
      flexDirection: 'row', // 1) Fila
      alignItems: 'center',
      justifyContent: 'space-between', // 2) Separar t√≠tulo y acciones
      paddingVertical: theme.spacing.s,
      paddingHorizontal: theme.spacing.s, // controla el "gap" desde el borde
      backgroundColor: theme.colors.surface,
      minHeight: 80, // Altura m√≠nima para mejor experiencia de swipe
    },

    itemTextContainer: {
      // Contenedor para t√≠tulo y descripci√≥n
      flex: 3, // Darle a√∫n m√°s espacio al texto ahora que no hay bot√≥n de eliminar
      marginRight: theme.spacing.xs, // Peque√±o margen para separar de las acciones
      justifyContent: 'center', // Centrar texto verticalmente
      // backgroundColor: 'lightyellow', // Debug
    },
    itemTitleText: {
      // Estilo para el texto del t√≠tulo
      fontSize: 15, // Aumentar tama√±o del t√≠tulo
      fontWeight: '500',
      color: theme.colors.onSurface,
      flexWrap: 'wrap', // Permitir que el texto se ajuste
      lineHeight: 20, // Ajustar altura de l√≠nea
    },
    itemDescription: {
      fontSize: 13, // Aumentar tama√±o de descripci√≥n
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
      flexWrap: 'wrap', // Permitir que el texto se ajuste
      lineHeight: 18, // Ajustar altura de l√≠nea
    },
    itemActionsContainer: {
      // Contenedor para acciones (cantidad, precio, borrar)
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'flex-end',
      flexShrink: 0, // No permitir que se encoja
      // backgroundColor: 'lightblue', // Debug
    },
    quantityActions: {
      flexDirection: 'row',
      alignItems: 'center',
      // marginRight: theme.spacing.s, // Adjust spacing as needed
    }, // <<< COMA RESTAURADA
    // quantityButton: { // <<< ESTILO DUPLICADO/INCORRECTO ELIMINADO
    //    margin: 0,
    //    // backgroundColor: 'lightgreen',
    // },
    //   flexDirection: "row", // <<< C√ìDIGO INCORRECTO ELIMINADO
    //   alignItems: "center",
    //   // marginRight: theme.spacing.xs,
    // },
    quantityButton: {
      // <<< ESTILO CORRECTO
      marginHorizontal: -4, // Reducir espacio horizontal entre botones
      padding: 0, // Eliminar padding interno
      // backgroundColor: 'lightgreen', // Debug
    }, // <<< COMA RESTAURADA
    quantityText: {
      fontSize: 14, // Aumentar tama√±o
      fontWeight: 'bold',
      minWidth: 20, // Ajustar ancho m√≠nimo
      textAlign: 'center',
      marginHorizontal: 2, // Ajustar margen horizontal
      // backgroundColor: 'pink', // Debug
    }, // <<< COMA RESTAURADA
    itemPrice: {
      alignSelf: 'center',
      marginRight: theme.spacing.xs, // Reducir espacio
      color: theme.colors.onSurfaceVariant,
      fontSize: 15, // Aumentar tama√±o
      fontWeight: 'bold',
      minWidth: 55, // Ajustar ancho m√≠nimo
      textAlign: 'right',
      // backgroundColor: 'lightcoral', // Debug
    }, // <<< COMA RESTAURADA
    priceContainer: {
      flexDirection: 'column',
      alignItems: 'flex-end',
      marginRight: theme.spacing.xs,
    },
    unitPriceText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
    },
    deleteActionContainer: {
      width: 120,
      height: '100%',
      justifyContent: 'center',
      alignItems: 'flex-end',
      paddingRight: theme.spacing.m,
    },
    deleteAction: {
      backgroundColor: theme.colors.error,
      justifyContent: 'center',
      alignItems: 'center',
      width: 90,
      height: '90%',
      borderRadius: theme.roundness * 2,
      flexDirection: 'column',
      shadowColor: theme.colors.error,
      shadowOffset: {
        width: 0,
        height: 2,
      },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
      elevation: 5,
    },
    deleteIconContainer: {
      width: 50,
      height: 50,
      borderRadius: 25,
      backgroundColor: 'rgba(255, 255, 255, 0.2)',
      justifyContent: 'center',
      alignItems: 'center',
      marginBottom: 4,
    },
    deleteIcon: {
      margin: 0,
      padding: 0,
    },
    deleteActionText: {
      color: 'white',
      fontSize: 11,
      fontWeight: '700',
      letterSpacing: 1,
      textTransform: 'uppercase',
    }, // <<< COMA RESTAURADA
    // End List Item Styles
    totalsContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      marginBottom: theme.spacing.xs,
      paddingHorizontal: theme.spacing.xs,
    }, // <<< COMA RESTAURADA
    totalsText: {
      fontSize: 16,
    }, // <<< COMA RESTAURADA
    totalsValue: {
      fontSize: 16,
      fontWeight: 'bold',
    }, // <<< COMA RESTAURADA
    totalLabel: {
      fontWeight: 'bold',
      fontSize: 18,
    }, // <<< COMA RESTAURADA
    totalValue: {
      fontSize: 18,
      color: theme.colors.primary,
    }, // <<< COMA RESTAURADA
    section: {
      marginBottom: theme.spacing.m,
      marginTop: theme.spacing.s,
    }, // <<< COMA RESTAURADA
    sectionCompact: {
      marginBottom: 0,
      paddingBottom: 0,
    }, // <<< COMA RESTAURADA
    dineInSelectorsRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      marginBottom: 0,
      gap: theme.spacing.s,
      marginTop: theme.spacing.s,
    }, // <<< COMA RESTAURADA
    dineInSelectorContainer: {
      flex: 1,
    }, // <<< COMA RESTAURADA
    selectorLoader: {}, // <<< COMA RESTAURADA
    sectionTitleContainer: {
      flexDirection: 'row',
      alignItems: 'baseline',
      marginBottom: theme.spacing.xs,
    }, // <<< COMA RESTAURADA
    sectionTitle: {
      fontSize: 16,
      fontWeight: 'bold',
      marginBottom: theme.spacing.xs,
    }, // <<< COMA RESTAURADA
    sectionTitleOptional: {
      ...theme.fonts.bodySmall,
      color: theme.colors.onSurfaceVariant,
      marginLeft: theme.spacing.xs,
    }, // <<< COMA RESTAURADA
    radioGroupHorizontal: {
      flexDirection: 'row',
      justifyContent: 'space-around',
      alignItems: 'center',
      width: '100%',
      paddingVertical: theme.spacing.xs,
    }, // <<< COMA RESTAURADA
    radioLabel: {
      marginLeft: 0,
      fontSize: 11,
      textTransform: 'uppercase',
      textAlign: 'center',
    }, // <<< COMA RESTAURADA
    radioButtonItem: {
      paddingHorizontal: 0,
      paddingVertical: 4,
      flexShrink: 1,
      flex: 1,
      marginHorizontal: 2,
    }, // <<< COMA RESTAURADA
    dropdownAnchor: {}, // <<< COMA RESTAURADA
    dropdownContent: {}, // <<< COMA RESTAURADA
    dropdownLabel: {}, // <<< COMA RESTAURADA
    helperTextFix: {
      marginTop: -6,
      marginBottom: 0,
      paddingHorizontal: 12,
    }, // <<< COMA RESTAURADA
    footer: {
      padding: theme.spacing.m,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
    }, // <<< COMA RESTAURADA
    confirmButton: {
      paddingVertical: theme.spacing.xs,
    },
    input: {}, // <<< COMA RESTAURADA
    fieldContainer: {
      marginTop: theme.spacing.s,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
    loadingText: {
      marginTop: theme.spacing.m,
      color: theme.colors.onSurfaceVariant,
    },
    errorContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
    errorText: {
      color: theme.colors.error,
      marginBottom: theme.spacing.m,
    },
    phoneHelperContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
      marginTop: 2,
      paddingHorizontal: 12,
      minHeight: 20,
    },
    recipientPhoneError: {
      flex: 1,
      marginBottom: 0,
      marginTop: 0,
    },
    digitCounter: {
      fontSize: 10,
      color: theme.colors.onSurfaceVariant,
      opacity: 0.6,
      marginLeft: theme.spacing.xs,
      marginTop: 2,
    },
    phoneInputWrapper: {
      position: 'relative',
    },
    digitCounterAbsolute: {
      position: 'absolute',
      right: 50, // Mover m√°s a la izquierda para evitar el bot√≥n de micr√≥fono
      top: 10, // Ajustar para estar en la parte superior del input
      fontSize: 10,
      color: theme.colors.onSurfaceVariant,
      opacity: 0.7,
      backgroundColor: theme.colors.background,
      paddingHorizontal: 8,
      paddingVertical: 3,
      borderRadius: 12,
      zIndex: 1,
    },
    notesText: {
      fontStyle: 'italic',
      marginTop: 4,
      paddingTop: 4,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
    },
    customHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: 4,
      paddingVertical: 8,
      backgroundColor: theme.colors.elevation.level2,
    },
    headerTitleContainer: {
      flex: 1,
      alignItems: 'center',
      gap: 4,
    },
    headerTitle: {
      ...theme.fonts.titleMedium,
      color: theme.colors.onSurface,
      fontWeight: 'bold',
      textAlign: 'center',
    },
    orderStatusBadge: {
      paddingHorizontal: 12,
      paddingVertical: 4,
      borderRadius: 12,
    },
    orderStatusText: {
      ...theme.fonts.labelSmall,
      color: 'white',
      fontWeight: '600',
      fontSize: 11,
    },
    statusContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      marginTop: 2, // Peque√±o margen para separar del nombre
      justifyContent: 'flex-start', // Alinear a la izquierda
    },
    statusBadge: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingHorizontal: theme.spacing.s,
      paddingVertical: 2, // Reducido de 4 a 2 para ser m√°s compacto
      borderRadius: 12,
      gap: 4,
    },
    statusDot: {
      width: 6,
      height: 6,
      borderRadius: 3,
    },
    statusText: {
      fontSize: 11,
      fontWeight: '600',
      textTransform: 'uppercase',
      letterSpacing: 0.5,
    },
    paymentFab: {
      position: 'absolute',
      margin: 16,
      right: 0,
      bottom: 140, // M√°s arriba para mejor visibilidad
      zIndex: 1000,
      elevation: 6,
      width: 56, // Tama√±o est√°ndar para FAB peque√±o
      height: 56,
      justifyContent: 'center',
      alignItems: 'center',
    },
    paymentConfigButton: {
      marginTop: theme.spacing.s,
    },
    paymentButtonContainer: {
      paddingHorizontal: theme.spacing.s,
      paddingVertical: theme.spacing.m,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
    },
    paymentButton: {
      marginVertical: theme.spacing.xs,
    },
    paymentValueContainer: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    editPaymentButton: {
      margin: 0,
      marginLeft: theme.spacing.xs,
      width: 28,
      height: 28,
    },
    checkboxContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      marginTop: theme.spacing.s,
      marginBottom: theme.spacing.xs,
    },
    checkboxLabel: {
      fontSize: 16,
      marginLeft: theme.spacing.xs,
      color: theme.colors.onSurface,
    },
    temporaryTableInputContainer: {
      marginTop: theme.spacing.xs,
      marginBottom: theme.spacing.s,
    },
    prepaymentSection: {
      marginBottom: theme.spacing.s,
      paddingHorizontal: theme.spacing.xs,
    },
    prepaymentHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.xs,
    },
    prepaymentTitle: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    prepaymentActions: {
      flexDirection: 'row',
      gap: theme.spacing.xs,
    },
    prepaymentIconButton: {
      margin: 0,
    },
    prepaymentWarning: {
      flexDirection: 'row',
      alignItems: 'center',
      backgroundColor: theme.colors.errorContainer,
      padding: theme.spacing.s,
      borderRadius: theme.roundness,
      marginTop: theme.spacing.xs,
      marginBottom: theme.spacing.xs,
    },
    prepaymentWarningText: {
      flex: 1,
      fontSize: 14,
      color: theme.colors.onErrorContainer,
      marginLeft: theme.spacing.xs,
    },
    errorModalContent: {
      backgroundColor: 'transparent',
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.m,
    },
    errorModalContainer: {
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness * 3,
      padding: theme.spacing.xl,
      alignItems: 'center',
      width: '90%',
      maxWidth: 400,
      elevation: 5,
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 2,
      },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
    },
    errorIconContainer: {
      width: 80,
      height: 80,
      borderRadius: 40,
      justifyContent: 'center',
      alignItems: 'center',
      marginBottom: theme.spacing.m,
    },
    errorModalTitle: {
      fontSize: 20,
      fontWeight: 'bold',
      marginBottom: theme.spacing.s,
      textAlign: 'center',
    },
    errorModalMessage: {
      fontSize: 16,
      textAlign: 'center',
      marginBottom: theme.spacing.l,
      lineHeight: 22,
    },
    errorModalButton: {
      marginTop: theme.spacing.m,
      minWidth: 120,
    },
    errorModalButtonContent: {
      paddingHorizontal: theme.spacing.l,
    },
    errorModalButtonLabel: {
      fontSize: 16,
    },
    // Estilos adicionales para eliminar inline styles
    iconButtonNoMargin: {
      margin: 0,
    },
    adjustmentButton: {
      marginTop: theme.spacing.m,
      marginBottom: theme.spacing.s,
    },
    addProductsButton: {
      marginTop: theme.spacing.m,
      marginBottom: theme.spacing.m,
    },
  });
export default OrderCartDetail;

================
File: app/src/modules/orderFinalization/components/OrderCard.tsx
================
import React from 'react';
import { View, StyleSheet, TouchableOpacity } from 'react-native';
import {
  Card,
  Text,
  Checkbox,
  Chip,
  IconButton,
  Icon,
} from 'react-native-paper';
import { OrderForFinalizationList } from '../types/orderFinalization.types';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import {
  formatOrderTypeShort,
  formatOrderStatus,
  getStatusColor,
  getPaymentStatus,
} from '@/app/utils/orderFormatters';

interface OrderCardProps {
  order: OrderForFinalizationList;
  isSelected: boolean;
  onToggleSelection: (orderId: string) => void;
  onShowDetails: (order: OrderForFinalizationList) => void;
  onPrintPress?: (order: OrderForFinalizationList) => void;
}

export const OrderCard = React.memo<OrderCardProps>(
  ({ order, isSelected, onToggleSelection, onShowDetails, onPrintPress }) => {
    const theme = useAppTheme();
    const responsive = useResponsive();
    const styles = React.useMemo(() => createStyles(responsive), [responsive]);

    let orderTitle = `#${order.shiftOrderNumber} ‚Ä¢ ${formatOrderTypeShort(order.orderType)}`;

    if (order.orderType === 'DINE_IN' && order.table) {
      const tableDisplay = order.table.isTemporary
        ? order.table.name
        : `Mesa ${order.table.name || order.table.number || 'N/A'}`;
      orderTitle += ` ‚Ä¢ ${order.table.area?.name || 'Sin √°rea'} ‚Ä¢ ${tableDisplay}`;
    } else if (order.orderType === 'TAKE_AWAY') {
      if (order.deliveryInfo?.recipientName) {
        orderTitle += ` ‚Ä¢ ${order.deliveryInfo.recipientName}`;
      }
      if (order.deliveryInfo?.recipientPhone) {
        orderTitle += ` ‚Ä¢ ${order.deliveryInfo.recipientPhone}`;
      }
    } else if (order.orderType === 'DELIVERY') {
      if (order.deliveryInfo?.fullAddress) {
        orderTitle += ` ‚Ä¢ ${order.deliveryInfo.fullAddress}`;
      }
      if (order.deliveryInfo?.recipientPhone) {
        orderTitle += ` ‚Ä¢ ${order.deliveryInfo.recipientPhone}`;
      }
    }

    const totalAmount =
      typeof order.total === 'string' ? parseFloat(order.total) : order.total;
    const totalPaid = order.paymentsSummary?.totalPaid || 0;
    const pendingAmount = totalAmount - totalPaid;

    const paymentStatus = getPaymentStatus(order);

    return (
      <TouchableOpacity
        activeOpacity={0.95}
        onPress={() => onShowDetails(order)}
      >
        <Card
          style={[
            styles.orderCard,
            {
              backgroundColor: isSelected
                ? theme.colors.primaryContainer
                : theme.colors.surface,
              borderColor: isSelected ? theme.colors.primary : 'transparent',
              borderWidth: isSelected ? 2 : 0,
            },
          ]}
          mode="elevated"
        >
          <Card.Content style={styles.cardContent}>
            <View style={styles.mainContainer}>
              <View style={styles.leftContainer}>
                <Text
                  style={[
                    styles.orderNumber,
                    {
                      color: isSelected
                        ? theme.colors.onPrimaryContainer
                        : theme.colors.onSurface,
                    },
                  ]}
                >
                  {orderTitle}
                  <Text
                    style={[
                      styles.orderPrice,
                      {
                        color:
                          pendingAmount > 0 ? theme.colors.error : '#10B981',
                      },
                    ]}
                  >
                    {' ‚Ä¢ '}
                    {pendingAmount > 0
                      ? `Por pagar: $${pendingAmount.toFixed(2)}`
                      : `Pagado: $${totalAmount.toFixed(2)}`}
                  </Text>
                  {order.notes && (
                    <Text
                      style={[
                        styles.notesInline,
                        {
                          color: isSelected
                            ? theme.colors.onPrimaryContainer
                            : theme.colors.onSurfaceVariant,
                        },
                      ]}
                      numberOfLines={1}
                    >
                      {' ‚Ä¢ '}
                      {order.notes}
                    </Text>
                  )}
                </Text>
                <View style={styles.timeAndPaymentRow}>
                  <Text
                    style={[
                      styles.orderTime,
                      {
                        color: isSelected
                          ? theme.colors.primary
                          : theme.colors.primary,
                      },
                    ]}
                  >
                    {format(new Date(order.createdAt), 'p', { locale: es })}
                  </Text>
                  {(() => {
                    const color =
                      paymentStatus === 'paid'
                        ? '#10B981'
                        : paymentStatus === 'partial'
                          ? '#F59E0B'
                          : '#EF4444';
                    const icon =
                      paymentStatus === 'paid'
                        ? '‚úì'
                        : paymentStatus === 'partial'
                          ? '¬Ω'
                          : '‚Ä¢';
                    return (
                      <View
                        style={[
                          styles.miniPaymentBadge,
                          { backgroundColor: color },
                        ]}
                      >
                        <Text style={styles.miniPaymentText}>{icon}</Text>
                      </View>
                    );
                  })()}

                  {/* Badge de WhatsApp */}
                  {order.isFromWhatsApp && (
                    <View
                      style={[
                        styles.inlinePreparationBadge,
                        {
                          backgroundColor: '#25D366',
                          borderColor: '#25D366',
                        },
                      ]}
                    >
                      <Icon source="whatsapp" size={12} color="#FFFFFF" />
                    </View>
                  )}

                  {order.preparationScreenStatuses &&
                    order.preparationScreenStatuses.length > 0 && (
                      <>
                        {order.preparationScreenStatuses.map(
                          (screen, index) => {
                            const backgroundColor =
                              screen.status === 'READY'
                                ? '#4CAF50'
                                : screen.status === 'IN_PROGRESS'
                                  ? '#FFA000'
                                  : isSelected
                                    ? theme.colors.primaryContainer
                                    : theme.colors.surfaceVariant;

                            const textColor =
                              screen.status === 'READY' ||
                              screen.status === 'IN_PROGRESS'
                                ? '#FFFFFF'
                                : isSelected
                                  ? theme.colors.onPrimaryContainer
                                  : theme.colors.onSurfaceVariant;

                            return (
                              <View
                                key={`${order.id}-screen-${index}`}
                                style={[
                                  styles.inlinePreparationBadge,
                                  {
                                    backgroundColor,
                                    borderColor:
                                      backgroundColor ===
                                      theme.colors.surfaceVariant
                                        ? theme.colors.outline
                                        : backgroundColor,
                                  },
                                ]}
                              >
                                <Text
                                  style={[
                                    styles.inlinePreparationText,
                                    { color: textColor },
                                  ]}
                                >
                                  {screen.status === 'READY'
                                    ? '‚úì '
                                    : screen.status === 'IN_PROGRESS'
                                      ? '‚è≥ '
                                      : ''}
                                  üç≥ {screen.name}
                                </Text>
                              </View>
                            );
                          },
                        )}
                      </>
                    )}
                </View>
              </View>

              <View style={styles.rightContainer}>
                {order.createdBy && (
                  <Text
                    style={[
                      styles.createdByText,
                      {
                        color: isSelected
                          ? theme.colors.onPrimaryContainer
                          : theme.colors.onSurfaceVariant,
                      },
                    ]}
                    numberOfLines={1}
                  >
                    {order.createdBy.firstName && order.createdBy.lastName
                      ? `${order.createdBy.firstName} ${order.createdBy.lastName}`
                      : order.createdBy.username}
                  </Text>
                )}
                <Chip
                  mode="flat"
                  compact
                  style={[
                    styles.statusChip,
                    {
                      backgroundColor: getStatusColor(order.orderStatus, theme),
                    },
                  ]}
                  textStyle={styles.statusChipText}
                >
                  {formatOrderStatus(order.orderStatus)}
                </Chip>
                <View style={styles.actionsContainer}>
                  {onPrintPress && (
                    <TouchableOpacity
                      style={styles.printContainer}
                      onPress={() => onPrintPress(order)}
                      activeOpacity={0.7}
                    >
                      <IconButton
                        icon="printer"
                        size={32}
                        style={styles.printButton}
                        disabled
                      />
                      {(order.ticketImpressionCount ?? 0) > 0 && (
                        <View style={styles.printCountBadge}>
                          <Text style={styles.printCountText}>
                            {order.ticketImpressionCount}
                          </Text>
                        </View>
                      )}
                    </TouchableOpacity>
                  )}
                  <View style={styles.checkboxContainer}>
                    <Checkbox
                      status={isSelected ? 'checked' : 'unchecked'}
                      onPress={() => {
                        onToggleSelection(order.id);
                      }}
                      color={theme.colors.primary}
                      style={styles.checkbox}
                    />
                  </View>
                </View>
              </View>
            </View>
          </Card.Content>
        </Card>
      </TouchableOpacity>
    );
  },
);

OrderCard.displayName = 'OrderCard';

const createStyles = (responsive: ReturnType<typeof useResponsive>) =>
  StyleSheet.create({
    orderCard: {
      marginBottom: responsive.isTablet ? 6 : 8,
    },
    cardContent: {
      paddingBottom: responsive.isTablet ? 6 : 8,
      paddingTop: responsive.isTablet ? 8 : 12,
      paddingHorizontal: responsive.isTablet ? 12 : 16,
    },
    mainContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
    },
    leftContainer: {
      flex: 1,
      paddingRight: 8,
    },
    rightContainer: {
      alignItems: 'flex-end',
      justifyContent: 'space-between',
      minWidth: responsive.isTablet ? 120 : 140,
      gap: responsive.isTablet ? 4 : 8,
    },
    actionsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'flex-end',
      gap: 4,
    },
    orderNumber: {
      fontSize: responsive.isTablet ? 14 : 16,
      fontWeight: 'bold',
      lineHeight: responsive.isTablet ? 18 : 22,
      marginBottom: responsive.isTablet ? 2 : 4,
    },
    orderPrice: {
      fontSize: responsive.isTablet ? 13 : 15,
      fontWeight: '700',
    },
    statusChip: {
      minHeight: 24,
      alignSelf: 'flex-end',
      paddingVertical: 2,
    },
    statusChipText: {
      fontSize: responsive.isTablet ? 10 : 12,
      fontWeight: '600',
      color: 'white',
      lineHeight: responsive.isTablet ? 12 : 14,
      marginVertical: 0,
      paddingVertical: 0,
    },
    orderTime: {
      fontSize: responsive.isTablet ? 13 : 16,
      fontWeight: '600',
    },
    estimatedTime: {
      fontSize: 14,
      marginLeft: 4,
    },
    timeAndPaymentRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 0,
    },
    paymentBadge: {
      paddingHorizontal: 8,
      paddingVertical: 2,
      borderRadius: 12,
      alignItems: 'center',
      justifyContent: 'center',
    },
    paymentBadgeText: {
      fontSize: 11,
      fontWeight: '600',
      lineHeight: 14,
    },
    checkboxContainer: {
      padding: 8,
      marginLeft: -8,
      marginRight: -12,
    },
    checkbox: {
      margin: 0,
      transform: [{ scale: 1.5 }],
    },
    notesInline: {
      fontSize: 12,
      fontStyle: 'italic',
    },
    inlinePreparationBadge: {
      paddingHorizontal: 6,
      paddingVertical: 2,
      borderRadius: 10,
      borderWidth: 0.5,
      marginLeft: 4,
    },
    inlinePreparationText: {
      fontSize: 10,
      fontWeight: '500',
    },
    miniPaymentBadge: {
      width: 20,
      height: 20,
      borderRadius: 10,
      alignItems: 'center',
      justifyContent: 'center',
      marginLeft: 6,
    },
    miniPaymentText: {
      fontSize: 10,
      fontWeight: 'bold',
      color: '#FFFFFF',
    },
    miniPreparationBadge: {
      width: 20,
      height: 20,
      borderRadius: 10,
      alignItems: 'center',
      justifyContent: 'center',
      marginLeft: 4,
    },
    miniPreparationText: {
      fontSize: 10,
      fontWeight: '600',
      color: '#FFFFFF',
    },
    moreIndicator: {
      fontSize: 10,
      marginLeft: 4,
    },
    createdByText: {
      fontSize: 10,
      marginBottom: 4,
      textAlign: 'right',
    },
    rightTopRow: {
      width: '100%',
    },
    printButton: {
      margin: -4,
    },
    printContainer: {
      position: 'relative',
      alignItems: 'center',
      justifyContent: 'center',
    },
    printCountBadge: {
      position: 'absolute',
      top: 0,
      right: 0,
      backgroundColor: '#3B82F6',
      borderRadius: 10,
      minWidth: 20,
      height: 20,
      paddingHorizontal: 4,
      alignItems: 'center',
      justifyContent: 'center',
    },
    printCountText: {
      color: '#FFFFFF',
      fontSize: 10,
      fontWeight: 'bold',
    },
  });

================
File: app/src/app/services/discoveryService.ts
================
import NetInfo from '@react-native-community/netinfo';
import EncryptedStorage from '@/app/services/secureStorageService';
import { NETWORK_CONFIG } from '../constants/network';
import { API_PATHS } from '../constants/apiPaths';
import { Platform } from 'react-native';

const DISCOVERY_ENDPOINT = API_PATHS.DISCOVERY.substring(1); // Quitar / inicial
const STORAGE_KEY = 'last_known_api_url';

interface DiscoveryResponse {
  type: string;
  name: string;
  version: string;
  port: number;
  features: string[];
  timestamp: number;
  remoteUrl?: string;
  tunnelEnabled?: boolean;
}

export class DiscoveryService {
  private static instance: DiscoveryService;
  private cachedUrl: string | null = null;
  private discovering = false;
  private discoveryPromise: Promise<string | null> | null = null;
  private lastDiscoveryTime = 0;
  private logCallback: ((message: string) => void) | null = null;
  private manualUrl: string | null = null;
  private progressCallback:
    | ((progress: { current: number; total: number; message: string }) => void)
    | null = null;

  private constructor() {}

  /**
   * Establece un callback para logs
   */
  setLogCallback(callback: ((message: string) => void) | null) {
    this.logCallback = callback;
  }

  /**
   * Establece un callback para el progreso del discovery
   */
  setProgressCallback(
    callback:
      | ((progress: {
          current: number;
          total: number;
          message: string;
        }) => void)
      | null,
  ) {
    this.progressCallback = callback;
  }

  private log(message: string) {
    if (this.logCallback) {
      this.logCallback(message);
    }
  }

  private updateProgress(current: number, total: number, message: string) {
    if (this.progressCallback) {
      this.progressCallback({ current, total, message });
    }
  }

  static getInstance(): DiscoveryService {
    if (!DiscoveryService.instance) {
      DiscoveryService.instance = new DiscoveryService();
    }
    return DiscoveryService.instance;
  }

  /**
   * Obtiene la URL del API desde cache o almacenamiento
   * Solo verifica si la URL almacenada sigue funcionando
   * @returns string si encuentra una URL v√°lida, null si no encuentra ninguna
   */
  async getApiUrl(): Promise<string | null> {
    // Si hay URL manual configurada, usarla
    if (this.manualUrl) {
      return this.manualUrl;
    }

    // En web, intentar recuperar URL manual guardada
    if (Platform.OS === 'web') {
      try {
        const savedUrl = await EncryptedStorage.getItem('manual_server_url');
        if (savedUrl) {
          this.manualUrl = savedUrl;
          return savedUrl;
        }
      } catch {}
      return null;
    }

    // Si ya tenemos una URL en cache, devolverla sin verificar
    // La verificaci√≥n se hace en otros lugares (health monitoring)
    if (this.cachedUrl) {
      return this.cachedUrl;
    }

    // Intentar con la √∫ltima URL conocida almacenada
    try {
      const lastKnown = await EncryptedStorage.getItem(STORAGE_KEY);
      if (lastKnown) {
        this.cachedUrl = lastKnown;
        return lastKnown;
      }
    } catch {}

    // Si no hay URL v√°lida, devolver null
    return null;
  }

  /**
   * Fuerza un nuevo descubrimiento del backend
   * IMPORTANTE: Solo debe llamarse despu√©s de m√∫ltiples health checks fallidos
   */
  async forceRediscovery(): Promise<string> {
    // Si hay un descubrimiento en progreso, esperar a que termine
    if (this.discoveryPromise && this.discovering) {
      const result = await this.discoveryPromise;
      if (result) return result;
    }

    // FORZAR nueva b√∫squeda - limpiar cache SIEMPRE en forceRediscovery
    await this.clearCache();

    // Verificar que no se est√© llamando muy frecuentemente
    const timeSinceLastDiscovery = Date.now() - this.lastDiscoveryTime;
    if (timeSinceLastDiscovery < NETWORK_CONFIG.MIN_DISCOVERY_INTERVAL) {
      await new Promise((resolve) => setTimeout(resolve, 1000));
    }

    const discoveredUrl = await this.discoverBackend();
    if (!discoveredUrl) {
      throw new Error(
        'No se pudo encontrar el servidor CloudBite en la red local',
      );
    }

    return discoveredUrl;
  }

  async clearCache(): Promise<void> {
    this.cachedUrl = null;
    try {
      await EncryptedStorage.removeItem(STORAGE_KEY);
    } catch {}
  }

  /**
   * Obtiene la √∫ltima URL conocida sin hacer discovery
   */
  async getLastKnownUrl(): Promise<string | null> {
    if (this.cachedUrl) {
      return this.cachedUrl;
    }

    try {
      const lastKnown = await EncryptedStorage.getItem(STORAGE_KEY);
      return lastKnown;
    } catch {
      return null;
    }
  }

  /**
   * Verifica si un servidor est√° disponible
   */
  private async checkServer(url: string): Promise<boolean> {
    const controller = new AbortController();
    const timeoutId = setTimeout(
      () => controller.abort(),
      NETWORK_CONFIG.DISCOVERY_TIMEOUT,
    );

    try {
      const response = await fetch(`${url}${DISCOVERY_ENDPOINT}`, {
        method: 'GET',
        signal: controller.signal,
        headers: {
          Accept: 'application/json',
        },
      });

      if (!response.ok) return false;

      const data: DiscoveryResponse = await response.json();
      return data.type === 'cloudbite-api';
    } catch (error) {
      return false;
    } finally {
      clearTimeout(timeoutId);
    }
  }

  private async discoverBackend(): Promise<string | null> {
    // Si ya hay un descubrimiento en progreso, devolver la promesa existente
    if (this.discoveryPromise && this.discovering) {
      return this.discoveryPromise;
    }

    this.lastDiscoveryTime = Date.now();
    this.discovering = true;

    // Crear nueva promesa de descubrimiento
    this.discoveryPromise = this.performDiscovery()
      .then(async (result) => {
        if (result) {
          // Usar el m√©todo unificado para guardar la URL descubierta
          await this.setServerUrl(result, false);
        }
        return result;
      })
      .finally(() => {
        this.discoveryPromise = null;
        this.discovering = false;
      });

    return this.discoveryPromise;
  }

  private async performDiscovery(): Promise<string | null> {
    try {
      // En web no podemos hacer descubrimiento
      if (Platform.OS === 'web') {
        this.log('‚ùå El descubrimiento autom√°tico no est√° disponible en web');
        return null;
      }

      // Obtener informaci√≥n de red
      const netInfo = await NetInfo.fetch();

      if (!netInfo.isConnected) {
        throw new Error('No hay conexi√≥n de red disponible');
      }

      this.log(
        `üîß Buscando servidor en puerto ${NETWORK_CONFIG.DISCOVERY_PORT}`,
      );

      const subnets = this.detectCurrentSubnet();
      this.log(`üì° Iniciando b√∫squeda en redes: ${subnets.join(', ')}`);

      // Calcular total de IPs a escanear
      let totalIps = 0;
      for (const subnet of subnets) {
        totalIps += 254; // IPs de .1 a .254
      }
      this.updateProgress(0, totalIps, 'Iniciando b√∫squeda...');

      let globalIpsScanned = 0;

      // Probar cada subnet hasta encontrar el servidor
      for (const subnet of subnets) {
        this.log(`üîç Escaneando red ${subnet}.*`);
        this.updateProgress(
          globalIpsScanned,
          totalIps,
          `Escaneando red ${subnet}.*`,
        );

        const ips = this.generateIpRange(subnet);
        const chunks = this.chunkArray(
          ips,
          NETWORK_CONFIG.MAX_CONCURRENT_REQUESTS,
        );

        let totalIpsScanned = 0;

        for (let i = 0; i < chunks.length; i++) {
          const currentIps = chunks[i];

          const results = await Promise.allSettled(
            currentIps.map((ip) => this.probeServer(ip)),
          );

          totalIpsScanned += currentIps.length;
          globalIpsScanned += currentIps.length;

          // Actualizar progreso
          this.updateProgress(
            globalIpsScanned,
            totalIps,
            `Escaneando ${subnet}.* (${Math.round((globalIpsScanned / totalIps) * 100)}%)`,
          );

          // Buscar si alguna petici√≥n fue exitosa
          for (let j = 0; j < results.length; j++) {
            const result = results[j];
            if (result.status === 'fulfilled' && result.value) {
              const foundIp = currentIps[j];
              this.log(`‚úÖ ¬°SERVIDOR ENCONTRADO EN ${foundIp}!`);
              this.updateProgress(
                globalIpsScanned,
                totalIps,
                `¬°Servidor encontrado en ${foundIp}!`,
              );
              return result.value;
            }
          }

          // Mostrar progreso cada 10 IPs
          if (totalIpsScanned % 10 === 0) {
            const lastIp = currentIps[currentIps.length - 1];
            this.log(
              `  ‚ñ∂ Escaneadas ${totalIpsScanned} IPs (√∫ltima: ${lastIp})`,
            );
          }
        }

        this.log(`  ‚ùå No encontrado en ${subnet}.*`);
      }

      return null;
    } catch (error) {
      this.log(
        `‚ùå Error durante el descubrimiento: ${error instanceof Error ? error.message : 'Error desconocido'}`,
      );
      return null;
    }
  }

  /**
   * Prueba si una IP espec√≠fica tiene el servidor CloudBite
   */
  private async probeServer(ip: string): Promise<string | null> {
    const url = `http://${ip}:${NETWORK_CONFIG.DISCOVERY_PORT}`;
    const fullUrl = `http://${ip}:${NETWORK_CONFIG.DISCOVERY_PORT}${API_PATHS.DISCOVERY}`;

    // Crear AbortController para timeout real
    const controller = new AbortController();
    const timeoutId = setTimeout(() => {
      controller.abort();
    }, NETWORK_CONFIG.DISCOVERY_TIMEOUT);

    try {
      const response = await fetch(fullUrl, {
        method: 'GET',
        headers: {
          Accept: 'application/json',
        },
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      if (response.ok) {
        const text = await response.text();
        try {
          const data = JSON.parse(text);
          if (data.type === 'cloudbite-api') {
            this.log(`‚úÖ ¬°SERVIDOR ENCONTRADO!`);
            this.log(`üìç IP: ${ip}`);
            this.log(`üîó URL: ${url}`);
            return url;
          }
        } catch {
          // No es el servidor que buscamos
        }
      }
    } catch {
    } finally {
      clearTimeout(timeoutId);
    }

    return null;
  }

  private detectCurrentSubnet(): string[] {
    return NETWORK_CONFIG.COMMON_SUBNETS;
  }

  /**
   * Genera un rango de IPs para escanear
   */
  private generateIpRange(subnet: string): string[] {
    const ips: string[] = [];
    for (let i = 1; i <= 254; i++) {
      ips.push(`${subnet}.${i}`);
    }
    return ips;
  }

  /**
   * Divide un array en chunks m√°s peque√±os
   */
  private chunkArray<T>(array: T[], size: number): T[][] {
    const chunks: T[][] = [];
    for (let i = 0; i < array.length; i += size) {
      chunks.push(array.slice(i, i + size));
    }
    return chunks;
  }

  /**
   * Guarda la URL en almacenamiento seguro
   */
  private async saveUrl(url: string): Promise<void> {
    try {
      await EncryptedStorage.setItem(STORAGE_KEY, url);
    } catch {}
  }

  /**
   * Establece la URL del servidor y la guarda
   * @param url - La URL del servidor (null para limpiar URL manual)
   * @param isManual - Si es true, se marca como configuraci√≥n manual
   */
  async setServerUrl(
    url: string | null,
    isManual: boolean = false,
  ): Promise<void> {
    if (url) {
      // Actualizar cache en memoria
      this.cachedUrl = url;

      // Si es manual, guardar referencia especial
      if (isManual) {
        this.manualUrl = url;
      }

      // Persistir en almacenamiento seguro
      await this.saveUrl(url);
    } else if (isManual) {
      // Solo limpiar manual URL si expl√≠citamente se pide
      this.manualUrl = null;
    }
  }

  async discoverServer(): Promise<string | null> {
    return this.discoverBackend();
  }

  /**
   * Obtiene informaci√≥n del servidor incluyendo URL remota si est√° disponible
   */
  async getServerInfo(): Promise<DiscoveryResponse | null> {
    const url = await this.getApiUrl();
    if (!url) return null;

    try {
      const response = await fetch(`${url}${DISCOVERY_ENDPOINT}`, {
        method: 'GET',
        headers: {
          Accept: 'application/json',
        },
      });

      if (response.ok) {
        const data: DiscoveryResponse = await response.json();
        return data;
      }
    } catch (error) {
      console.error('Error getting server info:', error);
    }

    return null;
  }
}

// Exportar instancia singleton
export const discoveryService = DiscoveryService.getInstance();

================
File: app/src/modules/orders/screens/OpenOrdersScreen.tsx
================
import React, { useCallback, useEffect, useState } from 'react';
import {
  StyleSheet,
  View,
  Pressable,
  TouchableOpacity,
  Animated,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { FlashList } from '@shopify/flash-list';
import {
  Text,
  ActivityIndicator,
  Appbar,
  IconButton,
  Portal,
  Card,
  Chip,
  Icon,
  Surface,
  Button,
} from 'react-native-paper';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { useResponsive } from '../../../app/hooks/useResponsive';
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import type { OrdersStackParamList } from '../../../app/navigation/types';
import { useAuthStore } from '../../../app/store/authStore';
import { canOpenShift } from '../../../app/utils/roleUtils';
import { useGlobalShift } from '../../../app/hooks/useGlobalShift';
import { useSnackbarStore } from '../../../app/store/snackbarStore';
import { NAVIGATION_PATHS } from '@/app/constants/navigationPaths';
import {
  useGetOpenOrdersListQuery,
  useUpdateOrderMutation,
  useCancelOrderMutation,
} from '../hooks/useOrdersQueries';
import {
  OrderOpenList,
  OrderType,
  OrderTypeEnum,
  OrderStatusEnum,
} from '../types/orders.types';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import { PrintTicketModal } from '@/modules/shared/components/PrintTicketModal';
import { orderPrintService } from '../services/orderPrintService';
import OrderCartDetail from '../components/OrderCartDetail';
import { useListState } from '../../../app/hooks/useListState';
import { CartItem } from '../stores/useCartStore';
import {
  formatOrderStatus,
  formatOrderType,
  formatOrderTypeShort,
  getPaymentStatus,
  getStatusColor,
} from '../../../app/utils/orderFormatters';

type OpenOrdersScreenProps = NativeStackScreenProps<
  OrdersStackParamList,
  'OpenOrders'
>;

const OpenOrdersScreen: React.FC<OpenOrdersScreenProps> = ({ navigation }) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const [isPrintModalVisible, setIsPrintModalVisible] = useState(false);
  const [orderToPrint, setOrderToPrint] = useState<OrderOpenList | null>(null);
  const [acceptingOrderId, setAcceptingOrderId] = useState<string | null>(null);

  const user = useAuthStore((state) => state.user);
  const { data: shift, isLoading: shiftLoading } = useGlobalShift();
  const userCanOpenShift = canOpenShift(user);

  const [isEditModalVisible, setIsEditModalVisible] = useState(false);
  const [editingOrderId, setEditingOrderId] = useState<string | null>(null);
  const [pendingProductsToAdd, setPendingProductsToAdd] = useState<CartItem[]>(
    [],
  );
  const [temporaryProducts, setTemporaryProducts] = useState<{
    [orderId: string]: CartItem[];
  }>({});
  const [existingItemsCount, setExistingItemsCount] = useState<{
    [orderId: string]: number;
  }>({});

  const [selectedOrderType, setSelectedOrderType] = useState<
    OrderType | 'ALL' | 'WHATSAPP'
  >('ALL');

  const updateOrderMutation = useUpdateOrderMutation();
  const cancelOrderMutation = useCancelOrderMutation();

  const {
    data: ordersData,
    isLoading,
    isError,
    refetch,
    isFetching,
  } = useGetOpenOrdersListQuery();
  const filteredOrders = React.useMemo(() => {
    if (!ordersData) return [];

    if (selectedOrderType === 'ALL') {
      // En ALL, excluir pedidos de WhatsApp pendientes
      return ordersData.filter(
        (order) =>
          !(
            order.isFromWhatsApp &&
            order.orderStatus === OrderStatusEnum.PENDING
          ),
      );
    }

    if (selectedOrderType === 'WHATSAPP') {
      // Filtrar solo pedidos de WhatsApp con estado PENDING
      return ordersData.filter(
        (order) =>
          order.isFromWhatsApp && order.orderStatus === OrderStatusEnum.PENDING,
      );
    }

    // Para otros filtros (DINE_IN, TAKE_AWAY, DELIVERY), excluir pedidos de WhatsApp pendientes
    return ordersData.filter(
      (order) =>
        order.orderType === selectedOrderType &&
        !(
          order.isFromWhatsApp && order.orderStatus === OrderStatusEnum.PENDING
        ),
    );
  }, [ordersData, selectedOrderType]);

  const handleRefresh = useCallback(() => {
    refetch();
  }, [refetch]);

  // Funci√≥n para abrir el modal de impresi√≥n
  const handleOpenPrintModal = useCallback((order: OrderOpenList) => {
    setOrderToPrint(order);
    setIsPrintModalVisible(true);
  }, []);

  const handleOrderItemPress = (order: OrderOpenList) => {
    // Guardar solo el ID y abrir el modal
    setEditingOrderId(order.id);
    setIsEditModalVisible(true);
  };

  const renderOrderItem = useCallback(
    ({ item: order }: { item: OrderOpenList }) => {
      // Construir el t√≠tulo seg√∫n el tipo de orden
      let orderTitle = `#${order.shiftOrderNumber} ‚Ä¢ ${formatOrderTypeShort(order.orderType)}`;

      if (order.orderType === OrderTypeEnum.DINE_IN && order.table) {
        // Para mesas temporales, mostrar solo el nombre sin prefijo "Mesa"
        const tableDisplay = order.table.isTemporary
          ? order.table.name
          : `Mesa ${order.table.name || order.table.number || 'N/A'}`;
        orderTitle += ` ‚Ä¢ ${order.table.area?.name || 'Sin √°rea'} ‚Ä¢ ${tableDisplay}`;
      } else if (order.orderType === OrderTypeEnum.TAKE_AWAY) {
        if (order.deliveryInfo?.recipientName) {
          orderTitle += ` ‚Ä¢ ${order.deliveryInfo.recipientName}`;
        }
        if (order.deliveryInfo?.recipientPhone) {
          orderTitle += ` ‚Ä¢ ${order.deliveryInfo.recipientPhone}`;
        }
      } else if (order.orderType === OrderTypeEnum.DELIVERY) {
        if (order.deliveryInfo?.fullAddress) {
          orderTitle += ` ‚Ä¢ ${order.deliveryInfo.fullAddress}`;
        }
        if (order.deliveryInfo?.recipientPhone) {
          orderTitle += ` ‚Ä¢ ${order.deliveryInfo.recipientPhone}`;
        }
      }

      const totalAmount =
        typeof order.total === 'string' ? parseFloat(order.total) : order.total;
      const totalPaid = order.paymentsSummary?.totalPaid || 0;
      const pendingAmount = totalAmount - totalPaid;

      return (
        <TouchableOpacity
          activeOpacity={0.95}
          onPress={() => handleOrderItemPress(order)}
        >
          <Card
            style={[
              styles.orderCard,
              {
                backgroundColor: theme.colors.surface,
              },
            ]}
            mode="elevated"
          >
            <Card.Content style={styles.cardContent}>
              <View style={styles.mainContainer}>
                <View style={styles.leftContainer}>
                  <Text
                    style={[
                      styles.orderNumber,
                      { color: theme.colors.onSurface },
                    ]}
                  >
                    {orderTitle}
                    <Text
                      style={[
                        styles.orderPrice,
                        {
                          color:
                            pendingAmount > 0 ? theme.colors.error : '#10B981',
                        },
                      ]}
                    >
                      {' ‚Ä¢ '}
                      {pendingAmount > 0
                        ? `Por pagar: $${pendingAmount.toFixed(2)}`
                        : `Pagado: $${totalAmount.toFixed(2)}`}
                    </Text>
                    {order.notes && (
                      <Text
                        style={[
                          styles.notesInline,
                          { color: theme.colors.onSurfaceVariant },
                        ]}
                        numberOfLines={1}
                      >
                        {' ‚Ä¢ '}
                        {order.notes}
                      </Text>
                    )}
                  </Text>
                  <View style={styles.timeAndPaymentRow}>
                    <Text
                      style={[
                        styles.orderTime,
                        { color: theme.colors.primary },
                      ]}
                    >
                      {format(new Date(order.createdAt), 'p', { locale: es })}
                    </Text>
                    {(() => {
                      const paymentStatus = getPaymentStatus(order);
                      const color =
                        paymentStatus === 'paid'
                          ? '#10B981'
                          : paymentStatus === 'partial'
                            ? '#F59E0B'
                            : '#EF4444';
                      const icon =
                        paymentStatus === 'paid'
                          ? '‚úì'
                          : paymentStatus === 'partial'
                            ? '¬Ω'
                            : '‚Ä¢';
                      return (
                        <View
                          style={[
                            styles.miniPaymentBadge,
                            { backgroundColor: color },
                          ]}
                        >
                          <Text style={styles.miniPaymentText}>{icon}</Text>
                        </View>
                      );
                    })()}

                    {/* Badge de WhatsApp */}
                    {order.isFromWhatsApp && (
                      <View
                        style={[
                          styles.inlinePreparationBadge,
                          {
                            backgroundColor: '#25D366',
                            borderColor: '#25D366',
                          },
                        ]}
                      >
                        <Icon source="whatsapp" size={12} color="#FFFFFF" />
                      </View>
                    )}

                    {order.preparationScreenStatuses &&
                      order.preparationScreenStatuses.length > 0 && (
                        <>
                          {order.preparationScreenStatuses.map(
                            (screen, index) => {
                              const backgroundColor =
                                screen.status === 'READY'
                                  ? '#4CAF50'
                                  : screen.status === 'IN_PROGRESS'
                                    ? '#FFA000'
                                    : theme.colors.surfaceVariant;

                              const textColor =
                                screen.status === 'READY' ||
                                screen.status === 'IN_PROGRESS'
                                  ? '#FFFFFF'
                                  : theme.colors.onSurfaceVariant;

                              return (
                                <View
                                  key={`${order.id}-screen-${index}`}
                                  style={[
                                    styles.inlinePreparationBadge,
                                    {
                                      backgroundColor,
                                      borderColor:
                                        backgroundColor ===
                                        theme.colors.surfaceVariant
                                          ? theme.colors.outline
                                          : backgroundColor,
                                    },
                                  ]}
                                >
                                  <Text
                                    style={[
                                      styles.inlinePreparationText,
                                      { color: textColor },
                                    ]}
                                  >
                                    {screen.status === 'READY'
                                      ? '‚úì '
                                      : screen.status === 'IN_PROGRESS'
                                        ? '‚è≥ '
                                        : ''}
                                    üç≥ {screen.name}
                                  </Text>
                                </View>
                              );
                            },
                          )}
                        </>
                      )}
                  </View>
                </View>

                <View style={styles.rightContainer}>
                  {order.createdBy && (
                    <Text style={styles.createdByText} numberOfLines={1}>
                      {order.createdBy.firstName && order.createdBy.lastName
                        ? `${order.createdBy.firstName} ${order.createdBy.lastName}`
                        : order.createdBy.username}
                    </Text>
                  )}
                  <Chip
                    mode="flat"
                    compact
                    style={[
                      styles.statusChip,
                      {
                        backgroundColor: getStatusColor(
                          order.orderStatus,
                          theme,
                        ),
                      },
                    ]}
                    textStyle={styles.statusChipText}
                  >
                    {formatOrderStatus(order.orderStatus)}
                  </Chip>
                  <View style={styles.actionsContainer}>
                    {selectedOrderType === 'WHATSAPP' &&
                    order.orderStatus === OrderStatusEnum.PENDING ? (
                      <Button
                        mode="contained"
                        icon="check"
                        onPress={() => handleAcceptWhatsAppOrder(order.id)}
                        disabled={acceptingOrderId === order.id}
                        loading={acceptingOrderId === order.id}
                        compact
                      >
                        Aceptar
                      </Button>
                    ) : (
                      <TouchableOpacity
                        style={styles.printContainer}
                        onPress={() => handleOpenPrintModal(order)}
                        activeOpacity={0.7}
                      >
                        <IconButton
                          icon="printer"
                          size={32}
                          style={styles.printButton}
                          disabled
                        />
                        {(order.ticketImpressionCount ?? 0) > 0 && (
                          <View style={styles.printCountBadge}>
                            <Text style={styles.printCountText}>
                              {order.ticketImpressionCount}
                            </Text>
                          </View>
                        )}
                      </TouchableOpacity>
                    )}
                  </View>
                </View>
              </View>
            </Card.Content>
          </Card>
        </TouchableOpacity>
      );
    },
    [
      handleOrderItemPress,
      handleOpenPrintModal,
      handleAcceptWhatsAppOrder,
      selectedOrderType,
      acceptingOrderId,
      theme,
      styles,
    ],
  );

  const { ListEmptyComponent } = useListState({
    isLoading,
    isError,
    data: filteredOrders,
    emptyConfig: {
      title:
        selectedOrderType === 'ALL'
          ? 'No hay √≥rdenes abiertas'
          : selectedOrderType === 'WHATSAPP'
            ? 'No hay pedidos de WhatsApp pendientes'
            : `No hay √≥rdenes de tipo ${formatOrderType(
                selectedOrderType as OrderType,
              )
                .replace(/[\u{1F37D}]|[\u{FE0F}]|[\u{1F961}]|[\u{1F69A}]/gu, '')
                .trim()}`,
      message:
        selectedOrderType === 'ALL'
          ? 'No hay √≥rdenes abiertas en este momento.'
          : selectedOrderType === 'WHATSAPP'
            ? 'No hay pedidos de WhatsApp esperando aceptaci√≥n.'
            : `No hay √≥rdenes de este tipo en este momento.`,
      icon:
        selectedOrderType === 'WHATSAPP'
          ? 'whatsapp'
          : 'clipboard-text-outline',
    },
    errorConfig: {
      title: 'Error al cargar √≥rdenes',
      message: 'No se pudieron cargar las √≥rdenes. Verifica tu conexi√≥n.',
      icon: 'wifi-off',
      actionLabel: 'Reintentar',
      onAction: () => refetch(),
    },
  });

  // Efecto para configurar el bot√≥n de refrescar en el header
  useEffect(() => {
    navigation.setOptions({
      headerRight: () => (
        <Appbar.Action
          icon="refresh"
          iconColor={theme.colors.onPrimary}
          size={28}
          onPress={handleRefresh}
          disabled={isFetching} // Deshabilitar mientras se refresca
          style={styles.headerRefreshButton} // Agregar margen para mejor accesibilidad
        />
      ),
    });
  }, [navigation, handleRefresh, isFetching, theme.colors.onPrimary]); // A√±adir dependencias

  // Efecto para sincronizar productos temporales con pendientes
  useEffect(() => {
    if (
      isEditModalVisible &&
      editingOrderId &&
      temporaryProducts[editingOrderId]
    ) {
      setPendingProductsToAdd(temporaryProducts[editingOrderId]);
    }
  }, [isEditModalVisible, editingOrderId, temporaryProducts]);

  // Funci√≥n para manejar la impresi√≥n del ticket
  const handlePrint = useCallback(
    async (printerId: string, ticketType: 'GENERAL' | 'BILLING') => {
      if (!orderToPrint) return;

      try {
        await orderPrintService.printTicket(orderToPrint.id, {
          printerId,
          ticketType,
        });

        showSnackbar({
          message: 'Ticket impreso exitosamente',
          type: 'success',
        });

        // Refrescar la lista
        refetch();

        // Limpiar estado
        setOrderToPrint(null);
      } catch (error) {
        showSnackbar({
          message: 'Error al imprimir el ticket',
          type: 'error',
        });
      }
    },
    [orderToPrint, refetch, showSnackbar],
  );

  // Funci√≥n para aceptar un pedido de WhatsApp
  const handleAcceptWhatsAppOrder = useCallback(
    async (orderId: string) => {
      if (acceptingOrderId !== null) return;

      setAcceptingOrderId(orderId);

      try {
        await updateOrderMutation.mutateAsync({
          orderId,
          payload: {
            orderStatus: OrderStatusEnum.IN_PROGRESS,
          },
        });

        showSnackbar({
          message: 'Pedido aceptado exitosamente',
          type: 'success',
        });

        refetch();
      } catch (error) {
        showSnackbar({
          message: 'Error al aceptar el pedido',
          type: 'error',
        });
      } finally {
        setAcceptingOrderId(null);
      }
    },
    [acceptingOrderId, updateOrderMutation, refetch, showSnackbar],
  );

  // Funci√≥n para manejar la cancelaci√≥n de una orden
  const handleCancelOrder = useCallback(
    async (orderId: string) => {
      try {
        await cancelOrderMutation.mutateAsync(orderId);
        // Cerrar el modal despu√©s de cancelar exitosamente
        setIsEditModalVisible(false);
        setEditingOrderId(null);
      } catch (error) {
        // El error se muestra a trav√©s del hook useCancelOrderMutation
      }
    },
    [cancelOrderMutation],
  );

  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      {!shiftLoading && (!shift || shift.status !== 'OPEN') ? (
        <View style={styles.container}>
          <View style={styles.emptyStateContainer}>
            <Icon
              source="store-alert"
              size={64}
              color={theme.colors.onSurfaceVariant}
            />
            <Text variant="headlineSmall" style={styles.emptyStateTitle}>
              Turno Cerrado
            </Text>
            <Text variant="bodyLarge" style={styles.emptyStateText}>
              {userCanOpenShift
                ? 'Para ver las √≥rdenes abiertas, primero debes abrir el turno usando el indicador en la barra superior.'
                : 'El turno debe estar abierto para ver las √≥rdenes. Contacta a un administrador.'}
            </Text>
          </View>
        </View>
      ) : isLoading && !ordersData ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
          <Text style={styles.loadingText}>Cargando √≥rdenes...</Text>
        </View>
      ) : (
        <>
          {/* Filtros de tipo de orden con el mismo dise√±o que finalizaci√≥n */}
          <Surface style={styles.header}>
            <View style={styles.headerContent}>
              <View style={styles.filterContainer}>
                <Pressable
                  style={[
                    styles.filterButton,
                    selectedOrderType === 'ALL' && styles.filterButtonActive,
                    {
                      backgroundColor:
                        selectedOrderType === 'ALL'
                          ? theme.colors.primaryContainer
                          : theme.colors.surface,
                    },
                  ]}
                  onPress={() => setSelectedOrderType('ALL')}
                >
                  <Icon
                    source="view-grid"
                    size={26}
                    color={
                      selectedOrderType === 'ALL'
                        ? theme.colors.primary
                        : theme.colors.onSurfaceVariant
                    }
                  />
                  {ordersData &&
                    ordersData.filter(
                      (o) =>
                        !(
                          o.isFromWhatsApp &&
                          o.orderStatus === OrderStatusEnum.PENDING
                        ),
                    ).length > 0 && (
                      <View
                        style={[
                          styles.countBadge,
                          {
                            backgroundColor:
                              selectedOrderType === 'ALL'
                                ? theme.colors.error
                                : theme.colors.errorContainer,
                            borderColor:
                              selectedOrderType === 'ALL'
                                ? theme.colors.error
                                : theme.colors.outline,
                          },
                        ]}
                      >
                        <Text
                          style={[
                            styles.countBadgeText,
                            {
                              color:
                                selectedOrderType === 'ALL'
                                  ? theme.colors.onError
                                  : theme.colors.onErrorContainer,
                            },
                          ]}
                        >
                          {
                            ordersData.filter(
                              (o) =>
                                !(
                                  o.isFromWhatsApp &&
                                  o.orderStatus === OrderStatusEnum.PENDING
                                ),
                            ).length
                          }
                        </Text>
                      </View>
                    )}
                </Pressable>
                <Pressable
                  style={[
                    styles.filterButton,
                    selectedOrderType === OrderTypeEnum.DINE_IN &&
                      styles.filterButtonActive,
                    {
                      backgroundColor:
                        selectedOrderType === OrderTypeEnum.DINE_IN
                          ? theme.colors.primaryContainer
                          : theme.colors.surface,
                    },
                  ]}
                  onPress={() => setSelectedOrderType(OrderTypeEnum.DINE_IN)}
                >
                  <Icon
                    source="silverware-fork-knife"
                    size={26}
                    color={
                      selectedOrderType === OrderTypeEnum.DINE_IN
                        ? theme.colors.primary
                        : theme.colors.onSurfaceVariant
                    }
                  />
                  {ordersData &&
                    ordersData.filter(
                      (o) =>
                        o.orderType === OrderTypeEnum.DINE_IN &&
                        !(
                          o.isFromWhatsApp &&
                          o.orderStatus === OrderStatusEnum.PENDING
                        ),
                    ).length > 0 && (
                      <View
                        style={[
                          styles.countBadge,
                          {
                            backgroundColor:
                              selectedOrderType === OrderTypeEnum.DINE_IN
                                ? theme.colors.error
                                : theme.colors.errorContainer,
                            borderColor:
                              selectedOrderType === OrderTypeEnum.DINE_IN
                                ? theme.colors.error
                                : theme.colors.outline,
                          },
                        ]}
                      >
                        <Text
                          style={[
                            styles.countBadgeText,
                            {
                              color:
                                selectedOrderType === OrderTypeEnum.DINE_IN
                                  ? theme.colors.onError
                                  : theme.colors.onErrorContainer,
                            },
                          ]}
                        >
                          {
                            ordersData.filter(
                              (o) =>
                                o.orderType === OrderTypeEnum.DINE_IN &&
                                !(
                                  o.isFromWhatsApp &&
                                  o.orderStatus === OrderStatusEnum.PENDING
                                ),
                            ).length
                          }
                        </Text>
                      </View>
                    )}
                </Pressable>
                <Pressable
                  style={[
                    styles.filterButton,
                    selectedOrderType === OrderTypeEnum.TAKE_AWAY &&
                      styles.filterButtonActive,
                    {
                      backgroundColor:
                        selectedOrderType === OrderTypeEnum.TAKE_AWAY
                          ? theme.colors.primaryContainer
                          : theme.colors.surface,
                    },
                  ]}
                  onPress={() => setSelectedOrderType(OrderTypeEnum.TAKE_AWAY)}
                >
                  <Icon
                    source="bag-personal"
                    size={26}
                    color={
                      selectedOrderType === OrderTypeEnum.TAKE_AWAY
                        ? theme.colors.primary
                        : theme.colors.onSurfaceVariant
                    }
                  />
                  {ordersData &&
                    ordersData.filter(
                      (o) =>
                        o.orderType === OrderTypeEnum.TAKE_AWAY &&
                        !(
                          o.isFromWhatsApp &&
                          o.orderStatus === OrderStatusEnum.PENDING
                        ),
                    ).length > 0 && (
                      <View
                        style={[
                          styles.countBadge,
                          {
                            backgroundColor:
                              selectedOrderType === OrderTypeEnum.TAKE_AWAY
                                ? theme.colors.error
                                : theme.colors.errorContainer,
                            borderColor:
                              selectedOrderType === OrderTypeEnum.TAKE_AWAY
                                ? theme.colors.error
                                : theme.colors.outline,
                          },
                        ]}
                      >
                        <Text
                          style={[
                            styles.countBadgeText,
                            {
                              color:
                                selectedOrderType === OrderTypeEnum.TAKE_AWAY
                                  ? theme.colors.onError
                                  : theme.colors.onErrorContainer,
                            },
                          ]}
                        >
                          {
                            ordersData.filter(
                              (o) =>
                                o.orderType === OrderTypeEnum.TAKE_AWAY &&
                                !(
                                  o.isFromWhatsApp &&
                                  o.orderStatus === OrderStatusEnum.PENDING
                                ),
                            ).length
                          }
                        </Text>
                      </View>
                    )}
                </Pressable>
                <Pressable
                  style={[
                    styles.filterButton,
                    selectedOrderType === OrderTypeEnum.DELIVERY &&
                      styles.filterButtonActive,
                    {
                      backgroundColor:
                        selectedOrderType === OrderTypeEnum.DELIVERY
                          ? theme.colors.primaryContainer
                          : theme.colors.surface,
                    },
                  ]}
                  onPress={() => setSelectedOrderType(OrderTypeEnum.DELIVERY)}
                >
                  <Icon
                    source="moped"
                    size={26}
                    color={
                      selectedOrderType === OrderTypeEnum.DELIVERY
                        ? theme.colors.primary
                        : theme.colors.onSurfaceVariant
                    }
                  />
                  {ordersData &&
                    ordersData.filter(
                      (o) =>
                        o.orderType === OrderTypeEnum.DELIVERY &&
                        !(
                          o.isFromWhatsApp &&
                          o.orderStatus === OrderStatusEnum.PENDING
                        ),
                    ).length > 0 && (
                      <View
                        style={[
                          styles.countBadge,
                          {
                            backgroundColor:
                              selectedOrderType === OrderTypeEnum.DELIVERY
                                ? theme.colors.error
                                : theme.colors.errorContainer,
                            borderColor:
                              selectedOrderType === OrderTypeEnum.DELIVERY
                                ? theme.colors.error
                                : theme.colors.outline,
                          },
                        ]}
                      >
                        <Text
                          style={[
                            styles.countBadgeText,
                            {
                              color:
                                selectedOrderType === OrderTypeEnum.DELIVERY
                                  ? theme.colors.onError
                                  : theme.colors.onErrorContainer,
                            },
                          ]}
                        >
                          {
                            ordersData.filter(
                              (o) =>
                                o.orderType === OrderTypeEnum.DELIVERY &&
                                !(
                                  o.isFromWhatsApp &&
                                  o.orderStatus === OrderStatusEnum.PENDING
                                ),
                            ).length
                          }
                        </Text>
                      </View>
                    )}
                </Pressable>
                <Pressable
                  style={[
                    styles.filterButton,
                    selectedOrderType === 'WHATSAPP' &&
                      styles.filterButtonActive,
                    {
                      backgroundColor:
                        selectedOrderType === 'WHATSAPP'
                          ? theme.colors.primaryContainer
                          : theme.colors.surface,
                    },
                  ]}
                  onPress={() => setSelectedOrderType('WHATSAPP')}
                >
                  <Icon
                    source="whatsapp"
                    size={26}
                    color={
                      selectedOrderType === 'WHATSAPP'
                        ? theme.colors.primary
                        : theme.colors.onSurfaceVariant
                    }
                  />
                  {ordersData &&
                    ordersData.filter(
                      (o) =>
                        o.isFromWhatsApp &&
                        o.orderStatus === OrderStatusEnum.PENDING,
                    ).length > 0 && (
                      <View
                        style={[
                          styles.countBadge,
                          {
                            backgroundColor:
                              selectedOrderType === 'WHATSAPP'
                                ? theme.colors.error
                                : theme.colors.errorContainer,
                            borderColor:
                              selectedOrderType === 'WHATSAPP'
                                ? theme.colors.error
                                : theme.colors.outline,
                          },
                        ]}
                      >
                        <Text
                          style={[
                            styles.countBadgeText,
                            {
                              color:
                                selectedOrderType === 'WHATSAPP'
                                  ? theme.colors.onError
                                  : theme.colors.onErrorContainer,
                            },
                          ]}
                        >
                          {
                            ordersData.filter(
                              (o) =>
                                o.isFromWhatsApp &&
                                o.orderStatus === OrderStatusEnum.PENDING,
                            ).length
                          }
                        </Text>
                      </View>
                    )}
                </Pressable>
              </View>
            </View>
          </Surface>

          {/* Lista de √≥rdenes */}
          <View style={styles.listContainer}>
            <FlashList
              data={filteredOrders}
              keyExtractor={(item) => item.id}
              renderItem={renderOrderItem}
              refreshing={isFetching}
              onRefresh={handleRefresh}
              contentContainerStyle={styles.listContentContainer}
              ListEmptyComponent={ListEmptyComponent}
              estimatedItemSize={120}
              removeClippedSubviews={true}
            />
          </View>
        </>
      )}
      {/* Modal de Impresi√≥n de Ticket */}
      <Portal>
        <PrintTicketModal
          visible={isPrintModalVisible}
          onDismiss={() => {
            setIsPrintModalVisible(false);
            setOrderToPrint(null);
          }}
          order={orderToPrint}
          onPrint={handlePrint}
        />
        {/* Modal de Edici√≥n de Orden usando OrderCartDetail */}
        {editingOrderId && (
            <OrderCartDetail
              visible={isEditModalVisible}
              isEditMode={true}
              orderId={editingOrderId}
              orderNumber={
                ordersData?.find((o) => o.id === editingOrderId)
                  ?.shiftOrderNumber
              }
              orderDate={
                ordersData?.find((o) => o.id === editingOrderId)?.createdAt
                  ? new Date(
                      ordersData.find(
                        (o) => o.id === editingOrderId,
                      )!.createdAt,
                    )
                  : undefined
              }
              navigation={navigation}
              pendingProductsToAdd={
                editingOrderId && temporaryProducts[editingOrderId]
                  ? temporaryProducts[editingOrderId]
                  : pendingProductsToAdd
              }
              onItemsCountChanged={(count) => {
                // Actualizar el conteo de items existentes para esta orden
                setExistingItemsCount((prev) => ({
                  ...prev,
                  [editingOrderId]: count,
                }));
              }}
              onClose={() => {
                setIsEditModalVisible(false);
                setEditingOrderId(null);
                setPendingProductsToAdd([]);
                // NO limpiar temporaryProducts aqu√≠ para mantener los productos
                // NO llamar refetch() aqu√≠ porque ya se maneja con invalidateQueries
                // y el refetchInterval autom√°tico
              }}
              onAddProducts={() => {
                // Cerrar el modal temporalmente para navegar
                setIsEditModalVisible(false);

                const orderNumber = ordersData?.find(
                  (o) => o.id === editingOrderId,
                )?.shiftOrderNumber;

                // Navegar a a√±adir productos
                setTimeout(() => {
                  const existingProducts =
                    temporaryProducts[editingOrderId!] || [];
                  navigation.navigate(NAVIGATION_PATHS.ADD_PRODUCTS_TO_ORDER, {
                    orderId: editingOrderId!,
                    orderNumber: orderNumber!,
                    // Pasar productos temporales existentes si los hay
                    existingTempProducts: existingProducts,
                    existingOrderItemsCount:
                      existingItemsCount[editingOrderId!] || 0, // Usar el conteo rastreado
                    onProductsAdded: (newProducts) => {
                      // Actualizar productos temporales para esta orden
                      setTemporaryProducts((prev) => ({
                        ...prev,
                        [editingOrderId!]: newProducts,
                      }));
                      // NO establecer pendingProductsToAdd aqu√≠, se har√° en el useEffect
                      // Reabrir el modal cuando regresemos
                      setIsEditModalVisible(true);
                    },
                  });
                }, 100);
              }}
              onConfirmOrder={async (details: OrderDetailsForBackend) => {
                // Adaptar el formato de OrderDetailsForBackend a UpdateOrderPayload
                const payload = {
                  orderType: details.orderType,
                  items: details.items, // Enviar items para actualizar
                  tableId: details.tableId || null,
                  isTemporaryTable: details.isTemporaryTable || false,
                  temporaryTableName: details.temporaryTableName || null,
                  temporaryTableAreaId: details.temporaryTableAreaId || null,
                  scheduledAt: details.scheduledAt || null,
                  // Enviar null cuando deliveryInfo est√° vac√≠o para indicar limpieza
                  deliveryInfo: (() => {
                    if (!details.deliveryInfo) return null;

                    // Filtrar solo las propiedades que tienen valores reales (no undefined)
                    const filteredDeliveryInfo = Object.entries(
                      details.deliveryInfo,
                    )
                      .filter(([_, value]) => value !== undefined)
                      .reduce(
                        (acc, [key, value]) => ({ ...acc, [key]: value }),
                        {},
                      );

                    // Si no quedan propiedades con valores, enviar null
                    return Object.keys(filteredDeliveryInfo).length > 0
                      ? filteredDeliveryInfo
                      : null;
                  })(),
                  notes: details.notes || null,
                  total: details.total,
                  subtotal: details.subtotal,
                  adjustments: details.adjustments || [], // Incluir ajustes en el payload
                };

                try {
                  // Actualizar la orden (ahora incluye los ajustes)
                  await updateOrderMutation.mutateAsync({
                    orderId: editingOrderId,
                    payload,
                  });

                  // Limpiar estados despu√©s de actualizaci√≥n exitosa
                  setIsEditModalVisible(false);
                  setEditingOrderId(null);
                  // Limpiar productos temporales y conteo para esta orden
                  if (editingOrderId) {
                    setTemporaryProducts((prev) => {
                      const newState = { ...prev };
                      delete newState[editingOrderId];
                      return newState;
                    });
                    setExistingItemsCount((prev) => {
                      const newState = { ...prev };
                      delete newState[editingOrderId];
                      return newState;
                    });
                  }
                } catch (error) {
                  // No cerrar el modal en caso de error para que el usuario pueda reintentar
                }
              }}
              onCancelOrder={() => {
                if (editingOrderId) {
                  handleCancelOrder(editingOrderId);
                }
              }}
            />
        )}
      </Portal>
    </SafeAreaView>
  );
};

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
    loadingText: {
      marginTop: responsive.isTablet ? theme.spacing.s : theme.spacing.m,
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 14 : 16,
    },
    header: {
      paddingHorizontal: 0,
      paddingVertical: 0,
      backgroundColor: 'transparent',
      elevation: 0,
    },
    headerContent: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 0,
    },
    filterContainer: {
      flex: 1,
      flexDirection: 'row',
      gap: 0,
    },
    filterButton: {
      flex: 1,
      height: responsive.isTablet ? 44 : 52,
      justifyContent: 'center',
      alignItems: 'center',
      borderRadius: 0,
      elevation: 1,
      position: 'relative',
    },
    filterButtonActive: {
      elevation: 3,
    },
    countBadge: {
      position: 'absolute',
      top: responsive.isTablet ? 3 : 6,
      right: responsive.isTablet ? 3 : 6,
      minWidth: responsive.isTablet ? 18 : 22,
      height: responsive.isTablet ? 18 : 22,
      borderRadius: responsive.isTablet ? 9 : 11,
      justifyContent: 'center',
      alignItems: 'center',
      paddingHorizontal: responsive.isTablet ? 4 : 6,
      borderWidth: 1,
      elevation: 2,
    },
    countBadgeText: {
      fontSize: responsive.isTablet ? 10 : 12,
      fontWeight: '700',
    },
    listContainer: {
      flex: 1,
    },
    listContentContainer: {
      padding: responsive.isTablet ? theme.spacing.xs : theme.spacing.s,
      paddingBottom: responsive.isTablet
        ? theme.spacing.l
        : theme.spacing.l * 2,
    },
    orderCard: {
      marginBottom: responsive.isTablet ? 6 : 8,
    },
    cardContent: {
      paddingBottom: responsive.isTablet ? 6 : 8,
      paddingHorizontal: responsive.isTablet ? 12 : 16,
      paddingTop: responsive.isTablet ? 12 : 16,
    },
    mainContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
    },
    leftContainer: {
      flex: 1,
      paddingRight: responsive.isTablet ? 6 : 8,
    },
    rightContainer: {
      alignItems: 'flex-end',
      justifyContent: 'space-between',
      minWidth: responsive.isTablet ? 120 : 140,
      gap: responsive.isTablet ? 6 : 8,
    },
    actionsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'flex-end',
      gap: responsive.isTablet ? 2 : 4,
    },
    orderNumber: {
      fontSize: responsive.isTablet ? 14 : 16,
      fontWeight: 'bold',
      lineHeight: responsive.isTablet ? 20 : 22,
      marginBottom: responsive.isTablet ? 2 : 4,
    },
    orderPrice: {
      fontSize: responsive.isTablet ? 13 : 15,
      fontWeight: '700',
    },
    statusChip: {
      minHeight: responsive.isTablet ? 22 : 24,
      alignSelf: 'flex-end',
      paddingVertical: responsive.isTablet ? 1 : 2,
    },
    statusChipText: {
      fontSize: responsive.isTablet ? 11 : 12,
      fontWeight: '600',
      color: 'white',
      lineHeight: responsive.isTablet ? 13 : 14,
      marginVertical: 0,
      paddingVertical: 0,
    },
    paidChip: {
      height: responsive.isTablet ? 24 : 28,
      minHeight: responsive.isTablet ? 24 : 28,
      marginBottom: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    paidChipText: {
      fontSize: responsive.isTablet ? 11 : 12,
      fontWeight: '600',
      color: 'white',
      lineHeight: responsive.isTablet ? 14 : 16,
    },
    orderTime: {
      fontSize: responsive.isTablet ? 14 : 16,
      fontWeight: '600',
    },
    estimatedTime: {
      fontSize: responsive.isTablet ? 12 : 14,
      marginLeft: responsive.isTablet ? 3 : 4,
    },
    timeAndPaymentRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 0,
    },
    paymentBadge: {
      paddingHorizontal: responsive.isTablet ? 6 : 8,
      paddingVertical: responsive.isTablet ? 1 : 2,
      borderRadius: responsive.isTablet ? 10 : 12,
      alignItems: 'center',
      justifyContent: 'center',
    },
    paymentBadgeText: {
      fontSize: responsive.isTablet ? 10 : 11,
      fontWeight: '600',
      lineHeight: responsive.isTablet ? 12 : 14,
    },
    printButton: {
      margin: responsive.isTablet ? -6 : -4,
    },
    printContainer: {
      position: 'relative',
      alignItems: 'center',
      justifyContent: 'center',
    },
    printCountBadge: {
      position: 'absolute',
      top: 0,
      right: 0,
      backgroundColor: '#3B82F6',
      borderRadius: responsive.isTablet ? 8 : 10,
      minWidth: responsive.isTablet ? 18 : 20,
      height: responsive.isTablet ? 18 : 20,
      paddingHorizontal: responsive.isTablet ? 3 : 4,
      alignItems: 'center',
      justifyContent: 'center',
    },
    printCountText: {
      color: '#FFFFFF',
      fontSize: responsive.isTablet ? 9 : 10,
      fontWeight: 'bold',
    },
    customerInfo: {
      ...theme.fonts.bodyMedium,
      fontSize: responsive.isTablet ? 13 : 14,
      color: theme.colors.onSurfaceVariant,
      marginBottom: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    phoneInfo: {
      ...theme.fonts.bodySmall,
      fontSize: responsive.isTablet ? 11 : 12,
      color: theme.colors.onSurfaceVariant,
      marginBottom: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    notesInline: {
      fontSize: responsive.isTablet ? 11 : 12,
      fontStyle: 'italic',
    },
    inlinePreparationBadge: {
      paddingHorizontal: responsive.isTablet ? 4 : 6,
      paddingVertical: responsive.isTablet ? 1 : 2,
      borderRadius: responsive.isTablet ? 8 : 10,
      borderWidth: 0.5,
      marginLeft: responsive.isTablet ? 3 : 4,
    },
    inlinePreparationText: {
      fontSize: responsive.isTablet ? 9 : 10,
      fontWeight: '500',
    },
    miniPaymentBadge: {
      width: responsive.isTablet ? 18 : 20,
      height: responsive.isTablet ? 18 : 20,
      borderRadius: responsive.isTablet ? 9 : 10,
      alignItems: 'center',
      justifyContent: 'center',
      marginLeft: responsive.isTablet ? 4 : 6,
    },
    miniPaymentText: {
      fontSize: responsive.isTablet ? 9 : 10,
      fontWeight: 'bold',
      color: '#FFFFFF',
    },
    miniPreparationBadge: {
      width: responsive.isTablet ? 18 : 20,
      height: responsive.isTablet ? 18 : 20,
      borderRadius: responsive.isTablet ? 9 : 10,
      alignItems: 'center',
      justifyContent: 'center',
      marginLeft: responsive.isTablet ? 3 : 4,
    },
    miniPreparationText: {
      fontSize: responsive.isTablet ? 9 : 10,
      fontWeight: '600',
      color: '#FFFFFF',
    },
    moreIndicator: {
      fontSize: responsive.isTablet ? 9 : 10,
      color: theme.colors.onSurfaceVariant,
      marginLeft: responsive.isTablet ? 3 : 4,
    },
    createdByText: {
      fontSize: responsive.isTablet ? 9 : 10,
      color: theme.colors.onSurfaceVariant,
      marginBottom: responsive.isTablet ? 3 : 4,
      textAlign: 'right',
    },
    emptyStateContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.isTablet ? theme.spacing.m : theme.spacing.l,
    },
    emptyStateTitle: {
      marginTop: responsive.isTablet ? theme.spacing.m : theme.spacing.l,
      marginBottom: responsive.isTablet ? theme.spacing.s : theme.spacing.m,
      textAlign: 'center',
      color: theme.colors.onSurface,
      fontWeight: '600',
      fontSize: responsive.isTablet ? 20 : 24,
    },
    emptyStateText: {
      textAlign: 'center',
      color: theme.colors.onSurfaceVariant,
      maxWidth: responsive.isTablet ? 280 : 320,
      lineHeight: responsive.isTablet ? 20 : 24,
      fontSize: responsive.isTablet ? 14 : 16,
    },
    // Estilo adicional para eliminar inline style
    headerRefreshButton: {
      marginRight: 8,
    },
  });

export default OpenOrdersScreen;




================================================================
End of Codebase
================================================================
