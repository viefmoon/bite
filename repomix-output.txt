This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: app
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
app/.eslintignore
app/.eslintrc.js
app/.gitignore
app/.prettierrc
app/android/app/src/main/res/xml/network_security_config.xml
app/app.config.js
app/App.tsx
app/babel.config.js
app/docs/guides/BUILD_LOCAL_GUIDE.md
app/docs/guides/BUILD_QUICKSTART.md
app/docs/guides/EAS_PROJECT_SETUP_GUIDE.md
app/docs/guides/FIRST_UPLOAD_GUIDE.md
app/docs/guides/PLAY_STORE_PUBLISHING.md
app/eas.json
app/index.ts
app/ios/.gitignore
app/ios/.xcode.env
app/ios/pizza.xcodeproj/project.pbxproj
app/ios/pizza.xcodeproj/xcshareddata/xcschemes/pizza.xcscheme
app/ios/pizza/AppDelegate.swift
app/ios/pizza/Images.xcassets/AppIcon.appiconset/Contents.json
app/ios/pizza/Images.xcassets/Contents.json
app/ios/pizza/Images.xcassets/SplashScreenBackground.colorset/Contents.json
app/ios/pizza/Info.plist
app/ios/pizza/pizza-Bridging-Header.h
app/ios/pizza/pizza.entitlements
app/ios/pizza/SplashScreen.storyboard
app/ios/pizza/Supporting/Expo.plist
app/ios/Podfile
app/ios/Podfile.properties.json
app/metro.config.js
app/package.json
app/scripts/check-new-arch-compatibility.js
app/scripts/dev/reset-project.sh
app/scripts/install-android-sdk.sh
app/scripts/install-java.sh
app/scripts/release-to-playstore.sh
app/scripts/verify-android-setup.sh
app/src/app/components/common/AdaptiveModal.tsx
app/src/app/components/common/AnimatedLabelInput.tsx
app/src/app/components/common/AnimatedLabelSelector.tsx
app/src/app/components/common/AutoImage.tsx
app/src/app/components/common/ConfirmationModal.tsx
app/src/app/components/common/CustomImagePicker.tsx
app/src/app/components/common/EmptyState.tsx
app/src/app/components/common/GlobalSnackbar.tsx
app/src/app/components/common/PhoneNumberInput.tsx
app/src/app/components/common/SpeechRecognitionInput.tsx
app/src/app/components/ConnectionErrorModal.tsx
app/src/app/components/ConnectionIndicator.tsx
app/src/app/components/crud/GenericDetailModal.tsx
app/src/app/components/crud/GenericFormModal.tsx
app/src/app/components/crud/GenericList.tsx
app/src/app/components/DateTimePickerSafe.tsx
app/src/app/components/OrientationTransition.tsx
app/src/app/components/responsive/index.ts
app/src/app/components/responsive/ResponsiveGrid.tsx
app/src/app/components/responsive/ResponsiveImage.tsx
app/src/app/components/responsive/ResponsiveModal.tsx
app/src/app/components/responsive/ResponsiveView.tsx
app/src/app/components/ServerConfigModal.tsx
app/src/app/components/ShiftIndicator.tsx
app/src/app/constants/apiErrorCodes.ts
app/src/app/constants/apiPaths.ts
app/src/app/constants/navigationPaths.ts
app/src/app/constants/network.ts
app/src/app/constants/rolePermissions.ts
app/src/app/constants/storageKeys.ts
app/src/app/hooks/useCrudScreenLogic.ts
app/src/app/hooks/useGlobalShift.ts
app/src/app/hooks/useInitializeAuth.ts
app/src/app/hooks/useListState.ts
app/src/app/hooks/useRefreshOnFocus.ts
app/src/app/hooks/useResponsive.ts
app/src/app/hooks/useServerConnection.ts
app/src/app/lib/errorMapping.ts
app/src/app/lib/errors.ts
app/src/app/lib/formatters.ts
app/src/app/lib/IMAGE_CACHE_GUIDE.md
app/src/app/lib/imageCache.ts
app/src/app/lib/imageUploadService.ts
app/src/app/lib/imageUtils.ts
app/src/app/lib/zodResolver.ts
app/src/app/navigation/AppDrawerNavigator.tsx
app/src/app/navigation/AppNavigator.tsx
app/src/app/navigation/AuthStack.tsx
app/src/app/navigation/components/CustomDrawerContent.tsx
app/src/app/navigation/components/KitchenHeader.tsx
app/src/app/navigation/components/WebDrawer.tsx
app/src/app/navigation/components/WebDrawerContent.tsx
app/src/app/navigation/ConditionalAppNavigator.tsx
app/src/app/navigation/helpers/navigationHelpers.ts
app/src/app/navigation/KitchenOnlyNavigator.tsx
app/src/app/navigation/KitchenWebNavigator.tsx
app/src/app/navigation/options.ts
app/src/app/navigation/OrdersStackNavigator.tsx
app/src/app/navigation/types.ts
app/src/app/schemas/domain/adjustment.schema.ts
app/src/app/schemas/domain/area.schema.ts
app/src/app/schemas/domain/category.schema.ts
app/src/app/schemas/domain/delivery-info.schema.ts
app/src/app/schemas/domain/modifier-group.schema.ts
app/src/app/schemas/domain/modifier.schema.ts
app/src/app/schemas/domain/order.schema.ts
app/src/app/schemas/domain/photo.schema.ts
app/src/app/schemas/domain/preparation-screen.schema.ts
app/src/app/schemas/domain/product-variant.schema.ts
app/src/app/schemas/domain/product.schema.ts
app/src/app/schemas/domain/shift.schema.ts
app/src/app/schemas/domain/subcategory.schema.ts
app/src/app/schemas/domain/table.schema.ts
app/src/app/schemas/domain/user.schema.ts
app/src/app/services/apiClient.ts
app/src/app/services/certificateValidator.ts
app/src/app/services/discoveryService.ts
app/src/app/services/secureStorageService.ts
app/src/app/store/authStore.ts
app/src/app/store/snackbarStore.ts
app/src/app/store/themeStore.ts
app/src/app/styles/colors.ts
app/src/app/styles/responsive.ts
app/src/app/styles/theme.ts
app/src/app/styles/typography.ts
app/src/app/types/api.types.ts
app/src/app/types/query.types.ts
app/src/app/types/theme.types.ts
app/src/app/utils/dateTimeHelpers.ts
app/src/app/utils/roleUtils.ts
app/src/app/utils/tokenVerification.ts
app/src/components/AudioOrderModal.tsx
app/src/components/AudioRecorderWidget.tsx
app/src/components/index.ts
app/src/hooks/useAudioRecorder.ts
app/src/hooks/useGoogleMapsConfig.ts
app/src/hooks/useSnackbar.ts
app/src/modules/areasTables/components/AreaFormModal.tsx
app/src/modules/areasTables/components/TableFormModal.tsx
app/src/modules/areasTables/hooks/useAreasQueries.ts
app/src/modules/areasTables/hooks/useTablesQueries.ts
app/src/modules/areasTables/navigation/AreasTablesStackNavigator.tsx
app/src/modules/areasTables/navigation/types.ts
app/src/modules/areasTables/schema/area.schema.ts
app/src/modules/areasTables/schema/table.schema.ts
app/src/modules/areasTables/screens/AreasScreen.tsx
app/src/modules/areasTables/screens/TablesScreen.tsx
app/src/modules/areasTables/services/areaService.ts
app/src/modules/areasTables/services/tableService.ts
app/src/modules/auth/components/LoginForm.tsx
app/src/modules/auth/components/RegisterForm.tsx
app/src/modules/auth/schema/auth.schema.ts
app/src/modules/auth/screens/LoginScreen.tsx
app/src/modules/auth/services/authService.ts
app/src/modules/availability/components/AvailabilityListItem.tsx
app/src/modules/availability/components/CategoryAvailabilityItem.tsx
app/src/modules/availability/components/ModifierGroupAvailabilityItem.tsx
app/src/modules/availability/components/PizzaCustomizationAvailabilityItem.tsx
app/src/modules/availability/hooks/useAvailabilityQueries.ts
app/src/modules/availability/hooks/useOptimisticAvailability.ts
app/src/modules/availability/hooks/usePizzaCustomizationsAvailability.ts
app/src/modules/availability/schema/availability.schema.ts
app/src/modules/availability/screens/AvailabilityScreen.tsx
app/src/modules/availability/services/availabilityService.ts
app/src/modules/customers/components/AddressFormModal.tsx
app/src/modules/customers/components/CustomerFormModal.tsx
app/src/modules/customers/components/LocationPicker.tsx
app/src/modules/customers/constants/maps.config.ts
app/src/modules/customers/hooks/useCustomersQueries.ts
app/src/modules/customers/index.ts
app/src/modules/customers/navigation/CustomersStackNavigator.tsx
app/src/modules/customers/schema/customer.schema.ts
app/src/modules/customers/screens/CustomersScreen.tsx
app/src/modules/customers/services/addressesService.ts
app/src/modules/customers/services/customersService.ts
app/src/modules/kitchen/components/KitchenFilterButton.tsx
app/src/modules/kitchen/components/OrderCard.tsx
app/src/modules/kitchen/components/OrderItemRow.tsx
app/src/modules/kitchen/components/RefreshButton.tsx
app/src/modules/kitchen/context/KitchenContext.tsx
app/src/modules/kitchen/hooks/useKitchenOrders.ts
app/src/modules/kitchen/hooks/useKitchenSnackbar.ts
app/src/modules/kitchen/schema/kitchen.schema.ts
app/src/modules/kitchen/screens/KitchenOrdersScreen.tsx
app/src/modules/kitchen/services/kitchenService.ts
app/src/modules/kitchen/store/kitchenStore.ts
app/src/modules/menu/components/ProductFormModal.tsx
app/src/modules/menu/components/VariantFormModal.tsx
app/src/modules/menu/hooks/useProductsQueries.ts
app/src/modules/menu/hooks/useSubcategoriesQueries.ts
app/src/modules/menu/navigation/MenuStackNavigator.tsx
app/src/modules/menu/navigation/types.ts
app/src/modules/menu/schema/category.schema.ts
app/src/modules/menu/schema/products.schema.ts
app/src/modules/menu/schema/subcategories.schema.ts
app/src/modules/menu/screens/CategoriesScreen.tsx
app/src/modules/menu/screens/ProductsScreen.tsx
app/src/modules/menu/screens/SubcategoriesScreen.tsx
app/src/modules/menu/services/categoryService.ts
app/src/modules/menu/services/fileService.ts
app/src/modules/menu/services/productsService.ts
app/src/modules/menu/services/subcategoriesService.ts
app/src/modules/modifiers/components/ModifierFormModal.tsx
app/src/modules/modifiers/components/ModifierGroupFormModal.tsx
app/src/modules/modifiers/hooks/useModifierGroupsQuery.ts
app/src/modules/modifiers/navigation/ModifiersStackNavigator.tsx
app/src/modules/modifiers/schema/modifier.schema.ts
app/src/modules/modifiers/schema/modifierGroup.schema.ts
app/src/modules/modifiers/screens/ModifierGroupsScreen.tsx
app/src/modules/modifiers/screens/ModifiersScreen.tsx
app/src/modules/modifiers/services/modifierGroupService.ts
app/src/modules/modifiers/services/modifierService.ts
app/src/modules/orderFinalization/components/OrderCard.tsx
app/src/modules/orderFinalization/components/OrderDetailsModal.tsx
app/src/modules/orderFinalization/hooks/useOrderFinalizationQueries.ts
app/src/modules/orderFinalization/navigation/OrderFinalizationStackNavigator.tsx
app/src/modules/orderFinalization/navigation/types.ts
app/src/modules/orderFinalization/schema/orderFinalization.schema.ts
app/src/modules/orderFinalization/screens/OrderFinalizationScreen.tsx
app/src/modules/orderFinalization/services/orderFinalizationService.ts
app/src/modules/orders/components/AdjustmentFormModal.tsx
app/src/modules/orders/components/CartButton.tsx
app/src/modules/orders/components/ChangeCalculatorModal.tsx
app/src/modules/orders/components/MenuItemCard.tsx
app/src/modules/orders/components/order-cart/DeliveryForm.tsx
app/src/modules/orders/components/order-cart/DineInForm.tsx
app/src/modules/orders/components/order-cart/index.ts
app/src/modules/orders/components/order-cart/ModalsContainer.tsx
app/src/modules/orders/components/order-cart/OrderAdjustments.tsx
app/src/modules/orders/components/order-cart/OrderItemsList.tsx
app/src/modules/orders/components/order-cart/OrderSummary.tsx
app/src/modules/orders/components/order-cart/OrderTypeSelector.tsx
app/src/modules/orders/components/order-cart/PrepaymentSection.tsx
app/src/modules/orders/components/order-cart/TakeAwayForm.tsx
app/src/modules/orders/components/order-creation/CategoryGrid.tsx
app/src/modules/orders/components/order-creation/CategoryQuickAccess.tsx
app/src/modules/orders/components/order-creation/index.ts
app/src/modules/orders/components/order-creation/ShiftClosedView.tsx
app/src/modules/orders/components/OrderCartDetail.tsx
app/src/modules/orders/components/OrderDetailModal.tsx
app/src/modules/orders/components/OrderHeader.tsx
app/src/modules/orders/components/PaymentModal.tsx
app/src/modules/orders/components/PizzaCustomizationSection.tsx
app/src/modules/orders/components/PrinterSelectionModal.tsx
app/src/modules/orders/components/ProductCustomizationModal.tsx
app/src/modules/orders/components/ShiftActionModal.tsx
app/src/modules/orders/components/ShiftStatusBanner.tsx
app/src/modules/orders/components/ShiftStatusModal.tsx
app/src/modules/orders/components/SimpleProductDescriptionModal.tsx
app/src/modules/orders/hooks/order-cart/useOrderTypeLogic.ts
app/src/modules/orders/hooks/order-creation/index.ts
app/src/modules/orders/hooks/order-creation/useAudioOrder.ts
app/src/modules/orders/hooks/order-creation/useOrderCreation.ts
app/src/modules/orders/hooks/order-creation/useOrderNavigation.ts
app/src/modules/orders/hooks/order-creation/useProductSelection.ts
app/src/modules/orders/hooks/useAdjustmentQueries.ts
app/src/modules/orders/hooks/useMenuQueries.ts
app/src/modules/orders/hooks/useOrderCalculations.ts
app/src/modules/orders/hooks/useOrderDataLoader.ts
app/src/modules/orders/hooks/useOrdersQueries.ts
app/src/modules/orders/hooks/useOrderState.ts
app/src/modules/orders/hooks/useOrderType.ts
app/src/modules/orders/hooks/useOrderValidation.ts
app/src/modules/orders/hooks/usePaymentQueries.ts
app/src/modules/orders/hooks/usePrepayment.ts
app/src/modules/orders/hooks/useProductValidation.ts
app/src/modules/orders/schema/adjustments.schema.ts
app/src/modules/orders/schema/orders.schema.ts
app/src/modules/orders/schema/payment.schema.ts
app/src/modules/orders/schema/update-order.schema.ts
app/src/modules/orders/screens/AddProductsToOrderScreen.tsx
app/src/modules/orders/screens/CreateOrderScreen.tsx
app/src/modules/orders/screens/OpenOrdersScreen.tsx
app/src/modules/orders/screens/OrdersScreen.tsx
app/src/modules/orders/services/adjustmentService.ts
app/src/modules/orders/services/orderPrintService.ts
app/src/modules/orders/services/orderService.ts
app/src/modules/orders/services/paymentService.ts
app/src/modules/orders/stores/useModalStore.ts
app/src/modules/orders/stores/useOrderStore.ts
app/src/modules/orders/utils/formatters.ts
app/src/modules/payments/services/prepaymentService.ts
app/src/modules/pizzaCustomizations/components/AssociatePizzaToppingsModal.tsx
app/src/modules/pizzaCustomizations/components/index.ts
app/src/modules/pizzaCustomizations/components/PizzaConfigurationModal.tsx
app/src/modules/pizzaCustomizations/components/PizzaCustomizationCard.tsx
app/src/modules/pizzaCustomizations/components/PizzaCustomizationDetailModal.tsx
app/src/modules/pizzaCustomizations/components/PizzaCustomizationFormModal.tsx
app/src/modules/pizzaCustomizations/components/PizzaCustomizationsTab.tsx
app/src/modules/pizzaCustomizations/components/PizzaProductsTab.tsx
app/src/modules/pizzaCustomizations/hooks/usePizzaCustomizationsQueries.ts
app/src/modules/pizzaCustomizations/navigation/PizzaCustomizationsStackNavigator.tsx
app/src/modules/pizzaCustomizations/navigation/types.ts
app/src/modules/pizzaCustomizations/schema/pizzaConfiguration.schema.ts
app/src/modules/pizzaCustomizations/schema/pizzaCustomization.schema.ts
app/src/modules/pizzaCustomizations/screens/PizzaManagementScreen.tsx
app/src/modules/pizzaCustomizations/services/pizzaConfigurationsService.ts
app/src/modules/pizzaCustomizations/services/pizzaCustomizationsService.ts
app/src/modules/preparationScreens/components/PreparationScreenDetailModalSimple.tsx
app/src/modules/preparationScreens/components/PreparationScreenFormModal.tsx
app/src/modules/preparationScreens/components/PreparationScreenListItem.tsx
app/src/modules/preparationScreens/components/ProductSelectionModal.tsx
app/src/modules/preparationScreens/hooks/usePreparationScreensQueries.ts
app/src/modules/preparationScreens/navigation/PreparationScreensStackNavigator.tsx
app/src/modules/preparationScreens/navigation/types.ts
app/src/modules/preparationScreens/schema/preparationScreen.schema.ts
app/src/modules/preparationScreens/screens/PreparationScreensScreen.tsx
app/src/modules/preparationScreens/services/preparationScreenService.ts
app/src/modules/printers/components/NumericField.tsx
app/src/modules/printers/components/PrinterAdvancedConfig.tsx
app/src/modules/printers/components/PrinterDetailModal.tsx
app/src/modules/printers/components/PrinterDiscoveryModal.tsx
app/src/modules/printers/components/PrinterFormModal.tsx
app/src/modules/printers/components/PrinterListItem.tsx
app/src/modules/printers/hooks/usePrintersQueries.ts
app/src/modules/printers/navigation/PrintersStackNavigator.tsx
app/src/modules/printers/navigation/types.ts
app/src/modules/printers/schema/printer.schema.ts
app/src/modules/printers/screens/PrintersScreen.tsx
app/src/modules/printers/services/printerService.ts
app/src/modules/printers/types/printer.types.ts
app/src/modules/receipts/components/ReceiptDetailsModal.tsx
app/src/modules/receipts/hooks/useReceiptsQueries.ts
app/src/modules/receipts/navigation/ReceiptsStackNavigator.tsx
app/src/modules/receipts/navigation/types.ts
app/src/modules/receipts/schema/receipt.schema.ts
app/src/modules/receipts/screens/ReceiptsScreen.tsx
app/src/modules/receipts/services/receiptService.ts
app/src/modules/restaurantConfig/components/BusinessHoursForm.tsx
app/src/modules/restaurantConfig/components/TimeZoneSelector.tsx
app/src/modules/restaurantConfig/components/WebViewDeliveryCoverageMap.tsx
app/src/modules/restaurantConfig/hooks/useRestaurantConfigQueries.ts
app/src/modules/restaurantConfig/navigation/RestaurantConfigStackNavigator.tsx
app/src/modules/restaurantConfig/navigation/types.ts
app/src/modules/restaurantConfig/schema/restaurantConfig.schema.ts
app/src/modules/restaurantConfig/screens/RestaurantConfigScreen.tsx
app/src/modules/restaurantConfig/services/restaurantConfigService.ts
app/src/modules/settings/navigation/SettingsStackNavigator.tsx
app/src/modules/settings/navigation/types.ts
app/src/modules/settings/screens/ServerSettingsScreen.tsx
app/src/modules/shared/components/OrderHistoryModal.tsx
app/src/modules/shared/components/OrderSummaryCard.tsx
app/src/modules/shared/components/PrintTicketModal.tsx
app/src/modules/shiftAudit/components/BatchOperationsSection.tsx
app/src/modules/shiftAudit/components/ChangeDetailRenderer.tsx
app/src/modules/shiftAudit/components/HistoryItemComponent.tsx
app/src/modules/shiftAudit/components/index.ts
app/src/modules/shiftAudit/components/OrderDetailsSection.tsx
app/src/modules/shiftAudit/components/OrderDetailsView.tsx
app/src/modules/shiftAudit/components/OrderHistoryView.tsx
app/src/modules/shiftAudit/components/ProductItemRenderer.tsx
app/src/modules/shiftAudit/components/ShiftOrdersModal.tsx
app/src/modules/shiftAudit/components/ShiftSalesSummaryView.tsx
app/src/modules/shiftAudit/hooks/useShiftOrders.ts
app/src/modules/shiftAudit/hooks/useShifts.ts
app/src/modules/shiftAudit/hooks/useShiftSalesSummary.ts
app/src/modules/shiftAudit/navigation/ShiftAuditStackNavigator.tsx
app/src/modules/shiftAudit/navigation/types.ts
app/src/modules/shiftAudit/screens/ShiftsListScreen.tsx
app/src/modules/shiftAudit/styles/orderHistoryStyles.ts
app/src/modules/shiftAudit/types/index.ts
app/src/modules/shiftAudit/types/orderHistory.ts
app/src/modules/shiftAudit/utils/orderHistoryUtils.ts
app/src/modules/sync/navigation/SyncStackNavigator.tsx
app/src/modules/sync/schema/sync.schema.ts
app/src/modules/sync/screens/SyncStatusScreen.tsx
app/src/modules/sync/services/syncService.ts
app/src/modules/users/components/index.ts
app/src/modules/users/components/UserDetailModal.tsx
app/src/modules/users/components/UserFormModal.tsx
app/src/modules/users/hooks/useUsers.ts
app/src/modules/users/schema/user.schema.ts
app/src/modules/users/screens/UsersListScreen.tsx
app/src/modules/users/services/usersApi.service.ts
app/src/services/appConfig.ts
app/src/services/audioOrderService.ts
app/src/services/audioServiceHealth.ts
app/src/services/autoReconnectService.ts
app/src/services/healthMonitoringService.ts
app/src/services/reconnectionSnackbarService.ts
app/src/services/serverConnectionService.ts
app/src/services/shifts.ts
app/tsconfig.json

================================================================
Files
================================================================

================
File: app/.eslintignore
================
node_modules/
android/
ios/
.expo/
dist/
build/
coverage/
*.config.js
*.config.ts
babel.config.js
metro.config.js
.eslintrc.js
fix-*.js
fix-*.sh
scripts/

================
File: app/ios/.gitignore
================
# OSX
#
.DS_Store

# Xcode
#
build/
*.pbxuser
!default.pbxuser
*.mode1v3
!default.mode1v3
*.mode2v3
!default.mode2v3
*.perspectivev3
!default.perspectivev3
xcuserdata
*.xccheckout
*.moved-aside
DerivedData
*.hmap
*.ipa
*.xcuserstate
project.xcworkspace
.xcode.env.local

# Bundle artifacts
*.jsbundle

# CocoaPods
/Pods/

================
File: app/ios/.xcode.env
================
# This `.xcode.env` file is versioned and is used to source the environment
# used when running script phases inside Xcode.
# To customize your local environment, you can create an `.xcode.env.local`
# file that is not versioned.

# NODE_BINARY variable contains the PATH to the node executable.
#
# Customize the NODE_BINARY variable here.
# For example, to use nvm with brew, add the following line
# . "$(brew --prefix nvm)/nvm.sh" --no-use
export NODE_BINARY=$(command -v node)

================
File: app/ios/pizza.xcodeproj/project.pbxproj
================
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 54;
	objects = {

/* Begin PBXBuildFile section */
		13B07FBF1A68108700A75B9A /* Images.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 13B07FB51A68108700A75B9A /* Images.xcassets */; };
		3E461D99554A48A4959DE609 /* SplashScreen.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = AA286B85B6C04FC6940260E9 /* SplashScreen.storyboard */; };
		BB2F792D24A3F905000567C9 /* Expo.plist in Resources */ = {isa = PBXBuildFile; fileRef = BB2F792C24A3F905000567C9 /* Expo.plist */; };
		F11748422D0307B40044C1D9 /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = F11748412D0307B40044C1D9 /* AppDelegate.swift */; };
/* End PBXBuildFile section */

/* Begin PBXFileReference section */
		13B07F961A680F5B00A75B9A /* pizza.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = pizza.app; sourceTree = BUILT_PRODUCTS_DIR; };
		13B07FB51A68108700A75B9A /* Images.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; name = Images.xcassets; path = pizza/Images.xcassets; sourceTree = "<group>"; };
		13B07FB61A68108700A75B9A /* Info.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; name = Info.plist; path = pizza/Info.plist; sourceTree = "<group>"; };
		AA286B85B6C04FC6940260E9 /* SplashScreen.storyboard */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = file.storyboard; name = SplashScreen.storyboard; path = pizza/SplashScreen.storyboard; sourceTree = "<group>"; };
		BB2F792C24A3F905000567C9 /* Expo.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; path = Expo.plist; sourceTree = "<group>"; };
		ED297162215061F000B7C4FE /* JavaScriptCore.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = JavaScriptCore.framework; path = System/Library/Frameworks/JavaScriptCore.framework; sourceTree = SDKROOT; };
		F11748412D0307B40044C1D9 /* AppDelegate.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; name = AppDelegate.swift; path = pizza/AppDelegate.swift; sourceTree = "<group>"; };
		F11748442D0722820044C1D9 /* pizza-Bridging-Header.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = "pizza-Bridging-Header.h"; path = "pizza/pizza-Bridging-Header.h"; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		13B07F8C1A680F5B00A75B9A /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		13B07FAE1A68108700A75B9A /* pizza */ = {
			isa = PBXGroup;
			children = (
				F11748412D0307B40044C1D9 /* AppDelegate.swift */,
				F11748442D0722820044C1D9 /* pizza-Bridging-Header.h */,
				BB2F792B24A3F905000567C9 /* Supporting */,
				13B07FB51A68108700A75B9A /* Images.xcassets */,
				13B07FB61A68108700A75B9A /* Info.plist */,
				AA286B85B6C04FC6940260E9 /* SplashScreen.storyboard */,
			);
			name = pizza;
			sourceTree = "<group>";
		};
		2D16E6871FA4F8E400B85C8A /* Frameworks */ = {
			isa = PBXGroup;
			children = (
				ED297162215061F000B7C4FE /* JavaScriptCore.framework */,
			);
			name = Frameworks;
			sourceTree = "<group>";
		};
		832341AE1AAA6A7D00B99B32 /* Libraries */ = {
			isa = PBXGroup;
			children = (
			);
			name = Libraries;
			sourceTree = "<group>";
		};
		83CBB9F61A601CBA00E9B192 = {
			isa = PBXGroup;
			children = (
				13B07FAE1A68108700A75B9A /* pizza */,
				832341AE1AAA6A7D00B99B32 /* Libraries */,
				83CBBA001A601CBA00E9B192 /* Products */,
				2D16E6871FA4F8E400B85C8A /* Frameworks */,
			);
			indentWidth = 2;
			sourceTree = "<group>";
			tabWidth = 2;
			usesTabs = 0;
		};
		83CBBA001A601CBA00E9B192 /* Products */ = {
			isa = PBXGroup;
			children = (
				13B07F961A680F5B00A75B9A /* pizza.app */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		BB2F792B24A3F905000567C9 /* Supporting */ = {
			isa = PBXGroup;
			children = (
				BB2F792C24A3F905000567C9 /* Expo.plist */,
			);
			name = Supporting;
			path = pizza/Supporting;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		13B07F861A680F5B00A75B9A /* pizza */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 13B07F931A680F5B00A75B9A /* Build configuration list for PBXNativeTarget "pizza" */;
			buildPhases = (
				08A4A3CD28434E44B6B9DE2E /* [CP] Check Pods Manifest.lock */,
				13B07F871A680F5B00A75B9A /* Sources */,
				13B07F8C1A680F5B00A75B9A /* Frameworks */,
				13B07F8E1A680F5B00A75B9A /* Resources */,
				00DD1BFF1BD5951E006B06BC /* Bundle React Native code and images */,
				800E24972A6A228C8D4807E9 /* [CP] Copy Pods Resources */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = pizza;
			productName = pizza;
			productReference = 13B07F961A680F5B00A75B9A /* pizza.app */;
			productType = "com.apple.product-type.application";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		83CBB9F71A601CBA00E9B192 /* Project object */ = {
			isa = PBXProject;
			attributes = {
				LastUpgradeCheck = 1130;
				TargetAttributes = {
					13B07F861A680F5B00A75B9A = {
						LastSwiftMigration = 1250;
					};
				};
			};
			buildConfigurationList = 83CBB9FA1A601CBA00E9B192 /* Build configuration list for PBXProject "pizza" */;
			compatibilityVersion = "Xcode 3.2";
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = 83CBB9F61A601CBA00E9B192;
			productRefGroup = 83CBBA001A601CBA00E9B192 /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				13B07F861A680F5B00A75B9A /* pizza */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		13B07F8E1A680F5B00A75B9A /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				BB2F792D24A3F905000567C9 /* Expo.plist in Resources */,
				13B07FBF1A68108700A75B9A /* Images.xcassets in Resources */,
				3E461D99554A48A4959DE609 /* SplashScreen.storyboard in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXShellScriptBuildPhase section */
		00DD1BFF1BD5951E006B06BC /* Bundle React Native code and images */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputPaths = (
			);
			name = "Bundle React Native code and images";
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "if [[ -f \"$PODS_ROOT/../.xcode.env\" ]]; then\n  source \"$PODS_ROOT/../.xcode.env\"\nfi\nif [[ -f \"$PODS_ROOT/../.xcode.env.local\" ]]; then\n  source \"$PODS_ROOT/../.xcode.env.local\"\nfi\n\n# The project root by default is one level up from the ios directory\nexport PROJECT_ROOT=\"$PROJECT_DIR\"/..\n\nif [[ \"$CONFIGURATION\" = *Debug* ]]; then\n  export SKIP_BUNDLING=1\nfi\nif [[ -z \"$ENTRY_FILE\" ]]; then\n  # Set the entry JS file using the bundler's entry resolution.\n  export ENTRY_FILE=\"$(\"$NODE_BINARY\" -e \"require('expo/scripts/resolveAppEntry')\" \"$PROJECT_ROOT\" ios absolute | tail -n 1)\"\nfi\n\nif [[ -z \"$CLI_PATH\" ]]; then\n  # Use Expo CLI\n  export CLI_PATH=\"$(\"$NODE_BINARY\" --print \"require.resolve('@expo/cli', { paths: [require.resolve('expo/package.json')] })\")\"\nfi\nif [[ -z \"$BUNDLE_COMMAND\" ]]; then\n  # Default Expo CLI command for bundling\n  export BUNDLE_COMMAND=\"export:embed\"\nfi\n\n# Source .xcode.env.updates if it exists to allow\n# SKIP_BUNDLING to be unset if needed\nif [[ -f \"$PODS_ROOT/../.xcode.env.updates\" ]]; then\n  source \"$PODS_ROOT/../.xcode.env.updates\"\nfi\n# Source local changes to allow overrides\n# if needed\nif [[ -f \"$PODS_ROOT/../.xcode.env.local\" ]]; then\n  source \"$PODS_ROOT/../.xcode.env.local\"\nfi\n\n`\"$NODE_BINARY\" --print \"require('path').dirname(require.resolve('react-native/package.json')) + '/scripts/react-native-xcode.sh'\"`\n\n";
		};
		08A4A3CD28434E44B6B9DE2E /* [CP] Check Pods Manifest.lock */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
				"${PODS_PODFILE_DIR_PATH}/Podfile.lock",
				"${PODS_ROOT}/Manifest.lock",
			);
			name = "[CP] Check Pods Manifest.lock";
			outputFileListPaths = (
			);
			outputPaths = (
				"$(DERIVED_FILE_DIR)/Pods-pizza-checkManifestLockResult.txt",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "diff \"${PODS_PODFILE_DIR_PATH}/Podfile.lock\" \"${PODS_ROOT}/Manifest.lock\" > /dev/null\nif [ $? != 0 ] ; then\n    # print error to STDERR\n    echo \"error: The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation.\" >&2\n    exit 1\nfi\n# This output is used by Xcode 'outputs' to avoid re-running this script phase.\necho \"SUCCESS\" > \"${SCRIPT_OUTPUT_FILE_0}\"\n";
			showEnvVarsInLog = 0;
		};
		800E24972A6A228C8D4807E9 /* [CP] Copy Pods Resources */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputPaths = (
				"${PODS_ROOT}/Target Support Files/Pods-pizza/Pods-pizza-resources.sh",
				"${PODS_CONFIGURATION_BUILD_DIR}/EXConstants/EXConstants.bundle",
				"${PODS_CONFIGURATION_BUILD_DIR}/EXUpdates/EXUpdates.bundle",
				"${PODS_CONFIGURATION_BUILD_DIR}/React-Core/RCTI18nStrings.bundle",
			);
			name = "[CP] Copy Pods Resources";
			outputPaths = (
				"${TARGET_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/EXConstants.bundle",
				"${TARGET_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/EXUpdates.bundle",
				"${TARGET_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/RCTI18nStrings.bundle",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "\"${PODS_ROOT}/Target Support Files/Pods-pizza/Pods-pizza-resources.sh\"\n";
			showEnvVarsInLog = 0;
		};
/* End PBXShellScriptBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		13B07F871A680F5B00A75B9A /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				F11748422D0307B40044C1D9 /* AppDelegate.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin XCBuildConfiguration section */
		13B07F941A680F5B00A75B9A /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = 1;
				ENABLE_BITCODE = NO;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"$(inherited)",
					"FB_SONARKIT_ENABLED=1",
				);
				INFOPLIST_FILE = pizza/Info.plist;
				IPHONEOS_DEPLOYMENT_TARGET = 15.1;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				OTHER_LDFLAGS = (
					"$(inherited)",
					"-ObjC",
					"-lc++",
				);
				PRODUCT_BUNDLE_IDENTIFIER = "com.viefmoon.pizza";
				PRODUCT_NAME = "pizza";
				SWIFT_OBJC_BRIDGING_HEADER = "pizza/pizza-Bridging-Header.h";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
				TARGETED_DEVICE_FAMILY = "1";
				CODE_SIGN_ENTITLEMENTS = pizza/pizza.entitlements;
			};
			name = Debug;
		};
		13B07F951A680F5B00A75B9A /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = 1;
				INFOPLIST_FILE = pizza/Info.plist;
				IPHONEOS_DEPLOYMENT_TARGET = 15.1;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				OTHER_LDFLAGS = (
					"$(inherited)",
					"-ObjC",
					"-lc++",
				);
				PRODUCT_BUNDLE_IDENTIFIER = "com.viefmoon.pizza";
				PRODUCT_NAME = "pizza";
				SWIFT_OBJC_BRIDGING_HEADER = "pizza/pizza-Bridging-Header.h";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
				TARGETED_DEVICE_FAMILY = "1";
				CODE_SIGN_ENTITLEMENTS = pizza/pizza.entitlements;
			};
			name = Release;
		};
		83CBBA201A601CBA00E9B192 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CLANG_ANALYZER_LOCALIZABILITY_NONLOCALIZED = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "c++20";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_SYMBOLS_PRIVATE_EXTERN = NO;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 15.1;
				LD_RUNPATH_SEARCH_PATHS = (
					/usr/lib/swift,
					"$(inherited)",
				);
				LIBRARY_SEARCH_PATHS = "\"$(inherited)\"";
				MTL_ENABLE_DEBUG_INFO = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = iphoneos;
			};
			name = Debug;
		};
		83CBBA211A601CBA00E9B192 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CLANG_ANALYZER_LOCALIZABILITY_NONLOCALIZED = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "c++20";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = YES;
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 15.1;
				LD_RUNPATH_SEARCH_PATHS = (
					/usr/lib/swift,
					"$(inherited)",
				);
				LIBRARY_SEARCH_PATHS = "\"$(inherited)\"";
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = iphoneos;
				VALIDATE_PRODUCT = YES;
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		13B07F931A680F5B00A75B9A /* Build configuration list for PBXNativeTarget "pizza" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				13B07F941A680F5B00A75B9A /* Debug */,
				13B07F951A680F5B00A75B9A /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		83CBB9FA1A601CBA00E9B192 /* Build configuration list for PBXProject "pizza" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				83CBBA201A601CBA00E9B192 /* Debug */,
				83CBBA211A601CBA00E9B192 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = 83CBB9F71A601CBA00E9B192 /* Project object */;
}

================
File: app/ios/pizza.xcodeproj/xcshareddata/xcschemes/pizza.xcscheme
================
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "1130"
   version = "1.3">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "13B07F861A680F5B00A75B9A"
               BuildableName = "pizza.app"
               BlueprintName = "pizza"
               ReferencedContainer = "container:pizza.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES">
      <Testables>
         <TestableReference
            skipped = "NO">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "00E356ED1AD99517003FC87E"
               BuildableName = "pizzaTests.xctest"
               BlueprintName = "pizzaTests"
               ReferencedContainer = "container:pizza.xcodeproj">
            </BuildableReference>
         </TestableReference>
      </Testables>
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "13B07F861A680F5B00A75B9A"
            BuildableName = "pizza.app"
            BlueprintName = "pizza"
            ReferencedContainer = "container:pizza.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Release"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "13B07F861A680F5B00A75B9A"
            BuildableName = "pizza.app"
            BlueprintName = "pizza"
            ReferencedContainer = "container:pizza.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>

================
File: app/ios/pizza/AppDelegate.swift
================
import Expo
import React
import ReactAppDependencyProvider

@UIApplicationMain
public class AppDelegate: ExpoAppDelegate {
  var window: UIWindow?

  var reactNativeDelegate: ExpoReactNativeFactoryDelegate?
  var reactNativeFactory: RCTReactNativeFactory?

  public override func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? = nil
  ) -> Bool {
    let delegate = ReactNativeDelegate()
    let factory = ExpoReactNativeFactory(delegate: delegate)
    delegate.dependencyProvider = RCTAppDependencyProvider()

    reactNativeDelegate = delegate
    reactNativeFactory = factory
    bindReactNativeFactory(factory)

#if os(iOS) || os(tvOS)
    window = UIWindow(frame: UIScreen.main.bounds)
    factory.startReactNative(
      withModuleName: "main",
      in: window,
      launchOptions: launchOptions)
#endif

    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }

  // Linking API
  public override func application(
    _ app: UIApplication,
    open url: URL,
    options: [UIApplication.OpenURLOptionsKey: Any] = [:]
  ) -> Bool {
    return super.application(app, open: url, options: options) || RCTLinkingManager.application(app, open: url, options: options)
  }

  // Universal Links
  public override func application(
    _ application: UIApplication,
    continue userActivity: NSUserActivity,
    restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void
  ) -> Bool {
    let result = RCTLinkingManager.application(application, continue: userActivity, restorationHandler: restorationHandler)
    return super.application(application, continue: userActivity, restorationHandler: restorationHandler) || result
  }
}

class ReactNativeDelegate: ExpoReactNativeFactoryDelegate {
  // Extension point for config-plugins

  override func sourceURL(for bridge: RCTBridge) -> URL? {
    // needed to return the correct URL for expo-dev-client.
    bridge.bundleURL ?? bundleURL()
  }

  override func bundleURL() -> URL? {
#if DEBUG
    return RCTBundleURLProvider.sharedSettings().jsBundleURL(forBundleRoot: ".expo/.virtual-metro-entry")
#else
    return Bundle.main.url(forResource: "main", withExtension: "jsbundle")
#endif
  }
}

================
File: app/ios/pizza/Info.plist
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
  <dict>
    <key>CADisableMinimumFrameDurationOnPhone</key>
    <true/>
    <key>CFBundleDevelopmentRegion</key>
    <string>$(DEVELOPMENT_LANGUAGE)</string>
    <key>CFBundleDisplayName</key>
    <string>CloudBite</string>
    <key>CFBundleExecutable</key>
    <string>$(EXECUTABLE_NAME)</string>
    <key>CFBundleIdentifier</key>
    <string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
    <key>CFBundleInfoDictionaryVersion</key>
    <string>6.0</string>
    <key>CFBundleName</key>
    <string>$(PRODUCT_NAME)</string>
    <key>CFBundlePackageType</key>
    <string>$(PRODUCT_BUNDLE_PACKAGE_TYPE)</string>
    <key>CFBundleShortVersionString</key>
    <string>1.0.0</string>
    <key>CFBundleSignature</key>
    <string>????</string>
    <key>CFBundleURLTypes</key>
    <array>
      <dict>
        <key>CFBundleURLSchemes</key>
        <array>
          <string>com.viefmoon.cloudbite</string>
        </array>
      </dict>
      <dict>
        <key>CFBundleURLSchemes</key>
        <array>
          <string>exp+cloudbite</string>
        </array>
      </dict>
    </array>
    <key>CFBundleVersion</key>
    <string>1</string>
    <key>LSMinimumSystemVersion</key>
    <string>12.0</string>
    <key>LSRequiresIPhoneOS</key>
    <true/>
    <key>NSAppTransportSecurity</key>
    <dict>
      <key>NSAllowsArbitraryLoads</key>
      <false/>
      <key>NSAllowsLocalNetworking</key>
      <true/>
    </dict>
    <key>NSCameraUsageDescription</key>
    <string>Allow $(PRODUCT_NAME) to access your camera</string>
    <key>NSMicrophoneUsageDescription</key>
    <string>Allow $(PRODUCT_NAME) to use the microphone.</string>
    <key>NSPhotoLibraryUsageDescription</key>
    <string>Allow $(PRODUCT_NAME) to access your photos</string>
    <key>NSSpeechRecognitionUsageDescription</key>
    <string>Allow $(PRODUCT_NAME) to use speech recognition.</string>
    <key>UILaunchStoryboardName</key>
    <string>SplashScreen</string>
    <key>UIRequiredDeviceCapabilities</key>
    <array>
      <string>arm64</string>
    </array>
    <key>UIRequiresFullScreen</key>
    <false/>
    <key>UIStatusBarStyle</key>
    <string>UIStatusBarStyleDefault</string>
    <key>UISupportedInterfaceOrientations</key>
    <array>
      <string>UIInterfaceOrientationPortrait</string>
      <string>UIInterfaceOrientationPortraitUpsideDown</string>
      <string>UIInterfaceOrientationLandscapeLeft</string>
      <string>UIInterfaceOrientationLandscapeRight</string>
    </array>
    <key>UIUserInterfaceStyle</key>
    <string>Light</string>
    <key>UIViewControllerBasedStatusBarAppearance</key>
    <false/>
  </dict>
</plist>

================
File: app/ios/pizza/pizza-Bridging-Header.h
================
//
// Use this file to import your target's public headers that you would like to expose to Swift.
//

================
File: app/ios/pizza/pizza.entitlements
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
  <dict/>
</plist>

================
File: app/ios/pizza/SplashScreen.storyboard
================
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="32700.99.1234" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" useTraitCollections="YES" useSafeAreas="YES" colorMatched="YES" initialViewController="EXPO-VIEWCONTROLLER-1">
    <device id="retina6_12" orientation="portrait" appearance="light"/>
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="22685"/>
        <capability name="Named colors" minToolsVersion="9.0"/>
        <capability name="Safe area layout guides" minToolsVersion="9.0"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <scenes>
        <scene sceneID="EXPO-SCENE-1">
            <objects>
                <viewController storyboardIdentifier="SplashScreenViewController" id="EXPO-VIEWCONTROLLER-1" sceneMemberID="viewController">
                    <view key="view" userInteractionEnabled="NO" contentMode="scaleToFill" insetsLayoutMarginsFromSafeArea="NO" id="EXPO-ContainerView" userLabel="ContainerView">
                        <rect key="frame" x="0.0" y="0.0" width="393" height="852"/>
                        <autoresizingMask key="autoresizingMask" flexibleMaxX="YES" flexibleMaxY="YES"/>
                        <subviews/>
                        <viewLayoutGuide key="safeArea" id="Rmq-lb-GrQ"/>
                        <constraints>
                            <constraint firstItem="EXPO-SplashScreen" firstAttribute="centerY" secondItem="EXPO-ContainerView" secondAttribute="centerY" id="0VC-Wk-OaO"/>
                            <constraint firstItem="EXPO-SplashScreen" firstAttribute="centerX" secondItem="EXPO-ContainerView" secondAttribute="centerX" id="zR4-NK-mVN"/>
                        </constraints>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="EXPO-PLACEHOLDER-1" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="0.0" y="0.0"/>
        </scene>
    </scenes>
    <resources>
        <image name="SplashScreenLogo" width="100" height="90.333335876464844"/>
    </resources>
</document>

================
File: app/ios/pizza/Supporting/Expo.plist
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
  <dict>
    <key>EXUpdatesCheckOnLaunch</key>
    <string>ALWAYS</string>
    <key>EXUpdatesEnabled</key>
    <false/>
    <key>EXUpdatesLaunchWaitMs</key>
    <integer>0</integer>
  </dict>
</plist>

================
File: app/ios/Podfile
================
require File.join(File.dirname(`node --print "require.resolve('expo/package.json')"`), "scripts/autolinking")
require File.join(File.dirname(`node --print "require.resolve('react-native/package.json')"`), "scripts/react_native_pods")

require 'json'
podfile_properties = JSON.parse(File.read(File.join(__dir__, 'Podfile.properties.json'))) rescue {}

ENV['RCT_NEW_ARCH_ENABLED'] = '0' if podfile_properties['newArchEnabled'] == 'false'
ENV['EX_DEV_CLIENT_NETWORK_INSPECTOR'] = podfile_properties['EX_DEV_CLIENT_NETWORK_INSPECTOR']

platform :ios, podfile_properties['ios.deploymentTarget'] || '15.1'
install! 'cocoapods',
  :deterministic_uuids => false

prepare_react_native_project!

target 'pizza' do
  use_expo_modules!

  if ENV['EXPO_USE_COMMUNITY_AUTOLINKING'] == '1'
    config_command = ['node', '-e', "process.argv=['', '', 'config'];require('@react-native-community/cli').run()"];
  else
    config_command = [
      'npx',
      'expo-modules-autolinking',
      'react-native-config',
      '--json',
      '--platform',
      'ios'
    ]
  end

  config = use_native_modules!(config_command)

  use_frameworks! :linkage => podfile_properties['ios.useFrameworks'].to_sym if podfile_properties['ios.useFrameworks']
  use_frameworks! :linkage => ENV['USE_FRAMEWORKS'].to_sym if ENV['USE_FRAMEWORKS']

  use_react_native!(
    :path => config[:reactNativePath],
    :hermes_enabled => podfile_properties['expo.jsEngine'] == nil || podfile_properties['expo.jsEngine'] == 'hermes',
    # An absolute path to your application root.
    :app_path => "#{Pod::Config.instance.installation_root}/..",
    :privacy_file_aggregation_enabled => podfile_properties['apple.privacyManifestAggregationEnabled'] != 'false',
  )

  post_install do |installer|
    react_native_post_install(
      installer,
      config[:reactNativePath],
      :mac_catalyst_enabled => false,
      :ccache_enabled => podfile_properties['apple.ccacheEnabled'] == 'true',
    )

    # This is necessary for Xcode 14, because it signs resource bundles by default
    # when building for devices.
    installer.target_installation_results.pod_target_installation_results
      .each do |pod_name, target_installation_result|
      target_installation_result.resource_bundle_targets.each do |resource_bundle_target|
        resource_bundle_target.build_configurations.each do |config|
          config.build_settings['CODE_SIGNING_ALLOWED'] = 'NO'
        end
      end
    end
  end
end

================
File: app/ios/Podfile.properties.json
================
{
  "expo.jsEngine": "hermes",
  "EX_DEV_CLIENT_NETWORK_INSPECTOR": "true"
}

================
File: app/scripts/dev/reset-project.sh
================
#!/bin/bash

echo " Limpiando proyecto React Native..."

# Detener Metro bundler
echo "Deteniendo Metro bundler..."
pkill -f "react-native.*metro" || true

# Limpiar watchman
echo "Limpiando watchman..."
watchman watch-del-all 2>/dev/null || true

# Limpiar caches de React Native
echo "Limpiando caches..."
rm -rf $TMPDIR/react-* 2>/dev/null || true
rm -rf $TMPDIR/metro-* 2>/dev/null || true
rm -rf $TMPDIR/haste-* 2>/dev/null || true

# Limpiar node_modules y lock files
echo "Eliminando node_modules..."
rm -rf node_modules
rm -rf package-lock.json

# Limpiar caches de npm
echo "Limpiando cache de npm..."
npm cache clean --force

# Reinstalar dependencias
echo "Reinstalando dependencias..."
npm install

# Limpiar cache de Expo
echo "Limpiando cache de Expo..."
npx expo start --clear

echo " Limpieza completa!"

================
File: app/scripts/install-android-sdk.sh
================
#!/bin/bash

echo "=== Instalacin de Android SDK para builds locales ==="
echo ""

# Crear directorio para Android SDK
ANDROID_SDK_ROOT="$HOME/Android/Sdk"
mkdir -p "$ANDROID_SDK_ROOT"

# Instalar unzip si no est instalado
if ! command -v unzip &> /dev/null; then
    echo " Instalando unzip..."
    sudo apt install -y unzip
fi

# Descargar Android command line tools
if [ ! -d "$ANDROID_SDK_ROOT/cmdline-tools" ]; then
    echo " Descargando Android Command Line Tools..."
    cd "$ANDROID_SDK_ROOT"
    
    # URL de las herramientas ms recientes
    TOOLS_URL="https://dl.google.com/android/repository/commandlinetools-linux-11076708_latest.zip"
    
    echo "Descargando desde: $TOOLS_URL"
    wget -q --show-progress "$TOOLS_URL" -O cmdline-tools.zip
    
    echo "Extrayendo herramientas..."
    unzip -q cmdline-tools.zip
    
    # Reorganizar la estructura de directorios correctamente
    mkdir -p cmdline-tools/latest
    mv cmdline-tools/* cmdline-tools/latest/ 2>/dev/null || true
    
    # Limpiar
    rm -f cmdline-tools.zip
    
    echo " Android Command Line Tools instaladas"
else
    echo " Android Command Line Tools ya existen"
fi

# Configurar variables de entorno
echo ""
echo " Configurando variables de entorno..."

# Detectar shell
SHELL_CONFIG="$HOME/.bashrc"
if [ -n "$ZSH_VERSION" ]; then
    SHELL_CONFIG="$HOME/.zshrc"
fi

# Agregar ANDROID_HOME si no existe
if ! grep -q "ANDROID_HOME" "$SHELL_CONFIG"; then
    echo "" >> "$SHELL_CONFIG"
    echo "# Android SDK" >> "$SHELL_CONFIG"
    echo "export ANDROID_HOME=$ANDROID_SDK_ROOT" >> "$SHELL_CONFIG"
    echo "export ANDROID_SDK_ROOT=$ANDROID_SDK_ROOT" >> "$SHELL_CONFIG"
    echo "export PATH=\$PATH:\$ANDROID_HOME/emulator" >> "$SHELL_CONFIG"
    echo "export PATH=\$PATH:\$ANDROID_HOME/platform-tools" >> "$SHELL_CONFIG"
    echo "export PATH=\$PATH:\$ANDROID_HOME/cmdline-tools/latest/bin" >> "$SHELL_CONFIG"
    echo "export PATH=\$PATH:\$ANDROID_HOME/tools" >> "$SHELL_CONFIG"
    echo "export PATH=\$PATH:\$ANDROID_HOME/tools/bin" >> "$SHELL_CONFIG"
fi

# Exportar para la sesin actual
export ANDROID_HOME=$ANDROID_SDK_ROOT
export ANDROID_SDK_ROOT=$ANDROID_SDK_ROOT
export PATH=$PATH:$ANDROID_HOME/emulator
export PATH=$PATH:$ANDROID_HOME/platform-tools
export PATH=$PATH:$ANDROID_HOME/cmdline-tools/latest/bin
export PATH=$PATH:$ANDROID_HOME/tools
export PATH=$PATH:$ANDROID_HOME/tools/bin

# Verificar que sdkmanager est disponible
if ! command -v sdkmanager &> /dev/null; then
    echo " Error: sdkmanager no se encuentra. Verificando instalacin..."
    ls -la "$ANDROID_HOME/cmdline-tools/latest/bin/"
    exit 1
fi

echo ""
echo " Instalando componentes de Android SDK..."
echo "Esto puede tomar varios minutos..."

# Aceptar licencias
yes | sdkmanager --licenses 2>/dev/null || true

# Instalar componentes esenciales
sdkmanager "platform-tools"
sdkmanager "platforms;android-34"
sdkmanager "build-tools;34.0.0"
sdkmanager "ndk;25.1.8937393"

# Crear/actualizar local.properties
echo ""
echo " Actualizando local.properties..."
echo "sdk.dir=$ANDROID_SDK_ROOT" > "$HOME/bite/app/android/local.properties"

echo ""
echo " Android SDK instalado y configurado!"
echo ""
echo " Resumen de la configuracin:"
echo "   ANDROID_HOME=$ANDROID_HOME"
echo "   JAVA_HOME=$JAVA_HOME"
echo ""
echo "  IMPORTANTE: Ejecuta este comando para cargar las variables:"
echo "    source $SHELL_CONFIG"
echo ""
echo " Luego puedes ejecutar tu build con:"
echo "    npm run build:android:dev"

================
File: app/scripts/install-java.sh
================
#!/bin/bash

# Install Java JDK 17 and configure environment for Android builds

echo "Installing OpenJDK 17..."
sudo apt update
sudo apt install -y openjdk-17-jdk

# Verify installation
echo -e "\nVerifying Java installation..."
java -version
javac -version

# Find Java installation path
JAVA_PATH=$(update-alternatives --list java | grep java-17)
if [ -z "$JAVA_PATH" ]; then
    echo "Error: Java 17 installation not found"
    exit 1
fi

# Extract JAVA_HOME from the path (remove /bin/java from the end)
JAVA_HOME_PATH=$(dirname $(dirname $JAVA_PATH))

echo -e "\nJava installed at: $JAVA_HOME_PATH"

# Add JAVA_HOME and PATH to .bashrc
echo -e "\nConfiguring environment variables..."

# Check if JAVA_HOME is already in .bashrc
if ! grep -q "export JAVA_HOME=" ~/.bashrc; then
    echo "" >> ~/.bashrc
    echo "# Java configuration" >> ~/.bashrc
    echo "export JAVA_HOME=$JAVA_HOME_PATH" >> ~/.bashrc
    echo 'export PATH=$JAVA_HOME/bin:$PATH' >> ~/.bashrc
    echo "Environment variables added to ~/.bashrc"
else
    echo "JAVA_HOME already exists in ~/.bashrc, updating..."
    sed -i "s|export JAVA_HOME=.*|export JAVA_HOME=$JAVA_HOME_PATH|" ~/.bashrc
fi

# Also add to .profile for non-interactive shells
if ! grep -q "export JAVA_HOME=" ~/.profile; then
    echo "" >> ~/.profile
    echo "# Java configuration" >> ~/.profile
    echo "export JAVA_HOME=$JAVA_HOME_PATH" >> ~/.profile
    echo 'export PATH=$JAVA_HOME/bin:$PATH' >> ~/.profile
fi

# Export for current session
export JAVA_HOME=$JAVA_HOME_PATH
export PATH=$JAVA_HOME/bin:$PATH

echo -e "\nJava installation complete!"
echo "JAVA_HOME set to: $JAVA_HOME"
echo -e "\nPlease run: source ~/.bashrc"
echo "Or restart your terminal for changes to take effect."

================
File: app/scripts/release-to-playstore.sh
================
#!/bin/bash

# Colores para output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

echo -e "${YELLOW} Iniciando release a Play Store...${NC}"

# 1. Verificar que estamos en main
BRANCH=$(git rev-parse --abbrev-ref HEAD)
if [ "$BRANCH" != "main" ]; then
    echo -e "${RED} Debes estar en la rama main para hacer release${NC}"
    exit 1
fi

# 2. Verificar que no hay cambios sin commitear
if ! git diff-index --quiet HEAD --; then
    echo -e "${RED} Hay cambios sin commitear. Por favor commitea o stashea los cambios primero.${NC}"
    exit 1
fi

# 3. Obtener versin actual
CURRENT_VERSION=$(node -p "require('./app.json').expo.version")
echo -e "${GREEN}Versin actual: $CURRENT_VERSION${NC}"

# 4. Solicitar nueva versin
echo -e "${YELLOW} Ingresa la nueva versin (formato: X.Y.Z):${NC}"
read VERSION

# Validar formato de versin
if ! [[ $VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    echo -e "${RED} Formato de versin invlido. Usa X.Y.Z (ej: 1.0.1)${NC}"
    exit 1
fi

# 5. Actualizar versionCode
CURRENT_VERSION_CODE=$(node -p "require('./app.json').expo.android.versionCode")
NEW_VERSION_CODE=$((CURRENT_VERSION_CODE + 1))

# 6. Actualizar app.json
node -e "
const fs = require('fs');
const appJson = require('./app.json');
appJson.expo.version = '$VERSION';
appJson.expo.android.versionCode = $NEW_VERSION_CODE;
fs.writeFileSync('./app.json', JSON.stringify(appJson, null, 2));
"

echo -e "${GREEN} Versin actualizada a $VERSION (versionCode: $NEW_VERSION_CODE)${NC}"

# 7. Solicitar mensaje de release
echo -e "${YELLOW} Ingresa una descripcin breve de los cambios:${NC}"
read RELEASE_MESSAGE

# 8. Commit cambios
git add app.json
git commit -m "Release v$VERSION: $RELEASE_MESSAGE"
git tag "v$VERSION"

# 9. Verificar credenciales de Google Play
if [ ! -f "./google-play-service-account.json" ]; then
    echo -e "${RED} No se encontr google-play-service-account.json${NC}"
    echo -e "${YELLOW}Por favor, descarga el archivo de credenciales de Google Play Console y gurdalo como google-play-service-account.json${NC}"
    exit 1
fi

# 10. Confirmar build
echo -e "${YELLOW}Deseas continuar con el build y publicacin? (s/n)${NC}"
read CONFIRM

if [ "$CONFIRM" != "s" ]; then
    echo -e "${RED} Release cancelado${NC}"
    # Revertir cambios
    git reset --hard HEAD~1
    git tag -d "v$VERSION"
    exit 1
fi

# 11. Build y submit
echo -e "${YELLOW}  Iniciando build y submit a Play Store...${NC}"
eas build --platform android --profile production --auto-submit --non-interactive --message "v$VERSION: $RELEASE_MESSAGE"

# 12. Push cambios si el build fue exitoso
if [ $? -eq 0 ]; then
    echo -e "${YELLOW} Subiendo cambios a repositorio...${NC}"
    git push origin main --tags
    echo -e "${GREEN} Release v$VERSION completado exitosamente!${NC}"
    echo -e "${GREEN} Tu app ser revisada y publicada en el track 'internal' de Play Store${NC}"
else
    echo -e "${RED} Error en el build. Los cambios locales no se han subido.${NC}"
    echo -e "${YELLOW}Para revertir los cambios locales, ejecuta:${NC}"
    echo "git reset --hard HEAD~1 && git tag -d v$VERSION"
fi

================
File: app/scripts/verify-android-setup.sh
================
#!/bin/bash

# Verify Android development environment setup

echo "=== Android Development Environment Verification ==="
echo

# Check Java
echo "1. Java Installation:"
if command -v java &> /dev/null; then
    java -version
    echo " Java is installed"
else
    echo " Java is not installed or not in PATH"
fi
echo

# Check JAVA_HOME
echo "2. JAVA_HOME Environment Variable:"
if [ -n "$JAVA_HOME" ]; then
    echo "JAVA_HOME is set to: $JAVA_HOME"
    if [ -d "$JAVA_HOME" ]; then
        echo " JAVA_HOME directory exists"
    else
        echo " JAVA_HOME directory does not exist"
    fi
else
    echo " JAVA_HOME is not set"
fi
echo

# Check Android SDK (if exists)
echo "3. Android SDK:"
if [ -n "$ANDROID_HOME" ] || [ -n "$ANDROID_SDK_ROOT" ]; then
    if [ -n "$ANDROID_HOME" ]; then
        echo "ANDROID_HOME is set to: $ANDROID_HOME"
    fi
    if [ -n "$ANDROID_SDK_ROOT" ]; then
        echo "ANDROID_SDK_ROOT is set to: $ANDROID_SDK_ROOT"
    fi
    echo " Android SDK environment variables are set"
else
    echo " Android SDK environment variables not set (this is OK if using EAS Build)"
fi
echo

# Check Node.js
echo "4. Node.js:"
if command -v node &> /dev/null; then
    echo "Node version: $(node --version)"
    echo " Node.js is installed"
else
    echo " Node.js is not installed"
fi
echo

# Check npm
echo "5. npm:"
if command -v npm &> /dev/null; then
    echo "npm version: $(npm --version)"
    echo " npm is installed"
else
    echo " npm is not installed"
fi
echo

# Check EAS CLI
echo "6. EAS CLI:"
if command -v eas &> /dev/null; then
    echo "EAS CLI version: $(eas --version)"
    echo " EAS CLI is installed"
else
    echo " EAS CLI is not installed"
    echo "  Install with: npm install -g eas-cli"
fi
echo

# Check Expo CLI
echo "7. Expo CLI:"
if npx expo --version &> /dev/null 2>&1; then
    echo "Expo CLI version: $(npx expo --version)"
    echo " Expo CLI is available"
else
    echo " Expo CLI is not available"
fi
echo

echo "=== Summary ==="
echo "Run the following commands to complete setup:"
echo "1. ./scripts/install-java.sh          # Install Java JDK 17"
echo "2. source ~/.bashrc                  # Reload environment variables"
echo "3. ./scripts/fix-expo-packages.sh     # Fix Expo package versions"
echo "4. npm install -g eas-cli            # Install EAS CLI if needed"

================
File: app/src/app/constants/storageKeys.ts
================
/**
 * Constantes para las claves utilizadas en el almacenamiento seguro (EncryptedStorage).
 */
export const STORAGE_KEYS = {
  /** Clave para almacenar las credenciales del usuario (email/username y password) en formato JSON string. */
  REMEMBERED_CREDENTIALS: 'user_credentials',

  /** Clave para almacenar la preferencia del usuario sobre si desea ser recordado ('true' o 'false'). */
  REMEMBER_ME_ENABLED: 'remember_me_preference',

  /** Clave existente para el token de autenticacin. */
  AUTH_TOKEN: 'auth_token',
} as const;

================
File: app/src/app/lib/errorMapping.ts
================
import { ApiError } from './errors';
import { ERROR_CODES, ApiErrorCode } from '../constants/apiErrorCodes';
import { AxiosError } from 'axios';

const errorCodeMessages: { [key in ApiErrorCode | string]?: string } = {
  // Errores de autenticacin
  [ERROR_CODES.AUTH_INVALID_CREDENTIALS]:
    'El correo/usuario o la contrasea son incorrectos.',
  [ERROR_CODES.AUTH_INCORRECT_PASSWORD]: 'La contrasea es incorrecta.',
  [ERROR_CODES.AUTH_DUPLICATE_EMAIL]:
    'Este correo electrnico ya est registrado. Intenta iniciar sesin.',
  [ERROR_CODES.AUTH_DUPLICATE_USERNAME]:
    'Este nombre de usuario ya est en uso. Elige otro.',
  [ERROR_CODES.AUTH_UNAUTHORIZED]:
    'No autorizado. Por favor, inicia sesin de nuevo.',
  [ERROR_CODES.AUTH_FORBIDDEN]: 'No tienes permiso para realizar esta accin.',
  [ERROR_CODES.REFRESH_FAILED]:
    'Tu sesin ha expirado. Por favor, inicia sesin nuevamente.',

  // Errores de validacin
  [ERROR_CODES.VALIDATION_ERROR]: 'Por favor, revisa la informacin ingresada.',

  // Errores de recursos
  [ERROR_CODES.RESOURCE_NOT_FOUND]: 'El recurso solicitado no se encontr.',
  [ERROR_CODES.CONFLICT_ERROR]: 'Hubo un conflicto al procesar tu solicitud.',
  [ERROR_CODES.PRODUCT_NAME_EXISTS]:
    'Ya existe un producto con ese nombre. Por favor, elige otro nombre.',

  // Errores de red y servidor
  [ERROR_CODES.NETWORK_ERROR]:
    'Error de red. Verifica tu conexin e intntalo de nuevo.',
  [ERROR_CODES.API_CLIENT_ERROR]: 'Error al comunicar con el servidor.',
  [ERROR_CODES.INTERNAL_SERVER_ERROR]:
    'Ocurri un error en el servidor. Intntalo de nuevo ms tarde.',
  [ERROR_CODES.UNKNOWN_API_ERROR]:
    'Ocurri un error inesperado al procesar tu solicitud.',
  [ERROR_CODES.UNKNOWN_ERROR]: 'Ocurri un error desconocido.',

  // Mensajes por cdigo de estado HTTP
  [`status_400`]: 'La solicitud contiene datos invlidos.',
  [`status_401`]: 'No autorizado. Por favor, inicia sesin de nuevo.',
  [`status_403`]: 'No tienes permiso para realizar esta accin.',
  [`status_404`]: 'El recurso solicitado no se encontr.',
  [`status_409`]: 'Existe un conflicto con el estado actual del recurso.',
  [`status_422`]: 'Los datos enviados son invlidos o incompletos.',
  [`status_500`]: 'Error interno del servidor. Por favor, intenta ms tarde.',
  [`status_502`]: 'Error de conexin con el servidor.',
  [`status_503`]: 'El servicio no est disponible temporalmente.',

  // Cdigos especficos del backend - Autenticacin
  AUTH_USER_NOT_FOUND: 'Usuario no encontrado.',
  AUTH_EMAIL_NOT_CONFIRMED:
    'Por favor, confirma tu correo electrnico antes de iniciar sesin.',
  AUTH_ACCOUNT_LOCKED:
    'Tu cuenta ha sido bloqueada. Contacta al administrador.',
  AUTH_SESSION_EXPIRED:
    'Tu sesin ha expirado. Por favor, inicia sesin nuevamente.',

  // Cdigos especficos del backend - Validacin
  VALIDATION_FAILED: 'Error de validacin. Revisa los datos ingresados.',
  DUPLICATE_ENTRY: 'Ya existe un registro con estos datos.',
  INVALID_INPUT: 'Los datos ingresados no son vlidos.',
  MISSING_REQUIRED_FIELD: 'Faltan campos obligatorios.',

  // Cdigos especficos del backend - Permisos
  INSUFFICIENT_PERMISSIONS:
    'No tienes permisos suficientes para realizar esta accin.',
  RATE_LIMIT_EXCEEDED:
    'Has realizado demasiadas solicitudes. Intenta ms tarde.',

  // Cdigos especficos del backend - rdenes
  ORDER_NOT_FOUND: 'La orden no fue encontrada.',
  ORDER_ALREADY_COMPLETED: 'Esta orden ya fue completada.',
  ORDER_CANNOT_BE_MODIFIED:
    'Esta orden no puede ser modificada en su estado actual.',
  TABLE_ALREADY_OCCUPIED: 'La mesa seleccionada ya est ocupada.',
  INVALID_ORDER_TYPE: 'Tipo de orden invlido.',
  NO_ITEMS_IN_ORDER: 'La orden debe contener al menos un producto.',

  // Cdigos especficos del backend - Productos
  PRODUCT_NOT_FOUND: 'El producto no fue encontrado.',
  PRODUCT_NOT_AVAILABLE: 'El producto no est disponible en este momento.',
  PRODUCT_OUT_OF_STOCK: 'El producto est agotado.',
  INVALID_PRODUCT_VARIANT: 'La variante del producto no es vlida.',
  INVALID_MODIFIER: 'El modificador seleccionado no es vlido.',

  // Cdigos especficos del backend - Mesas y reas
  TABLE_NOT_FOUND: 'La mesa no fue encontrada.',
  AREA_NOT_FOUND: 'El rea no fue encontrada.',
  TABLE_IN_USE: 'La mesa est siendo utilizada en otra orden.',

  // Cdigos especficos del backend - Impresoras
  PRINTER_NOT_FOUND: 'La impresora no fue encontrada.',
  PRINTER_OFFLINE: 'La impresora no est disponible.',
  PRINT_FAILED: 'Error al imprimir. Verifica la conexin de la impresora.',
  THERMAL_PRINTER_DUPLICATE_FIELD: 'Ya existe una impresora con ese nombre.',

  // Cdigos especficos del backend - Categoras
  CATEGORY_NOT_FOUND: 'La categora no fue encontrada.',
  SUBCATEGORY_NOT_FOUND: 'La subcategora no fue encontrada.',
  CATEGORY_HAS_PRODUCTS:
    'No se puede eliminar la categora porque tiene productos asociados.',

  // Errores de archivos
  [ERROR_CODES.UPLOAD_FAILED]:
    'Error al subir el archivo. Por favor, intenta nuevamente.',
  [ERROR_CODES.FILE_TOO_LARGE]:
    'El archivo es demasiado grande. El tamao mximo permitido es 10MB.',
  cantUploadFileType:
    'El tipo de archivo no est permitido. Solo se permiten imgenes (JPG, JPEG, PNG, GIF).',
};

export function getApiErrorMessage(error: unknown): string {
  const defaultMessage = 'Ocurri un error inesperado.';

  if (error instanceof ApiError) {
    // Si tenemos un mensaje especfico del backend y no es un mensaje genrico,
    // usarlo siempre, independientemente del cdigo
    if (
      error.originalMessage &&
      error.originalMessage !== 'Error desconocido de la API.' &&
      error.originalMessage !== 'Not Found' &&
      error.originalMessage !== 'Internal Server Error' &&
      error.originalMessage !==
        'Ocurri un error inesperado al procesar tu solicitud.' &&
      !error.originalMessage.includes('<!DOCTYPE') // Evitar HTML de errores
    ) {
      return error.originalMessage;
    }

    // Si no, intentamos con el cdigo especfico
    let message = errorCodeMessages[error.code];

    // Si no hay mensaje para el cdigo, intentamos con el cdigo de estado
    if (!message) {
      message = errorCodeMessages[`status_${error.status}`];
    }

    // Si encontramos un mensaje genrico pero tenemos detalles especficos, usar los detalles
    if (message === errorCodeMessages[`status_409`] && error.details?.message) {
      return error.details.message;
    }

    return message || defaultMessage;
  } else if (error instanceof AxiosError) {
    if (error.message === 'Network Error' || !error.response) {
      return errorCodeMessages[ERROR_CODES.NETWORK_ERROR] || 'Error de red.';
    }
    if (error.response?.status) {
      const statusMessage =
        errorCodeMessages[`status_${error.response.status}`];
      if (statusMessage) return statusMessage;
    }
    return errorCodeMessages[ERROR_CODES.UNKNOWN_API_ERROR] || defaultMessage;
  } else if (error instanceof Error) {
    if (
      error.message.toLowerCase().includes('network request failed') ||
      error.message.toLowerCase().includes('failed to fetch')
    ) {
      return errorCodeMessages[ERROR_CODES.NETWORK_ERROR] || 'Error de red.';
    }
    return error.message && !error.message.toLowerCase().includes('undefined')
      ? error.message
      : defaultMessage;
  } else {
    return defaultMessage;
  }
}

================
File: app/src/app/schemas/domain/adjustment.schema.ts
================
import { z } from 'zod';

export const adjustmentSchema = z.object({
  id: z.string(),
  orderId: z.string().nullable().optional(),
  orderItemId: z.string().nullable().optional(),
  name: z.string(),
  isPercentage: z.boolean(),
  value: z.number(), // Porcentaje si isPercentage es true (0-100)
  amount: z.number(), // Monto calculado o fijo
  appliedById: z.string(),
  appliedAt: z.string(),
  createdAt: z.string(),
  updatedAt: z.string(),
  deletedAt: z.string().nullable().optional(),

  // Relaciones opcionales
  order: z.any().optional(),
  orderItem: z.any().optional(),
  appliedBy: z.any().optional(),
});

export type Adjustment = z.infer<typeof adjustmentSchema>;

// Schema base para crear un ajuste (sin validaciones)
const createAdjustmentBaseSchema = z.object({
  orderId: z.string().uuid().optional(),
  orderItemId: z.string().uuid().optional(),
  name: z.string().max(100),
  isPercentage: z.boolean(),
  value: z.number().min(0).max(100).optional(), // Solo requerido si isPercentage es true
  amount: z.number().optional(), // Solo requerido si isPercentage es false
});

// Schema para crear un ajuste con validaciones
export const createAdjustmentSchema = createAdjustmentBaseSchema
  .refine(
    (data) => {
      // Debe tener orderId O orderItemId, pero no ambos
      return (
        (data.orderId && !data.orderItemId) ||
        (!data.orderId && data.orderItemId)
      );
    },
    {
      message:
        'El ajuste debe aplicarse a una orden o a un item de orden, pero no a ambos',
    },
  )
  .refine(
    (data) => {
      // Si es porcentaje, debe tener value. Si no, debe tener amount
      if (data.isPercentage) {
        return data.value !== undefined;
      } else {
        return data.amount !== undefined;
      }
    },
    {
      message:
        "Si es porcentaje debe incluir 'value', si no debe incluir 'amount'",
    },
  );

export type CreateAdjustment = z.infer<typeof createAdjustmentSchema>;

// Schema para actualizar un ajuste (usando el schema base sin validaciones)
export const updateAdjustmentSchema = createAdjustmentBaseSchema.partial();
export type UpdateAdjustment = z.infer<typeof updateAdjustmentSchema>;

================
File: app/src/app/schemas/domain/area.schema.ts
================
import { z } from 'zod';

// nica fuente de verdad para la entidad Area
export const areaSchema = z.object({
  id: z.string().uuid(),
  name: z.string(),
  description: z.string().nullable().optional(),
  isActive: z.boolean(),
  createdAt: z.string().datetime().optional(), // O z.date() si se prefiere
  updatedAt: z.string().datetime().optional(), // O z.date() si se prefiere
});

// Tipo TypeScript inferido y exportado centralmente
export type Area = z.infer<typeof areaSchema>;

================
File: app/src/app/schemas/domain/category.schema.ts
================
import { z } from 'zod';

/**
 * Esquema Zod para validar la estructura de una foto de categora.
 * Fuente de verdad centralizada.
 */
export const categoryPhotoSchema = z.object({
  id: z.string(), // Asumiendo que el ID puede no ser UUID aqu, ajustar si es necesario
  path: z.string(), // Podra ser z.string().url() si siempre es URL
});

/**
 * Esquema Zod para validar un objeto Category completo.
 * Fuente de verdad centralizada.
 */
export const categorySchema = z.object({
  id: z.string(),
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().nullable().optional(),
  isActive: z.boolean(),
  sortOrder: z.number(),
  photo: categoryPhotoSchema.nullable().optional(),
});

// Tipos TypeScript inferidos y exportados centralmente
export type CategoryPhoto = z.infer<typeof categoryPhotoSchema>;
export type Category = z.infer<typeof categorySchema>;

================
File: app/src/app/schemas/domain/delivery-info.schema.ts
================
import { z } from 'zod';

export const DeliveryInfoSchema = z.object({
  id: z.string().optional(),
  orderId: z.string().optional(),
  fullAddress: z.string().optional(),
  street: z.string().optional(),
  number: z.string().optional(),
  interiorNumber: z.string().optional(),
  neighborhood: z.string().optional(),
  city: z.string().optional(),
  state: z.string().optional(),
  zipCode: z.string().optional(),
  country: z.string().optional(),
  recipientName: z.string().optional(),
  recipientPhone: z.string().optional(),
  deliveryInstructions: z.string().optional(),
  latitude: z.number().optional(),
  longitude: z.number().optional(),
  createdAt: z.string().datetime().optional(),
  updatedAt: z.string().datetime().optional(),
});

export type DeliveryInfo = z.infer<typeof DeliveryInfoSchema>;

================
File: app/src/app/schemas/domain/modifier.schema.ts
================
import { z } from 'zod';

/**
 * Esquema Zod para validar un objeto Modifier completo.
 * Fuente de verdad centralizada.
 */
export const modifierSchema = z.object({
  id: z.string(),
  modifierGroupId: z.string().min(1, 'El ID del grupo no es vlido'),
  name: z.string().min(1, 'El nombre es requerido').max(100),
  description: z.string().max(255).nullable().optional(),
  price: z.coerce.number().nullable().optional(),
  sortOrder: z.number().int().default(0),
  isDefault: z.boolean().default(false),
  isActive: z.boolean().default(true),
});

// Tipo TypeScript inferido y exportado centralmente
export type Modifier = z.infer<typeof modifierSchema>;

================
File: app/src/app/schemas/domain/photo.schema.ts
================
import { z } from 'zod';

/**
 * Esquema Zod para validar la estructura de una foto en el dominio.
 * Fuente de verdad centralizada.
 */
export const photoSchema = z.object({
  id: z.string().uuid(), // ID puede ser custom format
  path: z.string().url(), // Usar url() como en products/subcategories
});

// Tipo TypeScript inferido y exportado centralmente
export type Photo = z.infer<typeof photoSchema>;

================
File: app/src/app/schemas/domain/preparation-screen.schema.ts
================
import { z } from 'zod';

/**
 * Esquema Zod para PreparationScreen simplificado para el dominio.
 * Solo incluye los campos necesarios para la referencia en productos.
 */
export const preparationScreenSchema = z.object({
  id: z.string(),
  name: z.string(),
  description: z.string().nullable().optional(),
  isActive: z.boolean(),
});

export type PreparationScreen = z.infer<typeof preparationScreenSchema>;

================
File: app/src/app/schemas/domain/product-variant.schema.ts
================
import { z } from 'zod';

/**
 * Esquema Zod para validar un objeto ProductVariant completo.
 * Fuente de verdad centralizada.
 */
export const productVariantSchema = z.object({
  id: z.string(), // ID es requerido en el dominio
  name: z.string().min(1, 'El nombre es requerido'),
  price: z.coerce.number({
    // Usar coerce para asegurar que sea nmero
    invalid_type_error: 'El precio debe ser un nmero',
    required_error: 'El precio es requerido',
  }), // No necesita ser positivo aqu, puede ser 0
  isActive: z.boolean(),
  sortOrder: z.number(),
});

// Tipo TypeScript inferido y exportado centralmente
export type ProductVariant = z.infer<typeof productVariantSchema>;

// Schema opcional para Input (definido manualmente, sin ID)
export const productVariantInputSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  price: z.coerce.number({
    invalid_type_error: 'El precio debe ser un nmero',
    required_error: 'El precio es requerido',
  }),
  isActive: z.boolean(),
  sortOrder: z.number(),
});
export type ProductVariantInput = z.infer<typeof productVariantInputSchema>;

================
File: app/src/app/schemas/domain/product.schema.ts
================
import { z } from 'zod';
import { photoSchema } from './photo.schema';
import { productVariantSchema } from './product-variant.schema';
import { modifierGroupSchema } from './modifier-group.schema';
import { preparationScreenSchema } from './preparation-screen.schema';

/**
 * Esquema Zod para validar un objeto Product completo.
 * Fuente de verdad centralizada.
 */
export const productSchema = z.object({
  id: z.string(), // ID es requerido en el dominio
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().nullable().optional(), // Campo descripcin agregado
  price: z
    .number()
    .positive('El precio debe ser positivo')
    .refine((val) => /^\d+(\.\d{1,2})?$/.test(String(val)), {
      message: 'El precio debe tener como mximo dos decimales',
    })
    .optional()
    .nullable(),
  hasVariants: z.boolean(),
  isActive: z.boolean(),
  isPizza: z.boolean(),
  subcategoryId: z.string().min(1, 'La subcategora es requerida'),
  sortOrder: z.number(),
  photo: photoSchema.optional().nullable(),
  estimatedPrepTime: z
    .number()
    .min(1, 'El tiempo debe ser al menos 1 minuto')
    .optional(),
  preparationScreenId: z.string().optional().nullable(),
  preparationScreen: preparationScreenSchema.optional().nullable(),
  variants: z.array(productVariantSchema).optional(),
  modifierGroups: z.array(modifierGroupSchema).optional(),
  pizzaCustomizations: z.array(z.any()).optional(),
  pizzaConfiguration: z.any().optional(),
  createdAt: z.union([z.string().datetime(), z.date()]).optional(),
  updatedAt: z.union([z.string().datetime(), z.date()]).optional(),
});

export type Product = z.infer<typeof productSchema> & {
  pizzaCustomizations?: any[];
  pizzaConfiguration?: any;
};

================
File: app/src/app/schemas/domain/table.schema.ts
================
import { z } from 'zod';

/**
 * Esquema Zod para validar un objeto Table completo.
 * Fuente de verdad centralizada.
 */
export const tableSchema = z.object({
  id: z.string().uuid(),
  name: z.string(),
  areaId: z.string().uuid(),
  capacity: z.number().int().nullable().optional(),
  isActive: z.boolean(),
  isAvailable: z.boolean(), // Incluido desde el schema original
  isTemporary: z.boolean(), // Incluido desde el schema original
  temporaryIdentifier: z.string().nullable().optional(), // Incluido desde el schema original
  area: z
    .object({
      id: z.string().uuid(),
      name: z.string(),
    })
    .optional(), // El rea puede venir incluida opcionalmente
  createdAt: z.union([z.string().datetime(), z.date()]).optional(), // Permitir string o Date
  updatedAt: z.union([z.string().datetime(), z.date()]).optional(), // Permitir string o Date
});

// Tipo TypeScript inferido y exportado centralmente
export type Table = z.infer<typeof tableSchema>;

================
File: app/src/app/store/snackbarStore.ts
================
import { create } from 'zustand';

export type SnackbarType = 'info' | 'success' | 'error' | 'warning';

export interface SnackbarState {
  visible: boolean;
  message: string;
  type: SnackbarType;
  duration?: number;
  showSnackbar: (params: {
    message: string;
    type?: SnackbarType;
    duration?: number;
  }) => void;
  hideSnackbar: () => void;
}

export const useSnackbarStore = create<SnackbarState>((set) => ({
  visible: false,
  message: '',
  type: 'info',
  duration: 2000,
  showSnackbar: ({ message, type = 'info', duration = 2000 }) =>
    set({ visible: true, message, type, duration }),
  hideSnackbar: () => set({ visible: false }),
}));

================
File: app/src/app/styles/colors.ts
================
export const lightColors = {
  primary: '#1976D2',
  primaryContainer: '#BBDEFB',
  onPrimary: '#FFFFFF',
  onPrimaryContainer: '#004C8B',

  secondary: '#FF9800',
  secondaryContainer: '#FFE0B2',
  onSecondary: '#FFFFFF',
  onSecondaryContainer: '#562800',

  tertiary: '#43A047',
  tertiaryContainer: '#C8E6C9',
  onTertiary: '#FFFFFF',
  onTertiaryContainer: '#002411',

  background: '#F8F9FA',
  onBackground: '#202124',
  surface: '#FFFFFF',
  onSurface: '#202124',
  surfaceVariant: '#E4E6EB',
  onSurfaceVariant: '#44464F',

  error: '#B00020',
  errorContainer: '#FFDAD6',
  onError: '#FFFFFF',
  onErrorContainer: '#410002',

  outline: '#74777F',
  outlineVariant: '#C4C7C5',
  inverseSurface: '#2E3133',
  inverseOnSurface: '#F2F2F2',
  inversePrimary: '#80CBC4',

  success: '#2E7D32',
  successContainer: '#C8E6C9',
  onSuccessContainer: '#0D3912',
  warning: '#F57C00',
  warningContainer: '#FFE0B2',
  onWarningContainer: '#662D00',
  info: '#1976D2',
  infoContainer: '#BBDEFB',
  onInfoContainer: '#00325B',
};

export const darkColors = {
  primary: '#FF7043',
  primaryContainer: '#662E1A',
  onPrimary: '#FFFFFF',
  onPrimaryContainer: '#FFDACF',

  secondary: '#FFB74D',
  secondaryContainer: '#774B1F',
  onSecondary: '#000000',
  onSecondaryContainer: '#FFE0B2',

  tertiary: '#FFD54F',
  tertiaryContainer: '#775B25',
  onTertiary: '#000000',
  onTertiaryContainer: '#FFF3C4',

  background: '#121212',
  onBackground: '#FFFFFF',
  surface: '#1E1E1E',
  onSurface: '#FFFFFF',
  surfaceVariant: '#2C2C2C',
  onSurfaceVariant: '#9E9E9E',

  error: '#FF6B6B',
  errorContainer: '#4D2626',
  onError: '#FFFFFF',
  onErrorContainer: '#FFE5E5',

  outline: '#4F4F4F',
  outlineVariant: '#3D3D3D',
  inverseSurface: '#FFFFFF',
  inverseOnSurface: '#121212',
  inversePrimary: '#FF5722',

  success: '#69F0AE',
  successContainer: '#1B5E20',
  onSuccessContainer: '#B3FFD1',
  warning: '#FFC107',
  warningContainer: '#795548',
  onWarningContainer: '#FFE0B2',
  info: '#64B5F6',
  infoContainer: '#1565C0',
  onInfoContainer: '#B3E5FC',
};

================
File: app/src/app/styles/typography.ts
================
import { Platform } from 'react-native';

export const typography = {
  fonts: {
    regular: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto',
      default: 'System',
    }),
    medium: Platform.select({
      ios: 'SF Pro Text-Medium',
      android: 'Roboto-Medium',
      default: 'System-Medium',
    }),
    light: Platform.select({
      ios: 'SF Pro Text-Light',
      android: 'Roboto-Light',
      default: 'System-Light',
    }),
    thin: Platform.select({
      ios: 'SF Pro Text-Thin',
      android: 'Roboto-Thin',
      default: 'System-Thin',
    }),
  },

  displayLarge: {
    fontFamily: Platform.select({
      ios: 'SF Pro Display',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 57,
    lineHeight: 64,
    letterSpacing: -0.25,
  },
  displayMedium: {
    fontFamily: Platform.select({
      ios: 'SF Pro Display',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 45,
    lineHeight: 52,
    letterSpacing: 0,
  },
  displaySmall: {
    fontFamily: Platform.select({
      ios: 'SF Pro Display',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 36,
    lineHeight: 44,
    letterSpacing: 0,
  },
  headlineLarge: {
    fontFamily: Platform.select({
      ios: 'SF Pro Display',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 32,
    lineHeight: 40,
    letterSpacing: 0,
  },
  headlineMedium: {
    fontFamily: Platform.select({
      ios: 'SF Pro Display',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 28,
    lineHeight: 36,
    letterSpacing: 0,
  },
  headlineSmall: {
    fontFamily: Platform.select({
      ios: 'SF Pro Display',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 24,
    lineHeight: 32,
    letterSpacing: 0,
  },
  titleLarge: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 22,
    lineHeight: 28,
    letterSpacing: 0,
  },
  titleMedium: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto-Medium',
      default: 'System-Medium',
    }),
    fontSize: 16,
    lineHeight: 24,
    letterSpacing: 0.15,
  },
  titleSmall: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto-Medium',
      default: 'System-Medium',
    }),
    fontSize: 14,
    lineHeight: 20,
    letterSpacing: 0.1,
  },
  labelLarge: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto-Medium',
      default: 'System-Medium',
    }),
    fontSize: 14,
    lineHeight: 20,
    letterSpacing: 0.1,
  },
  labelMedium: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto-Medium',
      default: 'System-Medium',
    }),
    fontSize: 12,
    lineHeight: 16,
    letterSpacing: 0.5,
  },
  labelSmall: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto-Medium',
      default: 'System-Medium',
    }),
    fontSize: 11,
    lineHeight: 16,
    letterSpacing: 0.5,
  },
  bodyLarge: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 16,
    lineHeight: 24,
    letterSpacing: 0.5,
  },
  bodyMedium: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 14,
    lineHeight: 20,
    letterSpacing: 0.25,
  },
  bodySmall: {
    fontFamily: Platform.select({
      ios: 'SF Pro Text',
      android: 'Roboto',
      default: 'System',
    }),
    fontSize: 12,
    lineHeight: 16,
    letterSpacing: 0.4,
  },
};

export const iosFontFamily = {
  regular: 'System',
  medium: 'System',
  light: 'System',
  thin: 'System',
};

export const androidFontFamily = {
  regular: 'sans-serif',
  medium: 'sans-serif-medium',
  light: 'sans-serif-light',
  thin: 'sans-serif-thin',
};

================
File: app/src/app/utils/dateTimeHelpers.ts
================
import { format, parse, setHours, setMinutes, isValid } from 'date-fns';
import { es } from 'date-fns/locale';

/**
 * Helpers seguros para manejo de fechas/horas en React Native con Hermes
 * Evita conversiones aritmticas que causan prdida de precisin
 */

/**
 * Convierte un string de hora (HH:mm) a un objeto Date seguro
 * @param timeString - String en formato HH:mm
 * @param baseDate - Fecha base opcional (por defecto hoy)
 * @returns Date con la hora configurada
 */
export const safeTimeStringToDate = (
  timeString: string,
  baseDate?: Date,
): Date => {
  // Validar formato
  if (!timeString || !timeString.match(/^\d{2}:\d{2}$/)) {
    throw new Error('Formato de hora invlido. Use HH:mm');
  }

  const [hourStr, minuteStr] = timeString.split(':');
  const hour = parseInt(hourStr, 10);
  const minute = parseInt(minuteStr, 10);

  // Validar rangos
  if (hour < 0 || hour > 23 || minute < 0 || minute > 59) {
    throw new Error('Hora o minutos fuera de rango');
  }

  // Usar date-fns para operaciones seguras
  let date = baseDate ? new Date(baseDate) : new Date();
  date = setHours(date, hour);
  date = setMinutes(date, minute);
  date.setSeconds(0);
  date.setMilliseconds(0);

  return date;
};

/**
 * Convierte un Date a string de hora (HH:mm) de forma segura
 * @param date - Objeto Date
 * @returns String en formato HH:mm
 */
export const safeDateToTimeString = (date: Date): string => {
  if (!date || !isValid(date)) {
    throw new Error('Fecha invlida');
  }

  return format(date, 'HH:mm');
};

/**
 * Crea una fecha programada combinando fecha y hora de forma segura
 * @param dateStr - String de fecha (yyyy-MM-dd) o Date
 * @param timeStr - String de hora (HH:mm)
 * @returns Date con fecha y hora combinadas
 */
export const createScheduledDateTime = (
  dateStr: string | Date,
  timeStr: string,
): Date => {
  let baseDate: Date;

  if (typeof dateStr === 'string') {
    // Parsear fecha string de forma segura
    baseDate = parse(dateStr, 'yyyy-MM-dd', new Date());
    if (!isValid(baseDate)) {
      throw new Error('Fecha invlida');
    }
  } else {
    baseDate = new Date(dateStr);
  }

  return safeTimeStringToDate(timeStr, baseDate);
};

/**
 * Formatea una fecha para mostrar de forma amigable
 * @param date - Fecha a formatear
 * @param includeTime - Si incluir la hora
 * @returns String formateado
 */
export const formatDateTimeDisplay = (
  date: Date,
  includeTime: boolean = true,
): string => {
  if (!date || !isValid(date)) {
    return '';
  }

  if (includeTime) {
    return format(date, "d 'de' MMMM 'a las' HH:mm", { locale: es });
  }

  return format(date, "d 'de' MMMM 'de' yyyy", { locale: es });
};

/**
 * Obtiene el timestamp de una fecha de forma segura para enviar al backend
 * @param date - Fecha a convertir
 * @returns ISO string seguro
 */
export const getDateTimeForBackend = (date: Date): string => {
  if (!date || !isValid(date)) {
    throw new Error('Fecha invlida para backend');
  }

  // Usar toISOString() que es seguro en Hermes
  return date.toISOString();
};

/**
 * Parsea una fecha del backend de forma segura
 * @param dateStr - String de fecha del backend
 * @returns Date parseado o null si es invlido
 */
export const parseDateFromBackend = (
  dateStr: string | null | undefined,
): Date | null => {
  if (!dateStr) {
    return null;
  }

  try {
    const date = new Date(dateStr);
    return isValid(date) ? date : null;
  } catch {
    return null;
  }
};

/**
 * Redondea minutos al mltiplo de 5 ms cercano
 * @param minutes - Minutos a redondear
 * @returns Minutos redondeados
 */
export const roundMinutesToFive = (minutes: number): number => {
  // Evitar operaciones aritmticas directas
  const quotient = Math.floor(minutes / 5);
  const remainder = minutes - quotient * 5;

  if (remainder >= 3) {
    return (quotient + 1) * 5;
  }

  return quotient * 5;
};

/**
 * Valida si una fecha/hora est en el futuro
 * @param date - Fecha a validar
 * @returns true si est en el futuro
 */
export const isFutureDateTime = (date: Date): boolean => {
  if (!date || !isValid(date)) {
    return false;
  }

  const now = new Date();
  return date.getTime() > now.getTime();
};

/**
 * Obtiene la prxima hora disponible para programacin (redondeada a 5 minutos)
 * @param minimumMinutesAhead - Minutos mnimos en el futuro (default: 30)
 * @returns Date con la prxima hora disponible
 */
export const getNextAvailableTime = (
  minimumMinutesAhead: number = 30,
): Date => {
  const now = new Date();

  // Aadir minutos mnimos
  const futureTime = new Date(now.getTime() + minimumMinutesAhead * 60 * 1000);

  // Redondear minutos
  const roundedMinutes = roundMinutesToFive(futureTime.getMinutes());

  let result = setMinutes(futureTime, roundedMinutes);
  result.setSeconds(0);
  result.setMilliseconds(0);

  // Si el redondeo nos llev al pasado, aadir 5 minutos ms
  if (result.getTime() <= now.getTime()) {
    result = new Date(result.getTime() + 5 * 60 * 1000);
  }

  return result;
};

================
File: app/src/components/index.ts
================
export { AudioRecorderWidget } from './AudioRecorderWidget';
export { AudioOrderModal } from './AudioOrderModal';

================
File: app/src/modules/areasTables/components/AreaFormModal.tsx
================
import React from 'react';
import GenericFormModal, {
  FormFieldConfig,
} from '../../../app/components/crud/GenericFormModal';
import {
  Area,
  CreateAreaDto,
  UpdateAreaDto,
  CreateAreaSchema,
  UpdateAreaSchema,
} from '../schema/area.schema';
import { z } from 'zod';

const areaFormFields: FormFieldConfig<CreateAreaDto | UpdateAreaDto>[] = [
  {
    name: 'name',
    label: 'Nombre del rea',
    type: 'text',
    placeholder: 'Ej: Terraza, Saln Principal',
    required: true,
  },
  {
    name: 'description',
    label: 'Descripcin (Opcional)',
    type: 'textarea',
    placeholder: 'Ej: rea al aire libre con vista',
    numberOfLines: 3,
  },
  {
    name: 'isActive',
    label: 'Est activa?',
    type: 'switch',
    switchLabel: 'Activa',
    defaultValue: true,
  },
];

interface AreaFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSubmit: (
    data: CreateAreaDto | UpdateAreaDto,
    photoId: string | null | undefined,
  ) => Promise<void>;
  editingItem: Area | null;
  isSubmitting: boolean;
}

const AreaFormModal: React.FC<AreaFormModalProps> = ({
  visible,
  onDismiss,
  onSubmit,
  editingItem,
  isSubmitting,
}) => {
  const isEditing = !!editingItem;

  const formSchema = isEditing ? UpdateAreaSchema : CreateAreaSchema;
  const initialValues = isEditing
    ? {
        name: editingItem?.name,
        description: editingItem?.description ?? undefined,
        isActive: editingItem?.isActive,
      }
    : {
        name: '',
        description: undefined,
        isActive: true,
      };

  return (
    <GenericFormModal<CreateAreaDto | UpdateAreaDto, Area>
      visible={visible}
      onDismiss={onDismiss}
      onSubmit={onSubmit}
      formSchema={formSchema as z.ZodSchema<CreateAreaDto | UpdateAreaDto>}
      formFields={areaFormFields}
      initialValues={initialValues}
      editingItem={editingItem}
      isSubmitting={isSubmitting}
      modalTitle={(isEditing) =>
        isEditing ? 'Editar rea' : 'Crear Nueva rea'
      }
    />
  );
};

export default AreaFormModal;

================
File: app/src/modules/areasTables/components/TableFormModal.tsx
================
import React from 'react';
import GenericFormModal, {
  FormFieldConfig,
} from '../../../app/components/crud/GenericFormModal';
import {
  Table,
  CreateTableDto,
  UpdateTableDto,
  CreateTableSchema,
  UpdateTableSchema,
} from '../schema/table.schema';
import { z } from 'zod';

const tableFormFields: FormFieldConfig<CreateTableDto | UpdateTableDto>[] = [
  {
    name: 'name',
    label: 'Nombre de la Mesa',
    type: 'text',
    placeholder: 'Ej: Mesa 1, Barra 2',
    required: true,
  },
  {
    name: 'capacity',
    label: 'Capacidad (Opcional)',
    type: 'number',
    placeholder: 'Ej: 4',
    inputProps: { keyboardType: 'numeric' },
  },
  {
    name: 'isActive',
    label: 'Est activa?',
    type: 'switch',
    switchLabel: 'Activa',
    defaultValue: true,
  },
];

interface TableFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSubmit: (
    data: CreateTableDto | UpdateTableDto,
    photoId: string | null | undefined,
  ) => Promise<void>;
  editingItem: Table | null;
  isSubmitting: boolean;
}

const TableFormModal: React.FC<TableFormModalProps> = ({
  visible,
  onDismiss,
  onSubmit,
  editingItem,
  isSubmitting,
}) => {
  const isEditing = !!editingItem;

  const formSchema = isEditing ? UpdateTableSchema : CreateTableSchema;
  const initialValues = isEditing
    ? {
        name: editingItem?.name,
        capacity: editingItem?.capacity ?? undefined,
        isActive: editingItem?.isActive,
      }
    : {
        name: '',
        capacity: undefined,
        isActive: true,
      };

  return (
    <GenericFormModal<CreateTableDto | UpdateTableDto, Table>
      visible={visible}
      onDismiss={onDismiss}
      onSubmit={onSubmit}
      formSchema={formSchema as z.ZodSchema<CreateTableDto | UpdateTableDto>}
      formFields={tableFormFields}
      initialValues={initialValues}
      editingItem={editingItem}
      isSubmitting={isSubmitting}
      modalTitle={(isEditing) =>
        isEditing ? 'Editar Mesa' : 'Crear Nueva Mesa'
      }
    />
  );
};

export default TableFormModal;

================
File: app/src/modules/areasTables/navigation/types.ts
================
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import type { DrawerScreenProps } from '@react-navigation/drawer';
import { AppDrawerParamList } from '../../../app/navigation/types';

export type AreasTablesStackParamList = {
  AreasList: undefined;
  TablesList: { areaId: string; areaName: string };
};

export type AreasListScreenProps = NativeStackScreenProps<
  AreasTablesStackParamList,
  'AreasList'
>;
export type TablesListScreenProps = NativeStackScreenProps<
  AreasTablesStackParamList,
  'TablesList'
>;

export type AreasTablesDrawerScreenProps = DrawerScreenProps<
  AppDrawerParamList,
  'AreasTablesStack'
>;

================
File: app/src/modules/availability/hooks/useAvailabilityQueries.ts
================
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { availabilityService } from '../services/availabilityService';
import { useSnackbarStore } from '@/app/store/snackbarStore';

export const useMenuAvailability = () => {
  return useQuery({
    queryKey: ['availability', 'menu'],
    queryFn: availabilityService.getMenuAvailability,
  });
};

export const useModifierGroupsAvailability = () => {
  return useQuery({
    queryKey: ['availability', 'modifierGroups'],
    queryFn: availabilityService.getModifierGroupsAvailability,
  });
};

export const useUpdateAvailability = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: availabilityService.updateAvailability,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['availability'] });
      showSnackbar({ message: 'Disponibilidad actualizada', type: 'success' });
    },
    onError: () => {
      showSnackbar({
        message: 'Error al actualizar disponibilidad',
        type: 'error',
      });
    },
  });
};

export const useBulkUpdateAvailability = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: availabilityService.bulkUpdateAvailability,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['availability'] });
      showSnackbar({ message: 'Disponibilidad actualizada', type: 'success' });
    },
    onError: () => {
      showSnackbar({
        message: 'Error al actualizar disponibilidad',
        type: 'error',
      });
    },
  });
};

================
File: app/src/modules/kitchen/context/KitchenContext.tsx
================
import React, {
  createContext,
  useContext,
  useRef,
  MutableRefObject,
} from 'react';

interface KitchenContextType {
  refetchRef: MutableRefObject<(() => void) | null>;
}

const KitchenContext = createContext<KitchenContextType | undefined>(undefined);

export const KitchenProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  const refetchRef = useRef<(() => void) | null>(null);

  return (
    <KitchenContext.Provider value={{ refetchRef }}>
      {children}
    </KitchenContext.Provider>
  );
};

export const useKitchenContext = () => {
  const context = useContext(KitchenContext);
  if (!context) {
    throw new Error('useKitchenContext must be used within a KitchenProvider');
  }
  return context;
};

================
File: app/src/modules/menu/navigation/types.ts
================
export type MenuStackParamList = {
  CategoriesScreen: undefined;
  SubcategoriesScreen: { categoryId: string; categoryName: string };
  Products: { subcategoryId: string; subCategoryName: string };
};

================
File: app/src/modules/modifiers/hooks/useModifierGroupsQuery.ts
================
import {
  useQuery,
  type UseQueryOptions,
  type UseQueryResult,
} from '@tanstack/react-query';
import { modifierGroupService } from '../services/modifierGroupService';
import { ModifierGroup } from '../schema/modifierGroup.schema';
import { ApiError } from '@/app/lib/errors';
import { PaginatedResponse } from '@/app/types/api.types';

const modifierGroupKeys = {
  all: ['modifierGroups'] as const,
  lists: () => [...modifierGroupKeys.all, 'list'] as const,
  list: (filters: FindAllModifierGroupsQuery) =>
    [...modifierGroupKeys.lists(), filters] as const,
};

interface FindAllModifierGroupsQuery {
  page?: number;
  limit?: number;
  isActive?: boolean;
  search?: string;
}

export const useModifierGroupsQuery = (
  filters: FindAllModifierGroupsQuery = {},
  options?: Omit<
    UseQueryOptions<PaginatedResponse<ModifierGroup>, ApiError>,
    'queryKey' | 'queryFn'
  >,
): UseQueryResult<PaginatedResponse<ModifierGroup>, ApiError> => {
  const queryKey = modifierGroupKeys.list(filters);
  return useQuery<PaginatedResponse<ModifierGroup>, ApiError>({
    queryKey: queryKey,
    queryFn: () => modifierGroupService.findAll(filters),
    ...options,
  });
};

================
File: app/src/modules/orderFinalization/navigation/types.ts
================
export type OrderFinalizationStackParamList = {
  OrderFinalizationScreen: undefined;
};

================
File: app/src/modules/orders/components/ShiftStatusBanner.tsx
================
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, Button, ActivityIndicator, Card } from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useAppTheme } from '@/app/styles/theme';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import type { Shift } from '@/services/shifts';

interface ShiftStatusBannerProps {
  shift: Shift | null;
  loading: boolean;
  onOpenShift: () => void;
  canOpenShift: boolean;
}

export const ShiftStatusBanner: React.FC<ShiftStatusBannerProps> = ({
  shift,
  loading,
  onOpenShift,
  canOpenShift,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="small" />
      </View>
    );
  }

  if (!shift || shift.status !== 'OPEN') {
    return (
      <Card style={styles.statusCard} mode="elevated">
        <Card.Content style={styles.closedShiftContent}>
          <View style={styles.iconContainer}>
            <MaterialCommunityIcons
              name="store-clock"
              size={64}
              color={theme.colors.primary}
            />
          </View>

          <Text variant="headlineSmall" style={styles.closedTitle}>
            {canOpenShift ? 'Bienvenido!' : 'Turno Cerrado'}
          </Text>

          <Text variant="bodyLarge" style={styles.closedDescription}>
            {canOpenShift
              ? 'Para comenzar a operar, necesitas abrir el turno.'
              : 'El restaurante an no ha abierto operaciones.'}
          </Text>

          {canOpenShift && (
            <View style={styles.adminInfo}>
              <MaterialCommunityIcons
                name="shield-crown"
                size={20}
                color={theme.colors.primary}
              />
              <Text variant="labelMedium" style={styles.adminText}>
                Como administrador, puedes iniciar las operaciones del turno
              </Text>
            </View>
          )}

          {canOpenShift && (
            <Button
              mode="contained"
              onPress={onOpenShift}
              style={styles.openShiftButton}
              icon="play-circle"
              contentStyle={styles.openShiftButtonContent}
            >
              Abrir Turno
            </Button>
          )}

          {!canOpenShift && (
            <View style={styles.contactInfo}>
              <MaterialCommunityIcons
                name="information"
                size={20}
                color={theme.colors.onSurfaceVariant}
              />
              <Text variant="bodyMedium" style={styles.contactText}>
                Contacta a tu administrador o gerente para iniciar operaciones
              </Text>
            </View>
          )}
        </Card.Content>
      </Card>
    );
  }

  return (
    <Card style={styles.openStatusCard} mode="elevated">
      <Card.Content>
        <View style={styles.statusHeader}>
          <View style={styles.openIconContainer}>
            <MaterialCommunityIcons
              name="store-check"
              size={28}
              color={theme.colors.primary}
            />
          </View>
          <View style={styles.statusHeaderText}>
            <Text variant="titleMedium" style={styles.statusTitle}>
              Turno Activo
            </Text>
            <Text variant="labelMedium" style={styles.statusSubtitle}>
              {format(new Date(shift.date), "EEEE, d 'de' MMMM", {
                locale: es,
              })}
            </Text>
          </View>
        </View>

        <View style={styles.statusInfoGrid}>
          <View style={styles.infoCard}>
            <MaterialCommunityIcons
              name="counter"
              size={20}
              color={theme.colors.primary}
            />
            <Text variant="labelSmall" style={styles.infoCardLabel}>
              Turno Global
            </Text>
            <Text variant="titleMedium" style={styles.infoCardValue}>
              #{shift.globalShiftNumber}
            </Text>
          </View>

          <View style={styles.infoCard}>
            <MaterialCommunityIcons
              name="calendar-today"
              size={20}
              color={theme.colors.primary}
            />
            <Text variant="labelSmall" style={styles.infoCardLabel}>
              Turno de Hoy
            </Text>
            <Text variant="titleMedium" style={styles.infoCardValue}>
              #{shift.shiftNumber}
            </Text>
          </View>

          <View style={styles.infoCard}>
            <MaterialCommunityIcons
              name="account-clock"
              size={20}
              color={theme.colors.primary}
            />
            <Text variant="labelSmall" style={styles.infoCardLabel}>
              Abierto desde
            </Text>
            <Text variant="titleMedium" style={styles.infoCardValue}>
              {format(new Date(shift.openedAt), 'HH:mm', {
                locale: es,
              })}
            </Text>
          </View>
        </View>

        <View style={styles.openedByInfo}>
          <MaterialCommunityIcons
            name="account-circle"
            size={16}
            color={theme.colors.onSurfaceVariant}
          />
          <Text variant="bodySmall" style={styles.openedByText}>
            Abierto por {shift.openedBy.firstName} {shift.openedBy.lastName}
          </Text>
        </View>
      </Card.Content>
    </Card>
  );
};

const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    loadingContainer: {
      padding: theme.spacing.m,
      alignItems: 'center',
    },
    statusCard: {
      margin: theme.spacing.m,
      marginBottom: theme.spacing.l,
      backgroundColor: theme.colors.surface,
      elevation: 4,
    },
    closedShiftContent: {
      alignItems: 'center',
      paddingVertical: theme.spacing.xl,
      paddingHorizontal: theme.spacing.l,
    },
    iconContainer: {
      marginBottom: theme.spacing.l,
      padding: theme.spacing.m,
      borderRadius: 100,
      backgroundColor: theme.colors.primaryContainer,
    },
    closedTitle: {
      color: theme.colors.onSurface,
      fontWeight: '700',
      marginBottom: theme.spacing.s,
      textAlign: 'center',
    },
    closedDescription: {
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
      marginBottom: theme.spacing.l,
      paddingHorizontal: theme.spacing.m,
    },
    adminInfo: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
      backgroundColor: theme.colors.primaryContainer,
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.s,
      borderRadius: theme.roundness * 2,
      marginBottom: theme.spacing.l,
    },
    adminText: {
      color: theme.colors.onPrimaryContainer,
      fontWeight: '500',
    },
    openShiftButton: {
      marginTop: theme.spacing.m,
      paddingHorizontal: theme.spacing.l,
    },
    openShiftButtonContent: {
      paddingVertical: theme.spacing.s,
    },
    contactInfo: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
      backgroundColor: theme.colors.surfaceVariant,
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.s,
      borderRadius: theme.roundness,
      marginTop: theme.spacing.m,
    },
    contactText: {
      color: theme.colors.onSurfaceVariant,
      flex: 1,
    },
    openStatusCard: {
      margin: theme.spacing.m,
      marginBottom: theme.spacing.l,
      backgroundColor: theme.colors.surface,
      elevation: 2,
    },
    statusHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.m,
      marginBottom: theme.spacing.l,
    },
    openIconContainer: {
      padding: theme.spacing.s,
      borderRadius: 50,
      backgroundColor: theme.colors.primaryContainer,
    },
    statusHeaderText: {
      flex: 1,
    },
    statusTitle: {
      color: theme.colors.onSurface,
      fontWeight: '600',
    },
    statusSubtitle: {
      color: theme.colors.onSurfaceVariant,
      textTransform: 'capitalize',
    },
    statusInfoGrid: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      gap: theme.spacing.s,
      marginBottom: theme.spacing.m,
    },
    infoCard: {
      flex: 1,
      backgroundColor: theme.colors.surfaceVariant,
      padding: theme.spacing.m,
      borderRadius: theme.roundness,
      alignItems: 'center',
      gap: theme.spacing.xs,
    },
    infoCardLabel: {
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
    },
    infoCardValue: {
      color: theme.colors.primary,
      fontWeight: '700',
      textAlign: 'center',
    },
    openedByInfo: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
      paddingTop: theme.spacing.s,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
    },
    openedByText: {
      color: theme.colors.onSurfaceVariant,
    },
  });

================
File: app/src/modules/orders/components/SimpleProductDescriptionModal.tsx
================
import React from 'react';
import { StyleSheet, ScrollView } from 'react-native';
import { Portal, Modal, Text, Title } from 'react-native-paper';
import type { Product } from '@/app/schemas/domain/product.schema';
import { useAppTheme } from '@/app/styles/theme';

interface SimpleProductDescriptionModalProps {
  visible: boolean;
  product: Product | null;
  onDismiss: () => void;
}

const SimpleProductDescriptionModal: React.FC<
  SimpleProductDescriptionModalProps
> = ({ visible, product, onDismiss }) => {
  const theme = useAppTheme();

  const styles = StyleSheet.create({
    modal: {
      backgroundColor: theme.colors.background,
      margin: 20,
      padding: 20,
      borderRadius: 8,
      maxHeight: '60%',
    },
    title: {
      fontSize: 20,
      fontWeight: 'bold',
      marginBottom: 16,
      color: theme.colors.onBackground,
    },
    description: {
      fontSize: 16,
      lineHeight: 24,
      color: theme.colors.onSurfaceVariant,
    },
  });

  if (!product || !product.description) return null;

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modal}
      >
        <ScrollView>
          <Title style={styles.title}>{product.name}</Title>
          <Text style={styles.description}>{product.description}</Text>
        </ScrollView>
      </Modal>
    </Portal>
  );
};

export default SimpleProductDescriptionModal;

================
File: app/src/modules/pizzaCustomizations/components/index.ts
================
// Componentes principales usados en screens
export { PizzaProductsTab } from './PizzaProductsTab';
export { PizzaCustomizationsTab } from './PizzaCustomizationsTab';
export { PizzaCustomizationFormModal } from './PizzaCustomizationFormModal';

// Los siguientes componentes son internos y no necesitan ser exportados
// PizzaCustomizationCard - usado solo en PizzaCustomizationsTab
// PizzaConfigurationModal - usado solo en PizzaProductsTab
// AssociatePizzaToppingsModal - usado solo en PizzaProductsTab
// PizzaCustomizationDetailModal - usado solo en PizzaCustomizationsTab

================
File: app/src/modules/pizzaCustomizations/hooks/usePizzaCustomizationsQueries.ts
================
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { pizzaCustomizationsService } from '../services/pizzaCustomizationsService';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import type { FindAllPizzaCustomizationsQuery } from '../schema/pizzaCustomization.schema';

const PIZZA_CUSTOMIZATIONS_QUERY_KEYS = {
  all: ['pizzaCustomizations'] as const,
  lists: () => [...PIZZA_CUSTOMIZATIONS_QUERY_KEYS.all, 'list'] as const,
  list: (params?: FindAllPizzaCustomizationsQuery) =>
    [...PIZZA_CUSTOMIZATIONS_QUERY_KEYS.lists(), params] as const,
  details: () => [...PIZZA_CUSTOMIZATIONS_QUERY_KEYS.all, 'detail'] as const,
  detail: (id: string) =>
    [...PIZZA_CUSTOMIZATIONS_QUERY_KEYS.details(), id] as const,
};

export function usePizzaCustomizationsList(
  params?: FindAllPizzaCustomizationsQuery,
) {
  return useQuery({
    queryKey: PIZZA_CUSTOMIZATIONS_QUERY_KEYS.list(params),
    queryFn: () => pizzaCustomizationsService.findAll(params),
  });
}

export function usePizzaCustomization(id: string) {
  return useQuery({
    queryKey: PIZZA_CUSTOMIZATIONS_QUERY_KEYS.detail(id),
    queryFn: () => pizzaCustomizationsService.findOne(id),
    enabled: !!id,
  });
}

export function useCreatePizzaCustomization() {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: pizzaCustomizationsService.create,
    onSuccess: () => {
      queryClient.invalidateQueries({
        queryKey: PIZZA_CUSTOMIZATIONS_QUERY_KEYS.lists(),
      });
      showSnackbar({
        message: 'Personalizacin creada exitosamente',
        type: 'success',
      });
    },
    onError: (error) => {
      showSnackbar({
        message:
          error instanceof Error
            ? error.message
            : 'Error al crear personalizacin',
        type: 'error',
      });
    },
  });
}

export function useUpdatePizzaCustomization() {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: ({
      id,
      data,
    }: {
      id: string;
      data: Parameters<typeof pizzaCustomizationsService.update>[1];
    }) => pizzaCustomizationsService.update(id, data),
    onSuccess: (data, variables) => {
      queryClient.invalidateQueries({
        queryKey: PIZZA_CUSTOMIZATIONS_QUERY_KEYS.lists(),
      });
      queryClient.invalidateQueries({
        queryKey: PIZZA_CUSTOMIZATIONS_QUERY_KEYS.detail(variables.id),
      });
      showSnackbar({
        message: 'Personalizacin actualizada exitosamente',
        type: 'success',
      });
    },
    onError: (error) => {
      showSnackbar({
        message:
          error instanceof Error
            ? error.message
            : 'Error al actualizar personalizacin',
        type: 'error',
      });
    },
  });
}

export function useDeletePizzaCustomization() {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: pizzaCustomizationsService.remove,
    onSuccess: () => {
      queryClient.invalidateQueries({
        queryKey: PIZZA_CUSTOMIZATIONS_QUERY_KEYS.lists(),
      });
      showSnackbar({
        message: 'Personalizacin eliminada exitosamente',
        type: 'success',
      });
    },
    onError: (error) => {
      showSnackbar({
        message:
          error instanceof Error
            ? error.message
            : 'Error al eliminar personalizacin',
        type: 'error',
      });
    },
  });
}

================
File: app/src/modules/pizzaCustomizations/navigation/PizzaCustomizationsStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { PizzaManagementScreen } from '../screens/PizzaManagementScreen';
import type { PizzaCustomizationsStackParamList } from './types';

const Stack = createNativeStackNavigator<PizzaCustomizationsStackParamList>();

export function PizzaCustomizationsStackNavigator() {
  return (
    <Stack.Navigator
      screenOptions={{
        headerShown: false,
      }}
    >
      <Stack.Screen
        name="PizzaCustomizationsList"
        component={PizzaManagementScreen}
      />
    </Stack.Navigator>
  );
}

================
File: app/src/modules/pizzaCustomizations/navigation/types.ts
================
export type PizzaCustomizationsStackParamList = {
  PizzaCustomizationsList: undefined;
};

================
File: app/src/modules/pizzaCustomizations/screens/PizzaManagementScreen.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, Pressable } from 'react-native';
import { FAB, Text, Icon } from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useAppTheme } from '@/app/styles/theme';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';

// Importar las tabs
import {
  PizzaProductsTab,
  PizzaCustomizationsTab,
  PizzaCustomizationFormModal,
} from '../components';

export function PizzaManagementScreen() {
  const theme = useAppTheme();
  const [selectedTab, setSelectedTab] = useState('products');
  const [formModalVisible, setFormModalVisible] = useState(false);

  // Refrescar datos de pizzas cuando la pantalla recibe foco
  useRefreshModuleOnFocus('pizza-products');
  useRefreshModuleOnFocus('pizza-customizations');

  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    header: {
      backgroundColor: theme.colors.elevation.level2,
      elevation: 0,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    tabsContainer: {
      flexDirection: 'row',
      height: 48,
    },
    tab: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      paddingHorizontal: theme.spacing.m,
      gap: theme.spacing.xs,
    },
    tabActive: {
      borderBottomWidth: 2,
      borderBottomColor: theme.colors.primary,
    },
    tabText: {
      fontSize: 14,
      fontWeight: '500',
      color: theme.colors.onSurfaceVariant,
    },
    tabTextActive: {
      color: theme.colors.primary,
      fontWeight: '600',
    },
    tabIcon: {
      marginRight: 4,
    },
    content: {
      flex: 1,
    },
    fab: {
      position: 'absolute',
      margin: 16,
      right: 0,
      bottom: 0,
      backgroundColor: theme.colors.primary,
    },
  });

  // Renderizar contenido segn tab seleccionada
  const renderContent = () => {
    switch (selectedTab) {
      case 'products':
        return <PizzaProductsTab />;
      case 'customizations':
        return <PizzaCustomizationsTab />;
      default:
        return null;
    }
  };

  return (
    <SafeAreaView style={styles.container} edges={['bottom']}>
      <View style={styles.header}>
        <View style={styles.tabsContainer}>
          <Pressable
            style={[styles.tab, selectedTab === 'products' && styles.tabActive]}
            onPress={() => setSelectedTab('products')}
          >
            <Icon
              source="pizza"
              size={20}
              color={
                selectedTab === 'products'
                  ? theme.colors.primary
                  : theme.colors.onSurfaceVariant
              }
            />
            <Text
              style={[
                styles.tabText,
                selectedTab === 'products' && styles.tabTextActive,
              ]}
            >
              Productos
            </Text>
          </Pressable>

          <Pressable
            style={[
              styles.tab,
              selectedTab === 'customizations' && styles.tabActive,
            ]}
            onPress={() => setSelectedTab('customizations')}
          >
            <Icon
              source="cheese"
              size={20}
              color={
                selectedTab === 'customizations'
                  ? theme.colors.primary
                  : theme.colors.onSurfaceVariant
              }
            />
            <Text
              style={[
                styles.tabText,
                selectedTab === 'customizations' && styles.tabTextActive,
              ]}
            >
              Ingredientes
            </Text>
          </Pressable>
        </View>
      </View>

      <View style={styles.content}>{renderContent()}</View>

      {selectedTab === 'customizations' && (
        <FAB
          icon="plus"
          style={styles.fab}
          onPress={() => setFormModalVisible(true)}
          color={theme.colors.onPrimary}
        />
      )}

      <PizzaCustomizationFormModal
        visible={formModalVisible}
        onDismiss={() => setFormModalVisible(false)}
        onSuccess={() => {
          // La tab se actualizar automticamente cuando reciba el foco
        }}
      />
    </SafeAreaView>
  );
}

================
File: app/src/modules/preparationScreens/navigation/PreparationScreensStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { PreparationScreensStackParamList } from './types';
import PreparationScreensScreen from '../screens/PreparationScreensScreen';
import { useAppTheme } from '../../../app/styles/theme';
import { getStackHeaderOptions } from '../../../app/navigation/options';

const Stack = createNativeStackNavigator<PreparationScreensStackParamList>();

const PreparationScreensStackNavigator = () => {
  const theme = useAppTheme();

  return (
    <Stack.Navigator
      initialRouteName="PreparationScreensList"
      screenOptions={{
        ...getStackHeaderOptions(theme),
      }}
    >
      <Stack.Screen
        name="PreparationScreensList"
        component={PreparationScreensScreen}
        options={{
          title: 'Pantallas de Preparacin',
          headerShown: false,
        }}
      />
    </Stack.Navigator>
  );
};

export default PreparationScreensStackNavigator;

================
File: app/src/modules/preparationScreens/navigation/types.ts
================
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import type { DrawerScreenProps } from '@react-navigation/drawer';
import { AppDrawerParamList } from '../../../app/navigation/types';

// Definir los parmetros para cada pantalla dentro de este Stack Navigator
export type PreparationScreensStackParamList = {
  PreparationScreensList: undefined; // La pantalla de lista no recibe parmetros
};

// Tipos especficos para las props de cada pantalla del Stack
export type PreparationScreensListScreenProps = NativeStackScreenProps<
  PreparationScreensStackParamList,
  'PreparationScreensList'
>;

// Tipo para las props de este Stack cuando se usa dentro del Drawer principal
export type PreparationScreensDrawerScreenProps = DrawerScreenProps<
  AppDrawerParamList,
  'PreparationScreensStack'
>;

================
File: app/src/modules/receipts/navigation/types.ts
================
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { RouteProp } from '@react-navigation/native';

export type ReceiptsStackParamList = {
  ReceiptsList: undefined;
};

export type ReceiptsListScreenNavigationProp = NativeStackNavigationProp<
  ReceiptsStackParamList,
  'ReceiptsList'
>;

export type ReceiptsListScreenRouteProp = RouteProp<
  ReceiptsStackParamList,
  'ReceiptsList'
>;

================
File: app/src/modules/restaurantConfig/components/TimeZoneSelector.tsx
================
import React, { useState, useMemo } from 'react';
import { View, StyleSheet, TouchableOpacity, FlatList } from 'react-native';
import {
  Text,
  Portal,
  Modal,
  Searchbar,
  List,
  Divider,
  Surface,
  IconButton,
} from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useAppTheme, AppTheme } from '@/app/styles/theme';

interface TimeZoneSelectorProps {
  value: string;
  onChange: (timezone: string) => void;
  disabled?: boolean;
}

// Lista de zonas horarias comunes en Amrica
const TIMEZONES = [
  // Mxico
  { value: 'America/Mexico_City', label: 'Ciudad de Mxico', offset: 'UTC-6' },
  { value: 'America/Tijuana', label: 'Tijuana', offset: 'UTC-8' },
  { value: 'America/Cancun', label: 'Cancn', offset: 'UTC-5' },
  { value: 'America/Hermosillo', label: 'Hermosillo', offset: 'UTC-7' },
  { value: 'America/Monterrey', label: 'Monterrey', offset: 'UTC-6' },
  { value: 'America/Mazatlan', label: 'Mazatln', offset: 'UTC-7' },
  { value: 'America/Chihuahua', label: 'Chihuahua', offset: 'UTC-7' },

  // Estados Unidos
  { value: 'America/New_York', label: 'Nueva York', offset: 'UTC-5' },
  { value: 'America/Chicago', label: 'Chicago', offset: 'UTC-6' },
  { value: 'America/Denver', label: 'Denver', offset: 'UTC-7' },
  { value: 'America/Los_Angeles', label: 'Los ngeles', offset: 'UTC-8' },
  { value: 'America/Phoenix', label: 'Phoenix', offset: 'UTC-7' },

  // Centroamrica
  { value: 'America/Guatemala', label: 'Guatemala', offset: 'UTC-6' },
  { value: 'America/El_Salvador', label: 'El Salvador', offset: 'UTC-6' },
  { value: 'America/Tegucigalpa', label: 'Honduras', offset: 'UTC-6' },
  { value: 'America/Managua', label: 'Nicaragua', offset: 'UTC-6' },
  { value: 'America/Costa_Rica', label: 'Costa Rica', offset: 'UTC-6' },
  { value: 'America/Panama', label: 'Panam', offset: 'UTC-5' },

  // Sudamrica
  { value: 'America/Bogota', label: 'Bogot', offset: 'UTC-5' },
  { value: 'America/Lima', label: 'Lima', offset: 'UTC-5' },
  { value: 'America/Quito', label: 'Quito', offset: 'UTC-5' },
  { value: 'America/Caracas', label: 'Caracas', offset: 'UTC-4' },
  { value: 'America/La_Paz', label: 'La Paz', offset: 'UTC-4' },
  { value: 'America/Santiago', label: 'Santiago', offset: 'UTC-3' },
  { value: 'America/Buenos_Aires', label: 'Buenos Aires', offset: 'UTC-3' },
  { value: 'America/Sao_Paulo', label: 'So Paulo', offset: 'UTC-3' },
  { value: 'America/Montevideo', label: 'Montevideo', offset: 'UTC-3' },
  { value: 'America/Asuncion', label: 'Asuncin', offset: 'UTC-3' },

  // Caribe
  { value: 'America/Havana', label: 'La Habana', offset: 'UTC-5' },
  { value: 'America/Santo_Domingo', label: 'Santo Domingo', offset: 'UTC-4' },
  { value: 'America/Puerto_Rico', label: 'Puerto Rico', offset: 'UTC-4' },
];

const TimeZoneSelector: React.FC<TimeZoneSelectorProps> = ({
  value,
  onChange,
  disabled = false,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);
  const [visible, setVisible] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');

  const selectedTimeZone = useMemo(
    () => TIMEZONES.find((tz) => tz.value === value) || TIMEZONES[0],
    [value],
  );

  const filteredTimeZones = useMemo(() => {
    if (!searchQuery.trim()) return TIMEZONES;

    const query = searchQuery.toLowerCase();
    return TIMEZONES.filter(
      (tz) =>
        tz.label.toLowerCase().includes(query) ||
        tz.value.toLowerCase().includes(query) ||
        tz.offset.toLowerCase().includes(query),
    );
  }, [searchQuery]);

  const handleSelect = (timezone: string) => {
    onChange(timezone);
    setVisible(false);
    setSearchQuery('');
  };

  const renderTimeZoneItem = ({ item }: { item: (typeof TIMEZONES)[0] }) => (
    <>
      <List.Item
        title={item.label}
        description={`${item.value} (${item.offset})`}
        onPress={() => handleSelect(item.value)}
        left={(props) => <List.Icon {...props} icon="clock-outline" />}
        right={(props) =>
          item.value === value ? (
            <List.Icon {...props} icon="check" color={theme.colors.primary} />
          ) : null
        }
        style={[styles.listItem, item.value === value && styles.selectedItem]}
        titleStyle={[
          styles.listItemTitle,
          item.value === value && styles.selectedItemText,
        ]}
        descriptionStyle={styles.listItemDescription}
      />
      <Divider />
    </>
  );

  return (
    <>
      <TouchableOpacity
        style={[styles.selector, disabled && styles.selectorDisabled]}
        onPress={() => !disabled && setVisible(true)}
        disabled={disabled}
      >
        <View style={styles.selectorContent}>
          <MaterialCommunityIcons
            name="earth"
            size={24}
            color={
              disabled ? theme.colors.onSurfaceDisabled : theme.colors.primary
            }
          />
          <View style={styles.textContainer}>
            <Text style={[styles.label, disabled && styles.labelDisabled]}>
              Zona Horaria
            </Text>
            <Text style={[styles.value, disabled && styles.valueDisabled]}>
              {selectedTimeZone.label}
            </Text>
            <Text style={[styles.offset, disabled && styles.offsetDisabled]}>
              {selectedTimeZone.offset}
            </Text>
          </View>
          <MaterialCommunityIcons
            name="chevron-down"
            size={24}
            color={
              disabled
                ? theme.colors.onSurfaceDisabled
                : theme.colors.onSurfaceVariant
            }
          />
        </View>
      </TouchableOpacity>

      <Portal>
        <Modal
          visible={visible}
          onDismiss={() => {
            setVisible(false);
            setSearchQuery('');
          }}
          contentContainerStyle={styles.modal}
        >
          <Surface style={styles.modalContent} elevation={3}>
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>Seleccionar Zona Horaria</Text>
              <IconButton
                icon="close"
                size={24}
                onPress={() => {
                  setVisible(false);
                  setSearchQuery('');
                }}
              />
            </View>

            <Searchbar
              placeholder="Buscar zona horaria..."
              onChangeText={setSearchQuery}
              value={searchQuery}
              style={styles.searchbar}
              inputStyle={styles.searchbarInput}
              icon="magnify"
              clearIcon="close"
            />

            <FlatList
              data={filteredTimeZones}
              renderItem={renderTimeZoneItem}
              keyExtractor={(item) => item.value}
              style={styles.list}
              contentContainerStyle={styles.listContent}
              showsVerticalScrollIndicator={true}
              ListEmptyComponent={
                <View style={styles.emptyContainer}>
                  <MaterialCommunityIcons
                    name="magnify-close"
                    size={48}
                    color={theme.colors.onSurfaceVariant}
                  />
                  <Text style={styles.emptyText}>
                    No se encontraron zonas horarias
                  </Text>
                </View>
              }
            />
          </Surface>
        </Modal>
      </Portal>
    </>
  );
};

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    selector: {
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: 12,
      padding: theme.spacing.m,
      borderWidth: 1,
      borderColor: theme.colors.outline,
    },
    selectorDisabled: {
      backgroundColor: theme.colors.surface,
      borderColor: theme.colors.surfaceVariant,
    },
    selectorContent: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.m,
    },
    textContainer: {
      flex: 1,
    },
    label: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 2,
    },
    labelDisabled: {
      color: theme.colors.onSurfaceDisabled,
    },
    value: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    valueDisabled: {
      color: theme.colors.onSurfaceDisabled,
      fontWeight: '500',
    },
    offset: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
    },
    offsetDisabled: {
      color: theme.colors.onSurfaceDisabled,
    },
    modal: {
      margin: theme.spacing.l,
      justifyContent: 'center',
    },
    modalContent: {
      borderRadius: 16,
      maxHeight: '80%',
      backgroundColor: theme.colors.surface,
    },
    modalHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: theme.spacing.l,
      paddingTop: theme.spacing.l,
      paddingBottom: theme.spacing.s,
    },
    modalTitle: {
      fontSize: 20,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    searchbar: {
      marginHorizontal: theme.spacing.l,
      marginBottom: theme.spacing.m,
      elevation: 0,
      backgroundColor: theme.colors.surfaceVariant,
    },
    searchbarInput: {
      fontSize: 14,
    },
    list: {
      maxHeight: 400,
    },
    listContent: {
      paddingBottom: theme.spacing.m,
    },
    listItem: {
      paddingHorizontal: theme.spacing.l,
    },
    selectedItem: {
      backgroundColor: theme.colors.primaryContainer,
    },
    listItemTitle: {
      fontSize: 16,
      color: theme.colors.onSurface,
    },
    selectedItemText: {
      color: theme.colors.primary,
      fontWeight: '600',
    },
    listItemDescription: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    emptyContainer: {
      alignItems: 'center',
      justifyContent: 'center',
      paddingVertical: theme.spacing.xl * 2,
    },
    emptyText: {
      fontSize: 16,
      color: theme.colors.onSurfaceVariant,
      marginTop: theme.spacing.m,
    },
  });

export default TimeZoneSelector;

================
File: app/src/modules/restaurantConfig/navigation/types.ts
================
export type RestaurantConfigStackParamList = {
  RestaurantConfig: undefined;
};

================
File: app/src/modules/users/components/index.ts
================
export * from './UserFormModal';
export * from './UserDetailModal';

================
File: app/.gitignore
================
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files


# Node
node_modules/

# Prebuild
# android/

# ios/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

# Archivos especficos
roo-code-messages.log
repomix-output.txt
bundles.json

# Ignorar carpeta .repomix y su archivo bundles.json
.repomix/
.repomix/bundles.json


*.apk

# Build files
build-*.apk
build-*.aab
build-*.ipa

# Google Play Service Account
google-play-service-account.json

# Temporary files
tmp/
temp/

================
File: app/.prettierrc
================
{
  "semi": true,
  "trailingComma": "all",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2,
  "endOfLine": "lf"
}

================
File: app/docs/guides/BUILD_LOCAL_GUIDE.md
================
# Gua para Builds Locales con EAS

## Instalacin Rpida (Scripts Automatizados)

Esta app incluye scripts automatizados para configurar todo el entorno necesario:

### 1. **Configuracin Completa de Java y Expo**

```bash
cd app
./scripts/install-java.sh
source ~/.bashrc
```

### 2. **Instalacin de Android SDK**

```bash
./scripts/install-android-sdk.sh
source ~/.bashrc
```

### 3. **Verificar el Entorno (Opcional)**

```bash
./scripts/verify-android-setup.sh  # Verifica la configuracin
```

## Requisitos Previos (Instalacin Manual)

### Para Android:

1. **Java Development Kit (JDK)**

   ```bash
   # Instalar OpenJDK 17 (recomendado para React Native)
   sudo apt update
   sudo apt install openjdk-17-jdk
   ```

2. **Android SDK**

   - Opcin 1: Usar el script automatizado `./scripts/install-android-sdk.sh`
   - Opcin 2: Instalar manualmente:

   ```bash
   # Crear directorio para Android SDK
   mkdir -p ~/Android/Sdk
   cd ~/Android/Sdk

   # Descargar herramientas de lnea de comandos
   wget https://dl.google.com/android/repository/commandlinetools-linux-11076708_latest.zip
   unzip commandlinetools-linux-11076708_latest.zip
   mkdir -p cmdline-tools/latest
   mv cmdline-tools/* cmdline-tools/latest/
   ```

3. **Configurar variables de entorno**
   Agrega esto a tu `~/.bashrc` o `~/.zshrc`:

   ```bash
   export JAVA_HOME=/usr/lib/jvm/java-17-openjdk-amd64
   export ANDROID_HOME=$HOME/Android/Sdk
   export ANDROID_SDK_ROOT=$HOME/Android/Sdk
   export PATH=$PATH:$JAVA_HOME/bin
   export PATH=$PATH:$ANDROID_HOME/emulator
   export PATH=$PATH:$ANDROID_HOME/platform-tools
   export PATH=$PATH:$ANDROID_HOME/cmdline-tools/latest/bin
   export PATH=$PATH:$ANDROID_HOME/tools
   export PATH=$PATH:$ANDROID_HOME/tools/bin
   ```

4. **Instalar componentes de Android SDK**

   ```bash
   # Despus de configurar las variables de entorno
   source ~/.bashrc  # o ~/.zshrc

   # Instalar componentes necesarios
   sdkmanager "platform-tools" "platforms;android-34" "build-tools;34.0.0"
   sdkmanager "ndk;25.1.8937393"  # NDK necesario para React Native
   ```

5. **Configurar local.properties**
   ```bash
   echo "sdk.dir=$HOME/Android/Sdk" > android/local.properties
   ```

### Para iOS (solo en macOS):

1. **Xcode**

   - Instala desde App Store
   - Instala las herramientas de lnea de comandos:

   ```bash
   xcode-select --install
   ```

2. **CocoaPods**
   ```bash
   sudo gem install cocoapods
   ```

## Construccin de Builds Locales

### Android

#### APK de Desarrollo (para pruebas):

```bash
cd app
npm run build:android:sim
```

#### APK para Dispositivo:

```bash
npm run build:android:dev
```

#### APK/AAB de Produccin:

```bash
npm run build:android:prod
```

### iOS (solo en macOS)

#### Build para Simulador:

```bash
npm run build:ios:sim
```

#### Build para Dispositivo:

```bash
npm run build:ios:dev
```

#### Build de Produccin:

```bash
npm run build:ios:prod
```

## Proceso de Build

1. **Primera vez**: EAS te pedir autenticarte

   ```bash
   npx eas login
   ```

2. **Durante el build local**:

   - EAS descargar las herramientas necesarias
   - Compilar tu aplicacin localmente
   - El archivo generado estar en la carpeta del proyecto

3. **Ubicacin de los archivos generados**:
   - Android: `build-*.apk` o `build-*.aab`
   - iOS: `build-*.tar.gz` (contiene el .app o .ipa)

## Instalacin en Dispositivos

### Android:

#### Instalar en Dispositivo Fsico:

```bash
# 1. Habilita el modo desarrollador en tu dispositivo Android
# 2. Habilita la depuracin USB
# 3. Conecta el dispositivo por USB
# 4. Verifica que el dispositivo est conectado:
adb devices

# 5. Instalar el APK generado:
adb install build-*.apk
# o especficamente:
adb install build-1748967974325.apk
```

#### Instalar en Emulador:

```bash
# 1. Abrir emulador (si tienes Android Studio):
emulator -avd Pixel_6_API_34  # Reemplaza con el nombre de tu AVD

# 2. Instalar APK:
adb install build-*.apk
```

#### Ejecutar la App con Expo Dev Client:

```bash
# Una vez instalada la build de desarrollo, puedes ejecutar:
npm start

# Esto abrir el servidor de desarrollo de Expo
# Escanea el cdigo QR con la app instalada o presiona 'a' para Android
```

### iOS:

- Para simulador: Arrastra el .app al simulador
- Para dispositivo: Usa Xcode o herramientas como ios-deploy

## Solucin de Problemas

### Error: "ANDROID_HOME not set"

Asegrate de haber configurado las variables de entorno correctamente.

### Error: "SDK location not found"

Crea el archivo `local.properties` en `android/`:

```
sdk.dir=/home/tu-usuario/Android/Sdk
```

### Error de memoria durante el build

Aumenta la memoria de Gradle en `android/gradle.properties`:

```
org.gradle.jvmargs=-Xmx4096m -XX:MaxPermSize=1024m
```

## Notas Importantes

- Las builds locales requieren ms recursos que las builds en la nube
- El primer build descargar muchas dependencias (puede tomar tiempo)
- Asegrate de tener al menos 10GB de espacio libre
- Para produccin, considera usar certificados y keystore apropiados

================
File: app/docs/guides/BUILD_QUICKSTART.md
================
#  Gua Rpida - Builds Locales

## Primera vez (Configuracin)

```bash
# 1. Ejecutar scripts de instalacin
cd app
./scripts/install-java.sh
./scripts/install-android-sdk.sh
source ~/.bashrc

# 2. Instalar EAS CLI y login
npm install -g eas-cli
eas login
```

## Crear Build Local

```bash
# Build de desarrollo para dispositivo Android
npm run build:android:sim

# El APK se generar como: build-[timestamp].apk
```

## Instalar en Dispositivo

```bash
# Ver dispositivos conectados
adb devices

# Instalar APK
adb install build-*.apk
```

## Ejecutar la App

```bash
# Para Expo Go
npx expo start

# Para Development Build (APK instalado)
npx expo start --dev-client

# Si tienes problemas de conexin de red, usa modo tunnel
npx expo start --tunnel          # Para Expo Go
npx expo start --dev-client --tunnel  # Para Development Build
```

**Nota:** El modo tunnel es ms confiable para problemas de red aunque ligeramente ms lento.

## Scripts Disponibles

| Script                            | Descripcin                                    |
| --------------------------------- | ---------------------------------------------- |
| `scripts/install-java.sh`         | Instala Java 17                                |
| `scripts/install-android-sdk.sh`  | Instala Android SDK y configura el entorno     |
| `scripts/verify-android-setup.sh` | Verifica la configuracin del entorno          |
| `scripts/fix-expo-packages.sh`    | Actualiza y corrige versiones de paquetes Expo |

## Comandos de Build

| Comando                      | Descripcin                                 |
| ---------------------------- | ------------------------------------------- |
| `npm run build:android:sim`  | Build para emulador Android                 |
| `npm run build:android:dev`  | Build para dispositivo Android (desarrollo) |
| `npm run build:android:prod` | Build de produccin Android                 |

## Requisitos del Sistema

- Ubuntu/Debian
- Node.js >=18.18.0
- Java JDK 17
- Android SDK con API 34
- ~10GB de espacio libre

## Notas Importantes

- Las variables de entorno de Android SDK pueden no persistir entre sesiones
- Si encuentras errores de SDK, ejecuta `source ~/.bashrc` o crea el archivo `android/local.properties`
- Los builds locales con EAS pueden fallar si no se aceptan todas las licencias del Android SDK

## Troubleshooting

### Error: Cannot determine which native SDK version (expo module not installed)

```bash
# Este error ocurre cuando el mdulo expo no est instalado
# Solucin:
npm install expo
npx expo install --fix
```

### Error: could not determine executable to run (npx eas)

```bash
# Este error ocurre cuando EAS CLI no est instalado
# Solucin:
npm install -g eas-cli
eas login  # En lugar de npx eas login
```

### Java no encontrado

```bash
./scripts/install-java.sh
source ~/.bashrc
```

### Android SDK no encontrado (Build local con EAS)

```bash
# 1. Instalar Android SDK
./scripts/install-android-sdk.sh
source ~/.bashrc

# 2. Si el error persiste, configurar variables en la sesin actual:
export ANDROID_HOME=$HOME/android-sdk
export ANDROID_SDK_ROOT=$HOME/android-sdk
export PATH=$PATH:$ANDROID_HOME/cmdline-tools/latest/bin:$ANDROID_HOME/platform-tools

# 3. Crear local.properties
echo "sdk.dir=$HOME/android-sdk" > android/local.properties

# 4. Alternativa: Usar una shell con las variables cargadas
bash -c "source ~/.bashrc && npm run build:android:sim"

# 5. Si nada funciona, considerar usar build en la nube:
eas build --platform android --profile development  # Sin --local
```

### Dispositivo no detectado

```bash
# Verificar modo desarrollador y depuracin USB
adb devices
adb kill-server
adb start-server
```

### Error: expo doctor failed

```bash
# Este error puede ignorarse si el resto del build funciona
# Es causado por tener carpetas android/ios en un proyecto Expo
# Si necesitas solucionarlo, aade a .gitignore:
/android
/ios
```

## Build Exitosa

Cuando la build sea exitosa vers:

```
Build successful
You can find the build artifacts in app/build-1748967974325.apk
```

================
File: app/docs/guides/EAS_PROJECT_SETUP_GUIDE.md
================
# Gua para Crear un Nuevo Proyecto EAS

Esta gua te ayudar a desvincular el proyecto actual de EAS y crear uno nuevo con el slug "bite-restaurant".

## Prerrequisitos

- Tener instalado EAS CLI: `npm install -g eas-cli`
- Estar logueado en tu cuenta de Expo: `eas login`
- Tener el proyecto React Native/Expo funcionando localmente

## Paso 1: Verificar el Estado Actual del Proyecto

```bash
cd app
eas project:info
```

Esto mostrar informacin sobre el proyecto actual vinculado a EAS (si existe).

## Paso 2: Desvincular el Proyecto Actual

### Opcin A: Limpiar completamente la configuracin (recomendado)

1. Eliminar el ID del proyecto del archivo `app.json`:

   ```json
   {
     "expo": {
       // Eliminar esta lnea si existe:
       "extra": {
         "eas": {
           "projectId": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
         }
       }
     }
   }
   ```

2. Eliminar la carpeta .expo si existe:

   ```bash
   rm -rf .expo
   ```

3. Verificar que no hay archivos de configuracin EAS locales:
   ```bash
   # Estos archivos normalmente no existen, pero verificar por si acaso
   ls -la .easignore .eas.json 2>/dev/null
   ```

## Paso 3: Actualizar app.json con el Nuevo Slug

Editar `app/app.json` y asegurarse de que tenga la configuracin correcta:

```json
{
  "expo": {
    "name": "Bite Restaurant",
    "slug": "bite-restaurant",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "light",
    "splash": {
      "image": "./assets/splash-icon.png",
      "resizeMode": "contain",
      "backgroundColor": "#FF6B6B"
    },
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.biterestaurant.app"
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#FF6B6B"
      },
      "package": "com.biterestaurant.app"
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "plugins": [
      "expo-router",
      [
        "expo-splash-screen",
        {
          "backgroundColor": "#FF6B6B",
          "image": "./assets/splash-icon.png",
          "imageWidth": 200
        }
      ]
    ],
    "experiments": {
      "typedRoutes": true
    },
    "scheme": "bite-restaurant"
  }
}
```

## Paso 4: Crear el Nuevo Proyecto en EAS

```bash
# Inicializar EAS con el nuevo proyecto
eas init

# Si ya tienes un proyecto vinculado, usa:
eas project:init
```

Durante este proceso:

1. EAS detectar el slug "bite-restaurant"
2. Te preguntar si quieres crear un nuevo proyecto
3. Selecciona "Yes" para crear el nuevo proyecto
4. EAS generar un nuevo project ID y lo agregar a tu app.json

## Paso 5: Verificar la Configuracin de EAS

Asegrate de que `app/eas.json` est configurado correctamente:

```json
{
  "cli": {
    "version": ">= 5.2.0"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal",
      "android": {
        "gradleCommand": ":app:assembleDebug"
      },
      "ios": {
        "buildConfiguration": "Debug"
      }
    },
    "preview": {
      "distribution": "internal",
      "android": {
        "buildType": "apk"
      }
    },
    "production": {
      "autoIncrement": true
    }
  },
  "submit": {
    "production": {}
  }
}
```

## Paso 6: Verificar el Nuevo Proyecto

```bash
# Verificar que el proyecto est correctamente vinculado
eas project:info

# Debera mostrar:
# Project: bite-restaurant
# ID: [nuevo-project-id]
# Owner: [tu-usuario]
```

## Paso 7: Configurar los Secretos del Proyecto (Opcional)

Si tu proyecto necesita variables de entorno secretas:

```bash
# Configurar secretos para el nuevo proyecto
eas secret:create --name API_URL --value "https://tu-api.com"
eas secret:create --name OTRO_SECRETO --value "valor-secreto"

# Listar secretos configurados
eas secret:list
```

## Paso 8: Realizar una Build de Prueba

Para verificar que todo est funcionando correctamente:

```bash
# Build de desarrollo para Android
eas build --platform android --profile development

# Build de desarrollo para iOS
eas build --platform ios --profile development
```

## Troubleshooting

### Error: "Project already exists"

Si EAS dice que el proyecto ya existe con ese slug:

1. Intenta con un slug diferente (ej: "bite-restaurant-app")
2. O contacta al soporte de Expo para liberar el slug si es tuyo

### Error: "Invalid project ID"

Si hay problemas con el project ID:

1. Elimina completamente la seccin `extra.eas` de app.json
2. Ejecuta `eas init` nuevamente

### Error: "Authentication required"

Si tienes problemas de autenticacin:

```bash
eas logout
eas login
```

## Notas Importantes

1. **Backup**: Antes de desvincular, asegrate de tener un backup de cualquier configuracin importante
2. **Builds anteriores**: Las builds del proyecto anterior seguirn disponibles en tu cuenta de Expo
3. **Colaboradores**: Si tienes colaboradores, debern actualizar su configuracin local despus del cambio
4. **CI/CD**: Si usas CI/CD, actualiza las variables de entorno con el nuevo project ID

## Comandos tiles

```bash
# Ver todos tus proyectos en EAS
eas project:list

# Ver informacin detallada del proyecto actual
eas project:info

# Ver el estado de las builds
eas build:list

# Cancelar una build en progreso
eas build:cancel [build-id]
```

## Siguiente Paso

Una vez completada la configuracin, puedes continuar con el desarrollo normal:

```bash
# Desarrollo local
npm start

# Crear builds
npm run build:android:dev
npm run build:ios:dev
```

================
File: app/docs/guides/FIRST_UPLOAD_GUIDE.md
================
# Gua para la Primera Subida a Play Store

## Generar y subir tu primer AAB (Android App Bundle)

### 1. Generar el AAB de produccin

```bash
cd app

# Asegrate de estar logueado en EAS
eas login

# Generar el AAB de produccin
eas build --platform android --profile production
```

### 2. Descargar el AAB

Una vez que el build termine (aproximadamente 15-20 minutos):

1. Ve a https://expo.dev y busca tu build
2. Descarga el archivo `.aab`
3. O usa el comando: `eas build:download --platform android`

### 3. Subir a Play Store

En la pantalla que ests viendo:

1. Haz clic en "Subir" (el botn junto a "Suelta los paquetes de aplicaciones aqu para subirlos")
2. Selecciona el archivo `.aab` que descargaste
3. Espera a que se procese

### 4. Completar informacin de la versin

Despus de subir el AAB:

1. **Nombre de la versin**: Se llenar automticamente (ej: "1.0.0")
2. **Notas de la versin**: Escribe algo como:

   ```
   - Versin inicial de Bite
   - Sistema de gestin de restaurante
   - Gestin de pedidos y mesas
   - Impresin trmica
   ```

3. Haz clic en "Guardar"

### 5. Configurar el lanzamiento

1. Ve a "Pruebas"  "Prueba interna"
2. Crea un nuevo lanzamiento
3. Agrega el AAB que subiste
4. Completa las notas de la versin
5. Revisa y lanza

## Importante

- Esta primera subida DEBE hacerse manualmente
- Despus de esta primera subida, podrs usar la automatizacin con EAS Submit
- El AAB debe estar firmado (EAS lo hace automticamente)
- Google Play procesar el AAB y generar APKs optimizados para cada dispositivo

## Prximos pasos

Una vez que hayas subido el primer AAB:

1. Completa todas las secciones requeridas en Play Console:

   - Descripcin de la app
   - Capturas de pantalla
   - Categorizacin
   - Clasificacin de contenido
   - Poltica de privacidad

2. Configura el Service Account para automatizacin futura
3. Usa `npm run release:playstore` para publicaciones futuras

================
File: app/docs/guides/PLAY_STORE_PUBLISHING.md
================
# Gua de Publicacin en Google Play Store

Esta gua te ayudar a publicar tu app Bite en Google Play Store de forma automatizada usando EAS (Expo Application Services).

## Requisitos Previos

1. **Cuenta de Google Play Console** ($25 nico pago)

   - Crear cuenta en: https://play.google.com/console
   - Crear tu primera aplicacin en la consola

2. **Configuracin inicial en Play Console**:

   - Crear aplicacin nueva
   - Completar todas las secciones requeridas:
     - Detalles de la app
     - Clasificacin de contenido
     - Poltica de privacidad
     - Informacin de contacto
   - Subir al menos un APK/AAB manualmente la primera vez

3. **Service Account para automatizacin**:
   - Ve a Play Console  Configuracin  Acceso a API
   - Crear proyecto en Google Cloud Console
   - Habilitar Google Play Android Developer API
   - Crear Service Account con permisos de "Release Manager"
   - Descargar el archivo JSON de credenciales

## Configuracin del Proyecto

### 1. Preparar app.json para produccin

```json
{
  "expo": {
    "name": "Bite",
    "slug": "bite-restaurant",
    "version": "1.0.0",
    "android": {
      "package": "com.tuempresa.bite",
      "versionCode": 1,
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "permissions": []
    }
  }
}
```

### 2. Configurar eas.json para Play Store

```json
{
  "build": {
    "production": {
      "android": {
        "buildType": "app-bundle",
        "env": {
          "API_URL": "https://tu-api-produccion.com"
        }
      }
    }
  },
  "submit": {
    "production": {
      "android": {
        "serviceAccountKeyPath": "./google-play-service-account.json",
        "track": "internal",
        "releaseStatus": "draft",
        "changesNotSentForReview": false
      }
    }
  }
}
```

### 3. Variables de entorno para produccin

Crear archivo `.env.production`:

```
API_URL=https://tu-api-produccion.com
```

## Proceso de Publicacin Automatizado

### Mtodo 1: Script NPM (Recomendado)

Agregar estos scripts a tu `package.json`:

```json
{
  "scripts": {
    "build:prod": "eas build --platform android --profile production",
    "submit:prod": "eas submit --platform android --profile production",
    "release:prod": "npm run build:prod && npm run submit:prod",
    "release:prod:auto": "eas build --platform android --profile production --auto-submit"
  }
}
```

### Mtodo 2: GitHub Actions (CI/CD)

Crear `.github/workflows/release.yml`:

```yaml
name: Release to Play Store

on:
  push:
    tags:
      - 'v*'

jobs:
  build-and-submit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: 18

      - name: Setup Expo
        uses: expo/expo-github-action@v8
        with:
          expo-version: latest
          eas-version: latest
          token: ${{ secrets.EXPO_TOKEN }}

      - name: Install dependencies
        run: npm ci

      - name: Build and Submit
        run: eas build --platform android --profile production --auto-submit --non-interactive
```

## Pasos para Publicar

### Primera vez (configuracin):

```bash
# 1. Login en EAS
eas login

# 2. Configurar el proyecto
eas build:configure

# 3. Guardar el service account JSON
cp ~/Downloads/tu-service-account.json ./google-play-service-account.json

# 4. Agregar a .gitignore
echo "google-play-service-account.json" >> .gitignore
```

### Publicacin regular:

```bash
# Opcin 1: Build y submit por separado
npm run build:prod
# Esperar a que termine el build
npm run submit:prod

# Opcin 2: Todo automatizado
npm run release:prod:auto

# Opcin 3: Con versin especfica
eas build --platform android --profile production --auto-submit --message "Version 1.0.1: Bug fixes"
```

## Configuracin de Tracks en Play Store

- **internal**: Testing interno (recomendado para empezar)
- **alpha**: Testing cerrado
- **beta**: Testing abierto
- **production**: Produccin

Modificar en `eas.json`:

```json
"track": "internal"  // cambiar segn necesites
```

## Automatizacin Completa con Script

Crear `scripts/release-to-playstore.sh`:

```bash
#!/bin/bash

# Colores para output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

echo -e "${YELLOW} Iniciando release a Play Store...${NC}"

# 1. Verificar que estamos en main
BRANCH=$(git rev-parse --abbrev-ref HEAD)
if [ "$BRANCH" != "main" ]; then
    echo " Debes estar en la rama main para hacer release"
    exit 1
fi

# 2. Actualizar version en app.json
echo -e "${YELLOW} Ingresa la nueva versin (actual: $(node -p "require('./app.json').expo.version")):${NC}"
read VERSION

# 3. Actualizar versionCode
CURRENT_VERSION_CODE=$(node -p "require('./app.json').expo.android.versionCode")
NEW_VERSION_CODE=$((CURRENT_VERSION_CODE + 1))

# 4. Actualizar app.json
node -e "
const fs = require('fs');
const appJson = require('./app.json');
appJson.expo.version = '$VERSION';
appJson.expo.android.versionCode = $NEW_VERSION_CODE;
fs.writeFileSync('./app.json', JSON.stringify(appJson, null, 2));
"

echo -e "${GREEN} Versin actualizada a $VERSION (versionCode: $NEW_VERSION_CODE)${NC}"

# 5. Commit cambios
git add app.json
git commit -m "Release v$VERSION"
git tag "v$VERSION"

# 6. Build y submit
echo -e "${YELLOW}  Iniciando build y submit...${NC}"
eas build --platform android --profile production --auto-submit --non-interactive

# 7. Push cambios
git push origin main --tags

echo -e "${GREEN} Release completado!${NC}"
```

Hacer ejecutable:

```bash
chmod +x scripts/release-to-playstore.sh
```

## Tips y Mejores Prcticas

1. **Versionado**: Siempre incrementa `versionCode` para cada build
2. **Testing**: Usa track "internal" primero antes de produccin
3. **Changelogs**: Mantn un CHANGELOG.md actualizado
4. **Assets**: Prepara todos los assets requeridos:
   - Screenshots (mnimo 2)
   - Feature graphic (1024x500)
   - Icono alta resolucin (512x512)
5. **Monitoreo**: Configura Sentry o similar para crashes en produccin

## Troubleshooting

- **Error de permisos**: Verifica que el Service Account tenga rol "Release Manager"
- **Build fallido**: Revisa los logs en https://expo.dev
- **Versin rechazada**: Incrementa `versionCode` e intenta de nuevo

================
File: app/eas.json
================
{
  "cli": {
    "version": ">= 16.3.0",
    "appVersionSource": "remote"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal",
      "android": {
        "buildType": "apk"
      }
    },
    "preview": {
      "distribution": "internal",
      "android": {
        "buildType": "apk"
      },
      "env": {
        "NODE_ENV": "production"
      }
    },
    "production": {
      "autoIncrement": true,
      "android": {
        "buildType": "app-bundle"
      },
      "env": {
        "NODE_ENV": "production"
      }
    },
    "release": {
      "android": {
        "buildType": "apk"
      }
    },
    "production-apk": {
      "autoIncrement": true,
      "android": {
        "buildType": "apk"
      },
      "env": {
        "NODE_ENV": "production"
      }
    }
  },
  "submit": {
    "production": {
      "android": {
        "serviceAccountKeyPath": "./google-play-service-account.json",
        "track": "internal",
        "releaseStatus": "draft",
        "changesNotSentForReview": false
      }
    }
  }
}

================
File: app/index.ts
================
import { registerRootComponent } from 'expo';
import App from './App';

registerRootComponent(App);

================
File: app/ios/pizza/Images.xcassets/AppIcon.appiconset/Contents.json
================
{
  "images": [
    {
      "filename": "App-Icon-1024x1024@1x.png",
      "idiom": "universal",
      "platform": "ios",
      "size": "1024x1024"
    }
  ],
  "info": {
    "version": 1,
    "author": "expo"
  }
}

================
File: app/ios/pizza/Images.xcassets/Contents.json
================
{
  "info": {
    "version": 1,
    "author": "expo"
  }
}

================
File: app/ios/pizza/Images.xcassets/SplashScreenBackground.colorset/Contents.json
================
{
  "colors": [
    {
      "color": {
        "components": {
          "alpha": "1.000",
          "blue": "1.00000000000000",
          "green": "1.00000000000000",
          "red": "1.00000000000000"
        },
        "color-space": "srgb"
      },
      "idiom": "universal"
    }
  ],
  "info": {
    "version": 1,
    "author": "expo"
  }
}

================
File: app/src/app/components/responsive/ResponsiveGrid.tsx
================
import React, { ReactNode, useMemo, Children } from 'react';
import {
  View,
  ViewStyle,
  StyleProp,
  DimensionValue,
  StyleSheet,
} from 'react-native';
import { useResponsive } from '@/app/hooks/useResponsive';

interface ResponsiveGridProps {
  children: ReactNode;
  style?: StyleProp<ViewStyle>;

  // Configuracin de columnas
  columns?: number;
  columnsTablet?: number;
  columnsLandscape?: number;
  minItemWidth?: number;

  // Configuracin de filas
  rows?: number;
  minItemHeight?: number;

  // Espaciado
  gap?: number;
  gapTablet?: number;
  rowGap?: number;
  columnGap?: number;
  padding?: number;

  // Alineacin
  alignItems?: 'flex-start' | 'center' | 'flex-end' | 'stretch';
  justifyContent?:
    | 'flex-start'
    | 'center'
    | 'flex-end'
    | 'space-between'
    | 'space-around'
    | 'space-evenly';

  // Comportamiento
  fillLastRow?: boolean;
  equalHeight?: boolean;

  // Estilos de items
  itemStyle?: StyleProp<ViewStyle>;
  itemPadding?: number;
}

interface GridItemProps {
  children: ReactNode;
  style?: StyleProp<ViewStyle>;
  span?: number;
  spanTablet?: number;
}

// Componente para items del grid
export const GridItem: React.FC<GridItemProps> = ({
  children,
  style,
  span = 1,
  spanTablet,
}) => {
  const responsive = useResponsive();
  const actualSpan = responsive.isTablet && spanTablet ? spanTablet : span;

  return <View style={[{ flex: actualSpan }, style]}>{children}</View>;
};

export const ResponsiveGrid: React.FC<ResponsiveGridProps> = ({
  children,
  style,

  // Columnas
  columns = 1,
  columnsTablet,
  columnsLandscape,
  minItemWidth,

  // Filas
  rows,
  minItemHeight,

  // Espaciado
  gap = 16,
  gapTablet,
  rowGap,
  columnGap,
  padding = 0,

  // Alineacin
  alignItems = 'stretch',
  justifyContent = 'flex-start',

  // Comportamiento
  fillLastRow = false,
  equalHeight = false,

  // Estilos
  itemStyle,
  itemPadding = 0,
}) => {
  const responsive = useResponsive();

  // Calcular nmero de columnas
  const calculateColumns = useMemo(() => {
    // Si hay un ancho mnimo definido, calcular columnas dinmicamente
    if (minItemWidth) {
      return responsive.getGridColumns(minItemWidth, gap, padding);
    }

    // Si estamos en landscape y hay columnas especficas para landscape
    if (responsive.isLandscape && columnsLandscape) {
      return columnsLandscape;
    }

    // Si es tablet y hay columnas especficas para tablet
    if (responsive.isTablet && columnsTablet) {
      return columnsTablet;
    }

    // Columnas por defecto
    return columns;
  }, [
    columns,
    columnsTablet,
    columnsLandscape,
    minItemWidth,
    gap,
    padding,
    responsive,
  ]);

  // Calcular gap responsive
  const actualGap =
    responsive.isTablet && gapTablet !== undefined ? gapTablet : gap;
  const scaledGap = responsive.scaleWidth(actualGap);
  const actualRowGap =
    rowGap !== undefined ? responsive.scaleHeight(rowGap) : scaledGap;
  const actualColumnGap =
    columnGap !== undefined ? responsive.scaleWidth(columnGap) : scaledGap;

  // Procesar children en filas
  const processedChildren = useMemo(() => {
    const childArray = Children.toArray(children);
    const gridRows: ReactNode[][] = [];

    // Agrupar children en filas
    for (let i = 0; i < childArray.length; i += calculateColumns) {
      const row = childArray.slice(i, i + calculateColumns);

      // Si fillLastRow est activo y es la ltima fila incompleta
      if (
        fillLastRow &&
        row.length < calculateColumns &&
        i + calculateColumns >= childArray.length
      ) {
        // Agregar elementos vacos para completar la fila
        while (row.length < calculateColumns) {
          row.push(
            <View key={`empty-${i}-${row.length}`} style={styles.emptySlot} />,
          );
        }
      }

      gridRows.push(row);
    }

    return gridRows;
  }, [children, calculateColumns, fillLastRow]);

  // Estilos del contenedor
  const containerStyle = useMemo(() => {
    const baseStyle: ViewStyle = {
      padding: responsive.scaleWidth(padding),
    };

    // Si se especifica un nmero de filas, establecer altura
    if (rows && minItemHeight) {
      baseStyle.height =
        rows * (minItemHeight + actualRowGap) - actualRowGap + padding * 2;
    }

    return [baseStyle, style];
  }, [padding, rows, minItemHeight, actualRowGap, responsive, style]);

  // Estilos de fila
  const rowStyle = useMemo(() => {
    const style: ViewStyle = {
      flexDirection: 'row',
      justifyContent,
      alignItems,
    };

    if (equalHeight) {
      style.alignItems = 'stretch';
    }

    return style;
  }, [justifyContent, alignItems, equalHeight]);

  // Estilos de item
  const gridItemStyle = useMemo(() => {
    const style: ViewStyle = {
      flex: 1,
      padding: responsive.scaleWidth(itemPadding),
    };

    if (minItemHeight) {
      style.minHeight = responsive.scaleHeight(minItemHeight);
    }

    return [style, itemStyle];
  }, [itemPadding, minItemHeight, responsive, itemStyle]);

  return (
    <View style={containerStyle}>
      {processedChildren.map((row, rowIndex) => (
        <View
          key={`row-${rowIndex}`}
          style={[
            rowStyle,
            rowIndex < processedChildren.length - 1 && {
              marginBottom: actualRowGap,
            },
          ]}
        >
          {row.map((child, colIndex) => (
            <View
              key={`item-${rowIndex}-${colIndex}`}
              style={[
                gridItemStyle,
                colIndex < row.length - 1 && { marginRight: actualColumnGap },
              ]}
            >
              {child}
            </View>
          ))}
        </View>
      ))}
    </View>
  );
};

const styles = StyleSheet.create({
  emptySlot: {
    flex: 1,
  },
});

// Componente alternativo usando flexWrap para grids ms simples
export const ResponsiveFlexGrid: React.FC<ResponsiveGridProps> = ({
  children,
  style,
  columns = 2,
  columnsTablet,
  minItemWidth,
  gap = 16,
  gapTablet,
  padding = 0,
  alignItems = 'stretch',
  justifyContent = 'flex-start',
  itemStyle,
}) => {
  const responsive = useResponsive();

  // Calcular columnas
  const calculateColumns = minItemWidth
    ? responsive.getGridColumns(minItemWidth, gap, padding)
    : responsive.isTablet && columnsTablet
      ? columnsTablet
      : columns;

  // Calcular ancho de cada item
  const itemWidth = `${100 / calculateColumns - (gap * (calculateColumns - 1)) / calculateColumns}%`;
  const actualGap =
    responsive.isTablet && gapTablet !== undefined ? gapTablet : gap;

  const containerStyle: ViewStyle = {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent,
    alignItems,
    padding: responsive.scaleWidth(padding),
    gap: responsive.scaleWidth(actualGap),
  };

  const flexItemStyle: ViewStyle = {
    width: itemWidth as DimensionValue,
    minWidth: minItemWidth || 0,
  };

  return (
    <View style={[containerStyle, style]}>
      {Children.map(children, (child, index) => (
        <View key={index} style={[flexItemStyle, itemStyle]}>
          {child}
        </View>
      ))}
    </View>
  );
};

================
File: app/src/app/components/responsive/ResponsiveImage.tsx
================
import React, { useMemo } from 'react';
import { Image } from 'expo-image';
import { ImageProps } from 'expo-image';
import { StyleProp, ImageStyle } from 'react-native';
import { useResponsive } from '@/app/hooks/useResponsive';

interface ResponsiveImageProps
  extends Omit<ImageProps, 'style' | 'width' | 'height'> {
  style?: StyleProp<ImageStyle>;

  // Dimensiones base
  width?: number;
  height?: number;

  // Dimensiones responsive
  widthMobile?: number;
  widthTablet?: number;
  heightMobile?: number;
  heightTablet?: number;

  // Dimensiones por orientacin
  widthPortrait?: number;
  widthLandscape?: number;
  heightPortrait?: number;
  heightLandscape?: number;

  // Escalado automtico
  autoScale?: boolean;
  minScale?: number;
  maxScale?: number;

  // Aspect ratio
  aspectRatio?: number;
  maintainAspectRatio?: boolean;

  // Tamaos predefinidos
  size?: 'small' | 'medium' | 'large' | 'xlarge';
  sizeTablet?: 'small' | 'medium' | 'large' | 'xlarge';

  // Comportamiento responsive
  fillContainer?: boolean;
  maxWidth?: number | string;
  maxHeight?: number | string;
  minWidth?: number | string;
  minHeight?: number | string;

  // Optimizacin
  enableDPIScaling?: boolean;

  // Estilos condicionales
  mobileStyle?: StyleProp<ImageStyle>;
  tabletStyle?: StyleProp<ImageStyle>;
  portraitStyle?: StyleProp<ImageStyle>;
  landscapeStyle?: StyleProp<ImageStyle>;
}

// Tamaos predefinidos
const PREDEFINED_SIZES = {
  small: { mobile: 40, tablet: 48 },
  medium: { mobile: 80, tablet: 96 },
  large: { mobile: 120, tablet: 160 },
  xlarge: { mobile: 200, tablet: 280 },
};

export const ResponsiveImage: React.FC<ResponsiveImageProps> = ({
  style,

  // Dimensiones
  width,
  height,
  widthMobile,
  widthTablet,
  heightMobile,
  heightTablet,
  widthPortrait,
  widthLandscape,
  heightPortrait,
  heightLandscape,

  // Escalado
  autoScale = true,
  minScale = 0.8,
  maxScale = 1.5,

  // Aspect ratio
  aspectRatio,
  maintainAspectRatio = true,

  // Tamaos predefinidos
  size,
  sizeTablet,

  // Comportamiento
  fillContainer = false,
  maxWidth,
  maxHeight,
  minWidth,
  minHeight,

  // Optimizacin
  enableDPIScaling = true,

  // Estilos condicionales
  mobileStyle,
  tabletStyle,
  portraitStyle,
  landscapeStyle,

  ...imageProps
}) => {
  const responsive = useResponsive();

  // Calcular dimensiones responsive
  const { responsiveWidth, responsiveHeight } = useMemo(() => {
    let finalWidth: number | undefined;
    let finalHeight: number | undefined;

    // Si se usa un tamao predefinido
    if (size || sizeTablet) {
      const currentSize = responsive.isTablet && sizeTablet ? sizeTablet : size;
      if (currentSize) {
        const sizeValue = PREDEFINED_SIZES[currentSize];
        finalWidth = responsive.isTablet ? sizeValue.tablet : sizeValue.mobile;
        finalHeight = finalWidth; // Por defecto, las imgenes predefinidas son cuadradas
      }
    }

    // Dimensiones especficas por dispositivo
    if (responsive.isTablet) {
      finalWidth = widthTablet || width || finalWidth;
      finalHeight = heightTablet || height || finalHeight;
    } else {
      finalWidth = widthMobile || width || finalWidth;
      finalHeight = heightMobile || height || finalHeight;
    }

    // Dimensiones por orientacin (tienen prioridad)
    if (responsive.isPortrait) {
      finalWidth = widthPortrait || finalWidth;
      finalHeight = heightPortrait || finalHeight;
    } else if (responsive.isLandscape) {
      finalWidth = widthLandscape || finalWidth;
      finalHeight = heightLandscape || finalHeight;
    }

    // Aplicar escalado automtico si est habilitado
    if (autoScale && finalWidth) {
      finalWidth = responsive.scaleWithLimits(finalWidth, minScale, maxScale);
    }
    if (autoScale && finalHeight) {
      finalHeight = responsive.scaleWithLimits(finalHeight, minScale, maxScale);
    }

    // Mantener aspect ratio si es necesario
    if (maintainAspectRatio && aspectRatio && finalWidth && !finalHeight) {
      finalHeight = finalWidth / aspectRatio;
    } else if (
      maintainAspectRatio &&
      aspectRatio &&
      finalHeight &&
      !finalWidth
    ) {
      finalWidth = finalHeight * aspectRatio;
    }

    // Aplicar DPI scaling si est habilitado
    if (enableDPIScaling) {
      if (finalWidth) finalWidth = responsive.normalizeDPI(finalWidth);
      if (finalHeight) finalHeight = responsive.normalizeDPI(finalHeight);
    }

    return {
      responsiveWidth: finalWidth,
      responsiveHeight: finalHeight,
    };
  }, [
    width,
    height,
    widthMobile,
    widthTablet,
    heightMobile,
    heightTablet,
    widthPortrait,
    widthLandscape,
    heightPortrait,
    heightLandscape,
    size,
    sizeTablet,
    autoScale,
    minScale,
    maxScale,
    aspectRatio,
    maintainAspectRatio,
    enableDPIScaling,
    responsive,
  ]);

  // Calcular estilos responsive
  const responsiveStyles = useMemo(() => {
    const baseStyle: ImageStyle = {};

    // Aplicar dimensiones calculadas
    if (responsiveWidth) baseStyle.width = responsiveWidth;
    if (responsiveHeight) baseStyle.height = responsiveHeight;

    // Si fillContainer est activo
    if (fillContainer) {
      baseStyle.width = '100%';
      baseStyle.height = '100%';
    }

    // Aplicar lmites
    if (maxWidth) baseStyle.maxWidth = maxWidth as any;
    if (maxHeight) baseStyle.maxHeight = maxHeight as any;
    if (minWidth) baseStyle.minWidth = minWidth as any;
    if (minHeight) baseStyle.minHeight = minHeight as any;

    // Aplicar aspect ratio si no hay altura definida
    if (aspectRatio && !responsiveHeight && !fillContainer) {
      baseStyle.aspectRatio = aspectRatio;
    }

    // Estilos condicionales por dispositivo
    const deviceStyle = responsive.isTablet ? tabletStyle : mobileStyle;

    // Estilos condicionales por orientacin
    const orientationStyle = responsive.isPortrait
      ? portraitStyle
      : landscapeStyle;

    // Combinar todos los estilos
    return [baseStyle, deviceStyle, orientationStyle, style].filter(Boolean);
  }, [
    responsiveWidth,
    responsiveHeight,
    fillContainer,
    maxWidth,
    maxHeight,
    minWidth,
    minHeight,
    aspectRatio,
    mobileStyle,
    tabletStyle,
    portraitStyle,
    landscapeStyle,
    style,
    responsive,
  ]);

  // Props optimizadas para Image
  const optimizedImageProps = useMemo(() => {
    const props: Partial<ImageProps> = {
      ...imageProps,
      style: responsiveStyles,
      cachePolicy: 'memory-disk',
      priority: responsive.isTablet ? 'normal' : 'high',
      contentFit: imageProps.contentFit || 'cover',
    };

    // Solo aplicar quality si la fuente es una URI
    if (
      imageProps.source &&
      typeof imageProps.source === 'object' &&
      'uri' in imageProps.source
    ) {
      props.source = {
        ...imageProps.source,
        // La API de expo-image no soporta quality directamente,
        // pero podemos usar esto para futuras optimizaciones
      };
    }

    return props;
  }, [imageProps, responsiveStyles, responsive.isTablet]);

  return <Image {...optimizedImageProps} />;
};

================
File: app/src/app/components/responsive/ResponsiveView.tsx
================
import React, { ReactNode, useMemo } from 'react';
import {
  View,
  ViewStyle,
  StyleProp,
  ViewProps,
  DimensionValue,
} from 'react-native';
import { useResponsive } from '@/app/hooks/useResponsive';

interface ResponsiveViewProps extends ViewProps {
  children?: ReactNode;
  style?: StyleProp<ViewStyle>;

  // Estilos responsivos por breakpoint
  xsStyle?: ViewStyle;
  smStyle?: ViewStyle;
  mdStyle?: ViewStyle;
  lgStyle?: ViewStyle;
  xlStyle?: ViewStyle;
  xxlStyle?: ViewStyle;

  // Estilos por tipo de dispositivo
  mobileStyle?: ViewStyle;
  tabletStyle?: ViewStyle;

  // Estilos por orientacin
  portraitStyle?: ViewStyle;
  landscapeStyle?: ViewStyle;

  // Props de layout responsive
  direction?: 'row' | 'column' | 'row-reverse' | 'column-reverse';
  directionTablet?: 'row' | 'column' | 'row-reverse' | 'column-reverse';

  // Padding responsive
  padding?: number | 'auto';
  paddingHorizontal?: number | 'auto';
  paddingVertical?: number | 'auto';

  // Margin responsive
  margin?: number | 'auto';
  marginHorizontal?: number | 'auto';
  marginVertical?: number | 'auto';

  // Gap responsive (para flex)
  gap?: number | 'auto';
  gapTablet?: number;

  // Alignment responsive
  align?: 'flex-start' | 'center' | 'flex-end' | 'stretch';
  alignTablet?: 'flex-start' | 'center' | 'flex-end' | 'stretch';
  justify?:
    | 'flex-start'
    | 'center'
    | 'flex-end'
    | 'space-between'
    | 'space-around'
    | 'space-evenly';
  justifyTablet?:
    | 'flex-start'
    | 'center'
    | 'flex-end'
    | 'space-between'
    | 'space-around'
    | 'space-evenly';

  // Flex responsive
  flex?: number;
  flexTablet?: number;
  wrap?: boolean;
  wrapTablet?: boolean;

  // Dimensiones responsive
  width?: number | string | 'auto';
  widthTablet?: number | string | 'auto';
  height?: number | string | 'auto';
  heightTablet?: number | string | 'auto';

  // Max/Min dimensiones
  maxWidth?: number | string;
  maxWidthTablet?: number | string;
  maxHeight?: number | string;
  maxHeightTablet?: number | string;
  minWidth?: number | string;
  minWidthTablet?: number | string;
  minHeight?: number | string;
  minHeightTablet?: number | string;

  // Mostrar/Ocultar segn dispositivo
  hideOnMobile?: boolean;
  hideOnTablet?: boolean;
  hideOnPortrait?: boolean;
  hideOnLandscape?: boolean;
}

export const ResponsiveView: React.FC<ResponsiveViewProps> = ({
  children,
  style,

  // Estilos por breakpoint
  xsStyle,
  smStyle,
  mdStyle,
  lgStyle,
  xlStyle,
  xxlStyle,

  // Estilos por dispositivo
  mobileStyle,
  tabletStyle,

  // Estilos por orientacin
  portraitStyle,
  landscapeStyle,

  // Props de layout
  direction = 'column',
  directionTablet,

  // Padding
  padding,
  paddingHorizontal,
  paddingVertical,

  // Margin
  margin,
  marginHorizontal,
  marginVertical,

  // Gap
  gap,
  gapTablet,

  // Alignment
  align,
  alignTablet,
  justify,
  justifyTablet,

  // Flex
  flex,
  flexTablet,
  wrap = false,
  wrapTablet,

  // Dimensiones
  width,
  widthTablet,
  height,
  heightTablet,

  // Max/Min
  maxWidth,
  maxWidthTablet,
  maxHeight,
  maxHeightTablet,
  minWidth,
  minWidthTablet,
  minHeight,
  minHeightTablet,

  // Visibility
  hideOnMobile = false,
  hideOnTablet = false,
  hideOnPortrait = false,
  hideOnLandscape = false,

  ...restProps
}) => {
  const responsive = useResponsive();

  // Calcular estilos responsivos
  const responsiveStyles = useMemo(() => {
    // Ocultar segn condiciones
    if (
      (hideOnMobile && responsive.isMobile) ||
      (hideOnTablet && responsive.isTablet) ||
      (hideOnPortrait && responsive.isPortrait) ||
      (hideOnLandscape && responsive.isLandscape)
    ) {
      return { display: 'none' } as ViewStyle;
    }

    // Base styles
    const baseStyle: ViewStyle = {
      // Direccin
      flexDirection:
        responsive.isTablet && directionTablet ? directionTablet : direction,

      // Flex
      flex: responsive.isTablet && flexTablet !== undefined ? flexTablet : flex,
      flexWrap:
        responsive.isTablet && wrapTablet !== undefined
          ? wrapTablet
            ? 'wrap'
            : 'nowrap'
          : wrap
            ? 'wrap'
            : 'nowrap',

      // Alignment
      alignItems: responsive.isTablet && alignTablet ? alignTablet : align,
      justifyContent:
        responsive.isTablet && justifyTablet ? justifyTablet : justify,

      // Dimensiones
      width: (responsive.isTablet && widthTablet !== undefined
        ? widthTablet
        : width) as any,
      height: (responsive.isTablet && heightTablet !== undefined
        ? heightTablet
        : height) as DimensionValue,

      // Max/Min
      maxWidth: (responsive.isTablet && maxWidthTablet !== undefined
        ? maxWidthTablet
        : maxWidth) as DimensionValue,
      maxHeight: (responsive.isTablet && maxHeightTablet !== undefined
        ? maxHeightTablet
        : maxHeight) as DimensionValue,
      minWidth: (responsive.isTablet && minWidthTablet !== undefined
        ? minWidthTablet
        : minWidth) as DimensionValue,
      minHeight: (responsive.isTablet && minHeightTablet !== undefined
        ? minHeightTablet
        : minHeight) as DimensionValue,
    };

    // Padding responsive
    if (padding !== undefined) {
      const paddingValue =
        padding === 'auto'
          ? responsive.spacingPreset.m
          : responsive.scaleWidth(padding);
      baseStyle.padding = paddingValue;
    }
    if (paddingHorizontal !== undefined) {
      const paddingValue =
        paddingHorizontal === 'auto'
          ? responsive.spacingPreset.m
          : responsive.scaleWidth(paddingHorizontal);
      baseStyle.paddingHorizontal = paddingValue;
    }
    if (paddingVertical !== undefined) {
      const paddingValue =
        paddingVertical === 'auto'
          ? responsive.spacingPreset.m
          : responsive.scaleHeight(paddingVertical);
      baseStyle.paddingVertical = paddingValue;
    }

    // Margin responsive
    if (margin !== undefined) {
      const marginValue =
        margin === 'auto'
          ? responsive.spacingPreset.m
          : responsive.scaleWidth(margin);
      baseStyle.margin = marginValue;
    }
    if (marginHorizontal !== undefined) {
      const marginValue =
        marginHorizontal === 'auto'
          ? responsive.spacingPreset.m
          : responsive.scaleWidth(marginHorizontal);
      baseStyle.marginHorizontal = marginValue;
    }
    if (marginVertical !== undefined) {
      const marginValue =
        marginVertical === 'auto'
          ? responsive.spacingPreset.m
          : responsive.scaleHeight(marginVertical);
      baseStyle.marginVertical = marginValue;
    }

    // Gap responsive
    if (gap !== undefined || gapTablet !== undefined) {
      const gapValue =
        responsive.isTablet && gapTablet !== undefined
          ? gapTablet
          : gap === 'auto'
            ? responsive.spacingPreset.m
            : gap;
      baseStyle.gap = responsive.scaleWidth(gapValue as number);
    }

    // Aplicar estilos por breakpoint
    const breakpointStyle = responsive.applyResponsiveStyle({
      xs: xsStyle,
      sm: smStyle,
      md: mdStyle,
      lg: lgStyle,
      xl: xlStyle,
      xxl: xxlStyle,
    });

    // Aplicar estilos por dispositivo
    const deviceStyle = responsive.isTablet ? tabletStyle : mobileStyle;

    // Aplicar estilos por orientacin
    const orientationStyle = responsive.isPortrait
      ? portraitStyle
      : landscapeStyle;

    // Combinar todos los estilos
    return [
      baseStyle,
      breakpointStyle,
      deviceStyle,
      orientationStyle,
      style,
    ].filter(Boolean);
  }, [
    responsive,
    style,
    xsStyle,
    smStyle,
    mdStyle,
    lgStyle,
    xlStyle,
    xxlStyle,
    mobileStyle,
    tabletStyle,
    portraitStyle,
    landscapeStyle,
    direction,
    directionTablet,
    padding,
    paddingHorizontal,
    paddingVertical,
    margin,
    marginHorizontal,
    marginVertical,
    gap,
    gapTablet,
    align,
    alignTablet,
    justify,
    justifyTablet,
    flex,
    flexTablet,
    wrap,
    wrapTablet,
    width,
    widthTablet,
    height,
    heightTablet,
    maxWidth,
    maxWidthTablet,
    maxHeight,
    maxHeightTablet,
    minWidth,
    minWidthTablet,
    minHeight,
    minHeightTablet,
    hideOnMobile,
    hideOnTablet,
    hideOnPortrait,
    hideOnLandscape,
  ]);

  return (
    <View style={responsiveStyles} {...restProps}>
      {children}
    </View>
  );
};

// Exportar tambin un componente Row para facilitar layouts horizontales
export const ResponsiveRow: React.FC<ResponsiveViewProps> = (props) => {
  return <ResponsiveView direction="row" {...props} />;
};

// Exportar un componente Column para mantener consistencia
export const ResponsiveColumn: React.FC<ResponsiveViewProps> = (props) => {
  return <ResponsiveView direction="column" {...props} />;
};

================
File: app/src/app/constants/apiErrorCodes.ts
================
export const ERROR_CODES = {
  AUTH_INVALID_CREDENTIALS: 'AUTH_INVALID_CREDENTIALS',
  AUTH_INCORRECT_PASSWORD: 'AUTH_INCORRECT_PASSWORD',
  AUTH_DUPLICATE_EMAIL: 'AUTH_DUPLICATE_EMAIL',
  AUTH_DUPLICATE_USERNAME: 'AUTH_DUPLICATE_USERNAME',
  AUTH_UNAUTHORIZED: 'AUTH_UNAUTHORIZED',
  AUTH_FORBIDDEN: 'AUTH_FORBIDDEN',
  REFRESH_FAILED: 'REFRESH_FAILED',

  VALIDATION_ERROR: 'VALIDATION_ERROR',

  RESOURCE_NOT_FOUND: 'RESOURCE_NOT_FOUND',

  CONFLICT_ERROR: 'CONFLICT_ERROR',
  PRODUCT_NAME_EXISTS: 'PRODUCT_NAME_EXISTS',

  NETWORK_ERROR: 'NETWORK_ERROR',
  API_CLIENT_ERROR: 'API_CLIENT_ERROR',
  INTERNAL_SERVER_ERROR: 'INTERNAL_SERVER_ERROR',
  UNKNOWN_API_ERROR: 'UNKNOWN_API_ERROR',
  UNKNOWN_ERROR: 'UNKNOWN_ERROR',

  UPLOAD_FAILED: 'UPLOAD_FAILED',
  FILE_TOO_LARGE: 'FILE_TOO_LARGE',
} as const;

export type ApiErrorCode = (typeof ERROR_CODES)[keyof typeof ERROR_CODES];

================
File: app/src/app/hooks/useCrudScreenLogic.ts
================
import { useState, useCallback } from 'react';
import { useMutation, useQueryClient, QueryKey } from '@tanstack/react-query';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { getApiErrorMessage } from '@/app/lib/errorMapping';

interface CrudLogicParams {
  entityName: string;
  queryKey: QueryKey;
  deleteMutationFn: (id: string) => Promise<void>;
}

export function useCrudScreenLogic<TItem extends { id: string }>({
  entityName,
  queryKey,
  deleteMutationFn,
}: CrudLogicParams) {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((s) => s.showSnackbar);
  const [isFormModalVisible, setIsFormModalVisible] = useState(false);
  const [isDetailModalVisible, setIsDetailModalVisible] = useState(false);
  const [editingItem, setEditingItem] = useState<TItem | null>(null);
  const [selectedItem, setSelectedItem] = useState<TItem | null>(null);

  const deleteMutation = useMutation({
    mutationFn: deleteMutationFn,
    onSuccess: (_, _deletedId) => {
      queryClient.invalidateQueries({ queryKey });
      showSnackbar({
        message: `${entityName} eliminado con xito`,
        type: 'success',
      });
      handleCloseModals();
    },
    onError: (error) => {
      showSnackbar({
        message: `Error al eliminar ${entityName}: ${getApiErrorMessage(error)}`,
        type: 'error',
      });
    },
  });

  const handleOpenCreateModal = useCallback(() => {
    setEditingItem(null);
    setSelectedItem(null);
    setIsFormModalVisible(true);
    setIsDetailModalVisible(false);
  }, []);

  const handleOpenEditModal = useCallback((item: TItem) => {
    setEditingItem(item);
    setSelectedItem(null);
    setIsFormModalVisible(true);
    setIsDetailModalVisible(false);
  }, []);

  const handleOpenDetailModal = useCallback((item: TItem) => {
    setSelectedItem(item);
    setEditingItem(null);
    setIsDetailModalVisible(true);
    setIsFormModalVisible(false);
  }, []);

  const handleCloseModals = useCallback(() => {
    setIsFormModalVisible(false);
    setIsDetailModalVisible(false);
    setEditingItem(null);
    setSelectedItem(null);
  }, []);


  // Alternative deletion methods for use with ConfirmationModal
  const [deleteConfirmationState, setDeleteConfirmationState] = useState<{
    visible: boolean;
    itemId: string | null;
  }>({
    visible: false,
    itemId: null,
  });

  const showDeleteConfirmation = useCallback((id: string) => {
    setDeleteConfirmationState({ visible: true, itemId: id });
  }, []);

  const hideDeleteConfirmation = useCallback(() => {
    setDeleteConfirmationState({ visible: false, itemId: null });
  }, []);

  const confirmDelete = useCallback(() => {
    if (deleteConfirmationState.itemId) {
      deleteMutation.mutate(deleteConfirmationState.itemId);
      hideDeleteConfirmation();
    }
  }, [deleteConfirmationState.itemId, deleteMutation, hideDeleteConfirmation]);

  return {
    isFormModalVisible,
    isDetailModalVisible,
    editingItem,
    selectedItem,
    isDeleting: deleteMutation.isPending,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
    // Properties for ConfirmationModal integration
    deleteConfirmation: {
      visible: deleteConfirmationState.visible,
      title: 'Confirmar Eliminacin',
      message: `Ests seguro de que deseas eliminar este ${entityName.toLowerCase()}?`,
      onConfirm: confirmDelete,
      onCancel: hideDeleteConfirmation,
      show: showDeleteConfirmation,
    },
  };
}

================
File: app/src/app/lib/errors.ts
================
import { ERROR_CODES, ApiErrorCode } from '../constants/apiErrorCodes';
import { BackendErrorResponse } from '../types/api.types';
import { AxiosError } from 'axios'; // Import AxiosError type

export class ApiError extends Error {
  public readonly code: ApiErrorCode | string;
  public readonly status: number;
  public readonly details?: any;
  public readonly originalMessage: string;

  constructor(
    code: ApiErrorCode | string = ERROR_CODES.UNKNOWN_API_ERROR,
    backendMessage: string = 'Ocurri un error en la API',
    status: number = 500,
    details?: any,
  ) {
    super(backendMessage);
    this.code = code;
    this.status = status;
    this.details = details;
    this.originalMessage = backendMessage;
    this.name = 'ApiError';
    // Mantener compatibilidad con entornos Node/V8
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ApiError);
    }
  }


  /**
   * Creates an ApiError instance from an AxiosError.
   * Extracts relevant information from the Axios error response.
   */
  static fromAxiosError(error: any): ApiError {
    if (error instanceof ApiError) {
      // If it's already an ApiError (e.g., from refresh failure), return it directly
      return error;
    }

    // Use type assertion for better property access
    const axiosError = error as AxiosError;
    const responseData = axiosError.response?.data as
      | BackendErrorResponse
      | any;
    const status = axiosError.response?.status ?? 500;

    // Manejar errores de red especficamente
    if (axiosError.code === 'ERR_NETWORK' || !axiosError.response) {
      return new ApiError(
        ERROR_CODES.NETWORK_ERROR,
        'Error de conexin. Verifica tu conexin a internet e intenta nuevamente.',
        0,
        { originalError: axiosError.message },
      );
    }

    // Manejar timeout
    if (
      axiosError.code === 'ECONNABORTED' ||
      axiosError.message.includes('timeout')
    ) {
      return new ApiError(
        ERROR_CODES.NETWORK_ERROR,
        'La solicitud tard demasiado tiempo. Intenta nuevamente con una conexin ms estable.',
        0,
        { originalError: axiosError.message },
      );
    }

    // Extract error code - check multiple possible locations
    const code =
      responseData?.code ||
      responseData?.error?.code ||
      responseData?.errors?.[0]?.code ||
      ERROR_CODES.UNKNOWN_API_ERROR;

    // Extract error message - check multiple possible locations
    const message =
      responseData?.message ||
      responseData?.error?.message ||
      responseData?.errors?.[0]?.message ||
      axiosError.message ||
      'Error desconocido de la API.';

    // Include full response data as details if no specific 'details' property exists
    const details = responseData?.details ?? responseData;

    // Uses the main constructor signature: code, message, status, details
    return new ApiError(code, message, status, details);
  }

  /**
   * Creates a specific ApiError for refresh token failures.
   */
  static fromRefreshError(error: any): ApiError {
    // Note: Logout logic should primarily reside in the refreshToken function itself

    // Uses the main constructor signature: code, message, status, details
    return new ApiError(
      ERROR_CODES.REFRESH_FAILED, // Specific code for refresh failure - Ensure this exists in ERROR_CODES
      error?.message || 'La sesin ha expirado o no se pudo renovar.', // Message
      401, // Status (force 401)
      error, // Details (original error)
    );
  }
} // End of ApiError class definition

================
File: app/src/app/lib/formatters.ts
================
/**
 * Formatea un nmero como moneda
 * @param amount - Cantidad a formatear
 * @param currency - Cdigo de moneda (por defecto MXN)
 * @returns String formateado como moneda
 */
export function formatCurrency(
  amount: number | null | undefined,
  currency = 'MXN',
): string {
  // Si el valor es null, undefined o NaN, devolver $0.00
  if (amount === null || amount === undefined || isNaN(amount)) {
    return new Intl.NumberFormat('es-MX', {
      style: 'currency',
      currency,
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
    }).format(0);
  }

  return new Intl.NumberFormat('es-MX', {
    style: 'currency',
    currency,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  }).format(amount);
}

================
File: app/src/app/lib/IMAGE_CACHE_GUIDE.md
================
#  Sistema de Cache de Imgenes Optimizado

##  Resumen de Optimizaciones Implementadas

###  **Correcciones Crticas**

1. **Eliminacin de doble resolucin de URLs**

   - Componentes ahora pasan `path` directamente a `AutoImage`
   - `AutoImage` maneja internamente la resolucin con `getImageUrl()`
   - Eliminado uso innecesario de `await getImageUrl()` en componentes

2. **Archivos corregidos:**
   - `GenericDetailModal.tsx`: Usa `imageSource` en lugar de `imageUrl`
   - `CategoriesScreen.tsx`: Pasa `photo.path` directamente al formulario
   - `ProductFormModal.tsx`: Pasa `photo.path` directamente al formulario
   - `SubcategoriesScreen.tsx`: Pasa `photo.path` directamente al formulario

###  **Optimizaciones Implementadas**

#### 1. **Logging Optimizado (Solo Errores)**

```typescript
// Logs reducidos a lo esencial:
- CACHE_MISS_FAILED: Fallo en descarga
- CACHE_CLEANED: Limpieza exitosa (con detalles)
- CACHE_CLEAN_ERROR: Error en limpieza
- CACHE_ITEM_REMOVE_FAILED: Error al remover item
- CACHE_CLEAR_FAILED: Error al limpiar cache
- PREFETCH_FAILED: Fallos en prefetch
```

#### 2. **Retry Logic con Backoff Exponencial**

```typescript
// Configuracin:
- MAX_RETRIES: 3 intentos
- BASE_RETRY_DELAY: 1000ms
- Backoff: 1s, 2s, 4s, 8s...
- Lmite de cache: 500MB (aumentado desde 100MB)
```

#### 3. **Prefetching Inteligente**

```typescript
// Funciones disponibles:
- prefetchImages(): Prefetch genrico
- prefetchMenuImages(): Especfico para mens
- Integracin automtica en useGetFullMenu()
```

#### 4. **Limpieza de Cache Optimizada**

```typescript
// Estrategia mejorada:
- Fase 1: Eliminacin por edad (ms eficiente)
- Fase 2: Eliminacin por tamao (LRU)
- Margen del 10% para evitar limpiezas frecuentes
- Logging detallado con mtricas
```

###  **Impacto en Rendimiento**

#### **Antes:**

-  Doble resolucin de URLs (componente + AutoImage)
-  Sin retry en descargas fallidas
-  Sin prefetch automtico
-  Limpieza bsica de cache
-  Logs excesivos para cada operacin

#### **Despus:**

-  Resolucin nica de URLs (solo AutoImage)
-  Retry automtico con backoff exponencial
-  Prefetch automtico en background
-  Limpieza inteligente con mtricas
-  Logging optimizado (solo errores y operaciones crticas)

###  **Beneficios Esperados**

- **30-50% reduccin** en tiempo de carga de imgenes
- **60-80% reduccin** en uso de ancho de banda
- **Mejor experiencia** en mens largos
- **Mayor confiabilidad** en conexiones inestables
- **Performance mejorada** sin logs innecesarios
- **Lmite de cache aumentado** a 500MB para casos extremos

###  **Uso Recomendado**

#### Para Desarrolladores:

```typescript
//  Correcto - Usar AutoImage con path
<AutoImage source={item.photo?.path} />

//  Incorrecto - No resolver URL manualmente
const imageUrl = await getImageUrl(item.photo.path);
<AutoImage source={imageUrl} />
```

#### Para Prefetch Manual:

```typescript
// Prefetch especfico para mens
await prefetchMenuImages(menuData, {
  maxConcurrent: 3,
  onProgress: (completed, total) => console.log(`${completed}/${total}`),
});
```

###  **Logs de Ejemplo (Solo Errores)**

```
[ImageCache] CACHE_MISS_FAILED: {
  url: "https://api.example.com/image.jpg",
  filename: "abc123.jpg",
  error: "Download failed after all retries"
}

[ImageCache] CACHE_CLEANED: {
  filesDeleted: 45,
  sizeCleaned: "123.45MB",
  totalFilesRemaining: 155,
  totalSizeRemaining: "376.55MB",
  originalSize: "500.00MB",
  spaceFreed: "123.45MB",
  cacheUtilization: "75.3%"
}

[ImageCache] PREFETCH_FAILED: {
  totalImages: 25,
  failed: 2,
  successRate: "92.0%"
}
```

##  **Monitoreo**

Para monitorear el rendimiento del cache, busca en los logs:

- Fallos en `CACHE_MISS_FAILED`
- Limpiezas en `CACHE_CLEANED` para verificar uso de espacio
- Tasas de error en `PREFETCH_FAILED`
- Errores de sistema en `CACHE_*_ERROR`

##  **Activacin**

El sistema est **completamente activado** y funcionando automticamente:

- Cache se inicializa al arrancar la app
- Prefetch se ejecuta automticamente al cargar mens
- Retry funciona automticamente en descargas fallidas
- Limpieza se ejecuta automticamente en segundo plano

================
File: app/src/app/navigation/components/KitchenHeader.tsx
================
import React, { useMemo } from 'react';
import { TouchableOpacity, StyleSheet, View, Text } from 'react-native';
import { Icon, Surface, Checkbox } from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { ConnectionIndicator } from '@/app/components/ConnectionIndicator';
import { KitchenFilterButton } from '@/modules/kitchen/components/KitchenFilterButton';
import { RefreshButton } from '@/modules/kitchen/components/RefreshButton';
import { useAuthStore } from '@/app/store/authStore';
import { useKitchenStore } from '@/modules/kitchen/store/kitchenStore';
import { OrderTypeEnum } from '@/modules/kitchen/schema/kitchen.schema';

interface KitchenHeaderProps {
  onMenuPress: () => void;
}

export const useKitchenHeader = ({ onMenuPress }: KitchenHeaderProps) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const user = useAuthStore((state) => state.user);
  const { filters, setFilters } = useKitchenStore();
  const screenName = user?.preparationScreen?.name || 'Pantalla de Preparacin';

  const getFilterText = () => {
    switch (filters.orderType) {
      case OrderTypeEnum.DINE_IN:
        return '  Mesa';
      case OrderTypeEnum.TAKE_AWAY:
        return '  Llevar';
      case OrderTypeEnum.DELIVERY:
        return '  Domicilio';
      default:
        return '';
    }
  };

  const styles = useMemo(
    () =>
      StyleSheet.create({
        drawerButtonContainer: {
          width: 56,
          height: 56,
          justifyContent: 'center',
          alignItems: 'center',
          marginLeft: 0,
          borderRadius: 28,
        },
        titleContainer: {
          flexDirection: 'row',
          alignItems: 'center',
        },
        headerTitleStyle: {
          ...theme.fonts.titleLarge,
          color: theme.colors.onPrimary,
          fontWeight: 'bold',
          fontSize: responsive.isWeb ? 26 : responsive.isTablet ? 20 : 22,
        },
        filterIndicator: {
          ...theme.fonts.titleMedium,
          fontWeight: '500',
          opacity: 0.9,
          color: theme.colors.onPrimary,
        },
        transparentSurface: {
          backgroundColor: 'transparent',
        },
        headerRightContainer: {
          flexDirection: 'row',
          alignItems: 'center',
        },
        preparedOrdersToggle: {
          flexDirection: 'row',
          alignItems: 'center',
          paddingHorizontal: 12,
          paddingVertical: 8,
          marginRight: 8,
          borderRadius: 20,
        },
        preparedOrdersText: {
          marginLeft: 4,
          color: theme.colors.onPrimary,
        },
        preparedOrdersToggleActive: {
          backgroundColor: 'rgba(255,255,255,0.2)',
        },
        preparedOrdersToggleInactive: {
          backgroundColor: 'transparent',
        },
        preparedOrdersTextWeb: {
          fontSize: 16,
        },
        preparedOrdersTextMobile: {
          fontSize: 14,
        },
        preparedOrdersTextBold: {
          fontWeight: 'bold',
        },
        preparedOrdersTextNormal: {
          fontWeight: 'normal',
        },
      }),
    [theme, responsive],
  );

  const MenuButton = () => (
    <TouchableOpacity
      style={styles.drawerButtonContainer}
      onPress={onMenuPress}
      hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
    >
      <Icon
        source="menu"
        size={responsive.isWeb ? 36 : 32}
        color={theme.colors.onPrimary}
      />
    </TouchableOpacity>
  );

  const Title = () => (
    <Surface elevation={0} style={styles.transparentSurface}>
      <View style={styles.titleContainer}>
        <Text style={styles.headerTitleStyle}>{screenName}</Text>
        {filters.orderType && (
          <Text style={styles.filterIndicator}>{getFilterText()}</Text>
        )}
      </View>
    </Surface>
  );

  const RightActions = () => (
    <View style={styles.headerRightContainer}>
      <TouchableOpacity
        style={[
          styles.preparedOrdersToggle,
          filters.showPrepared
            ? styles.preparedOrdersToggleActive
            : styles.preparedOrdersToggleInactive,
        ]}
        onPress={() =>
          setFilters({
            ...filters,
            showPrepared: !filters.showPrepared,
          })
        }
      >
        <Checkbox
          status={filters.showPrepared ? 'checked' : 'unchecked'}
          onPress={() =>
            setFilters({
              ...filters,
              showPrepared: !filters.showPrepared,
            })
          }
          color={theme.colors.onPrimary}
          uncheckedColor={theme.colors.onPrimary}
        />
        <Text
          style={[
            styles.preparedOrdersText,
            responsive.isWeb
              ? styles.preparedOrdersTextWeb
              : styles.preparedOrdersTextMobile,
            filters.showPrepared
              ? styles.preparedOrdersTextBold
              : styles.preparedOrdersTextNormal,
          ]}
        >
          Mostrar Listas
        </Text>
      </TouchableOpacity>
      <KitchenFilterButton />
      <RefreshButton />
      <ConnectionIndicator />
    </View>
  );

  return {
    MenuButton,
    Title,
    RightActions,
    screenName,
    styles,
  };
};

================
File: app/src/app/navigation/helpers/navigationHelpers.ts
================
import { CommonActions } from '@react-navigation/native';
import { DrawerSection, hasPermission } from '@/app/constants/rolePermissions';

// Todas las rutas disponibles en el drawer en orden
export const ALL_DRAWER_ROUTES: DrawerSection[] = [
  'OrdersStack',
  'ReceiptsStack',
  'OrderFinalizationStack',
  'MenuStack',
  'AvailabilityScreen',
  'ModifiersStack',
  'PizzaCustomizationsStack',
  'PreparationScreensStack',
  'AreasTablesStack',
  'PrintersStack',
  'RestaurantConfigStack',
  'CustomersStack',
  'SyncStack',
  'UsersScreen',
  'ShiftAuditStack',
  'KitchenScreen',
];

// Mapa de rutas a sus pantallas iniciales
export const ROUTE_INITIAL_SCREENS: Record<DrawerSection, string> = {
  OrdersStack: 'Orders',
  ReceiptsStack: 'ReceiptsList',
  OrderFinalizationStack: 'OrderFinalizationScreen',
  MenuStack: 'CategoriesScreen',
  AvailabilityScreen: 'AvailabilityScreen',
  ModifiersStack: 'ModifierGroupsScreen',
  PizzaCustomizationsStack: 'PizzaCustomizationsList',
  PreparationScreensStack: 'PreparationScreensList',
  AreasTablesStack: 'AreasList',
  PrintersStack: 'PrintersList',
  RestaurantConfigStack: 'RestaurantConfig',
  CustomersStack: 'Customers',
  SyncStack: 'SyncStatus',
  UsersScreen: 'UsersScreen',
  ShiftAuditStack: 'ShiftsList',
  KitchenScreen: 'KitchenScreen',
};

// Helper para generar la accin de navegacin
export const generateNavigationAction = (
  targetRoute: DrawerSection,
  userRoleId: number | undefined,
) => {
  // Filtrar rutas basndose en permisos
  const allowedRoutes = ALL_DRAWER_ROUTES.filter((route) =>
    hasPermission(userRoleId, route),
  );

  // Encontrar el ndice de la ruta objetivo
  const targetIndex = allowedRoutes.indexOf(targetRoute);

  if (targetIndex === -1) {
    return null;
  }

  // Construir las rutas con sus estados iniciales
  const routes = allowedRoutes.map((route, index) => {
    const baseRoute = { name: route };

    // Solo agregar state a la ruta activa
    if (index === targetIndex) {
      return {
        ...baseRoute,
        state: {
          routes: [{ name: ROUTE_INITIAL_SCREENS[route] }],
        },
      };
    }

    return baseRoute;
  });

  return CommonActions.reset({
    index: targetIndex,
    routes,
  });
};

================
File: app/src/app/navigation/OrdersStackNavigator.tsx
================
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import OrdersScreen from '../../modules/orders/screens/OrdersScreen';
import CreateOrderScreen from '../../modules/orders/screens/CreateOrderScreen';
import OpenOrdersScreen from '../../modules/orders/screens/OpenOrdersScreen';
import AddProductsToOrderScreen from '../../modules/orders/screens/AddProductsToOrderScreen';

import type { OrdersStackParamList } from './types';
import { useAppTheme } from '../styles/theme';
import { getStackHeaderOptions } from './options';

const Stack = createNativeStackNavigator<OrdersStackParamList>();

function OrdersStackNavigator() {
  const theme = useAppTheme();

  return (
    <Stack.Navigator
      initialRouteName="Orders"
      screenOptions={{
        ...getStackHeaderOptions(theme),
      }}
    >
      <Stack.Screen
        name="Orders"
        component={OrdersScreen}
        options={{ title: 'rdenes' }}
      />
      <Stack.Screen
        name="CreateOrder"
        component={CreateOrderScreen}
        options={{ title: 'Crear Nueva Orden', headerShown: false }}
      />
      <Stack.Screen
        name="OpenOrders"
        component={OpenOrdersScreen}
        options={{ title: 'rdenes Abiertas' }}
      />
      <Stack.Screen
        name="AddProductsToOrder"
        component={AddProductsToOrderScreen}
        options={{ title: 'Aadir Productos', headerShown: false }}
      />
    </Stack.Navigator>
  );
}

export default OrdersStackNavigator;

================
File: app/src/app/schemas/domain/modifier-group.schema.ts
================
import { z } from 'zod';

/**
 * Esquema Zod para validar un objeto ModifierGroup completo.
 * Fuente de verdad centralizada.
 */
export const modifierGroupSchema = z.object({
  id: z.string(),
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().nullable().optional(),
  minSelections: z.number().int().min(0).optional(),
  maxSelections: z.number().int().min(1).optional(),
  isRequired: z.boolean().optional(),
  allowMultipleSelections: z.boolean().optional(),
  isActive: z.boolean().optional(), // Mantener opcional si la API puede no devolverlo siempre
  sortOrder: z.number(),
  // Opcional: Incluir schema de modificadores si es parte del dominio central
  // modifiers: z.array(modifierSchema).optional(),
});

// Tipo TypeScript inferido y exportado centralmente
export type ModifierGroup = z.infer<typeof modifierGroupSchema>;

================
File: app/src/app/schemas/domain/order.schema.ts
================
import { z } from 'zod';
import { adjustmentSchema } from './adjustment.schema';
import { DeliveryInfoSchema } from './delivery-info.schema';
import { tableSchema } from './table.schema';

// Definir enums localmente para evitar dependencias circulares
enum PizzaHalf {
  FULL = 'FULL',
  HALF_1 = 'HALF_1',
  HALF_2 = 'HALF_2',
}

enum CustomizationAction {
  ADD = 'ADD',
  REMOVE = 'REMOVE',
}

// Enum para los estados de la orden
export const orderStatusSchema = z.enum([
  'PENDING',
  'IN_PROGRESS',
  'IN_PREPARATION',
  'READY',
  'DELIVERED',
  'COMPLETED',
  'CANCELLED',
]);
export type OrderStatus = z.infer<typeof orderStatusSchema>;

// Enum para los tipos de orden
export const orderTypeSchema = z.enum(['DINE_IN', 'TAKE_AWAY', 'DELIVERY']);
export type OrderType = z.infer<typeof orderTypeSchema>;

// Schema para los modificadores dentro de un tem de orden
export const orderItemModifierSchema = z.object({
  productModifierId: z.string(),
  modifierName: z.string(),
  price: z.number(),
});
export type OrderItemModifier = z.infer<typeof orderItemModifierSchema>;

// Schema para las personalizaciones de pizza seleccionadas
export const selectedPizzaCustomizationSchema = z.object({
  pizzaCustomizationId: z.string(),
  pizzaCustomization: z
    .object({
      id: z.string(),
      name: z.string(),
      type: z.enum(['FLAVOR', 'INGREDIENT']),
      ingredients: z.string().nullable().optional(),
      toppingValue: z.number(),
      isActive: z.boolean(),
      sortOrder: z.number(),
    })
    .optional(),
  half: z.nativeEnum(PizzaHalf),
  action: z.nativeEnum(CustomizationAction),
});
export type SelectedPizzaCustomization = z.infer<
  typeof selectedPizzaCustomizationSchema
>;

// Schema para un tem individual de la orden
export const orderItemSchema = z.object({
  id: z.string(),
  productId: z.string().uuid(),
  productName: z.string(),
  quantity: z.number().int().positive(),
  unitPrice: z.number(),
  totalPrice: z.number(),
  modifiers: z.array(orderItemModifierSchema),
  variantId: z.string().uuid().nullable().optional(),
  variantName: z.string().nullable().optional(),
  notes: z.string().nullable().optional(),
  selectedPizzaCustomizations: z
    .array(selectedPizzaCustomizationSchema)
    .optional(),
});
export type OrderItem = z.infer<typeof orderItemSchema>;

// Schema para la orden completa
export const orderSchema = z.object({
  id: z.string().uuid(),
  orderNumber: z.string().optional(),
  shiftOrderNumber: z.number().int().positive(),
  orderItems: z.array(z.any()).optional(),
  total: z.union([z.string(), z.number()]).optional(),
  orderStatus: orderStatusSchema,
  orderType: orderTypeSchema,
  createdAt: z.union([z.string().datetime(), z.date()]),
  updatedAt: z.union([z.string().datetime(), z.date()]),
  finalizedAt: z.union([z.string().datetime(), z.date()]).nullable().optional(),
  userId: z.string().uuid().nullable().optional(),
  tableId: z.string().uuid().nullable().optional(),
  notes: z.string().nullable().optional(),
  scheduledAt: z.union([z.string().datetime(), z.date()]).nullable().optional(),
  deliveryInfo: DeliveryInfoSchema,
  user: z.any().optional(),
  table: tableSchema.optional(),
  payments: z.array(z.any()).optional(),
  deletedAt: z.string().nullable().optional(),
  adjustments: z.array(adjustmentSchema).optional(),
  subtotal: z.union([z.string(), z.number()]).optional(),
  isFromWhatsApp: z.boolean().optional().default(false),
  estimatedDeliveryTime: z
    .union([z.string().datetime(), z.date()])
    .nullable()
    .optional(),
});
export type Order = z.infer<typeof orderSchema>;

================
File: app/src/app/schemas/domain/shift.schema.ts
================
import { z } from 'zod';
import { userSchema } from './user.schema';

export const shiftStatusSchema = z.enum(['OPEN', 'CLOSED']);

export const shiftSchema = z.object({
  id: z.string(),
  date: z.string(),
  globalShiftNumber: z.number(),
  shiftNumber: z.number(),
  status: shiftStatusSchema,
  openedAt: z.string(),
  closedAt: z.string().nullable(),
  openedBy: userSchema,
  closedBy: userSchema.nullable(),
  initialCash: z.number(),
  finalCash: z.number().nullable(),
  totalSales: z.number().nullable(),
  totalOrders: z.number().nullable(),
  cashDifference: z.number().nullable(),
  expectedCash: z.number().nullable().optional(),
  notes: z.string().nullable(),
  closeNotes: z.string().nullable(),
  createdAt: z.string().optional(),
  updatedAt: z.string().optional(),
});

export const openShiftDtoSchema = z.object({
  initialCash: z.number(),
  notes: z.string().optional(),
  date: z.string().optional(),
});

export const closeShiftDtoSchema = z.object({
  finalCash: z.number(),
  closeNotes: z.string().optional(),
});

export const paymentMethodSummarySchema = z.object({
  method: z.string(),
  count: z.number(),
  total: z.number(),
});

export const productSummarySchema = z.object({
  productName: z.string(),
  quantity: z.number(),
  total: z.number(),
});

export const orderItemSchema = z.object({
  id: z.string(),
  productName: z.string(),
  quantity: z.number(),
  unitPrice: z.number(),
  total: z.number(),
  modifiers: z.array(z.string()).optional(),
});

export const shiftOrderSchema = z.object({
  id: z.string(),
  orderNumber: z.string(),
  total: z.number(),
  status: z.string(),
  paymentMethod: z.string(),
  customerName: z.string().nullable(),
  createdAt: z.string(),
  items: z.array(orderItemSchema),
});

export const shiftSummarySchema = z.object({
  shift: shiftSchema,
  ordersCount: z.number(),
  totalSales: z.number(),
  paymentMethodsSummary: z.array(paymentMethodSummarySchema),
  productsSummary: z.array(productSummarySchema),
});

export type Shift = z.infer<typeof shiftSchema>;
export type ShiftStatus = z.infer<typeof shiftStatusSchema>;
export type OpenShiftDto = z.infer<typeof openShiftDtoSchema>;
export type CloseShiftDto = z.infer<typeof closeShiftDtoSchema>;
export type PaymentMethodSummary = z.infer<typeof paymentMethodSummarySchema>;
export type ProductSummary = z.infer<typeof productSummarySchema>;
export type OrderItem = z.infer<typeof orderItemSchema>;
export type ShiftOrder = z.infer<typeof shiftOrderSchema>;
export type ShiftSummary = z.infer<typeof shiftSummarySchema>;

================
File: app/src/app/schemas/domain/subcategory.schema.ts
================
import { z } from 'zod';
import { photoSchema } from './photo.schema'; // Importar schema de Photo centralizado

/**
 * Esquema Zod para validar un objeto SubCategory completo.
 * Fuente de verdad centralizada.
 */
export const subCategorySchema = z.object({
  id: z.string(),
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().nullable().optional(),
  isActive: z.boolean(),
  categoryId: z.string().min(1, 'El ID de categora no es vlido'),
  sortOrder: z.number(),
  photo: photoSchema.nullable().optional(), // Usar photoSchema centralizado
  // Opcional: Incluir productos si es relevante en el dominio general
  // products: z.array(productSchema).optional(),
  createdAt: z.union([z.string().datetime(), z.date()]).optional(), // Incluido desde la interfaz original
  updatedAt: z.union([z.string().datetime(), z.date()]).optional(), // Incluido desde la interfaz original
});

// Tipo TypeScript inferido y exportado centralmente
export type SubCategory = z.infer<typeof subCategorySchema>;

================
File: app/src/app/schemas/domain/user.schema.ts
================
import { z } from 'zod';

// Enums
export enum GenderEnum {
  MALE = 'male',
  FEMALE = 'female',
  OTHER = 'other',
}

export enum RoleEnum {
  ADMIN = 1,
  MANAGER = 2,
  CASHIER = 3,
  WAITER = 4,
  KITCHEN = 5,
  DELIVERY = 6,
}

// Esquema para contacto de emergencia
export const emergencyContactSchema = z
  .object({
    name: z.string().optional(),
    phone: z.string().optional(),
    relationship: z.string().optional(),
  })
  .optional()
  .nullable();

// Esquema para rol
export const roleSchema = z.object({
  id: z.number(),
  name: z.string().optional(),
});

// Esquema para pantalla de preparacin
export const userPreparationScreenSchema = z
  .object({
    id: z.string(),
    name: z.string(),
    description: z.string().nullable().optional(),
  })
  .optional()
  .nullable();

// Esquema principal del usuario
export const userSchema = z.object({
  id: z.string().uuid(),
  email: z.string().email().nullable().optional(),
  username: z.string().min(1, 'El nombre de usuario es requerido'),
  firstName: z.string().nullable().optional(),
  lastName: z.string().nullable().optional(),
  birthDate: z.string().nullable().optional(),
  gender: z.nativeEnum(GenderEnum).nullable().optional(),
  phoneNumber: z.string().nullable().optional(),
  address: z.string().nullable().optional(),
  city: z.string().nullable().optional(),
  state: z.string().nullable().optional(),
  country: z.string().nullable().optional(),
  zipCode: z.string().nullable().optional(),
  emergencyContact: emergencyContactSchema,
  isActive: z.boolean(),
  role: roleSchema.optional(),
  preparationScreen: userPreparationScreenSchema,
  createdAt: z.string(),
  updatedAt: z.string(),
});

// Tipos TypeScript inferidos y exportados centralmente
export type User = z.infer<typeof userSchema>;
export type Role = z.infer<typeof roleSchema>;
export type EmergencyContact = z.infer<typeof emergencyContactSchema>;
export type UserPreparationScreen = z.infer<typeof userPreparationScreenSchema>;

================
File: app/src/app/styles/theme.ts
================
import { MD3LightTheme, MD3DarkTheme, useTheme } from 'react-native-paper';
import type { MD3Typescale } from 'react-native-paper/lib/typescript/types';
import { lightColors, darkColors } from './colors';
import { typography } from './typography';
import { BREAKPOINTS, DEVICE_TYPES, RESPONSIVE_DIMENSIONS } from './responsive';

declare global {
  namespace ReactNativePaper {
    interface MD3Colors {
      success: string;
      successContainer: string;
      onSuccessContainer: string;
      warning: string;
      warningContainer: string;
      onWarningContainer: string;
      info: string;
      infoContainer: string;
      onInfoContainer: string;
    }
  }
}

const spacing = {
  xxxs: 1,
  xxs: 2,
  xs: 4,
  s: 8,
  m: 16,
  l: 24,
  xl: 32,
  xxl: 40,
};

// Sistema responsive integrado con el tema
const responsive = {
  breakpoints: BREAKPOINTS,
  deviceTypes: DEVICE_TYPES,
  dimensions: RESPONSIVE_DIMENSIONS,
};

const typescale: MD3Typescale = {
  default: {
    fontFamily: typography.bodyMedium.fontFamily,
    fontWeight: 'normal',
    letterSpacing: typography.bodyMedium.letterSpacing,
  },
  displayLarge: { ...typography.displayLarge, fontWeight: 'normal' },
  displayMedium: { ...typography.displayMedium, fontWeight: 'normal' },
  displaySmall: { ...typography.displaySmall, fontWeight: 'normal' },
  headlineLarge: { ...typography.headlineLarge, fontWeight: 'normal' },
  headlineMedium: { ...typography.headlineMedium, fontWeight: 'normal' },
  headlineSmall: { ...typography.headlineSmall, fontWeight: 'normal' },
  titleLarge: { ...typography.titleLarge, fontWeight: 'normal' },
  titleMedium: { ...typography.titleMedium, fontWeight: '500' },
  titleSmall: { ...typography.titleSmall, fontWeight: '500' },
  bodyLarge: { ...typography.bodyLarge, fontWeight: 'normal' },
  bodyMedium: { ...typography.bodyMedium, fontWeight: 'normal' },
  bodySmall: { ...typography.bodySmall, fontWeight: 'normal' },
  labelLarge: { ...typography.labelLarge, fontWeight: '500' },
  labelMedium: { ...typography.labelMedium, fontWeight: '500' },
  labelSmall: { ...typography.labelSmall, fontWeight: '500' },
};

export const lightTheme = {
  ...MD3LightTheme,
  colors: {
    ...MD3LightTheme.colors,
    ...lightColors,
  },
  fonts: typescale,
  spacing,
  responsive,
  roundness: 8,
};

export const darkTheme = {
  ...MD3DarkTheme,
  colors: {
    ...MD3DarkTheme.colors,
    ...darkColors,
  },
  fonts: typescale,
  spacing,
  responsive,
  roundness: 8,
};

export type AppTheme = typeof lightTheme;

export const useAppTheme = () => {
  try {
    const theme = useTheme();
    // Verificar que el tema sea un objeto vlido
    if (!theme || typeof theme !== 'object') {
      return lightTheme;
    }
    return theme as AppTheme;
  } catch (error) {
    return lightTheme;
  }
};

================
File: app/src/app/types/api.types.ts
================
import { z } from 'zod';

export interface BackendErrorResponse {
  statusCode: number;
  code: string;
  message: string;
  details?: any;
  timestamp?: string;
  path?: string;
}


export interface PaginatedResponse<T> {
  data: T[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

================
File: app/src/app/types/query.types.ts
================
import { z } from 'zod';

export const baseListQuerySchema = z.object({
  page: z.coerce.number().int().positive().optional().default(1),
  limit: z.coerce.number().int().positive().optional().default(10),
  search: z.string().optional(),
});

export type BaseListQuery = z.infer<typeof baseListQuerySchema>;

================
File: app/src/app/types/theme.types.ts
================
import { z } from 'zod';
import { MD3Theme } from 'react-native-paper';

export const themePreferenceSchema = z.enum(['light', 'dark', 'system']);
export type ThemePreference = z.infer<typeof themePreferenceSchema>;

export const THEME_PREFERENCE_STORAGE_KEY = 'app_theme_preference';

export const THEME_MODE = {
  LIGHT: 'light',
  DARK: 'dark',
  SYSTEM: 'system',
} as const;

export interface AppTheme extends MD3Theme {}

export interface ThemeState {
  preference: ThemePreference;
  setPreference: (preference: ThemePreference) => void;
}

================
File: app/src/hooks/useGoogleMapsConfig.ts
================
import { useState, useEffect } from 'react';
import { appConfigService } from '../services/appConfig';
import { GOOGLE_MAPS_CONFIG } from '../modules/customers/constants/maps.config';

export interface GoogleMapsConfigWithApiKey {
  apiKey: string;
  defaultCenter: {
    lat: number;
    lng: number;
  };
  defaultZoom: number;
  locationZoom: number;
  mapOptions: {
    disableDefaultUI: boolean;
    zoomControl: boolean;
    mapTypeControl: boolean;
    scaleControl: boolean;
    streetViewControl: boolean;
    rotateControl: boolean;
    fullscreenControl: boolean;
    clickableIcons: boolean;
  };
}

export function useGoogleMapsConfig() {
  const [config, setConfig] = useState<GoogleMapsConfigWithApiKey | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function loadConfig() {
      try {
        const apiKey = await appConfigService.getMapsApiKey();
        setConfig({
          ...GOOGLE_MAPS_CONFIG,
          apiKey,
        });
      } catch (err) {
        setError('No se pudo cargar la configuracin de mapas');
      } finally {
        setLoading(false);
      }
    }

    loadConfig();
  }, []);

  return { config, loading, error };
}

================
File: app/src/hooks/useSnackbar.ts
================
import { useSnackbarStore, SnackbarType } from '../app/store/snackbarStore';

export function useSnackbar() {
  const { showSnackbar: show, hideSnackbar } = useSnackbarStore();

  const showSnackbar = (
    message: string,
    type: SnackbarType = 'info',
    duration?: number,
  ) => {
    show({ message, type, duration });
  };

  return {
    showSnackbar,
    hideSnackbar,
  };
}

================
File: app/src/modules/areasTables/navigation/AreasTablesStackNavigator.tsx
================
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { AreasTablesStackParamList } from './types';
import AreasScreen from '../screens/AreasScreen';
import TablesScreen from '../screens/TablesScreen';
import { useAppTheme } from '../../../app/styles/theme';
import { getStackHeaderOptions } from '../../../app/navigation/options';

const Stack = createNativeStackNavigator<AreasTablesStackParamList>();

const AreasTablesStackNavigator = () => {
  const theme = useAppTheme();

  return (
    <Stack.Navigator
      initialRouteName="AreasList"
      screenOptions={{
        ...getStackHeaderOptions(theme),
      }}
    >
      <Stack.Screen
        name="AreasList"
        component={AreasScreen}
        options={{
          title: 'reas',
        }}
      />
      <Stack.Screen
        name="TablesList"
        component={TablesScreen}
        options={({ route }) => ({
          title: `Mesas de ${route.params.areaName || 'rea'}`,
        })}
      />
    </Stack.Navigator>
  );
};

export default AreasTablesStackNavigator;

================
File: app/src/modules/availability/schema/availability.schema.ts
================
import { z } from 'zod';

const availabilityBaseSchema = z.object({
  id: z.string().uuid(),
  name: z.string(),
  isActive: z.boolean(),
});

export const categoryAvailabilitySchema = availabilityBaseSchema.extend({
  subcategories: z.array(z.lazy(() => subcategoryAvailabilitySchema)),
});

export const subcategoryAvailabilitySchema = availabilityBaseSchema.extend({
  categoryId: z.string().uuid(),
  products: z.array(z.lazy(() => productAvailabilitySchema)),
});

export const productAvailabilitySchema = availabilityBaseSchema.extend({
  subcategoryId: z.string().uuid(),
  modifierGroups: z
    .array(z.lazy(() => modifierGroupAvailabilitySchema))
    .optional(),
});

export const modifierGroupAvailabilitySchema = availabilityBaseSchema.extend({
  modifiers: z.array(z.lazy(() => modifierAvailabilitySchema)),
});

export const modifierAvailabilitySchema = availabilityBaseSchema.extend({
  modifierGroupId: z.string().uuid(),
});

export const pizzaCustomizationAvailabilitySchema =
  availabilityBaseSchema.extend({
    type: z.enum(['FLAVOR', 'INGREDIENT']),
    sortOrder: z.number(),
  });

export const pizzaCustomizationGroupAvailabilitySchema = z.object({
  type: z.string(),
  items: z.array(pizzaCustomizationAvailabilitySchema),
});

export const availabilityUpdatePayloadSchema = z.object({
  type: z.enum([
    'category',
    'subcategory',
    'product',
    'modifierGroup',
    'modifier',
    'pizzaCustomization',
  ]),
  id: z.string().uuid(),
  isActive: z.boolean(),
  cascade: z.boolean().optional(),
});

export const availabilityFilterSchema = z.object({
  search: z.string().optional(),
  showOnlyUnavailable: z.boolean().optional(),
  categoryId: z.string().uuid().optional(),
  subcategoryId: z.string().uuid().optional(),
});

export type CategoryAvailability = z.infer<typeof categoryAvailabilitySchema>;
export type SubcategoryAvailability = z.infer<
  typeof subcategoryAvailabilitySchema
>;
export type ProductAvailability = z.infer<typeof productAvailabilitySchema>;
export type ModifierGroupAvailability = z.infer<
  typeof modifierGroupAvailabilitySchema
>;
export type ModifierAvailability = z.infer<typeof modifierAvailabilitySchema>;
export type PizzaCustomizationAvailability = z.infer<
  typeof pizzaCustomizationAvailabilitySchema
>;
export type PizzaCustomizationGroupAvailability = z.infer<
  typeof pizzaCustomizationGroupAvailabilitySchema
>;
export type AvailabilityUpdatePayload = z.infer<
  typeof availabilityUpdatePayloadSchema
>;
export type AvailabilityFilter = z.infer<typeof availabilityFilterSchema>;

================
File: app/src/modules/customers/constants/maps.config.ts
================
// Configuracin para Google Maps
export const GOOGLE_MAPS_CONFIG = {
  // Centro por defecto para Mxico
  defaultCenter: {
    lat: 23.6345,
    lng: -102.5528,
  },

  // Configuracin de zoom
  defaultZoom: 5,
  locationZoom: 16,

  // Opciones del mapa
  mapOptions: {
    disableDefaultUI: false,
    zoomControl: true,
    mapTypeControl: false,
    scaleControl: false,
    streetViewControl: false,
    rotateControl: false,
    fullscreenControl: false,
    clickableIcons: false,
  },
};

================
File: app/src/modules/kitchen/components/RefreshButton.tsx
================
import React, { useState } from 'react';
import { View, TouchableOpacity, Animated, StyleSheet } from 'react-native';
import { ActivityIndicator } from 'react-native-paper';
import { MaterialCommunityIcons as Icon } from '@expo/vector-icons';
import { useKitchenContext } from '../context/KitchenContext';

export const RefreshButton: React.FC = () => {
  const { refetchRef } = useKitchenContext();
  const [isRefreshing, setIsRefreshing] = useState(false);
  const scaleAnim = new Animated.Value(1);

  const handleRefresh = async () => {
    if (refetchRef.current && !isRefreshing) {
      // Animacin de presin
      Animated.sequence([
        Animated.timing(scaleAnim, {
          toValue: 0.9,
          duration: 100,
          useNativeDriver: true,
        }),
        Animated.timing(scaleAnim, {
          toValue: 1,
          duration: 100,
          useNativeDriver: true,
        }),
      ]).start();

      setIsRefreshing(true);
      try {
        await refetchRef.current();
      } finally {
        setTimeout(() => setIsRefreshing(false), 500);
      }
    }
  };

  return (
    <Animated.View
      style={[styles.container, { transform: [{ scale: scaleAnim }] }]}
    >
      <TouchableOpacity
        style={[styles.button, isRefreshing && styles.buttonRefreshing]}
        onPress={handleRefresh}
        disabled={isRefreshing}
        activeOpacity={0.8}
      >
        <View style={styles.iconContainer}>
          {isRefreshing ? (
            <ActivityIndicator size={26} color="white" />
          ) : (
            <Icon name="refresh" size={26} color="white" />
          )}
        </View>
      </TouchableOpacity>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    marginHorizontal: 8,
  },
  button: {
    backgroundColor: 'rgba(255, 255, 255, 0.25)',
    borderRadius: 22,
    width: 44,
    height: 44,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1.5,
    borderColor: 'rgba(255, 255, 255, 0.4)',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  },
  buttonRefreshing: {
    backgroundColor: 'rgba(255, 255, 255, 0.15)',
    borderColor: 'rgba(255, 255, 255, 0.3)',
  },
  iconContainer: {
    width: 26,
    height: 26,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

================
File: app/src/modules/kitchen/schema/kitchen.schema.ts
================
import { z } from 'zod';

// Enums
export const orderTypeSchema = z.enum(['DINE_IN', 'TAKE_AWAY', 'DELIVERY']);
export const preparationStatusSchema = z.enum([
  'PENDING',
  'IN_PROGRESS',
  'READY',
  'DELIVERED',
  'CANCELLED',
]);
export const preparationScreenStatusSchema = z.enum([
  'PENDING',
  'IN_PREPARATION',
  'READY',
]);

export type OrderType = z.infer<typeof orderTypeSchema>;
export type PreparationStatus = z.infer<typeof preparationStatusSchema>;
export type PreparationScreenStatus = z.infer<
  typeof preparationScreenStatusSchema
>;

// Exportar los valores de los enums para uso en runtime
export const OrderTypeEnum = orderTypeSchema.enum;
export const PreparationStatusEnum = preparationStatusSchema.enum;
export const PreparationScreenStatusEnum = preparationScreenStatusSchema.enum;

// Exportar como constantes para uso en runtime en comparaciones
export const PreparationStatus = PreparationStatusEnum;
export const PreparationScreenStatus = PreparationScreenStatusEnum;

// Esquema para KitchenOrderItem
export const kitchenOrderItemSchema = z.object({
  id: z.string(),
  productName: z.string(),
  variantName: z.string().optional(),
  modifiers: z.array(z.string()),
  pizzaCustomizations: z
    .array(
      z.object({
        customizationName: z.string(),
        action: z.string(),
        half: z.string().optional(),
      }),
    )
    .optional(),
  preparationNotes: z.string().optional(),
  preparationStatus: preparationStatusSchema,
  preparedAt: z.string().optional(),
  preparedByUser: z
    .object({
      firstName: z.string(),
      lastName: z.string(),
    })
    .optional(),
  quantity: z.number(),
  belongsToMyScreen: z.boolean(),
});

export type KitchenOrderItem = z.infer<typeof kitchenOrderItemSchema>;

// Esquema para PreparationScreenStatusInfo
export const preparationScreenStatusInfoSchema = z.object({
  screenId: z.string(),
  screenName: z.string(),
  status: preparationScreenStatusSchema,
});

export type PreparationScreenStatusInfo = z.infer<
  typeof preparationScreenStatusInfoSchema
>;

// Esquema para KitchenOrder
export const kitchenOrderSchema = z.object({
  id: z.string(),
  shiftOrderNumber: z.number(),
  orderType: orderTypeSchema,
  orderStatus: z.string(), // Estado real de la orden
  createdAt: z.string(),
  orderNotes: z.string().optional(),
  // Campos especficos segn tipo
  deliveryAddress: z.string().optional(),
  deliveryPhone: z.string().optional(),
  receiptName: z.string().optional(),
  customerPhone: z.string().optional(),
  areaName: z.string().optional(),
  tableName: z.string().optional(),
  items: z.array(kitchenOrderItemSchema),
  hasPendingItems: z.boolean(),
  screenStatuses: z.array(preparationScreenStatusInfoSchema),
  myScreenStatus: preparationScreenStatusSchema.optional(),
  isFromWhatsApp: z.boolean().optional(),
});

export type KitchenOrder = z.infer<typeof kitchenOrderSchema>;

// Esquema para KitchenFilters
export const kitchenFiltersSchema = z.object({
  orderType: orderTypeSchema.optional(),
  showPrepared: z.boolean(),
  showAllProducts: z.boolean(),
  ungroupProducts: z.boolean(),
  screenId: z.string().optional(),
});

export type KitchenFilters = z.infer<typeof kitchenFiltersSchema>;

// Esquema para PreparationScreen
export const preparationScreenSchema = z.object({
  id: z.string(),
  name: z.string(),
  description: z.string().optional(),
  isActive: z.boolean(),
});

export type PreparationScreen = z.infer<typeof preparationScreenSchema>;

================
File: app/src/modules/menu/hooks/useProductsQueries.ts
================
import {
  useQuery,
  useMutation,
  useQueryClient,
  UseQueryResult,
  UseMutationResult,
} from '@tanstack/react-query';
import { productsService } from '../services/productsService';
import {
  Product,
  ProductFormInputs,
  FindAllProductsQuery,
  AssignModifierGroupsInput,
} from '../schema/products.schema';
import { PaginatedResponse } from '@/app/types/api.types';
import { ApiError } from '@/app/lib/errors';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { getApiErrorMessage } from '@/app/lib/errorMapping';

const productKeys = {
  all: ['products'] as const,
  lists: (filters: FindAllProductsQuery) =>
    [...productKeys.all, 'list', filters] as const,
  details: (id: string) => [...productKeys.all, 'detail', id] as const,
  detailModifierGroups: (id: string) =>
    [...productKeys.details(id), 'modifier-groups'] as const,
};

export function useProductsQuery(
  filters: FindAllProductsQuery,
  options?: { enabled?: boolean },
): UseQueryResult<PaginatedResponse<Product>, ApiError> {
  return useQuery<PaginatedResponse<Product>, ApiError>({
    queryKey: productKeys.lists(filters),
    queryFn: () => productsService.findAll(filters),
    enabled: options?.enabled ?? true,
  });
}

export function useProductQuery(
  productId: string,
  options?: { enabled?: boolean },
): UseQueryResult<Product, ApiError> {
  return useQuery<Product, ApiError>({
    queryKey: productKeys.details(productId),
    queryFn: () => productsService.findOne(productId),
    enabled: !!productId && (options?.enabled ?? true),
  });
}

export function useCreateProductMutation(): UseMutationResult<
  Product,
  ApiError,
  ProductFormInputs
> {
  const queryClient = useQueryClient();
  return useMutation<Product, ApiError, ProductFormInputs>({
    mutationFn: (newProduct) => {
      return productsService.create(newProduct);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: productKeys.all });
    },
    onError: () => {},
  });
}

export function useUpdateProductMutation(): UseMutationResult<
  Product,
  ApiError,
  { id: string; data: Partial<ProductFormInputs> },
  { previousProducts?: PaginatedResponse<Product>; previousDetail?: Product }
> {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  type UpdateProductContext = { previousDetail?: Product };

  return useMutation<
    Product,
    ApiError,
    { id: string; data: Partial<ProductFormInputs> },
    UpdateProductContext
  >({
    mutationFn: ({ id, data }) => productsService.update(id, data),

    onMutate: async (variables) => {
      const { id, data } = variables;
      const detailQueryKey = productKeys.details(id);

      await queryClient.cancelQueries({ queryKey: detailQueryKey });

      const previousDetail = queryClient.getQueryData<Product>(detailQueryKey);

      if (previousDetail) {
        queryClient.setQueryData<Product>(
          detailQueryKey,
          (old: Product | undefined) => {
            if (!old) return undefined;
            const { variants, modifierGroupIds, ...restOfData } = data;
            return { ...old, ...restOfData };
          },
        );
      }

      return { previousDetail };
    },

    onError: (error, variables, context) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });

      if (context?.previousDetail) {
        queryClient.setQueryData(
          productKeys.details(variables.id),
          context.previousDetail,
        );
      }
    },

    onSettled: (data, error, _variables) => {
      queryClient.invalidateQueries({ queryKey: productKeys.all });

      if (!error && data) {
        showSnackbar({
          message: 'Producto actualizado con xito',
          type: 'success',
        });
      }
    },
  });
}

export function useDeleteProductMutation(): UseMutationResult<
  void,
  ApiError,
  string,
  { previousDetail?: Product }
> {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  type DeleteProductContext = { previousDetail?: Product };

  return useMutation<void, ApiError, string, DeleteProductContext>({
    mutationFn: (productId) => productsService.remove(productId),

    onMutate: async (deletedId) => {
      const detailQueryKey = productKeys.details(deletedId);

      await queryClient.cancelQueries({ queryKey: detailQueryKey });

      const previousDetail = queryClient.getQueryData<Product>(detailQueryKey);

      queryClient.removeQueries({ queryKey: detailQueryKey });

      return { previousDetail };
    },

    onError: (error, deletedId, context) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });

      if (context?.previousDetail) {
        queryClient.setQueryData(
          productKeys.details(deletedId),
          context.previousDetail,
        );
      }
    },

    onSettled: (_data, error, deletedId) => {
      queryClient.invalidateQueries({ queryKey: productKeys.all });

      if (!error) {
        queryClient.removeQueries({ queryKey: productKeys.details(deletedId) });
        showSnackbar({
          message: 'Producto eliminado con xito',
          type: 'success',
        });
      }
    },
  });
}

export function useAssignModifierGroupsMutation(): UseMutationResult<
  Product,
  ApiError,
  { productId: string; data: AssignModifierGroupsInput }
> {
  const queryClient = useQueryClient();
  return useMutation<
    Product,
    ApiError,
    { productId: string; data: AssignModifierGroupsInput }
  >({
    mutationFn: ({ productId, data }) =>
      productsService.assignModifierGroups(productId, data),
    onSuccess: (updatedProduct) => {
      queryClient.invalidateQueries({
        queryKey: productKeys.details(updatedProduct.id),
      });
      queryClient.invalidateQueries({
        queryKey: productKeys.detailModifierGroups(updatedProduct.id),
      });
    },
  });
}

export function useProductModifierGroupsQuery(
  productId: string,
  options?: { enabled?: boolean },
): UseQueryResult<Product, ApiError> {
  return useQuery<Product, ApiError>({
    queryKey: productKeys.detailModifierGroups(productId),
    queryFn: () => productsService.getModifierGroups(productId),
    enabled: !!productId && (options?.enabled ?? true),
  });
}

export function useRemoveModifierGroupsMutation(): UseMutationResult<
  Product,
  ApiError,
  { productId: string; data: AssignModifierGroupsInput }
> {
  const queryClient = useQueryClient();
  return useMutation<
    Product,
    ApiError,
    { productId: string; data: AssignModifierGroupsInput }
  >({
    mutationFn: ({ productId, data }) =>
      productsService.removeModifierGroups(productId, data),
    onSuccess: (updatedProduct) => {
      queryClient.invalidateQueries({
        queryKey: productKeys.details(updatedProduct.id),
      });
      queryClient.invalidateQueries({
        queryKey: productKeys.detailModifierGroups(updatedProduct.id),
      });
    },
  });
}

================
File: app/src/modules/menu/navigation/MenuStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { useAppTheme } from '../../../app/styles/theme';
import { getStackHeaderOptions } from '../../../app/navigation/options';
import type { MenuStackParamList } from './types';

import CategoriesScreen from '../screens/CategoriesScreen';
import SubcategoriesScreen from '../screens/SubcategoriesScreen';
import ProductsScreen from '../screens/ProductsScreen';

const Stack = createNativeStackNavigator<MenuStackParamList>();

export const MenuStackNavigator: React.FC = () => {
  const theme = useAppTheme();

  return (
    <Stack.Navigator
      screenOptions={{
        ...getStackHeaderOptions(theme),
        headerShown: true,
      }}
    >
      <Stack.Screen
        name="CategoriesScreen"
        component={CategoriesScreen}
        options={{
          title: 'Categoras',
        }}
      />
      <Stack.Screen
        name="SubcategoriesScreen"
        component={SubcategoriesScreen}
        options={({ route }) => ({
          title: route.params?.categoryName
            ? `Subcategoras de ${route.params.categoryName}`
            : 'Subcategoras',
        })}
      />
      <Stack.Screen
        name="Products"
        component={ProductsScreen}
        options={({ route }) => ({
          title: route.params?.subCategoryName
            ? `Productos de ${route.params.subCategoryName}`
            : 'Productos',
        })}
      />
    </Stack.Navigator>
  );
};

================
File: app/src/modules/menu/screens/ProductsScreen.tsx
================
import React, { useMemo, useCallback, useState } from 'react';
import { StyleSheet } from 'react-native';
import { Portal } from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useRoute, RouteProp, useNavigation } from '@react-navigation/native';
import { useDrawerStatus } from '@react-navigation/drawer';
import debounce from 'lodash.debounce';
import { useQueryClient } from '@tanstack/react-query';

import {
  useProductsQuery,
  useCreateProductMutation,
  useUpdateProductMutation,
  useDeleteProductMutation,
} from '../hooks/useProductsQueries';
import { Product, ProductFormInputs } from '../schema/products.schema';
import { MenuStackParamList } from '@/modules/menu/navigation/types';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { getApiErrorMessage } from '@/app/lib/errorMapping';
import GenericList, { FilterOption } from '@/app/components/crud/GenericList';
import ProductFormModal from '../components/ProductFormModal';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { FileObject } from '@/app/components/common/CustomImagePicker';
import { useCrudScreenLogic } from '@/app/hooks/useCrudScreenLogic';
import { useListState } from '@/app/hooks/useListState';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';

type ProductsScreenRouteProp = RouteProp<MenuStackParamList, 'Products'>;

function ProductsScreen(): React.ReactElement {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme as AppTheme), [theme]);
  const navigation = useNavigation();
  const route = useRoute<ProductsScreenRouteProp>();
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';

  const { subcategoryId, subCategoryName } = route.params;

  const [searchQuery, setSearchQuery] = useState('');
  const [statusFilter, setStatusFilter] = useState<
    'all' | 'active' | 'inactive'
  >('all');
  const [debouncedSearchQuery, setDebouncedSearchQuery] = useState('');

  const debouncedSetSearch = useMemo(
    () => debounce((query: string) => setDebouncedSearchQuery(query), 300),
    [],
  );

  const handleSearchChange = (query: string) => {
    setSearchQuery(query);
    debouncedSetSearch(query);
  };

  const handleFilterChange = (value: string | number) => {
    if (value === 'all' || value === 'active' || value === 'inactive') {
      setStatusFilter(value);
    } else {
      setStatusFilter('all');
    }
  };

  const queryFilters = useMemo(
    () => ({
      subcategoryId: subcategoryId,
      search: debouncedSearchQuery || undefined,
      limit: 20,
      page: 1,
      isActive: statusFilter === 'all' ? undefined : statusFilter === 'active',
    }),
    [subcategoryId, debouncedSearchQuery, statusFilter],
  );

  const {
    data: productsResponse,
    isLoading,
    error,
    refetch,
    isFetching,
  } = useProductsQuery(queryFilters, {});

  useRefreshModuleOnFocus('products');

  const createMutation = useCreateProductMutation();
  const updateMutation = useUpdateProductMutation();
  const { mutateAsync: deleteProduct } = useDeleteProductMutation();

  const {
    isFormModalVisible,
    editingItem,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleCloseModals,
  } = useCrudScreenLogic<Product>({
    entityName: 'Producto',
    queryKey: ['products', queryFilters],
    deleteMutationFn: deleteProduct,
  });

  const products = useMemo(() => {
    return (productsResponse?.data ?? []).map((p: Product) => ({
      ...p,
      displayDescription: p.hasVariants
        ? `${p.variants?.length || 0} variante(s)`
        : !isNaN(parseFloat(String(p.price)))
          ? `$${parseFloat(String(p.price)).toFixed(2)}`
          : 'Precio no definido',
    }));
  }, [productsResponse]);

  const handleFormSubmit = useCallback(
    async (
      formData: ProductFormInputs,
      photoId: string | null | undefined,
      _file?: FileObject | null,
    ) => {
      const isEditing = !!editingItem;

      const { imageUri, ...dataToSend } = formData;

      const mutationData = {
        ...dataToSend,
        modifierGroupIds: dataToSend.modifierGroupIds ?? [],
        ...(photoId !== undefined && { photoId }),
      };

      try {
        let productResult: Product;

        if (isEditing && editingItem) {
          productResult = await updateMutation.mutateAsync({
            id: editingItem.id,
            data: mutationData,
          });
        } else {
          productResult = await createMutation.mutateAsync(mutationData);
        }

        const message = isEditing
          ? 'Producto actualizado con xito'
          : 'Producto creado con xito';

        showSnackbar({ message, type: 'success' });
        handleCloseModals();

        queryClient.invalidateQueries({
          queryKey: ['products', queryFilters],
        });
        if (productResult?.id) {
          queryClient.invalidateQueries({
            queryKey: ['product', productResult.id],
          });
        }
      } catch (err) {
        const errorMessage = getApiErrorMessage(err);
        showSnackbar({
          message: `Error al ${isEditing ? 'actualizar' : 'crear'} producto: ${errorMessage}`,
          type: 'error',
        });
      }
    },
    [
      editingItem,
      updateMutation,
      createMutation,
      showSnackbar,
      handleCloseModals,
      queryClient,
      queryFilters,
    ],
  );

  const listRenderConfig = {
    titleField: 'name' as keyof Product,
    descriptionField: 'displayDescription' as keyof (Product & {
      displayDescription: string;
    }),
    imageField: 'photo' as keyof Product,
    sortOrderField: 'sortOrder' as keyof Product,
    statusConfig: {
      field: 'isActive' as keyof Product,
      activeValue: true,
      activeLabel: 'Activo',
      inactiveLabel: 'Inactivo',
    },
  };

  const filterOptions: FilterOption<'all' | 'active' | 'inactive'>[] = [
    { value: 'all', label: 'Todos' },
    { value: 'active', label: 'Activos' },
    { value: 'inactive', label: 'Inactivos' },
  ];

  const { ListEmptyComponent } = useListState({
    isLoading,
    isError: !!error,
    data: products,
    emptyConfig: {
      title: debouncedSearchQuery
        ? `No se encontraron productos`
        : 'No hay productos',
      message: debouncedSearchQuery
        ? `No se encontraron productos para "${debouncedSearchQuery}"`
        : `No hay productos en "${subCategoryName}". Presiona el botn + para crear el primero.`,
      icon: 'package-variant',
    },
    errorConfig: {
      title: 'Error al cargar productos',
      message: 'No se pudieron cargar los productos. Verifica tu conexin.',
      icon: 'alert-circle-outline',
      onAction: refetch,
    },
  });

  React.useLayoutEffect(() => {
    navigation.setOptions({
      title: subCategoryName ? `Productos de ${subCategoryName}` : 'Productos',
    });
  }, [navigation, subCategoryName]);

  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      <GenericList<Product & { displayDescription: string }>
        items={products}
        renderConfig={listRenderConfig}
        onItemPress={handleOpenEditModal}
        onRefresh={refetch}
        isRefreshing={isFetching && !isLoading}
        ListEmptyComponent={ListEmptyComponent}
        isLoading={isLoading && !isFetching}
        filterValue={statusFilter}
        onFilterChange={handleFilterChange}
        filterOptions={filterOptions}
        enableSearch={true}
        searchQuery={searchQuery}
        onSearchChange={handleSearchChange}
        searchPlaceholder="Buscar productos..."
        showFab={true}
        onFabPress={handleOpenCreateModal}
        isModalOpen={isFormModalVisible}
        enableSort={false}
        contentContainerStyle={styles.contentContainer}
        showImagePlaceholder={true}
        placeholderIcon="food-outline"
        isDrawerOpen={isDrawerOpen}
      />

      <Portal>
        {isFormModalVisible && (
          <ProductFormModal
            visible={isFormModalVisible}
            onDismiss={handleCloseModals}
            onSubmit={handleFormSubmit}
            initialData={editingItem}
            isSubmitting={createMutation.isPending || updateMutation.isPending}
            productId={editingItem?.id}
            subcategoryId={subcategoryId}
          />
        )}
      </Portal>
    </SafeAreaView>
  );
}

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    centered: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.l,
    },
    errorText: {
      color: theme.colors.error,
      textAlign: 'center',
    },
    contentContainer: {
      paddingBottom: 80,
    },
  });

export default ProductsScreen;

================
File: app/src/modules/modifiers/navigation/ModifiersStackNavigator.tsx
================
import {
  createNativeStackNavigator,
  NativeStackNavigationOptions,
} from '@react-navigation/native-stack';
import { ModifiersStackParamList } from '@/app/navigation/types';
import ModifierGroupsScreen from '../screens/ModifierGroupsScreen';
import ModifiersScreen from '../screens/ModifiersScreen';
import { useAppTheme } from '@/app/styles/theme';
import { getStackHeaderOptions } from '@/app/navigation/options';

const Stack = createNativeStackNavigator<ModifiersStackParamList>();

const ModifiersStackNavigator = () => {
  const theme = useAppTheme();

  return (
    <Stack.Navigator
      screenOptions={{
        ...getStackHeaderOptions(theme),
      }}
    >
      <Stack.Screen
        name="ModifierGroupsScreen"
        component={ModifierGroupsScreen}
        options={(): NativeStackNavigationOptions => ({
          title: 'Grupos de Modificadores',
        })}
      />
      <Stack.Screen
        name="ModifiersScreen"
        component={ModifiersScreen}
        options={{ title: 'Modificadores' }}
      />
    </Stack.Navigator>
  );
};

export default ModifiersStackNavigator;

================
File: app/src/modules/orderFinalization/schema/orderFinalization.schema.ts
================
import { z } from 'zod';

const deliveryInfoSchema = z.object({
  recipientName: z.string().optional(),
  recipientPhone: z.string().optional(),
  fullAddress: z.string().optional(),
});

export const orderForFinalizationListSchema = z.object({
  id: z.string(),
  shiftOrderNumber: z.number(),
  orderType: z.enum(['TAKE_AWAY', 'DELIVERY', 'DINE_IN']),
  orderStatus: z.enum([
    'PENDING',
    'IN_PROGRESS',
    'READY',
    'DELIVERED',
    'COMPLETED',
    'CANCELLED',
  ]),
  total: z.union([z.string(), z.number()]),
  createdAt: z.string(),
  scheduledAt: z.string().optional(),
  paymentsSummary: z
    .object({
      totalPaid: z.number(),
    })
    .optional(),
  deliveryInfo: z
    .object({
      recipientName: z.string().optional(),
      recipientPhone: z.string().optional(),
      fullAddress: z.string().optional(),
    })
    .optional(),
  preparationScreens: z.array(z.string()).optional(),
  preparationScreenStatuses: z
    .array(
      z.object({
        name: z.string(),
        status: z.enum(['PENDING', 'IN_PROGRESS', 'READY']),
      }),
    )
    .optional(),
  ticketImpressionCount: z.number().optional(),
  notes: z.string().optional(),
  table: z
    .object({
      number: z.string(),
      name: z.string(),
      isTemporary: z.boolean(),
      area: z
        .object({
          name: z.string(),
        })
        .optional(),
    })
    .optional(),
  createdBy: z
    .object({
      username: z.string(),
      firstName: z.string().nullable().optional(),
      lastName: z.string().nullable().optional(),
    })
    .optional(),
  isFromWhatsApp: z.boolean().optional(),
});

export type OrderForFinalizationList = z.infer<
  typeof orderForFinalizationListSchema
>;

export const orderItemModifierForFinalizationSchema = z.object({
  id: z.string(),
  name: z.string(),
  price: z.union([z.number(), z.string()]),
});

export type OrderItemModifierForFinalization = z.infer<
  typeof orderItemModifierForFinalizationSchema
>;

export const orderItemForFinalizationSchema = z.object({
  id: z.string(),
  quantity: z.number(),
  basePrice: z.string(),
  finalPrice: z.string(),
  preparationNotes: z.string().optional(),
  preparationStatus: z.string().optional(),
  product: z.object({
    id: z.string(),
    name: z.string(),
    description: z.string().optional(),
  }),
  productVariant: z
    .object({
      id: z.string(),
      name: z.string(),
    })
    .nullable()
    .optional(),
  modifiers: z.array(orderItemModifierForFinalizationSchema),
  selectedPizzaCustomizations: z.array(z.any()).optional(),
});

export type OrderItemForFinalization = z.infer<
  typeof orderItemForFinalizationSchema
>;

export const orderForFinalizationSchema = z.object({
  id: z.string(),
  shiftOrderNumber: z.number(),
  deliveryInfo: deliveryInfoSchema,
  orderType: z.enum(['TAKE_AWAY', 'DELIVERY', 'DINE_IN']),
  orderStatus: z.enum([
    'PENDING',
    'IN_PROGRESS',
    'READY',
    'DELIVERED',
    'COMPLETED',
    'CANCELLED',
  ]),
  total: z.union([z.string(), z.number()]),
  orderItems: z.array(orderItemForFinalizationSchema),
  createdAt: z.string(),
  updatedAt: z.string(),
  scheduledAt: z.string().optional(),
  tableId: z.string().optional(),
  user: z
    .object({
      id: z.string(),
      firstName: z.string().optional(),
      lastName: z.string().optional(),
    })
    .optional(),
  table: z
    .object({
      id: z.string(),
      number: z.string(),
      area: z
        .object({
          name: z.string(),
        })
        .optional(),
    })
    .nullable()
    .optional(),
  isFromWhatsApp: z.boolean().optional(),
  preparationScreens: z.array(z.string()).optional(),
  payments: z
    .array(
      z.object({
        id: z.string(),
        amount: z.number(),
        paymentMethod: z.string(),
        paymentStatus: z.string(),
        createdAt: z.string(),
        updatedAt: z.string(),
      }),
    )
    .optional(),
  notes: z.string().optional(),
  ticketImpressions: z
    .array(
      z.object({
        id: z.string(),
        ticketType: z.string(),
        impressionTime: z.string(),
        user: z
          .object({
            id: z.string(),
            firstName: z.string().optional(),
            lastName: z.string().optional(),
          })
          .optional(),
        printer: z
          .object({
            id: z.string(),
            name: z.string(),
          })
          .optional(),
      }),
    )
    .optional(),
});

export type OrderForFinalization = z.infer<typeof orderForFinalizationSchema>;

export const orderSelectionStateSchema = z.object({
  selectedOrders: z.set(z.string()),
  totalAmount: z.number(),
});

export type OrderSelectionState = z.infer<typeof orderSelectionStateSchema>;

export const finalizeOrdersPayloadSchema = z.object({
  orderIds: z.array(z.string()),
  paymentMethod: z.string().optional(),
  notes: z.string().optional(),
});

export type FinalizeOrdersPayload = z.infer<typeof finalizeOrdersPayloadSchema>;

export const orderFinalizationFilterSchema = z.enum([
  'delivery',
  'take_away',
  'dine_in',
]);
export type OrderFinalizationFilter = z.infer<
  typeof orderFinalizationFilterSchema
>;

================
File: app/src/modules/orders/components/ChangeCalculatorModal.tsx
================
import React, { useState, useEffect, useMemo } from 'react';
import { View, StyleSheet, Pressable } from 'react-native';
import { Text, Button, TextInput } from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { ResponsiveModal } from '@/app/components/responsive/ResponsiveModal';

interface ChangeCalculatorModalProps {
  visible: boolean;
  onDismiss: () => void;
  onConfirm: () => void;
  amountToPay: number;
}

export const ChangeCalculatorModal: React.FC<ChangeCalculatorModalProps> = ({
  visible,
  onDismiss,
  onConfirm,
  amountToPay,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);

  const [receivedAmount, setReceivedAmount] = useState('');

  // Calcular cambio
  const changeAmount = useMemo(() => {
    const received = parseFloat(receivedAmount);
    if (isNaN(received)) return 0;
    return Math.max(0, received - amountToPay);
  }, [receivedAmount, amountToPay]);

  // Determinar qu botones de billetes mostrar
  const availableBills = useMemo(() => {
    const bills = [50, 100, 200, 500, 1000];
    // Filtrar billetes que sean mayores o iguales al monto a pagar
    const validBills = bills.filter((bill) => bill >= amountToPay);
    // Tomar mximo 4 opciones para que quepan en una lnea
    return validBills.slice(0, 4);
  }, [amountToPay]);

  // Resetear cuando se abre
  useEffect(() => {
    if (visible) {
      setReceivedAmount(amountToPay.toFixed(2));
    }
  }, [visible, amountToPay]);

  const handleConfirm = () => {
    const received = parseFloat(receivedAmount);
    if (!isNaN(received) && received >= amountToPay) {
      onConfirm();
    }
  };

  const footerActions = (
    <View style={styles.footer}>
      <Button
        mode="outlined"
        onPress={onDismiss}
        style={styles.cancelButton}
        labelStyle={styles.cancelButtonLabel}
        contentStyle={styles.footerButtonContent}
      >
        Cancelar
      </Button>
      <Button
        mode="contained"
        onPress={handleConfirm}
        disabled={
          !receivedAmount ||
          isNaN(parseFloat(receivedAmount)) ||
          parseFloat(receivedAmount) < amountToPay
        }
        style={styles.confirmButton}
        contentStyle={styles.footerButtonContent}
        labelStyle={styles.confirmButtonLabel}
      >
        Confirmar Pago
      </Button>
    </View>
  );

  return (
    <ResponsiveModal
      visible={visible}
      onDismiss={onDismiss}
      title="Calcular Cambio"
      widthTablet={480}
      maxWidthMobile="95%"
      scrollable={false}
      footer={footerActions}
    >
      <View style={styles.content}>
        {/* Inputs en lnea */}
        <View style={styles.inputsRow}>
          {/* Total a pagar */}
          <View style={styles.inputContainer}>
            <Text style={styles.inputLabel}>Total a pagar</Text>
            <TextInput
              value={`$${amountToPay.toFixed(2)}`}
              editable={false}
              mode="flat"
              style={styles.totalInput}
              dense
              theme={{
                colors: {
                  primary: theme.colors.primary,
                  background: 'rgba(255, 255, 255, 0.05)',
                  text: theme.dark ? '#FFFFFF' : '#000000',
                },
              }}
            />
          </View>

          {/* Monto recibido */}
          <View style={styles.inputContainer}>
            <Text style={styles.inputLabel}>Monto recibido</Text>
            <TextInput
              value={receivedAmount}
              onChangeText={setReceivedAmount}
              keyboardType="decimal-pad"
              mode="flat"
              left={<TextInput.Affix text="$" />}
              style={styles.receivedInput}
              error={
                receivedAmount !== '' &&
                (isNaN(parseFloat(receivedAmount)) ||
                  parseFloat(receivedAmount) < amountToPay)
              }
              dense
              theme={{
                colors: {
                  primary: theme.colors.primary,
                  background: 'rgba(255, 255, 255, 0.05)',
                },
              }}
            />
          </View>
        </View>

        {/* Error message */}
        {receivedAmount !== '' &&
          (isNaN(parseFloat(receivedAmount)) ||
            parseFloat(receivedAmount) < amountToPay) && (
            <Text style={styles.errorText}>Monto insuficiente</Text>
          )}

        {/* Botones de billetes comunes */}
        {availableBills.length > 0 && (
          <View style={styles.quickAmountsRow}>
            {availableBills.map((bill) => (
              <Pressable
                key={bill}
                onPress={() => setReceivedAmount(`${bill}.00`)}
                style={({ pressed }) => [
                  styles.quickAmountButton,
                  pressed && styles.quickAmountButtonPressed,
                ]}
              >
                <Text style={styles.quickAmountButtonText}>
                  ${bill >= 1000 ? '1k' : bill}
                </Text>
              </Pressable>
            ))}
          </View>
        )}

        {/* Mostrar cambio */}
        {receivedAmount !== '' &&
          !isNaN(parseFloat(receivedAmount)) &&
          parseFloat(receivedAmount) >= amountToPay && (
            <View style={styles.changeSection}>
              <Text style={styles.changeLabel}>Cambio</Text>
              <Text style={styles.changeAmount}>
                ${changeAmount.toFixed(2)}
              </Text>
            </View>
          )}
      </View>
    </ResponsiveModal>
  );
};

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    content: {
      // Ya no necesita padding ya que ResponsiveModal lo maneja
    },
    inputsRow: {
      flexDirection: 'row',
      gap: 16,
      marginBottom: 20,
    },
    inputContainer: {
      flex: 1,
    },
    inputLabel: {
      ...theme.fonts.bodyMedium,
      color: theme.dark ? 'rgba(255, 255, 255, 0.7)' : 'rgba(0, 0, 0, 0.6)',
      marginBottom: 8,
      fontSize: 14,
    },
    totalInput: {
      backgroundColor: theme.dark
        ? 'rgba(255, 255, 255, 0.08)'
        : 'rgba(0, 0, 0, 0.04)',
      borderRadius: 12,
      fontSize: 20,
      height: 56,
      paddingHorizontal: 16,
      opacity: 0.8,
    },
    receivedInput: {
      backgroundColor: theme.dark
        ? 'rgba(255, 255, 255, 0.08)'
        : 'rgba(0, 0, 0, 0.04)',
      borderRadius: 12,
      fontSize: 20,
      height: 56,
      paddingHorizontal: 16,
    },
    quickAmountsRow: {
      flexDirection: 'row',
      gap: 12,
      marginTop: 16,
      justifyContent: 'center',
    },
    quickAmountButton: {
      backgroundColor: theme.dark
        ? 'rgba(255, 255, 255, 0.1)'
        : 'rgba(0, 0, 0, 0.05)',
      paddingHorizontal: 20,
      paddingVertical: 16,
      borderRadius: 12,
      flex: 1,
      alignItems: 'center',
      minHeight: 56,
      justifyContent: 'center',
    },
    quickAmountButtonPressed: {
      backgroundColor: theme.dark
        ? 'rgba(255, 255, 255, 0.2)'
        : 'rgba(0, 0, 0, 0.1)',
    },
    quickAmountButtonText: {
      ...theme.fonts.labelLarge,
      color: theme.dark ? '#FFFFFF' : '#000000',
      fontWeight: '700',
      fontSize: 18,
    },
    errorText: {
      ...theme.fonts.bodyMedium,
      color: '#FF4444',
      marginTop: 4,
      marginLeft: 4,
      fontSize: 14,
    },
    changeSection: {
      backgroundColor: theme.dark
        ? 'rgba(16, 185, 129, 0.1)'
        : 'rgba(16, 185, 129, 0.08)',
      padding: 20,
      borderRadius: 16,
      alignItems: 'center',
      marginTop: 16,
    },
    changeLabel: {
      ...theme.fonts.bodyLarge,
      color: theme.dark ? 'rgba(255, 255, 255, 0.7)' : 'rgba(0, 0, 0, 0.6)',
      marginBottom: 4,
      fontSize: 16,
    },
    changeAmount: {
      ...theme.fonts.headlineMedium,
      color: '#10B981',
      fontWeight: '700',
      letterSpacing: -0.5,
      fontSize: 32,
    },
    footer: {
      flexDirection: 'row',
      gap: 16,
      // ResponsiveModal maneja padding, border y background
    },
    cancelButton: {
      flex: 1,
      borderColor: theme.colors.error,
      backgroundColor: theme.colors.errorContainer,
    },
    cancelButtonLabel: {
      fontSize: 16,
      fontWeight: '700',
      color: theme.colors.onErrorContainer,
    },
    confirmButton: {
      flex: 2,
      backgroundColor: '#10B981',
    },
    confirmButtonLabel: {
      fontSize: 16,
      fontWeight: '700',
      color: '#FFFFFF',
    },
    footerButtonContent: {
      height: 48,
    },
  });

export default ChangeCalculatorModal;

================
File: app/src/modules/orders/components/OrderHeader.tsx
================
import { StyleSheet, View } from 'react-native';
import { Text, IconButton } from 'react-native-paper';
import CartButton from './CartButton';
import { useAppTheme } from '@/app/styles/theme';

interface OrderHeaderProps {
  title: string;
  itemCount: number;
  onBackPress?: () => void;
  onCartPress: () => void;
  isCartVisible: boolean;
}

const OrderHeader = ({
  title,
  itemCount,
  onBackPress,
  onCartPress,
  isCartVisible,
}: OrderHeaderProps) => {
  const theme = useAppTheme();

  const styles = StyleSheet.create({
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: 4,
      paddingVertical: 8,
      backgroundColor: theme.colors.elevation.level2,
      elevation: 0,
      shadowOpacity: 0,
    },
    headerTitle: {
      ...theme.fonts.titleMedium,
      color: theme.colors.onSurface,
      fontWeight: 'bold',
      textAlign: 'center',
      flex: 1,
    },
    headerSpacer: {
      width: 48,
    },
  });

  return (
    <View style={styles.header}>
      {onBackPress ? (
        <IconButton
          icon="arrow-left"
          size={24}
          onPress={onBackPress}
          iconColor={theme.colors.onSurface}
        />
      ) : (
        <View style={styles.headerSpacer} />
      )}

      <Text style={styles.headerTitle}>{title}</Text>

      {!isCartVisible ? (
        <CartButton itemCount={itemCount} onPress={onCartPress} />
      ) : (
        <View style={styles.headerSpacer} />
      )}
    </View>
  );
};

export default OrderHeader;

================
File: app/src/modules/orders/components/ShiftStatusModal.tsx
================
import React from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  Surface,
  Divider,
  Card,
  Chip,
} from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useAppTheme } from '@/app/styles/theme';
import { type Shift } from '@/services/shifts';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';

interface ShiftStatusModalProps {
  visible: boolean;
  onDismiss: () => void;
  shift: Shift | null;
  onOpenShift: () => void;
  onCloseShift?: () => void;
  canOpenShift: boolean;
  loading: boolean;
}

export const ShiftStatusModal: React.FC<ShiftStatusModalProps> = ({
  visible,
  onDismiss,
  shift,
  onOpenShift,
  onCloseShift,
  canOpenShift,
  loading: _loading,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);

  const isShiftOpen = shift && shift.status === 'OPEN';
  const today = new Date();
  const todayFormatted = format(today, "EEEE, d 'de' MMMM 'de' yyyy", {
    locale: es,
  });

  const handleOpenShift = () => {
    onDismiss();
    onOpenShift();
  };

  const formatCurrency = (amount: number) => {
    return new Intl.NumberFormat('es-MX', {
      style: 'currency',
      currency: 'MXN',
    }).format(amount);
  };

  const formatTime = (dateString: string) => {
    return format(new Date(dateString), 'HH:mm', { locale: es });
  };

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalContainer}
      >
        <ScrollView showsVerticalScrollIndicator={false}>
          <Surface style={styles.modal} elevation={3}>
            {/* Header */}
            <View style={styles.header}>
              <View style={styles.iconContainer}>
                <MaterialCommunityIcons
                  name={isShiftOpen ? 'store-check' : 'store-alert'}
                  size={48}
                  color={isShiftOpen ? '#4CAF50' : '#FF9800'}
                />
              </View>
              <Text variant="headlineMedium" style={styles.title}>
                {isShiftOpen ? 'Turno Abierto' : 'Turno Cerrado'}
              </Text>
              <Text variant="bodyLarge" style={styles.date}>
                {todayFormatted}
              </Text>
              <Chip
                mode="outlined"
                style={[
                  styles.statusChip,
                  isShiftOpen ? styles.openBorder : styles.closedBorder,
                ]}
                textStyle={isShiftOpen ? styles.openText : styles.closedText}
              >
                {isShiftOpen ? 'ABIERTO' : 'CERRADO'}
              </Chip>
            </View>

            <Divider style={styles.divider} />

            {/* Content */}
            <View style={styles.content}>
              {isShiftOpen && shift ? (
                <>
                  {/* Informacin del turno abierto */}
                  <Card style={styles.infoCard}>
                    <Card.Content>
                      <Text variant="titleMedium" style={styles.sectionTitle}>
                        Informacin del Turno
                      </Text>

                      <View style={styles.infoRow}>
                        <Text variant="bodyMedium" style={styles.label}>
                          Turno #:
                        </Text>
                        <Text variant="bodyMedium" style={styles.value}>
                          {shift.globalShiftNumber}
                        </Text>
                      </View>

                      <View style={styles.infoRow}>
                        <Text variant="bodyMedium" style={styles.label}>
                          Abierto a las:
                        </Text>
                        <Text variant="bodyMedium" style={styles.value}>
                          {formatTime(shift.openedAt)}
                        </Text>
                      </View>

                      <View style={styles.infoRow}>
                        <Text variant="bodyMedium" style={styles.label}>
                          Abierto por:
                        </Text>
                        <Text variant="bodyMedium" style={styles.value}>
                          {shift.openedBy.firstName} {shift.openedBy.lastName}
                        </Text>
                      </View>

                      <View style={styles.infoRow}>
                        <Text variant="bodyMedium" style={styles.label}>
                          Efectivo inicial:
                        </Text>
                        <Text variant="bodyMedium" style={styles.value}>
                          {formatCurrency(shift.initialCash)}
                        </Text>
                      </View>

                      {shift.totalSales !== null && (
                        <View style={styles.infoRow}>
                          <Text variant="bodyMedium" style={styles.label}>
                            Ventas del turno:
                          </Text>
                          <Text
                            variant="bodyMedium"
                            style={[styles.value, styles.highlight]}
                          >
                            {formatCurrency(shift.totalSales)}
                          </Text>
                        </View>
                      )}

                      {shift.totalOrders !== null && (
                        <View style={styles.infoRow}>
                          <Text variant="bodyMedium" style={styles.label}>
                            rdenes:
                          </Text>
                          <Text variant="bodyMedium" style={styles.value}>
                            {shift.totalOrders}
                          </Text>
                        </View>
                      )}

                      {shift.expectedCash !== null && (
                        <View style={styles.infoRow}>
                          <Text variant="bodyMedium" style={styles.label}>
                            Efectivo esperado:
                          </Text>
                          <Text
                            variant="bodyMedium"
                            style={[styles.value, styles.highlight]}
                          >
                            {formatCurrency(shift.expectedCash)}
                          </Text>
                        </View>
                      )}

                      {shift.notes && (
                        <View style={styles.notesSection}>
                          <Text variant="bodyMedium" style={styles.label}>
                            Notas:
                          </Text>
                          <Text variant="bodySmall" style={styles.notes}>
                            {shift.notes}
                          </Text>
                        </View>
                      )}
                    </Card.Content>
                  </Card>
                </>
              ) : (
                <>
                  {/* Turno cerrado */}
                  <View style={styles.closedInfo}>
                    <MaterialCommunityIcons
                      name="information"
                      size={20}
                      color={theme.colors.primary}
                    />
                    <Text variant="bodyMedium" style={styles.closedText}>
                      {canOpenShift
                        ? 'El turno est cerrado. Para comenzar las operaciones, abre el turno.'
                        : 'El turno est cerrado. Contacta a un administrador para abrirlo.'}
                    </Text>
                  </View>
                </>
              )}
            </View>

            {/* Footer */}
            <View style={styles.footer}>
              <Button
                mode="text"
                onPress={onDismiss}
                style={styles.cancelButton}
                labelStyle={styles.cancelButtonText}
              >
                Cerrar
              </Button>

              {!isShiftOpen && canOpenShift && (
                <Button
                  mode="contained"
                  onPress={handleOpenShift}
                  style={styles.actionButton}
                  contentStyle={styles.actionButtonContent}
                  labelStyle={styles.actionButtonText}
                  icon="play-circle"
                >
                  Abrir Turno
                </Button>
              )}

              {isShiftOpen && canOpenShift && onCloseShift && (
                <Button
                  mode="contained"
                  onPress={() => {
                    onDismiss();
                    onCloseShift();
                  }}
                  style={styles.closeShiftButton}
                  contentStyle={styles.actionButtonContent}
                  labelStyle={styles.closeShiftButtonText}
                  icon="stop-circle"
                >
                  Cerrar Turno
                </Button>
              )}
            </View>
          </Surface>
        </ScrollView>
      </Modal>
    </Portal>
  );
};

const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    modalContainer: {
      flex: 1,
      justifyContent: 'center',
      paddingVertical: theme.spacing.xl,
      paddingHorizontal: theme.spacing.m,
    },
    modal: {
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness * 3,
      borderWidth: 2,
      borderColor: theme.colors.outline,
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 8,
      },
      shadowOpacity: 0.25,
      shadowRadius: 16,
      elevation: 8,
    },
    header: {
      alignItems: 'center',
      paddingTop: theme.spacing.xl,
      paddingHorizontal: theme.spacing.l,
      paddingBottom: theme.spacing.l,
      borderTopLeftRadius: theme.roundness * 3,
      borderTopRightRadius: theme.roundness * 3,
      backgroundColor: theme.colors.surfaceVariant,
    },
    iconContainer: {
      width: 90,
      height: 90,
      borderRadius: 45,
      backgroundColor: theme.colors.surface,
      justifyContent: 'center',
      alignItems: 'center',
      marginBottom: theme.spacing.m,
      borderWidth: 3,
      borderColor: theme.colors.primary,
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 4,
      },
      shadowOpacity: 0.15,
      shadowRadius: 8,
      elevation: 4,
    },
    title: {
      color: theme.colors.onSurfaceVariant,
      fontWeight: '700',
      textAlign: 'center',
      marginBottom: theme.spacing.xs,
    },
    date: {
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
      textTransform: 'capitalize',
      marginBottom: theme.spacing.m,
    },
    statusChip: {
      backgroundColor: theme.colors.surface,
      borderWidth: 2,
    },
    divider: {
      backgroundColor: theme.colors.outlineVariant,
      height: 1,
    },
    content: {
      padding: theme.spacing.l,
    },
    infoCard: {
      backgroundColor: theme.colors.surfaceVariant,
      borderWidth: 1,
      borderColor: theme.colors.outline,
      borderRadius: theme.roundness * 2,
    },
    sectionTitle: {
      color: theme.colors.onSurface,
      fontWeight: '600',
      marginBottom: theme.spacing.m,
    },
    infoRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.s,
    },
    label: {
      color: theme.colors.onSurfaceVariant,
      flex: 1,
    },
    value: {
      color: theme.colors.onSurface,
      fontWeight: '500',
      textAlign: 'right',
    },
    highlight: {
      color: theme.colors.primary,
      fontWeight: '600',
    },
    notesSection: {
      marginTop: theme.spacing.m,
      paddingTop: theme.spacing.m,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outline,
    },
    notes: {
      color: theme.colors.onSurfaceVariant,
      marginTop: theme.spacing.xs,
      fontStyle: 'italic',
    },
    closedInfo: {
      flexDirection: 'row',
      backgroundColor: theme.colors.primaryContainer,
      padding: theme.spacing.m,
      borderRadius: theme.roundness * 2,
      borderWidth: 1,
      borderColor: theme.colors.primary,
      gap: theme.spacing.s,
    },
    closedText: {
      flex: 1,
      color: theme.colors.onPrimaryContainer,
      lineHeight: 20,
    },
    footer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      padding: theme.spacing.l,
      paddingTop: theme.spacing.s,
      gap: theme.spacing.m,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
      borderBottomLeftRadius: theme.roundness * 3,
      borderBottomRightRadius: theme.roundness * 3,
    },
    cancelButton: {
      flex: 1,
      borderWidth: 2,
      borderColor: theme.colors.outline,
      borderRadius: theme.roundness * 2,
    },
    cancelButtonText: {
      color: theme.colors.onSurface,
      fontWeight: '600',
    },
    actionButton: {
      flex: 1,
      backgroundColor: theme.colors.primary,
      borderWidth: 2,
      borderColor: theme.colors.primary,
      borderRadius: theme.roundness * 2,
    },
    actionButtonContent: {
      paddingVertical: theme.spacing.xs,
    },
    actionButtonText: {
      color: theme.colors.onPrimary,
      fontWeight: '600',
    },
    closeShiftButton: {
      flex: 1,
      backgroundColor: '#FF5722',
      borderWidth: 2,
      borderColor: '#FF5722',
      borderRadius: theme.roundness * 2,
    },
    closeShiftButtonText: {
      color: '#FFFFFF',
      fontWeight: '600',
    },
    openBorder: {
      borderColor: '#4CAF50',
    },
    closedBorder: {
      borderColor: '#FF9800',
    },
    openText: {
      color: '#4CAF50',
    },
    closedText: {
      color: '#FF9800',
    },
  });

================
File: app/src/modules/orders/hooks/useAdjustmentQueries.ts
================
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { adjustmentService } from '../services/adjustmentService';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import type { OrderAdjustmentDto } from '../schema/update-order.schema';

export const useCreateBulkAdjustmentsMutation = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: (adjustments: OrderAdjustmentDto[]) =>
      adjustmentService.createBulkAdjustments(adjustments),
    onSuccess: (data, variables) => {
      // Invalidar queries relacionadas
      if (variables.length > 0 && variables[0].orderId) {
        queryClient.invalidateQueries({
          queryKey: ['orders', variables[0].orderId],
        });
        queryClient.invalidateQueries({
          queryKey: ['adjustments', 'order', variables[0].orderId],
        });
      }
      showSnackbar({
        message: 'Ajustes aplicados correctamente',
        type: 'success',
      });
    },
    onError: (error: Error) => {
      showSnackbar({
        message: error.message || 'Error al aplicar ajustes',
        type: 'error',
      });
    },
  });
};

export const useOrderAdjustmentsQuery = (orderId: string, enabled = true) => {
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useQuery({
    queryKey: ['adjustments', 'order', orderId],
    queryFn: () => adjustmentService.getOrderAdjustments(orderId),
    enabled: enabled && !!orderId,
    onError: (error: Error) => {
      showSnackbar({
        message: error.message || 'Error al cargar ajustes',
        type: 'error',
      });
    },
  });
};

export const useDeleteAdjustmentMutation = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: (adjustmentId: string) =>
      adjustmentService.deleteAdjustment(adjustmentId),
    onSuccess: () => {
      // Invalidar todas las queries de ajustes
      queryClient.invalidateQueries({ queryKey: ['adjustments'] });
      queryClient.invalidateQueries({ queryKey: ['orders'] });
      showSnackbar({
        message: 'Ajuste eliminado correctamente',
        type: 'success',
      });
    },
    onError: (error: Error) => {
      showSnackbar({
        message: error.message || 'Error al eliminar ajuste',
        type: 'error',
      });
    },
  });
};

================
File: app/src/modules/orders/hooks/usePaymentQueries.ts
================
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { paymentService } from '../services/paymentService';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import type {
  CreatePaymentDto,
  UpdatePaymentDto,
  PaymentMethod,
  PaymentStatus,
} from '../schema/payment.schema';

// Query Keys
export const paymentKeys = {
  all: ['payments'] as const,
  lists: () => [...paymentKeys.all, 'list'] as const,
  list: (filters?: {
    orderId?: string;
    paymentMethod?: PaymentMethod;
    paymentStatus?: PaymentStatus;
  }) => [...paymentKeys.lists(), filters] as const,
  details: () => [...paymentKeys.all, 'detail'] as const,
  detail: (id: string) => [...paymentKeys.details(), id] as const,
  byOrder: (orderId: string) => [...paymentKeys.all, 'order', orderId] as const,
};

// Queries
export const useGetPaymentsQuery = (filters?: {
  orderId?: string;
  paymentMethod?: PaymentMethod;
  paymentStatus?: PaymentStatus;
}) => {
  return useQuery({
    queryKey: paymentKeys.list(filters),
    queryFn: () => paymentService.getPayments(filters),
  });
};

export const useGetPaymentByIdQuery = (id: string) => {
  return useQuery({
    queryKey: paymentKeys.detail(id),
    queryFn: () => paymentService.getPaymentById(id),
    enabled: !!id,
  });
};

export const useGetPaymentsByOrderIdQuery = (
  orderId: string,
  options?: { enabled?: boolean },
) => {
  return useQuery({
    queryKey: paymentKeys.byOrder(orderId),
    queryFn: () => paymentService.getPaymentsByOrderId(orderId),
    enabled: options?.enabled !== undefined ? options.enabled : !!orderId,
    initialData: [],
  });
};

// Mutations
export const useCreatePaymentMutation = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: (dto: CreatePaymentDto) => paymentService.createPayment(dto),
    onSuccess: (data) => {
      // Invalidar queries relacionadas
      queryClient.invalidateQueries({ queryKey: paymentKeys.lists() });
      queryClient.invalidateQueries({
        queryKey: paymentKeys.byOrder(data.orderId),
      });
      // Invalidar tambin las queries de rdenes para que se actualice el estado de pago
      queryClient.invalidateQueries({ queryKey: ['orders'] });

      showSnackbar({
        message: 'Pago registrado exitosamente',
        type: 'success',
      });
    },
    onError: (error: any) => {
      showSnackbar({
        message: error.response?.data?.message || 'Error al registrar el pago',
        type: 'error',
      });
    },
  });
};

export const useUpdatePaymentMutation = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: ({ id, dto }: { id: string; dto: UpdatePaymentDto }) =>
      paymentService.updatePayment(id, dto),
    onSuccess: (data) => {
      // Invalidar queries relacionadas
      queryClient.invalidateQueries({ queryKey: paymentKeys.lists() });
      queryClient.invalidateQueries({ queryKey: paymentKeys.detail(data.id) });
      queryClient.invalidateQueries({
        queryKey: paymentKeys.byOrder(data.orderId),
      });
      // Invalidar tambin las queries de rdenes para que se actualice el estado de pago
      queryClient.invalidateQueries({ queryKey: ['orders'] });

      showSnackbar({
        message: 'Pago actualizado exitosamente',
        type: 'success',
      });
    },
    onError: (error: any) => {
      showSnackbar({
        message: error.response?.data?.message || 'Error al actualizar el pago',
        type: 'error',
      });
    },
  });
};

export const useDeletePaymentMutation = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: (id: string) => paymentService.deletePayment(id),
    onSuccess: () => {
      // Invalidar todas las queries de pagos
      queryClient.invalidateQueries({ queryKey: paymentKeys.all });
      // Invalidar tambin las queries de rdenes para que se actualice el estado de pago
      queryClient.invalidateQueries({ queryKey: ['orders'] });

      showSnackbar({
        message: 'Pago eliminado exitosamente',
        type: 'success',
      });
    },
    onError: (error: any) => {
      showSnackbar({
        message: error.response?.data?.message || 'Error al eliminar el pago',
        type: 'error',
      });
    },
  });
};

================
File: app/src/modules/orders/services/orderPrintService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';

interface PrintTicketPayload {
  printerId: string;
  ticketType: 'GENERAL' | 'BILLING';
}

export const orderPrintService = {
  /**
   * Imprime un ticket para una orden
   */
  printTicket: async (orderId: string, payload: PrintTicketPayload) => {
    const response = await apiClient.post(
      API_PATHS.ORDERS_PRINT_TICKET.replace(':orderId', orderId),
      payload,
    );
    return response.data;
  },
};

================
File: app/src/modules/pizzaCustomizations/schema/pizzaConfiguration.schema.ts
================
import { z } from 'zod';

// Esquema principal para PizzaConfiguration
export const pizzaConfigurationSchema = z.object({
  id: z.string(),
  productId: z.string(),
  includedToppings: z.number(),
  extraToppingCost: z.number(),
  createdAt: z.string(),
  updatedAt: z.string(),
});

export type PizzaConfiguration = z.infer<typeof pizzaConfigurationSchema>;

// Esquemas para inputs
export const createPizzaConfigurationInputSchema = z.object({
  productId: z.string(),
  includedToppings: z.number(),
  extraToppingCost: z.number(),
});

export type CreatePizzaConfigurationInput = z.infer<
  typeof createPizzaConfigurationInputSchema
>;

export const updatePizzaConfigurationInputSchema = z.object({
  includedToppings: z.number().optional(),
  extraToppingCost: z.number().optional(),
});

export type UpdatePizzaConfigurationInput = z.infer<
  typeof updatePizzaConfigurationInputSchema
>;

// Esquemas para formularios
export const pizzaConfigurationFormSchema = z.object({
  productId: z.string().min(1, 'El producto es requerido'),
  includedToppings: z
    .number()
    .min(0, 'Los toppings incluidos deben ser mayor o igual a 0')
    .default(4),
  extraToppingCost: z
    .number()
    .min(0, 'El costo extra debe ser mayor o igual a 0')
    .default(20),
});

export type PizzaConfigurationFormInputs = z.infer<
  typeof pizzaConfigurationFormSchema
>;

export const updatePizzaConfigurationSchema = z.object({
  includedToppings: z.number().min(0).optional(),
  extraToppingCost: z.number().min(0).optional(),
});

export type UpdatePizzaConfigurationInputs = z.infer<
  typeof updatePizzaConfigurationSchema
>;

================
File: app/src/modules/pizzaCustomizations/schema/pizzaCustomization.schema.ts
================
import { z } from 'zod';

// Enums
export const customizationTypeSchema = z.enum(['FLAVOR', 'INGREDIENT']);
export const pizzaHalfSchema = z.enum(['FULL', 'HALF_1', 'HALF_2']);
export const customizationActionSchema = z.enum(['ADD', 'REMOVE']);

export type CustomizationType = z.infer<typeof customizationTypeSchema>;
export type PizzaHalf = z.infer<typeof pizzaHalfSchema>;
export type CustomizationAction = z.infer<typeof customizationActionSchema>;

// Exportar los valores de los enums para uso en runtime
export const CustomizationTypeEnum = customizationTypeSchema.enum;
export const PizzaHalfEnum = pizzaHalfSchema.enum;
export const CustomizationActionEnum = customizationActionSchema.enum;

// Esquema para PizzaCustomization
export const pizzaCustomizationSchema = z.object({
  id: z.string(),
  name: z.string(),
  type: customizationTypeSchema,
  ingredients: z.string().nullable().optional(),
  toppingValue: z.number(),
  isActive: z.boolean(),
  sortOrder: z.number(),
  productIds: z.array(z.string()).optional(),
  products: z
    .array(
      z.object({
        id: z.string(),
        name: z.string(),
      }),
    )
    .optional(),
  createdAt: z.string(),
  updatedAt: z.string(),
});

export type PizzaCustomization = z.infer<typeof pizzaCustomizationSchema>;

// Esquema para SelectedPizzaCustomization
export const selectedPizzaCustomizationSchema = z.object({
  id: z.string(),
  orderItemId: z.string(),
  pizzaCustomizationId: z.string(),
  pizzaCustomization: pizzaCustomizationSchema.optional(),
  half: pizzaHalfSchema,
  action: customizationActionSchema,
  createdAt: z.string(),
  updatedAt: z.string(),
});

export type SelectedPizzaCustomization = z.infer<
  typeof selectedPizzaCustomizationSchema
>;

// Esquemas para formularios
export const pizzaCustomizationFormSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  type: customizationTypeSchema,
  ingredients: z.string().optional().nullable(),
  toppingValue: z
    .number()
    .min(0, 'El valor debe ser mayor o igual a 0')
    .default(1),
  isActive: z.boolean().default(true),
  sortOrder: z.number().default(0),
});

export type PizzaCustomizationFormInputs = z.infer<
  typeof pizzaCustomizationFormSchema
>;

export const findAllPizzaCustomizationsQuerySchema = z.object({
  page: z.number().optional(),
  limit: z.number().optional(),
  search: z.string().optional(),
  type: customizationTypeSchema.optional(),
  isActive: z.boolean().optional(),
});

export type FindAllPizzaCustomizationsQuery = z.infer<
  typeof findAllPizzaCustomizationsQuerySchema
>;

================
File: app/src/modules/preparationScreens/components/ProductSelectionModal.tsx
================
import React, { useState, useEffect, useMemo } from 'react';
import {
  View,
  ScrollView,
  StyleSheet,
  TouchableOpacity,
  ActivityIndicator,
} from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Checkbox,
  Button,
  Searchbar,
  Divider,
  IconButton,
} from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useTheme } from 'react-native-paper';

interface Product {
  id: string;
  name: string;
  photo: any;
  price: string | number | null | undefined;
  isAssociated: boolean;
  currentPreparationScreenId: string | null;
}

interface Subcategory {
  id: string;
  name: string;
  photo: any;
  products: Product[];
}

interface Category {
  id: string;
  name: string;
  photo: any;
  subcategories: Subcategory[];
}

interface MenuData {
  screenId: string;
  screenName: string;
  menu: Category[];
  screenAssignments?: Record<string, string>; // Mapeo de productId a nombre de pantalla
}

interface ProductSelectionModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSave: (productIds: string[]) => void;
  screenId: string;
  menuData?: MenuData;
  loading?: boolean;
}

export const ProductSelectionModal: React.FC<ProductSelectionModalProps> = ({
  visible,
  onDismiss,
  onSave,
  screenId,
  menuData,
  loading = false,
}) => {
  const theme = useTheme();
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedProducts, setSelectedProducts] = useState<Set<string>>(
    new Set(),
  );
  const [expandedCategories, setExpandedCategories] = useState<Set<string>>(
    new Set(),
  );
  const [expandedSubcategories, setExpandedSubcategories] = useState<
    Set<string>
  >(new Set());
  const [showConfirmDialog, setShowConfirmDialog] = useState(false);
  const [conflictingProducts, setConflictingProducts] = useState<
    Array<{ id: string; name: string; currentScreen: string }>
  >([]);

  // Inicializar productos seleccionados
  useEffect(() => {
    if (menuData) {
      const associatedProducts = new Set<string>();
      menuData.menu.forEach((category) => {
        category.subcategories.forEach((subcategory) => {
          subcategory.products.forEach((product) => {
            if (product.isAssociated) {
              associatedProducts.add(product.id);
            }
          });
        });
      });
      setSelectedProducts(associatedProducts);
    }
  }, [menuData]);

  // Crear mapeo de productos a nombres de pantalla para el mensaje de conflicto
  const getScreenNameForProduct = (productId: string): string => {
    // Primero intentar obtener el nombre desde screenAssignments
    if (menuData?.screenAssignments && menuData.screenAssignments[productId]) {
      return menuData.screenAssignments[productId];
    }

    // Si no est disponible, usar un nombre genrico
    return 'otra pantalla de preparacin';
  };

  // Filtrar men basado en bsqueda
  const filteredMenu = useMemo(() => {
    if (!menuData || !searchQuery) return menuData?.menu || [];

    const query = searchQuery.toLowerCase();
    return menuData.menu
      .map((category) => ({
        ...category,
        subcategories: category.subcategories
          .map((subcategory) => ({
            ...subcategory,
            products: subcategory.products.filter((product) =>
              product.name.toLowerCase().includes(query),
            ),
          }))
          .filter((subcategory) => subcategory.products.length > 0),
      }))
      .filter((category) => category.subcategories.length > 0);
  }, [menuData, searchQuery]);

  const toggleCategory = (categoryId: string) => {
    const newExpanded = new Set(expandedCategories);
    if (newExpanded.has(categoryId)) {
      newExpanded.delete(categoryId);
    } else {
      newExpanded.add(categoryId);
    }
    setExpandedCategories(newExpanded);
  };

  const toggleSubcategory = (subcategoryId: string) => {
    const newExpanded = new Set(expandedSubcategories);
    if (newExpanded.has(subcategoryId)) {
      newExpanded.delete(subcategoryId);
    } else {
      newExpanded.add(subcategoryId);
    }
    setExpandedSubcategories(newExpanded);
  };

  const toggleProduct = (productId: string) => {
    const newSelected = new Set(selectedProducts);
    if (newSelected.has(productId)) {
      newSelected.delete(productId);
    } else {
      newSelected.add(productId);
    }
    setSelectedProducts(newSelected);
  };

  const toggleAllInCategory = (category: Category) => {
    const newSelected = new Set(selectedProducts);
    const categoryProducts = category.subcategories.flatMap((sub) =>
      sub.products.map((p) => p.id),
    );

    const allSelected = categoryProducts.every((id) => newSelected.has(id));

    if (allSelected) {
      categoryProducts.forEach((id) => newSelected.delete(id));
    } else {
      categoryProducts.forEach((id) => newSelected.add(id));
    }

    setSelectedProducts(newSelected);
  };

  const toggleAllInSubcategory = (subcategory: Subcategory) => {
    const newSelected = new Set(selectedProducts);
    const subcategoryProducts = subcategory.products.map((p) => p.id);

    const allSelected = subcategoryProducts.every((id) => newSelected.has(id));

    if (allSelected) {
      subcategoryProducts.forEach((id) => newSelected.delete(id));
    } else {
      subcategoryProducts.forEach((id) => newSelected.add(id));
    }

    setSelectedProducts(newSelected);
  };

  const isCategoryPartiallySelected = (category: Category) => {
    const categoryProducts = category.subcategories.flatMap((sub) =>
      sub.products.map((p) => p.id),
    );
    const selectedCount = categoryProducts.filter((id) =>
      selectedProducts.has(id),
    ).length;
    return selectedCount > 0 && selectedCount < categoryProducts.length;
  };

  const isCategoryFullySelected = (category: Category) => {
    const categoryProducts = category.subcategories.flatMap((sub) =>
      sub.products.map((p) => p.id),
    );
    return (
      categoryProducts.length > 0 &&
      categoryProducts.every((id) => selectedProducts.has(id))
    );
  };

  const isSubcategoryPartiallySelected = (subcategory: Subcategory) => {
    const selectedCount = subcategory.products.filter((p) =>
      selectedProducts.has(p.id),
    ).length;
    return selectedCount > 0 && selectedCount < subcategory.products.length;
  };

  const isSubcategoryFullySelected = (subcategory: Subcategory) => {
    return (
      subcategory.products.length > 0 &&
      subcategory.products.every((p) => selectedProducts.has(p.id))
    );
  };

  const handleSave = () => {
    // Verificar si hay productos seleccionados que ya estn asignados a otras pantallas
    const conflicts: Array<{
      id: string;
      name: string;
      currentScreen: string;
    }> = [];

    if (menuData) {
      menuData.menu.forEach((category) => {
        category.subcategories.forEach((subcategory) => {
          subcategory.products.forEach((product) => {
            if (
              selectedProducts.has(product.id) &&
              product.currentPreparationScreenId &&
              product.currentPreparationScreenId !== screenId
            ) {
              // Buscar el nombre de la pantalla actual del producto
              const screenName = getScreenNameForProduct(product.id);
              conflicts.push({
                id: product.id,
                name: product.name,
                currentScreen: screenName,
              });
            }
          });
        });
      });
    }

    if (conflicts.length > 0) {
      setConflictingProducts(conflicts);
      setShowConfirmDialog(true);
    } else {
      onSave(Array.from(selectedProducts));
    }
  };

  const handleConfirmSave = () => {
    setShowConfirmDialog(false);
    onSave(Array.from(selectedProducts));
  };

  const handleCancelSave = () => {
    setShowConfirmDialog(false);
  };

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={[
          styles.modalContainer,
          { backgroundColor: theme.colors.surface },
        ]}
      >
        <View style={styles.header}>
          <Text variant="headlineSmall">Seleccionar Productos</Text>
        </View>

        <Searchbar
          placeholder="Buscar productos..."
          onChangeText={setSearchQuery}
          value={searchQuery}
          style={styles.searchBar}
        />

        {loading ? (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
          </View>
        ) : (
          <ScrollView
            style={styles.scrollView}
            showsVerticalScrollIndicator={false}
          >
            {filteredMenu.map((category) => (
              <View key={category.id} style={styles.categoryContainer}>
                <TouchableOpacity
                  style={styles.categoryHeader}
                  onPress={() => toggleCategory(category.id)}
                >
                  <View style={styles.categoryTitleContainer}>
                    <IconButton
                      icon={
                        expandedCategories.has(category.id)
                          ? 'chevron-down'
                          : 'chevron-right'
                      }
                      size={20}
                    />
                    <Text variant="titleMedium" style={styles.categoryTitle}>
                      {category.name}
                    </Text>
                  </View>
                  <Checkbox.Android
                    status={
                      isCategoryFullySelected(category)
                        ? 'checked'
                        : isCategoryPartiallySelected(category)
                          ? 'indeterminate'
                          : 'unchecked'
                    }
                    onPress={() => toggleAllInCategory(category)}
                  />
                </TouchableOpacity>

                {expandedCategories.has(category.id) && (
                  <View style={styles.subcategoriesContainer}>
                    {category.subcategories.map((subcategory) => (
                      <View
                        key={subcategory.id}
                        style={styles.subcategoryContainer}
                      >
                        <TouchableOpacity
                          style={styles.subcategoryHeader}
                          onPress={() => toggleSubcategory(subcategory.id)}
                        >
                          <View style={styles.subcategoryTitleContainer}>
                            <IconButton
                              icon={
                                expandedSubcategories.has(subcategory.id)
                                  ? 'chevron-down'
                                  : 'chevron-right'
                              }
                              size={16}
                            />
                            <Text
                              variant="titleSmall"
                              style={styles.subcategoryTitle}
                            >
                              {subcategory.name}
                            </Text>
                          </View>
                          <Checkbox.Android
                            status={
                              isSubcategoryFullySelected(subcategory)
                                ? 'checked'
                                : isSubcategoryPartiallySelected(subcategory)
                                  ? 'indeterminate'
                                  : 'unchecked'
                            }
                            onPress={() => toggleAllInSubcategory(subcategory)}
                          />
                        </TouchableOpacity>

                        {expandedSubcategories.has(subcategory.id) && (
                          <View style={styles.productsContainer}>
                            {subcategory.products.map((product) => (
                              <TouchableOpacity
                                key={product.id}
                                style={styles.productItem}
                                onPress={() => toggleProduct(product.id)}
                              >
                                <View style={styles.productInfo}>
                                  <Text variant="bodyMedium">
                                    {product.name}
                                  </Text>
                                  {product.currentPreparationScreenId &&
                                    product.currentPreparationScreenId !==
                                      screenId && (
                                      <View style={styles.warningContainer}>
                                        <MaterialCommunityIcons
                                          name="alert"
                                          size={12}
                                          color={theme.colors.error}
                                        />
                                        <Text
                                          variant="bodySmall"
                                          style={[
                                            styles.warningText,
                                            { color: theme.colors.error },
                                          ]}
                                        >
                                          Asignado a otra pantalla
                                        </Text>
                                      </View>
                                    )}
                                </View>
                                <Checkbox.Android
                                  status={
                                    selectedProducts.has(product.id)
                                      ? 'checked'
                                      : 'unchecked'
                                  }
                                  onPress={() => toggleProduct(product.id)}
                                />
                              </TouchableOpacity>
                            ))}
                          </View>
                        )}
                      </View>
                    ))}
                  </View>
                )}
                <Divider style={styles.divider} />
              </View>
            ))}
          </ScrollView>
        )}

        <View style={styles.actions}>
          <Button mode="outlined" onPress={onDismiss}>
            Cancelar
          </Button>
          <Button mode="contained" onPress={handleSave} disabled={loading}>
            Guardar
          </Button>
        </View>
      </Modal>

      {/* Modal de confirmacin personalizado */}
      <Modal
        visible={showConfirmDialog}
        onDismiss={handleCancelSave}
        contentContainerStyle={[
          styles.confirmModalContainer,
          { backgroundColor: theme.colors.surface },
        ]}
      >
        {/* Header */}
        <View
          style={[
            styles.confirmModalHeader,
            { borderBottomColor: theme.colors.surfaceVariant },
          ]}
        >
          <View
            style={[
              styles.confirmModalIcon,
              { backgroundColor: theme.colors.errorContainer },
            ]}
          >
            <MaterialCommunityIcons
              name="alert"
              size={24}
              color={theme.colors.error}
            />
          </View>
          <Text variant="headlineSmall" style={styles.confirmModalTitle}>
            Reasignar Productos
          </Text>
        </View>

        {/* Subtitle */}
        <View style={styles.confirmModalSubtitleContainer}>
          <Text
            variant="bodyLarge"
            style={{
              color: theme.colors.onSurfaceVariant,
            }}
          >
            {conflictingProducts.length === 1
              ? 'El siguiente producto ser reasignado:'
              : `Los siguientes ${conflictingProducts.length} productos sern reasignados:`}
          </Text>
        </View>

        {/* Scrollable Product List */}
        <ScrollView
          style={styles.confirmModalScrollView}
          showsVerticalScrollIndicator={true}
        >
          {conflictingProducts.map((product, _index) => (
            <View
              key={product.id}
              style={[
                styles.confirmModalProductItem,
                {
                  backgroundColor: theme.colors.surfaceVariant,
                  borderLeftColor: theme.colors.error,
                },
              ]}
            >
              <Text
                variant="bodyLarge"
                style={[
                  styles.confirmModalProductName,
                  { color: theme.colors.onSurface },
                ]}
              >
                {product.name}
              </Text>
              <View
                style={[
                  styles.confirmModalProductContent,
                  { backgroundColor: theme.colors.surface },
                ]}
              >
                <View style={styles.confirmModalProductSection}>
                  <Text
                    variant="labelSmall"
                    style={[
                      styles.confirmModalProductSectionText,
                      { color: theme.colors.onSurfaceVariant },
                    ]}
                  >
                    Desde
                  </Text>
                  <Text
                    variant="bodySmall"
                    style={[
                      styles.confirmModalProductSectionLabel,
                      { color: theme.colors.error },
                    ]}
                  >
                    {product.currentScreen}
                  </Text>
                </View>

                <MaterialCommunityIcons
                  name="arrow-right"
                  size={20}
                  color={theme.colors.primary}
                  style={styles.confirmModalDivider}
                />

                <View style={styles.confirmModalProductSection}>
                  <Text
                    variant="labelSmall"
                    style={[
                      styles.confirmModalProductSectionText,
                      { color: theme.colors.onSurfaceVariant },
                    ]}
                  >
                    Hacia
                  </Text>
                  <Text
                    variant="bodySmall"
                    style={[
                      styles.confirmModalProductSectionLabel,
                      { color: theme.colors.primary },
                    ]}
                  >
                    {menuData?.screenName || 'Esta pantalla'}
                  </Text>
                </View>
              </View>
            </View>
          ))}
        </ScrollView>

        {/* Info Box */}
        <View
          style={[
            styles.confirmModalInfoContainer,
            { backgroundColor: theme.colors.secondaryContainer },
          ]}
        >
          <MaterialCommunityIcons
            name="information"
            size={20}
            color={theme.colors.onSecondaryContainer}
            style={styles.confirmModalInfoIcon}
          />
          <Text
            variant="bodySmall"
            style={[
              styles.confirmModalInfoText,
              { color: theme.colors.onSecondaryContainer },
            ]}
          >
            Los productos sern removidos automticamente de sus pantallas
            actuales al confirmar.
          </Text>
        </View>

        {/* Actions */}
        <View
          style={[
            styles.confirmModalActions,
            { borderTopColor: theme.colors.surfaceVariant },
          ]}
        >
          <Button
            onPress={handleCancelSave}
            mode="outlined"
            style={[
              styles.confirmModalActionButton,
              { borderColor: theme.colors.outline },
            ]}
            contentStyle={styles.confirmModalActionButtonContent}
          >
            Cancelar
          </Button>
          <Button
            onPress={handleConfirmSave}
            mode="contained"
            buttonColor={theme.colors.error}
            icon="check-circle"
            style={styles.confirmModalActionButton}
            contentStyle={styles.confirmModalActionButtonContent}
          >
            Reasignar
          </Button>
        </View>
      </Modal>
    </Portal>
  );
};

const styles = StyleSheet.create({
  modalContainer: {
    margin: 20,
    padding: 20,
    borderRadius: 8,
    maxHeight: '90%',
  },
  header: {
    marginBottom: 16,
  },
  searchBar: {
    marginBottom: 16,
  },
  scrollView: {
    maxHeight: 400,
  },
  loadingContainer: {
    height: 200,
    justifyContent: 'center',
    alignItems: 'center',
  },
  categoryContainer: {
    marginBottom: 8,
  },
  categoryHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 8,
  },
  categoryTitleContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  categoryTitle: {
    fontWeight: 'bold',
  },
  subcategoriesContainer: {
    paddingLeft: 20,
  },
  subcategoryContainer: {
    marginBottom: 4,
  },
  subcategoryHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 4,
  },
  subcategoryTitleContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  subcategoryTitle: {
    fontWeight: '600',
  },
  productsContainer: {
    paddingLeft: 20,
  },
  productItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 8,
    paddingLeft: 16,
  },
  productInfo: {
    flex: 1,
  },
  warningContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 2,
  },
  warningText: {
    marginLeft: 4,
    fontSize: 11,
  },
  divider: {
    marginTop: 8,
  },
  actions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 16,
  },
  // Estilos para el modal de confirmacin
  confirmModalContainer: {
    margin: 20,
    borderRadius: 16,
    maxHeight: '75%',
    elevation: 8,
  },
  confirmModalHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 20,
    paddingBottom: 16,
    borderBottomWidth: 1,
  },
  confirmModalIcon: {
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  confirmModalTitle: {
    flex: 1,
  },
  confirmModalSubtitleContainer: {
    paddingHorizontal: 20,
    paddingTop: 16,
  },
  confirmModalScrollView: {
    maxHeight: 250,
    marginTop: 16,
    marginHorizontal: 20,
  },
  confirmModalProductItem: {
    paddingVertical: 14,
    paddingHorizontal: 16,
    borderRadius: 12,
    marginBottom: 8,
    borderLeftWidth: 4,
  },
  confirmModalProductName: {
    fontWeight: '600',
    marginBottom: 8,
  },
  confirmModalProductContent: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 8,
    borderRadius: 8,
  },
  confirmModalProductSection: {
    flex: 1,
    alignItems: 'center',
  },
  confirmModalProductSectionText: {
    marginBottom: 2,
  },
  confirmModalProductSectionLabel: {
    fontWeight: '500',
  },
  confirmModalDivider: {
    marginHorizontal: 8,
  },
  confirmModalInfoContainer: {
    margin: 20,
    marginTop: 16,
    marginBottom: 0,
    padding: 16,
    borderRadius: 12,
    flexDirection: 'row',
    alignItems: 'center',
  },
  confirmModalInfoIcon: {
    marginRight: 12,
  },
  confirmModalInfoText: {
    flex: 1,
  },
  confirmModalActions: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
    paddingTop: 16,
    gap: 16,
    borderTopWidth: 1,
    marginTop: 16,
  },
  confirmModalActionButton: {
    flex: 1,
    maxWidth: 150,
  },
  confirmModalActionButtonContent: {
    paddingVertical: 4,
  },
});

================
File: app/src/modules/preparationScreens/hooks/usePreparationScreensQueries.ts
================
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import * as preparationScreenService from '../services/preparationScreenService';
import {
  PreparationScreen,
  CreatePreparationScreenDto,
  UpdatePreparationScreenDto,
  FindAllPreparationScreensDto,
} from '../schema/preparationScreen.schema';
import { BaseListQuery } from '../../../app/types/query.types';
import { PaginatedResponse } from '../../../app/types/api.types';
import { useSnackbarStore } from '../../../app/store/snackbarStore';
import { getApiErrorMessage } from '../../../app/lib/errorMapping';

// --- Query Keys ---
const preparationScreensQueryKeys = {
  all: ['preparationScreens'] as const,
  lists: () => [...preparationScreensQueryKeys.all, 'list'] as const,
  list: (filters: FindAllPreparationScreensDto & BaseListQuery) =>
    [...preparationScreensQueryKeys.lists(), filters] as const,
  details: () => [...preparationScreensQueryKeys.all, 'detail'] as const,
  detail: (id: string) =>
    [...preparationScreensQueryKeys.details(), id] as const,
  products: (id: string) =>
    [...preparationScreensQueryKeys.detail(id), 'products'] as const,
  menuWithAssociations: (id: string) =>
    [
      ...preparationScreensQueryKeys.detail(id),
      'menuWithAssociations',
    ] as const,
};

// --- Hooks ---

/**
 * Hook to fetch a paginated list of preparation screens with filters.
 */
export const useGetPreparationScreens = (
  filters: FindAllPreparationScreensDto = {},
  pagination: BaseListQuery = { page: 1, limit: 15 }, // Default limit 15
) => {
  const queryKey = preparationScreensQueryKeys.list({
    ...filters,
    ...pagination,
  });
  return useQuery<PaginatedResponse<PreparationScreen>, Error>({
    queryKey,
    queryFn: () =>
      preparationScreenService.getPreparationScreens(filters, pagination),
    // Considerar placeholderData o initialData si es necesario para UX
  });
};

/**
 * Hook to fetch a single preparation screen by its ID.
 */
export const useGetPreparationScreenById = (
  id: string | null,
  options?: { enabled?: boolean },
) => {
  const queryKey = preparationScreensQueryKeys.detail(id!); // Use non-null assertion as it's enabled conditionally
  return useQuery<PreparationScreen, Error>({
    queryKey,
    queryFn: () => preparationScreenService.getPreparationScreenById(id!),
    enabled: !!id && (options?.enabled ?? true), // Only run query if id is provided and enabled
  });
};

/**
 * Hook for creating a new preparation screen.
 */
export const useCreatePreparationScreen = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<PreparationScreen, Error, CreatePreparationScreenDto>({
    mutationFn: preparationScreenService.createPreparationScreen,
    onSuccess: () => {
      // Invalidate list queries to refetch
      queryClient.invalidateQueries({
        queryKey: preparationScreensQueryKeys.lists(),
      });
      showSnackbar({
        message: 'Pantalla de preparacin creada con xito',
        type: 'success',
      });
    },
    onError: (error) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
    },
  });
};

/**
 * Hook for updating an existing preparation screen.
 */
export const useUpdatePreparationScreen = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  // Contexto para actualizacin optimista
  type UpdatePreparationScreenContext = { previousDetail?: PreparationScreen };

  return useMutation<
    PreparationScreen,
    Error,
    { id: string; data: UpdatePreparationScreenDto },
    UpdatePreparationScreenContext
  >({
    mutationFn: ({ id, data }) =>
      preparationScreenService.updatePreparationScreen(id, data),

    // --- Inicio Actualizacin Optimista ---
    onMutate: async (variables) => {
      const { id, data } = variables;
      const detailQueryKey = preparationScreensQueryKeys.detail(id);

      // 1. Cancelar query de detalle
      await queryClient.cancelQueries({ queryKey: detailQueryKey });

      // 2. Guardar estado anterior del detalle
      const previousDetail =
        queryClient.getQueryData<PreparationScreen>(detailQueryKey);

      // 3. Actualizar cach de detalle optimistamente
      if (previousDetail) {
        // Fusionar datos antiguos y nuevos. Asumiendo que UpdatePreparationScreenDto no tiene estructuras anidadas problemticas.
        queryClient.setQueryData<PreparationScreen>(detailQueryKey, (old) =>
          old ? { ...old, ...data } : undefined,
        );
      }

      // 4. Retornar contexto
      return { previousDetail };
    },
    // --- Fin Actualizacin Optimista ---

    onError: (error, variables, context) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
      // Error al actualizar pantalla de preparacin

      // Revertir cach de detalle
      if (context?.previousDetail) {
        queryClient.setQueryData(
          preparationScreensQueryKeys.detail(variables.id),
          context.previousDetail,
        );
      }
    },

    onSettled: (data, error, variables) => {
      // Invalidar listas y detalle para consistencia final
      queryClient.invalidateQueries({
        queryKey: preparationScreensQueryKeys.lists(),
      });
      queryClient.invalidateQueries({
        queryKey: preparationScreensQueryKeys.detail(variables.id),
      });

      // Mostrar snackbar de xito solo si no hubo error
      if (!error && data) {
        showSnackbar({
          message: 'Pantalla de preparacin actualizada con xito',
          type: 'success',
        });
      }
    },
  });
};

/**
 * Hook for deleting a preparation screen.
 */
export const useDeletePreparationScreen = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  // Contexto para guardar el detalle eliminado
  type DeletePreparationScreenContext = { previousDetail?: PreparationScreen };

  return useMutation<void, Error, string, DeletePreparationScreenContext>({
    mutationFn: preparationScreenService.deletePreparationScreen,

    // --- Inicio Actualizacin Optimista ---
    onMutate: async (deletedId) => {
      const detailQueryKey = preparationScreensQueryKeys.detail(deletedId);

      // 1. Cancelar query de detalle
      await queryClient.cancelQueries({ queryKey: detailQueryKey });

      // 2. Guardar estado anterior del detalle
      const previousDetail =
        queryClient.getQueryData<PreparationScreen>(detailQueryKey);

      // 3. Eliminar optimistamente de la cach de detalle
      queryClient.removeQueries({ queryKey: detailQueryKey });

      // 4. Retornar contexto
      return { previousDetail };
    },
    // --- Fin Actualizacin Optimista ---

    onError: (error, deletedId, context) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });

      // Revertir cach de detalle si hubo error
      if (context?.previousDetail) {
        queryClient.setQueryData(
          preparationScreensQueryKeys.detail(deletedId),
          context.previousDetail,
        );
      }
    },

    onSettled: (_, error, deletedId) => {
      // Invalidar listas para asegurar consistencia final
      queryClient.invalidateQueries({
        queryKey: preparationScreensQueryKeys.lists(),
      });

      // Asegurar remocin en xito y mostrar snackbar
      if (!error) {
        queryClient.removeQueries({
          queryKey: preparationScreensQueryKeys.detail(deletedId),
        });
        showSnackbar({
          message: 'Pantalla de preparacin eliminada con xito',
          type: 'success',
        });
      }
    },
  });
};

/**
 * Hook to fetch products associated with a preparation screen.
 */
export const useGetPreparationScreenProducts = (
  id: string | null,
  options?: { enabled?: boolean },
) => {
  const queryKey = preparationScreensQueryKeys.products(id!);
  return useQuery<any[], Error>({
    queryKey,
    queryFn: () => preparationScreenService.getPreparationScreenProducts(id!),
    enabled: !!id && (options?.enabled ?? true),
  });
};

/**
 * Hook to fetch menu with associations for a preparation screen.
 */
export const useGetMenuWithAssociations = (
  id: string | null,
  options?: { enabled?: boolean },
) => {
  const queryKey = preparationScreensQueryKeys.menuWithAssociations(id!);
  return useQuery<any, Error>({
    queryKey,
    queryFn: () => preparationScreenService.getMenuWithAssociations(id!),
    enabled: !!id && (options?.enabled ?? true),
  });
};

/**
 * Hook for associating products with a preparation screen.
 */
export const useAssociateProducts = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<
    PreparationScreen,
    Error,
    { id: string; productIds: string[] }
  >({
    mutationFn: ({ id, productIds }) =>
      preparationScreenService.associateProducts(id, productIds),
    onSuccess: (_, variables) => {
      // Invalidate related queries
      queryClient.invalidateQueries({
        queryKey: preparationScreensQueryKeys.detail(variables.id),
      });
      queryClient.invalidateQueries({
        queryKey: preparationScreensQueryKeys.products(variables.id),
      });
      queryClient.invalidateQueries({
        queryKey: preparationScreensQueryKeys.menuWithAssociations(
          variables.id,
        ),
      });
      queryClient.invalidateQueries({
        queryKey: preparationScreensQueryKeys.lists(),
      });

      showSnackbar({
        message: 'Productos asociados con xito',
        type: 'success',
      });
    },
    onError: (error) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
    },
  });
};

================
File: app/src/modules/printers/components/PrinterListItem.tsx
================
import React from 'react';
import { View, StyleSheet, Pressable } from 'react-native';
import { Text, Surface, Icon, Chip } from 'react-native-paper';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { ThermalPrinter } from '../types/printer.types';

interface PrinterListItemProps {
  printer: ThermalPrinter;
  onPress: () => void;
  renderActions?: React.ReactNode;
}

const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      marginHorizontal: theme.spacing.m,
      marginVertical: theme.spacing.xs,
      borderRadius: theme.roundness * 2,
      overflow: 'hidden',
      elevation: 2,
    },
    pressable: {
      padding: theme.spacing.m,
    },
    content: {
      gap: theme.spacing.s,
    },
    header: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    titleRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
      flex: 1,
      marginRight: 60,
    },
    printerIcon: {
      backgroundColor: theme.colors.primaryContainer,
      borderRadius: theme.roundness,
      padding: theme.spacing.xs,
    },
    titleContainer: {
      flex: 1,
    },
    title: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    connectionInfo: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
    },
    statusBadge: {
      backgroundColor: theme.colors.surface,
      borderWidth: 1,
    },
    activeBadge: {
      borderColor: theme.colors.primary,
    },
    inactiveBadge: {
      borderColor: theme.colors.error,
    },
    detailsContainer: {
      flexDirection: 'row',
      flexWrap: 'wrap',
      gap: theme.spacing.xs,
      marginTop: theme.spacing.xs,
      marginRight: 60,
    },
    detailChip: {
      height: 24,
      backgroundColor: theme.colors.surfaceVariant,
    },
    detailChipLabel: {
      fontSize: 11,
      marginHorizontal: 8,
      marginVertical: 0,
    },
    featuresRow: {
      flexDirection: 'row',
      gap: theme.spacing.xs,
      marginTop: theme.spacing.xs,
      marginRight: 60,
    },
    featureChip: {
      height: 28,
      backgroundColor: theme.colors.secondaryContainer,
    },
    featureChipLabel: {
      fontSize: 12,
      marginHorizontal: 10,
      marginVertical: 0,
      color: theme.colors.onSecondaryContainer,
    },
    actionsContainer: {
      position: 'absolute',
      right: theme.spacing.m,
      top: theme.spacing.m,
    },
  });

const PrinterListItem: React.FC<PrinterListItemProps> = ({
  printer,
  onPress,
  renderActions,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => getStyles(theme), [theme]);

  const getConnectionDisplay = () => {
    if (printer.connectionType === 'NETWORK' && printer.ipAddress) {
      return `${printer.ipAddress}:${printer.port || 9100}`;
    }
    return printer.connectionType;
  };

  const hasAutoPrintFeatures =
    printer.autoDeliveryPrint || printer.autoPickupPrint;

  return (
    <Surface style={styles.container}>
      <Pressable
        style={styles.pressable}
        onPress={onPress}
        android_ripple={{ color: theme.colors.primary + '20' }}
      >
        <View style={styles.content}>
          <View style={styles.header}>
            <View style={styles.titleRow}>
              <View style={styles.printerIcon}>
                <Icon
                  source="printer"
                  size={20}
                  color={theme.colors.onPrimaryContainer}
                />
              </View>
              <View style={styles.titleContainer}>
                <Text style={styles.title}>{printer.name}</Text>
                <Text style={styles.connectionInfo}>
                  {getConnectionDisplay()}
                </Text>
              </View>
            </View>
            {renderActions && (
              <View style={styles.actionsContainer}>{renderActions}</View>
            )}
          </View>

          <View style={styles.detailsContainer}>
            <Chip
              mode="flat"
              style={[
                styles.statusBadge,
                printer.isActive ? styles.activeBadge : styles.inactiveBadge,
              ]}
              textStyle={[
                styles.detailChipLabel,
                {
                  color: printer.isActive
                    ? theme.colors.primary
                    : theme.colors.error,
                },
              ]}
            >
              {printer.isActive ? 'Activa' : 'Inactiva'}
            </Chip>

            {printer.isDefaultPrinter && (
              <Chip
                mode="flat"
                style={styles.detailChip}
                textStyle={styles.detailChipLabel}
                icon="star"
              >
                Predeterminada
              </Chip>
            )}

            <Chip
              mode="flat"
              style={styles.detailChip}
              textStyle={styles.detailChipLabel}
              icon="file-document-outline"
            >
              {printer.paperWidth}mm
            </Chip>
          </View>

          {hasAutoPrintFeatures && (
            <View style={styles.featuresRow}>
              {printer.autoDeliveryPrint && (
                <Chip
                  mode="flat"
                  style={styles.featureChip}
                  textStyle={styles.featureChipLabel}
                  icon="home-export-outline"
                >
                  Auto Domicilio
                </Chip>
              )}
              {printer.autoPickupPrint && (
                <Chip
                  mode="flat"
                  style={styles.featureChip}
                  textStyle={styles.featureChipLabel}
                  icon="bag-checked"
                >
                  Auto Para Llevar
                </Chip>
              )}
            </View>
          )}
        </View>
      </Pressable>
    </Surface>
  );
};

export default PrinterListItem;

================
File: app/src/modules/printers/navigation/PrintersStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { PrintersStackParamList } from './types';
import PrintersScreen from '../screens/PrintersScreen';
import { useAppTheme } from '@/app/styles/theme';
import { getStackHeaderOptions } from '@/app/navigation/options';

const Stack = createNativeStackNavigator<PrintersStackParamList>();

const PrintersStackNavigator = () => {
  const theme = useAppTheme();

  return (
    <Stack.Navigator
      initialRouteName="PrintersList"
      screenOptions={{
        ...getStackHeaderOptions(theme),
      }}
    >
      <Stack.Screen
        name="PrintersList"
        component={PrintersScreen}
        options={{
          title: 'Impresoras',
        }}
      />
    </Stack.Navigator>
  );
};

export default PrintersStackNavigator;

================
File: app/src/modules/printers/navigation/types.ts
================
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import type { DrawerScreenProps } from '@react-navigation/drawer';
import { AppDrawerParamList } from '@/app/navigation/types';

export type PrintersStackParamList = {
  PrintersList: undefined;
};

export type PrintersListScreenProps = NativeStackScreenProps<
  PrintersStackParamList,
  'PrintersList'
>;

export type PrintersDrawerScreenProps = DrawerScreenProps<
  AppDrawerParamList,
  'PrintersStack'
>;

================
File: app/src/modules/receipts/navigation/ReceiptsStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { ReceiptsScreen } from '../screens/ReceiptsScreen';
import { getStackHeaderOptions } from '@/app/navigation/options';
import { useAppTheme } from '@/app/styles/theme';
import { ReceiptsStackParamList } from './types';

const Stack = createNativeStackNavigator<ReceiptsStackParamList>();

export const ReceiptsStackNavigator = () => {
  const theme = useAppTheme();

  return (
    <Stack.Navigator screenOptions={getStackHeaderOptions(theme)}>
      <Stack.Screen
        name="ReceiptsList"
        component={ReceiptsScreen}
        options={{
          title: 'Recibos',
          headerShown: false,
        }}
      />
    </Stack.Navigator>
  );
};

================
File: app/src/modules/restaurantConfig/components/BusinessHoursForm.tsx
================
import React from 'react';
import { View, StyleSheet, TouchableOpacity } from 'react-native';
import { Text, Switch, Chip, Card } from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import DateTimePickerSafe from '@/app/components/DateTimePickerSafe';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import {
  BusinessHours,
  CreateBusinessHoursDto,
} from '../schema/restaurantConfig.schema';

interface BusinessHoursFormProps {
  businessHours: BusinessHours[] | CreateBusinessHoursDto[];
  isEditing: boolean;
  onChange: (businessHours: CreateBusinessHoursDto[]) => void;
}

const DAYS_OF_WEEK = [
  'Domingo',
  'Lunes',
  'Martes',
  'Mircoles',
  'Jueves',
  'Viernes',
  'Sbado',
];

const BusinessHoursForm: React.FC<BusinessHoursFormProps> = ({
  businessHours,
  isEditing,
  onChange,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);

  const [showTimePicker, setShowTimePicker] = React.useState(false);
  const [currentPickerConfig, setCurrentPickerConfig] = React.useState<{
    dayIndex: number;
    type: 'opening' | 'closing';
    currentDate: Date;
  } | null>(null);

  // Initialize business hours if empty
  const initializedHours = React.useMemo(() => {
    if (businessHours.length === 0) {
      return DAYS_OF_WEEK.map((_, index) => ({
        dayOfWeek: index,
        openingTime: '09:00',
        closingTime: '22:00',
        isClosed: false,
        closesNextDay: false,
      }));
    }

    // Asegurar que closesNextDay est calculado para cada horario
    return businessHours.map((hour) => {
      if (hour.openingTime && hour.closingTime && !hour.isClosed) {
        const [openHour, openMin] = hour.openingTime.split(':').map(Number);
        const [closeHour, closeMin] = hour.closingTime.split(':').map(Number);

        const closesNextDay =
          closeHour < openHour ||
          (closeHour === openHour && closeMin < openMin);

        return { ...hour, closesNextDay };
      }
      return { ...hour, closesNextDay: false };
    });
  }, [businessHours]);

  // Funcin para detectar conflictos de horarios
  const checkScheduleConflict = (dayIndex: number): string | null => {
    const currentDay = initializedHours.find((h) => h.dayOfWeek === dayIndex);
    if (!currentDay || currentDay.isClosed || !currentDay.openingTime) {
      return null;
    }

    // Verificar si el da anterior cierra despus de medianoche
    const previousDayIndex = dayIndex === 0 ? 6 : dayIndex - 1;
    const previousDay = initializedHours.find(
      (h) => h.dayOfWeek === previousDayIndex,
    );

    if (
      !previousDay ||
      previousDay.isClosed ||
      !previousDay.closesNextDay ||
      !previousDay.closingTime
    ) {
      return null;
    }

    // Comparar horarios
    const [currentOpenHour, currentOpenMin] = currentDay.openingTime
      .split(':')
      .map(Number);
    const [prevCloseHour, prevCloseMin] = previousDay.closingTime
      .split(':')
      .map(Number);

    const currentOpenMinutes = currentOpenHour * 60 + currentOpenMin;
    const prevCloseMinutes = prevCloseHour * 60 + prevCloseMin;

    // Si el da actual abre antes o exactamente cuando cierre el da anterior
    if (currentOpenMinutes <= prevCloseMinutes) {
      return `Conflicto: ${DAYS_OF_WEEK[previousDayIndex]} cierra a las ${previousDay.closingTime}. Debe haber al menos 1 minuto de diferencia`;
    }

    return null;
  };

  const handleTimeChange = (
    dayIndex: number,
    type: 'opening' | 'closing',
    time: string | null,
  ) => {
    if (!onChange || !isEditing) return;

    const updatedHours = [...initializedHours];
    const hourIndex = updatedHours.findIndex((h) => h.dayOfWeek === dayIndex);

    if (hourIndex !== -1 && time !== null) {
      if (type === 'opening') {
        updatedHours[hourIndex].openingTime = time;
      } else {
        updatedHours[hourIndex].closingTime = time;
      }

      // Detectar automticamente si cierra al da siguiente
      const hour = updatedHours[hourIndex];
      if (hour.openingTime && hour.closingTime) {
        const [openHour, openMin] = hour.openingTime.split(':').map(Number);
        const [closeHour, closeMin] = hour.closingTime.split(':').map(Number);

        // Si la hora de cierre es menor que la de apertura, cierra al da siguiente
        hour.closesNextDay =
          closeHour < openHour ||
          (closeHour === openHour && closeMin < openMin);
      } else {
        hour.closesNextDay = false;
      }

      onChange(updatedHours as CreateBusinessHoursDto[]);
    }
  };

  const handleClosedChange = (dayIndex: number, isClosed: boolean) => {
    if (!onChange || !isEditing) return;

    const updatedHours = [...initializedHours];
    const hourIndex = updatedHours.findIndex((h) => h.dayOfWeek === dayIndex);

    if (hourIndex !== -1) {
      updatedHours[hourIndex].isClosed = isClosed;
      if (isClosed) {
        updatedHours[hourIndex].openingTime = null;
        updatedHours[hourIndex].closingTime = null;
      }
      onChange(updatedHours as CreateBusinessHoursDto[]);
    }
  };

  const formatTimeForDisplay = (
    timeString: string | null | undefined,
  ): string => {
    if (!timeString) return '';
    // Si el string tiene segundos (formato HH:MM:SS), mostrar solo HH:MM
    if (timeString.length > 5) {
      return timeString.substring(0, 5);
    }
    return timeString;
  };

  const openTimePicker = (dayIndex: number, type: 'opening' | 'closing') => {
    if (!isEditing) return;

    const dayHours = initializedHours.find((h) => h.dayOfWeek === dayIndex);
    const currentTimeString =
      dayHours?.[type === 'opening' ? 'openingTime' : 'closingTime'];

    const date = new Date();
    if (currentTimeString) {
      const [hours, minutes] = currentTimeString.split(':').map(Number);
      date.setHours(hours, minutes, 0, 0);
    } else {
      // Default times
      date.setHours(type === 'opening' ? 9 : 22, 0, 0, 0);
    }

    setCurrentPickerConfig({ dayIndex, type, currentDate: date });
    setShowTimePicker(true);
  };

  const handleTimeConfirm = (date: Date) => {
    setShowTimePicker(false);

    if (currentPickerConfig) {
      const hours = date.getHours().toString().padStart(2, '0');
      const minutes = date.getMinutes().toString().padStart(2, '0');
      const timeString = `${hours}:${minutes}`;

      handleTimeChange(
        currentPickerConfig.dayIndex,
        currentPickerConfig.type,
        timeString,
      );
    }
    setCurrentPickerConfig(null);
  };

  const handleTimeCancel = () => {
    setShowTimePicker(false);
    setCurrentPickerConfig(null);
  };

  return (
    <>
      <View style={styles.container}>
        {DAYS_OF_WEEK.map((day, index) => {
          const dayHours = initializedHours.find(
            (h) => h.dayOfWeek === index,
          ) || {
            dayOfWeek: index,
            openingTime: null,
            closingTime: null,
            isClosed: false,
          };

          return (
            <Card key={index} style={styles.dayCard} mode="elevated">
              <View style={styles.dayHeader}>
                <Text style={styles.dayName}>{day}</Text>
                <View style={styles.dayActions}>
                  <Switch
                    value={!dayHours.isClosed}
                    onValueChange={(value) => {
                      if (isEditing) {
                        handleClosedChange(index, !value);
                      }
                    }}
                    disabled={!isEditing}
                    color={theme.colors.primary}
                  />
                </View>
              </View>

              {!dayHours.isClosed ? (
                <View style={styles.timeContainer}>
                  <TouchableOpacity
                    style={[
                      styles.timeButton,
                      !isEditing && styles.timeButtonDisabled,
                    ]}
                    onPress={() =>
                      isEditing && openTimePicker(index, 'opening')
                    }
                    disabled={!isEditing}
                  >
                    <View style={styles.timeButtonContent}>
                      <MaterialCommunityIcons
                        name="clock-outline"
                        size={20}
                        color={
                          !isEditing
                            ? theme.colors.onSurfaceDisabled
                            : theme.colors.primary
                        }
                      />
                      <View style={styles.timeTextContainer}>
                        <Text
                          style={[
                            styles.timeLabel,
                            !isEditing && styles.timeLabelDisabled,
                          ]}
                        >
                          Apertura
                        </Text>
                        <Text
                          style={[
                            styles.timeValue,
                            !isEditing && styles.timeValueDisabled,
                          ]}
                        >
                          {formatTimeForDisplay(dayHours.openingTime) ||
                            '--:--'}
                        </Text>
                      </View>
                    </View>
                  </TouchableOpacity>

                  <MaterialCommunityIcons
                    name="arrow-right"
                    size={24}
                    color={
                      !isEditing
                        ? theme.colors.onSurfaceDisabled
                        : theme.colors.onSurfaceVariant
                    }
                    style={styles.arrow}
                  />

                  <TouchableOpacity
                    style={[
                      styles.timeButton,
                      !isEditing && styles.timeButtonDisabled,
                    ]}
                    onPress={() =>
                      isEditing && openTimePicker(index, 'closing')
                    }
                    disabled={!isEditing}
                  >
                    <View style={styles.timeButtonContent}>
                      <MaterialCommunityIcons
                        name="clock-check-outline"
                        size={20}
                        color={
                          !isEditing
                            ? theme.colors.onSurfaceDisabled
                            : theme.colors.primary
                        }
                      />
                      <View style={styles.timeTextContainer}>
                        <Text
                          style={[
                            styles.timeLabel,
                            !isEditing && styles.timeLabelDisabled,
                          ]}
                        >
                          Cierre
                        </Text>
                        <Text
                          style={[
                            styles.timeValue,
                            !isEditing && styles.timeValueDisabled,
                          ]}
                        >
                          {formatTimeForDisplay(dayHours.closingTime) ||
                            '--:--'}
                        </Text>
                      </View>
                      {(dayHours as any)?.closesNextDay === true && (
                        <View style={styles.nextDayBadge}>
                          <MaterialCommunityIcons
                            name="moon-waning-crescent"
                            size={12}
                            color={theme.colors.onPrimaryContainer}
                          />
                        </View>
                      )}
                    </View>
                  </TouchableOpacity>
                </View>
              ) : (
                <View style={styles.closedContainer}>
                  <Chip
                    icon="store-off"
                    mode="flat"
                    style={styles.closedChip}
                    textStyle={styles.closedChipText}
                  >
                    Cerrado
                  </Chip>
                </View>
              )}

              {/* Mostrar advertencia de conflicto */}
              {(() => {
                const conflict = checkScheduleConflict(index);
                if (conflict && !dayHours.isClosed) {
                  return (
                    <View style={styles.conflictWarning}>
                      <MaterialCommunityIcons
                        name="alert-circle"
                        size={16}
                        color={theme.colors.error}
                      />
                      <Text style={styles.conflictText}>{conflict}</Text>
                    </View>
                  );
                }
                return null;
              })()}
            </Card>
          );
        })}
      </View>

      <DateTimePickerSafe
        visible={showTimePicker}
        mode="time"
        value={currentPickerConfig?.currentDate || new Date()}
        onConfirm={handleTimeConfirm}
        onCancel={handleTimeCancel}
        minimumDate={undefined}
        maximumDate={undefined}
        minuteInterval={1}
        title={
          currentPickerConfig?.type === 'opening'
            ? `${DAYS_OF_WEEK[currentPickerConfig.dayIndex || 0]} - Apertura`
            : currentPickerConfig?.type === 'closing'
              ? `${DAYS_OF_WEEK[currentPickerConfig.dayIndex || 0]} - Cierre`
              : 'Seleccionar Hora'
        }
        allowManualInput={true}
      />
    </>
  );
};

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      gap: theme.spacing.s,
    },
    dayCard: {
      marginBottom: theme.spacing.s,
      backgroundColor: theme.colors.surface,
      overflow: 'hidden',
      padding: theme.spacing.m,
    },
    dayHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.s,
    },
    dayName: {
      fontSize: 16,
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    dayActions: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    timeContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
    },
    timeButton: {
      flex: 1,
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: 12,
      padding: theme.spacing.m,
      borderWidth: 1,
      borderColor: theme.colors.outline,
      overflow: 'visible',
    },
    timeButtonDisabled: {
      backgroundColor: theme.colors.surface,
      borderColor: theme.colors.surfaceVariant,
    },
    timeButtonContent: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
      position: 'relative',
    },
    timeTextContainer: {
      flex: 1,
    },
    timeLabel: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 2,
    },
    timeLabelDisabled: {
      color: theme.colors.onSurfaceDisabled,
    },
    timeValue: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    timeValueDisabled: {
      color: theme.colors.onSurfaceDisabled,
      fontWeight: '500',
    },
    arrow: {
      marginHorizontal: theme.spacing.xs,
    },
    closedContainer: {
      alignItems: 'center',
      paddingVertical: theme.spacing.s,
    },
    closedChip: {
      backgroundColor: theme.colors.errorContainer,
    },
    closedChipText: {
      fontSize: 12,
      color: theme.colors.onErrorContainer,
    },
    nextDayBadge: {
      position: 'absolute',
      top: -4,
      right: -4,
      backgroundColor: theme.colors.primaryContainer,
      borderRadius: 10,
      width: 20,
      height: 20,
      justifyContent: 'center',
      alignItems: 'center',
      borderWidth: 2,
      borderColor: theme.colors.surface,
    },
    conflictWarning: {
      flexDirection: 'row',
      alignItems: 'center',
      backgroundColor: theme.colors.errorContainer,
      padding: theme.spacing.s,
      marginTop: theme.spacing.s,
      borderRadius: 8,
      gap: theme.spacing.xs,
    },
    conflictText: {
      flex: 1,
      fontSize: 12,
      color: theme.colors.onErrorContainer,
      lineHeight: 16,
    },
  });

export default BusinessHoursForm;

================
File: app/src/modules/restaurantConfig/hooks/useRestaurantConfigQueries.ts
================
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { restaurantConfigService } from '../services/restaurantConfigService';
import { UpdateRestaurantConfigDto } from '../schema/restaurantConfig.schema';
import { useSnackbarStore } from '@/app/store/snackbarStore';

const QUERY_KEYS = {
  config: ['restaurantConfig'],
};

export const useRestaurantConfigQueries = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const useGetConfig = () => {
    return useQuery({
      queryKey: QUERY_KEYS.config,
      queryFn: restaurantConfigService.getConfig,
    });
  };

  const useUpdateConfig = (options?: { successMessage?: string }) => {
    return useMutation({
      mutationFn: (data: UpdateRestaurantConfigDto) =>
        restaurantConfigService.updateConfig(data),
      onSuccess: () => {
        queryClient.invalidateQueries({ queryKey: QUERY_KEYS.config });
        showSnackbar({
          message:
            options?.successMessage || 'Configuracin actualizada exitosamente',
          type: 'success',
        });
      },
      onError: (error: any) => {
        showSnackbar({
          message:
            error.response?.data?.message ||
            'Error al actualizar la configuracin',
          type: 'error',
        });
      },
    });
  };

  return {
    useGetConfig,
    useUpdateConfig,
  };
};

================
File: app/src/modules/restaurantConfig/navigation/RestaurantConfigStackNavigator.tsx
================
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { useAppTheme } from '@/app/styles/theme';
import { getStackHeaderOptions } from '@/app/navigation/options';
import RestaurantConfigScreen from '../screens/RestaurantConfigScreen';
import { RestaurantConfigStackParamList } from './types';

const Stack = createNativeStackNavigator<RestaurantConfigStackParamList>();

export const RestaurantConfigStackNavigator = () => {
  const theme = useAppTheme();

  return (
    <Stack.Navigator screenOptions={getStackHeaderOptions(theme)}>
      <Stack.Screen
        name="RestaurantConfig"
        component={RestaurantConfigScreen}
        options={{
          headerShown: false,
        }}
      />
    </Stack.Navigator>
  );
};

================
File: app/src/modules/restaurantConfig/schema/restaurantConfig.schema.ts
================
import { z } from 'zod';

// Esquema para DeliveryCoveragePoint
export const deliveryCoveragePointSchema = z.object({
  lat: z.number(),
  lng: z.number(),
});

export type DeliveryCoveragePoint = z.infer<typeof deliveryCoveragePointSchema>;

// Esquema para BusinessHours
export const businessHoursSchema = z.object({
  id: z.string(),
  dayOfWeek: z.number().min(0).max(6), // 0 = Domingo, 1 = Lunes, ... 6 = Sbado
  openingTime: z.string().nullable(), // HH:mm
  closingTime: z.string().nullable(), // HH:mm
  closesNextDay: z.boolean().optional(), // true si cierra despus de medianoche
  isClosed: z.boolean(),
  restaurantConfigId: z.string(),
  createdAt: z.string(),
  updatedAt: z.string(),
});

export type BusinessHours = z.infer<typeof businessHoursSchema>;

// Esquema principal para RestaurantConfig
export const restaurantConfigSchema = z.object({
  id: z.string(),
  // Informacin bsica
  restaurantName: z.string(),
  phoneMain: z.string().nullable(),
  phoneSecondary: z.string().nullable(),
  address: z.string().nullable(),
  city: z.string().nullable(),
  state: z.string().nullable(),
  postalCode: z.string().nullable(),
  country: z.string().nullable(),

  // Configuracin de operacin
  acceptingOrders: z.boolean(),
  estimatedPickupTime: z.number(),
  estimatedDeliveryTime: z.number(),
  estimatedDineInTime: z.number(),
  openingGracePeriod: z.number(),
  closingGracePeriod: z.number(),
  timeZone: z.string(),
  scheduledOrdersLeadTime: z.number(),

  // Configuracin de delivery
  deliveryCoverageArea: z.array(deliveryCoveragePointSchema).nullable(),
  minimumOrderValueForDelivery: z.union([z.number(), z.string()]), // Puede venir como string desde el backend (decimal)

  // Relaciones
  businessHours: z.array(businessHoursSchema),

  createdAt: z.string(),
  updatedAt: z.string(),
});

export type RestaurantConfig = z.infer<typeof restaurantConfigSchema>;

// Esquemas para DTOs
export const createBusinessHoursDtoSchema = z.object({
  dayOfWeek: z.number().min(0).max(6),
  openingTime: z.string().nullable().optional(),
  closingTime: z.string().nullable().optional(),
  closesNextDay: z.boolean().optional(),
  isClosed: z.boolean().optional(),
  restaurantConfigId: z.string().optional(),
});

export type CreateBusinessHoursDto = z.infer<
  typeof createBusinessHoursDtoSchema
>;

export const updateBusinessHoursDtoSchema = z.object({
  openingTime: z.string().nullable().optional(),
  closingTime: z.string().nullable().optional(),
  closesNextDay: z.boolean().optional(),
  isClosed: z.boolean().optional(),
});

export type UpdateBusinessHoursDto = z.infer<
  typeof updateBusinessHoursDtoSchema
>;

export const updateRestaurantConfigDtoSchema = z.object({
  // Informacin bsica
  restaurantName: z.string().optional(),
  phoneMain: z.string().nullable().optional(),
  phoneSecondary: z.string().nullable().optional(),
  address: z.string().nullable().optional(),
  city: z.string().nullable().optional(),
  state: z.string().nullable().optional(),
  postalCode: z.string().nullable().optional(),
  country: z.string().nullable().optional(),

  // Configuracin de operacin
  acceptingOrders: z.boolean().optional(),
  estimatedPickupTime: z.number().optional(),
  estimatedDeliveryTime: z.number().optional(),
  estimatedDineInTime: z.number().optional(),
  openingGracePeriod: z.number().optional(),
  closingGracePeriod: z.number().optional(),
  timeZone: z.string().optional(),
  scheduledOrdersLeadTime: z.number().optional(),

  // Configuracin de delivery
  deliveryCoverageArea: z
    .array(deliveryCoveragePointSchema)
    .nullable()
    .optional(),
  minimumOrderValueForDelivery: z.number().optional(),

  // Horarios
  businessHours: z.array(createBusinessHoursDtoSchema).optional(),
});

export type UpdateRestaurantConfigDto = z.infer<
  typeof updateRestaurantConfigDtoSchema
>;

================
File: app/src/modules/shiftAudit/components/BatchOperationsSection.tsx
================
import React from 'react';
import { View } from 'react-native';
import { Text } from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { BatchOperation } from '../types/orderHistory';
import { 
  isBatchOperation, 
  getOperationLabel,
  formatFieldName 
} from '../utils/orderHistoryUtils';
import { ChangeDetailRenderer } from './ChangeDetailRenderer';

interface BatchOperationsSectionProps {
  batchOperations: BatchOperation[];
  styles: any;
}

export const BatchOperationsSection: React.FC<BatchOperationsSectionProps> = ({
  batchOperations,
  styles,
}) => {
  const theme = useAppTheme();

  return (
    <View style={styles.changesContainer}>
      <Text
        variant="bodySmall"
        style={[styles.batchTitle, { color: theme.colors.primary }]}
      >
        Cambios realizados en una sola edicin:
      </Text>

      {batchOperations
        .filter(isBatchOperation)
        .map((op, idx) => (
          <View
            key={idx}
            style={[
              styles.batchOperationContainer,
              idx < batchOperations.length - 1
                ? styles.batchOperationMarginBottom
                : styles.batchOperationNoMargin,
              {
                borderLeftColor: theme.colors.primary + '30',
              },
            ]}
          >
            <View style={styles.batchOperationRow}>
              <Text
                style={[
                  styles.batchBulletText,
                  { color: theme.colors.primary },
                ]}
              >
                
              </Text>
              <View style={styles.batchOperationContent}>
                <Text
                  variant="labelSmall"
                  style={[
                    styles.batchOperationLabel,
                    { color: theme.colors.primary },
                  ]}
                >
                  {getOperationLabel(op.operation)}
                </Text>

                {/* Mostrar descripcin del item */}
                {(op.itemDescription || op.snapshot?.itemDescription) && (
                  <Text
                    variant="bodySmall"
                    style={[
                      styles.batchOperationDescription,
                      {
                        color: theme.colors.onSurface,
                        backgroundColor: theme.colors.surface,
                      },
                    ]}
                  >
                    {op.itemDescription || op.snapshot?.itemDescription}
                  </Text>
                )}

                {/* Para UPDATE, mostrar el cambio */}
                {op.operation === 'UPDATE' && op.formattedChanges && (
                  <View style={styles.batchUpdateMargin}>
                    {Object.entries(op.formattedChanges)
                      .filter(([fieldName]) => {
                        // Solo mostrar campos relevantes (no precios)
                        const allowedFields = [
                          'quantity',
                          'notes',
                          'specialInstructions',
                          'preparationNotes',
                          'status',
                        ];
                        return allowedFields.some((allowed) =>
                          fieldName.includes(allowed),
                        );
                      })
                      .map(([field, change]) => (
                        <View
                          key={field}
                          style={styles.batchFieldContainer}
                        >
                          <Text
                            variant="labelSmall"
                            style={[
                              styles.batchFieldLabel,
                              { color: theme.colors.onSurfaceVariant },
                            ]}
                          >
                            {formatFieldName(field)}:
                          </Text>
                          <ChangeDetailRenderer
                            change={change}
                            fieldName={field}
                            styles={styles}
                          />
                        </View>
                      ))}
                  </View>
                )}
              </View>
            </View>
          </View>
        ))}
    </View>
  );
};

================
File: app/src/modules/shiftAudit/components/ChangeDetailRenderer.tsx
================
import React from 'react';
import { View } from 'react-native';
import { Text } from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { 
  isChangeDetail, 
  safeStringify,
} from '../utils/orderHistoryUtils';

interface ChangeDetailRendererProps {
  change: unknown;
  fieldName?: string;
  styles: any;
}

export const ChangeDetailRenderer: React.FC<ChangeDetailRendererProps> = ({
  change,
  fieldName,
  styles,
}) => {
  const theme = useAppTheme();

  if (!isChangeDetail(change)) {
    // Para arrays de cambios simples
    if (Array.isArray(change) && change.length === 2) {
      return (
        <View style={styles.changeContainer}>
          <View
            style={[
              styles.errorContainer,
              { backgroundColor: theme.colors.errorContainer },
            ]}
          >
            <Text
              variant="labelSmall"
              style={[
                styles.labelSmallMedium,
                { color: theme.colors.onErrorContainer },
              ]}
            >
              {safeStringify(change[0])}
            </Text>
          </View>
          <Text
            style={[
              styles.marginHorizontal4,
              { color: theme.colors.onSurface },
            ]}
          >
            
          </Text>
          <View
            style={[
              styles.primaryContainer,
              { backgroundColor: theme.colors.primaryContainer },
            ]}
          >
            <Text
              variant="labelSmall"
              style={[
                styles.labelSmallMedium,
                { color: theme.colors.onPrimaryContainer },
              ]}
            >
              {safeStringify(change[1])}
            </Text>
          </View>
        </View>
      );
    }

    return (
      <Text variant="bodySmall" style={{ color: theme.colors.onSurface }}>
        {safeStringify(change)}
      </Text>
    );
  }

  // Para descripcin del item, mostrar en formato vertical si es muy largo
  if (
    (fieldName === 'Descripcin del Item' || fieldName === 'Descripcin') &&
    (String(change.anterior).length > 30 || String(change.nuevo).length > 30)
  ) {
    return (
      <View style={styles.marginTop4}>
        <View
          style={[
            styles.errorContainer,
            { backgroundColor: theme.colors.errorContainer },
          ]}
        >
          <Text
            variant="labelSmall"
            style={[
              styles.labelSmallMedium,
              { color: theme.colors.onErrorContainer },
            ]}
          >
            Antes:
          </Text>
          <Text
            variant="bodySmall"
            style={{ color: theme.colors.onErrorContainer }}
          >
            {String(change.anterior)}
          </Text>
        </View>
        <View
          style={[
            styles.primaryContainer,
            { backgroundColor: theme.colors.primaryContainer },
          ]}
        >
          <Text
            variant="labelSmall"
            style={[
              styles.labelSmallMedium,
              { color: theme.colors.onPrimaryContainer },
            ]}
          >
            Despus:
          </Text>
          <Text
            variant="bodySmall"
            style={{ color: theme.colors.onPrimaryContainer }}
          >
            {String(change.nuevo)}
          </Text>
        </View>
      </View>
    );
  }

  // Formato horizontal normal
  return (
    <View style={styles.changeContainer}>
      <View
        style={[
          styles.errorContainer,
          { backgroundColor: theme.colors.errorContainer },
        ]}
      >
        <Text
          variant="labelSmall"
          style={[
            styles.labelSmallMedium,
            { color: theme.colors.onErrorContainer },
          ]}
        >
          {String(change.anterior)}
        </Text>
      </View>
      <Text
        style={[
          styles.marginHorizontal4,
          { color: theme.colors.onSurface },
        ]}
      >
        
      </Text>
      <View
        style={[
          styles.primaryContainer,
          { backgroundColor: theme.colors.primaryContainer },
        ]}
      >
        <Text
          variant="labelSmall"
          style={[
            styles.labelSmallMedium,
            { color: theme.colors.onPrimaryContainer },
          ]}
        >
          {String(change.nuevo)}
        </Text>
      </View>
    </View>
  );
};

================
File: app/src/modules/shiftAudit/components/HistoryItemComponent.tsx
================
import React, { useState, useMemo } from 'react';
import { View, TouchableOpacity } from 'react-native';
import { Text, Divider, Chip, Avatar, Surface } from 'react-native-paper';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import { useAppTheme } from '@/app/styles/theme';
import { HistoryItem } from '../types/orderHistory';
import { 
  getOperationIcon, 
  getOperationLabel, 
  getPreparationStatusColor,
  formatValue,
  safeStringify,
  formatFieldName
} from '../utils/orderHistoryUtils';
import { ChangeDetailRenderer } from './ChangeDetailRenderer';
import { ProductItemRenderer } from './ProductItemRenderer';
import { OrderDetailsSection } from './OrderDetailsSection';
import { BatchOperationsSection } from './BatchOperationsSection';
import { createStyles } from '../styles/orderHistoryStyles';

interface HistoryItemComponentProps {
  item: HistoryItem;
  theme: ReturnType<typeof useAppTheme>;
}

export const HistoryItemComponent: React.FC<HistoryItemComponentProps> = ({ 
  item, 
  theme 
}) => {
  const [expanded, setExpanded] = useState(false);
  const styles = useMemo(() => createStyles(theme), [theme]);

  const getUserDisplayName = (
    changedByUser?: HistoryItem['changedByUser'],
    user?: HistoryItem['user'],
  ): string => {
    if (changedByUser?.firstName && changedByUser?.lastName) {
      return `${changedByUser.firstName} ${changedByUser.lastName}`;
    }
    if (user?.firstName && user?.lastName) {
      return `${user.firstName} ${user.lastName}`;
    }
    return 'Usuario no especificado';
  };

  return (
    <Surface style={styles.historyItem} elevation={1}>
      <TouchableOpacity
        style={styles.historyItemHeader}
        onPress={() => setExpanded(!expanded)}
        activeOpacity={0.7}
      >
        <View style={styles.historyItemContent}>
          <View style={styles.historyItemLeft}>
            <Avatar.Icon
              size={40}
              icon={getOperationIcon(item.operation, item.type)}
              style={[
                styles.operationIcon,
                {
                  backgroundColor:
                    item.type === 'order'
                      ? theme.colors.primaryContainer
                      : theme.colors.secondaryContainer,
                },
              ]}
              theme={{
                colors: {
                  onSurface:
                    item.type === 'order'
                      ? theme.colors.onPrimaryContainer
                      : theme.colors.onSecondaryContainer,
                },
              }}
            />
            <View style={styles.historyItemInfo}>
              <View style={styles.operationBadgeRow}>
                <View
                  style={[
                    styles.operationBadge,
                    {
                      backgroundColor:
                        item.type === 'order'
                          ? theme.colors.primary + '20'
                          : theme.colors.secondary + '20',
                    },
                  ]}
                >
                  <Text
                    variant="labelSmall"
                    style={[
                      styles.operationBadgeText,
                      {
                        color:
                          item.type === 'order'
                            ? theme.colors.primary
                            : theme.colors.secondary,
                      },
                    ]}
                  >
                    {getOperationLabel(item.operation, item.type)}
                  </Text>
                </View>
                {item.preparationStatus && (
                  <Chip
                    mode="flat"
                    textStyle={styles.statusChipText}
                    style={[
                      styles.statusChip,
                      {
                        backgroundColor:
                          getPreparationStatusColor(
                            item.preparationStatus,
                            theme,
                          ) + '20',
                      },
                    ]}
                    compact
                  >
                    {formatValue('preparationStatus', item.preparationStatus)}
                  </Chip>
                )}
              </View>
              <Text variant="labelSmall" style={styles.userText}>
                {getUserDisplayName(item.changedByUser, item.user)}
              </Text>
            </View>
          </View>
          <View style={styles.historyItemRight}>
            {item.preparationStatus && (
              <Chip
                mode="flat"
                textStyle={styles.statusChipText}
                style={[
                  styles.statusChip,
                  {
                    backgroundColor:
                      getPreparationStatusColor(item.preparationStatus, theme) +
                      '20',
                  },
                ]}
                compact
              >
                {formatValue('preparationStatus', item.preparationStatus)}
              </Chip>
            )}
            <Text variant="labelSmall" style={styles.timestampText}>
              {format(new Date(item.changedAt), 'dd/MM/yyyy HH:mm', {
                locale: es,
              })}
            </Text>
          </View>
        </View>
      </TouchableOpacity>

      {expanded && (
        <View style={styles.expandedContent}>
          <Divider style={styles.dividerMargin} />
          
          {/* Contenido para rdenes */}
          {item.type === 'order' && (
            <View style={styles.changesContainer}>
              {item.operation === 'INSERT' && (
                <>
                  {/* Si hay diff consolidado para INSERT, usarlo */}
                  {item.diff && (item.diff.order || item.diff.items) ? (
                    <>
                      {item.diff.summary && (
                        <Text
                          variant="bodySmall"
                          style={[
                            styles.summaryText,
                            { color: theme.colors.primary },
                          ]}
                        >
                          {safeStringify(item.diff.summary)}
                        </Text>
                      )}

                      {/* Informacin de la orden */}
                      {item.diff.order && (
                        <OrderDetailsSection
                          orderDiff={item.diff.order}
                          snapshot={item.snapshot}
                          styles={styles}
                        />
                      )}

                      {/* Productos agregados */}
                      {item.diff.items?.added &&
                        item.diff.items.added.length > 0 && (
                          <>
                            <Text
                              variant="labelSmall"
                              style={[
                                styles.sectionTitle,
                                { color: theme.colors.primary },
                              ]}
                            >
                              Productos incluidos en la orden:
                            </Text>
                            {item.diff.items.added.map((addedItem, idx) => (
                              <ProductItemRenderer
                                key={`added-${idx}`}
                                item={addedItem}
                                index={idx}
                                type="added"
                                styles={styles}
                              />
                            ))}
                          </>
                        )}
                    </>
                  ) : (
                    <Text
                      variant="bodySmall"
                      style={[
                        styles.summaryText,
                        { color: theme.colors.primary },
                      ]}
                    >
                      Orden creada
                    </Text>
                  )}
                </>
              )}

              {/* Renderizado de otros tipos de operaciones para rdenes */}
              {item.operation === 'UPDATE' && item.formattedChanges && (
                <>
                  <Text
                    variant="bodySmall"
                    style={[
                      styles.summaryText,
                      { color: theme.colors.primary },
                    ]}
                  >
                    Cambios realizados en la orden:
                  </Text>
                  {Object.entries(item.formattedChanges).map(([field, change]) => (
                    <View key={field} style={styles.changeRow}>
                      <Text
                        variant="labelSmall"
                        style={[
                          styles.fieldLabel,
                          { color: theme.colors.onSurfaceVariant },
                        ]}
                      >
                        {formatFieldName(field)}:
                      </Text>
                      <ChangeDetailRenderer
                        change={change}
                        fieldName={field}
                        styles={styles}
                      />
                    </View>
                  ))}
                </>
              )}

              {item.operation === 'DELETE' && (
                <Text
                  variant="bodySmall"
                  style={[
                    styles.summaryText,
                    { color: theme.colors.error },
                  ]}
                >
                  Orden eliminada
                </Text>
              )}
            </View>
          )}

          {/* Contenido para items individuales */}
          {item.type === 'item' && (
            <View style={styles.changesContainer}>
              {item.operation === 'UPDATE' && item.formattedChanges && (
                <>
                  <Text
                    variant="bodySmall"
                    style={[
                      styles.summaryText,
                      { color: theme.colors.primary },
                    ]}
                  >
                    Cambios en el item:
                  </Text>
                  {Object.entries(item.formattedChanges).map(([field, change]) => (
                    <View key={field} style={styles.changeRow}>
                      <Text
                        variant="labelSmall"
                        style={[
                          styles.fieldLabel,
                          { color: theme.colors.onSurfaceVariant },
                        ]}
                      >
                        {formatFieldName(field)}:
                      </Text>
                      <ChangeDetailRenderer
                        change={change}
                        fieldName={field}
                        styles={styles}
                      />
                    </View>
                  ))}
                </>
              )}

              {/* Mostrar la descripcin del item para INSERT y DELETE */}
              {(item.operation === 'INSERT' || item.operation === 'DELETE') &&
                item.itemDescription && (
                  <Text
                    variant="bodySmall"
                    style={[
                      styles.itemDescriptionContainer,
                      {
                        color: theme.colors.onSurface,
                        backgroundColor: theme.colors.surface,
                      },
                    ]}
                  >
                    {item.itemDescription}
                  </Text>
                )}
            </View>
          )}

          {/* Contenido para batch de items */}
          {item.operation === 'BATCH' && item.batchOperations && (
            <BatchOperationsSection
              batchOperations={item.batchOperations}
              styles={styles}
            />
          )}
        </View>
      )}
    </Surface>
  );
};

================
File: app/src/modules/shiftAudit/components/OrderDetailsSection.tsx
================
import React from 'react';
import { View } from 'react-native';
import { Text } from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { DiffOrder } from '../types/orderHistory';
import { getDiffValue, formatValue, safeGetNestedProperty } from '../utils/orderHistoryUtils';

interface OrderDetailsSectionProps {
  orderDiff: DiffOrder;
  snapshot?: Record<string, unknown>;
  styles: any;
}

export const OrderDetailsSection: React.FC<OrderDetailsSectionProps> = ({
  orderDiff,
  snapshot,
  styles,
}) => {
  const theme = useAppTheme();

  return (
    <View
      style={[
        styles.orderDetailsContainer,
        { backgroundColor: theme.colors.surface },
      ]}
    >
      <Text
        variant="labelSmall"
        style={[
          styles.orderDetailsTitle,
          { color: theme.colors.primary },
        ]}
      >
        Detalles de la orden:
      </Text>

      {orderDiff.fields?.orderType && (
        <Text variant="bodySmall" style={styles.fieldRow}>
          <Text style={styles.fieldLabel}>Tipo:</Text>{' '}
          {formatValue('orderType', getDiffValue(orderDiff.fields.orderType))}
        </Text>
      )}

      {orderDiff.fields?.tableId && (
        <Text variant="bodySmall" style={styles.fieldRow}>
          <Text style={styles.fieldLabel}>Mesa:</Text>{' '}
          {safeGetNestedProperty(snapshot, 'table', 'name') ||
            `Mesa ${getDiffValue(orderDiff.fields.tableId)}`}
        </Text>
      )}

      {orderDiff.fields?.notes && (
        <Text variant="bodySmall" style={styles.fieldRow}>
          <Text style={styles.fieldLabel}>Notas:</Text>{' '}
          {getDiffValue(orderDiff.fields.notes)}
        </Text>
      )}

      {/* Informacin de entrega */}
      {orderDiff.deliveryInfo && (
        <>
          {orderDiff.deliveryInfo.recipientName && (
            <Text variant="bodySmall" style={styles.fieldRow}>
              <Text style={styles.fieldLabel}>Cliente:</Text>{' '}
              {getDiffValue(orderDiff.deliveryInfo.recipientName)}
            </Text>
          )}

          {orderDiff.deliveryInfo.recipientPhone && (
            <Text variant="bodySmall" style={styles.fieldRow}>
              <Text style={styles.fieldLabel}>Telfono:</Text>{' '}
              {getDiffValue(orderDiff.deliveryInfo.recipientPhone)}
            </Text>
          )}

          {orderDiff.deliveryInfo.fullAddress && (
            <Text variant="bodySmall" style={styles.fieldRow}>
              <Text style={styles.fieldLabel}>Direccin:</Text>{' '}
              {getDiffValue(orderDiff.deliveryInfo.fullAddress)}
            </Text>
          )}
        </>
      )}
    </View>
  );
};

================
File: app/src/modules/shiftAudit/components/ProductItemRenderer.tsx
================
import React from 'react';
import { View } from 'react-native';
import { Text } from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { 
  safeGetProperty, 
  hasArrayItems, 
  safeJoinArray 
} from '../utils/orderHistoryUtils';

interface ProductItemRendererProps {
  item: Record<string, unknown>;
  index: number;
  type: 'added' | 'removed' | 'modified';
  styles: any;
}

export const ProductItemRenderer: React.FC<ProductItemRendererProps> = ({
  item,
  index,
  type,
  styles,
}) => {
  const theme = useAppTheme();

  const getContainerStyle = () => {
    switch (type) {
      case 'added':
        return {
          borderLeftColor: theme.colors.primary + '50',
          backgroundColor: theme.colors.surface,
        };
      case 'removed':
        return {
          borderLeftColor: theme.colors.error + '50',
          backgroundColor: theme.colors.surface,
        };
      case 'modified':
        return {
          borderLeftColor: theme.colors.warning + '50',
          backgroundColor: theme.colors.surface,
        };
      default:
        return {
          backgroundColor: theme.colors.surface,
        };
    }
  };

  return (
    <View
      key={`${type}-${index}`}
      style={[
        styles.productItemBorder,
        getContainerStyle(),
      ]}
    >
      <Text variant="bodySmall" style={styles.productNameText}>
        {safeGetProperty(item, 'productName')}
        {safeGetProperty(item, 'variantName')
          ? ` - ${safeGetProperty(item, 'variantName')}`
          : ''}
      </Text>

      {hasArrayItems(item, 'modifiers') && (
        <Text
          variant="labelSmall"
          style={[
            styles.modifierText,
            { color: theme.colors.onSurfaceVariant },
          ]}
        >
          Modificadores: {safeJoinArray(item, 'modifiers')}
        </Text>
      )}

      {hasArrayItems(item, 'customizations') && (
        <Text
          variant="labelSmall"
          style={[
            styles.modifierText,
            { color: theme.colors.onSurfaceVariant },
          ]}
        >
          Personalizaciones: {safeJoinArray(item, 'customizations')}
        </Text>
      )}

      {safeGetProperty(item, 'specialInstructions') && (
        <Text
          variant="labelSmall"
          style={[
            styles.modifierText,
            { color: theme.colors.onSurfaceVariant },
          ]}
        >
          Instrucciones: {safeGetProperty(item, 'specialInstructions')}
        </Text>
      )}

      {safeGetProperty(item, 'quantity') && (
        <Text
          variant="labelSmall"
          style={[
            styles.quantityText,
            { color: theme.colors.primary },
          ]}
        >
          Cantidad: {safeGetProperty(item, 'quantity')}
        </Text>
      )}

      {safeGetProperty(item, 'price') && (
        <Text
          variant="labelSmall"
          style={[
            styles.priceText,
            { color: theme.colors.onSurface },
          ]}
        >
          Precio: ${safeGetProperty(item, 'price')}
        </Text>
      )}
    </View>
  );
};

================
File: app/src/modules/shiftAudit/navigation/types.ts
================
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import type { CompositeScreenProps } from '@react-navigation/native';
import type { DrawerScreenProps } from '@react-navigation/drawer';
import type { DrawerNavigatorParamList } from '@/app/navigation/types';

export type ShiftAuditStackParamList = {
  ShiftsList: undefined;
};

export type ShiftAuditStackScreenProps<
  T extends keyof ShiftAuditStackParamList,
> = CompositeScreenProps<
  NativeStackScreenProps<ShiftAuditStackParamList, T>,
  DrawerScreenProps<DrawerNavigatorParamList>
>;

export type ShiftsListScreenNavigationProp =
  ShiftAuditStackScreenProps<'ShiftsList'>['navigation'];
export type ShiftsListScreenRouteProp =
  ShiftAuditStackScreenProps<'ShiftsList'>['route'];

export type ShiftAuditStackNavigationProp = ShiftsListScreenNavigationProp;

================
File: app/src/modules/shiftAudit/styles/orderHistoryStyles.ts
================
import { StyleSheet } from 'react-native';
import { useAppTheme } from '@/app/styles/theme';

export const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    header: {
      backgroundColor: theme.colors.surface,
      elevation: 2,
    },
    content: {
      flex: 1,
      padding: theme.spacing.m,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.l,
    },
    emptyContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.l,
    },
    errorContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.l,
    },
    emptyText: {
      marginTop: theme.spacing.m,
      textAlign: 'center',
      color: theme.colors.onSurface,
    },
    errorText: {
      marginTop: theme.spacing.m,
      textAlign: 'center',
      color: theme.colors.error,
    },
    historyItem: {
      marginBottom: theme.spacing.m,
      borderRadius: theme.roundness,
      backgroundColor: theme.colors.surface,
      overflow: 'hidden',
    },
    historyItemHeader: {
      padding: theme.spacing.m,
    },
    historyItemContent: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
    },
    historyItemLeft: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
    },
    historyItemRight: {
      alignItems: 'flex-end',
    },
    operationIcon: {
      marginRight: theme.spacing.m,
    },
    historyItemInfo: {
      flex: 1,
    },
    operationBadgeRow: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: theme.spacing.xs,
    },
    operationBadge: {
      paddingHorizontal: theme.spacing.s,
      paddingVertical: theme.spacing.xs,
      borderRadius: theme.roundness,
      marginRight: theme.spacing.s,
    },
    operationBadgeText: {
      fontWeight: '500',
    },
    statusChip: {
      height: 24,
    },
    statusChipText: {
      fontSize: 10,
      lineHeight: 12,
    },
    userText: {
      color: theme.colors.onSurfaceVariant,
    },
    timestampText: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 11,
    },
    expandedContent: {
      borderTopWidth: StyleSheet.hairlineWidth,
      borderTopColor: theme.colors.outlineVariant,
      padding: theme.spacing.m,
    },
    dividerMargin: {
      marginVertical: theme.spacing.s,
    },
    changesContainer: {
      marginTop: theme.spacing.s,
    },
    summaryText: {
      marginBottom: theme.spacing.s,
      fontWeight: '500',
    },
    sectionTitle: {
      marginTop: theme.spacing.m,
      marginBottom: theme.spacing.s,
      fontWeight: '500',
    },
    orderDetailsContainer: {
      padding: theme.spacing.m,
      borderRadius: theme.roundness,
      marginBottom: theme.spacing.m,
    },
    orderDetailsTitle: {
      marginBottom: theme.spacing.s,
      fontWeight: '500',
    },
    fieldRow: {
      marginBottom: theme.spacing.xs,
    },
    fieldLabel: {
      fontWeight: '500',
    },
    changeRow: {
      marginBottom: theme.spacing.s,
    },
    changeContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      marginTop: theme.spacing.xs,
    },
    productItemBorder: {
      borderLeftWidth: 3,
      paddingLeft: theme.spacing.m,
      paddingRight: theme.spacing.m,
      paddingVertical: theme.spacing.s,
      marginBottom: theme.spacing.s,
      borderRadius: theme.roundness,
    },
    productNameText: {
      fontWeight: '500',
      marginBottom: theme.spacing.xs,
    },
    modifierText: {
      fontSize: 12,
      marginBottom: theme.spacing.xs,
    },
    quantityText: {
      fontSize: 12,
      fontWeight: '500',
    },
    priceText: {
      fontSize: 12,
      fontWeight: '500',
    },
    itemDescriptionContainer: {
      padding: theme.spacing.s,
      borderRadius: theme.roundness,
      marginTop: theme.spacing.s,
    },
    batchTitle: {
      marginBottom: theme.spacing.s,
      fontWeight: '500',
    },
    batchOperationContainer: {
      borderLeftWidth: 2,
      paddingLeft: theme.spacing.m,
      paddingRight: theme.spacing.m,
      paddingVertical: theme.spacing.s,
    },
    batchOperationMarginBottom: {
      marginBottom: theme.spacing.m,
    },
    batchOperationNoMargin: {
      marginBottom: 0,
    },
    batchOperationRow: {
      flexDirection: 'row',
      alignItems: 'flex-start',
    },
    batchBulletText: {
      fontSize: 16,
      marginRight: theme.spacing.s,
      marginTop: 2,
    },
    batchOperationContent: {
      flex: 1,
    },
    batchOperationLabel: {
      fontWeight: '500',
      marginBottom: theme.spacing.xs,
    },
    batchOperationDescription: {
      padding: theme.spacing.s,
      borderRadius: theme.roundness,
      marginTop: theme.spacing.xs,
    },
    batchUpdateMargin: {
      marginTop: theme.spacing.s,
    },
    batchFieldContainer: {
      marginBottom: theme.spacing.s,
    },
    batchFieldLabel: {
      marginBottom: theme.spacing.xs,
    },
    primaryContainer: {
      paddingHorizontal: theme.spacing.s,
      paddingVertical: theme.spacing.xs,
      borderRadius: theme.roundness,
    },
    labelSmallMedium: {
      fontWeight: '500',
    },
    marginHorizontal4: {
      marginHorizontal: 4,
    },
    marginTop4: {
      marginTop: theme.spacing.xs,
    },
    emptyIcon: {
      marginBottom: theme.spacing.m,
    },
    errorIcon: {
      marginBottom: theme.spacing.m,
    },
    retryButton: {
      marginTop: theme.spacing.m,
    },
    loadingText: {
      marginTop: theme.spacing.m,
    },
    listContent: {
      paddingBottom: theme.spacing.l,
    },
  });

================
File: app/src/modules/shiftAudit/types/index.ts
================
export type {
  Shift,
  ShiftSummary,
  PaymentMethodSummary,
  ProductSummary,
  ShiftOrder,
  OrderItem,
} from '../../../app/schemas/domain/shift.schema';

export type { User } from '../../../app/schemas/domain/user.schema';

================
File: app/src/modules/shiftAudit/types/orderHistory.ts
================
export interface ChangeDetail {
  anterior: unknown;
  nuevo: unknown;
}

export interface BatchOperation {
  operation: string;
  itemDescription?: string;
  snapshot?: { itemDescription?: string };
  formattedChanges?: Record<string, ChangeDetail>;
}

export interface DiffOrderFields {
  orderType?: [unknown, unknown];
  tableId?: [unknown, unknown];
  notes?: [unknown, unknown];
  [key: string]: [unknown, unknown] | undefined;
}

export interface DiffDeliveryInfo {
  recipientName?: [unknown, unknown];
  recipientPhone?: [unknown, unknown];
  fullAddress?: [unknown, unknown];
  [key: string]: [unknown, unknown] | undefined;
}

export interface DiffOrder {
  fields?: DiffOrderFields;
  deliveryInfo?: DiffDeliveryInfo;
}

export interface DiffItems {
  added?: Array<Record<string, unknown>>;
  removed?: Array<Record<string, unknown>>;
  modified?: Array<Record<string, unknown>>;
}

export interface OrderDiff {
  summary?: string;
  order?: DiffOrder;
  items?: DiffItems;
}

export interface HistoryItem {
  id: string | number;
  orderId: string;
  orderItemId?: string;
  operation: 'INSERT' | 'UPDATE' | 'DELETE' | 'BATCH';
  changedBy: string;
  changedAt: string;
  diff?: OrderDiff | null;
  snapshot?: Record<string, unknown>;
  productId?: string;
  preparationStatus?: string;
  changedByUser?: {
    id?: string;
    firstName: string;
    lastName: string;
  };
  user?: {
    firstName: string;
    lastName: string;
  };
  itemDescription?: string;
  formattedChanges?: Record<string, ChangeDetail>;
  batchOperations?: BatchOperation[];
  type: 'order' | 'item';
}

export interface OrderHistoryViewProps {
  orderId: string;
  orderNumber?: number | null;
  onBack: () => void;
}

================
File: app/src/modules/shiftAudit/utils/orderHistoryUtils.ts
================
import { ChangeDetail, BatchOperation } from '../types/orderHistory';

// Type guard para ChangeDetail
export const isChangeDetail = (value: unknown): value is ChangeDetail => {
  return (
    value !== null &&
    typeof value === 'object' &&
    'anterior' in value &&
    'nuevo' in value
  );
};

// Type guard para BatchOperation
export const isBatchOperation = (value: unknown): value is BatchOperation => {
  return (
    value !== null &&
    typeof value === 'object' &&
    'operation' in value &&
    typeof (value as any).operation === 'string'
  );
};

// Utility function para convertir unknown a string para renderizado
export const safeStringify = (value: unknown): string => {
  if (value === null || value === undefined) return '';
  if (typeof value === 'string') return value;
  if (typeof value === 'number' || typeof value === 'boolean') return String(value);
  if (typeof value === 'object') return JSON.stringify(value);
  return String(value);
};

// Utility function para obtener el segundo elemento de un array diff de forma segura
export const getDiffValue = (diffArray: [unknown, unknown] | undefined): string => {
  if (!diffArray || !Array.isArray(diffArray) || diffArray.length < 2) return '';
  return safeStringify(diffArray[1]);
};

// Utility function para obtener propiedades de objetos unknown de forma segura
export const safeGetProperty = (obj: unknown, key: string): string => {
  if (!obj || typeof obj !== 'object') return '';
  const typedObj = obj as Record<string, unknown>;
  return safeStringify(typedObj[key]);
};

// Utility function para verificar si un array existe y tiene elementos
export const hasArrayItems = (obj: unknown, key: string): boolean => {
  if (!obj || typeof obj !== 'object') return false;
  const typedObj = obj as Record<string, unknown>;
  const arr = typedObj[key];
  return Array.isArray(arr) && arr.length > 0;
};

// Utility function para obtener un array como string separado por comas
export const safeJoinArray = (obj: unknown, key: string): string => {
  if (!obj || typeof obj !== 'object') return '';
  const typedObj = obj as Record<string, unknown>;
  const arr = typedObj[key];
  if (!Array.isArray(arr)) return '';
  return arr.map(safeStringify).join(', ');
};

// Utility function para obtener propiedades anidadas de forma segura
export const safeGetNestedProperty = (obj: unknown, ...keys: string[]): string => {
  if (!obj || typeof obj !== 'object') return '';
  
  let current: unknown = obj;
  for (const key of keys) {
    if (!current || typeof current !== 'object') return '';
    const typedCurrent = current as Record<string, unknown>;
    current = typedCurrent[key];
  }
  
  return safeStringify(current);
};

// Helper para obtener el icono de la operacin
export const getOperationIcon = (
  operation: string,
  type: 'order' | 'item' = 'item',
) => {
  if (type === 'order') {
    return 'receipt';
  }

  switch (operation) {
    case 'INSERT':
      return 'plus';
    case 'UPDATE':
      return 'pencil';
    case 'DELETE':
      return 'delete';
    case 'BATCH':
      return 'folder-multiple';
    default:
      return 'information';
  }
};

// Helper para obtener el label de la operacin
export const getOperationLabel = (
  operation: string,
  type: 'order' | 'item' = 'item',
) => {
  if (type === 'order') {
    const orderOperationMap: Record<string, string> = {
      INSERT: 'Orden creada',
      UPDATE: 'Orden modificada',
      DELETE: 'Orden eliminada',
    };
    return orderOperationMap[operation] || operation;
  }

  const itemOperationMap: Record<string, string> = {
    INSERT: 'Item agregado',
    UPDATE: 'Item modificado',
    DELETE: 'Item eliminado',
    BATCH: 'Edicin mltiple',
  };
  return itemOperationMap[operation] || operation;
};

// Helper para obtener el color del status de preparacin
export const getPreparationStatusColor = (
  status: string,
  theme: any,
): string => {
  const statusColors: Record<string, string> = {
    PENDING: theme.colors.onSurfaceDisabled,
    IN_PROGRESS: theme.colors.warning || '#FFA500',
    READY: theme.colors.success || '#4CAF50',
    CANCELLED: theme.colors.error,
  };
  return statusColors[status] || theme.colors.onSurfaceDisabled;
};

// Helper para formatear nombres de campos
export const formatFieldName = (field: string): string => {
  const fieldMap: Record<string, string> = {
    orderStatus: 'Estado de la orden',
    orderType: 'Tipo de orden',
    tableId: 'Mesa',
    table: 'Mesa',
    notes: 'Notas',
    deliveryInfo: 'Informacin de entrega',
    customerName: 'Nombre del cliente',
    customerPhone: 'Telfono del cliente',
    recipientName: 'Nombre del destinatario',
    recipientPhone: 'Telfono del destinatario',
    deliveryAddress: 'Direccin de entrega',
    fullAddress: 'Direccin',
    estimatedDeliveryTime: 'Tiempo estimado de entrega',
    preparationStatus: 'Estado de preparacin',
    preparationNotes: 'Notas de preparacin',
    customerId: 'Cliente',
    scheduledAt: 'Fecha programada',
    total: 'Total',
    subtotal: 'Subtotal',
    itemName: 'Nombre del item',
    quantity: 'Cantidad',
    unitPrice: 'Precio unitario',
    totalPrice: 'Precio total',
    modifiers: 'Modificadores',
    customizations: 'Personalizaciones',
    productVariant: 'Variante del producto',
    specialInstructions: 'Instrucciones especiales',
  };
  return fieldMap[field] || field;
};

// Helper para formatear valores
export const formatValue = (
  field: string,
  value: unknown,
  snapshot?: Record<string, unknown>,
): string => {
  if (value === null || value === undefined) return '-';

  switch (field) {
    case 'orderType':
      const typeMap: Record<string, string> = {
        DINE_IN: 'Comer en el local',
        TAKEAWAY: 'Para llevar',
        DELIVERY: 'Delivery',
      };
      return typeMap[String(value)] || String(value);

    case 'orderStatus':
      const statusMap: Record<string, string> = {
        PENDING: 'Pendiente',
        CONFIRMED: 'Confirmada',
        IN_PREPARATION: 'En preparacin',
        READY: 'Lista',
        DELIVERED: 'Entregada',
        CANCELLED: 'Cancelada',
      };
      return statusMap[String(value)] || String(value);

    case 'preparationStatus':
      const prepStatusMap: Record<string, string> = {
        PENDING: 'Pendiente',
        IN_PROGRESS: 'En preparacin',
        READY: 'Listo',
        CANCELLED: 'Cancelado',
      };
      return prepStatusMap[String(value)] || String(value);

    case 'tableId':
    case 'table':
      if (snapshot && typeof snapshot === 'object') {
        const typedSnapshot = snapshot as Record<string, unknown>;
        if (typedSnapshot.table && typeof typedSnapshot.table === 'object') {
          const table = typedSnapshot.table as Record<string, unknown>;
          if (table.name && typeof table.name === 'string') {
            return table.name;
          }
        }
      }
      return `Mesa ${value}`;

    case 'total':
    case 'subtotal':
    case 'unitPrice':
    case 'totalPrice':
      const num = Number(value);
      return isNaN(num) ? String(value) : `$${num.toFixed(2)}`;

    case 'scheduledAt':
      try {
        const date = new Date(String(value));
        return date.toLocaleString('es-ES');
      } catch {
        return String(value);
      }

    default:
      return String(value);
  }
};

================
File: app/src/modules/sync/navigation/SyncStackNavigator.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { SyncStatusScreen } from '../screens/SyncStatusScreen';

export type SyncStackParamList = {
  SyncStatus: undefined;
};

const Stack = createNativeStackNavigator<SyncStackParamList>();

export const SyncStackNavigator: React.FC = () => {
  return (
    <Stack.Navigator
      screenOptions={{
        headerShown: false,
      }}
    >
      <Stack.Screen
        name="SyncStatus"
        component={SyncStatusScreen}
        options={{ title: 'Estado de Sincronizacin' }}
      />
    </Stack.Navigator>
  );
};

================
File: app/tsconfig.json
================
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "moduleResolution": "bundler",
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    },
    "jsx": "react-jsx",
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true
  }
}

================
File: app/.eslintrc.js
================
module.exports = {
  root: true,
  parser: '@typescript-eslint/parser',
  parserOptions: {
    ecmaVersion: 2021,
    sourceType: 'module',
    ecmaFeatures: {
      jsx: true,
    },
    project: './tsconfig.json',
  },
  plugins: [
    '@typescript-eslint',
    'react',
    'react-hooks',
    'react-native',
    'prettier',
  ],
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:react/recommended',
    'plugin:react-hooks/recommended',
    'plugin:react-native/all',
    'prettier',
  ],
  env: {
    'react-native/react-native': true,
    node: true,
    es2021: true,
  },
  settings: {
    react: {
      version: 'detect',
    },
  },
  rules: {
    // TypeScript
    '@typescript-eslint/no-unused-vars': [
      'error',
      {
        argsIgnorePattern: '^_',
        varsIgnorePattern: '^_',
        ignoreRestSiblings: true,
      },
    ],
    '@typescript-eslint/no-explicit-any': 'off', // Too many to fix now
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-namespace': 'off',

    // React
    'react/react-in-jsx-scope': 'off', // Not needed with React 17+
    'react/prop-types': 'off', // Using TypeScript
    'react/display-name': 'off',

    // React Native
    'react-native/no-inline-styles': 'warn', // TODO: Refactor to StyleSheet
    'react-native/no-color-literals': 'off',
    'react-native/no-raw-text': 'off',
    'react-native/sort-styles': 'off',
    'react-native/no-unused-styles': 'off', // Disabled - too many false positives

    // React Hooks
    'react-hooks/exhaustive-deps': 'warn',
    'react-hooks/rules-of-hooks': 'error',

    // General
    'no-console': ['warn', { allow: ['warn', 'error', 'info'] }],
    'prettier/prettier': 'error',
    'no-empty': ['error', { allowEmptyCatch: true }],
    'no-prototype-builtins': 'off',
  },
  ignorePatterns: [
    'node_modules/',
    'android/',
    'ios/',
    '.expo/',
    'babel.config.js',
    'metro.config.js',
    '*.config.js',
    '.eslintrc.js',
  ],
};

================
File: app/android/app/src/main/res/xml/network_security_config.xml
================
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <!-- Configuracin base para produccin - Solo HTTPS por defecto -->
    <base-config cleartextTrafficPermitted="false">
        <trust-anchors>
            <certificates src="system" />
        </trust-anchors>
    </base-config>
    
    <!-- Permitir trfico cleartext SOLO para redes locales (auto-descubrimiento) -->
    <!-- Esto es necesario para el sistema de discovery del servidor -->
    <domain-config cleartextTrafficPermitted="true">
        <!-- Redes privadas IPv4 (RFC 1918) -->
        <domain>10.0.0.0/8</domain>
        <domain>172.16.0.0/12</domain>
        <domain>192.168.0.0/16</domain>
        
        <!-- Localhost y loopback -->
        <domain>localhost</domain>
        <domain>127.0.0.1</domain>
        <domain>10.0.2.2</domain> <!-- Emulador Android -->
        
        <!-- Patrn para IPs locales comunes -->
        <domain includeSubdomains="false">192.168.1.*</domain>
        <domain includeSubdomains="false">192.168.0.*</domain>
        <domain includeSubdomains="false">10.0.0.*</domain>
        <domain includeSubdomains="false">172.16.*.*</domain>
    </domain-config>
    
    <!-- Configuracin especfica para tu dominio de produccin -->
    <!-- TODO: Reemplaza "tu-dominio.com" con tu dominio real de produccin -->
    <domain-config>
        <domain includeSubdomains="true">tu-dominio.com</domain>
        <trust-anchors>
            <certificates src="system" />
        </trust-anchors>
        
        <!-- Certificate Pinning (opcional pero recomendado para produccin) -->
        <!-- TODO: Descomentar y actualizar con los hashes SHA-256 de tu certificado
        <pin-set expiration="2026-01-01">
            <pin digest="SHA-256">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=</pin>
            <pin digest="SHA-256">BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB=</pin>
        </pin-set>
        -->
    </domain-config>
    
    <!-- Solo para desarrollo - Se ignora en builds de produccin -->
    <debug-overrides>
        <trust-anchors>
            <!-- Permite certificados del sistema -->
            <certificates src="system" />
            <!-- Permite certificados instalados por el usuario (ej: Charles Proxy) -->
            <certificates src="user" />
        </trust-anchors>
    </debug-overrides>
</network-security-config>

================
File: app/scripts/check-new-arch-compatibility.js
================
const fs = require('fs');
const path = require('path');

const checkCompatibility = (packageName) => {
  const packagePath = path.join(__dirname, '../node_modules', packageName);

  if (!fs.existsSync(packagePath)) {
    return { status: 'not-found', packageName };
  }

  // Buscar indicadores de Nueva Arquitectura
  const indicators = {
    turboModules: false,
    fabric: false,
    codegen: false,
    reactNativeConfig: false,
  };

  // Verificar package.json
  const packageJsonPath = path.join(packagePath, 'package.json');
  if (fs.existsSync(packageJsonPath)) {
    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));

    // Buscar configuracin de codegen
    if (packageJson.codegenConfig) {
      indicators.codegen = true;
    }
  }

  // Verificar react-native.config.js
  const rnConfigPath = path.join(packagePath, 'react-native.config.js');
  if (fs.existsSync(rnConfigPath)) {
    indicators.reactNativeConfig = true;
  }

  // Buscar archivos indicadores (limitado para evitar bsquedas muy largas)
  const searchFiles = (dir, depth = 0) => {
    if (!fs.existsSync(dir) || depth > 3) return;

    try {
      const files = fs.readdirSync(dir);
      for (const file of files) {
        const filePath = path.join(dir, file);
        const stat = fs.statSync(filePath);

        if (
          stat.isDirectory() &&
          !file.includes('node_modules') &&
          !file.startsWith('.')
        ) {
          searchFiles(filePath, depth + 1);
        } else if (
          (file.endsWith('.js') ||
            file.endsWith('.ts') ||
            file.endsWith('.tsx')) &&
          stat.size < 100000
        ) {
          try {
            const content = fs.readFileSync(filePath, 'utf8');
            if (content.includes('TurboModule')) indicators.turboModules = true;
            if (content.includes('codegenNativeComponent'))
              indicators.fabric = true;
          } catch (e) {
            // Ignorar errores de lectura
          }
        }
      }
    } catch (e) {
      // Ignorar errores de directorio
    }
  };

  searchFiles(packagePath);

  const isCompatible =
    indicators.turboModules || indicators.fabric || indicators.codegen;

  return {
    packageName,
    status: isCompatible ? 'compatible' : 'unknown',
    indicators,
  };
};

// Leer todas las dependencias del package.json
const packageJson = JSON.parse(
  fs.readFileSync(path.join(__dirname, '../package.json'), 'utf8'),
);
const allDependencies = {
  ...packageJson.dependencies,
  ...packageJson.devDependencies,
};

// Filtrar solo las que empiezan con react-native o expo
const nativeDependencies = Object.keys(allDependencies).filter(
  (dep) =>
    dep.startsWith('react-native') ||
    dep.startsWith('expo') ||
    dep.startsWith('@react-native') ||
    dep.includes('react-native') ||
    dep === '@shopify/flash-list',
);

console.log(' Verificando compatibilidad con Nueva Arquitectura...\n');
console.log(
  ` Total de dependencias nativas encontradas: ${nativeDependencies.length}\n`,
);

const results = {
  compatible: [],
  unknown: [],
  notFound: [],
};

nativeDependencies.forEach((dep) => {
  const result = checkCompatibility(dep);
  const emoji = result.status === 'compatible' ? '' : '';

  if (result.status === 'compatible') {
    results.compatible.push(dep);
    console.log(`${emoji} ${result.packageName}: Compatible`);
    const indicators = Object.entries(result.indicators)
      .filter(([_, value]) => value)
      .map(([key]) => key);
    if (indicators.length > 0) {
      console.log(`   Indicadores encontrados: ${indicators.join(', ')}`);
    }
  } else if (result.status === 'unknown') {
    results.unknown.push(dep);
    console.log(`${emoji} ${result.packageName}: Compatibilidad desconocida`);
  } else {
    results.notFound.push(dep);
    console.log(` ${result.packageName}: No encontrado`);
  }
});

console.log('\n Resumen:');
console.log(` Compatibles: ${results.compatible.length}`);
console.log(`  Desconocidas: ${results.unknown.length}`);
console.log(` No encontradas: ${results.notFound.length}`);

console.log('\n Recomendaciones:');
if (results.unknown.length > 0) {
  console.log(
    '- Las bibliotecas con compatibilidad desconocida pueden funcionar con el Interop Layer',
  );
  console.log('- Verifica la documentacin oficial de cada biblioteca');
  console.log(
    '- Considera buscar alternativas para bibliotecas crticas sin soporte',
  );
}

console.log(
  '\n Para ms informacin, consulta NEW_ARCHITECTURE_COMPATIBILITY.md',
);

================
File: app/src/app/components/common/AnimatedLabelSelector.tsx
================
import React, { useRef, useEffect } from 'react';
import {
  View,
  TouchableOpacity,
  Animated,
  StyleSheet,
  Text,
  StyleProp,
  ViewStyle,
  TextStyle,
  ActivityIndicator,
} from 'react-native';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { Icon, IconButton } from 'react-native-paper';

interface AnimatedLabelSelectorProps {
  label: string;
  value: string | null | undefined;
  onPress: () => void;
  onClear?: () => void;
  containerStyle?: StyleProp<ViewStyle>;
  valueStyle?: StyleProp<TextStyle>;
  labelStyle?: StyleProp<TextStyle>;
  activeLabelColor?: string;
  inactiveLabelColor?: string;
  borderColor?: string;
  activeBorderColor?: string;
  disabled?: boolean;
  isLoading?: boolean;
  error?: boolean;
  errorColor?: string;
}

const AnimatedLabelSelector: React.FC<AnimatedLabelSelectorProps> = ({
  label,
  value,
  onPress,
  onClear,
  containerStyle,
  valueStyle,
  labelStyle,
  activeLabelColor,
  inactiveLabelColor,
  borderColor: defaultBorderColor,
  activeBorderColor: focusedBorderColor,
  disabled = false,
  isLoading = false,
  error = false,
  errorColor: customErrorColor,
  ...rest
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();

  const isActive = value != null && value !== '';
  const animation = useRef(new Animated.Value(isActive ? 1 : 0)).current;

  const finalActiveLabelColor = activeLabelColor || theme.colors.primary;
  const finalInactiveLabelColor =
    inactiveLabelColor || theme.colors.onSurfaceVariant;
  const finalBorderColor = defaultBorderColor || theme.colors.outline;
  const finalActiveBorderColor = focusedBorderColor || theme.colors.primary;
  const finalErrorColor = customErrorColor || theme.colors.error;

  const currentBorderColor = disabled
    ? theme.colors.surfaceVariant
    : error
      ? finalErrorColor
      : isActive
        ? finalActiveBorderColor
        : finalBorderColor;

  useEffect(() => {
    Animated.timing(animation, {
      toValue: isActive ? 1 : 0,
      duration: 200,
      useNativeDriver: false,
    }).start();
  }, [isActive, animation]);

  const labelTranslateY = animation.interpolate({
    inputRange: [0, 1],
    outputRange: [0, -26],
  });

  const labelScale = animation.interpolate({
    inputRange: [0, 1],
    outputRange: [1, 0.8],
  });

  const labelColor = animation.interpolate({
    inputRange: [0, 1],
    outputRange: [finalInactiveLabelColor, finalActiveLabelColor],
  });

  const styles = React.useMemo(
    () =>
      createStyles(theme, responsive, {
        disabled,
        finalInactiveLabelColor,
      }),
    [theme, responsive, disabled, finalInactiveLabelColor],
  );

  const animatedLabelStyle = {
    transform: [{ translateY: labelTranslateY }, { scale: labelScale }],
    color: labelColor,
    backgroundColor: animation.interpolate({
      inputRange: [0, 1],
      outputRange: ['transparent', theme.colors.background],
    }),
  };

  // Estilos estticos que no deben ser animados
  const staticLabelStyle = {
    paddingHorizontal: isActive ? 4 : 0,
    zIndex: isActive ? 2 : 0,
  };

  return (
    <View style={styles.outerContainer}>
      <TouchableOpacity
        onPress={onPress}
        disabled={disabled || isLoading}
        style={[
          styles.container,
          { borderColor: currentBorderColor },
          containerStyle,
        ]}
        activeOpacity={0.7}
        {...rest}
      >
        <Animated.Text
          style={[
            styles.label,
            staticLabelStyle,
            labelStyle,
            animatedLabelStyle,
          ]}
          numberOfLines={1}
        >
          {label}
        </Animated.Text>
        <View style={styles.valueContainer}>
          <Text style={[styles.valueText, valueStyle]} numberOfLines={1}>
            {!isLoading ? value || ' ' : ' '}
          </Text>
          <View style={styles.iconsContainer}>
            {isLoading ? (
              <ActivityIndicator
                size="small"
                color={theme.colors.primary}
                style={styles.loader}
              />
            ) : (
              <Icon
                source="chevron-down"
                size={20}
                color={
                  disabled
                    ? theme.colors.onSurfaceDisabled
                    : theme.colors.onSurfaceVariant
                }
              />
            )}
          </View>
        </View>

        {disabled && <View style={styles.disabledOverlay} />}
      </TouchableOpacity>

      {isActive && !disabled && !isLoading && onClear && (
        <View style={styles.clearButtonContainer}>
          <IconButton
            icon="close-circle"
            size={24}
            onPress={onClear}
            iconColor={theme.colors.onSurfaceVariant}
            style={styles.clearButton}
            rippleColor="rgba(0, 0, 0, .1)"
          />
        </View>
      )}
    </View>
  );
};

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
  props: {
    disabled: boolean;
    finalInactiveLabelColor: string;
  },
) =>
  StyleSheet.create({
    container: {
      borderWidth: 1,
      borderRadius: theme.roundness,
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.isTablet ? 16 : 18,
      paddingBottom: responsive.isTablet ? 4 : 6,
      position: 'relative',
      backgroundColor: theme.colors.background,
      minHeight: responsive.isTablet ? 52 : 58,
      justifyContent: 'center',
      flex: 1,
    },
    outerContainer: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    label: {
      position: 'absolute',
      left: responsive.spacing(theme.spacing.m),
      top: responsive.isTablet ? 16 : 18,
      fontSize: responsive.fontSize(16),
      color: props.finalInactiveLabelColor,
      zIndex: 1,
    },
    valueContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      minHeight: responsive.isTablet ? 20 : 24,
    },
    valueText: {
      fontSize: responsive.fontSize(16),
      color: props.disabled
        ? theme.colors.onSurfaceDisabled
        : theme.colors.onSurface,
      flex: 1,
      marginRight: responsive.spacing(theme.spacing.xs),
    },
    loader: {},
    iconsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    clearButtonContainer: {
      marginLeft: responsive.spacing(theme.spacing.s),
      height: responsive.isTablet ? 52 : 58,
      justifyContent: 'center',
    },
    clearButton: {
      margin: 0,
    },
    icon: {},
    disabledOverlay: {
      ...StyleSheet.absoluteFillObject,
      backgroundColor: theme.dark
        ? 'rgba(0, 0, 0, 0.2)'
        : 'rgba(0, 0, 0, 0.05)',
      zIndex: 3,
      borderRadius: theme.roundness,
    },
  });

export default AnimatedLabelSelector;

================
File: app/src/app/components/common/CustomImagePicker.tsx
================
import React, { useState, useEffect } from 'react';
import {
  View,
  StyleSheet,
  Alert,
  TouchableOpacity,
  StyleProp,
  ViewStyle,
} from 'react-native';
import {
  ActivityIndicator,
  Avatar,
  IconButton,
  Surface,
  Text,
  useTheme,
} from 'react-native-paper';
import * as ImagePicker from 'expo-image-picker';
import { Image } from 'expo-image';
import { AppTheme } from '../../styles/theme';
import { useResponsive } from '../../hooks/useResponsive';

export interface FileObject {
  uri: string;
  name: string;
  type: string;
}

interface CustomImagePickerProps {
  value?: string | null;
  onImageSelected?: (imageUri: string, file: FileObject) => void;
  onImageRemoved?: () => void;
  style?: StyleProp<ViewStyle>;
  size?: number;
  placeholderIcon?: string;
  placeholderText?: string;
  isLoading?: boolean;
  disabled?: boolean;
}

export const CustomImagePicker: React.FC<CustomImagePickerProps> = ({
  value,
  onImageSelected,
  onImageRemoved,
  style,
  size = 150,
  placeholderIcon = 'camera-plus-outline',
  placeholderText = 'Aadir imagen',
  isLoading = false,
  disabled = false,
}) => {
  const theme = useTheme<AppTheme>();
  const responsive = useResponsive();
  const [imageUri, setImageUri] = useState<string | null | undefined>(value);
  const [hasPermission, setHasPermission] = useState<boolean | null>(null);
  const [imageLoadError, setImageLoadError] = useState(false);

  useEffect(() => {
    let isMounted = true;

    (async () => {
      try {
        const { status } = await ImagePicker.getMediaLibraryPermissionsAsync();
        if (isMounted) {
          setHasPermission(status === 'granted');
        }
      } catch {
        if (isMounted) {
          setHasPermission(false);
        }
      }
    })();

    return () => {
      isMounted = false;
    };
  }, []);

  useEffect(() => {
    setImageUri(value);
    setImageLoadError(false);
  }, [value]);

  const requestPermission = async (): Promise<boolean> => {
    if (hasPermission) return true;
    try {
      const { status } =
        await ImagePicker.requestMediaLibraryPermissionsAsync();
      if (status === 'granted') {
        setHasPermission(true);
        return true;
      } else {
        Alert.alert(
          'Permiso requerido',
          'Se necesita acceso a la galera para seleccionar imgenes.',
        );
        setHasPermission(false);
        return false;
      }
    } catch (e) {
      Alert.alert(
        'Error',
        'No se pudieron solicitar los permisos de la galera.',
      );
      setHasPermission(false);
      return false;
    }
  };

  const handlePickImage = async () => {
    if (isLoading || disabled) return;

    const permissionGranted = await requestPermission();
    if (!permissionGranted) return;

    try {
      const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: 'images',
        allowsEditing: true,
        aspect: [1, 1],
        quality: 0.8,
      });

      if (!result.canceled && result.assets && result.assets.length > 0) {
        const selectedAsset = result.assets[0];
        const selectedUri = selectedAsset.uri;
        const fileName = selectedUri.split('/').pop() || 'image.jpg';
        const fileType =
          selectedAsset.mimeType ||
          (fileName.toLowerCase().endsWith('.png')
            ? 'image/png'
            : 'image/jpeg');

        const fileObject: FileObject = {
          uri: selectedUri,
          name: fileName,
          type: fileType,
        };
        setImageUri(selectedUri);
        onImageSelected?.(selectedUri, fileObject);
      }
    } catch (error) {
      Alert.alert(
        'Error',
        `No se pudo abrir la galera: ${error instanceof Error ? error.message : 'Intntalo de nuevo.'}`,
      );
    }
  };

  const handleRemoveImage = () => {
    if (isLoading || disabled) return;
    setImageUri(null);
    onImageRemoved?.();
  };

  // Calcular tamao responsive
  const responsiveSize = responsive.getResponsiveDimension(size, size * 1.2);

  const styles = StyleSheet.create({
    container: {
      width: responsiveSize,
      height: responsiveSize,
      borderRadius: theme.roundness * 1.5,
      justifyContent: 'center',
      alignItems: 'center',
      overflow: 'hidden',
      position: 'relative',
      backgroundColor: theme.colors.surfaceVariant,
    },
    touchable: {
      width: '100%',
      height: '100%',
      justifyContent: 'center',
      alignItems: 'center',
    },
    image: {
      width: '100%',
      height: '100%',
    },
    placeholderContainer: {
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.spacingPreset.s,
    },
    placeholderText: {
      marginTop: responsive.spacingPreset.xs,
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
      fontSize: responsive.fontSizePreset.s,
    },
    loadingOverlay: {
      ...StyleSheet.absoluteFillObject,
      backgroundColor: 'rgba(0,0,0,0.4)',
      justifyContent: 'center',
      alignItems: 'center',
      borderRadius: theme.roundness * 1.5,
    },
    removeButton: {
      position: 'absolute',
      top: responsive.spacingPreset.xs,
      right: responsive.spacingPreset.xs,
      backgroundColor: 'rgba(0, 0, 0, 0.6)',
    },
    transparentBackground: {
      backgroundColor: 'transparent',
    },
  });

  return (
    <Surface style={[styles.container, style]} elevation={1}>
      <TouchableOpacity
        style={styles.touchable}
        onPress={handlePickImage}
        disabled={isLoading || disabled}
      >
        {imageUri && !imageLoadError ? (
          <Image
            source={{ uri: imageUri }}
            style={styles.image}
            contentFit="cover"
            onError={() => setImageLoadError(true)}
          />
        ) : (
          <View style={styles.placeholderContainer}>
            <Avatar.Icon
              size={responsiveSize * 0.4}
              icon={placeholderIcon}
              style={styles.transparentBackground}
              color={theme.colors.onSurfaceVariant}
            />
            <Text style={styles.placeholderText} variant="bodySmall">
              {placeholderText}
            </Text>
          </View>
        )}

        {isLoading && (
          <View style={styles.loadingOverlay}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
          </View>
        )}

        {imageUri && !imageLoadError && !isLoading && !disabled && (
          <IconButton
            icon="close-circle"
            size={responsive.dimensions.iconSize.medium}
            iconColor={theme.colors.onErrorContainer}
            style={styles.removeButton}
            onPress={handleRemoveImage}
            rippleColor="rgba(255, 255, 255, 0.32)"
          />
        )}
      </TouchableOpacity>
    </Surface>
  );
};

export default CustomImagePicker;

================
File: app/src/app/components/common/PhoneNumberInput.tsx
================
import React, { useState, useEffect } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import { TextInput, Menu, Button, HelperText } from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';

interface Country {
  code: string;
  name: string;
  prefix: string;
  flag: string;
}

// Lista de pases ms comunes en Amrica
// IMPORTANTE: Ordenados con prefijos ms largos primero para evitar conflictos
const COUNTRIES: Country[] = [
  // Pases con prefijos de 4 dgitos
  { code: 'DO', name: 'Rep. Dominicana', prefix: '+1809', flag: '' },
  { code: 'PR', name: 'Puerto Rico', prefix: '+1787', flag: '' },

  // Pases con prefijos de 3 dgitos
  { code: 'EC', name: 'Ecuador', prefix: '+593', flag: '' },
  { code: 'BO', name: 'Bolivia', prefix: '+591', flag: '' },
  { code: 'PY', name: 'Paraguay', prefix: '+595', flag: '' },
  { code: 'UY', name: 'Uruguay', prefix: '+598', flag: '' },
  { code: 'GT', name: 'Guatemala', prefix: '+502', flag: '' },
  { code: 'SV', name: 'El Salvador', prefix: '+503', flag: '' },
  { code: 'HN', name: 'Honduras', prefix: '+504', flag: '' },
  { code: 'NI', name: 'Nicaragua', prefix: '+505', flag: '' },
  { code: 'CR', name: 'Costa Rica', prefix: '+506', flag: '' },
  { code: 'PA', name: 'Panam', prefix: '+507', flag: '' },

  // Pases con prefijos de 2 dgitos
  { code: 'MX', name: 'Mxico', prefix: '+52', flag: '' },
  { code: 'AR', name: 'Argentina', prefix: '+54', flag: '' },
  { code: 'BR', name: 'Brasil', prefix: '+55', flag: '' },
  { code: 'CL', name: 'Chile', prefix: '+56', flag: '' },
  { code: 'CO', name: 'Colombia', prefix: '+57', flag: '' },
  { code: 'PE', name: 'Per', prefix: '+51', flag: '' },
  { code: 'VE', name: 'Venezuela', prefix: '+58', flag: '' },
  { code: 'CU', name: 'Cuba', prefix: '+53', flag: '' },
  { code: 'ES', name: 'Espaa', prefix: '+34', flag: '' },

  // Pases con prefijo de 1 dgito (al final)
  { code: 'US', name: 'Estados Unidos', prefix: '+1', flag: '' },
  { code: 'CA', name: 'Canad', prefix: '+1', flag: '' },
];

interface PhoneNumberInputProps {
  value: string;
  onChange: (fullNumber: string) => void;
  error?: boolean;
  helperText?: string;
  placeholder?: string;
}

export default function PhoneNumberInput({
  value,
  onChange,
  error,
  helperText,
  placeholder = 'Telfono',
}: PhoneNumberInputProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => getStyles(theme, responsive),
    [theme, responsive],
  );

  const [selectedCountry, setSelectedCountry] = useState<Country>(COUNTRIES[0]);
  const [phoneNumber, setPhoneNumber] = useState('');
  const [menuVisible, setMenuVisible] = useState(false);

  // Detectar pas y nmero al recibir un valor completo
  useEffect(() => {
    if (value && value.startsWith('+')) {
      // Ordenar pases por longitud de prefijo (ms largos primero) para evitar coincidencias errneas
      const sortedCountries = [...COUNTRIES].sort(
        (a, b) => b.prefix.length - a.prefix.length,
      );

      // Encontrar el pas por el prefijo
      const country = sortedCountries.find((c) => value.startsWith(c.prefix));
      if (country) {
        setSelectedCountry(country);
        setPhoneNumber(value.substring(country.prefix.length));
      } else {
        // Si no encontramos el pas, usar el default y mostrar todo el nmero
        setPhoneNumber(value);
      }
    } else {
      setPhoneNumber(value || '');
    }
  }, [value]);

  const handlePhoneChange = (text: string) => {
    // Solo permitir nmeros y limitar a 15 dgitos (estndar internacional)
    const cleaned = text.replace(/[^\d]/g, '').slice(0, 15);
    setPhoneNumber(cleaned);

    // Actualizar el valor completo
    if (cleaned) {
      onChange(`${selectedCountry.prefix}${cleaned}`);
    } else {
      onChange('');
    }
  };

  const handleCountrySelect = (country: Country) => {
    setSelectedCountry(country);
    setMenuVisible(false);

    // Actualizar el valor completo con el nuevo pas
    if (phoneNumber) {
      onChange(`${country.prefix}${phoneNumber}`);
    }
  };

  return (
    <View>
      <View style={styles.container}>
        <Menu
          visible={menuVisible}
          onDismiss={() => setMenuVisible(false)}
          anchor={
            <Button
              mode="outlined"
              onPress={() => setMenuVisible(true)}
              style={styles.countryButton}
              labelStyle={styles.countryButtonLabel}
            >
              {selectedCountry.flag} {selectedCountry.prefix}
            </Button>
          }
          contentStyle={styles.menuContent}
        >
          <ScrollView
            style={styles.menuScrollView}
            showsVerticalScrollIndicator={true}
            nestedScrollEnabled={true}
          >
            {COUNTRIES.map((country) => (
              <Menu.Item
                key={country.code}
                onPress={() => handleCountrySelect(country)}
                title={`${country.flag} ${country.name} (${country.prefix})`}
                titleStyle={styles.menuItem}
              />
            ))}
          </ScrollView>
        </Menu>

        <TextInput
          value={phoneNumber}
          onChangeText={handlePhoneChange}
          placeholder={placeholder}
          keyboardType="phone-pad"
          mode="outlined"
          error={error}
          style={styles.input}
          outlineStyle={styles.inputOutline}
          maxLength={15}
        />
      </View>

      {helperText && (
        <HelperText type="error" visible={error}>
          {helperText}
        </HelperText>
      )}
    </View>
  );
}

const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.spacing(theme.spacing.s),
    },
    countryButton: {
      minWidth: responsive.isTablet ? 85 : 90,
      height: responsive.isTablet ? 48 : 56,
      justifyContent: 'center',
    },
    countryButtonLabel: {
      fontSize: responsive.fontSize(16),
    },
    menuContent: {
      maxHeight: responsive.isTablet ? 400 : 350,
      backgroundColor: theme.colors.surface,
    },
    menuScrollView: {
      maxHeight: responsive.isTablet ? 390 : 340,
    },
    menuItem: {
      fontSize: responsive.fontSize(14),
    },
    input: {
      flex: 1,
      height: responsive.isTablet ? 48 : 56,
    },
    inputOutline: {
      borderRadius: theme.roundness * 2,
    },
  });

================
File: app/src/app/components/common/SpeechRecognitionInput.tsx
================
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { View, StyleSheet, Animated } from 'react-native';
import { IconButton } from 'react-native-paper';
import {
  ExpoSpeechRecognitionModule,
  useSpeechRecognitionEvent,
} from 'expo-speech-recognition';
import AnimatedLabelInput from './AnimatedLabelInput';
import { useAppTheme } from '../../styles/theme';

// Clase para manejar instancias de reconocimiento de forma aislada
class RecognitionInstance {
  private static instances = new Map<string, RecognitionInstance>();
  private static activeInstanceId: string | null = null;

  public readonly id: string;
  private isActive: boolean = false;
  private onResultCallback: ((text: string) => void) | null = null;
  private onErrorCallback: ((error: string) => void) | null = null;
  private onStartCallback: (() => void) | null = null;
  private onEndCallback: (() => void) | null = null;

  constructor(id: string) {
    this.id = id;
    RecognitionInstance.instances.set(id, this);
  }

  static getInstance(id: string): RecognitionInstance {
    if (!RecognitionInstance.instances.has(id)) {
      new RecognitionInstance(id);
    }
    return RecognitionInstance.instances.get(id)!;
  }

  static removeInstance(id: string) {
    const instance = RecognitionInstance.instances.get(id);
    if (instance && instance.isActive) {
      instance.stop();
    }
    RecognitionInstance.instances.delete(id);
  }

  static getActiveInstance(): RecognitionInstance | null {
    if (RecognitionInstance.activeInstanceId) {
      return (
        RecognitionInstance.instances.get(
          RecognitionInstance.activeInstanceId,
        ) || null
      );
    }
    return null;
  }

  setCallbacks(callbacks: {
    onResult?: (text: string) => void;
    onError?: (error: string) => void;
    onStart?: () => void;
    onEnd?: () => void;
  }) {
    this.onResultCallback = callbacks.onResult || null;
    this.onErrorCallback = callbacks.onError || null;
    this.onStartCallback = callbacks.onStart || null;
    this.onEndCallback = callbacks.onEnd || null;
  }

  async start(lang: string) {
    // Si hay otra instancia activa, detenerla primero
    const activeInstance = RecognitionInstance.getActiveInstance();
    if (activeInstance && activeInstance.id !== this.id) {
      await activeInstance.stop();
    }

    try {
      const permissions =
        await ExpoSpeechRecognitionModule.requestPermissionsAsync();
      if (!permissions.granted) {
        this.onErrorCallback?.('Permiso de micrfono denegado');
        return;
      }

      RecognitionInstance.activeInstanceId = this.id;
      this.isActive = true;

      await ExpoSpeechRecognitionModule.start({
        lang,
        interimResults: false,
        continuous: false,
      });

      this.onStartCallback?.();
    } catch (error: any) {
      this.isActive = false;
      RecognitionInstance.activeInstanceId = null;
      this.onErrorCallback?.(
        error.message || 'Error al iniciar reconocimiento',
      );
    }
  }

  async stop() {
    if (this.isActive) {
      try {
        await ExpoSpeechRecognitionModule.stop();
      } catch (error) {
        // Ignorar errores al detener
      } finally {
        this.isActive = false;
        if (RecognitionInstance.activeInstanceId === this.id) {
          RecognitionInstance.activeInstanceId = null;
        }
        this.onEndCallback?.();
      }
    }
  }

  handleResult(transcript: string) {
    if (this.isActive && RecognitionInstance.activeInstanceId === this.id) {
      this.onResultCallback?.(transcript);
    }
  }

  handleError(error: string) {
    if (this.isActive && RecognitionInstance.activeInstanceId === this.id) {
      this.isActive = false;
      RecognitionInstance.activeInstanceId = null;
      this.onErrorCallback?.(error);
    }
  }

  handleEnd() {
    if (this.isActive && RecognitionInstance.activeInstanceId === this.id) {
      this.isActive = false;
      RecognitionInstance.activeInstanceId = null;
      this.onEndCallback?.();
    }
  }
}

interface SpeechRecognitionInputProps
  extends Omit<
    React.ComponentProps<typeof AnimatedLabelInput>,
    'value' | 'onChangeText'
  > {
  value: string;
  onChangeText: (text: string) => void;
  label: string;
  speechLang?: string;
  clearOnStart?: boolean;
  replaceContent?: boolean;
  onError?: (error: string) => void;
}

const SpeechRecognitionInput: React.FC<SpeechRecognitionInputProps> = ({
  value,
  onChangeText,
  label,
  speechLang = 'es-MX',
  clearOnStart = false,
  replaceContent = true,
  onError,
  error,
  errorColor,
  activeBorderColor,
  containerStyle,
  inputStyle,
  labelStyle,
  style,
  ...rest
}) => {
  const theme = useAppTheme();
  const [isRecognizingSpeech, setIsRecognizingSpeech] = useState(false);
  const [localValue, setLocalValue] = useState(value);
  const instanceId = useRef(
    `speech-${Date.now()}-${Math.floor(Math.random() * 10000)}`,
  ).current;
  const recognitionInstance = useRef<RecognitionInstance | null>(null);
  const scaleAnim = useRef(new Animated.Value(1)).current;
  const lastProcessedValue = useRef(value);
  const isUpdatingFromSpeech = useRef(false);

  // Sincronizar valor externo con valor local solo cuando cambia externamente
  useEffect(() => {
    if (!isUpdatingFromSpeech.current && value !== lastProcessedValue.current) {
      setLocalValue(value);
      lastProcessedValue.current = value;
    }
  }, [value]);

  // Configurar la instancia de reconocimiento
  useEffect(() => {
    recognitionInstance.current = RecognitionInstance.getInstance(instanceId);

    recognitionInstance.current.setCallbacks({
      onStart: () => {
        setIsRecognizingSpeech(true);
        if (clearOnStart) {
          setLocalValue('');
          lastProcessedValue.current = '';
          onChangeText('');
        }
      },
      onEnd: () => {
        setIsRecognizingSpeech(false);
      },
      onResult: (transcript: string) => {
        let newValue: string;

        if (replaceContent) {
          if (rest.keyboardType === 'phone-pad') {
            newValue = transcript.replace(/\D/g, '');
          } else {
            newValue = transcript;
          }
        } else {
          // Usar el valor local ms actualizado
          newValue = localValue ? localValue + ' ' + transcript : transcript;
        }

        isUpdatingFromSpeech.current = true;
        setLocalValue(newValue);
        lastProcessedValue.current = newValue;
        onChangeText(newValue);

        // Resetear flag despus de un breve delay
        setTimeout(() => {
          isUpdatingFromSpeech.current = false;
        }, 100);
      },
      onError: (errorMsg: string) => {
        setIsRecognizingSpeech(false);
        onError?.(errorMsg);
      },
    });

    return () => {
      RecognitionInstance.removeInstance(instanceId);
    };
  }, [
    instanceId,
    clearOnStart,
    onChangeText,
    replaceContent,
    rest.keyboardType,
    onError,
    localValue,
  ]);

  // Animacin del botn
  useEffect(() => {
    Animated.spring(scaleAnim, {
      toValue: isRecognizingSpeech ? 1.2 : 1,
      friction: 3,
      useNativeDriver: true,
    }).start();
  }, [isRecognizingSpeech, scaleAnim]);

  // Event listeners globales - solo procesan si la instancia activa coincide
  useSpeechRecognitionEvent('start', () => {
    // El evento start ya se maneja en el mtodo start() de RecognitionInstance
  });

  useSpeechRecognitionEvent('end', () => {
    const activeInstance = RecognitionInstance.getActiveInstance();
    if (activeInstance?.id === instanceId) {
      activeInstance.handleEnd();
    }
  });

  useSpeechRecognitionEvent('result', (event) => {
    const activeInstance = RecognitionInstance.getActiveInstance();
    if (activeInstance?.id === instanceId && event.results?.[0]) {
      activeInstance.handleResult(event.results[0].transcript);
    }
  });

  useSpeechRecognitionEvent('error', (event) => {
    const activeInstance = RecognitionInstance.getActiveInstance();
    if (activeInstance?.id === instanceId) {
      activeInstance.handleError(
        event.message || event.error || 'Error desconocido',
      );
    }
  });

  const toggleRecognition = async () => {
    if (!recognitionInstance.current) return;

    if (isRecognizingSpeech) {
      await recognitionInstance.current.stop();
    } else {
      await recognitionInstance.current.start(speechLang);
    }
  };

  const micIconColor = isRecognizingSpeech
    ? theme.colors.error
    : theme.colors.primary;

  // Manejar cambios de texto desde el teclado
  const handleTextChange = useCallback(
    (text: string) => {
      // Actualizar estado local inmediatamente
      setLocalValue(text);
      lastProcessedValue.current = text;

      // Notificar al padre
      onChangeText(text);
    },
    [onChangeText],
  );

  return (
    <View style={styles.wrapper}>
      <AnimatedLabelInput
        label={label}
        value={localValue}
        onChangeText={handleTextChange}
        error={error}
        errorColor={errorColor}
        activeBorderColor={activeBorderColor}
        containerStyle={[containerStyle, styles.flexContainer]}
        inputStyle={inputStyle}
        labelStyle={labelStyle}
        style={style}
        {...rest}
      />
      <Animated.View style={{ transform: [{ scale: scaleAnim }] }}>
        <IconButton
          key={isRecognizingSpeech ? 'mic-active' : 'mic-inactive'}
          icon={isRecognizingSpeech ? 'microphone-off' : 'microphone'}
          size={24}
          iconColor={micIconColor}
          onPress={toggleRecognition}
          style={styles.iconButton}
        />
      </Animated.View>
    </View>
  );
};

const styles = StyleSheet.create({
  wrapper: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  iconButton: {
    marginLeft: 8,
    marginVertical: 0,
    padding: 0,
  },
  flexContainer: {
    flex: 1,
  },
});

export default SpeechRecognitionInput;

================
File: app/src/app/components/responsive/index.ts
================
// Exportar todos los componentes responsive desde un nico punto
export {
  ResponsiveView,
  ResponsiveRow,
  ResponsiveColumn,
} from './ResponsiveView';
export { ResponsiveGrid, ResponsiveFlexGrid, GridItem } from './ResponsiveGrid';
export {
  ResponsiveImage,
} from './ResponsiveImage';
export { ResponsiveModal, ResponsiveConfirmModal } from './ResponsiveModal';

================
File: app/src/app/constants/rolePermissions.ts
================
import { RoleEnum } from '@/modules/users/schema/user.schema';

export type DrawerSection =
  | 'OrdersStack'
  | 'ReceiptsStack'
  | 'OrderFinalizationStack'
  | 'MenuStack'
  | 'AvailabilityScreen'
  | 'ModifiersStack'
  | 'PizzaCustomizationsStack'
  | 'PreparationScreensStack'
  | 'AreasTablesStack'
  | 'PrintersStack'
  | 'RestaurantConfigStack'
  | 'CustomersStack'
  | 'SyncStack'
  | 'UsersScreen'
  | 'KitchenScreen'
  | 'ShiftAuditStack';

// Definir permisos por rol
export const ROLE_PERMISSIONS: Record<RoleEnum, DrawerSection[]> = {
  // Admin - Acceso completo
  [RoleEnum.ADMIN]: [
    'OrdersStack',
    'OrderFinalizationStack',
    'ReceiptsStack',
    'MenuStack',
    'AvailabilityScreen',
    'ModifiersStack',
    'PizzaCustomizationsStack',
    'PreparationScreensStack',
    'AreasTablesStack',
    'PrintersStack',
    'RestaurantConfigStack',
    'CustomersStack',
    'SyncStack',
    'UsersScreen',
    'ShiftAuditStack',
  ],

  // Manager - Acceso completo excepto usuarios
  [RoleEnum.MANAGER]: [
    'OrdersStack',
    'OrderFinalizationStack',
    'ReceiptsStack',
    'MenuStack',
    'AvailabilityScreen',
    'ModifiersStack',
    'PizzaCustomizationsStack',
    'PreparationScreensStack',
    'AreasTablesStack',
    'PrintersStack',
    'RestaurantConfigStack',
    'CustomersStack',
    'SyncStack',
    'ShiftAuditStack',
  ],

  // Cashier - Ventas, clientes y configuracin bsica
  [RoleEnum.CASHIER]: [
    'OrdersStack',
    'OrderFinalizationStack',
    'ReceiptsStack',
    'MenuStack',
    'AvailabilityScreen',
    'AreasTablesStack',
    'CustomersStack',
  ],

  // Waiter - rdenes, mesas y disponibilidad
  [RoleEnum.WAITER]: [
    'OrdersStack',
    'MenuStack',
    'AvailabilityScreen',
    'AreasTablesStack',
    'CustomersStack',
  ],

  // Kitchen - Solo acceso a pantalla de preparacin
  // Los usuarios con pantalla asignada van directo a KitchenScreen
  [RoleEnum.KITCHEN]: ['KitchenScreen'],

  // Delivery - rdenes, clientes y reas
  [RoleEnum.DELIVERY]: [
    'OrdersStack',
    'OrderFinalizationStack',
    'CustomersStack',
    'AreasTablesStack',
  ],
};

// Helper para verificar si un rol tiene permiso para una seccin
export const hasPermission = (
  roleId: number | undefined,
  section: DrawerSection,
): boolean => {
  if (!roleId) return false;

  const permissions = ROLE_PERMISSIONS[roleId as RoleEnum];
  return permissions ? permissions.includes(section) : false;
};

// Agrupar secciones por categora para facilitar el renderizado
export const DRAWER_SECTIONS = {
  sales: {
    title: 'Ventas',
    items: [
      {
        route: 'OrdersStack',
        label: 'rdenes',
        icon: 'clipboard-list-outline',
      },
      {
        route: 'OrderFinalizationStack',
        label: 'Finalizacin',
        icon: 'clipboard-check-outline',
      },
      { route: 'ReceiptsStack', label: 'Recibos', icon: 'receipt' },
    ],
  },
  configuration: {
    title: 'Configuracin',
    items: [
      { route: 'MenuStack', label: 'Men', icon: 'menu' },
      {
        route: 'AvailabilityScreen',
        label: 'Disponibilidad',
        icon: 'eye-off-outline',
      },
      { route: 'ModifiersStack', label: 'Modificadores', icon: 'tune' },
      {
        route: 'PizzaCustomizationsStack',
        label: 'Personalizacin Pizzas',
        icon: 'pizza',
      },
      {
        route: 'PreparationScreensStack',
        label: 'Pantallas Preparacin',
        icon: 'monitor-dashboard',
      },
      {
        route: 'AreasTablesStack',
        label: 'reas y Mesas',
        icon: 'map-marker-radius-outline',
      },
      { route: 'PrintersStack', label: 'Impresoras', icon: 'printer' },
      {
        route: 'RestaurantConfigStack',
        label: 'Configuracin',
        icon: 'cog-outline',
      },
      {
        route: 'CustomersStack',
        label: 'Clientes',
        icon: 'account-group-outline',
      },
      { route: 'SyncStack', label: 'Sincronizacin', icon: 'sync' },
    ],
  },
  administration: {
    title: 'Administracin',
    items: [
      { route: 'UsersScreen', label: 'Usuarios', icon: 'account-multiple' },
      {
        route: 'ShiftAuditStack',
        label: 'Historial de Turnos',
        icon: 'history',
      },
    ],
  },
} as const;

================
File: app/src/app/hooks/useGlobalShift.ts
================
import { useQuery } from '@tanstack/react-query';
import { shiftsService, type Shift } from '@/services/shifts';

export const useGlobalShift = () => {
  return useQuery<Shift | null, Error>({
    queryKey: ['global', 'shift', 'current'],
    queryFn: () => shiftsService.getCurrentShift(),
    staleTime: 60 * 1000, // Los datos se consideran obsoletos despus de 60 segundos
    gcTime: 5 * 60 * 1000, // Mantener en cach por 5 minutos
    refetchInterval: 2 * 60 * 1000, // Actualizar cada 2 minutos automticamente
    refetchOnWindowFocus: false, // No actualizar automticamente al volver al foco
    refetchOnMount: 'always', // Actualizar siempre al montar el componente
    refetchOnReconnect: true, // Actualizar cuando se reconecta
    retry: 1, // Solo reintentar una vez en caso de error
    retryDelay: 1000, // Esperar 1 segundo antes de reintentar
  });
};

================
File: app/src/app/hooks/useInitializeAuth.ts
================
import { useEffect, useState } from 'react';
import { initializeAuthStore } from '../store/authStore';
import { verifyStoredToken } from '../utils/tokenVerification';

export function useInitializeAuth() {
  const [isInitializing, setIsInitializing] = useState(true);

  useEffect(() => {
    const initialize = async () => {
      try {
        await initializeAuthStore();
        // Verificar el token despus de inicializar el store
        await verifyStoredToken();
      } catch (error) {
        // Error al inicializar auth store
      } finally {
        setIsInitializing(false);
      }
    };

    initialize();
  }, []);

  return isInitializing;
}

================
File: app/src/app/hooks/useListState.ts
================
import { useMemo, createElement } from 'react';
import EmptyState from '../components/common/EmptyState';

interface UseListStateProps {
  isLoading: boolean;
  isError: boolean;
  data: any[] | undefined;
  emptyConfig: {
    title: string;
    message?: string;
    actionLabel?: string;
    onAction?: () => void;
    icon?: string;
  };
  errorConfig?: {
    title?: string;
    message?: string;
    actionLabel?: string;
    onAction?: () => void;
    onRetry?: (...args: any[]) => any;
    icon?: string;
  };
}

export const useListState = ({
  isLoading,
  isError,
  data,
  emptyConfig,
  errorConfig,
}: UseListStateProps) => {
  const isEmpty = useMemo(() => {
    return !isLoading && !isError && data && data.length === 0;
  }, [isLoading, isError, data]);

  const ListEmptyComponent = useMemo(() => {
    // Return a function component instead of JSX directly
    return () => {
      if (isLoading) return null;

      if (isError) {
        return createElement(EmptyState, {
          icon: errorConfig?.icon || 'alert-circle',
          title: errorConfig?.title || 'Error al cargar los datos',
          message:
            errorConfig?.message ||
            'Ocurri un error al cargar la informacin. Por favor, intenta de nuevo.',
          actionLabel: errorConfig?.actionLabel || 'Reintentar',
          onAction: errorConfig?.onAction || errorConfig?.onRetry || emptyConfig.onAction,
        });
      }

      if (isEmpty) {
        return createElement(EmptyState, {
          icon: emptyConfig.icon || 'folder-open',
          title: emptyConfig.title,
          message: emptyConfig.message,
          actionLabel: emptyConfig.actionLabel,
          onAction: emptyConfig.onAction,
        });
      }

      return null;
    };
  }, [isLoading, isError, isEmpty, emptyConfig, errorConfig]);

  return {
    isEmpty,
    ListEmptyComponent,
  };
};

================
File: app/src/app/hooks/useRefreshOnFocus.ts
================
import { useCallback } from 'react';
import { useFocusEffect } from '@react-navigation/native';
import { useQueryClient } from '@tanstack/react-query';

/**
 * Hook que refresca todas las queries de un mdulo cuando la pantalla recibe foco
 * @param modulePrefix - Prefijo del mdulo (ej: 'products', 'orders', etc)
 */
export function useRefreshModuleOnFocus(
  modulePrefix: string,
  options?: {
    enabled?: boolean;
  },
) {
  const queryClient = useQueryClient();
  const { enabled = true } = options || {};

  useFocusEffect(
    useCallback(() => {
      if (!enabled) return;

      // Invalidar todas las queries que empiecen con el prefijo del mdulo
      queryClient.invalidateQueries({
        predicate: (query) => {
          const queryKey = query.queryKey;
          if (Array.isArray(queryKey) && queryKey.length > 0) {
            return queryKey[0] === modulePrefix;
          }
          return false;
        },
      });
    }, [enabled, modulePrefix, queryClient]),
  );
}

================
File: app/src/app/lib/imageUploadService.ts
================
import {
  uploadFile,
  FileUploadResponse,
} from '../../modules/menu/services/fileService';
import { ApiError } from './errors';
import { getImageUrl } from './imageUtils';

export interface ImageUploadResult {
  success: boolean;
  photoId?: string;
  error?: string;
}

export interface FileObject {
  uri: string;
  name: string;
  type: string;
}

export interface EntityWithOptionalPhoto {
  photo?: {
    id: string;
    path: string;
  } | null;
}

export class ImageUploadService {
  /**
   * Sube una imagen usando el fileService.
   * @param imageFile El objeto FileObject con uri, name, type.
   * @returns Un objeto ImageUploadResult indicando xito/fallo y el ID de la foto.
   */
  static async uploadImage(imageFile: FileObject): Promise<ImageUploadResult> {
    if (!imageFile || !imageFile.uri) {
      // Intento de subir imagen invlida
      return {
        success: false,
        error: 'No se proporcion ninguna imagen vlida',
      };
    }

    try {
      const uploadResult: FileUploadResponse = await uploadFile(imageFile);

      if (!uploadResult || !uploadResult.file || !uploadResult.file.id) {
        // Respuesta invlida del fileService
        return {
          success: false,
          error: 'Respuesta invlida del servidor al subir imagen.',
        };
      }

      return {
        success: true,
        photoId: uploadResult.file.id,
      };
    } catch (error) {
      // Error en ImageUploadService.uploadImage
      let errorMessage = 'Error desconocido al subir la imagen.';
      if (error instanceof ApiError) {
        errorMessage = `Error al subir: ${error.originalMessage || error.code}`;
      } else if (error instanceof Error) {
        errorMessage = error.message;
      }
      return {
        success: false,
        error: errorMessage,
      };
    }
  }

  /**
   * Determina el valor de photoId a enviar al backend basado en el estado actual del formulario y la entidad existente.
   * @param formImageUri La URI de la imagen actual en el formulario (puede ser 'file://...', una URL remota, o null).
   * @param existingEntity La entidad actual (ej. Category) que podra tener una propiedad 'photo' con 'id' y 'path'.
   * @returns
   *   - `undefined`: No hay cambios en la foto O se va a subir una nueva. El DTO NO debe incluir `photoId`.
   *   - `null`: Se debe eliminar la foto existente en el backend. El DTO DEBE incluir `photoId: null`.
   */
  static determinePhotoId(
    currentImageUri: string | null,
    editingItem?: EntityWithOptionalPhoto,
  ): string | null | undefined {
    if (!currentImageUri && editingItem?.photo) {
      return null;
    }
    
    return undefined;
  }
}

================
File: app/src/app/navigation/AuthStack.tsx
================
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { useAppTheme } from '../styles/theme';

import LoginScreen from '../../modules/auth/screens/LoginScreen';
import type { AuthStackParamList } from './types';

const Stack = createNativeStackNavigator<AuthStackParamList>();

export function AuthStack() {
  const theme = useAppTheme();

  return (
    <Stack.Navigator
      screenOptions={{
        headerStyle: {
          backgroundColor: theme.colors.primary,
        },
        headerTintColor: theme.colors.onPrimary,
        headerTitleStyle: {
          ...theme.fonts.titleLarge,
        },
      }}
    >
      <Stack.Screen
        name="Login"
        component={LoginScreen}
        options={{
          title: 'Iniciar Sesin',
          headerShown: false,
        }}
      />
    </Stack.Navigator>
  );
}

================
File: app/src/app/navigation/ConditionalAppNavigator.tsx
================
import { useEffect, useState, useCallback } from 'react';
import { View, ActivityIndicator } from 'react-native';
import { Portal, Dialog, Button, Text } from 'react-native-paper';
import { useAuthStore } from '../store/authStore';
import { AppDrawerNavigator } from './AppDrawerNavigator';
import { KitchenOnlyNavigator } from './KitchenOnlyNavigator';
import { useAppTheme } from '../styles/theme';

export function ConditionalAppNavigator() {
  const theme = useAppTheme();
  const user = useAuthStore((state) => state.user);
  const logout = useAuthStore((state) => state.logout);
  const [loading, setLoading] = useState(true);
  const [showNoScreenAlert, setShowNoScreenAlert] = useState(false);
  const [isKitchenUser, setIsKitchenUser] = useState(false);

  const styles = {
    loadingContainer: {
      flex: 1,
      justifyContent: 'center' as const,
      alignItems: 'center' as const,
      backgroundColor: theme.colors.background,
    },
    dialogSurface: {
      backgroundColor: theme.colors.surface,
    },
    dialogTitleCenter: {
      textAlign: 'center' as const,
    },
    dialogContentCenter: {
      textAlign: 'center' as const,
    },
    dialogContentSpaced: {
      textAlign: 'center' as const,
      marginTop: 8,
    },
  };

  const checkUserAccess = useCallback(async () => {
    if (!user) {
      setLoading(false);
      return;
    }

    try {
      // Obtener el ID del rol
      const roleId = typeof user.role === 'object' ? user.role?.id : null;

      // Solo verificar pantalla para usuarios con rol kitchen (ID 5)
      if (roleId === 5) {
        setIsKitchenUser(true);
        // La informacin de la pantalla ya viene en el objeto user
        const hasScreen = !!user.preparationScreen;

        if (!hasScreen) {
          // Usuario de cocina sin pantalla asignada
          setShowNoScreenAlert(true);
        }
      } else {
        setIsKitchenUser(false);
      }
    } catch (error) {
      setIsKitchenUser(false);
    } finally {
      setLoading(false);
    }
  }, [user]);

  useEffect(() => {
    checkUserAccess();
  }, [checkUserAccess]);

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </View>
    );
  }

  // Usuarios de cocina usan un navegador especial, otros usan el drawer normal
  return (
    <>
      {isKitchenUser ? <KitchenOnlyNavigator /> : <AppDrawerNavigator />}
      <Portal>
        <Dialog
          visible={showNoScreenAlert}
          onDismiss={() => setShowNoScreenAlert(false)}
          style={styles.dialogSurface}
        >
          <Dialog.Icon
            icon="alert-circle"
            size={64}
            color={theme.colors.error}
          />
          <Dialog.Title style={styles.dialogTitleCenter}>
            Sin Pantalla Asignada
          </Dialog.Title>
          <Dialog.Content>
            <Text variant="bodyLarge" style={styles.dialogContentCenter}>
              Tu usuario de cocina no tiene una pantalla de preparacin
              asignada.
            </Text>
            <Text variant="bodyMedium" style={styles.dialogContentSpaced}>
              Por favor, contacta a tu administrador para que te asigne una
              pantalla de preparacin.
            </Text>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setShowNoScreenAlert(false)}>
              Entendido
            </Button>
            <Button
              mode="contained"
              onPress={async () => {
                setShowNoScreenAlert(false);
                await logout();
              }}
            >
              Cerrar Sesin
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </>
  );
}

================
File: app/src/app/navigation/options.ts
================
import { NativeStackNavigationOptions } from '@react-navigation/native-stack';
import { DrawerNavigationOptions } from '@react-navigation/drawer';
import { AppTheme } from '../styles/theme';
import { ResponsiveInfo } from '../hooks/useResponsive';

export const getDrawerHeaderOptions = (
  theme: AppTheme,
  responsive?: ResponsiveInfo,
): DrawerNavigationOptions => ({
  headerStyle: {
    backgroundColor: theme.colors.primary,
  },
  headerTintColor: theme.colors.onPrimary,
  headerTitleStyle: {
    ...theme.fonts.titleLarge,
    color: theme.colors.onPrimary,
    fontWeight: 'bold',
    fontSize: responsive?.fontSizePreset.xl,
  },
  headerShadowVisible: false,
});

export const getStackHeaderOptions = (
  theme: AppTheme,
  responsive?: ResponsiveInfo,
): NativeStackNavigationOptions => ({
  headerStyle: {
    backgroundColor: theme.colors.elevation.level2,
  },
  headerTintColor: theme.colors.onSurface,
  headerTitleStyle: {
    ...theme.fonts.titleMedium,
    color: theme.colors.onSurface,
    fontWeight: 'bold',
    fontSize: responsive?.fontSizePreset.l,
  },
  headerTitleAlign: 'center',
  headerShadowVisible: false,
});

================
File: app/src/app/services/certificateValidator.ts
================
import { Platform } from 'react-native';

/**
 * Servicio para validacin de certificados SSL
 * En produccin, valida que las conexiones HTTPS usen certificados vlidos
 */
export class CertificateValidator {
  private static instance: CertificateValidator;
  private isProduction: boolean;

  private constructor() {
    // Determinar si estamos en produccin basndonos en __DEV__
    this.isProduction = !__DEV__;
  }

  static getInstance(): CertificateValidator {
    if (!CertificateValidator.instance) {
      CertificateValidator.instance = new CertificateValidator();
    }
    return CertificateValidator.instance;
  }

  /**
   * Valida si una URL es segura para conectarse
   * @param url URL a validar
   * @returns true si la URL es segura o estamos en desarrollo
   */
  isSecureUrl(url: string): boolean {
    // En desarrollo, permitir cualquier URL
    if (!this.isProduction) {
      return true;
    }

    try {
      const urlObj = new URL(url);

      // En produccin, solo permitir HTTPS para dominios externos
      if (this.isExternalDomain(urlObj.hostname)) {
        return urlObj.protocol === 'https:';
      }

      // Para IPs locales, permitir HTTP (necesario para discovery)
      return this.isLocalNetwork(urlObj.hostname);
    } catch {
      return false;
    }
  }

  /**
   * Determina si un hostname es una red local
   */
  private isLocalNetwork(hostname: string): boolean {
    // Localhost
    if (hostname === 'localhost' || hostname === '127.0.0.1') {
      return true;
    }

    // Redes privadas IPv4 (RFC 1918)
    const parts = hostname.split('.');
    if (parts.length === 4) {
      const firstOctet = parseInt(parts[0]);
      const secondOctet = parseInt(parts[1]);

      // 10.0.0.0/8
      if (firstOctet === 10) return true;

      // 172.16.0.0/12
      if (firstOctet === 172 && secondOctet >= 16 && secondOctet <= 31)
        return true;

      // 192.168.0.0/16
      if (firstOctet === 192 && secondOctet === 168) return true;
    }

    return false;
  }

  /**
   * Determina si un hostname es un dominio externo
   */
  private isExternalDomain(hostname: string): boolean {
    // Si no es IP local y no es localhost, es externo
    return (
      !this.isLocalNetwork(hostname) &&
      !hostname.includes('.local') &&
      !hostname.includes('.internal')
    );
  }

  /**
   * Obtiene configuracin de seguridad para axios
   */
  getAxiosSecurityConfig() {
    if (Platform.OS === 'android' && this.isProduction) {
      return {
        // En produccin, validar certificados
        httpsAgent: {
          rejectUnauthorized: true,
        },
      };
    }

    return {};
  }

  /**
   * Valida si se debe permitir una conexin
   * @throws Error si la conexin no es segura en produccin
   */
  validateConnection(url: string): void {
    if (!this.isSecureUrl(url)) {
      throw new Error(
        `Conexin insegura bloqueada: ${url}. ` +
          'En produccin solo se permiten conexiones HTTPS a dominios externos.',
      );
    }
  }
}

export const certificateValidator = CertificateValidator.getInstance();

================
File: app/src/app/utils/roleUtils.ts
================
import type { User } from '@/app/schemas/domain/user.schema';

/**
 * Enum de roles basado en los IDs del backend
 */
export enum RoleEnum {
  ADMIN = 1,
  MANAGER = 2,
  CASHIER = 3,
  WAITER = 4,
  KITCHEN = 5,
}

/**
 * Verifica si el usuario tiene un rol especfico
 */
export const hasRole = (user: User | null, roleId: RoleEnum): boolean => {
  return user?.role?.id === roleId;
};

/**
 * Verifica si el usuario tiene alguno de los roles especificados
 */
export const hasAnyRole = (user: User | null, roleIds: RoleEnum[]): boolean => {
  if (!user?.role?.id) return false;
  return roleIds.includes(user.role.id);
};


/**
 * Permisos especficos de funcionalidad
 */
export const canOpenShift = (user: User | null): boolean => {
  return hasAnyRole(user, [RoleEnum.ADMIN, RoleEnum.MANAGER]);
};

export const canRegisterPayments = (user: User | null): boolean => {
  return hasAnyRole(user, [RoleEnum.ADMIN, RoleEnum.MANAGER, RoleEnum.CASHIER]);
};

================
File: app/src/hooks/useAudioRecorder.ts
================
import { useState, useCallback, useRef, useEffect } from 'react';
import {
  useAudioRecorder as useExpoAudioRecorder,
  AudioModule,
  RecordingPresets,
} from 'expo-audio';
import {
  ExpoSpeechRecognitionModule,
  useSpeechRecognitionEvent,
} from 'expo-speech-recognition';

interface UseAudioRecorderReturn {
  isRecording: boolean;
  isPreparing: boolean;
  isProcessing: boolean;
  audioUri: string | null;
  transcription: string | null;
  startRecording: () => Promise<void>;
  stopRecording: () => Promise<void>;
  resetRecording: () => void;
  error: string | null;
}

export const useAudioRecorder = (): UseAudioRecorderReturn => {
  const [isRecording, setIsRecording] = useState(false);
  const [isPreparing, setIsPreparing] = useState(false);
  const [isProcessing, setIsProcessing] = useState(false);
  const [audioUri, setAudioUri] = useState<string | null>(null);
  const [transcription, setTranscription] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [isInitialized, setIsInitialized] = useState(false);

  const audioRecorder = useExpoAudioRecorder({
    ...RecordingPresets.HIGH_QUALITY,
    android: {
      ...RecordingPresets.HIGH_QUALITY.android,
      extension: '.mp4',
      outputFormat: 'mpeg4',
      audioEncoder: 'aac',
      sampleRate: 16000,
    },
    ios: {
      ...RecordingPresets.HIGH_QUALITY.ios,
      extension: '.m4a',
      sampleRate: 16000,
    },
  });

  const [currentTranscription, setCurrentTranscription] = useState<string>('');
  const currentTranscriptionRef = useRef<string>('');
  const isTranscribing = useRef(false);
  const isMounted = useRef(true);

  useEffect(() => {
    if (audioRecorder && typeof audioRecorder.record === 'function') {
      setIsInitialized(true);
    }
  }, [audioRecorder]);

  const isStopping = useRef(false);

  useSpeechRecognitionEvent('result', (event) => {
    if (!isMounted.current) return;

    const results = event.results;
    if (results && results.length > 0) {
      const bestResult = results[0];
      if (bestResult && bestResult.transcript) {
        const newTranscript = bestResult.transcript;
        currentTranscriptionRef.current = newTranscript;
        setCurrentTranscription(newTranscript);

        if (event.isFinal) {
          setTranscription(newTranscript);
        }
      }
    }
  });

  useSpeechRecognitionEvent('end', () => {
    if (!isMounted.current) return;
    isTranscribing.current = false;
  });

  const startRecording = useCallback(async () => {
    if (!isMounted.current) return;
    if (!isInitialized || !audioRecorder) {
      setError('El grabador de audio no est listo');
      return;
    }

    try {
      setError(null);
      setIsPreparing(true);
      setCurrentTranscription('');
      currentTranscriptionRef.current = '';
      setTranscription('');

      const audioPermission =
        await AudioModule.requestRecordingPermissionsAsync();
      if (!audioPermission.granted) {
        throw new Error('Se requiere permiso para grabar audio');
      }

      const speechPermissions =
        await ExpoSpeechRecognitionModule.requestPermissionsAsync();
      if (!speechPermissions.granted) {
        throw new Error('Se requiere permiso para reconocimiento de voz');
      }

      isTranscribing.current = true;
      setCurrentTranscription('');

      try {
        await ExpoSpeechRecognitionModule.start({
          lang: 'es-MX',
          interimResults: true,
          continuous: true,
          maxAlternatives: 1,
        });
      } catch (speechError) {}

      await new Promise((resolve) => setTimeout(resolve, 300));

      await audioRecorder.prepareToRecordAsync();
      await audioRecorder.record();

      if (isMounted.current) {
        setIsRecording(true);
        setIsPreparing(false);
      }
    } catch (err) {
      if (isMounted.current) {
        setIsPreparing(false);
        const errorMessage =
          err instanceof Error ? err.message : 'Error al iniciar grabacin';
        setError(errorMessage);
      }
    }
  }, [audioRecorder, isInitialized]);

  const stopRecording = useCallback(async () => {
    if (!isMounted.current) return;

    if (isStopping.current) {
      return;
    }

    try {
      const isCurrentlyRecording = audioRecorder.isRecording;
      if (!isCurrentlyRecording) {
        return;
      }

      isStopping.current = true;

      setIsProcessing(true);
      setIsRecording(false);

      if (isTranscribing.current) {
        try {
          await ExpoSpeechRecognitionModule.stop();
          await new Promise((resolve) => setTimeout(resolve, 500));
        } catch (error) {
        } finally {
          isTranscribing.current = false;
        }
      }

      let uri: string | undefined;
      try {
        await audioRecorder.stop();
        uri = audioRecorder.uri || undefined;
      } catch (audioError) {
        if ((audioError as Error)?.message?.includes('stop failed')) {
          uri = audioRecorder.uri || undefined;
        } else {
          throw audioError;
        }
      }

      if (!uri) {
        throw new Error('No se pudo obtener el archivo de audio');
      }

      if (isMounted.current) {
        const finalTranscription =
          currentTranscriptionRef.current ||
          currentTranscription ||
          transcription ||
          '';

        if (finalTranscription) {
          setTranscription(finalTranscription);
        } else {
          setTranscription('');
        }

        setAudioUri(uri);
        setIsProcessing(false);
      }
    } catch (err) {
      if (isMounted.current) {
        setIsProcessing(false);
        const errorMessage =
          err instanceof Error ? err.message : 'Error al detener grabacin';
        setError(errorMessage);
      }
    } finally {
      isStopping.current = false;
    }
  }, [audioRecorder, currentTranscription, transcription]);

  const resetRecording = useCallback(() => {
    if (!isMounted.current) return;

    if (isTranscribing.current) {
      try {
        ExpoSpeechRecognitionModule.stop();
      } catch (_err) {}
      isTranscribing.current = false;
    }

    if (audioRecorder && audioRecorder.isRecording) {
      try {
        audioRecorder.stop();
      } catch (err) {}
    }

    setAudioUri(null);
    setTranscription(null);
    setCurrentTranscription('');
    currentTranscriptionRef.current = '';
    setError(null);
    setIsRecording(false);
    setIsProcessing(false);
    setIsPreparing(false);
    isStopping.current = false;
  }, [audioRecorder]);

  useEffect(() => {
    isMounted.current = true;

    return () => {
      isMounted.current = false;

      if (isTranscribing.current) {
        isTranscribing.current = false;
        try {
          ExpoSpeechRecognitionModule.stop();
        } catch (err) {}
      }
    };
  }, []);

  return {
    isRecording,
    isPreparing,
    isProcessing,
    audioUri,
    transcription,
    startRecording,
    stopRecording,
    resetRecording,
    error,
  };
};

================
File: app/src/modules/areasTables/schema/area.schema.ts
================
import { z } from 'zod';
import type { Area } from '../../../app/schemas/domain/area.schema';
const areaBaseSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().optional(),
  isActive: z.boolean().optional(),
});

export const CreateAreaSchema = areaBaseSchema.extend({
  isActive: z.boolean().optional().default(true),
});

export const UpdateAreaSchema = areaBaseSchema.partial();

export type CreateAreaDto = z.infer<typeof CreateAreaSchema>;
export type UpdateAreaDto = z.infer<typeof UpdateAreaSchema>;

export const FindAllAreasSchema = areaBaseSchema
  .pick({ name: true, isActive: true })
  .partial();

export type FindAllAreasDto = z.infer<typeof FindAllAreasSchema>;

export type { Area };

================
File: app/src/modules/areasTables/schema/table.schema.ts
================
import { z } from 'zod';
import type { Table } from '../../../app/schemas/domain/table.schema';
const tableBaseSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  capacity: z.preprocess(
    (val) => (val === '' || val === null ? undefined : val),
    z.coerce
      .number()
      .int()
      .positive('La capacidad debe ser un nmero positivo')
      .nullable()
      .optional(),
  ),
  isActive: z.boolean().optional(),
});

export const CreateTableSchema = tableBaseSchema.extend({
  isActive: z.boolean().optional().default(true),
});

export const UpdateTableSchema = tableBaseSchema.partial();

export type CreateTableDto = z.infer<typeof CreateTableSchema>;
export type UpdateTableDto = z.infer<typeof UpdateTableSchema>;

const transformBoolean = (val: unknown) => {
  if (val === 'true') return true;
  if (val === 'false') return false;
  return val;
};

export const FindAllTablesSchema = z.object({
  name: z.string().optional(),
  areaId: z.string().uuid().optional(),
  capacity: z.coerce.number().int().optional(),
  isActive: z.preprocess(transformBoolean, z.boolean().optional()),
  isAvailable: z.preprocess(transformBoolean, z.boolean().optional()),
  isTemporary: z.preprocess(transformBoolean, z.boolean().optional()),
});
export type FindAllTablesDto = z.infer<typeof FindAllTablesSchema>;

export type { Table };

================
File: app/src/modules/availability/hooks/useOptimisticAvailability.ts
================
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { availabilityService } from '../services/availabilityService';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import {
  CategoryAvailability,
  ModifierGroupAvailability,
  PizzaCustomizationGroupAvailability,
  AvailabilityUpdatePayload,
} from '../schema/availability.schema';

export const useOptimisticAvailability = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const updateOptimistically = (
    type: string,
    id: string,
    isActive: boolean,
    cascade?: boolean,
  ) => {
    const menuQueryKey = ['availability', 'menu'];
    const modifierQueryKey = ['availability', 'modifierGroups'];
    const pizzaQueryKey = ['availability', 'pizzaCustomizations'];

    const updateMenuOptimistically = (oldData: CategoryAvailability[]) => {
      if (!oldData) return oldData;

      return oldData.map((category) => {
        if (type === 'category' && category.id === id) {
          const updated = { ...category, isActive };
          if (cascade) {
            return {
              ...updated,
              subcategories: updated.subcategories.map((sub) => ({
                ...sub,
                isActive,
                products: sub.products.map((prod) => ({ ...prod, isActive })),
              })),
            };
          }
          return updated;
        }

        if (type === 'subcategory') {
          const updatedSubcategories = category.subcategories.map((sub) => {
            if (sub.id === id) {
              const updated = { ...sub, isActive };
              if (cascade) {
                return {
                  ...updated,
                  products: updated.products.map((prod) => ({
                    ...prod,
                    isActive,
                  })),
                };
              }
              return updated;
            }
            return sub;
          });

          return { ...category, subcategories: updatedSubcategories };
        }

        if (type === 'product') {
          const updatedSubcategories = category.subcategories.map((sub) => ({
            ...sub,
            products: sub.products.map((prod) =>
              prod.id === id ? { ...prod, isActive } : prod,
            ),
          }));

          return { ...category, subcategories: updatedSubcategories };
        }

        return category;
      });
    };

    const updateModifierGroupsOptimistically = (
      oldData: ModifierGroupAvailability[],
    ) => {
      if (!oldData) return oldData;

      return oldData.map((group) => {
        if (type === 'modifierGroup' && group.id === id) {
          const updated = { ...group, isActive };
          if (cascade) {
            return {
              ...updated,
              modifiers: updated.modifiers.map((mod) => ({ ...mod, isActive })),
            };
          }
          return updated;
        }

        if (type === 'modifier') {
          const updatedModifiers = group.modifiers.map((mod) =>
            mod.id === id ? { ...mod, isActive } : mod,
          );
          return { ...group, modifiers: updatedModifiers };
        }

        return group;
      });
    };

    const updatePizzaCustomizationsOptimistically = (
      oldData: PizzaCustomizationGroupAvailability[],
    ) => {
      if (!oldData) return oldData;

      return oldData.map((group) => ({
        ...group,
        items: group.items.map((item) =>
          item.id === id ? { ...item, isActive } : item,
        ),
      }));
    };

    if (type === 'category' || type === 'subcategory' || type === 'product') {
      queryClient.setQueryData(menuQueryKey, updateMenuOptimistically);
    } else if (type === 'modifierGroup' || type === 'modifier') {
      queryClient.setQueryData(
        modifierQueryKey,
        updateModifierGroupsOptimistically,
      );
    } else if (type === 'pizzaCustomization') {
      queryClient.setQueryData(
        pizzaQueryKey,
        updatePizzaCustomizationsOptimistically,
      );
    }
  };

  const mutation = useMutation({
    mutationFn: availabilityService.updateAvailability,
    onMutate: async (variables: AvailabilityUpdatePayload) => {
      await queryClient.cancelQueries({ queryKey: ['availability'] });

      const previousMenuData = queryClient.getQueryData([
        'availability',
        'menu',
      ]);
      const previousModifierData = queryClient.getQueryData([
        'availability',
        'modifierGroups',
      ]);
      const previousPizzaData = queryClient.getQueryData([
        'availability',
        'pizzaCustomizations',
      ]);

      updateOptimistically(
        variables.type,
        variables.id,
        variables.isActive,
        variables.cascade,
      );

      return {
        previousMenuData,
        previousModifierData,
        previousPizzaData,
        variables,
      };
    },
    onSuccess: () => {
      showSnackbar({ message: 'Disponibilidad actualizada', type: 'success' });
    },
    onError: (_error, _variables, context) => {
      if (context?.previousMenuData) {
        queryClient.setQueryData(
          ['availability', 'menu'],
          context.previousMenuData,
        );
      }
      if (context?.previousModifierData) {
        queryClient.setQueryData(
          ['availability', 'modifierGroups'],
          context.previousModifierData,
        );
      }
      if (context?.previousPizzaData) {
        queryClient.setQueryData(
          ['availability', 'pizzaCustomizations'],
          context.previousPizzaData,
        );
      }

      showSnackbar({
        message: 'Error al actualizar disponibilidad',
        type: 'error',
      });
    },
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ['availability'] });
    },
  });

  return mutation;
};

================
File: app/src/modules/availability/hooks/usePizzaCustomizationsAvailability.ts
================
import { useQuery } from '@tanstack/react-query';
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import { PizzaCustomizationGroupAvailability } from '../schema/availability.schema';

export function usePizzaCustomizationsAvailability(search?: string) {
  return useQuery({
    queryKey: ['availability', 'pizzaCustomizations', search],
    queryFn: async () => {
      const response = await apiClient.get<
        PizzaCustomizationGroupAvailability[]
      >(API_PATHS.AVAILABILITY_PIZZA_CUSTOMIZATIONS);

      let data = response.data;

      if (search) {
        const searchLower = search.toLowerCase();
        data = data
          .map((group) => ({
            ...group,
            items: group.items.filter((item) =>
              item.name.toLowerCase().includes(searchLower),
            ),
          }))
          .filter((group) => group.items.length > 0);
      }

      return data;
    },
  });
}

================
File: app/src/modules/availability/services/availabilityService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import {
  AvailabilityUpdatePayload,
  CategoryAvailability,
  ModifierGroupAvailability,
} from '../schema/availability.schema';

export const availabilityService = {
  async getMenuAvailability(): Promise<CategoryAvailability[]> {
    const response = await apiClient.get<CategoryAvailability[]>(
      API_PATHS.AVAILABILITY_MENU,
    );
    return response.data;
  },

  async getModifierGroupsAvailability(): Promise<ModifierGroupAvailability[]> {
    const response = await apiClient.get<ModifierGroupAvailability[]>(
      API_PATHS.AVAILABILITY_MODIFIER_GROUPS,
    );
    return response.data;
  },

  async updateAvailability(payload: AvailabilityUpdatePayload): Promise<void> {
    await apiClient.patch(API_PATHS.AVAILABILITY_UPDATE, payload);
  },

  async bulkUpdateAvailability(
    updates: AvailabilityUpdatePayload[],
  ): Promise<void> {
    await apiClient.patch(API_PATHS.AVAILABILITY_BULK_UPDATE, { updates });
  },
};

================
File: app/src/modules/customers/navigation/CustomersStackNavigator.tsx
================
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import CustomersScreen from '../screens/CustomersScreen';

export type CustomersStackParamList = {
  Customers: undefined;
  CustomerDetail?: { customerId: string };
  CustomerAddresses?: { customerId: string };
  CustomerChatHistory?: { customerId: string };
};

const Stack = createNativeStackNavigator<CustomersStackParamList>();

export function CustomersStackNavigator() {
  return (
    <Stack.Navigator
      screenOptions={{
        headerShown: false,
      }}
    >
      <Stack.Screen
        name="Customers"
        component={CustomersScreen}
        options={{
          title: 'Clientes',
        }}
      />
    </Stack.Navigator>
  );
}

================
File: app/src/modules/kitchen/components/KitchenFilterButton.tsx
================
import React, { useState } from 'react';
import {
  View,
  StyleSheet,
  TouchableOpacity,
  Animated,
  ScrollView,
  useWindowDimensions,
} from 'react-native';
import { Portal, Modal, Surface, Text, Switch } from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { useKitchenStore } from '../store/kitchenStore';
import { MaterialCommunityIcons as Icon } from '@expo/vector-icons';
import { OrderTypeEnum } from '../schema/kitchen.schema';

export const KitchenFilterButton: React.FC = () => {
  const { height: screenHeight } = useWindowDimensions();
  const theme = useAppTheme();
  const [visible, setVisible] = useState(false);
  const { filters, setFilters } = useKitchenStore();
  const scaleAnim = React.useRef(new Animated.Value(1)).current;
  const styles = createStyles(screenHeight, theme);

  const activeFiltersCount = [
    filters.showPrepared,
    filters.showAllProducts,
    filters.ungroupProducts,
    filters.orderType !== undefined,
  ].filter(Boolean).length;

  const handleToggleFilter = (filterName: keyof typeof filters) => {
    setFilters({
      ...filters,
      [filterName]: !filters[filterName],
    });
  };

  const handlePressIn = () => {
    Animated.spring(scaleAnim, {
      toValue: 0.9,
      useNativeDriver: true,
    }).start();
  };

  const handlePressOut = () => {
    Animated.spring(scaleAnim, {
      toValue: 1,
      useNativeDriver: true,
    }).start();
  };

  return (
    <>
      <TouchableOpacity
        onPress={() => setVisible(true)}
        onPressIn={handlePressIn}
        onPressOut={handlePressOut}
        activeOpacity={0.8}
        style={styles.buttonContainer}
      >
        <Animated.View
          style={[
            styles.filterButton,
            activeFiltersCount > 0
              ? styles.filterButtonActive
              : styles.filterButtonInactive,
            {
              transform: [{ scale: scaleAnim }],
            },
          ]}
        >
          <Icon
            name="tune-variant"
            size={24}
            color={
              activeFiltersCount > 0
                ? theme.colors.onPrimaryContainer
                : theme.colors.onPrimary
            }
          />
          {activeFiltersCount > 0 && (
            <View
              style={[
                styles.badge,
                {
                  backgroundColor: theme.colors.error,
                },
              ]}
            >
              <Text style={[styles.badgeText, { color: theme.colors.onError }]}>
                {activeFiltersCount}
              </Text>
            </View>
          )}
        </Animated.View>
      </TouchableOpacity>

      <Portal>
        <Modal
          visible={visible}
          onDismiss={() => setVisible(false)}
          contentContainerStyle={[
            styles.modalContent,
            {
              backgroundColor: theme.colors.surface,
            },
          ]}
        >
          <ScrollView
            style={[
              styles.scrollView,
              screenHeight < 400 && { maxHeight: screenHeight - 80 },
            ]}
            showsVerticalScrollIndicator={false}
          >
            <Surface
              style={[
                styles.modalSurface,
                { backgroundColor: theme.colors.surface },
              ]}
              elevation={3}
            >
              <View
                style={[
                  styles.modalHeader,
                  { backgroundColor: theme.colors.primaryContainer },
                ]}
              >
                <View style={styles.headerContent}>
                  <Icon
                    name="tune-variant"
                    size={24}
                    color={theme.colors.onPrimaryContainer}
                  />
                  <View style={styles.headerTextContainer}>
                    <Text
                      variant="titleMedium"
                      style={[
                        styles.modalTitle,
                        { color: theme.colors.onPrimaryContainer },
                      ]}
                    >
                      Filtros de visualizacin
                    </Text>
                  </View>
                </View>
                <TouchableOpacity
                  onPress={() => setVisible(false)}
                  style={styles.closeButton}
                >
                  <Icon
                    name="close"
                    size={22}
                    color={theme.colors.onPrimaryContainer}
                  />
                </TouchableOpacity>
              </View>

              <View style={styles.filtersList}>
                {/* Tipo de orden */}
                <View style={styles.sectionHeader}>
                  <Text variant="titleMedium" style={styles.sectionTitle}>
                    Tipo de orden
                  </Text>
                </View>
                <View style={styles.orderTypeContainer}>
                  {[
                    { value: undefined, label: 'Todos', icon: 'check-all' },
                    {
                      value: OrderTypeEnum.DINE_IN,
                      label: 'Mesa',
                      icon: 'table',
                    },
                    {
                      value: OrderTypeEnum.TAKE_AWAY,
                      label: 'Llevar',
                      icon: 'bag-personal',
                    },
                    {
                      value: OrderTypeEnum.DELIVERY,
                      label: 'Domicilio',
                      icon: 'truck-delivery',
                    },
                  ].map((option) => {
                    const isSelected = filters.orderType === option.value;
                    return (
                      <TouchableOpacity
                        key={option.label}
                        style={[
                          styles.orderTypeButton,
                          isSelected && {
                            backgroundColor: theme.colors.primaryContainer,
                            borderColor: theme.colors.primary,
                          },
                          !isSelected && styles.orderTypeButtonInactive,
                        ]}
                        onPress={() =>
                          setFilters({ ...filters, orderType: option.value })
                        }
                        activeOpacity={0.8}
                      >
                        <Icon
                          name={option.icon as any}
                          size={20}
                          color={
                            isSelected
                              ? theme.colors.onPrimaryContainer
                              : theme.colors.onSurfaceVariant
                          }
                        />
                        <Text
                          variant="labelMedium"
                          style={[
                            styles.orderTypeLabel,
                            isSelected
                              ? styles.orderTypeLabelSelected
                              : styles.orderTypeLabelUnselected,
                          ]}
                        >
                          {option.label}
                        </Text>
                      </TouchableOpacity>
                    );
                  })}
                </View>

                <View
                  style={[
                    styles.divider,
                    { backgroundColor: theme.colors.outlineVariant },
                  ]}
                />

                {/* Otros filtros */}
                <View style={styles.sectionHeader}>
                  <Text variant="titleMedium" style={styles.sectionTitle}>
                    Opciones de visualizacin
                  </Text>
                </View>
                <TouchableOpacity
                  onPress={() => handleToggleFilter('showPrepared')}
                  activeOpacity={0.7}
                >
                  <Surface
                    style={[
                      styles.filterItem,
                      filters.showPrepared && {
                        backgroundColor: theme.colors.primaryContainer,
                        borderColor: theme.colors.primary,
                      },
                    ]}
                    elevation={1}
                  >
                    <View style={styles.filterItemContent}>
                      <View
                        style={[
                          styles.iconContainer,
                          {
                            backgroundColor: filters.showPrepared
                              ? theme.colors.primary
                              : theme.colors.surfaceVariant,
                          },
                        ]}
                      >
                        <Icon
                          name="check-circle-outline"
                          size={22}
                          color={
                            filters.showPrepared
                              ? theme.colors.onPrimary
                              : theme.colors.onSurfaceVariant
                          }
                        />
                      </View>
                      <View style={styles.filterTextContent}>
                        <Text
                          variant="titleSmall"
                          style={styles.filterItemTitle}
                        >
                          Mostrar listas
                        </Text>
                        <Text
                          variant="bodySmall"
                          style={styles.filterItemDescription}
                        >
                          Muestra solo las rdenes listas
                        </Text>
                      </View>
                      <Switch
                        value={filters.showPrepared}
                        onValueChange={() => handleToggleFilter('showPrepared')}
                        color={theme.colors.primary}
                      />
                    </View>
                  </Surface>
                </TouchableOpacity>

                <TouchableOpacity
                  onPress={() => handleToggleFilter('showAllProducts')}
                  activeOpacity={0.7}
                >
                  <Surface
                    style={[
                      styles.filterItem,
                      filters.showAllProducts && {
                        backgroundColor: theme.colors.primaryContainer,
                        borderColor: theme.colors.primary,
                      },
                    ]}
                    elevation={1}
                  >
                    <View style={styles.filterItemContent}>
                      <View
                        style={[
                          styles.iconContainer,
                          {
                            backgroundColor: filters.showAllProducts
                              ? theme.colors.primary
                              : theme.colors.surfaceVariant,
                          },
                        ]}
                      >
                        <Icon
                          name="eye-outline"
                          size={22}
                          color={
                            filters.showAllProducts
                              ? theme.colors.onPrimary
                              : theme.colors.onSurfaceVariant
                          }
                        />
                      </View>
                      <View style={styles.filterTextContent}>
                        <Text
                          variant="titleSmall"
                          style={styles.filterItemTitle}
                        >
                          Ver todos los productos
                        </Text>
                        <Text
                          variant="bodySmall"
                          style={styles.filterItemDescription}
                        >
                          Muestra productos de todas las rdenes
                        </Text>
                      </View>
                      <Switch
                        value={filters.showAllProducts}
                        onValueChange={() =>
                          handleToggleFilter('showAllProducts')
                        }
                        color={theme.colors.primary}
                      />
                    </View>
                  </Surface>
                </TouchableOpacity>

                <TouchableOpacity
                  onPress={() => handleToggleFilter('ungroupProducts')}
                  activeOpacity={0.7}
                >
                  <Surface
                    style={[
                      styles.filterItem,
                      filters.ungroupProducts && {
                        backgroundColor: theme.colors.primaryContainer,
                        borderColor: theme.colors.primary,
                      },
                    ]}
                    elevation={1}
                  >
                    <View style={styles.filterItemContent}>
                      <View
                        style={[
                          styles.iconContainer,
                          {
                            backgroundColor: filters.ungroupProducts
                              ? theme.colors.primary
                              : theme.colors.surfaceVariant,
                          },
                        ]}
                      >
                        <Icon
                          name="ungroup"
                          size={22}
                          color={
                            filters.ungroupProducts
                              ? theme.colors.onPrimary
                              : theme.colors.onSurfaceVariant
                          }
                        />
                      </View>
                      <View style={styles.filterTextContent}>
                        <Text
                          variant="titleSmall"
                          style={styles.filterItemTitle}
                        >
                          Desagrupar productos
                        </Text>
                        <Text
                          variant="bodySmall"
                          style={styles.filterItemDescription}
                        >
                          Muestra cada producto individualmente
                        </Text>
                      </View>
                      <Switch
                        value={filters.ungroupProducts}
                        onValueChange={() =>
                          handleToggleFilter('ungroupProducts')
                        }
                        color={theme.colors.primary}
                      />
                    </View>
                  </Surface>
                </TouchableOpacity>
              </View>
            </Surface>
          </ScrollView>
        </Modal>
      </Portal>
    </>
  );
};

const createStyles = (screenHeight: number, theme: any) =>
  StyleSheet.create({
    buttonContainer: {
      marginRight: 12,
    },
    filterButton: {
      width: 44,
      height: 44,
      borderRadius: 22,
      justifyContent: 'center',
      alignItems: 'center',
      elevation: 3,
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 2,
      },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
    },
    filterButtonActive: {
      backgroundColor: theme.colors.primaryContainer,
    },
    filterButtonInactive: {
      backgroundColor: 'rgba(255,255,255,0.2)',
    },
    badge: {
      position: 'absolute',
      top: -4,
      right: -4,
      width: 20,
      height: 20,
      borderRadius: 10,
      justifyContent: 'center',
      alignItems: 'center',
      elevation: 4,
    },
    badgeText: {
      fontSize: 11,
      fontWeight: 'bold',
    },
    modalContent: {
      margin: screenHeight < 400 ? 10 : 20,
      maxWidth: screenHeight < 400 ? '90%' : 380,
      maxHeight: screenHeight < 400 ? screenHeight - 60 : undefined,
      alignSelf: 'center',
      width: '90%',
      borderRadius: 20,
      overflow: 'hidden',
    },
    modalSurface: {
      borderRadius: 20,
      overflow: 'hidden',
      maxHeight: screenHeight < 400 ? screenHeight - 60 : undefined,
    },
    modalHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      padding: screenHeight < 400 ? 12 : 16,
      paddingBottom: screenHeight < 400 ? 8 : 12,
      marginBottom: 4,
    },
    headerContent: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
    },
    headerTextContainer: {
      marginLeft: 10,
      flex: 1,
    },
    modalTitle: {
      fontWeight: '700',
    },
    closeButton: {
      width: 36,
      height: 36,
      borderRadius: 18,
      justifyContent: 'center',
      alignItems: 'center',
      marginLeft: 8,
    },
    filtersList: {
      padding: screenHeight < 400 ? 8 : 12,
      paddingTop: screenHeight < 400 ? 4 : 8,
      gap: screenHeight < 400 ? 6 : 10,
    },
    filterItem: {
      borderRadius: 12,
      borderWidth: 1,
      borderColor: 'transparent',
      overflow: 'hidden',
    },
    filterItemContent: {
      flexDirection: 'row',
      alignItems: 'center',
      padding: screenHeight < 400 ? 8 : 12,
      gap: screenHeight < 400 ? 8 : 10,
    },
    iconContainer: {
      width: screenHeight < 400 ? 32 : 40,
      height: screenHeight < 400 ? 32 : 40,
      borderRadius: screenHeight < 400 ? 16 : 20,
      justifyContent: 'center',
      alignItems: 'center',
    },
    filterTextContent: {
      flex: 1,
      gap: 2,
    },
    sectionHeader: {
      marginBottom: screenHeight < 400 ? 8 : 12,
      paddingHorizontal: 4,
    },
    orderTypeContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      marginBottom: 16,
      gap: 8,
    },
    orderTypeButton: {
      flex: 1,
      alignItems: 'center',
      justifyContent: 'center',
      paddingVertical: screenHeight < 400 ? 8 : 12,
      paddingHorizontal: screenHeight < 400 ? 4 : 8,
      borderRadius: 12,
      borderWidth: 1.5,
    },
    divider: {
      height: 1,
      marginVertical: screenHeight < 400 ? 8 : 16,
      marginHorizontal: screenHeight < 400 ? -8 : -12,
    },
    scrollView: {
      flex: 1,
    },
    sectionTitle: {
      color: theme.colors.onSurface,
      fontWeight: '600',
    },
    orderTypeLabel: {
      marginTop: 4,
    },
    orderTypeButtonInactive: {
      backgroundColor: theme.colors.surfaceVariant,
      borderColor: 'transparent',
    },
    orderTypeLabelSelected: {
      color: theme.colors.onPrimaryContainer,
      fontWeight: '700',
    },
    orderTypeLabelUnselected: {
      color: theme.colors.onSurfaceVariant,
      fontWeight: '500',
    },
    filterItemTitle: {
      color: theme.colors.onSurface,
      fontWeight: '600',
    },
    filterItemDescription: {
      color: theme.colors.onSurfaceVariant,
    },
  });

================
File: app/src/modules/kitchen/hooks/useKitchenSnackbar.ts
================
import { useSnackbar } from '@/hooks/useSnackbar';

export function useKitchenSnackbar() {
  const { showSnackbar } = useSnackbar();

  const showError = (message: string) => {
    // Mostrar errores de forma ms discreta con duracin ms corta
    showSnackbar(message, 'error', 2000); // 2 segundos en lugar del default
  };

  return {
    showError,
  };
}

================
File: app/src/modules/menu/components/VariantFormModal.tsx
================
import React, { useEffect, useMemo, useState } from 'react';
import { View, StyleSheet } from 'react-native';
import {
  Portal,
  Modal,
  Card,
  TextInput,
  Button,
  Switch,
  Text,
  HelperText,
} from 'react-native-paper';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { ProductVariant } from '../schema/products.schema';
import { z } from 'zod';
import { useAppTheme } from '@/app/styles/theme';

const variantFormSchema = z.object({
  id: z.string().optional(),
  name: z.string().min(1, 'El nombre es requerido'),
  price: z.coerce
    .number({
      invalid_type_error: 'El precio debe ser un nmero',
      required_error: 'El precio es requerido',
    })
    .positive('El precio debe ser mayor a 0'),
  isActive: z.boolean(),
  sortOrder: z.number().optional().default(0),
});

type VariantFormData = z.infer<typeof variantFormSchema>;

interface VariantFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSubmit: (data: ProductVariant) => void;
  initialData?: Partial<ProductVariant>;
}

function VariantFormModal({
  visible,
  onDismiss,
  onSubmit,
  initialData,
}: VariantFormModalProps): React.ReactElement {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);
  const isEditing = !!initialData?.name;
  const [priceInputValue, setPriceInputValue] = useState<string>('');

  const {
    control,
    handleSubmit,
    reset,
    watch,
    formState: { errors, isSubmitting },
  } = useForm<VariantFormData>({
    resolver: zodResolver(variantFormSchema),
    defaultValues: {
      name: initialData?.name ?? '',
      price: initialData?.price ?? 0,
      isActive: initialData?.isActive ?? true,
      sortOrder: initialData?.sortOrder ?? 0,
      id: initialData?.id,
    },
  });

  const priceValue = watch('price');

  useEffect(() => {
    if (visible) {
      reset({
        name: initialData?.name ?? '',
        price: initialData?.price ?? 0,
        isActive: initialData?.isActive ?? true,
        sortOrder: initialData?.sortOrder ?? 0,
        id: initialData?.id,
      });
    }
  }, [visible, initialData, reset]);

  useEffect(() => {
    setPriceInputValue(
      priceValue !== undefined && priceValue !== null ? String(priceValue) : '',
    );
  }, [priceValue]);

  const handleFormSubmit = (data: VariantFormData) => {
    const finalData: ProductVariant = {
      ...data,
      ...(initialData?.id && { id: initialData.id }),
    } as ProductVariant;
    onSubmit(finalData);
  };

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalContainer}
      >
        <Card style={styles.card}>
          <Card.Title
            title={isEditing ? 'Editar Variante' : 'Nueva Variante'}
          />
          <Card.Content style={styles.content}>
            <View style={styles.fieldContainer}>
              <Controller
                control={control}
                name="name"
                render={({ field: { onChange, onBlur, value } }) => (
                  <TextInput
                    label="Nombre Variante *"
                    value={value}
                    onChangeText={onChange}
                    onBlur={onBlur}
                    error={!!errors.name}
                    style={styles.input}
                    autoFocus={!isEditing}
                  />
                )}
              />
              {errors.name && (
                <HelperText type="error" visible={!!errors.name}>
                  {errors.name.message}
                </HelperText>
              )}
            </View>

            <View style={styles.fieldContainer}>
              <Controller
                control={control}
                name="price"
                render={({ field }) => (
                  <TextInput
                    label="Precio *"
                    value={priceInputValue}
                    onChangeText={(text) => {
                      const formattedText = text.replace(/,/g, '.');
                      if (/^(\d*\.?\d*)$/.test(formattedText)) {
                        setPriceInputValue(formattedText);
                        if (formattedText === '') {
                          field.onChange(undefined);
                        } else if (formattedText !== '.') {
                          const numericValue = parseFloat(formattedText);
                          if (!isNaN(numericValue)) {
                            field.onChange(numericValue);
                          }
                        }
                      }
                    }}
                    onBlur={field.onBlur}
                    error={!!errors.price}
                    style={styles.input}
                    keyboardType="decimal-pad"
                  />
                )}
              />
              {errors.price && (
                <HelperText type="error" visible={!!errors.price}>
                  {errors.price.message}
                </HelperText>
              )}
            </View>

            <View style={styles.fieldContainer}>
              <Controller
                control={control}
                name="sortOrder"
                render={({ field }) => (
                  <TextInput
                    mode="outlined"
                    label="Orden de visualizacin"
                    value={String(field.value || 0)}
                    onChangeText={(text) => {
                      const value = parseInt(text, 10);
                      field.onChange(isNaN(value) ? 0 : value);
                    }}
                    onBlur={field.onBlur}
                    error={!!errors.sortOrder}
                    style={styles.input}
                    keyboardType="numeric"
                  />
                )}
              />
              {errors.sortOrder && (
                <HelperText type="error" visible={!!errors.sortOrder}>
                  {errors.sortOrder.message}
                </HelperText>
              )}
            </View>

            <View style={[styles.fieldContainer, styles.switchContainer]}>
              <Text style={styles.label}>Variante Activa</Text>
              <Controller
                control={control}
                name="isActive"
                render={({ field: { onChange, value } }) => (
                  <Switch value={!!value} onValueChange={onChange} />
                )}
              />
            </View>
          </Card.Content>
          <Card.Actions style={styles.actions}>
            <Button onPress={onDismiss} disabled={isSubmitting}>
              Cancelar
            </Button>
            <Button
              mode="contained"
              onPress={handleSubmit(handleFormSubmit)}
              loading={isSubmitting}
              disabled={isSubmitting}
            >
              Guardar
            </Button>
          </Card.Actions>
        </Card>
      </Modal>
    </Portal>
  );
}

const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    modalContainer: {
      padding: theme.spacing.l, // Ms padding exterior
    },
    card: {
      backgroundColor: theme.colors.inverseOnSurface,
      borderRadius: theme.roundness * 3, // Un poco ms redondeado
    },
    content: {
      paddingHorizontal: theme.spacing.m, // Padding horizontal para el contenido
      paddingBottom: theme.spacing.s, // Pequeo padding inferior antes de las acciones
    },
    fieldContainer: {
      marginBottom: theme.spacing.m, // Espacio uniforme debajo de cada campo/grupo
    },
    input: {},
    switchContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    label: {
      color: theme.colors.onSurfaceVariant,
    },
    actions: {
      justifyContent: 'flex-end',
      padding: theme.spacing.m, // Padding uniforme para las acciones
    },
  });

export default VariantFormModal;

================
File: app/src/modules/modifiers/schema/modifier.schema.ts
================
import { z } from 'zod';
import { modifierSchema as domainModifierSchema } from '../../../app/schemas/domain/modifier.schema';
import type { Modifier } from '../../../app/schemas/domain/modifier.schema';

const modifierBaseSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido').max(100),
  description: z.string().max(255).nullable().optional(),
  price: z.coerce.number().nullable().optional(),
  sortOrder: z.number().int(),
  isDefault: z.boolean(),
  isActive: z.boolean(),
});

export const createModifierSchema = modifierBaseSchema.extend({
  modifierGroupId: z.string().min(1, 'El ID del grupo no es vlido'),
  sortOrder: z.number().int().default(0),
  isDefault: z.boolean().default(false),
  isActive: z.boolean().default(true),
});
export type CreateModifierInput = z.infer<typeof createModifierSchema>;

export const updateModifierSchema = modifierBaseSchema.partial();
export type UpdateModifierInput = z.infer<typeof updateModifierSchema>;

export const modifierFormValidationSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido').max(100),
  description: z.string().max(255).nullable().optional(),
  price: z.preprocess(
    (val) => (val === '' || val === null ? undefined : val),
    z.coerce.number().nullable().optional(),
  ),
  sortOrder: z.preprocess(
    (val) => (val === '' || val === null ? 0 : val),
    z.coerce.number().int().optional().default(0),
  ),
  isDefault: z.boolean().optional().default(false),
  isActive: z.boolean().optional().default(true),
});

export const modifierApiSchema = domainModifierSchema.extend({
  createdAt: z.string().datetime().optional(),
  updatedAt: z.string().datetime().optional(),
  deletedAt: z.string().datetime().nullable().optional(),
});

export type { Modifier };

export type ModifierFormInputs = {
  name: string;
  description?: string | null;
  price?: number | null;
  sortOrder?: number;
  isDefault?: boolean;
  isActive?: boolean;
};

================
File: app/src/modules/modifiers/schema/modifierGroup.schema.ts
================
import { z } from 'zod';
import { modifierGroupSchema as domainModifierGroupSchema } from '../../../app/schemas/domain/modifier-group.schema';
import type { ModifierGroup } from '../../../app/schemas/domain/modifier-group.schema';

export const modifierGroupBaseSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().nullable().optional(),
  minSelections: z.number().int().min(0).optional(),
  maxSelections: z.number().int().min(1).optional(),
  isRequired: z.boolean().optional(),
  allowMultipleSelections: z.boolean().optional(),
  isActive: z.boolean().optional(),
  sortOrder: z.number().optional().default(0),
});

export const modifierGroupFormValidationSchema =
  modifierGroupBaseSchema.superRefine((data, ctx) => {
    if (data.allowMultipleSelections) {
      if (data.maxSelections === undefined || data.maxSelections === null) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          path: ['maxSelections'],
          message:
            'Mx. selecciones es requerido si se permiten mltiples selecciones.',
        });
      } else {
        if (data.maxSelections <= 1) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            path: ['maxSelections'],
            message:
              'Mx. selecciones debe ser mayor que 1 si se permiten mltiples selecciones.',
          });
        }

        const min = data.minSelections ?? 0;
        if (data.maxSelections > 1 && min > data.maxSelections) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            path: ['minSelections'],
            message:
              'Mn. selecciones no puede ser mayor que Mx. selecciones.',
          });
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            path: ['maxSelections'],
            message:
              'Mx. selecciones no puede ser menor que Mn. selecciones.',
          });
        }
      }
    }
  });

export type ModifierGroupFormInputs = z.infer<
  typeof modifierGroupFormValidationSchema
>;

export const createModifierGroupSchema = modifierGroupBaseSchema.transform(
  (data) => ({
    ...data,
    minSelections: data.minSelections ?? 0,
    isRequired: data.isRequired ?? false,
    allowMultipleSelections: data.allowMultipleSelections ?? false,
    isActive: data.isActive ?? true,
    sortOrder: data.sortOrder ?? 0,
    maxSelections: data.allowMultipleSelections ? (data.maxSelections ?? 1) : 1,
  }),
);

export type CreateModifierGroupInput = z.infer<
  typeof createModifierGroupSchema
>;

export const updateModifierGroupSchema = modifierGroupBaseSchema.partial();

export type UpdateModifierGroupInput = z.infer<
  typeof updateModifierGroupSchema
>;

export const modifierGroupApiSchema = domainModifierGroupSchema.extend({
  id: z.string(),
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
  deletedAt: z.string().datetime().nullable().optional(),
  productModifiers: z.array(z.any()).optional(),
  products: z.array(z.any()).optional(),
});

export type { ModifierGroup };

export const modifierGroupSchema = modifierGroupFormValidationSchema;

================
File: app/src/modules/orderFinalization/hooks/useOrderFinalizationQueries.ts
================
import { useQuery } from '@tanstack/react-query';
import { orderFinalizationService } from '../services/orderFinalizationService';

export const useOrdersForFinalizationList = () => {
  return useQuery({
    queryKey: ['orders', 'for-finalization-list'],
    queryFn: orderFinalizationService.getOrdersForFinalizationList,
    refetchInterval: 10000,
    refetchIntervalInBackground: false,
    refetchOnWindowFocus: true,
    refetchOnMount: true,
    staleTime: 5000,
    placeholderData: (previousData) => previousData,
    notifyOnChangeProps: ['data', 'error'],
  });
};

export const useOrderForFinalizationDetail = (orderId: string | null) => {
  return useQuery({
    queryKey: ['orders', 'for-finalization-detail', orderId],
    queryFn: () =>
      orderId
        ? orderFinalizationService.getOrderForFinalizationDetail(orderId)
        : null,
    enabled: !!orderId,
    staleTime: 30000,
  });
};

================
File: app/src/modules/orderFinalization/navigation/OrderFinalizationStackNavigator.tsx
================
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { OrderFinalizationScreen } from '../screens/OrderFinalizationScreen';
import { OrderFinalizationStackParamList } from './types';

const Stack = createNativeStackNavigator<OrderFinalizationStackParamList>();

export const OrderFinalizationStackNavigator = () => {
  return (
    <Stack.Navigator
      screenOptions={{
        headerShown: false,
      }}
    >
      <Stack.Screen
        name="OrderFinalizationScreen"
        component={OrderFinalizationScreen}
        options={{ headerShown: false }}
      />
    </Stack.Navigator>
  );
};

================
File: app/src/modules/orders/components/AdjustmentFormModal.tsx
================
import React, { useState, useEffect } from 'react';
import { View, StyleSheet, Platform } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  TextInput,
  HelperText,
  Chip,
  IconButton,
} from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import type {
  OrderAdjustment,
  AdjustmentFormData,
} from '../schema/adjustments.schema';

interface AdjustmentFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSave: (adjustment: OrderAdjustment) => void;
  adjustment?: OrderAdjustment | null;
  orderSubtotal: number;
}

export const AdjustmentFormModal: React.FC<AdjustmentFormModalProps> = ({
  visible,
  onDismiss,
  onSave,
  adjustment,
  orderSubtotal,
}) => {
  const theme = useAppTheme();

  // Estado del formulario
  const [formData, setFormData] = useState<AdjustmentFormData>({
    name: '',
    isPercentage: true,
    value: 0,
    amount: 0,
  });

  // Estados separados para los campos de texto
  const [percentageText, setPercentageText] = useState('');
  const [amountText, setAmountText] = useState('');
  const [isDiscount, setIsDiscount] = useState(false);
  const [nameWasEdited, setNameWasEdited] = useState(false);

  const [errors, setErrors] = useState<{
    name?: string;
    value?: string;
    amount?: string;
  }>({});

  // Inicializar formulario cuando se abre o cambia el ajuste
  useEffect(() => {
    if (visible) {
      if (adjustment) {
        setFormData({
          name: adjustment.name,
          isPercentage: adjustment.isPercentage,
          value: adjustment.value || 0,
          amount: adjustment.amount || 0,
        });
        setPercentageText(Math.abs(adjustment.value || 0).toString());
        setAmountText(Math.abs(adjustment.amount || 0).toString());
        setIsDiscount((adjustment.value || adjustment.amount || 0) < 0);
        setNameWasEdited(true); // Si es edicin, asumimos que el nombre fue editado
      } else {
        setFormData({
          name: 'Cargo adicional', // Por defecto cargo
          isPercentage: true,
          value: 0,
          amount: 0,
        });
        setPercentageText('');
        setAmountText('');
        setIsDiscount(false);
        setNameWasEdited(false);
      }
      setErrors({});
    }
  }, [visible, adjustment]);

  // Calcular el monto cuando cambia el valor o tipo
  useEffect(() => {
    if (formData.isPercentage && formData.value !== undefined) {
      const calculatedAmount = (orderSubtotal * formData.value) / 100;
      setFormData((prev) => ({ ...prev, amount: calculatedAmount }));
    }
  }, [formData.isPercentage, formData.value, orderSubtotal]);

  const handleTypeChange = (isPercentage: boolean) => {
    setFormData((prev) => ({
      ...prev,
      isPercentage,
      value: isPercentage ? 0 : undefined,
      amount: isPercentage ? 0 : prev.amount,
    }));
    if (isPercentage) {
      setPercentageText('');
    } else {
      setAmountText('');
    }
  };

  const validateForm = (): boolean => {
    const newErrors: typeof errors = {};

    if (!formData.name.trim()) {
      newErrors.name = 'El nombre es requerido';
    }

    if (formData.isPercentage) {
      if (formData.value === undefined || formData.value === null) {
        newErrors.value = 'El porcentaje es requerido';
      } else if (formData.value === 0) {
        newErrors.value = 'El porcentaje no puede ser 0';
      } else if (formData.value < -100 || formData.value > 100) {
        newErrors.value = 'El porcentaje debe estar entre -100 y 100';
      }
    } else {
      if (formData.amount === undefined || formData.amount === null) {
        newErrors.amount = 'El monto es requerido';
      } else if (formData.amount === 0) {
        newErrors.amount = 'El monto no puede ser 0';
      }
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSave = () => {
    if (!validateForm()) return;

    const adjustmentData: OrderAdjustment = {
      id: adjustment?.id || undefined,
      name: formData.name.trim(),
      isPercentage: formData.isPercentage,
      value: formData.isPercentage ? formData.value : undefined,
      amount: formData.amount,
      isNew: !adjustment?.id,
    };

    onSave(adjustmentData);
    onDismiss();
  };

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={[
          styles.modal,
          { backgroundColor: theme.colors.surface },
        ]}
      >
        {/* Header simplificado */}
        <View
          style={[styles.header, { backgroundColor: theme.colors.primary }]}
        >
          <Text
            variant="titleLarge"
            style={[styles.title, { color: theme.colors.onPrimary }]}
          >
            {adjustment ? 'Editar Ajuste' : 'Nuevo Ajuste'}
          </Text>
          <IconButton
            icon="close"
            size={20}
            onPress={onDismiss}
            style={styles.closeButton}
            iconColor={theme.colors.onPrimary}
          />
        </View>

        {/* Contenido */}
        <View style={styles.content}>
          {/* Nombre del ajuste */}
          <TextInput
            label="Nombre"
            value={formData.name}
            onChangeText={(text) => {
              setFormData((prev) => ({ ...prev, name: text }));
              // Detectar si el usuario edit manualmente el nombre
              setNameWasEdited(
                text !== 'Descuento' && text !== 'Cargo adicional',
              );
            }}
            mode="outlined"
            error={!!errors.name}
            placeholder="Ej: Descuento especial"
            style={styles.input}
          />
          {errors.name && (
            <HelperText type="error" visible={true}>
              {errors.name}
            </HelperText>
          )}

          {/* Tipo de ajuste con chips */}
          <View style={styles.typeContainer}>
            <Text
              variant="labelLarge"
              style={[styles.label, { color: theme.colors.onSurface }]}
            >
              Tipo de ajuste
            </Text>
            <View style={styles.chipGroup}>
              <Chip
                mode={formData.isPercentage ? 'flat' : 'outlined'}
                onPress={() => handleTypeChange(true)}
                selected={formData.isPercentage}
                style={[
                  styles.chip,
                  formData.isPercentage && {
                    backgroundColor: theme.colors.primaryContainer,
                  },
                ]}
                textStyle={
                  formData.isPercentage && {
                    color: theme.colors.onPrimaryContainer,
                  }
                }
              >
                Porcentaje
              </Chip>
              <Chip
                mode={!formData.isPercentage ? 'flat' : 'outlined'}
                onPress={() => handleTypeChange(false)}
                selected={!formData.isPercentage}
                style={[
                  styles.chip,
                  !formData.isPercentage && {
                    backgroundColor: theme.colors.primaryContainer,
                  },
                ]}
                textStyle={
                  !formData.isPercentage && {
                    color: theme.colors.onPrimaryContainer,
                  }
                }
              >
                Monto fijo
              </Chip>
            </View>
          </View>

          {/* Tipo de operacin (descuento o cargo) */}
          <View style={styles.operationContainer}>
            <Text
              variant="labelLarge"
              style={[styles.label, { color: theme.colors.onSurface }]}
            >
              Tipo de operacin
            </Text>
            <View style={styles.operationButtons}>
              <Button
                mode={isDiscount ? 'contained' : 'outlined'}
                onPress={() => {
                  setIsDiscount(true);
                  // Siempre actualizar el nombre si no fue editado manualmente
                  if (!nameWasEdited) {
                    setFormData((prev) => ({ ...prev, name: 'Descuento' }));
                  }
                  if (formData.isPercentage) {
                    const absValue = Math.abs(parseFloat(percentageText) || 0);
                    setFormData((prev) => ({ ...prev, value: -absValue }));
                  } else {
                    const absValue = Math.abs(parseFloat(amountText) || 0);
                    setFormData((prev) => ({ ...prev, amount: -absValue }));
                  }
                }}
                style={[
                  styles.operationButton,
                  isDiscount && {
                    backgroundColor: theme.colors.errorContainer,
                    borderColor: theme.colors.error,
                  },
                ]}
                labelStyle={{
                  color: isDiscount
                    ? theme.colors.onErrorContainer
                    : theme.colors.error,
                }}
                icon="minus"
              >
                Descuento
              </Button>
              <Button
                mode={!isDiscount ? 'contained' : 'outlined'}
                onPress={() => {
                  setIsDiscount(false);
                  // Siempre actualizar el nombre si no fue editado manualmente
                  if (!nameWasEdited) {
                    setFormData((prev) => ({
                      ...prev,
                      name: 'Cargo adicional',
                    }));
                  }
                  if (formData.isPercentage) {
                    const absValue = Math.abs(parseFloat(percentageText) || 0);
                    setFormData((prev) => ({ ...prev, value: absValue }));
                  } else {
                    const absValue = Math.abs(parseFloat(amountText) || 0);
                    setFormData((prev) => ({ ...prev, amount: absValue }));
                  }
                }}
                style={[
                  styles.operationButton,
                  !isDiscount && {
                    backgroundColor: theme.colors.primaryContainer,
                    borderColor: theme.colors.primary,
                  },
                ]}
                labelStyle={{
                  color: !isDiscount
                    ? theme.colors.onPrimaryContainer
                    : theme.colors.primary,
                }}
                icon="plus"
              >
                Cargo
              </Button>
            </View>
          </View>

          {/* Campo de valor */}
          {formData.isPercentage ? (
            <TextInput
              label="Porcentaje"
              value={percentageText}
              onChangeText={(text) => {
                // Solo permitir nmeros positivos
                const regex = /^\d*\.?\d*$/;
                if (regex.test(text) || text === '') {
                  setPercentageText(text);
                  const value = parseFloat(text) || 0;
                  setFormData((prev) => ({
                    ...prev,
                    value: isDiscount ? -value : value,
                  }));
                }
              }}
              mode="outlined"
              keyboardType="numeric"
              error={!!errors.value}
              right={<TextInput.Affix text="%" />}
              style={styles.input}
            />
          ) : (
            <TextInput
              label="Monto"
              value={amountText}
              onChangeText={(text) => {
                // Solo permitir nmeros positivos
                const regex = /^\d*\.?\d*$/;
                if (regex.test(text) || text === '') {
                  setAmountText(text);
                  const amount = parseFloat(text) || 0;
                  setFormData((prev) => ({
                    ...prev,
                    amount: isDiscount ? -amount : amount,
                  }));
                }
              }}
              mode="outlined"
              keyboardType="numeric"
              error={!!errors.amount}
              left={<TextInput.Affix text="$" />}
              style={styles.input}
            />
          )}
          {(errors.value || errors.amount) && (
            <HelperText type="error" visible={true}>
              {errors.value || errors.amount}
            </HelperText>
          )}
        </View>

        {/* Botones de accin */}
        <View
          style={[
            styles.actions,
            { borderTopColor: theme.colors.outlineVariant },
          ]}
        >
          <Button
            mode="outlined"
            onPress={onDismiss}
            style={[
              styles.actionButton,
              {
                borderColor: theme.colors.outline,
                backgroundColor: theme.colors.secondaryContainer,
              },
            ]}
            textColor={theme.colors.onSecondaryContainer}
          >
            Cancelar
          </Button>
          <Button
            mode="contained"
            onPress={handleSave}
            style={[styles.actionButton, styles.saveButton]}
            buttonColor={theme.colors.primary}
          >
            {adjustment ? 'Actualizar' : 'Guardar'}
          </Button>
        </View>
      </Modal>
    </Portal>
  );
};

const styles = StyleSheet.create({
  modal: {
    borderRadius: 16,
    margin: 20,
    maxWidth: 400,
    width: '90%',
    maxHeight: '80%',
    alignSelf: 'center',
    elevation: 5,
    ...Platform.select({
      web: {
        boxShadow: '0px 2px 3.84px rgba(0, 0, 0, 0.25)',
      },
      default: {
        shadowColor: '#000',
        shadowOffset: {
          width: 0,
          height: 2,
        },
        shadowOpacity: 0.25,
        shadowRadius: 3.84,
      },
    }),
    overflow: 'hidden',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingVertical: 12,
    minHeight: 48,
  },
  title: {
    flex: 1,
    fontWeight: '500',
  },
  closeButton: {
    margin: -4,
  },
  content: {
    paddingHorizontal: 20,
    paddingTop: 20,
    paddingBottom: 16,
  },
  input: {
    marginBottom: 16,
  },
  typeContainer: {
    marginBottom: 16,
  },
  label: {
    marginBottom: 8,
    fontWeight: '500',
  },
  chipGroup: {
    flexDirection: 'row',
    gap: 12,
  },
  chip: {
    flex: 1,
  },
  operationContainer: {
    marginBottom: 16,
  },
  operationButtons: {
    flexDirection: 'row',
    gap: 12,
    marginTop: 8,
  },
  operationButton: {
    flex: 1,
  },
  actions: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingVertical: 16,
    borderTopWidth: 1,
    gap: 12,
  },
  actionButton: {
    minWidth: 100,
  },
  saveButton: {
    marginLeft: 4,
  },
});

================
File: app/src/modules/orders/components/order-cart/OrderSummary.tsx
================
import React, { useMemo } from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, Button, Divider } from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';

interface OrderSummaryProps {
  subtotal: number;
  adjustmentsTotal: number;
  total: number;
  onConfirm: () => void;
  onCancel?: () => void;
  confirmText?: string;
  cancelText?: string;
  isProcessing?: boolean;
  disabled?: boolean;
  showCancelButton?: boolean;
}

export const OrderSummary: React.FC<OrderSummaryProps> = ({
  subtotal,
  adjustmentsTotal,
  total,
  onConfirm,
  onCancel,
  confirmText = 'Confirmar Orden',
  cancelText = 'Cancelar',
  isProcessing = false,
  disabled = false,
  showCancelButton = false,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);

  return (
    <View style={styles.container}>
      <Divider style={styles.divider} />

      <View style={styles.summarySection}>
        <View style={styles.summaryRow}>
          <Text style={styles.summaryLabel}>Subtotal:</Text>
          <Text style={styles.summaryValue}>${subtotal.toFixed(2)}</Text>
        </View>

        {adjustmentsTotal > 0 && (
          <View style={styles.summaryRow}>
            <Text style={styles.summaryLabel}>Descuentos:</Text>
            <Text style={[styles.summaryValue, styles.discountText]}>
              -${adjustmentsTotal.toFixed(2)}
            </Text>
          </View>
        )}

        <Divider style={styles.totalDivider} />

        <View style={styles.summaryRow}>
          <Text style={styles.totalLabel}>Total:</Text>
          <Text style={styles.totalValue}>${total.toFixed(2)}</Text>
        </View>
      </View>

      <View style={styles.buttonContainer}>
        {showCancelButton && (
          <Button
            mode="outlined"
            onPress={onCancel}
            style={[styles.button, styles.cancelButton]}
            disabled={disabled || isProcessing}
          >
            {cancelText}
          </Button>
        )}

        <Button
          mode="contained"
          onPress={onConfirm}
          style={[styles.button, styles.confirmButton]}
          loading={isProcessing}
          disabled={disabled || isProcessing}
        >
          {confirmText}
        </Button>
      </View>
    </View>
  );
};

const createStyles = (theme: any) =>
  StyleSheet.create({
    container: {
      backgroundColor: theme.colors.surface,
      paddingVertical: theme.spacing.m,
    },
    divider: {
      marginBottom: theme.spacing.m,
    },
    summarySection: {
      paddingHorizontal: theme.spacing.m,
      marginBottom: theme.spacing.m,
    },
    summaryRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      marginBottom: theme.spacing.s,
    },
    summaryLabel: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    summaryValue: {
      fontSize: 14,
      color: theme.colors.onSurface,
      fontWeight: '500',
    },
    discountText: {
      color: theme.colors.primary,
    },
    totalDivider: {
      marginVertical: theme.spacing.s,
    },
    totalLabel: {
      fontSize: 18,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    totalValue: {
      fontSize: 20,
      fontWeight: 'bold',
      color: theme.colors.primary,
    },
    buttonContainer: {
      flexDirection: 'row',
      paddingHorizontal: theme.spacing.m,
      gap: theme.spacing.s,
    },
    button: {
      flex: 1,
    },
    cancelButton: {
      borderColor: theme.colors.outline,
    },
    confirmButton: {
      backgroundColor: theme.colors.primary,
    },
  });

================
File: app/src/modules/orders/components/order-creation/index.ts
================
export { CategoryGrid } from './CategoryGrid';
export { ShiftClosedView } from './ShiftClosedView';
export { CategoryQuickAccess } from './CategoryQuickAccess';

================
File: app/src/modules/orders/components/PrinterSelectionModal.tsx
================
import React, { useMemo } from 'react';
import { StyleSheet, FlatList, ListRenderItemInfo } from 'react-native';
import { Modal, Portal, List, Divider, Appbar } from 'react-native-paper';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { usePrintersQuery } from '../../printers/hooks/usePrintersQueries';
import type { ThermalPrinter } from '../../printers/schema/printer.schema';
import { useListState } from '../../../app/hooks/useListState';

interface PrinterSelectionModalProps {
  visible: boolean;
  onDismiss: () => void;
  onPrinterSelect: (printer: ThermalPrinter) => void;
  title?: string;
}

const PrinterSelectionModal: React.FC<PrinterSelectionModalProps> = ({
  visible,
  onDismiss,
  onPrinterSelect,
  title = 'Seleccionar Impresora',
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);

  const {
    data: printersResponse,
    isLoading,
    isError,
    error: _error,
    refetch: _refetch,
  } = usePrintersQuery(
    { isActive: true, limit: 100, page: 1 },
    { enabled: visible },
  );

  const printers = useMemo(
    () => printersResponse?.data ?? [],
    [printersResponse],
  );

  const renderPrinterItem = ({ item }: ListRenderItemInfo<ThermalPrinter>) => (
    <List.Item
      title={item.name}
      description={`Tipo: ${item.connectionType}${item.ipAddress ? ` - IP: ${item.ipAddress}` : ''}`}
      left={(props) => <List.Icon {...props} icon="printer" />}
      onPress={() => onPrinterSelect(item)}
      style={styles.listItem}
      titleStyle={styles.itemTitle}
      descriptionStyle={styles.itemDescription}
    />
  );

  const { ListEmptyComponent } = useListState({
    isLoading,
    isError,
    data: printers,
    emptyConfig: {
      title: 'No hay impresoras activas',
      message: 'No hay impresoras activas configuradas.',
      icon: 'printer-off',
    },
  });

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalContent}
      >
        <Appbar.Header style={styles.appBar} elevated>
          <Appbar.BackAction
            onPress={onDismiss}
            color={theme.colors.onSurface}
          />
          <Appbar.Content title={title} titleStyle={styles.appBarTitle} />
        </Appbar.Header>

        <FlatList
          data={printers}
          renderItem={renderPrinterItem}
          keyExtractor={(item: ThermalPrinter) => item.id}
          ItemSeparatorComponent={() => <Divider style={styles.divider} />}
          contentContainerStyle={styles.listContentContainer}
          ListEmptyComponent={ListEmptyComponent}
        />
      </Modal>
    </Portal>
  );
};

// --- Estilos ---
const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    modalContent: {
      backgroundColor: theme.colors.background,
      width: '90%',
      maxHeight: '70%',
      alignSelf: 'center',
      borderRadius: theme.roundness * 2,
      elevation: 5,
      overflow: 'hidden',
      display: 'flex',
      flexDirection: 'column',
    },
    appBar: {
      backgroundColor: theme.colors.elevation.level2,
    },
    appBarTitle: {
      ...theme.fonts.titleMedium,
      color: theme.colors.onSurface,
      fontWeight: 'bold',
    },
    listContentContainer: {
      paddingBottom: theme.spacing.m,
    },
    centeredView: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.l,
      minHeight: 150,
    },
    statusText: {
      marginTop: theme.spacing.m,
      fontSize: 16,
      textAlign: 'center',
      color: theme.colors.onSurfaceVariant,
    },
    errorText: {
      marginTop: theme.spacing.m,
      color: theme.colors.error,
      textAlign: 'center',
      marginBottom: theme.spacing.m,
    },
    listItem: {
      backgroundColor: theme.colors.surface,
      paddingHorizontal: theme.spacing.m,
    },
    itemTitle: {
      fontWeight: '500',
    },
    itemDescription: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    divider: {
      height: StyleSheet.hairlineWidth,
      backgroundColor: theme.colors.outlineVariant,
      marginHorizontal: theme.spacing.m,
    },
  });

export default PrinterSelectionModal;

================
File: app/src/modules/orders/components/ShiftActionModal.tsx
================
import React, { useState } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  TextInput,
  HelperText,
  Surface,
  Divider,
  Card,
} from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useAppTheme } from '@/app/styles/theme';
import { shiftsService, type Shift } from '@/services/shifts';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import SpeechRecognitionInput from '@/app/components/common/SpeechRecognitionInput';

type ShiftActionMode = 'open' | 'close';

interface ShiftActionModalProps {
  visible: boolean;
  onDismiss: () => void;
  mode: ShiftActionMode;
  shift?: Shift | null;
  onShiftOpened?: () => void;
  onShiftClosed?: () => void;
}

export const ShiftActionModal: React.FC<ShiftActionModalProps> = ({
  visible,
  onDismiss,
  mode,
  shift,
  onShiftOpened,
  onShiftClosed,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const [cashAmount, setCashAmount] = useState('');
  const [notes, setNotes] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');

  const isOpenMode = mode === 'open';

  const handleCashAmountChange = (text: string) => {
    const cleaned = text.replace(/[^0-9.]/g, '');
    const parts = cleaned.split('.');
    if (parts.length > 2) return;

    if (parts[1] && parts[1].length > 2) {
      setCashAmount(parts[0] + '.' + parts[1].substring(0, 2));
    } else {
      setCashAmount(cleaned);
    }
  };

  const handleSubmit = async () => {
    if (!cashAmount) {
      setError(
        isOpenMode
          ? 'El monto inicial es requerido'
          : 'El efectivo final es requerido',
      );
      return;
    }

    const amount = parseFloat(cashAmount);
    if (isNaN(amount) || amount < 0) {
      setError('Ingresa un monto vlido');
      return;
    }

    setLoading(true);
    setError('');

    try {
      if (isOpenMode) {
        await shiftsService.openShift({
          initialCash: amount,
          notes: notes || undefined,
        });
        showSnackbar({
          message: 'Turno abierto exitosamente',
          type: 'success',
        });
        onShiftOpened?.();
      } else {
        await shiftsService.closeShift({
          finalCash: amount,
          closeNotes: notes || undefined,
        });
        showSnackbar({
          message: 'Turno cerrado exitosamente',
          type: 'success',
        });
        onShiftClosed?.();
      }

      setCashAmount('');
      setNotes('');
      onDismiss();
    } catch (error: any) {
      let errorMessage = isOpenMode
        ? 'Error al abrir el turno'
        : 'Error al cerrar el turno';

      if (error?.message) {
        errorMessage = error.message;
      } else if (error?.response?.data?.message) {
        errorMessage = error.response.data.message;
      } else if (typeof error === 'string') {
        errorMessage = error;
      }

      setError(errorMessage);
      showSnackbar({ message: errorMessage, type: 'error' });
    } finally {
      setLoading(false);
    }
  };

  const handleDismiss = () => {
    if (!loading) {
      setCashAmount('');
      setNotes('');
      setError('');
      onDismiss();
    }
  };

  const formatCurrency = (amount: number) => {
    return new Intl.NumberFormat('es-MX', {
      style: 'currency',
      currency: 'MXN',
    }).format(amount);
  };

  const formatTime = (dateString: string) => {
    return format(new Date(dateString), 'HH:mm', { locale: es });
  };

  const calculateDifference = () => {
    if (isOpenMode || !cashAmount || !shift?.expectedCash) return null;
    const cash = parseFloat(cashAmount);
    if (isNaN(cash)) return null;
    return cash - shift.expectedCash;
  };

  const difference = calculateDifference();
  const today = new Date();
  const todayFormatted = format(today, "EEEE, d 'de' MMMM 'de' yyyy", {
    locale: es,
  });

  const config = {
    open: {
      title: 'Apertura de Turno',
      icon: 'store-check',
      iconColor: theme.colors.primary,
      buttonText: 'Abrir Turno',
      buttonIcon: 'play-circle',
      buttonColor: theme.colors.primary,
      cashLabel: 'Monto inicial en caja',
      notesLabel: 'Notas adicionales (opcional)',
      notesPlaceholder: 'Ej: Estado de la caja, observaciones...',
      infoText:
        'Registra el monto inicial para comenzar las operaciones del turno.',
    },
    close: {
      title: 'Cierre de Turno',
      icon: 'store-off',
      iconColor: '#FF5722',
      buttonText: 'Cerrar Turno',
      buttonIcon: 'stop-circle',
      buttonColor: '#FF5722',
      cashLabel: 'Efectivo final en caja',
      notesLabel: 'Notas de cierre (opcional)',
      notesPlaceholder: 'Ej: Observaciones del turno, incidencias...',
    },
  }[mode];

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={handleDismiss}
        contentContainerStyle={styles.modalContainer}
        dismissable={!loading}
      >
        <KeyboardAvoidingView
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={styles.keyboardAvoidingView}
        >
          <ScrollView
            contentContainerStyle={styles.scrollViewContent}
            keyboardShouldPersistTaps="handled"
            showsVerticalScrollIndicator={false}
          >
            <Surface style={styles.modal} elevation={3}>
              <View style={[styles.header, !isOpenMode && styles.closeHeader]}>
                <View
                  style={[
                    styles.iconContainer,
                    !isOpenMode && styles.closeIconContainer,
                  ]}
                >
                  <MaterialCommunityIcons
                    name={config.icon as any}
                    size={48}
                    color={config.iconColor}
                  />
                </View>
                <Text variant="headlineMedium" style={styles.title}>
                  {config.title}
                </Text>
                <Text variant="bodyLarge" style={styles.date}>
                  {todayFormatted}
                </Text>
              </View>

              <Divider style={styles.divider} />

              <View style={styles.content}>
                {isOpenMode && (
                  <View style={styles.infoCard}>
                    <MaterialCommunityIcons
                      name="information"
                      size={20}
                      color={theme.colors.primary}
                    />
                    <Text variant="bodyMedium" style={styles.infoText}>
                      {config.infoText}
                    </Text>
                  </View>
                )}

                {!isOpenMode && shift && (
                  <Card style={styles.summaryCard}>
                    <Card.Content>
                      <Text variant="titleMedium" style={styles.sectionTitle}>
                        Resumen del Turno #{shift.globalShiftNumber}
                      </Text>

                      <View style={styles.summaryRow}>
                        <Text variant="bodyMedium" style={styles.label}>
                          Abierto a las:
                        </Text>
                        <Text variant="bodyMedium" style={styles.value}>
                          {formatTime(shift.openedAt)}
                        </Text>
                      </View>

                      <View style={styles.summaryRow}>
                        <Text variant="bodyMedium" style={styles.label}>
                          Efectivo inicial:
                        </Text>
                        <Text variant="bodyMedium" style={styles.value}>
                          {formatCurrency(shift.initialCash)}
                        </Text>
                      </View>

                      {shift.totalSales !== null && (
                        <View style={styles.summaryRow}>
                          <Text variant="bodyMedium" style={styles.label}>
                            Ventas del turno:
                          </Text>
                          <Text
                            variant="bodyMedium"
                            style={[styles.value, styles.highlight]}
                          >
                            {formatCurrency(shift.totalSales)}
                          </Text>
                        </View>
                      )}

                      {shift.expectedCash !== null && (
                        <View style={styles.summaryRow}>
                          <Text variant="bodyMedium" style={styles.label}>
                            Efectivo esperado:
                          </Text>
                          <Text
                            variant="bodyMedium"
                            style={[styles.value, styles.highlight]}
                          >
                            {formatCurrency(shift.expectedCash)}
                          </Text>
                        </View>
                      )}
                    </Card.Content>
                  </Card>
                )}

                <View style={styles.inputSection}>
                  <Text variant="titleMedium" style={styles.sectionTitle}>
                    {isOpenMode
                      ? 'Informacin de Apertura'
                      : 'Informacin de Cierre'}
                  </Text>

                  <TextInput
                    label={config.cashLabel}
                    value={cashAmount}
                    onChangeText={handleCashAmountChange}
                    keyboardType="decimal-pad"
                    mode="outlined"
                    left={<TextInput.Affix text="$" />}
                    style={styles.input}
                    disabled={loading}
                    error={!!error}
                    placeholder="0.00"
                    outlineColor={
                      error ? theme.colors.error : theme.colors.outline
                    }
                    activeOutlineColor={
                      error ? theme.colors.error : theme.colors.primary
                    }
                  />

                  {!isOpenMode && difference !== null && (
                    <View
                      style={[
                        styles.differenceContainer,
                        difference < 0
                          ? styles.negativeDifference
                          : styles.positiveDifference,
                      ]}
                    >
                      <MaterialCommunityIcons
                        name={difference >= 0 ? 'trending-up' : 'trending-down'}
                        size={20}
                        color={difference >= 0 ? '#4CAF50' : '#FF5722'}
                      />
                      <Text
                        style={[
                          styles.differenceText,
                          difference >= 0
                            ? styles.positiveText
                            : styles.negativeText,
                        ]}
                      >
                        {difference >= 0 ? 'Sobrante: ' : 'Faltante: '}
                        {formatCurrency(Math.abs(difference))}
                      </Text>
                    </View>
                  )}

                  <HelperText
                    type="error"
                    visible={!!error}
                    style={styles.errorText}
                  >
                    {error}
                  </HelperText>

                  <SpeechRecognitionInput
                    key={`${mode}-notes-input`}
                    label={config.notesLabel}
                    value={notes}
                    onChangeText={setNotes}
                    multiline
                    speechLang="es-MX"
                    placeholder={config.notesPlaceholder}
                    autoCapitalize="sentences"
                    autoCorrect={false}
                    disabled={loading}
                  />
                </View>
              </View>

              <View style={styles.footer}>
                <Button
                  mode="text"
                  onPress={handleDismiss}
                  style={[styles.button, styles.cancelButton]}
                  labelStyle={styles.cancelButtonText}
                  disabled={loading}
                >
                  Cancelar
                </Button>
                <Button
                  mode="contained"
                  onPress={handleSubmit}
                  style={[
                    styles.button,
                    styles.confirmButton,
                    !isOpenMode && styles.closeConfirmButton,
                  ]}
                  contentStyle={styles.confirmButtonContent}
                  labelStyle={[
                    styles.confirmButtonText,
                    !isOpenMode && styles.closeConfirmButtonText,
                  ]}
                  loading={loading}
                  disabled={loading}
                  icon={config.buttonIcon}
                >
                  {config.buttonText}
                </Button>
              </View>
            </Surface>
          </ScrollView>
        </KeyboardAvoidingView>
      </Modal>
    </Portal>
  );
};

const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    modalContainer: {
      flex: 1,
    },
    scrollViewContent: {
      flexGrow: 1,
      justifyContent: 'center',
      paddingVertical: theme.spacing.xl,
      paddingHorizontal: theme.spacing.m,
    },
    modal: {
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness * 3,
      borderWidth: 2,
      borderColor: theme.colors.outline,
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 8,
      },
      shadowOpacity: 0.25,
      shadowRadius: 16,
      elevation: 8,
    },
    header: {
      alignItems: 'center',
      paddingTop: theme.spacing.xl,
      paddingHorizontal: theme.spacing.l,
      paddingBottom: theme.spacing.l,
      borderTopLeftRadius: theme.roundness * 3,
      borderTopRightRadius: theme.roundness * 3,
    },
    closeHeader: {
      backgroundColor: theme.colors.surfaceVariant,
    },
    iconContainer: {
      width: 80,
      height: 80,
      borderRadius: 40,
      backgroundColor: theme.colors.primaryContainer,
      justifyContent: 'center',
      alignItems: 'center',
      marginBottom: theme.spacing.m,
    },
    closeIconContainer: {
      width: 90,
      height: 90,
      borderRadius: 45,
      backgroundColor: theme.colors.surface,
      borderWidth: 3,
      borderColor: '#FF5722',
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 4,
      },
      shadowOpacity: 0.15,
      shadowRadius: 8,
      elevation: 4,
    },
    title: {
      color: theme.colors.onSurface,
      fontWeight: '700',
      textAlign: 'center',
      marginBottom: theme.spacing.xs,
    },
    date: {
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
      textTransform: 'capitalize',
    },
    divider: {
      backgroundColor: theme.colors.outlineVariant,
      height: 1,
    },
    content: {
      padding: theme.spacing.l,
    },
    infoCard: {
      flexDirection: 'row',
      backgroundColor: theme.colors.primaryContainer,
      padding: theme.spacing.m,
      borderRadius: theme.roundness,
      marginBottom: theme.spacing.l,
      gap: theme.spacing.s,
    },
    infoText: {
      flex: 1,
      color: theme.colors.onPrimaryContainer,
      lineHeight: 20,
    },
    summaryCard: {
      backgroundColor: theme.colors.surfaceVariant,
      borderWidth: 1,
      borderColor: theme.colors.outline,
      borderRadius: theme.roundness * 2,
      marginBottom: theme.spacing.l,
    },
    sectionTitle: {
      color: theme.colors.onSurface,
      fontWeight: '600',
      marginBottom: theme.spacing.m,
    },
    summaryRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.s,
    },
    label: {
      color: theme.colors.onSurfaceVariant,
      flex: 1,
    },
    value: {
      color: theme.colors.onSurface,
      fontWeight: '500',
      textAlign: 'right',
    },
    highlight: {
      color: theme.colors.primary,
      fontWeight: '600',
    },
    inputSection: {
      marginTop: theme.spacing.s,
    },
    input: {
      backgroundColor: theme.colors.surface,
      marginBottom: theme.spacing.s,
    },
    differenceContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      padding: theme.spacing.m,
      borderRadius: theme.roundness,
      marginBottom: theme.spacing.s,
      gap: theme.spacing.s,
    },
    positiveDifference: {
      backgroundColor: 'rgba(76, 175, 80, 0.1)',
      borderWidth: 1,
      borderColor: '#4CAF50',
    },
    negativeDifference: {
      backgroundColor: 'rgba(255, 87, 34, 0.1)',
      borderWidth: 1,
      borderColor: '#FF5722',
    },
    differenceText: {
      fontWeight: '600',
    },
    errorText: {
      marginTop: -theme.spacing.xs,
      marginBottom: theme.spacing.s,
    },
    footer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      padding: theme.spacing.l,
      paddingTop: theme.spacing.s,
      gap: theme.spacing.m,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
      borderBottomLeftRadius: theme.roundness * 3,
      borderBottomRightRadius: theme.roundness * 3,
    },
    button: {
      flex: 1,
    },
    cancelButton: {
      borderWidth: 2,
      borderColor: theme.colors.outline,
      borderRadius: theme.roundness * 2,
    },
    cancelButtonText: {
      color: theme.colors.onSurface,
      fontWeight: '600',
    },
    confirmButton: {
      backgroundColor: theme.colors.primary,
      borderWidth: 2,
      borderColor: theme.colors.primary,
      borderRadius: theme.roundness * 2,
    },
    closeConfirmButton: {
      backgroundColor: '#FF5722',
      borderColor: '#FF5722',
    },
    confirmButtonContent: {
      paddingVertical: theme.spacing.xs,
    },
    confirmButtonText: {
      color: theme.colors.onPrimary,
      fontWeight: '600',
    },
    closeConfirmButtonText: {
      color: '#FFFFFF',
    },
    keyboardAvoidingView: {
      flex: 1,
    },
    positiveText: {
      color: '#4CAF50',
    },
    negativeText: {
      color: '#FF5722',
    },
  });

================
File: app/src/modules/orders/hooks/order-creation/index.ts
================
export { useOrderNavigation } from './useOrderNavigation';
export { useProductSelection } from './useProductSelection';
export { useAudioOrder } from './useAudioOrder';
export { useOrderCreation } from './useOrderCreation';

================
File: app/src/modules/orders/schema/adjustments.schema.ts
================
import { z } from 'zod';

export const orderAdjustmentSchema = z.object({
  id: z.string().uuid().optional(),
  name: z.string().min(1, 'El nombre es requerido'),
  isPercentage: z.boolean(),
  value: z.number().min(0).max(100).optional(), // Porcentaje (0-100) si isPercentage es true
  amount: z.number().optional(), // Monto fijo si isPercentage es false (puede ser negativo para descuentos)
  // Para UI local
  isNew: z.boolean().optional(),
  isDeleted: z.boolean().optional(),
});

export type OrderAdjustment = z.infer<typeof orderAdjustmentSchema>;

export const adjustmentFormDataSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  isPercentage: z.boolean(),
  value: z.number().min(0).max(100).optional(),
  amount: z.number().optional(),
});

export type AdjustmentFormData = z.infer<typeof adjustmentFormDataSchema>;

================
File: app/src/modules/orders/schema/payment.schema.ts
================
import { z } from 'zod';

export const paymentMethodSchema = z.enum(['CASH', 'CARD', 'TRANSFER']);
export const paymentStatusSchema = z.enum([
  'PENDING',
  'COMPLETED',
  'FAILED',
  'REFUNDED',
  'CANCELLED',
]);

export type PaymentMethod = z.infer<typeof paymentMethodSchema>;
export type PaymentStatus = z.infer<typeof paymentStatusSchema>;

export const PaymentMethodEnum = paymentMethodSchema.enum;
export const PaymentStatusEnum = paymentStatusSchema.enum;

export const paymentSchema = z.object({
  id: z.string().uuid(),
  orderId: z.string().uuid(),
  paymentMethod: paymentMethodSchema,
  amount: z.number().positive(),
  paymentStatus: paymentStatusSchema,
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
  order: z
    .object({
      id: z.string().uuid(),
      shiftOrderNumber: z.number(),
      total: z.number(),
    })
    .optional(),
});

export type Payment = z.infer<typeof paymentSchema>;

export const createPaymentDtoSchema = z.object({
  orderId: z.string().uuid(),
  paymentMethod: paymentMethodSchema,
  amount: z.number().positive(),
});

export type CreatePaymentDto = z.infer<typeof createPaymentDtoSchema>;

export const updatePaymentDtoSchema = z.object({
  paymentMethod: paymentMethodSchema.optional(),
  amount: z.number().positive().optional(),
  paymentStatus: paymentStatusSchema.optional(),
});

export type UpdatePaymentDto = z.infer<typeof updatePaymentDtoSchema>;

================
File: app/src/modules/orders/schema/update-order.schema.ts
================
import { z } from 'zod';
import {
  orderTypeSchema,
  orderStatusSchema,
} from '@/app/schemas/domain/order.schema';
import { deliveryInfoSchema } from '@/app/schemas/domain/delivery-info.schema';

// Schema para modificadores de producto
export const productModifierDtoSchema = z.object({
  modifierId: z.string().uuid(),
});

export type ProductModifierDto = z.infer<typeof productModifierDtoSchema>;

// Schema para personalizaciones de pizza seleccionadas
export const selectedPizzaCustomizationDtoSchema = z.object({
  pizzaCustomizationId: z.string().uuid(),
  half: z.enum(['FULL', 'HALF_1', 'HALF_2']),
  action: z.enum(['ADD', 'REMOVE']),
});

export type SelectedPizzaCustomizationDto = z.infer<
  typeof selectedPizzaCustomizationDtoSchema
>;

// Schema para items en el DTO de actualizacin
export const orderItemDtoForBackendSchema = z.object({
  id: z.string().uuid().optional(),
  productId: z.string().uuid(),
  productVariantId: z.string().uuid().nullable().optional(),
  quantity: z.number().int().positive(), // NOTA: Siempre ser 1, el backend ya no maneja cantidades
  basePrice: z.number().nonnegative(),
  finalPrice: z.number().nonnegative(),
  preparationNotes: z.string().nullable().optional(),
  productModifiers: z.array(productModifierDtoSchema).optional(),
  selectedPizzaCustomizations: z
    .array(selectedPizzaCustomizationDtoSchema)
    .optional(),
});

export type OrderItemDtoForBackend = z.infer<
  typeof orderItemDtoForBackendSchema
>;

// Schema para ajustes en el DTO
export const orderAdjustmentDtoSchema = z.object({
  orderId: z.string().uuid().optional(),
  name: z.string().min(1),
  isPercentage: z.boolean(),
  value: z.number().optional(),
  amount: z.number().optional(),
});

export type OrderAdjustmentDto = z.infer<typeof orderAdjustmentDtoSchema>;

// Schema para el payload de actualizacin de orden
export const updateOrderPayloadSchema = z.object({
  orderType: orderTypeSchema.optional(),
  items: z.array(orderItemDtoForBackendSchema).optional(),
  tableId: z.string().uuid().nullable().optional(),
  scheduledAt: z.date().nullable().optional(),
  deliveryInfo: deliveryInfoSchema.optional(),
  notes: z.string().nullable().optional(),
  status: orderStatusSchema.optional(),
  total: z.number().nonnegative().optional(),
  subtotal: z.number().nonnegative().optional(),
  adjustments: z.array(orderAdjustmentDtoSchema).optional(),
});

export type UpdateOrderPayload = z.infer<typeof updateOrderPayloadSchema>;

================
File: app/src/modules/orders/screens/OrdersScreen.tsx
================
import React from 'react';
import { StyleSheet, View, ScrollView, RefreshControl } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Button, ActivityIndicator, Text } from 'react-native-paper';
import { useNavigation } from '@react-navigation/native';
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { useAppTheme } from '@/app/styles/theme';
import type { OrdersStackParamList } from '@/app/navigation/types';
import { useGlobalShift } from '@/app/hooks/useGlobalShift';
import { NAVIGATION_PATHS } from '@/app/constants/navigationPaths';

function OrdersScreen() {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);
  const navigation =
    useNavigation<NativeStackNavigationProp<OrdersStackParamList>>();

  const { data: shift, isLoading, isFetching, refetch } = useGlobalShift();
  const [isManualRefreshing, setIsManualRefreshing] = React.useState(false);

  // Manejar el pull to refresh
  const handleRefresh = React.useCallback(async () => {
    setIsManualRefreshing(true);
    await refetch();
    setIsManualRefreshing(false);
  }, [refetch]);

  const handleOpenOrders = () => {
    if (shift && shift.status === 'OPEN') {
      navigation.navigate(NAVIGATION_PATHS.OPEN_ORDERS);
    }
  };

  const handleCreateOrder = () => {
    if (shift && shift.status === 'OPEN') {
      navigation.navigate(NAVIGATION_PATHS.CREATE_ORDER);
    }
  };

  const isShiftOpen = shift && shift.status === 'OPEN';

  return (
    <SafeAreaView style={styles.container}>
      <ScrollView
        style={styles.scrollView}
        refreshControl={
          <RefreshControl
            refreshing={isManualRefreshing}
            onRefresh={handleRefresh}
            colors={[theme.colors.primary]}
            tintColor={theme.colors.primary}
          />
        }
        contentContainerStyle={styles.scrollContent}
      >
        <View style={styles.content}>
          {/* Indicador de carga */}
          {(isLoading || (isFetching && !isManualRefreshing)) && (
            <View style={styles.loadingIndicator}>
              <ActivityIndicator size="small" color={theme.colors.primary} />
              <Text variant="bodySmall" style={styles.loadingText}>
                Actualizando estado del turno...
              </Text>
            </View>
          )}
          {/* Botn Crear Orden */}
          <Button
            mode="contained"
            onPress={handleCreateOrder}
            style={[styles.button, !isShiftOpen && styles.buttonDisabled]}
            contentStyle={styles.buttonContent}
            icon="plus-circle-outline"
            disabled={!isShiftOpen}
          >
            Crear Orden
          </Button>

          {/* Botn rdenes Abiertas */}
          <Button
            mode="contained"
            onPress={handleOpenOrders}
            style={[styles.button, !isShiftOpen && styles.buttonDisabled]}
            contentStyle={styles.buttonContent}
            icon="folder-open-outline"
            disabled={!isShiftOpen}
          >
            rdenes Abiertas
          </Button>
        </View>
      </ScrollView>
    </SafeAreaView>
  );
}

const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    scrollView: {
      flex: 1,
    },
    scrollContent: {
      flexGrow: 1,
    },
    content: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.l,
    },
    loadingIndicator: {
      position: 'absolute',
      top: theme.spacing.m,
      alignSelf: 'center',
      flexDirection: 'row',
      alignItems: 'center',
      backgroundColor: theme.colors.surfaceVariant,
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.s,
      borderRadius: theme.roundness * 2,
      gap: theme.spacing.s,
    },
    loadingText: {
      color: theme.colors.onSurfaceVariant,
    },
    title: {
      marginBottom: theme.spacing.l,
      color: theme.colors.onBackground,
    },
    button: {
      width: '90%',
      marginVertical: theme.spacing.l,
    },
    buttonDisabled: {
      opacity: 0.6,
    },
    buttonContent: {
      paddingVertical: theme.spacing.m,
    },
  });

export default OrdersScreen;

================
File: app/src/modules/pizzaCustomizations/components/PizzaCustomizationCard.tsx
================
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Card, Text, Chip } from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import {
  CustomizationTypeEnum,
  type PizzaCustomization,
} from '../schema/pizzaCustomization.schema';

interface PizzaCustomizationCardProps {
  customization: PizzaCustomization;
  onPress: () => void;
}

export function PizzaCustomizationCard({
  customization,
  onPress,
}: PizzaCustomizationCardProps) {
  const theme = useAppTheme();

  const styles = StyleSheet.create({
    card: {
      marginBottom: theme.spacing.s,
    },
    content: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingVertical: -4,
    },
    info: {
      flex: 1,
    },
    name: {
      ...theme.fonts.titleMedium,
      color: theme.colors.onSurface,
      marginBottom: 2,
    },
    ingredients: {
      ...theme.fonts.bodySmall,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      lineHeight: 16,
    },
    chip: {
      marginRight: theme.spacing.xs,
      height: 24,
    },
    rightSection: {
      alignItems: 'flex-end',
      marginLeft: theme.spacing.s,
    },
    toppingValue: {
      ...theme.fonts.titleLarge,
      color: theme.colors.primary,
      fontWeight: 'bold',
    },
    toppingLabel: {
      ...theme.fonts.labelSmall,
      color: theme.colors.onSurfaceVariant,
      marginTop: -2,
    },
    cardContent: {
      paddingVertical: 12,
      paddingHorizontal: 16,
    },
    nameRow: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: 4,
    },
    typeChip: {
      marginLeft: theme.spacing.s,
    },
    inactiveChip: {
      marginLeft: theme.spacing.xs,
    },
    chipText: {
      fontSize: 11,
    },
  });

  const getTypeLabel = (type: any) => {
    return type === CustomizationTypeEnum.FLAVOR ? 'Sabor' : 'Ingrediente';
  };

  const getTypeIcon = (type: any) => {
    return type === CustomizationTypeEnum.FLAVOR ? 'pizza' : 'food-variant';
  };

  return (
    <Card style={styles.card} onPress={onPress} mode="contained">
      <Card.Content style={styles.cardContent}>
        <View style={styles.content}>
          <View style={styles.info}>
            <View style={styles.nameRow}>
              <Text style={styles.name}>{customization.name}</Text>
              <Chip
                icon={getTypeIcon(customization.type)}
                style={[styles.chip, styles.typeChip]}
                compact
                textStyle={styles.chipText}
              >
                {getTypeLabel(customization.type)}
              </Chip>
              {!customization.isActive && (
                <Chip
                  icon="eye-off"
                  style={[styles.chip, styles.inactiveChip]}
                  compact
                  mode="outlined"
                  textStyle={styles.chipText}
                >
                  Inactivo
                </Chip>
              )}
            </View>

            {customization.ingredients && (
              <Text style={styles.ingredients} numberOfLines={1}>
                {customization.ingredients}
              </Text>
            )}
          </View>

          <View style={styles.rightSection}>
            <Text style={styles.toppingValue}>
              {customization.toppingValue}
            </Text>
            <Text style={styles.toppingLabel}>
              topping{customization.toppingValue !== 1 ? 's' : ''}
            </Text>
          </View>
        </View>
      </Card.Content>
    </Card>
  );
}

================
File: app/src/modules/pizzaCustomizations/components/PizzaProductsTab.tsx
================
import React, { useState, useMemo, useEffect } from 'react';
import { View, StyleSheet, FlatList, RefreshControl } from 'react-native';
import {
  Surface,
  Text,
  IconButton,
  Chip,
  ActivityIndicator,
  Menu,
  Searchbar,
  Badge,
  Avatar,
} from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { useQuery } from '@tanstack/react-query';
import { productsService } from '@/modules/menu/services/productsService';
import EmptyState from '@/app/components/common/EmptyState';
import { Product } from '@/modules/menu/schema/products.schema';
import { getImageUrl } from '@/app/lib/imageUtils';
import { PizzaConfigurationModal } from './PizzaConfigurationModal';
import { AssociatePizzaToppingsModal } from './AssociatePizzaToppingsModal';

// Custom hook para manejar URLs de imagen
const useImageUrl = (imagePath: string | null | undefined) => {
  const [imageUrl, setImageUrl] = useState<string | null>(null);

  useEffect(() => {
    if (!imagePath) {
      setImageUrl(null);
      return;
    }

    getImageUrl(imagePath).then(setImageUrl);
  }, [imagePath]);

  return imageUrl;
};

export function PizzaProductsTab() {
  const theme = useAppTheme();
  const [searchQuery, setSearchQuery] = useState('');
  const [filterMenuVisible, setFilterMenuVisible] = useState(false);
  const [filter, setFilter] = useState<'all' | 'configured' | 'not_configured'>(
    'all',
  );
  const [configModalVisible, setConfigModalVisible] = useState(false);
  const [ingredientsModalVisible, setIngredientsModalVisible] = useState(false);
  const [selectedProduct, setSelectedProduct] = useState<Product | null>(null);

  const { data, isLoading, refetch, isRefetching } = useQuery({
    queryKey: ['pizza-products', filter],
    queryFn: async () => {
      const pizzaProducts = await productsService.findAllPizzas();
      return pizzaProducts;
    },
  });

  const filteredProducts = useMemo(() => {
    if (!data) return [];

    let filtered = data.filter((product) =>
      product.name.toLowerCase().includes(searchQuery.toLowerCase()),
    );

    if (filter === 'configured') {
      filtered = filtered.filter((product) => product.pizzaConfiguration);
    } else if (filter === 'not_configured') {
      filtered = filtered.filter((product) => !product.pizzaConfiguration);
    }

    return filtered;
  }, [data, searchQuery, filter]);

  // Componente para renderizar cada producto
  const ProductItem = ({ 
    item, 
    onConfigure, 
    onManageIngredients 
  }: { 
    item: Product;
    onConfigure: (product: Product) => void;
    onManageIngredients: (product: Product) => void;
  }) => {
    const isConfigured = !!item.pizzaConfiguration;
    const customizations = item.pizzaCustomizations || [];
    const flavorsCount = customizations.filter(
      (c: any) => c.type === 'FLAVOR',
    ).length;
    const ingredientsCount = customizations.filter(
      (c: any) => c.type === 'INGREDIENT',
    ).length;
    const imageUrl = useImageUrl(item.photo?.path);
    const variantsCount = item.variants?.length || 0;

    return (
      <Surface style={styles.productCard} elevation={2}>
        <View style={styles.productHeader}>
          <View style={styles.productTitleRow}>
            {imageUrl ? (
              <Avatar.Image
                size={48}
                source={{ uri: imageUrl }}
                style={styles.productImage}
              />
            ) : (
              <Avatar.Icon
                size={48}
                icon="pizza"
                style={[
                  styles.productImage,
                  { backgroundColor: theme.colors.primaryContainer },
                ]}
              />
            )}

            <View style={styles.productInfo}>
              <Text
                variant="titleMedium"
                style={styles.productName}
                numberOfLines={1}
              >
                {item.name}
              </Text>
              <Text variant="bodySmall" style={styles.variantText}>
                {variantsCount > 0
                  ? `${variantsCount} variantes`
                  : 'Sin variantes'}
              </Text>
            </View>

            <View style={styles.productActions}>
              <IconButton
                icon="cog"
                mode="contained-tonal"
                size={28}
                onPress={() => onConfigure(item)}
                style={styles.actionButton}
              />
              <IconButton
                icon="cheese"
                mode="contained-tonal"
                size={28}
                onPress={() => onManageIngredients(item)}
                style={styles.actionButton}
              />
            </View>
          </View>
        </View>

        <View style={styles.productStatus}>
          <Chip
            mode="flat"
            compact
            icon={isConfigured ? 'check-circle' : 'alert-circle'}
            style={[
              styles.statusChip,
              {
                backgroundColor: isConfigured
                  ? theme.colors.primaryContainer
                  : theme.colors.errorContainer,
              },
            ]}
            textStyle={styles.chipText}
          >
            {isConfigured ? 'Configurada' : 'Sin configurar'}
          </Chip>

          <View style={styles.countsContainer}>
            <Text variant="bodySmall" style={styles.countText}>
              {flavorsCount} sabores
            </Text>
            <Text variant="bodySmall" style={styles.countDivider}>
              
            </Text>
            <Text variant="bodySmall" style={styles.countText}>
              {ingredientsCount} ingredientes
            </Text>
          </View>
        </View>
      </Surface>
    );
  };

  const renderProductItem = ({ item }: { item: Product }) => (
    <ProductItem 
      item={item} 
      onConfigure={(product) => {
        setSelectedProduct(product);
        setConfigModalVisible(true);
      }}
      onManageIngredients={(product) => {
        setSelectedProduct(product);
        setIngredientsModalVisible(true);
      }}
    />
  );

  const hasActiveFilter = filter !== 'all';

  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    header: {
      padding: theme.spacing.m,
      backgroundColor: theme.colors.background,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    searchRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
    },
    searchbar: {
      flex: 1,
      backgroundColor: theme.colors.elevation.level2,
    },
    filterButtonContainer: {
      position: 'relative',
    },
    filterIconButton: {
      margin: 0,
      backgroundColor: theme.colors.elevation.level2,
    },
    filterBadge: {
      position: 'absolute',
      top: 4,
      right: 4,
      backgroundColor: theme.colors.primary,
    },
    menuContent: {
      backgroundColor: theme.colors.elevation.level3,
      marginTop: theme.spacing.xs,
    },
    content: {
      flex: 1,
    },
    listContent: {
      paddingVertical: theme.spacing.m,
    },
    productCard: {
      marginHorizontal: theme.spacing.m,
      marginVertical: theme.spacing.s,
      borderRadius: theme.roundness * 2,
      backgroundColor: theme.colors.surface,
      overflow: 'hidden',
      elevation: 1,
    },
    productHeader: {
      padding: theme.spacing.m,
      paddingBottom: theme.spacing.s,
    },
    productTitleRow: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    productImage: {
      marginRight: theme.spacing.m,
    },
    productInfo: {
      flex: 1,
    },
    productName: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      marginBottom: 2,
    },
    variantText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    productStatus: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: theme.spacing.m,
      paddingBottom: theme.spacing.m,
    },
    statusChip: {
      height: 28,
    },
    chipText: {
      fontSize: 12,
      marginHorizontal: theme.spacing.xs,
      marginVertical: 2,
    },
    ingredientCount: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    countsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
    },
    countText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    countDivider: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginHorizontal: 2,
    },
    productActions: {
      flexDirection: 'row',
      gap: theme.spacing.xs,
      marginLeft: theme.spacing.s,
    },
    actionButton: {
      margin: 0,
      width: 48,
      height: 48,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
    activeMenuTitle: {
      color: theme.colors.primary,
      fontWeight: '600',
    },
  });

  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <View style={styles.searchRow}>
          <Searchbar
            placeholder="Buscar pizzas..."
            onChangeText={setSearchQuery}
            value={searchQuery}
            style={styles.searchbar}
            elevation={0}
            inputStyle={{ color: theme.colors.onSurface }}
            placeholderTextColor={theme.colors.onSurfaceVariant}
            iconColor={theme.colors.onSurfaceVariant}
          />
          <View style={styles.filterButtonContainer}>
            <Menu
              visible={filterMenuVisible}
              onDismiss={() => setFilterMenuVisible(false)}
              anchor={
                <IconButton
                  icon={hasActiveFilter ? 'filter-check' : 'filter-variant'}
                  mode="contained-tonal"
                  size={24}
                  onPress={() => setFilterMenuVisible(true)}
                  style={styles.filterIconButton}
                  iconColor={
                    hasActiveFilter
                      ? theme.colors.primary
                      : theme.colors.onSurfaceVariant
                  }
                />
              }
              anchorPosition="bottom"
              contentStyle={styles.menuContent}
            >
              <Menu.Item
                onPress={() => {
                  setFilter('all');
                  setFilterMenuVisible(false);
                }}
                title="Todas"
                leadingIcon="filter-variant"
                trailingIcon={filter === 'all' ? 'check' : undefined}
                titleStyle={
                  filter === 'all' ? styles.activeMenuTitle : undefined
                }
              />
              <Menu.Item
                onPress={() => {
                  setFilter('configured');
                  setFilterMenuVisible(false);
                }}
                title="Configuradas"
                leadingIcon="check-circle"
                trailingIcon={filter === 'configured' ? 'check' : undefined}
                titleStyle={
                  filter === 'configured' ? styles.activeMenuTitle : undefined
                }
              />
              <Menu.Item
                onPress={() => {
                  setFilter('not_configured');
                  setFilterMenuVisible(false);
                }}
                title="Sin Configurar"
                leadingIcon="alert-circle"
                trailingIcon={filter === 'not_configured' ? 'check' : undefined}
                titleStyle={
                  filter === 'not_configured'
                    ? styles.activeMenuTitle
                    : undefined
                }
              />
            </Menu>
            {hasActiveFilter && <Badge style={styles.filterBadge} size={8} />}
          </View>
        </View>
      </View>

      <FlatList
        data={filteredProducts}
        renderItem={renderProductItem}
        keyExtractor={(item) => item.id}
        contentContainerStyle={styles.listContent}
        refreshControl={
          <RefreshControl
            refreshing={isRefetching}
            onRefresh={refetch}
            colors={[theme.colors.primary]}
          />
        }
        ListEmptyComponent={
          <EmptyState
            title="No hay pizzas"
            message={
              filter === 'not_configured'
                ? 'No hay pizzas sin configurar'
                : filter === 'configured'
                  ? 'No hay pizzas configuradas'
                  : 'No hay productos tipo pizza creados'
            }
            icon="pizza"
          />
        }
      />

      <PizzaConfigurationModal
        visible={configModalVisible}
        onDismiss={() => {
          setConfigModalVisible(false);
          setSelectedProduct(null);
        }}
        product={selectedProduct}
      />

      <AssociatePizzaToppingsModal
        visible={ingredientsModalVisible}
        onDismiss={() => {
          setIngredientsModalVisible(false);
          setSelectedProduct(null);
        }}
        product={selectedProduct}
      />
    </View>
  );
}

================
File: app/src/modules/preparationScreens/components/PreparationScreenListItem.tsx
================
import React from 'react';
import { View, StyleSheet, Pressable } from 'react-native';
import { Text, Chip, IconButton, Surface } from 'react-native-paper';
import { MaterialCommunityIcons as Icon } from '@expo/vector-icons';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { PreparationScreen } from '../schema/preparationScreen.schema';

interface PreparationScreenListItemProps {
  item: PreparationScreen;
  onPress: (item: PreparationScreen) => void;
  onManageProducts?: (item: PreparationScreen) => void;
}

const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      marginHorizontal: theme.spacing.m,
      marginVertical: theme.spacing.s,
      borderRadius: theme.roundness * 2,
      overflow: 'hidden',
      elevation: 2,
      backgroundColor: theme.colors.surface,
    },
    pressable: {
      borderRadius: theme.roundness * 2,
    },
    colorBar: {
      position: 'absolute',
      left: 0,
      right: 0,
      top: 0,
      height: 6,
    },
    content: {
      padding: theme.spacing.m,
    },
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      marginBottom: theme.spacing.s,
    },
    titleContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
    },
    iconContainer: {
      width: 48,
      height: 48,
      borderRadius: 24,
      justifyContent: 'center',
      alignItems: 'center',
      marginRight: theme.spacing.m,
    },
    title: {
      fontSize: 18,
      fontWeight: '600',
      color: theme.colors.onSurface,
      flex: 1,
    },
    statusChip: {
      paddingHorizontal: theme.spacing.s,
    },
    statusChipText: {
      fontSize: 12,
    },
    description: {
      color: theme.colors.onSurfaceVariant,
      marginBottom: theme.spacing.m,
      lineHeight: 20,
    },
    footer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingTop: theme.spacing.m,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
    },
    statsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.l,
    },
    stat: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
    },
    statIcon: {
      opacity: 0.7,
    },
    statText: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    actionButton: {
      margin: -8,
    },
  });

const PreparationScreenListItem: React.FC<PreparationScreenListItemProps> = ({
  item,
  onPress,
  onManageProducts,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => getStyles(theme), [theme]);

  const userCount = item.users?.length || 0;
  const productCount = item.products?.length || 0;
  const isActive = item.isActive ?? true;

  // Get gradient colors based on screen name
  const getGradientColors = () => {
    const name = item.name.toLowerCase();
    if (name.includes('pizza')) {
      return ['#FF6B6B', '#FF8E53'];
    } else if (name.includes('hamburguesa')) {
      return ['#4ECDC4', '#44A08D'];
    } else if (name.includes('bar')) {
      return ['#667EEA', '#764BA2'];
    }
    return [theme.colors.primary, theme.colors.secondary];
  };

  // Get icon based on screen name
  const getIcon = () => {
    const name = item.name.toLowerCase();
    if (name.includes('pizza')) return 'pizza';
    if (name.includes('hamburguesa')) return 'hamburger';
    if (name.includes('bar')) return 'glass-cocktail';
    return 'monitor-dashboard';
  };

  const gradientColors = getGradientColors();

  return (
    <Surface style={styles.container}>
      <Pressable
        style={styles.pressable}
        onPress={() => onPress(item)}
        android_ripple={{ borderless: false }}
      >
        <View
          style={[styles.colorBar, { backgroundColor: gradientColors[0] }]}
        />

        <View style={styles.content}>
          <View style={styles.header}>
            <View style={styles.titleContainer}>
              <View
                style={[
                  styles.iconContainer,
                  { backgroundColor: `${gradientColors[0]}20` },
                ]}
              >
                <Icon name={getIcon()} size={24} color={gradientColors[0]} />
              </View>
              <Text style={styles.title} numberOfLines={1}>
                {item.name}
              </Text>
            </View>

            <Chip
              mode="flat"
              compact
              style={[
                styles.statusChip,
                {
                  backgroundColor: isActive
                    ? theme.colors.successContainer
                    : theme.colors.surfaceVariant,
                },
              ]}
              textStyle={[
                styles.statusChipText,
                {
                  color: isActive
                    ? theme.colors.onSuccessContainer
                    : theme.colors.onSurfaceVariant,
                },
              ]}
            >
              {isActive ? 'Activa' : 'Inactiva'}
            </Chip>
          </View>

          {item.description && (
            <Text style={styles.description} numberOfLines={2}>
              {item.description}
            </Text>
          )}

          <View style={styles.footer}>
            <View style={styles.statsContainer}>
              <View style={styles.stat}>
                <Icon
                  name="account-group"
                  size={16}
                  color={theme.colors.onSurfaceVariant}
                  style={styles.statIcon}
                />
                <Text style={styles.statText}>
                  {userCount} {userCount === 1 ? 'usuario' : 'usuarios'}
                </Text>
              </View>

              <View style={styles.stat}>
                <Icon
                  name="food"
                  size={16}
                  color={theme.colors.onSurfaceVariant}
                  style={styles.statIcon}
                />
                <Text style={styles.statText}>
                  {productCount} {productCount === 1 ? 'producto' : 'productos'}
                </Text>
              </View>
            </View>

            {onManageProducts && (
              <IconButton
                icon="link-variant"
                size={20}
                onPress={() => onManageProducts(item)}
                style={styles.actionButton}
              />
            )}
          </View>
        </View>
      </Pressable>
    </Surface>
  );
};

export default PreparationScreenListItem;

================
File: app/src/modules/preparationScreens/schema/preparationScreen.schema.ts
================
import { z } from 'zod';
// Importar el schema y tipo de dominio centralizado
import {
  preparationScreenSchema as domainPreparationScreenSchema,
  type PreparationScreen as DomainPreparationScreen,
} from '../../../app/schemas/domain/preparation-screen.schema';

// Esquema principal extendido desde el dominio para incluir relaciones
export const PreparationScreenSchema = domainPreparationScreenSchema.extend({
  id: z.string().uuid(), // Refinar el ID para ser UUID especficamente
  products: z
    .array(
      z.object({
        id: z.string(),
        name: z.string(),
      }),
    )
    .optional(),
  users: z
    .array(
      z.object({
        id: z.string(),
        username: z.string(),
        firstName: z.string().nullable().optional(),
        lastName: z.string().nullable().optional(),
      }),
    )
    .nullable()
    .optional(),
  createdAt: z.string().datetime().optional(),
  updatedAt: z.string().datetime().optional(),
});

// Esquema para crear una nueva pantalla de preparacin - compuesto desde el dominio
export const CreatePreparationScreenSchema = domainPreparationScreenSchema
  .omit({ id: true })
  .extend({
    name: z
      .string()
      .min(1, 'El nombre es requerido')
      .max(100, 'El nombre no puede exceder los 100 caracteres'),
    description: z
      .string()
      .max(255, 'La descripcin no puede exceder los 255 caracteres')
      .nullable()
      .optional(),
    isActive: z.boolean().optional().default(true),
    productIds: z.array(z.string().uuid()).optional(), // IDs de productos asociados (opcional)
    userId: z
      .string()
      .min(1, 'Debe seleccionar un usuario de cocina')
      .uuid({ message: 'Debe seleccionar un usuario de cocina vlido' }), // ID del usuario asignado (requerido)
  });

// Esquema para actualizar una pantalla de preparacin existente - basado en el de creacin
export const UpdatePreparationScreenSchema = CreatePreparationScreenSchema.omit(
  { userId: true },
).extend({
  name: z
    .string()
    .min(1, 'El nombre es requerido')
    .max(100, 'El nombre no puede exceder los 100 caracteres')
    .optional(),
  description: z
    .string()
    .max(255, 'La descripcin no puede exceder los 255 caracteres')
    .nullable()
    .optional(),
  isActive: z.boolean().optional(),
  userId: z
    .string()
    .min(1, 'Debe seleccionar un usuario de cocina')
    .uuid({ message: 'Debe seleccionar un usuario de cocina vlido' })
    .optional(), // Opcional en actualizacin
});

// Tipos inferidos de los esquemas Zod
export type PreparationScreen = z.infer<typeof PreparationScreenSchema>;
export type CreatePreparationScreenDto = z.infer<
  typeof CreatePreparationScreenSchema
>;
export type UpdatePreparationScreenDto = z.infer<
  typeof UpdatePreparationScreenSchema
>;

// Re-exportar tipo de dominio para conveniencia
export type { DomainPreparationScreen };

// Esquema para los filtros de bsqueda/listado
export const FindAllPreparationScreensSchema = z.object({
  name: z.string().optional(),
  isActive: z.boolean().optional(),
  // Aadir otros filtros si son necesarios, ej: productId
});

// Tipo inferido para los filtros de bsqueda/listado
export type FindAllPreparationScreensDto = z.infer<
  typeof FindAllPreparationScreensSchema
>;

================
File: app/src/modules/preparationScreens/screens/PreparationScreensScreen.tsx
================
import React, { useCallback, useMemo, useState } from 'react';
import { StyleSheet } from 'react-native';
import { IconButton, Text } from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useDrawerStatus } from '@react-navigation/drawer';
import { discoveryService } from '@/app/services/discoveryService';

import GenericList, {
  FilterOption,
} from '../../../app/components/crud/GenericList';
import PreparationScreenDetailModalSimple from '../components/PreparationScreenDetailModalSimple';
import PreparationScreenListItem from '../components/PreparationScreenListItem';
import { useCrudScreenLogic } from '../../../app/hooks/useCrudScreenLogic';
import PreparationScreenFormModal from '../components/PreparationScreenFormModal';
import { ProductSelectionModal } from '../components/ProductSelectionModal';
import {
  useGetPreparationScreens,
  useGetPreparationScreenById,
  useDeletePreparationScreen,
  useGetMenuWithAssociations,
  useAssociateProducts,
} from '../hooks/usePreparationScreensQueries';
import {
  PreparationScreen,
  FindAllPreparationScreensDto as FindAllPreparationScreensFilter,
} from '../schema/preparationScreen.schema';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { BaseListQuery } from '../../../app/types/query.types';
import { useListState } from '@/app/hooks/useListState';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';

const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
  });

const PreparationScreensScreen = () => {
  const theme = useAppTheme();
  const styles = useMemo(() => getStyles(theme), [theme]);
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';

  const [filters, setFilters] = useState<FindAllPreparationScreensFilter>({});
  const [pagination, setPagination] = useState<BaseListQuery>({
    page: 1,
    limit: 15,
  });
  const [searchTerm, setSearchTerm] = useState('');
  const [isProductModalVisible, setIsProductModalVisible] = useState(false);
  const [productModalScreenId, setProductModalScreenId] = useState<
    string | null
  >(null);

  const {
    data: screensData,
    isLoading: isLoadingList,
    isFetching: isFetchingList,
    refetch: refetchList,
    error: errorList,
  } = useGetPreparationScreens(filters, pagination);

  const { mutate: deleteScreenMutate } = useDeletePreparationScreen();
  const associateProductsMutation = useAssociateProducts();

  const deleteScreenWrapper = useCallback(
    async (id: string): Promise<void> => {
      return new Promise((resolve, reject) => {
        deleteScreenMutate(id, {
          onSuccess: () => resolve(),
          onError: (error) => reject(error),
        });
      });
    },
    [deleteScreenMutate],
  );

  // Hooks para el modal de productos
  const { data: menuData, isLoading: isLoadingMenu } =
    useGetMenuWithAssociations(productModalScreenId, {
      enabled: !!productModalScreenId && isProductModalVisible,
    });

  // Recargar automticamente cuando la pantalla recibe foco
  useRefreshModuleOnFocus('preparation-screens');

  // Enriquecer menuData con informacin de pantallas
  const enrichedMenuData = React.useMemo(() => {
    if (!menuData || !screensData?.data) return menuData;

    // Crear un mapa de productId a nombre de pantalla
    const screenAssignments: Record<string, string> = {};

    screensData.data.forEach((screen) => {
      if (screen.products) {
        screen.products.forEach((product) => {
          screenAssignments[product.id] = screen.name;
        });
      }
    });

    return {
      ...menuData,
      screenAssignments,
    };
  }, [menuData, screensData]);

  const handleOpenProductModal = useCallback((screen: PreparationScreen) => {
    setProductModalScreenId(screen.id);
    setIsProductModalVisible(true);
  }, []);

  const handleCloseProductModal = useCallback(() => {
    setIsProductModalVisible(false);
    setProductModalScreenId(null);
  }, []);

  const handleSaveProducts = useCallback(
    (productIds: string[]) => {
      if (productModalScreenId) {
        associateProductsMutation.mutate(
          { id: productModalScreenId, productIds },
          {
            onSuccess: () => {
              handleCloseProductModal();
              refetchList();
            },
          },
        );
      }
    },
    [
      productModalScreenId,
      associateProductsMutation,
      handleCloseProductModal,
      refetchList,
    ],
  );

  const {
    isFormModalVisible,
    isDetailModalVisible,
    editingItem,
    selectedItem,
    isDeleting,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
    deleteConfirmation,
  } = useCrudScreenLogic<PreparationScreen>({
    entityName: 'Pantalla de Preparacin',
    queryKey: ['preparationScreens', filters, pagination],
    deleteMutationFn: deleteScreenWrapper,
  });

  const selectedScreenId = selectedItem?.id ?? null;

  const { data: selectedScreenData } = useGetPreparationScreenById(
    selectedScreenId,
    {
      enabled: !!selectedScreenId && isDetailModalVisible,
    },
  );

  const handleRefresh = useCallback(async () => {
    // Si hay error de conexin, intentar redescubrir el servidor
    if (
      errorList &&
      (errorList.message?.includes('conexin') ||
        errorList.message?.includes('network'))
    ) {
      try {
        await discoveryService.forceRediscovery();
        // Dar tiempo para que se reinicialice el cliente
        await new Promise((resolve) => setTimeout(resolve, 500));
      } catch (error) {
        // No es crtico, el usuario puede intentar manualmente
      }
    }
    refetchList();
  }, [refetchList, errorList]);

  const handleSearchChange = useCallback((query: string) => {
    setSearchTerm(query);
    const timerId = setTimeout(() => {
      setFilters((prev: FindAllPreparationScreensFilter) => ({
        ...prev,
        name: query || undefined,
      }));
      setPagination((prev) => ({ ...prev, page: 1 }));
    }, 500);
    return () => clearTimeout(timerId);
  }, []);

  const handleFilterChange = useCallback((value: string | number) => {
    const strValue = String(value);
    let newIsActive: boolean | undefined;
    if (strValue === 'true') newIsActive = true;
    else if (strValue === 'false') newIsActive = false;
    else newIsActive = undefined;
    setFilters((prev: FindAllPreparationScreensFilter) => ({
      ...prev,
      isActive: newIsActive,
    }));
    setPagination((prev) => ({ ...prev, page: 1 }));
  }, []);

  const listRenderConfig = {
    titleField: 'name' as keyof PreparationScreen,
    descriptionField: 'description' as keyof PreparationScreen,
    statusConfig: {
      field: 'isActive' as keyof PreparationScreen,
      activeValue: true,
      activeLabel: 'Activa',
      inactiveLabel: 'Inactiva',
    },
    renderDescription: (item: PreparationScreen) => {
      const parts: string[] = [];

      if (item.description) {
        parts.push(item.description);
      }

      if (item.users && item.users.length > 0) {
        const userNames = item.users
          .map((user) => {
            const fullName =
              `${user.firstName || ''} ${user.lastName || ''}`.trim();
            return fullName || user.username;
          })
          .join(', ');
        parts.push(`Usuarios: ${userNames}`);
      }

      const text = parts.join('  ');
      if (!text) return null;

      return (
        <Text variant="bodyMedium" numberOfLines={2} ellipsizeMode="tail">
          {text}
        </Text>
      );
    },
  };

  const filterOptions: FilterOption<string>[] = [
    { value: '', label: 'Todas' },
    { value: 'true', label: 'Activas' },
    { value: 'false', label: 'Inactivas' },
  ];

  const { ListEmptyComponent } = useListState({
    isLoading: isLoadingList,
    isError: !!errorList,
    data: screensData?.data,
    emptyConfig: {
      title: searchTerm
        ? 'No se encontraron pantallas'
        : 'No hay pantallas de preparacin',
      message: searchTerm
        ? `No se encontraron pantallas para "${searchTerm}"`
        : 'No hay pantallas de preparacin creadas. Presiona el botn + para crear la primera.',
      icon: 'monitor-dashboard',
    },
    errorConfig: {
      title: 'Error al cargar pantallas',
      message: errorList?.message?.includes('encontrar el servidor')
        ? 'No se pudo encontrar el servidor. Verifica que el servidor est encendido y en la misma red.'
        : 'No se pudieron cargar las pantallas de preparacin. Verifica tu conexin.',
      icon: 'alert-circle-outline',
      actionLabel: 'Reintentar',
      onAction: handleRefresh,
    },
  });

  const renderItem = useCallback(
    ({ item }: { item: PreparationScreen }) => (
      <PreparationScreenListItem
        item={item}
        onPress={handleOpenDetailModal}
        onManageProducts={handleOpenProductModal}
      />
    ),
    [handleOpenDetailModal, handleOpenProductModal],
  );

  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      <GenericList<PreparationScreen>
        showImagePlaceholder={false}
        items={screensData?.data ?? []}
        renderConfig={listRenderConfig}
        onItemPress={handleOpenDetailModal}
        onRefresh={handleRefresh}
        isRefreshing={isFetchingList && !isLoadingList}
        ListEmptyComponent={ListEmptyComponent}
        enableSearch={true}
        searchQuery={searchTerm}
        onSearchChange={handleSearchChange}
        searchPlaceholder="Buscar por nombre..."
        filterOptions={filterOptions}
        filterValue={
          filters.isActive === true
            ? 'true'
            : filters.isActive === false
              ? 'false'
              : ''
        }
        onFilterChange={handleFilterChange}
        showFab={true}
        onFabPress={handleOpenCreateModal}
        isModalOpen={
          isDetailModalVisible || isFormModalVisible || isProductModalVisible
        }
        isDrawerOpen={isDrawerOpen}
        renderItemActions={(item) => (
          <IconButton
            icon="link"
            size={20}
            onPress={() => handleOpenProductModal(item)}
          />
        )}
        renderItem={renderItem}
      />

      <PreparationScreenDetailModalSimple
        visible={isDetailModalVisible}
        onDismiss={handleCloseModals}
        item={selectedScreenData ?? selectedItem ?? null}
        onEdit={() => {
          const itemToEdit = selectedScreenData ?? selectedItem;
          if (itemToEdit) {
            handleOpenEditModal(itemToEdit);
          }
        }}
        deleteConfirmation={deleteConfirmation}
        onManageProducts={handleOpenProductModal}
        isDeleting={isDeleting}
      />

      <PreparationScreenFormModal
        visible={isFormModalVisible}
        onDismiss={handleCloseModals}
        editingItem={editingItem}
        onSubmitSuccess={() => {}}
      />

      <ProductSelectionModal
        visible={isProductModalVisible}
        onDismiss={handleCloseProductModal}
        onSave={handleSaveProducts}
        screenId={productModalScreenId || ''}
        menuData={enrichedMenuData}
        loading={isLoadingMenu}
      />
    </SafeAreaView>
  );
};

export default PreparationScreensScreen;

================
File: app/src/modules/preparationScreens/services/preparationScreenService.ts
================
import apiClient from '../../../app/services/apiClient';
import { API_PATHS } from '../../../app/constants/apiPaths';
import { PaginatedResponse } from '../../../app/types/api.types';
import { BaseListQuery } from '../../../app/types/query.types';
import {
  PreparationScreen,
  CreatePreparationScreenDto,
  UpdatePreparationScreenDto,
  FindAllPreparationScreensDto,
} from '../schema/preparationScreen.schema';

/**
 * Fetches a list of preparation screens based on filter and pagination options.
 * @param filterOptions - Options to filter the results (e.g., by name, isActive).
 * @param paginationOptions - Options for pagination (page number, limit).
 * @returns A promise that resolves to a paginated response of PreparationScreen objects.
 * @throws {ApiError} If the API request fails.
 */
export const getPreparationScreens = async (
  filterOptions: FindAllPreparationScreensDto = {},
  paginationOptions: BaseListQuery = { page: 1, limit: 15 }, // Default limit 15
): Promise<PaginatedResponse<PreparationScreen>> => {
  const response = await apiClient.get<PaginatedResponse<PreparationScreen>>(
    API_PATHS.PREPARATION_SCREENS,
    {
      params: {
        ...filterOptions,
        page: paginationOptions.page,
        limit: paginationOptions.limit,
      },
    },
  );

  // Verificar que la respuesta tenga la estructura esperada del backend paginado
  if (
    typeof response.data === 'object' &&
    'items' in response.data &&
    Array.isArray(response.data.items) &&
    'total' in response.data &&
    'page' in response.data &&
    'limit' in response.data
  ) {
    // Convertir de la estructura del backend a PaginatedResponse
    return {
      data: response.data.items,
      total: response.data.total,
      page: response.data.page,
      limit: response.data.limit,
      totalPages: Math.ceil(response.data.total / response.data.limit),
    };
  } else {
    throw new Error('Invalid response format from API');
  }
};

/**
 * Fetches a single preparation screen by its ID.
 * @param id - The UUID of the preparation screen.
 * @returns A promise that resolves to the PreparationScreen object.
 * @throws {ApiError} If the API request fails or the screen is not found.
 */
export const getPreparationScreenById = async (
  id: string,
): Promise<PreparationScreen> => {
  const response = await apiClient.get<PreparationScreen>(
    API_PATHS.PREPARATION_SCREENS_BY_ID.replace(':id', id),
  );
  return response.data;
};

/**
 * Creates a new preparation screen.
 * @param data - The data for the new preparation screen (CreatePreparationScreenDto).
 * @returns A promise that resolves to the newly created PreparationScreen object.
 * @throws {ApiError} If the API request fails.
 */
export const createPreparationScreen = async (
  data: CreatePreparationScreenDto,
): Promise<PreparationScreen> => {
  const response = await apiClient.post<PreparationScreen>(
    API_PATHS.PREPARATION_SCREENS,
    data,
  );
  return response.data;
};

/**
 * Updates an existing preparation screen.
 * @param id - The UUID of the preparation screen to update.
 * @param data - The data to update (UpdatePreparationScreenDto).
 * @returns A promise that resolves to the updated PreparationScreen object.
 * @throws {ApiError} If the API request fails or the screen is not found.
 */
export const updatePreparationScreen = async (
  id: string,
  data: UpdatePreparationScreenDto,
): Promise<PreparationScreen> => {
  const response = await apiClient.patch<PreparationScreen>(
    API_PATHS.PREPARATION_SCREENS_BY_ID.replace(':id', id),
    data,
  );
  return response.data;
};

/**
 * Deletes a preparation screen by its ID (soft delete likely).
 * @param id - The UUID of the preparation screen to delete.
 * @returns A promise that resolves when the deletion is successful.
 * @throws {ApiError} If the API request fails.
 */
export const deletePreparationScreen = async (id: string): Promise<void> => {
  await apiClient.delete(
    API_PATHS.PREPARATION_SCREENS_BY_ID.replace(':id', id),
  );
};

/**
 * Gets products associated with a preparation screen.
 * @param id - The UUID of the preparation screen.
 * @returns A promise that resolves to an array of products.
 * @throws {ApiError} If the API request fails.
 */
export const getPreparationScreenProducts = async (
  id: string,
): Promise<any[]> => {
  const response = await apiClient.get<any[]>(
    API_PATHS.PREPARATION_SCREENS_PRODUCTS.replace(':id', id),
  );
  return response.data;
};

/**
 * Gets the complete menu with association information for a preparation screen.
 * @param id - The UUID of the preparation screen.
 * @returns A promise that resolves to the menu data with associations.
 * @throws {ApiError} If the API request fails.
 */
export const getMenuWithAssociations = async (id: string): Promise<any> => {
  const response = await apiClient.get<any>(
    API_PATHS.PREPARATION_SCREENS_MENU_WITH_ASSOCIATIONS.replace(':id', id),
  );
  return response.data;
};

/**
 * Associates products with a preparation screen.
 * @param id - The UUID of the preparation screen.
 * @param productIds - Array of product IDs to associate.
 * @returns A promise that resolves to the updated preparation screen.
 * @throws {ApiError} If the API request fails.
 */
export const associateProducts = async (
  id: string,
  productIds: string[],
): Promise<PreparationScreen> => {
  const response = await apiClient.post<PreparationScreen>(
    API_PATHS.PREPARATION_SCREENS_PRODUCTS.replace(':id', id),
    { productIds },
  );
  return response.data;
};

================
File: app/src/modules/printers/components/NumericField.tsx
================
import React, { useState, useEffect } from 'react';
import { StyleSheet } from 'react-native';
import AnimatedLabelInput from '../../../app/components/common/AnimatedLabelInput';

interface NumericFieldProps {
  label: string;
  value: number | undefined;
  onChange: (value: number | undefined) => void;
  onBlur: () => void;
  error?: boolean;
  disabled?: boolean;
  defaultValue: number;
}

const NumericField: React.FC<NumericFieldProps> = ({
  label,
  value,
  onChange,
  onBlur,
  error,
  disabled,
  defaultValue,
}) => {
  const [displayValue, setDisplayValue] = useState(() =>
    value !== undefined ? String(value) : '',
  );
  const [isFocused, setIsFocused] = useState(false);

  useEffect(() => {
    if (!isFocused && value !== undefined) {
      setDisplayValue(String(value));
    }
  }, [value, isFocused]);

  const handleChangeText = (text: string) => {
    const numericText = text.replace(/[^0-9]/g, '');
    setDisplayValue(numericText);

    if (numericText === '') {
      onChange(undefined);
    } else {
      const numValue = parseInt(numericText, 10);
      if (!isNaN(numValue)) {
        onChange(numValue);
      }
    }
  };

  const handleBlur = () => {
    setIsFocused(false);
    if (value === undefined || isNaN(Number(value))) {
      onChange(defaultValue);
      setDisplayValue(String(defaultValue));
    }
    onBlur();
  };

  const handleFocus = () => {
    setIsFocused(true);
  };

  return (
    <AnimatedLabelInput
      label={label}
      value={displayValue}
      onChangeText={handleChangeText}
      onBlur={handleBlur}
      onFocus={handleFocus}
      error={error}
      disabled={disabled}
      keyboardType="number-pad"
      containerStyle={styles.container}
    />
  );
};

const styles = StyleSheet.create({
  container: {
    marginBottom: 12,
  },
});

export default NumericField;

================
File: app/src/modules/printers/components/PrinterAdvancedConfig.tsx
================
import React from 'react';
import { View, StyleSheet } from 'react-native';
import {
  Text,
  SegmentedButtons,
  HelperText,
  Switch,
  Card,
  Chip,
} from 'react-native-paper';
import { Controller, Control, FieldErrors } from 'react-hook-form';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { PrinterFormData } from '../schema/printer.schema';
import NumericField from './NumericField';

interface PrinterAdvancedConfigProps {
  control: Control<PrinterFormData>;
  errors: FieldErrors<PrinterFormData>;
  isSubmitting: boolean;
}

const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      marginTop: theme.spacing.m,
    },
    sectionTitle: {
      marginBottom: theme.spacing.m,
      marginTop: theme.spacing.l,
      color: theme.colors.primary,
      fontWeight: '600',
    },
    input: {
      marginBottom: theme.spacing.m,
    },
    switchContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      marginBottom: theme.spacing.m,
      paddingVertical: theme.spacing.s,
    },
    switchLabel: {
      color: theme.colors.onSurfaceVariant,
      marginRight: theme.spacing.m,
      fontSize: 16,
      flexShrink: 1,
    },
    helperText: {
      marginTop: -theme.spacing.s,
      marginBottom: theme.spacing.s,
    },
    segmentedButtons: {
      marginBottom: theme.spacing.m,
    },
    recommendationCard: {
      marginBottom: theme.spacing.m,
      padding: theme.spacing.m,
      backgroundColor: theme.colors.primaryContainer,
    },
    recommendationTitle: {
      fontWeight: '600',
      marginBottom: theme.spacing.xs,
      color: theme.colors.onPrimaryContainer,
    },
    recommendationRow: {
      flexDirection: 'row',
      alignItems: 'center',
      marginVertical: theme.spacing.xs,
    },
    recommendationText: {
      marginLeft: theme.spacing.s,
      color: theme.colors.onPrimaryContainer,
    },
    chip: {
      marginRight: theme.spacing.xs,
    },
    labelText: {
      marginBottom: 8,
    },
  });

const PrinterAdvancedConfig: React.FC<PrinterAdvancedConfigProps> = ({
  control,
  errors,
  isSubmitting,
}) => {
  const theme = useAppTheme();
  const styles = getStyles(theme);

  return (
    <View style={styles.container}>
      <Text variant="titleMedium" style={styles.sectionTitle}>
        Configuracin del Papel
      </Text>

      <Card style={styles.recommendationCard}>
        <Card.Content>
          <Text variant="bodyMedium" style={styles.recommendationTitle}>
            Recomendaciones de configuracin:
          </Text>
          <View style={styles.recommendationRow}>
            <Chip compact style={styles.chip}>
              80mm
            </Chip>
            <Text variant="bodySmall" style={styles.recommendationText}>
              48 caracteres (normal)  64 (comprimido)
            </Text>
          </View>
          <View style={styles.recommendationRow}>
            <Chip compact style={styles.chip}>
              58mm
            </Chip>
            <Text variant="bodySmall" style={styles.recommendationText}>
              32 caracteres (normal)  42 (comprimido)
            </Text>
          </View>
        </Card.Content>
      </Card>

      <Controller
        name="paperWidth"
        control={control}
        render={({ field: { onChange, value } }) => (
          <View>
            <Text variant="bodyMedium" style={styles.labelText}>
              Ancho del papel
            </Text>
            <SegmentedButtons
              value={String(value)}
              onValueChange={(val) => onChange(Number(val))}
              buttons={[
                {
                  value: '58',
                  label: '58mm',
                  disabled: isSubmitting,
                },
                {
                  value: '80',
                  label: '80mm',
                  disabled: isSubmitting,
                },
              ]}
              style={styles.segmentedButtons}
            />
          </View>
        )}
      />

      <Controller
        name="charactersPerLine"
        control={control}
        render={({ field: { onChange, onBlur, value } }) => (
          <NumericField
            label="Caracteres por lnea"
            value={value}
            onChange={onChange}
            onBlur={onBlur}
            error={!!errors.charactersPerLine}
            disabled={isSubmitting}
            defaultValue={48}
          />
        )}
      />
      {errors.charactersPerLine && (
        <HelperText
          type="error"
          visible={!!errors.charactersPerLine}
          style={styles.helperText}
        >
          {errors.charactersPerLine.message}
        </HelperText>
      )}

      <HelperText type="info" visible={true} style={styles.helperText}>
        Ajusta segn el ancho real de impresin de tu impresora
      </HelperText>

      <Text variant="titleMedium" style={styles.sectionTitle}>
        Configuracin de Corte
      </Text>

      <View style={styles.switchContainer}>
        <Text variant="bodyLarge" style={styles.switchLabel}>
          Cortar papel automticamente
        </Text>
        <Controller
          name="cutPaper"
          control={control}
          render={({ field: { onChange, value } }) => (
            <Switch
              value={value}
              onValueChange={onChange}
              disabled={isSubmitting}
            />
          )}
        />
      </View>

      <Controller
        name="feedLines"
        control={control}
        render={({ field: { onChange, onBlur, value } }) => (
          <NumericField
            label="Lneas de avance antes del corte"
            value={value}
            onChange={onChange}
            onBlur={onBlur}
            error={!!errors.feedLines}
            disabled={isSubmitting}
            defaultValue={3}
          />
        )}
      />
      {errors.feedLines && (
        <HelperText
          type="error"
          visible={!!errors.feedLines}
          style={styles.helperText}
        >
          {errors.feedLines.message}
        </HelperText>
      )}

      <HelperText type="info" visible={true} style={styles.helperText}>
        Lneas en blanco para que el ticket salga completamente (0-50)
      </HelperText>
    </View>
  );
};

export default PrinterAdvancedConfig;

================
File: app/src/modules/printers/components/PrinterDetailModal.tsx
================
import React from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Surface,
  IconButton,
  Divider,
  Button,
  Chip,
} from 'react-native-paper';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { ThermalPrinter } from '../types/printer.types';

interface PrinterDetailModalProps {
  visible: boolean;
  onDismiss: () => void;
  printer: ThermalPrinter | null;
  onEdit?: () => void;
  onDelete?: () => void;
  onTestPrint?: () => void;
  isDeleting?: boolean;
  isTestPrinting?: boolean;
}

const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    modalContent: {
      backgroundColor: theme.colors.background,
      borderRadius: theme.roundness * 3,
      margin: theme.spacing.l,
      maxHeight: '90%',
      overflow: 'hidden',
    },
    header: {
      backgroundColor: theme.colors.primary,
      padding: theme.spacing.l,
      paddingBottom: theme.spacing.m,
    },
    headerContent: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
    },
    headerTextContainer: {
      flex: 1,
    },
    headerTitle: {
      color: theme.colors.onPrimary,
      fontSize: 20,
      fontWeight: '700',
    },
    headerSubtitle: {
      color: theme.colors.onPrimary,
      opacity: 0.8,
      fontSize: 14,
      marginTop: 4,
    },
    closeButton: {
      margin: -theme.spacing.xs,
    },
    scrollView: {
      maxHeight: 400,
    },
    scrollContent: {
      padding: theme.spacing.l,
    },
    section: {
      marginBottom: theme.spacing.l,
    },
    sectionTitle: {
      fontSize: 14,
      fontWeight: '600',
      color: theme.colors.primary,
      marginBottom: theme.spacing.s,
      textTransform: 'uppercase',
      letterSpacing: 0.5,
    },
    infoRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingVertical: theme.spacing.s,
    },
    infoLabel: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    infoValue: {
      fontSize: 14,
      color: theme.colors.onSurface,
      fontWeight: '500',
      textAlign: 'right',
      flex: 1,
      marginLeft: theme.spacing.m,
    },
    statusContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
      marginBottom: theme.spacing.m,
    },
    statusChip: {
      paddingHorizontal: theme.spacing.xs,
    },
    activeChip: {
      backgroundColor: theme.colors.primaryContainer,
    },
    inactiveChip: {
      backgroundColor: theme.colors.errorContainer,
    },
    featuresGrid: {
      flexDirection: 'row',
      flexWrap: 'wrap',
      gap: theme.spacing.s,
      marginTop: theme.spacing.s,
    },
    featureCard: {
      padding: theme.spacing.m,
      borderRadius: theme.roundness * 2,
      backgroundColor: theme.colors.surfaceVariant,
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
      minWidth: '45%',
      flex: 1,
    },
    featureIcon: {
      backgroundColor: theme.colors.secondaryContainer,
      borderRadius: theme.roundness,
      padding: theme.spacing.xs,
    },
    featureText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      flex: 1,
    },
    divider: {
      marginVertical: theme.spacing.m,
    },
    testPrintButton: {
      marginBottom: theme.spacing.m,
      borderColor: theme.colors.primary,
    },
    footer: {
      padding: theme.spacing.l,
      paddingTop: 0,
      gap: theme.spacing.s,
    },
    footerButtons: {
      flexDirection: 'row',
      gap: theme.spacing.s,
    },
    footerButton: {
      flex: 1,
    },
    deleteButton: {
      borderColor: theme.colors.error,
    },
    emptyState: {
      padding: theme.spacing.xl,
      alignItems: 'center',
    },
    emptyText: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 16,
    },
    iconButtonCompact: {
      margin: 0,
    },
  });

const PrinterDetailModal: React.FC<PrinterDetailModalProps> = ({
  visible,
  onDismiss,
  printer,
  onEdit,
  onDelete,
  onTestPrint,
  isDeleting = false,
  isTestPrinting = false,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => getStyles(theme), [theme]);

  if (!printer && visible) {
    return (
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onDismiss}
          contentContainerStyle={styles.modalContent}
        >
          <View style={styles.emptyState}>
            <Text style={styles.emptyText}>No se encontr la impresora</Text>
          </View>
        </Modal>
      </Portal>
    );
  }

  if (!printer) return null;

  const getConnectionInfo = () => {
    if (printer.connectionType === 'NETWORK') {
      return `${printer.ipAddress || 'N/A'}:${printer.port || 9100}`;
    }
    return printer.path || 'N/A';
  };

  const formatDate = (dateString?: string) => {
    if (!dateString) return 'N/A';
    return new Date(dateString).toLocaleDateString('es-ES', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalContent}
      >
        <View>
          <Surface style={styles.header}>
            <View style={styles.headerContent}>
              <View style={styles.headerTextContainer}>
                <Text style={styles.headerTitle}>{printer.name}</Text>
                <Text style={styles.headerSubtitle}>
                  {printer.connectionType}  {getConnectionInfo()}
                </Text>
              </View>
              <IconButton
                icon="close"
                size={24}
                iconColor={theme.colors.onPrimary}
                onPress={onDismiss}
                style={styles.closeButton}
              />
            </View>
          </Surface>

          <ScrollView
            style={styles.scrollView}
            contentContainerStyle={styles.scrollContent}
          >
            <View style={styles.section}>
              <View style={styles.statusContainer}>
                <Chip
                  mode="flat"
                  style={[
                    styles.statusChip,
                    printer.isActive ? styles.activeChip : styles.inactiveChip,
                  ]}
                  textStyle={{
                    color: printer.isActive
                      ? theme.colors.onPrimaryContainer
                      : theme.colors.onErrorContainer,
                  }}
                >
                  {printer.isActive ? 'Activa' : 'Inactiva'}
                </Chip>
                {printer.isDefaultPrinter && (
                  <Chip
                    mode="flat"
                    style={[styles.statusChip, styles.activeChip]}
                    icon="star"
                    textStyle={{ color: theme.colors.onPrimaryContainer }}
                  >
                    Predeterminada
                  </Chip>
                )}
              </View>

              <View style={styles.featuresGrid}>
                {printer.autoDeliveryPrint && (
                  <Surface style={styles.featureCard}>
                    <View style={styles.featureIcon}>
                      <IconButton
                        icon="home-export-outline"
                        size={16}
                        iconColor={theme.colors.onSecondaryContainer}
                        style={styles.iconButtonCompact}
                      />
                    </View>
                    <Text style={styles.featureText}>
                      Impresin automtica para domicilio
                    </Text>
                  </Surface>
                )}
                {printer.autoPickupPrint && (
                  <Surface style={styles.featureCard}>
                    <View style={styles.featureIcon}>
                      <IconButton
                        icon="bag-checked"
                        size={16}
                        iconColor={theme.colors.onSecondaryContainer}
                        style={styles.iconButtonCompact}
                      />
                    </View>
                    <Text style={styles.featureText}>
                      Impresin automtica para llevar
                    </Text>
                  </Surface>
                )}
              </View>
            </View>

            <Divider style={styles.divider} />

            <View style={styles.section}>
              <Text style={styles.sectionTitle}>Informacin de Conexin</Text>

              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Tipo de conexin</Text>
                <Text style={styles.infoValue}>{printer.connectionType}</Text>
              </View>

              {printer.connectionType === 'NETWORK' && (
                <>
                  <View style={styles.infoRow}>
                    <Text style={styles.infoLabel}>Direccin IP</Text>
                    <Text style={styles.infoValue}>
                      {printer.ipAddress || 'N/A'}
                    </Text>
                  </View>
                  <View style={styles.infoRow}>
                    <Text style={styles.infoLabel}>Puerto</Text>
                    <Text style={styles.infoValue}>
                      {printer.port || 'N/A'}
                    </Text>
                  </View>
                  {printer.macAddress && (
                    <View style={styles.infoRow}>
                      <Text style={styles.infoLabel}>Direccin MAC</Text>
                      <Text style={styles.infoValue}>{printer.macAddress}</Text>
                    </View>
                  )}
                </>
              )}

              {printer.connectionType !== 'NETWORK' && printer.path && (
                <View style={styles.infoRow}>
                  <Text style={styles.infoLabel}>Ruta/ID</Text>
                  <Text style={styles.infoValue}>{printer.path}</Text>
                </View>
              )}
            </View>

            <Divider style={styles.divider} />

            <View style={styles.section}>
              <Text style={styles.sectionTitle}>Configuracin del Papel</Text>

              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Ancho del papel</Text>
                <Text style={styles.infoValue}>{printer.paperWidth}mm</Text>
              </View>
              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Caracteres por lnea</Text>
                <Text style={styles.infoValue}>
                  {printer.charactersPerLine}
                </Text>
              </View>
              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Corte automtico</Text>
                <Text style={styles.infoValue}>
                  {printer.cutPaper ? 'S' : 'No'}
                </Text>
              </View>
              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Lneas de avance</Text>
                <Text style={styles.infoValue}>{printer.feedLines}</Text>
              </View>
            </View>

            <Divider style={styles.divider} />

            <View style={styles.section}>
              <Text style={styles.sectionTitle}>Informacin Adicional</Text>

              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>Creada</Text>
                <Text style={styles.infoValue}>
                  {formatDate(printer.createdAt)}
                </Text>
              </View>
              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>ltima actualizacin</Text>
                <Text style={styles.infoValue}>
                  {formatDate(printer.updatedAt)}
                </Text>
              </View>
            </View>
          </ScrollView>

          <View style={styles.footer}>
            {onTestPrint && (
              <Button
                mode="outlined"
                icon="printer-check"
                onPress={onTestPrint}
                loading={isTestPrinting}
                disabled={isTestPrinting || isDeleting}
                style={styles.testPrintButton}
              >
                Imprimir Ticket de Prueba
              </Button>
            )}

            <View style={styles.footerButtons}>
              {onEdit && (
                <Button
                  mode="contained-tonal"
                  onPress={onEdit}
                  disabled={isDeleting || isTestPrinting}
                  style={styles.footerButton}
                >
                  Editar
                </Button>
              )}
              {onDelete && (
                <Button
                  mode="outlined"
                  onPress={onDelete}
                  loading={isDeleting}
                  disabled={isDeleting || isTestPrinting}
                  style={[styles.footerButton, styles.deleteButton]}
                  textColor={theme.colors.error}
                >
                  Eliminar
                </Button>
              )}
            </View>
          </View>
        </View>
      </Modal>
    </Portal>
  );
};

export default PrinterDetailModal;

================
File: app/src/modules/printers/components/PrinterDiscoveryModal.tsx
================
import React, { useEffect, useMemo } from 'react';
import { View, StyleSheet } from 'react-native';
import { FlashList, ListRenderItemInfo } from '@shopify/flash-list';
import {
  Modal,
  Portal,
  Text,
  ActivityIndicator,
  List,
  Icon,
  Divider,
  IconButton,
  Appbar,
} from 'react-native-paper';
import {
  useDiscoverPrinters,
  useTestPrintDiscoveredPrinter,
} from '../hooks/usePrintersQueries';
import { DiscoveredPrinter } from '../types/printer.types';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { getApiErrorMessage } from '@/app/lib/errorMapping';

interface PrinterDiscoveryModalProps {
  visible: boolean;
  onDismiss: () => void;
  onPrinterSelect: (printer: DiscoveredPrinter) => void;
}

const PrinterDiscoveryModal: React.FC<PrinterDiscoveryModalProps> = ({
  visible,
  onDismiss,
  onPrinterSelect,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const discoverMutation = useDiscoverPrinters();
  const testPrintMutation = useTestPrintDiscoveredPrinter();

  useEffect(() => {
    if (visible) {
      discoverMutation.mutate(undefined, {
        onError: (error) => {
          showSnackbar({
            message: `Error descubriendo impresoras: ${getApiErrorMessage(error)}`,
            type: 'error',
          });
        },
      });
    }
  }, [visible, discoverMutation, showSnackbar]);

  const handleRescan = () => {
    discoverMutation.mutate(undefined);
  };

  const handleTestPrint = (printer: DiscoveredPrinter) => {
    testPrintMutation.mutate(printer);
  };

  const renderPrinterItem = ({
    item,
  }: ListRenderItemInfo<DiscoveredPrinter>) => (
    <List.Item
      title={item.name || item.ip}
      description={`IP: ${item.ip}:${item.port}${item.mac ? ` | MAC: ${item.mac}` : ''}${item.model ? ` (${item.model})` : ''}`}
      left={(props) => <List.Icon {...props} icon="printer" />}
      right={(props) => (
        <View style={styles.itemActions}>
          <IconButton
            {...props}
            icon="printer-check"
            size={24}
            onPress={() => handleTestPrint(item)}
            disabled={testPrintMutation.isPending}
            loading={
              testPrintMutation.isPending &&
              testPrintMutation.variables?.ip === item.ip
            }
          />
          <IconButton
            {...props}
            icon="plus"
            size={24}
            onPress={() => onPrinterSelect(item)}
            disabled={testPrintMutation.isPending}
          />
        </View>
      )}
      style={styles.listItem}
      titleStyle={styles.itemTitle}
      descriptionStyle={styles.itemDescription}
    />
  );

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalContent}
        dismissable={
          !discoverMutation.isPending && !testPrintMutation.isPending
        }
      >
        <Appbar.Header style={styles.appBar} elevated>
          <Appbar.BackAction
            onPress={onDismiss}
            disabled={discoverMutation.isPending || testPrintMutation.isPending}
          />
          <Appbar.Content
            title="Descubrir Impresoras"
            titleStyle={styles.appBarTitle}
          />
          <Appbar.Action
            icon="refresh"
            size={32}
            onPress={handleRescan}
            disabled={discoverMutation.isPending || testPrintMutation.isPending}
            color={theme.colors.primary}
          />
        </Appbar.Header>

        <View style={styles.contentContainer}>
          {discoverMutation.isPending && (
            <View style={styles.centeredView}>
              <ActivityIndicator animating={true} size="large" />
              <Text style={styles.statusText}>
                Buscando impresoras en la red...
              </Text>
              <Text style={styles.statusSubText}>
                (Esto puede tardar unos segundos)
              </Text>
            </View>
          )}

          {discoverMutation.isError && !discoverMutation.isPending && (
            <View style={styles.centeredView}>
              <Icon
                source="alert-circle-outline"
                color={theme.colors.error}
                size={48}
              />
              <Text style={styles.errorText}>
                Error al buscar impresoras:{' '}
                {getApiErrorMessage(discoverMutation.error)}
              </Text>
            </View>
          )}

          {discoverMutation.isSuccess && !discoverMutation.isPending && (
            <>
              {discoverMutation.data.length === 0 ? (
                <View style={styles.centeredView}>
                  <Icon
                    source="printer-off"
                    color={theme.colors.onSurfaceVariant}
                    size={48}
                  />
                  <Text style={styles.statusText}>
                    No se encontraron impresoras.
                  </Text>
                  <Text style={styles.statusSubText}>
                    Asegrate de que estn encendidas y en la misma red.
                  </Text>
                </View>
              ) : (
                <>
                  <Text style={styles.foundText}>Impresoras encontradas:</Text>
                  <FlashList
                    data={discoverMutation.data}
                    renderItem={renderPrinterItem}
                    keyExtractor={(item: DiscoveredPrinter) =>
                      `${item.ip}:${item.port}`
                    }
                    estimatedItemSize={70}
                    ItemSeparatorComponent={() => (
                      <Divider style={styles.divider} />
                    )}
                  />
                </>
              )}
            </>
          )}
        </View>
      </Modal>
    </Portal>
  );
};

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    modalContent: {
      backgroundColor: theme.colors.background,

      width: '100%',
      height: '100%',
      margin: 0,

      justifyContent: 'flex-start',
    },
    appBar: {
      backgroundColor: theme.colors.elevation.level2,
    },
    appBarTitle: {
      ...theme.fonts.titleMedium,
      color: theme.colors.onSurface,
      fontWeight: 'bold',
      textAlign: 'center',
    },
    contentContainer: {
      flex: 1,
      padding: theme.spacing.m,
    },
    centeredView: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.l,
    },
    statusText: {
      marginTop: theme.spacing.m,
      fontSize: 16,
      textAlign: 'center',
      color: theme.colors.onSurface,
    },
    statusSubText: {
      marginTop: theme.spacing.xs,
      fontSize: 14,
      textAlign: 'center',
      color: theme.colors.onSurfaceVariant,
    },
    errorText: {
      marginTop: theme.spacing.m,
      color: theme.colors.error,
      textAlign: 'center',
      marginBottom: theme.spacing.m,
    },
    foundText: {
      fontSize: 16,
      fontWeight: 'bold',
      marginBottom: theme.spacing.m,
      color: theme.colors.primary,
    },
    list: {
      flex: 1,
      marginBottom: theme.spacing.m,
    },
    listItem: {
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness,
      marginBottom: theme.spacing.xs,
    },
    itemTitle: {
      fontWeight: '500',
    },
    itemDescription: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    itemActions: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    divider: {
      height: 0,
    },
    button: {
      marginTop: theme.spacing.m,
      minWidth: 150,
    },
  });

export default PrinterDiscoveryModal;

================
File: app/src/modules/printers/components/PrinterFormModal.tsx
================
import React, { useEffect, useMemo } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  Switch,
  HelperText,
  ActivityIndicator,
  RadioButton,
} from 'react-native-paper';
import { useForm, Controller, SubmitHandler } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';

import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import {
  PrinterFormData,
  printerFormSchema,
  ThermalPrinter,
  CreateThermalPrinterDto,
  UpdateThermalPrinterDto,
} from '../schema/printer.schema';
import {
  useCreatePrinterMutation,
  useUpdatePrinterMutation,
} from '../hooks/usePrintersQueries';
import AnimatedLabelInput from '../../../app/components/common/AnimatedLabelInput';
import PrinterAdvancedConfig from './PrinterAdvancedConfig';

interface PrinterFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  editingItem: ThermalPrinter | null;
  initialDataFromDiscovery?: Partial<PrinterFormData>;
}

const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    modalSurface: {
      padding: 0,
      margin: theme.spacing.l,
      borderRadius: theme.roundness * 2,
      elevation: 4,
      backgroundColor: theme.colors.background,
      maxHeight: '90%',
      overflow: 'hidden',
    },
    modalHeader: {
      backgroundColor: theme.colors.primary,
      paddingVertical: theme.spacing.m,
      paddingHorizontal: theme.spacing.l,
    },
    formContainer: {
      maxHeight: '100%',
    },
    scrollViewContent: {
      padding: theme.spacing.l,
      paddingBottom: theme.spacing.xl,
    },
    modalTitle: {
      color: theme.colors.onPrimary,
      fontWeight: '700',
      textAlign: 'center',
    },
    input: {
      marginBottom: theme.spacing.m,
    },
    switchLabel: {
      color: theme.colors.onSurfaceVariant,
      marginRight: theme.spacing.m,
      fontSize: 16,
      flexShrink: 1,
    },
    switchComponentContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      marginBottom: theme.spacing.m,
      paddingVertical: theme.spacing.s,
    },
    radioGroupContainer: {
      marginBottom: theme.spacing.m,
    },
    radioGroupLabel: {
      marginBottom: theme.spacing.xs,
      color: theme.colors.onSurfaceVariant,
      fontSize: 12,
    },
    radioGroupHorizontal: {
      flexDirection: 'row',
      justifyContent: 'space-around',
      flexWrap: 'wrap',
    },
    radioButtonItem: {
      flexDirection: 'row',
      alignItems: 'center',
      marginRight: theme.spacing.s,
      paddingVertical: 0,
    },
    radioLabel: {
      fontSize: 14,
    },
    modalActions: {
      flexDirection: 'row',
      justifyContent: 'center',
      paddingVertical: theme.spacing.m,
      paddingHorizontal: theme.spacing.l,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
      gap: theme.spacing.m,
    },
    formButton: {
      borderRadius: theme.roundness,
      paddingHorizontal: theme.spacing.xs,
      flex: 1,
      maxWidth: 200,
    },
    cancelButton: {},
    loadingOverlay: {
      ...StyleSheet.absoluteFillObject,
      backgroundColor: 'rgba(0, 0, 0, 0.3)',
      justifyContent: 'center',
      alignItems: 'center',
      borderRadius: theme.roundness * 2,
      zIndex: 10,
    },
    helperText: {
      marginTop: -theme.spacing.s,
      marginBottom: theme.spacing.s,
    },
  });

const PrinterFormModal: React.FC<PrinterFormModalProps> = ({
  visible,
  onDismiss,
  editingItem,
  initialDataFromDiscovery,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => getStyles(theme), [theme]);
  const isEditing = !!editingItem;

  const createMutation = useCreatePrinterMutation();
  const updateMutation = useUpdatePrinterMutation();

  const isSubmitting = createMutation.isPending || updateMutation.isPending;

  const defaultValues = useMemo((): PrinterFormData => {
    const baseDefaults: PrinterFormData = {
      name: '',
      connectionType: 'NETWORK',
      ipAddress: undefined,
      port: undefined,
      path: undefined,
      isActive: true,
      macAddress: undefined,
      isDefaultPrinter: false,
      autoDeliveryPrint: false,
      autoPickupPrint: false,
      paperWidth: 80,
      charactersPerLine: 48,
      cutPaper: true,
      feedLines: 3,
    };
    if (isEditing && editingItem) {
      return {
        name: editingItem.name,
        connectionType: editingItem.connectionType,
        ipAddress: editingItem.ipAddress ?? undefined,
        port: editingItem.port ?? undefined,
        path: editingItem.path ?? undefined,
        isActive: editingItem.isActive,
        macAddress: editingItem.macAddress ?? undefined,
        isDefaultPrinter: editingItem.isDefaultPrinter ?? false,
        autoDeliveryPrint: editingItem.autoDeliveryPrint ?? false,
        autoPickupPrint: editingItem.autoPickupPrint ?? false,
        paperWidth: editingItem.paperWidth ?? 80,
        charactersPerLine: editingItem.charactersPerLine ?? 48,
        cutPaper: editingItem.cutPaper ?? true,
        feedLines: editingItem.feedLines ?? 3,
      };
    }
    if (!isEditing && initialDataFromDiscovery) {
      return {
        ...baseDefaults,
        name:
          initialDataFromDiscovery.name ||
          `Impresora ${initialDataFromDiscovery.ipAddress}`,
        connectionType: 'NETWORK',
        ipAddress: initialDataFromDiscovery.ipAddress,
        port: initialDataFromDiscovery.port,
        macAddress: initialDataFromDiscovery.macAddress,
      };
    }
    return baseDefaults;
  }, [editingItem, isEditing, initialDataFromDiscovery]);

  const {
    control,
    handleSubmit,
    reset,
    watch,
    formState: { errors },
  } = useForm<PrinterFormData>({
    resolver: zodResolver(printerFormSchema),
    defaultValues: defaultValues,
  });

  const connectionType = watch('connectionType');

  useEffect(() => {
    if (visible) {
      reset(defaultValues);
    }
  }, [visible, editingItem, initialDataFromDiscovery, reset, defaultValues]);

  const onSubmit: SubmitHandler<PrinterFormData> = async (formData) => {
    const dataToSend = { ...formData };
    if (dataToSend.connectionType === 'NETWORK') {
      dataToSend.path = undefined;
    } else {
      dataToSend.ipAddress = undefined;
      dataToSend.port = undefined;
    }
    if (dataToSend.port && typeof dataToSend.port === 'string') {
      dataToSend.port = parseInt(dataToSend.port, 10);
      if (isNaN(dataToSend.port)) {
        dataToSend.port = undefined;
      }
    }

    try {
      if (isEditing && editingItem) {
        await updateMutation.mutateAsync({
          id: editingItem.id,
          data: dataToSend as UpdateThermalPrinterDto,
        });
      } else {
        await createMutation.mutateAsync(dataToSend as CreateThermalPrinterDto);
      }
      onDismiss();
    } catch (error) {}
  };

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalSurface}
        dismissable={!isSubmitting}
      >
        <View style={styles.formContainer}>
          <View style={styles.modalHeader}>
            <Text variant="titleLarge" style={styles.modalTitle}>
              {isEditing ? 'Editar Impresora' : 'Nueva Impresora'}
            </Text>
          </View>

          <ScrollView contentContainerStyle={styles.scrollViewContent}>
            <Controller
              name="name"
              control={control}
              render={({ field: { onChange, onBlur, value } }) => (
                <AnimatedLabelInput
                  label="Nombre *"
                  value={value}
                  onChangeText={onChange}
                  onBlur={onBlur}
                  error={!!errors.name}
                  disabled={isSubmitting}
                  containerStyle={styles.input}
                />
              )}
            />
            {errors.name && (
              <HelperText
                type="error"
                visible={!!errors.name}
                style={styles.helperText}
              >
                {errors.name.message}
              </HelperText>
            )}

            <View style={styles.radioGroupContainer}>
              <Text style={styles.radioGroupLabel}>Tipo de Conexin *</Text>
              <Controller
                name="connectionType"
                control={control}
                render={({ field: { onChange, value } }) => (
                  <RadioButton.Group onValueChange={onChange} value={value}>
                    <View style={styles.radioGroupHorizontal}>
                      <RadioButton.Item
                        label="Red"
                        value="NETWORK"
                        style={styles.radioButtonItem}
                        labelStyle={styles.radioLabel}
                        position="leading"
                        disabled={isSubmitting}
                      />
                      <RadioButton.Item
                        label="USB"
                        value="USB"
                        style={styles.radioButtonItem}
                        labelStyle={styles.radioLabel}
                        position="leading"
                        disabled={true}
                      />
                    </View>
                  </RadioButton.Group>
                )}
              />
              {errors.connectionType && (
                <HelperText
                  type="error"
                  visible={!!errors.connectionType}
                  style={styles.helperText}
                >
                  {errors.connectionType.message}
                </HelperText>
              )}
            </View>

            {connectionType === 'NETWORK' && (
              <>
                <Controller
                  name="ipAddress"
                  control={control}
                  render={({ field: { onChange, onBlur, value } }) => (
                    <AnimatedLabelInput
                      label="Direccin IP *"
                      value={value ?? ''}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.ipAddress}
                      disabled={isSubmitting}
                      containerStyle={styles.input}
                      keyboardType="decimal-pad"
                    />
                  )}
                />
                {errors.ipAddress && (
                  <HelperText
                    type="error"
                    visible={!!errors.ipAddress}
                    style={styles.helperText}
                  >
                    {errors.ipAddress.message}
                  </HelperText>
                )}

                <Controller
                  name="port"
                  control={control}
                  render={({ field: { onChange, onBlur, value } }) => (
                    <AnimatedLabelInput
                      label="Puerto *"
                      value={
                        value !== undefined && value !== null
                          ? String(value)
                          : ''
                      }
                      onChangeText={(text) => {
                        if (!text) {
                          onChange(undefined);
                          return;
                        }
                        const parsedPort = parseInt(text, 10);
                        onChange(isNaN(parsedPort) ? undefined : parsedPort);
                      }}
                      onBlur={onBlur}
                      error={!!errors.port}
                      disabled={isSubmitting}
                      containerStyle={styles.input}
                      keyboardType="number-pad"
                    />
                  )}
                />
                {errors.port && (
                  <HelperText
                    type="error"
                    visible={!!errors.port}
                    style={styles.helperText}
                  >
                    {errors.port.message}
                  </HelperText>
                )}

                <Controller
                  name="macAddress"
                  control={control}
                  render={({ field: { onChange, onBlur, value } }) => (
                    <AnimatedLabelInput
                      label="Direccin MAC (Opcional)"
                      value={value ?? ''}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.macAddress}
                      disabled={isSubmitting}
                      containerStyle={styles.input}
                      autoCapitalize="characters"
                    />
                  )}
                />
                {errors.macAddress && (
                  <HelperText
                    type="error"
                    visible={!!errors.macAddress}
                    style={styles.helperText}
                  >
                    {errors.macAddress.message}
                  </HelperText>
                )}
              </>
            )}

            {connectionType !== 'NETWORK' && (
              <>
                <Controller
                  name="path"
                  control={control}
                  render={({ field: { onChange, onBlur, value } }) => (
                    <AnimatedLabelInput
                      label="Ruta / Identificador *"
                      value={value ?? ''}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.path}
                      disabled={isSubmitting}
                      containerStyle={styles.input}
                      placeholder={
                        connectionType === 'USB'
                          ? '/dev/usb/lp0'
                          : connectionType === 'SERIAL'
                            ? '/dev/ttyS0'
                            : 'Direccin BT'
                      }
                    />
                  )}
                />
                {errors.path && (
                  <HelperText
                    type="error"
                    visible={!!errors.path}
                    style={styles.helperText}
                  >
                    {errors.path.message}
                  </HelperText>
                )}
              </>
            )}

            <View style={styles.switchComponentContainer}>
              <Text variant="bodyLarge" style={styles.switchLabel}>
                Activa
              </Text>
              <Controller
                name="isActive"
                control={control}
                render={({ field: { onChange, value } }) => (
                  <Switch
                    value={value}
                    onValueChange={onChange}
                    disabled={isSubmitting}
                  />
                )}
              />
            </View>
            {errors.isActive && (
              <HelperText
                type="error"
                visible={!!errors.isActive}
                style={styles.helperText}
              >
                {errors.isActive.message}
              </HelperText>
            )}

            <View style={styles.switchComponentContainer}>
              <Text variant="bodyLarge" style={styles.switchLabel}>
                Impresora Predeterminada
              </Text>
              <Controller
                name="isDefaultPrinter"
                control={control}
                render={({ field: { onChange, value } }) => (
                  <Switch
                    value={value}
                    onValueChange={onChange}
                    disabled={isSubmitting}
                  />
                )}
              />
            </View>

            <View style={styles.switchComponentContainer}>
              <Text variant="bodyLarge" style={styles.switchLabel}>
                Imprimir Automticamente Domicilio
              </Text>
              <Controller
                name="autoDeliveryPrint"
                control={control}
                render={({ field: { onChange, value } }) => (
                  <Switch
                    value={value}
                    onValueChange={onChange}
                    disabled={isSubmitting}
                  />
                )}
              />
            </View>

            <View style={styles.switchComponentContainer}>
              <Text variant="bodyLarge" style={styles.switchLabel}>
                Imprimir Automticamente Para Llevar
              </Text>
              <Controller
                name="autoPickupPrint"
                control={control}
                render={({ field: { onChange, value } }) => (
                  <Switch
                    value={value}
                    onValueChange={onChange}
                    disabled={isSubmitting}
                  />
                )}
              />
            </View>

            <PrinterAdvancedConfig
              control={control}
              errors={errors}
              isSubmitting={isSubmitting}
            />
          </ScrollView>

          {isSubmitting && (
            <View style={styles.loadingOverlay}>
              <ActivityIndicator
                animating={true}
                size="large"
                color={theme.colors.primary}
              />
            </View>
          )}

          <View style={styles.modalActions}>
            <Button
              mode="outlined"
              onPress={onDismiss}
              style={[styles.formButton, styles.cancelButton]}
              disabled={isSubmitting}
            >
              Cancelar
            </Button>
            <Button
              mode="contained"
              onPress={handleSubmit(onSubmit)}
              loading={isSubmitting}
              disabled={isSubmitting}
              style={styles.formButton}
            >
              {isEditing ? 'Guardar' : 'Crear'}
            </Button>
          </View>
        </View>
      </Modal>
    </Portal>
  );
};

export default PrinterFormModal;

================
File: app/src/modules/printers/hooks/usePrintersQueries.ts
================
import {
  useMutation,
  UseMutationResult,
  useQuery,
  UseQueryResult,
  useQueryClient,
} from '@tanstack/react-query';
import { printerService } from '../services/printerService';
import {
  DiscoveredPrinter,
  ThermalPrinter,
  CreateThermalPrinterDto,
  UpdateThermalPrinterDto,
  FindAllThermalPrintersDto,
} from '../types/printer.types';
import { ApiError } from '../../../app/lib/errors';
import { PaginatedResponse } from '../../../app/types/api.types';
import { useSnackbarStore } from '../../../app/store/snackbarStore';
import { getApiErrorMessage } from '../../../app/lib/errorMapping';

const printerKeys = {
  all: ['thermalPrinters'] as const,
  lists: () => [...printerKeys.all, 'list'] as const,
  list: (filters: FindAllThermalPrintersDto) =>
    [...printerKeys.lists(), filters] as const,
  details: () => [...printerKeys.all, 'detail'] as const,
  detail: (id: string) => [...printerKeys.details(), id] as const,
  discover: ['discoverPrinters'] as const,
};

export const useDiscoverPrinters = (): UseMutationResult<
  DiscoveredPrinter[],
  ApiError,
  number | undefined
> => {
  return useMutation<DiscoveredPrinter[], ApiError, number | undefined>({
    mutationFn: (duration: number | undefined) =>
      printerService.discoverPrinters(duration),
  });
};

export const usePrintersQuery = (
  params: FindAllThermalPrintersDto = { page: 1, limit: 10 },
  options?: { enabled?: boolean },
): UseQueryResult<PaginatedResponse<ThermalPrinter>, ApiError> => {
  const queryKey = printerKeys.list(params);
  return useQuery<PaginatedResponse<ThermalPrinter>, ApiError>({
    queryKey: queryKey,
    queryFn: () => printerService.findAllPrinters(params),
    enabled: options?.enabled ?? true,
  });
};

export const usePrinterQuery = (
  id: string | undefined,
  options?: { enabled?: boolean },
): UseQueryResult<ThermalPrinter, ApiError> => {
  const queryKey = printerKeys.detail(id!);
  return useQuery<ThermalPrinter, ApiError>({
    queryKey: queryKey,
    queryFn: () => printerService.findOnePrinter(id!),
    enabled: !!id && (options?.enabled ?? true),
  });
};

export const useCreatePrinterMutation = (): UseMutationResult<
  ThermalPrinter,
  ApiError,
  CreateThermalPrinterDto
> => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<ThermalPrinter, ApiError, CreateThermalPrinterDto>({
    mutationFn: printerService.createPrinter,
    onSuccess: (newPrinter) => {
      queryClient.invalidateQueries({ queryKey: printerKeys.lists() });
      showSnackbar({
        message: `Impresora "${newPrinter.name}" creada con xito`,
        type: 'success',
      });
    },
    onError: (error) => {
      showSnackbar({
        message: getApiErrorMessage(error),
        type: 'error',
      });
    },
  });
};

export const useUpdatePrinterMutation = (): UseMutationResult<
  ThermalPrinter,
  ApiError,
  { id: string; data: UpdateThermalPrinterDto }
> => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<
    ThermalPrinter,
    ApiError,
    { id: string; data: UpdateThermalPrinterDto }
  >({
    mutationFn: ({ id, data }) => printerService.updatePrinter(id, data),
    onSuccess: (updatedPrinter, variables) => {
      queryClient.invalidateQueries({ queryKey: printerKeys.lists() });
      queryClient.invalidateQueries({
        queryKey: printerKeys.detail(variables.id),
      });
      showSnackbar({
        message: `Impresora "${updatedPrinter.name}" actualizada`,
        type: 'success',
      });
    },
    onError: (error, _variables) => {
      showSnackbar({
        message: getApiErrorMessage(error),
        type: 'error',
      });
    },
  });
};

export const useDeletePrinterMutation = (): UseMutationResult<
  void,
  ApiError,
  string
> => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<void, ApiError, string>({
    mutationFn: printerService.deletePrinter,
    onSuccess: (_, deletedId) => {
      queryClient.invalidateQueries({ queryKey: printerKeys.lists() });
      queryClient.removeQueries({ queryKey: printerKeys.detail(deletedId) });
      showSnackbar({ message: 'Impresora eliminada', type: 'success' });
    },
    onError: (error) => {
      showSnackbar({
        message: `Error al eliminar impresora: ${getApiErrorMessage(error)}`,
        type: 'error',
      });
    },
  });
};

export const usePingPrinterMutation = (): UseMutationResult<
  { status: string },
  ApiError,
  string
> => {
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<{ status: string }, ApiError, string>({
    mutationFn: (printerId: string) => printerService.pingPrinter(printerId),
    onSuccess: (data, _printerId) => {
      const message =
        data.status === 'online'
          ? `Impresora conectada (ping exitoso).`
          : `Impresora desconectada (ping fallido).`;
      const type = data.status === 'online' ? 'success' : 'warning';
      showSnackbar({ message, type });
    },
    onError: (error, _printerId) => {
      showSnackbar({
        message: `Error al hacer ping a la impresora: ${getApiErrorMessage(error)}`,
        type: 'error',
      });
    },
  });
};

export const useTestPrintDiscoveredPrinter = (): UseMutationResult<
  { success: boolean; message?: string },
  ApiError,
  DiscoveredPrinter
> => {
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<
    { success: boolean; message?: string },
    ApiError,
    DiscoveredPrinter
  >({
    mutationFn: (printer: DiscoveredPrinter) =>
      printerService.testPrintDiscoveredPrinter(printer),
    onSuccess: (data) => {
      showSnackbar({
        message: data.message || 'Ticket de prueba impreso correctamente',
        type: 'success',
      });
    },
    onError: (error) => {
      showSnackbar({
        message: `Error al imprimir ticket de prueba: ${getApiErrorMessage(error)}`,
        type: 'error',
      });
    },
  });
};

export const useTestPrintPrinter = (): UseMutationResult<
  { success: boolean; message?: string },
  ApiError,
  string
> => {
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<{ success: boolean; message?: string }, ApiError, string>({
    mutationFn: (printerId: string) =>
      printerService.testPrintPrinter(printerId),
    onSuccess: (data) => {
      showSnackbar({
        message: data.message || 'Ticket de prueba impreso correctamente',
        type: 'success',
      });
    },
    onError: (error) => {
      showSnackbar({
        message: `Error al imprimir ticket de prueba: ${getApiErrorMessage(error)}`,
        type: 'error',
      });
    },
  });
};

================
File: app/src/modules/receipts/hooks/useReceiptsQueries.ts
================
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import {
  receiptService,
  receiptQueryOptions,
} from '../services/receiptService';
import { useSnackbarStore } from '@/app/store/snackbarStore';

import type {
  ReceiptFilters,
  ReceiptsListResponse,
  Receipt,
} from '../schema/receipt.schema';

export const useReceipts = (filters?: ReceiptFilters) => {
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const query = useQuery<ReceiptsListResponse, Error>({
    ...receiptQueryOptions.receipts(filters || {}),
  });

  if (query.error) {
    showSnackbar({
      message: query.error.message || 'Error al cargar los recibos',
      type: 'error',
    });
  }

  return query;
};

export const useReceipt = (id: string) => {
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const query = useQuery<Receipt, Error>({
    ...receiptQueryOptions.receipt(id),
  });

  if (query.error) {
    showSnackbar({
      message: query.error.message || 'Error al cargar el recibo',
      type: 'error',
    });
  }

  return query;
};

export const useRecoverOrder = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: (orderId: string) => receiptService.recoverOrder(orderId),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['receipts'] });
      queryClient.invalidateQueries({ queryKey: ['orders'] });
      showSnackbar({
        message: 'Orden recuperada exitosamente',
        type: 'success',
      });
    },
    onError: (error: Error) => {
      showSnackbar({
        message: error.message || 'Error al recuperar la orden',
        type: 'error',
      });
    },
  });
};

================
File: app/src/modules/receipts/schema/receipt.schema.ts
================
import { z } from 'zod';
import {
  orderTypeSchema,
  orderStatusSchema,
} from '@/app/schemas/domain/order.schema';

export type OrderType = z.infer<typeof orderTypeSchema>;
export type OrderStatus = z.infer<typeof orderStatusSchema>;

export const receiptListSchema = z.object({
  id: z.string(),
  shiftOrderNumber: z.number(),
  orderType: orderTypeSchema,
  orderStatus: orderStatusSchema,
  total: z.union([z.number(), z.string()]),
  createdAt: z.string(),
  scheduledAt: z.string().optional(),
  finalizedAt: z.string().optional(),
  notes: z.string().optional(),
  paymentsSummary: z
    .object({
      totalPaid: z.number(),
    })
    .optional(),
  table: z
    .object({
      id: z.string(),
      number: z.string(),
      name: z.string(),
      isTemporary: z.boolean(),
      area: z
        .object({
          name: z.string(),
        })
        .optional(),
    })
    .optional(),
  deliveryInfo: z
    .object({
      recipientName: z.string().optional(),
      recipientPhone: z.string().optional(),
      fullAddress: z.string().optional(),
    })
    .optional(),
  preparationScreenStatuses: z
    .array(
      z.object({
        name: z.string(),
        status: z.enum(['PENDING', 'IN_PROGRESS', 'READY']),
      }),
    )
    .optional(),
  ticketImpressionCount: z.number().optional(),
  createdBy: z
    .object({
      username: z.string(),
      firstName: z.string().nullable().optional(),
      lastName: z.string().nullable().optional(),
    })
    .optional(),
  isFromWhatsApp: z.boolean().optional(),
});

export type ReceiptList = z.infer<typeof receiptListSchema>;

export const receiptSchema = z.object({
  id: z.string(),
  shiftOrderNumber: z.number(),
  orderType: orderTypeSchema,
  orderStatus: orderStatusSchema,
  total: z.union([z.number(), z.string()]),
  subtotal: z.union([z.number(), z.string()]).optional(),
  createdAt: z.string(),
  updatedAt: z.string(),
  finalizedAt: z.string().optional(),
  scheduledAt: z.string().optional(),
  notes: z.string().optional(),
  userId: z.string().optional(),
  tableId: z.string().optional(),
  customerId: z.string().optional(),
  isFromWhatsApp: z.boolean().optional(),
  estimatedDeliveryTime: z.string().optional(),
  user: z
    .object({
      id: z.string(),
      firstName: z.string().optional(),
      lastName: z.string().optional(),
      username: z.string().optional(),
    })
    .optional(),
  table: z
    .object({
      id: z.string(),
      number: z.string(),
      name: z.string(),
      isTemporary: z.boolean(),
      area: z
        .object({
          id: z.string(),
          name: z.string(),
        })
        .optional(),
    })
    .optional(),
  customer: z
    .object({
      id: z.string(),
      name: z.string(),
      phone: z.string().optional(),
      email: z.string().optional(),
    })
    .optional(),
  deliveryInfo: z
    .object({
      id: z.string(),
      recipientName: z.string().optional(),
      recipientPhone: z.string().optional(),
      deliveryInstructions: z.string().optional(),
      fullAddress: z.string().optional(),
      street: z.string().optional(),
      number: z.string().optional(),
      interiorNumber: z.string().optional(),
      neighborhood: z.string().optional(),
      city: z.string().optional(),
      state: z.string().optional(),
      zipCode: z.string().optional(),
      country: z.string().optional(),
      latitude: z.number().optional(),
      longitude: z.number().optional(),
    })
    .optional(),
  preparationScreens: z.array(z.string()).optional(),
  orderItems: z.array(
    z.object({
      id: z.string(),
      quantity: z.number().optional(),
      basePrice: z.number(),
      finalPrice: z.number(),
      preparationNotes: z.string().optional(),
      preparationStatus: z.string().optional(),
      product: z.object({
        id: z.string(),
        name: z.string(),
        description: z.string().optional(),
        price: z.number(),
      }),
      productVariant: z
        .object({
          id: z.string(),
          name: z.string(),
          price: z.number(),
        })
        .optional(),
      productModifiers: z
        .array(
          z.object({
            id: z.string(),
            name: z.string(),
            price: z.number(),
          }),
        )
        .optional(),
      selectedPizzaCustomizations: z.array(z.any()).optional(),
    }),
  ),
  payments: z
    .array(
      z.object({
        id: z.string(),
        amount: z.number(),
        paymentMethod: z.string(),
        paymentStatus: z.string(),
        createdAt: z.string(),
        updatedAt: z.string(),
      }),
    )
    .optional(),
  adjustments: z
    .array(
      z.object({
        id: z.string(),
        type: z.string(),
        amount: z.number(),
        reason: z.string().optional(),
        createdAt: z.string(),
      }),
    )
    .optional(),
  ticketImpressions: z
    .array(
      z.object({
        id: z.string(),
        ticketType: z.string(),
        impressionTime: z.string(),
        user: z
          .object({
            id: z.string(),
            firstName: z.string().optional(),
            lastName: z.string().optional(),
          })
          .optional(),
        printer: z
          .object({
            id: z.string(),
            name: z.string(),
          })
          .optional(),
      }),
    )
    .optional(),
});

export type Receipt = z.infer<typeof receiptSchema>;

export const receiptsListResponseSchema = z.array(receiptListSchema);
export type ReceiptsListResponse = z.infer<typeof receiptsListResponseSchema>;

export const receiptFiltersSchema = z.object({
  startDate: z.string().optional(),
  endDate: z.string().optional(),
  orderType: orderTypeSchema.optional(),
});

export type ReceiptFilters = z.infer<typeof receiptFiltersSchema>;

================
File: app/src/modules/restaurantConfig/components/WebViewDeliveryCoverageMap.tsx
================
import React, { useRef, useEffect, useState } from 'react';
import { View, StyleSheet, Alert, useWindowDimensions } from 'react-native';
import { WebView } from 'react-native-webview';
import {
  Surface,
  IconButton,
  ActivityIndicator,
  Text,
} from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { DeliveryCoveragePoint } from '../schema/restaurantConfig.schema';
import { useGoogleMapsConfig } from '@/hooks/useGoogleMapsConfig';

interface DeliveryCoverageMapProps {
  initialPolygon?: DeliveryCoveragePoint[] | null;
  isEditing: boolean;
  onChange?: (polygon: DeliveryCoveragePoint[]) => void;
  restaurantLocation?: {
    latitude: number;
    longitude: number;
  };
}

export const WebViewDeliveryCoverageMap: React.FC<DeliveryCoverageMapProps> = ({
  initialPolygon,
  isEditing,
  onChange,
  restaurantLocation,
}) => {
  const theme = useAppTheme();
  const { height } = useWindowDimensions();
  const webViewRef = useRef<WebView>(null);
  const { config: mapsConfig, loading: isLoadingApiKey } =
    useGoogleMapsConfig();
  const apiKey = mapsConfig?.apiKey;

  const styles = React.useMemo(
    () => createStyles(theme, height),
    [theme, height],
  );

  const [mapReady, setMapReady] = useState(false);
  const [isDrawing, setIsDrawing] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [currentPolygon, setCurrentPolygon] = useState<DeliveryCoveragePoint[]>(
    () => {
      return initialPolygon || [];
    },
  );

  // HTML del mapa con Google Maps API
  const mapHtml = apiKey
    ? `
<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      height: 100%;
      width: 100%;
      overflow: hidden;
    }
    #map {
      height: 100%;
      width: 100%;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <script>
    let map;
    let polygon;
    let markers = [];
    let isEditing = false;
    let polygonPath = [];

    function initMap() {
      // Inicializar el mapa
      const initialLocation = ${
        restaurantLocation
          ? `{ lat: ${restaurantLocation.latitude}, lng: ${restaurantLocation.longitude} }`
          : '{ lat: 20.5425, lng: -102.7935 }'
      };
      
      map = new google.maps.Map(document.getElementById('map'), {
        center: initialLocation,
        zoom: 14,
        disableDefaultUI: true,
        zoomControl: true,
        mapTypeControl: false,
        scaleControl: false,
        streetViewControl: false,
        rotateControl: false,
        fullscreenControl: false
      });

      // Escuchar mensajes desde React Native
      window.addEventListener('message', handleMessage);
      
      // Notificar que el mapa est listo
      sendMessage('mapReady', {});
    }

    function handleMessage(event) {
      try {
        const data = JSON.parse(event.data);
        
        switch(data.type) {
          case 'setPolygon':
            setPolygon(data.coordinates);
            break;
          case 'setEditMode':
            setEditMode(data.isEditing);
            break;
          case 'centerOnPolygon':
            centerOnPolygon();
            break;
          case 'clearPolygon':
            clearPolygon();
            break;
        }
      } catch (e) {
        // Error handling message
      }
    }

    function setPolygon(coordinates) {
      // Limpiar polgono anterior
      if (polygon) {
        polygon.setMap(null);
      }
      
      // Limpiar marcadores
      markers.forEach(marker => marker.setMap(null));
      markers = [];
      
      // Convertir coordenadas
      polygonPath = coordinates.map(coord => ({
        lat: coord.lat || coord.latitude,
        lng: coord.lng || coord.longitude
      }));
      
      
      if (polygonPath.length >= 3) {
        // Crear polgono
        polygon = new google.maps.Polygon({
          paths: polygonPath,
          strokeColor: '#FF0000',
          strokeOpacity: 0.8,
          strokeWeight: 3,
          fillColor: '#FF0000',
          fillOpacity: 0.35,
          editable: false,
          draggable: false
        });
        
        polygon.setMap(map);
        
        // Centrar en el polgono
        setTimeout(() => {
          centerOnPolygon();
          // Notificar que el polgono se ha dibujado
          sendMessage('polygonSet', {});
        }, 100);
      }
    }

    function setEditMode(editing) {
      isEditing = editing;
      
      if (isEditing) {
        // Habilitar clicks en el mapa
        google.maps.event.clearListeners(map, 'click');
        map.addListener('click', function(event) {
          addPoint(event.latLng);
        });
        
        // Mostrar marcadores inmediatamente
        updateMarkers();
      } else {
        // Deshabilitar clicks
        google.maps.event.clearListeners(map, 'click');
        
        // Ocultar marcadores
        markers.forEach(marker => marker.setMap(null));
        markers = [];
      }
    }

    function addPoint(latLng) {
      if (!isEditing) return;
      
      polygonPath.push({
        lat: latLng.lat(),
        lng: latLng.lng()
      });
      
      updatePolygon();
      updateMarkers();
      
      // Enviar actualizacin a React Native
      sendMessage('polygonUpdated', {
        coordinates: polygonPath
      });
    }

    function updatePolygon() {
      if (polygon) {
        polygon.setPath(polygonPath);
      } else if (polygonPath.length >= 3) {
        polygon = new google.maps.Polygon({
          paths: polygonPath,
          strokeColor: '#FF0000',
          strokeOpacity: 0.8,
          strokeWeight: 3,
          fillColor: '#FF0000',
          fillOpacity: 0.35
        });
        polygon.setMap(map);
      }
    }

    function updateMarkers() {
      // Limpiar marcadores anteriores
      markers.forEach(marker => marker.setMap(null));
      markers = [];
      
      if (!isEditing) return;
      
      // Crear nuevos marcadores
      polygonPath.forEach((point, index) => {
        const marker = new google.maps.Marker({
          position: point,
          map: map,
          draggable: true,
          label: {
            text: (index + 1).toString(),
            color: 'white',
            fontSize: '12px',
            fontWeight: 'bold'
          },
          icon: {
            path: google.maps.SymbolPath.CIRCLE,
            scale: 20,
            fillColor: '#2563eb',
            fillOpacity: 1,
            strokeColor: 'white',
            strokeWeight: 2
          }
        });
        
        // Permitir arrastrar
        marker.addListener('dragend', function() {
          polygonPath[index] = {
            lat: marker.getPosition().lat(),
            lng: marker.getPosition().lng()
          };
          updatePolygon();
          sendMessage('polygonUpdated', {
            coordinates: polygonPath
          });
        });
        
        // Click para eliminar
        marker.addListener('click', function() {
          polygonPath.splice(index, 1);
          updatePolygon();
          updateMarkers();
          sendMessage('polygonUpdated', {
            coordinates: polygonPath
          });
        });
        
        markers.push(marker);
      });
    }

    function centerOnPolygon() {
      if (polygonPath.length > 0) {
        const bounds = new google.maps.LatLngBounds();
        polygonPath.forEach(point => {
          bounds.extend(point);
        });
        map.fitBounds(bounds);
        
        // Ajustar el zoom si es necesario
        const listener = google.maps.event.addListener(map, 'idle', function() { 
          if (map.getZoom() > 18) {
            map.setZoom(18);
          }
          google.maps.event.removeListener(listener);
        });
      }
    }

    function clearPolygon() {
      polygonPath = [];
      if (polygon) {
        polygon.setMap(null);
        polygon = null;
      }
      markers.forEach(marker => marker.setMap(null));
      markers = [];
      
      sendMessage('polygonUpdated', {
        coordinates: []
      });
    }

    function sendMessage(type, data) {
      try {
        if (window.ReactNativeWebView) {
          window.ReactNativeWebView.postMessage(JSON.stringify({
            type: type,
            ...data
          }));
        }
      } catch (e) {
        // Error sending message
      }
    }
  </script>
  <script async defer
    src="https://maps.googleapis.com/maps/api/js?key=${apiKey}&callback=initMap">
  </script>
</body>
</html>
  `
    : '';

  // Manejar mensajes del WebView
  const handleWebViewMessage = (event: any) => {
    try {
      const data = JSON.parse(event.nativeEvent.data);

      switch (data.type) {
        case 'mapReady':
          setMapReady(true);

          // Enviar polgono inicial si existe
          if (initialPolygon && initialPolygon.length > 0) {
            setTimeout(() => {
              sendMessageToWebView('setPolygon', {
                coordinates: initialPolygon,
              });
            }, 1000);
          } else {
            // Si no hay polgono inicial, ocultar el loading
            setIsLoading(false);
          }
          break;
        case 'polygonSet':
          // El polgono se ha dibujado en el mapa
          setIsLoading(false);
          break;
        case 'polygonUpdated': {
          const newPolygon = data.coordinates;
          setCurrentPolygon(newPolygon);
          if (onChange) {
            onChange(newPolygon);
          }
          break;
        }
      }
    } catch (e) {}
  };

  // Enviar mensaje al WebView
  const sendMessageToWebView = (type: string, data: any) => {
    if (webViewRef.current) {
      const message = JSON.stringify({ type, ...data });
      webViewRef.current.postMessage(message);
    }
  };

  // Actualizar el modo de edicin cuando cambie
  useEffect(() => {
    if (mapReady) {
      sendMessageToWebView('setEditMode', {
        isEditing: isEditing && isDrawing,
      });
    }
  }, [isEditing, isDrawing, mapReady]);

  // Actualizar el polgono cuando cambie desde fuera
  useEffect(() => {
    if (mapReady && initialPolygon && initialPolygon.length > 0) {
      setCurrentPolygon(initialPolygon);
      sendMessageToWebView('setPolygon', { coordinates: initialPolygon });
    }
  }, [initialPolygon, mapReady]);

  // Resetear estados cuando el componente se monta
  useEffect(() => {
    setIsLoading(true);
    setMapReady(false);
  }, []);

  const toggleDrawing = () => {
    if (isDrawing && currentPolygon.length < 3) {
      Alert.alert(
        'rea incompleta',
        'Necesitas al menos 3 puntos para crear un rea de cobertura.',
      );
      return;
    }
    const newDrawingState = !isDrawing;
    setIsDrawing(newDrawingState);

    // Enviar el estado de edicin al mapa inmediatamente
    if (webViewRef.current) {
      const jsCode = `
        if (typeof setEditMode === 'function') {
          setEditMode(${newDrawingState});
        }
        true;
      `;
      webViewRef.current.injectJavaScript(jsCode);
    }
  };

  const clearPolygon = () => {
    sendMessageToWebView('clearPolygon', {});

    // Tambin usar inyeccin directa
    if (webViewRef.current) {
      const jsCode = `
        if (typeof clearPolygon === 'function') {
          clearPolygon();
        }
        true;
      `;
      webViewRef.current.injectJavaScript(jsCode);
    }

    setCurrentPolygon([]);
    setIsDrawing(false);
    if (onChange) {
      onChange([]);
    }
  };

  const centerOnPolygon = () => {
    sendMessageToWebView('centerOnPolygon', {});

    // Tambin usar inyeccin directa
    if (webViewRef.current) {
      const jsCode = `
        if (typeof centerOnPolygon === 'function') {
          centerOnPolygon();
        }
        true;
      `;
      webViewRef.current.injectJavaScript(jsCode);
    }
  };

  // Si estamos cargando la API key o no tenemos HTML, mostrar loading
  if (isLoadingApiKey || !mapHtml) {
    return (
      <View style={[styles.container, styles.loadingContainer]}>
        <Surface style={styles.loadingCard} elevation={3}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
          <Text style={styles.loadingText}>
            Cargando configuracin del mapa...
          </Text>
        </Surface>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <WebView
        ref={webViewRef}
        source={{ html: mapHtml }}
        style={styles.map}
        onMessage={handleWebViewMessage}
        onLoad={() => {
          // Inyectar cdigo JavaScript despus de cargar
          if (
            webViewRef.current &&
            initialPolygon &&
            initialPolygon.length > 0
          ) {
            const jsCode = `
              setTimeout(() => {
                if (typeof setPolygon === 'function') {
                  setPolygon(${JSON.stringify(initialPolygon)});
                }
              }, 1500);
              true;
            `;
            webViewRef.current.injectJavaScript(jsCode);
          }
        }}
        onError={() => {}}
        javaScriptEnabled={true}
        domStorageEnabled={true}
        startInLoadingState={true}
        mixedContentMode="compatibility"
        allowsInlineMediaPlayback={true}
        originWhitelist={['*']}
      />

      {/* Indicador de carga */}
      {isLoading && (
        <View style={styles.loadingContainer}>
          <Surface style={styles.loadingCard} elevation={3}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
            <Text style={styles.loadingText}>Cargando mapa...</Text>
          </Surface>
        </View>
      )}

      {/* Controles flotantes */}
      {isEditing && (
        <View style={styles.controls}>
          <Surface style={styles.controlsCard} elevation={2}>
            <View style={styles.controlsRow}>
              <IconButton
                icon={isDrawing ? 'check' : 'draw'}
                mode="contained"
                containerColor={
                  isDrawing ? theme.colors.primary : theme.colors.secondary
                }
                iconColor={
                  isDrawing ? theme.colors.onPrimary : theme.colors.onSecondary
                }
                size={24}
                onPress={toggleDrawing}
              />
              <IconButton
                icon="crosshairs-gps"
                mode="contained"
                containerColor={theme.colors.tertiaryContainer}
                iconColor={theme.colors.onTertiaryContainer}
                size={24}
                onPress={centerOnPolygon}
                disabled={currentPolygon.length === 0}
              />
              <IconButton
                icon="delete"
                mode="contained"
                containerColor={theme.colors.errorContainer}
                iconColor={theme.colors.onErrorContainer}
                size={24}
                onPress={clearPolygon}
                disabled={currentPolygon.length === 0}
              />
            </View>
          </Surface>
        </View>
      )}

      {/* Botn de centrar cuando no se est editando */}
      {!isEditing && currentPolygon.length > 0 && (
        <View style={styles.centerButtonContainer}>
          <IconButton
            icon="crosshairs-gps"
            mode="contained"
            containerColor={theme.colors.primaryContainer}
            iconColor={theme.colors.onPrimaryContainer}
            size={24}
            onPress={centerOnPolygon}
            style={styles.floatingCenterButton}
          />
        </View>
      )}
    </View>
  );
};

const createStyles = (theme: AppTheme, height: number) =>
  StyleSheet.create({
    container: {
      height: Math.min(height * 0.6, 500),
      width: '100%',
      borderRadius: 16,
      overflow: 'hidden',
      backgroundColor: theme.colors.surfaceVariant,
    },
    map: {
      ...StyleSheet.absoluteFillObject,
    },
    controls: {
      position: 'absolute',
      top: theme.spacing.m,
      right: theme.spacing.m,
    },
    controlsCard: {
      borderRadius: 12,
      padding: theme.spacing.s,
      backgroundColor: theme.colors.surface,
      alignItems: 'center',
      gap: theme.spacing.xs,
    },
    controlsRow: {
      flexDirection: 'row',
      gap: theme.spacing.xs,
    },
    centerButtonContainer: {
      position: 'absolute',
      bottom: theme.spacing.m,
      right: theme.spacing.m,
    },
    floatingCenterButton: {
      elevation: 4,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
    },
    loadingContainer: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      justifyContent: 'center',
      alignItems: 'center',
      backgroundColor: 'rgba(0, 0, 0, 0.3)',
    },
    loadingCard: {
      padding: theme.spacing.xl,
      borderRadius: 16,
      alignItems: 'center',
      backgroundColor: theme.colors.surface,
    },
    loadingText: {
      marginTop: theme.spacing.m,
      fontSize: 16,
      color: theme.colors.onSurface,
      fontWeight: '500',
    },
  });

export default WebViewDeliveryCoverageMap;

================
File: app/src/modules/restaurantConfig/services/restaurantConfigService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import {
  RestaurantConfig,
  UpdateRestaurantConfigDto,
} from '../schema/restaurantConfig.schema';

export const restaurantConfigService = {
  getConfig: async (): Promise<RestaurantConfig> => {
    const response = await apiClient.get<RestaurantConfig>(
      API_PATHS.RESTAURANT_CONFIG,
    );
    return response.data;
  },

  updateConfig: async (
    data: UpdateRestaurantConfigDto,
  ): Promise<RestaurantConfig> => {
    const response = await apiClient.put<RestaurantConfig>(
      API_PATHS.RESTAURANT_CONFIG,
      data,
    );
    return response.data;
  },
};

================
File: app/src/modules/settings/navigation/types.ts
================
export type SettingsStackParamList = {
  ServerSettings: undefined;
};

================
File: app/src/modules/shiftAudit/components/index.ts
================
export { ShiftOrdersModal } from './ShiftOrdersModal';
export { OrderDetailsView } from './OrderDetailsView';
export { OrderHistoryView } from './OrderHistoryView';
export { ShiftSalesSummaryView } from './ShiftSalesSummaryView';

================
File: app/src/modules/shiftAudit/navigation/ShiftAuditStackNavigator.tsx
================
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { ShiftsListScreen } from '../screens/ShiftsListScreen';
import type { ShiftAuditStackParamList } from './types';

const Stack = createNativeStackNavigator<ShiftAuditStackParamList>();

export function ShiftAuditStackNavigator() {
  return (
    <Stack.Navigator
      screenOptions={{
        headerShown: false,
      }}
    >
      <Stack.Screen
        name="ShiftsList"
        component={ShiftsListScreen}
        options={{
          title: 'Historial de Turnos',
        }}
      />
    </Stack.Navigator>
  );
}

================
File: app/src/modules/sync/schema/sync.schema.ts
================
import { z } from 'zod';

export const syncActivityTypeSchema = z.enum([
  'PULL_CHANGES',
  'RESTAURANT_DATA',
  'ORDER_STATUS',
]);
export const syncDirectionSchema = z.enum(['IN', 'OUT']);

export type SyncActivityType = z.infer<typeof syncActivityTypeSchema>;
export type SyncDirection = z.infer<typeof syncDirectionSchema>;

export const SyncActivityTypeEnum = syncActivityTypeSchema.enum;
export const SyncDirectionEnum = syncDirectionSchema.enum;

export const syncActivitySchema = z.object({
  id: z.string(),
  type: syncActivityTypeSchema,
  direction: syncDirectionSchema,
  success: z.boolean(),
  timestamp: z.string(),
});

export type SyncActivity = z.infer<typeof syncActivitySchema>;

export const syncStatusSchema = z.object({
  enabled: z.boolean(),
  webSocketEnabled: z.boolean(),
  webSocketConnected: z.boolean().optional(),
  webSocketFailed: z.boolean().optional(),
  remoteUrl: z.string().nullable(),
  mode: z.string(),
});

export type SyncStatus = z.infer<typeof syncStatusSchema>;
export const SYNC_TYPE_LABELS: Record<SyncActivityType, string> = {
  [SyncActivityTypeEnum.PULL_CHANGES]: 'rdenes y Clientes',
  [SyncActivityTypeEnum.RESTAURANT_DATA]: 'Men y Configuracin',
  [SyncActivityTypeEnum.ORDER_STATUS]: 'Estado de Orden',
};

export const SYNC_DIRECTION_LABELS: Record<SyncDirection, string> = {
  [SyncDirectionEnum.IN]: 'Desde la nube',
  [SyncDirectionEnum.OUT]: 'Hacia la nube',
};

================
File: app/src/modules/users/hooks/useUsers.ts
================
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { usersApiService } from '../services';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import type { CreateUserDto, UpdateUserDto, UsersQuery } from '../schema/user.schema';

const USERS_QUERY_KEY = 'users';

export function useGetUsers(params?: UsersQuery) {
  return useQuery({
    queryKey: [USERS_QUERY_KEY, params],
    queryFn: () => usersApiService.findAll(params),
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
}

export function useGetUser(id?: string) {
  return useQuery({
    queryKey: [USERS_QUERY_KEY, id],
    queryFn: () => (id ? usersApiService.findOne(id) : Promise.resolve(null)),
    enabled: !!id,
    staleTime: 5 * 60 * 1000,
  });
}

export function useCreateUser() {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: (data: CreateUserDto) => usersApiService.create(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [USERS_QUERY_KEY] });
      showSnackbar({
        message: 'Usuario creado exitosamente',
        type: 'success',
      });
    },
    onError: (error: any) => {
      showSnackbar({
        message: error.response?.data?.message || 'Error al crear usuario',
        type: 'error',
      });
    },
  });
}

export function useUpdateUser() {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: UpdateUserDto }) =>
      usersApiService.update(id, data),
    onSuccess: (_, { id }) => {
      queryClient.invalidateQueries({ queryKey: [USERS_QUERY_KEY] });
      queryClient.invalidateQueries({ queryKey: [USERS_QUERY_KEY, id] });
      showSnackbar({
        message: 'Usuario actualizado exitosamente',
        type: 'success',
      });
    },
    onError: (error: any) => {
      showSnackbar({
        message: error.response?.data?.message || 'Error al actualizar usuario',
        type: 'error',
      });
    },
  });
}

export function useDeleteUser() {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: async (id: string) => {
      await usersApiService.remove(id);
      return id;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [USERS_QUERY_KEY] });
      showSnackbar({
        message: 'Usuario eliminado exitosamente',
        type: 'success',
      });
    },
    onError: (error: any) => {
      showSnackbar({
        message: error.response?.data?.message || 'Error al eliminar usuario',
        type: 'error',
      });
    },
  });
}

export function useResetPassword() {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: ({ id, password }: { id: string; password: string }) =>
      usersApiService.resetPassword(id, password),
    onSuccess: (_, { id }) => {
      queryClient.invalidateQueries({ queryKey: [USERS_QUERY_KEY, id] });
      showSnackbar({
        message: 'Contrasea actualizada exitosamente',
        type: 'success',
      });
    },
    onError: (error: any) => {
      showSnackbar({
        message: error.response?.data?.message || 'Error al cambiar contrasea',
        type: 'error',
      });
    },
  });
}

export function useToggleUserActive() {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation({
    mutationFn: ({ id, isActive }: { id: string; isActive: boolean }) =>
      usersApiService.toggleActive(id, isActive),
    onSuccess: (_, { id, isActive }) => {
      queryClient.invalidateQueries({ queryKey: [USERS_QUERY_KEY] });
      queryClient.invalidateQueries({ queryKey: [USERS_QUERY_KEY, id] });
      showSnackbar({
        message: `Usuario ${isActive ? 'activado' : 'desactivado'} exitosamente`,
        type: 'success',
      });
    },
    onError: (error: any) => {
      showSnackbar({
        message:
          error.response?.data?.message ||
          'Error al cambiar estado del usuario',
        type: 'error',
      });
    },
  });
}

================
File: app/src/services/appConfig.ts
================
import apiClient from '../app/services/apiClient';
import { API_PATHS } from '../app/constants/apiPaths';

export interface AppConfig {
  maps: {
    apiKey: string;
  };
}

class AppConfigService {
  private config: AppConfig | null = null;

  async getConfig(): Promise<AppConfig> {
    if (this.config) {
      return this.config;
    }

    try {
      const response = await apiClient.get<AppConfig>(API_PATHS.APP_CONFIG);
      this.config = response.data;
      return this.config;
    } catch (error) {
      const defaultConfig: AppConfig = {
        maps: {
          apiKey: '',
        },
      };
      this.config = defaultConfig;
      return defaultConfig;
    }
  }

  async getMapsApiKey(): Promise<string> {
    const config = await this.getConfig();
    return config.maps.apiKey;
  }

  clearCache() {
    this.config = null;
  }
}

export const appConfigService = new AppConfigService();

================
File: app/src/services/reconnectionSnackbarService.ts
================
import { autoReconnectService } from './autoReconnectService';
import { useSnackbarStore } from '../app/store/snackbarStore';
import { useAuthStore } from '../app/store/authStore';

class ReconnectionSnackbarService {
  private unsubscribe: (() => void) | null = null;
  private lastLogCount = 0;
  private lastStatus: string | null = null;
  private snackbarTimeouts: Map<string, NodeJS.Timeout> = new Map();

  start() {
    this.stop();

    this.unsubscribe = autoReconnectService.subscribe((state: any) => {
      const isLoggedIn = !!useAuthStore.getState().user;
      if (!isLoggedIn) return;

      if (!state.isReconnecting && state.status !== 'connected') {
        this.clearAllSnackbars();
        return;
      }

      if (state.status !== this.lastStatus) {
        this.lastStatus = state.status;
        this.showStatusSnackbar(state.status, state.attempts);
      }

      if (state.logs.length > this.lastLogCount) {
        const newLogs = state.logs.slice(
          0,
          state.logs.length - this.lastLogCount,
        );
        this.processNewLogs(newLogs);
      }

      this.lastLogCount = state.logs.length;
    });
  }

  stop() {
    if (this.unsubscribe) {
      this.unsubscribe();
      this.unsubscribe = null;
    }
    this.clearAllSnackbars();
    this.lastLogCount = 0;
    this.lastStatus = null;
  }

  private showStatusSnackbar(status: string, attempts: number) {
    const { showSnackbar } = useSnackbarStore.getState();

    this.clearSnackbar('status');

    let message = '';
    let type: 'info' | 'error' | 'success' | 'warning' = 'info';
    let duration = 3000;

    switch (status) {
      case 'checking-network':
        message = ' Verificando conexin WiFi...';
        type = 'info';
        break;
      case 'checking-health':
        message = ` Verificando servidor (intento #${attempts})`;
        type = 'info';
        break;
      case 'running-discovery':
        message = ' Buscando servidor en la red...';
        type = 'warning';
        duration = 5000;
        break;
      case 'no-wifi':
        message = ' Sin conexin WiFi';
        type = 'error';
        duration = 5000;
        break;
      case 'failed':
        message = ` Reconexin fallida (intento #${attempts})`;
        type = 'error';
        break;
      case 'connected':
        message = ' Conexin restablecida!';
        type = 'success';
        duration = 4000;
        break;
    }

    if (message) {
      showSnackbar({ message, type, duration });

      const timeout = setTimeout(() => {
        this.snackbarTimeouts.delete('status');
      }, duration);

      this.snackbarTimeouts.set('status', timeout);
    }
  }

  private processNewLogs(logs: string[]) {
    const { showSnackbar } = useSnackbarStore.getState();

    logs.forEach((log) => {
      if (
        log.includes('CICLO DE RECONEXIN') ||
        log.includes('') ||
        log.includes('PASO 1:') ||
        log.includes('PASO 2:') ||
        log.includes('PASO 3:')
      ) {
        return;
      }

      if (
        log.includes('ERROR:') &&
        (log.includes('Health check fall') ||
          log.includes('No se encontr servidor') ||
          log.includes('Ciclo fallido'))
      ) {
        showSnackbar({
          message: this.cleanLogMessage(log),
          type: 'error',
          duration: 4000,
        });
      } else if (
        log.includes('SUCCESS:') &&
        (log.includes('WiFi conectado') ||
          log.includes('Health check exitoso') ||
          log.includes('Servidor encontrado') ||
          log.includes('RECONEXIN EXITOSA'))
      ) {
        showSnackbar({
          message: this.cleanLogMessage(log),
          type: 'success',
          duration: 3000,
        });
      }
    });
  }

  private cleanLogMessage(log: string): string {
    return log
      .replace(/\[[^\]]+\]\s*(INFO|ERROR|SUCCESS):\s*/, '')
      .replace(/\s*\s*/, ' ')
      .trim();
  }

  private clearSnackbar(key: string) {
    const timeout = this.snackbarTimeouts.get(key);
    if (timeout) {
      clearTimeout(timeout);
      this.snackbarTimeouts.delete(key);
    }
  }

  private clearAllSnackbars() {
    this.snackbarTimeouts.forEach((timeout) => clearTimeout(timeout));
    this.snackbarTimeouts.clear();
  }
}

export const reconnectionSnackbarService = new ReconnectionSnackbarService();

================
File: app/babel.config.js
================
module.exports = function (api) {
  api.cache(true);

  const isWeb =
    process.env.WEBPACK_DEV_SERVER === 'true' || process.env.PLATFORM === 'web';

  const plugins = [
    [
      'module-resolver',
      {
        root: ['./'],
        alias: {
          '@': './src',
        },
      },
    ],
    'react-native-reanimated/plugin',
  ];

  if (isWeb) {
    plugins.push([
      function () {
        return {
          visitor: {
            MetaProperty(path) {
              if (
                path.node.meta.name === 'import' &&
                path.node.property.name === 'meta'
              ) {
                path.replaceWith(
                  require('@babel/types').objectExpression([
                    require('@babel/types').objectProperty(
                      require('@babel/types').identifier('url'),
                      require('@babel/types').stringLiteral(''),
                    ),
                  ]),
                );
              }
            },
          },
        };
      },
    ]);
  }

  return {
    presets: ['babel-preset-expo'],
    plugins,
  };
};

================
File: app/metro.config.js
================
const { getDefaultConfig } = require('expo/metro-config');

const config = getDefaultConfig(__dirname);

// Configuracin para asegurar que las peticiones HTTP funcionen en produccin
config.resolver.resolverMainFields = ['react-native', 'browser', 'main'];

// Configuracin adicional para web
config.resolver.sourceExts = [...config.resolver.sourceExts, 'mjs'];

module.exports = config;

================
File: app/src/app/constants/network.ts
================
export const NETWORK_CONFIG = {
  DISCOVERY_PORT: 3737,

  DISCOVERY_TIMEOUT: 1000,
  HEALTH_CHECK_TIMEOUT: 3000,
  API_TIMEOUT: 5000,

  HEALTH_CHECK_INTERVAL: 30000,
  HEALTH_RETRY_INTERVALS: [5000, 10000, 20000, 30000],

  MIN_DISCOVERY_INTERVAL: 10000,
  RECONNECT_CYCLE_DELAY: 10000,
  HEALTH_CHECK_ATTEMPTS: 3,

  MAX_CONCURRENT_REQUESTS: 50,

  COMMON_SUBNETS: ['192.168.1', '192.168.0', '10.0.0'],
} as const;

================
File: app/src/app/lib/imageUtils.ts
================
import { serverConnectionService } from '@/services/serverConnectionService';

/**
 * Helper function para normalizar y construir URLs de imagen
 */
const buildImageUrl = (imagePath: string, apiUrl: string): string | null => {
  const normalizedApiUrl = apiUrl.endsWith('/') ? apiUrl.slice(0, -1) : apiUrl;
  const normalizedPath = imagePath.replace(/\\/g, '/');

  if (normalizedPath.startsWith('http')) {
    try {
      const urlObj = new URL(normalizedPath);
      return `${normalizedApiUrl}${urlObj.pathname}`;
    } catch {
      return null;
    }
  }

  const formattedPath = normalizedPath.startsWith('/')
    ? normalizedPath
    : `/${normalizedPath}`;

  return `${normalizedApiUrl}${formattedPath}`;
};

/**
 * Construye la URL completa de una imagen a partir de su ruta relativa o absoluta.
 * @param imagePath - La ruta relativa o URL completa de la imagen.
 * @returns Promise con la URL completa y lista para usar, o null si la entrada es invlida.
 */
export const getImageUrl = async (
  imagePath: string | null | undefined,
): Promise<string | null> => {
  if (!imagePath || typeof imagePath !== 'string') {
    return null;
  }

  try {
    const connectionState = serverConnectionService.getState();
    if (!connectionState.currentUrl || !connectionState.isConnected) {
      return null;
    }

    return buildImageUrl(imagePath, connectionState.currentUrl);
  } catch (error) {
    return null;
  }
};

/**
 * Versin sncrona que usa una URL base proporcionada.
 * @param imagePath - La ruta relativa o URL completa de la imagen.
 * @param apiUrl - La URL base del API.
 * @returns La URL completa y lista para usar, o null si la entrada es invlida.
 */
export const getImageUrlSync = (
  imagePath: string | null | undefined,
  apiUrl: string,
): string | null => {
  if (!imagePath || typeof imagePath !== 'string') {
    return null;
  }

  return buildImageUrl(imagePath, apiUrl);
};

================
File: app/src/app/lib/zodResolver.ts
================
import type { FieldErrors, FieldValues, ResolverResult } from 'react-hook-form';
import type { ZodSchema, ZodError } from 'zod';

export function zodResolver<T extends FieldValues>(schema: ZodSchema<T>) {
  return async (data: T): Promise<ResolverResult<T>> => {
    try {
      const validatedData = await schema.parseAsync(data);
      return {
        values: validatedData,
        errors: {},
      };
    } catch (error) {
      if (error instanceof Error && 'errors' in error) {
        const zodError = error as ZodError;
        const fieldErrors: FieldErrors<T> = {};

        zodError.errors.forEach((err) => {
          const path = err.path.join('.');
          if (path) {
            (fieldErrors as any)[path] = {
              type: err.code,
              message: err.message,
            };
          }
        });

        return {
          values: {} as T,
          errors: fieldErrors,
        };
      }
      throw error;
    }
  };
}

================
File: app/src/app/navigation/components/WebDrawer.tsx
================
import React, { useEffect } from 'react';
import {
  View,
  StyleSheet,
  Pressable,
  Animated,
  Platform,
  ScrollView,
} from 'react-native';
import { Portal } from 'react-native-paper';
import { useAppTheme } from '../../styles/theme';

interface WebDrawerProps {
  open: boolean;
  onClose: () => void;
  children: React.ReactNode;
  drawerContent: React.ReactNode;
  drawerWidth?: number;
}

export function WebDrawer({
  open,
  onClose,
  children,
  drawerContent,
  drawerWidth = 320,
}: WebDrawerProps) {
  const theme = useAppTheme();
  const slideAnim = React.useRef(new Animated.Value(-drawerWidth)).current;
  const fadeAnim = React.useRef(new Animated.Value(0)).current;

  useEffect(() => {
    if (open) {
      // Abrir drawer
      Animated.parallel([
        Animated.timing(slideAnim, {
          toValue: 0,
          duration: 250,
          useNativeDriver: true,
        }),
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 250,
          useNativeDriver: true,
        }),
      ]).start();
    } else {
      // Cerrar drawer
      Animated.parallel([
        Animated.timing(slideAnim, {
          toValue: -drawerWidth,
          duration: 200,
          useNativeDriver: true,
        }),
        Animated.timing(fadeAnim, {
          toValue: 0,
          duration: 200,
          useNativeDriver: true,
        }),
      ]).start();
    }
  }, [open, slideAnim, fadeAnim, drawerWidth]);

  // Manejar ESC para cerrar
  useEffect(() => {
    if (Platform.OS === 'web' && open) {
      const handleKeyDown = (e: KeyboardEvent) => {
        if (e.key === 'Escape') {
          onClose();
        }
      };
      window.addEventListener('keydown', handleKeyDown);
      return () => window.removeEventListener('keydown', handleKeyDown);
    }
  }, [open, onClose]);

  const styles = StyleSheet.create({
    container: {
      flex: 1,
    },
    overlay: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: 'rgba(0, 0, 0, 0.5)',
      zIndex: 998,
    },
    drawer: {
      position: 'absolute',
      top: 0,
      left: 0,
      bottom: 0,
      width: drawerWidth,
      backgroundColor: theme.colors.surface,
      elevation: 16,
      shadowColor: '#000',
      shadowOffset: { width: 2, height: 0 },
      shadowOpacity: 0.25,
      shadowRadius: 10,
      zIndex: 999,
      borderRightWidth: 1,
      borderRightColor: theme.colors.outlineVariant,
    },
    scrollViewContent: {
      flexGrow: 1,
    },
  });

  // Solo mostrar el drawer personalizado en web
  if (Platform.OS !== 'web') {
    return <>{children}</>;
  }

  return (
    <View style={styles.container}>
      {children}
      {open && (
        <Portal>
          <Animated.View
            style={[
              styles.overlay,
              {
                opacity: fadeAnim,
              },
            ]}
          >
            <Pressable style={StyleSheet.absoluteFill} onPress={onClose} />
          </Animated.View>
          <Animated.View
            style={[
              styles.drawer,
              {
                transform: [{ translateX: slideAnim }],
              },
            ]}
          >
            <ScrollView
              contentContainerStyle={styles.scrollViewContent}
              showsVerticalScrollIndicator={false}
            >
              {drawerContent}
            </ScrollView>
          </Animated.View>
        </Portal>
      )}
    </View>
  );
}

================
File: app/src/app/store/themeStore.ts
================
import { useEffect } from 'react';
import { create } from 'zustand';
import { createJSONStorage, persist } from 'zustand/middleware';
import EncryptedStorage from '@/app/services/secureStorageService';
import { useColorScheme, Appearance } from 'react-native';

import {
  ThemePreference,
  THEME_PREFERENCE_STORAGE_KEY,
  THEME_MODE,
} from '../types/theme.types';
import { lightTheme, darkTheme } from '../styles/theme';

interface ThemeState {
  themePreference: ThemePreference;
  activeTheme: typeof lightTheme | typeof darkTheme;
  isSystemDarkMode: boolean | null;
  setThemePreference: (preference: ThemePreference) => void;
  setSystemDarkMode: (isDark: boolean | null) => void;
}

export const useThemeStore = create<ThemeState>()(
  persist(
    (set, get) => ({
      themePreference: THEME_MODE.SYSTEM,
      activeTheme: lightTheme,
      isSystemDarkMode: null,

      setThemePreference: (preference: ThemePreference) => {
        const { isSystemDarkMode } = get();
        set({ themePreference: preference });

        if (preference === THEME_MODE.SYSTEM) {
          if (isSystemDarkMode !== null) {
            set({ activeTheme: isSystemDarkMode ? darkTheme : lightTheme });
          }
        } else {
          set({
            activeTheme:
              preference === THEME_MODE.DARK ? darkTheme : lightTheme,
          });
        }
      },

      setSystemDarkMode: (isDark: boolean | null) => {
        const { themePreference } = get();
        set({ isSystemDarkMode: isDark });

        if (themePreference === THEME_MODE.SYSTEM && isDark !== null) {
          set({ activeTheme: isDark ? darkTheme : lightTheme });
        }
      },
    }),

    {
      name: THEME_PREFERENCE_STORAGE_KEY,
      storage: createJSONStorage(() => EncryptedStorage),
      partialize: (state) => ({ themePreference: state.themePreference }),
      onRehydrateStorage: () => {
        return (state, error) => {
          if (error) {
            // Error rehydrating theme store
            return;
          }
          if (!state) {
            // State not available during theme rehydration callback
            return;
          }

          const preference = state.themePreference;

          if (preference === THEME_MODE.LIGHT) {
            state.activeTheme = lightTheme;
            state.isSystemDarkMode = Appearance.getColorScheme() === 'dark';
          } else if (preference === THEME_MODE.DARK) {
            state.activeTheme = darkTheme;
            state.isSystemDarkMode = Appearance.getColorScheme() === 'dark';
          } else {
            const systemScheme = Appearance.getColorScheme();
            const isSystemDark = systemScheme === 'dark';
            state.isSystemDarkMode = isSystemDark;
            state.activeTheme = isSystemDark ? darkTheme : lightTheme;
          }
        };
      },
    },
  ),
);

export function useSystemThemeDetector() {
  const systemColorScheme = useColorScheme();
  const setSystemDarkMode = useThemeStore((state) => state.setSystemDarkMode);

  useEffect(() => {
    const isDarkMode = systemColorScheme === 'dark';
    if (useThemeStore.getState().isSystemDarkMode !== isDarkMode) {
      setSystemDarkMode(isDarkMode);
    }
  }, [systemColorScheme, setSystemDarkMode]);
}

================
File: app/src/app/styles/responsive.ts
================
import { Dimensions, PixelRatio } from 'react-native';

// Obtener dimensiones iniciales
const { width: screenWidth, height: screenHeight } = Dimensions.get('window');

// Breakpoints estndar
export const BREAKPOINTS = {
  xs: 0, // Extra pequeo (mviles pequeos)
  sm: 360, // Pequeo (mviles estndar)
  md: 600, // Mediano (mviles grandes y tablets pequeas)
  lg: 900, // Grande (tablets)
  xl: 1200, // Extra grande (tablets grandes)
  xxl: 1536, // Doble extra grande (tablets pro)
} as const;

// Tipos de dispositivos
export const DEVICE_TYPES = {
  MOBILE_SMALL: 'mobile_small',
  MOBILE: 'mobile',
  TABLET_SMALL: 'tablet_small',
  TABLET: 'tablet',
  TABLET_LARGE: 'tablet_large',
} as const;

// Densidades de pxeles estndar
export const PIXEL_DENSITIES = {
  MDPI: 1, // ~160 DPI
  HDPI: 1.5, // ~240 DPI
  XHDPI: 2, // ~320 DPI
  XXHDPI: 3, // ~480 DPI
  XXXHDPI: 4, // ~640 DPI
} as const;

// Dimensiones de referencia para escalado
export const REFERENCE_DIMENSIONS = {
  width: 360, // Ancho de referencia (mvil estndar)
  height: 640, // Altura de referencia
} as const;

// Funcin para obtener el tipo de dispositivo
export const getDeviceType = (width: number = screenWidth): string => {
  if (width < BREAKPOINTS.sm) return DEVICE_TYPES.MOBILE_SMALL;
  if (width < BREAKPOINTS.md) return DEVICE_TYPES.MOBILE;
  if (width < BREAKPOINTS.lg) return DEVICE_TYPES.TABLET_SMALL;
  if (width < BREAKPOINTS.xl) return DEVICE_TYPES.TABLET;
  return DEVICE_TYPES.TABLET_LARGE;
};

// Funcin para verificar si es tablet
export const isTablet = (width: number = screenWidth): boolean => {
  return width >= BREAKPOINTS.md;
};

// Funcin para obtener el factor de escala basado en el ancho
export const getWidthScale = (width: number = screenWidth): number => {
  return width / REFERENCE_DIMENSIONS.width;
};

// Funcin para obtener el factor de escala basado en la altura
export const getHeightScale = (height: number = screenHeight): number => {
  return height / REFERENCE_DIMENSIONS.height;
};

// Funcin para escalar un valor segn el ancho de pantalla
export const scaleWidth = (
  size: number,
  width: number = screenWidth,
): number => {
  const scale = getWidthScale(width);
  return Math.round(size * scale);
};

// Funcin para escalar un valor segn la altura de pantalla
export const scaleHeight = (
  size: number,
  height: number = screenHeight,
): number => {
  const scale = getHeightScale(height);
  return Math.round(size * scale);
};

// Funcin para escalar con lmites
export const scaleWithLimits = (
  size: number,
  minScale: number = 0.8,
  maxScale: number = 1.5,
  width: number = screenWidth,
): number => {
  const scale = Math.max(minScale, Math.min(maxScale, getWidthScale(width)));
  return Math.round(size * scale);
};

// Funcin para obtener dimensiones responsive
export const getResponsiveDimension = (
  mobile: number,
  tablet: number,
  width: number = screenWidth,
): number => {
  return isTablet(width) ? tablet : mobile;
};

// Escalas de spacing responsive (ms espacioso en tablets para mejor legibilidad)
export const RESPONSIVE_SPACING = {
  xxxs: (width: number = screenWidth) =>
    isTablet(width) ? scaleWidth(2, width) : scaleWidth(1, width),
  xxs: (width: number = screenWidth) =>
    isTablet(width) ? scaleWidth(4, width) : scaleWidth(2, width),
  xs: (width: number = screenWidth) =>
    isTablet(width) ? scaleWidth(6, width) : scaleWidth(4, width),
  s: (width: number = screenWidth) =>
    isTablet(width) ? scaleWidth(10, width) : scaleWidth(8, width),
  m: (width: number = screenWidth) =>
    isTablet(width) ? scaleWidth(16, width) : scaleWidth(16, width),
  l: (width: number = screenWidth) =>
    isTablet(width) ? scaleWidth(24, width) : scaleWidth(24, width),
  xl: (width: number = screenWidth) =>
    isTablet(width) ? scaleWidth(32, width) : scaleWidth(32, width),
  xxl: (width: number = screenWidth) =>
    isTablet(width) ? scaleWidth(40, width) : scaleWidth(40, width),
} as const;

// Tamaos de fuente responsive (optimizadas para tablets)
export const RESPONSIVE_FONT_SIZES = {
  xs: (width: number = screenWidth) =>
    isTablet(width) ? 10 : scaleWithLimits(10, 0.9, 1.1, width),
  s: (width: number = screenWidth) =>
    isTablet(width) ? 12 : scaleWithLimits(12, 0.9, 1.1, width),
  m: (width: number = screenWidth) =>
    isTablet(width) ? 14 : scaleWithLimits(14, 0.9, 1.2, width),
  l: (width: number = screenWidth) =>
    isTablet(width) ? 16 : scaleWithLimits(16, 0.9, 1.2, width),
  xl: (width: number = screenWidth) =>
    isTablet(width) ? 18 : scaleWithLimits(20, 0.9, 1.3, width),
  xxl: (width: number = screenWidth) =>
    isTablet(width) ? 22 : scaleWithLimits(24, 0.9, 1.3, width),
  xxxl: (width: number = screenWidth) =>
    isTablet(width) ? 28 : scaleWithLimits(32, 0.9, 1.4, width),
} as const;

// Dimensiones comunes responsive
export const RESPONSIVE_DIMENSIONS = {
  // Drawer
  drawerWidth: (width: number = screenWidth) => {
    if (width < BREAKPOINTS.sm) return 280;
    if (width < BREAKPOINTS.md) return 300;
    if (width < BREAKPOINTS.lg) return 340;
    if (width < BREAKPOINTS.xl) return 360;
    return 380;
  },

  // Modales
  modalWidth: (width: number = screenWidth) => {
    if (width < BREAKPOINTS.sm) return width * 0.95;
    if (width < BREAKPOINTS.md) return width * 0.85;
    if (width < BREAKPOINTS.lg) return Math.min(width * 0.6, 500);
    return Math.min(width * 0.45, 550);
  },

  // Headers
  headerHeight: (width: number = screenWidth) => {
    return getResponsiveDimension(56, 64, width);
  },

  // Botones
  buttonHeight: (width: number = screenWidth) => {
    return getResponsiveDimension(48, 44, width);
  },

  // Iconos
  iconSize: {
    small: (width: number = screenWidth) =>
      getResponsiveDimension(16, 16, width),
    medium: (width: number = screenWidth) =>
      getResponsiveDimension(24, 24, width),
    large: (width: number = screenWidth) =>
      getResponsiveDimension(32, 32, width),
  },

  // Imgenes de productos
  productImageSize: (width: number = screenWidth) => {
    if (width < BREAKPOINTS.sm) return 80;
    if (width < BREAKPOINTS.md) return 100;
    if (width < BREAKPOINTS.lg) return 90;
    return 100; // Ms compacto en tablets
  },

  // Cards
  cardMinWidth: (width: number = screenWidth) => {
    if (width < BREAKPOINTS.sm) return width - 32;
    if (width < BREAKPOINTS.md) return 280;
    if (width < BREAKPOINTS.lg) return 320;
    return 360;
  },
} as const;

// Funcin helper para aplicar estilos condicionales segn breakpoint
export const applyResponsiveStyle = <T>(
  width: number,
  styles: {
    xs?: T;
    sm?: T;
    md?: T;
    lg?: T;
    xl?: T;
    xxl?: T;
  },
): T | undefined => {
  const breakpoints = Object.keys(BREAKPOINTS).reverse() as Array<
    keyof typeof BREAKPOINTS
  >;

  for (const breakpoint of breakpoints) {
    if (width >= BREAKPOINTS[breakpoint] && styles[breakpoint]) {
      return styles[breakpoint];
    }
  }

  return undefined;
};

// Utilidad para calcular columnas en grids
export const getGridColumns = (
  width: number = screenWidth,
  minItemWidth: number = 150,
  gap: number = 16,
  padding: number = 16,
): number => {
  const availableWidth = width - padding * 2;
  const columns = Math.floor((availableWidth + gap) / (minItemWidth + gap));
  return Math.max(1, columns);
};

// Utilidad para obtener orientacin safe
export const getOrientation = (
  width: number = screenWidth,
  height: number = screenHeight,
) => {
  return width > height ? 'landscape' : 'portrait';
};

// Utilidad para calcular aspect ratio
export const maintainAspectRatio = (
  originalWidth: number,
  originalHeight: number,
  maxWidth: number,
  maxHeight: number,
) => {
  const aspectRatio = originalWidth / originalHeight;

  let width = maxWidth;
  let height = maxWidth / aspectRatio;

  if (height > maxHeight) {
    height = maxHeight;
    width = maxHeight * aspectRatio;
  }

  return { width: Math.round(width), height: Math.round(height) };
};

// Exportar utilidad para normalizar segn DPI
export const normalizeDPI = (size: number): number => {
  const pixelRatio = PixelRatio.get();
  return Math.round(size * pixelRatio) / pixelRatio;
};

// Utilidad para obtener dimensiones de pantalla actualizadas
export const getScreenDimensions = () => {
  return Dimensions.get('window');
};

// Multiplicador de densidad para tablets (ms compacto)
export const TABLET_DENSITY_MULTIPLIER = 0.75;

// Helper para obtener tamao compacto en tablets
export const getCompactSize = (
  mobileSize: number,
  width: number = screenWidth,
  compactRatio: number = TABLET_DENSITY_MULTIPLIER,
): number => {
  return isTablet(width) ? Math.round(mobileSize * compactRatio) : mobileSize;
};

// Helper para obtener tamao de fuente compacto
export const getCompactFontSize = (
  mobileSize: number,
  width: number = screenWidth,
  compactRatio: number = 0.85,
): number => {
  return isTablet(width) ? Math.round(mobileSize * compactRatio) : mobileSize;
};

// Helper para obtener spacing compacto
export const getCompactSpacing = (
  mobileSpacing: number,
  width: number = screenWidth,
  compactRatio: number = 0.65,
): number => {
  return isTablet(width)
    ? Math.round(mobileSpacing * compactRatio)
    : mobileSpacing;
};

================
File: app/src/app/utils/tokenVerification.ts
================
import { authService } from '@/modules/auth/services/authService';
import { useAuthStore } from '@/app/store/authStore';
import EncryptedStorage from '@/app/services/secureStorageService';

const AUTH_TOKEN_KEY = 'auth_token';
const REFRESH_TOKEN_KEY = 'refresh_token';
const USER_INFO_KEY = 'user_info';

/**
 * Verifica si el token almacenado es vlido con el backend
 * Esta funcin est separada para evitar ciclos de dependencias
 */
export async function verifyStoredToken(): Promise<boolean> {
  try {
    const { accessToken } = useAuthStore.getState();

    if (!accessToken) {
      return false;
    }

    const isTokenValid = await authService.verifyToken();

    if (!isTokenValid) {
      // Si el token no es vlido, limpiamos todo
      await EncryptedStorage.removeItem(AUTH_TOKEN_KEY);
      await EncryptedStorage.removeItem(REFRESH_TOKEN_KEY);
      await EncryptedStorage.removeItem(USER_INFO_KEY);

      useAuthStore.setState({
        accessToken: null,
        refreshToken: null,
        user: null,
        isAuthenticated: false,
      });

      return false;
    }

    return true;
  } catch (error) {
    // Error verificando token
    return false;
  }
}

================
File: app/src/modules/availability/components/AvailabilityListItem.tsx
================
import React from 'react';
import { View, StyleSheet, TouchableOpacity } from 'react-native';
import { Surface, Text, IconButton, Switch } from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';

interface AvailabilityListItemProps {
  title: string;
  subtitle: string;
  icon: string;
  isActive: boolean;
  onToggle?: (value: boolean) => void;
  isExpanded?: boolean;
  onToggleExpand?: () => void;
  children?: React.ReactNode;
}

export const AvailabilityListItem: React.FC<AvailabilityListItemProps> = ({
  title,
  subtitle,
  icon,
  isActive,
  onToggle,
  isExpanded = false,
  onToggleExpand,
  children,
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );

  return (
    <Surface
      style={[styles.container, { backgroundColor: theme.colors.surface }]}
      elevation={1}
    >
      <TouchableOpacity
        style={[
          styles.header,
          styles.headerBackground,
          isActive ? styles.activeHeader : styles.inactiveHeader,
        ]}
        onPress={onToggleExpand}
        activeOpacity={0.7}
        disabled={!onToggleExpand}
      >
        <View style={styles.left}>
          <View
            style={[
              styles.iconContainer,
              {
                backgroundColor: isActive
                  ? theme.colors.primaryContainer
                  : theme.colors.surfaceVariant,
              },
            ]}
          >
            <IconButton
              icon={icon}
              size={20}
              iconColor={isActive ? theme.colors.primary : theme.colors.outline}
              style={styles.iconButton}
            />
          </View>
          <View style={styles.info}>
            <Text
              style={[styles.title, { color: theme.colors.onSurface }]}
              numberOfLines={1}
            >
              {title}
            </Text>
            <Text
              style={[
                styles.subtitle,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              {subtitle}
            </Text>
          </View>
        </View>

        <View style={styles.right}>
          {onToggle && (
            <Switch
              value={isActive}
              onValueChange={onToggle}
              color={theme.colors.primary}
              style={styles.switch}
            />
          )}
          {onToggleExpand && (
            <IconButton
              icon={isExpanded ? 'chevron-up' : 'chevron-down'}
              size={20}
              iconColor={theme.colors.onSurfaceVariant}
              style={styles.iconButton}
            />
          )}
        </View>
      </TouchableOpacity>

      {isExpanded && children && (
        <View
          style={[
            styles.expandedContent,
            { backgroundColor: theme.colors.elevation.level1 },
          ]}
        >
          {children}
        </View>
      )}
    </Surface>
  );
};

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      marginHorizontal: responsive.spacing(theme.spacing.m),
      borderRadius: 16,
      overflow: 'hidden',
    },
    header: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      padding: responsive.spacing(theme.spacing.m),
    },
    left: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
    },
    iconContainer: {
      width: responsive.isTablet ? 32 : 40,
      height: responsive.isTablet ? 32 : 40,
      borderRadius: responsive.isTablet ? 16 : 20,
      justifyContent: 'center',
      alignItems: 'center',
      marginRight: responsive.spacing(theme.spacing.m),
    },
    info: {
      flex: 1,
    },
    title: {
      fontSize: responsive.fontSize(16),
      fontWeight: '600',
      marginBottom: 2,
    },
    subtitle: {
      fontSize: responsive.fontSize(12),
      opacity: 0.8,
    },
    right: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    switch: {
      marginHorizontal: responsive.spacing(theme.spacing.s),
    },
    expandedContent: {
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingBottom: responsive.spacing(theme.spacing.m),
    },
    headerBackground: {
      backgroundColor: theme.colors.elevation.level2,
    },
    activeHeader: {
      opacity: 1,
    },
    inactiveHeader: {
      opacity: 0.7,
    },
    iconButton: {
      margin: 0,
    },
  });

================
File: app/src/modules/availability/components/ModifierGroupAvailabilityItem.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, Switch } from 'react-native-paper';
import { ModifierGroupAvailability } from '../schema/availability.schema';
import { useOptimisticAvailability } from '../hooks/useOptimisticAvailability';
import { useAppTheme } from '@/app/styles/theme';
import { AvailabilityListItem } from './AvailabilityListItem';

interface ModifierGroupAvailabilityItemProps {
  modifierGroup: ModifierGroupAvailability;
}

export const ModifierGroupAvailabilityItem: React.FC<
  ModifierGroupAvailabilityItemProps
> = ({ modifierGroup }) => {
  const theme = useAppTheme();
  const [expanded, setExpanded] = useState(false);
  const updateAvailability = useOptimisticAvailability();

  const handleGroupToggle = (value: boolean) => {
    updateAvailability.mutate({
      type: 'modifierGroup',
      id: modifierGroup.id,
      isActive: value,
      cascade: true,
    });
  };

  const handleModifierToggle = (modifierId: string, value: boolean) => {
    updateAvailability.mutate({
      type: 'modifier',
      id: modifierId,
      isActive: value,
    });
  };

  const totalModifiers = modifierGroup.modifiers.length;
  const activeModifiers = modifierGroup.modifiers.filter(
    (m) => m.isActive,
  ).length;

  return (
    <AvailabilityListItem
      title={modifierGroup.name}
      subtitle={`${activeModifiers}/${totalModifiers} modificadores activos`}
      icon="tune-variant"
      isActive={modifierGroup.isActive}
      onToggle={handleGroupToggle}
      isExpanded={expanded}
      onToggleExpand={() => setExpanded(!expanded)}
    >
      <View style={styles.modifiersContainer}>
        {modifierGroup.modifiers.map((modifier) => (
          <View
            key={modifier.id}
            style={[
              styles.modifierItem,
              modifier.isActive
                ? styles.activeModifier
                : styles.inactiveModifier,
            ]}
          >
            <Text
              style={[
                styles.modifierTitle,
                !modifier.isActive && styles.strikethrough,
                { color: theme.colors.onSurface },
              ]}
            >
              {modifier.name}
            </Text>
            <Switch
              value={modifier.isActive}
              onValueChange={(value) =>
                handleModifierToggle(modifier.id, value)
              }
              disabled={!modifierGroup.isActive}
            />
          </View>
        ))}
      </View>
    </AvailabilityListItem>
  );
};

const styles = StyleSheet.create({
  modifiersContainer: {
    paddingLeft: 16,
  },
  modifierItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 4,
  },
  modifierTitle: {
    fontSize: 13,
  },
  strikethrough: {
    textDecorationLine: 'line-through',
  },
  activeModifier: {
    opacity: 1,
  },
  inactiveModifier: {
    opacity: 0.5,
  },
});

================
File: app/src/modules/customers/index.ts
================
// Services
export { customersService } from './services/customersService';
export { addressesService } from './services/addressesService';

// Hooks
export * from './hooks/useCustomersQueries';

// Types and Schema types
export type {
  Customer,
  Address,
  ChatMessage,
  FindAllCustomersQuery,
  CreateCustomerInput,
  UpdateCustomerInput,
  AddressFormInputs,
  CustomerFormInputs,
} from './schema/customer.schema';

// Schemas
export {
  createCustomerSchema,
  updateCustomerSchema,
  addressSchema,
  customerFormSchema,
} from './schema/customer.schema';

================
File: app/src/modules/customers/screens/CustomersScreen.tsx
================
import React, { useMemo, useCallback, useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { Portal, Text } from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useDrawerStatus } from '@react-navigation/drawer';
import debounce from 'lodash.debounce';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';

import {
  useCustomers,
  useCreateCustomer,
  useUpdateCustomer,
  useDeleteCustomer,
} from '../hooks/useCustomersQueries';
import { Customer, CustomerFormInputs } from '../schema/customer.schema';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import GenericList, { FilterOption } from '@/app/components/crud/GenericList';
import GenericDetailModal from '@/app/components/crud/GenericDetailModal';
import CustomerFormModal from '../components/CustomerFormModal';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { useCrudScreenLogic } from '@/app/hooks/useCrudScreenLogic';
import { useListState } from '@/app/hooks/useListState';
import { formatCurrency } from '@/app/lib/formatters';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';

function CustomersScreen(): React.ReactElement {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme as AppTheme), [theme]);
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';

  const [searchQuery, setSearchQuery] = useState('');
  const [statusFilter, setStatusFilter] = useState<
    'all' | 'active' | 'inactive' | 'banned'
  >('all');
  const [debouncedSearchQuery, setDebouncedSearchQuery] = useState('');
  const [selectedCustomer, setSelectedCustomer] = useState<Customer | null>(
    null,
  );
  const [detailModalVisible, setDetailModalVisible] = useState(false);
  const [showDeleteConfirmation, setShowDeleteConfirmation] = useState(false);
  const [customerToDelete, setCustomerToDelete] = useState<string | null>(null);

  const debouncedSetSearch = useMemo(
    () => debounce((query: string) => setDebouncedSearchQuery(query), 300),
    [], // eslint-disable-line react-hooks/exhaustive-deps
  );

  const handleSearchChange = (query: string) => {
    setSearchQuery(query);
    debouncedSetSearch(query);
  };

  const handleFilterChange = (value: string | number) => {
    if (
      value === 'all' ||
      value === 'active' ||
      value === 'inactive' ||
      value === 'banned'
    ) {
      setStatusFilter(value);
    } else {
      setStatusFilter('all');
    }
  };

  const queryFilters = useMemo(() => {
    const filters: any = {};

    if (debouncedSearchQuery) {
      filters.firstName = debouncedSearchQuery;
      filters.lastName = debouncedSearchQuery;
    }

    if (statusFilter === 'active') {
      filters.isActive = true;
    } else if (statusFilter === 'inactive') {
      filters.isActive = false;
    } else if (statusFilter === 'banned') {
      filters.isBanned = true;
    }

    return filters;
  }, [debouncedSearchQuery, statusFilter]);

  const {
    data: customers,
    isLoading,
    error,
    refetch,
    isFetching,
  } = useCustomers(queryFilters);

  const createMutation = useCreateCustomer();
  const updateMutation = useUpdateCustomer();
  const { mutateAsync: deleteCustomer } = useDeleteCustomer();

  useRefreshModuleOnFocus('customers');

  const {
    isFormModalVisible,
    editingItem,
    handleOpenCreateModal,
    handleOpenEditModal: originalHandleOpenEditModal,
    handleCloseModals: originalHandleCloseModals,
  } = useCrudScreenLogic<Customer>({
    entityName: 'Cliente',
    queryKey: ['customers', queryFilters],
    deleteMutationFn: deleteCustomer,
  });

  const handleOpenEditModal = useCallback(
    (item: any) => {
      setDetailModalVisible(false);
      const { fullName, ...originalCustomer } = item;
      originalHandleOpenEditModal(originalCustomer as Customer);
    },
    [originalHandleOpenEditModal],
  );

  const handleCloseModals = useCallback(() => {
    originalHandleCloseModals();
    setDetailModalVisible(false);
  }, [originalHandleCloseModals]);

  const handleItemPress = useCallback((item: Customer) => {
    setSelectedCustomer(item);
    setDetailModalVisible(true);
  }, []);

  const handleDelete = useCallback((id: string) => {
    setCustomerToDelete(id);
    setShowDeleteConfirmation(true);
  }, []);

  const handleConfirmDelete = useCallback(async () => {
    if (!customerToDelete) return;

    try {
      await deleteCustomer(customerToDelete);
      showSnackbar({
        message: 'Cliente eliminado con xito',
        type: 'success',
      });
      setDetailModalVisible(false);
      setShowDeleteConfirmation(false);
      setCustomerToDelete(null);
    } catch (error) {
      showSnackbar({
        message: 'Error al eliminar el cliente',
        type: 'error',
      });
    }
  }, [deleteCustomer, showSnackbar, customerToDelete]);

  const filterOptions: FilterOption<
    'all' | 'active' | 'inactive' | 'banned'
  >[] = [
    { label: 'Todos', value: 'all' },
    { label: 'Activos', value: 'active' },
    { label: 'Inactivos', value: 'inactive' },
    { label: 'Baneados', value: 'banned' },
  ];

  const { ListEmptyComponent } = useListState({
    isLoading,
    isError: !!error,
    data: customers,
    emptyConfig: {
      title: 'No hay clientes',
      message:
        statusFilter !== 'all'
          ? `No hay clientes ${
              statusFilter === 'active'
                ? 'activos'
                : statusFilter === 'inactive'
                  ? 'inactivos'
                  : 'baneados'
            }.`
          : 'No hay clientes registrados. Presiona el botn + para crear el primero.',
      icon: 'account-group-outline',
    },
    errorConfig: {
      title: 'Error al cargar clientes',
      message: 'No se pudieron cargar los clientes. Verifica tu conexin.',
      icon: 'alert-circle-outline',
      onAction: refetch,
    },
  });

  const mappedCustomers = useMemo(() => {
    return (
      customers?.map((customer) => ({
        ...customer,
        fullName: `${customer.firstName} ${customer.lastName}`.trim(),
        displayTitle:
          `${customer.firstName} ${customer.lastName} - ${customer.whatsappPhoneNumber}`.trim(),
        displayStatus: customer.isActive ? 'active' : 'inactive',
        whatsappInfo:
          customer.whatsappMessageCount > 0
            ? ` ${customer.whatsappMessageCount}`
            : null,
      })) || []
    );
  }, [customers]);

  const handleSubmit = useCallback(
    async (data: CustomerFormInputs) => {
      try {
        if (editingItem) {
          await updateMutation.mutateAsync({
            id: editingItem.id,
            data,
          });
          showSnackbar({
            message: 'Cliente actualizado con xito',
            type: 'success',
          });
        } else {
          await createMutation.mutateAsync(data);
          showSnackbar({
            message: 'Cliente creado con xito',
            type: 'success',
          });
        }
        handleCloseModals();
      } catch (error) {
        showSnackbar({
          message: 'Error al guardar el cliente',
          type: 'error',
        });
      }
    },
    [
      editingItem,
      createMutation,
      updateMutation,
      handleCloseModals,
      showSnackbar,
    ],
  );

  return (
    <SafeAreaView style={styles.container} edges={['bottom']}>
      <View style={styles.container}>
        <GenericList
          items={mappedCustomers}
          isLoading={isLoading}
          isRefreshing={isFetching}
          onRefresh={refetch}
          onItemPress={handleItemPress}
          renderConfig={{
            titleField: 'displayTitle' as keyof Customer,
            statusConfig: {
              field: 'displayStatus' as keyof Customer,
              activeValue: 'active',
              activeLabel: 'Activo',
              inactiveLabel: 'Inactivo',
            },
            renderDescription: (item: any) => (
              <View>
                {item.email && (
                  <Text variant="bodySmall" style={styles.subtitleText}>
                    {item.email}
                  </Text>
                )}
                <View style={styles.infoRow}>
                  <Text variant="bodySmall" style={styles.subtitleText}>
                    {item.isBanned ? ' Baneado' : ' No baneado'}
                  </Text>
                  <Text variant="bodySmall" style={styles.subtitleText}>
                      {item.addresses?.length || 0} direcciones
                  </Text>
                </View>
              </View>
            ),
          }}
          searchQuery={searchQuery}
          onSearchChange={handleSearchChange}
          searchPlaceholder="Buscar por nombre..."
          filterOptions={filterOptions}
          filterValue={statusFilter}
          onFilterChange={handleFilterChange}
          showFab={true}
          onFabPress={handleOpenCreateModal}
          ListEmptyComponent={ListEmptyComponent}
          isDrawerOpen={isDrawerOpen}
          enableSearch={true}
          showImagePlaceholder={false}
          placeholderIcon="account-group-outline"
        />
      </View>

      <Portal>
        <CustomerFormModal
          visible={isFormModalVisible}
          onDismiss={handleCloseModals}
          onSubmit={handleSubmit}
          editingItem={editingItem}
          isSubmitting={createMutation.isPending || updateMutation.isPending}
        />

        <GenericDetailModal
          visible={detailModalVisible}
          onDismiss={() => setDetailModalVisible(false)}
          item={
            selectedCustomer
              ? {
                  ...selectedCustomer,
                  fullName:
                    `${selectedCustomer.firstName} ${selectedCustomer.lastName}`.trim(),
                }
              : null
          }
          titleField="fullName"
          descriptionField="email"
          statusConfig={{
            field: 'isActive' as keyof Customer,
            activeValue: true,
            activeLabel: 'Activo',
            inactiveLabel: 'Inactivo',
          }}
          onEdit={handleOpenEditModal}
          onDelete={handleDelete}
          isDeleting={false}
          showImage={false}
          fieldsToDisplay={[
            {
              field: 'isBanned' as keyof Customer,
              label: 'Estado de baneo',
              render: (value) => (value ? ' Baneado' : ' No baneado'),
            },
            {
              field: 'whatsappPhoneNumber' as keyof Customer,
              label: 'WhatsApp',
              render: (value) => (value as string) || 'No registrado',
            },
            {
              field: 'stripeCustomerId' as keyof Customer,
              label: 'Stripe Customer ID',
              render: (value) => (value as string) || 'No registrado',
            },
            {
              field: 'email' as keyof Customer,
              label: 'Correo',
              render: (value) => (value as string) || 'No registrado',
            },
            {
              field: 'birthDate' as keyof Customer,
              label: 'Fecha de nacimiento',
              render: (value) =>
                value
                  ? new Date(value as string).toLocaleDateString()
                  : 'No registrada',
            },
            {
              field: 'addresses' as keyof Customer,
              label: 'Direcciones',
              render: (value) => {
                const addresses = value as any[];
                const count = addresses?.length || 0;
                if (count === 0) return ' Sin direcciones';
                if (count === 1) return ' 1 direccin';
                return ` ${count} direcciones ${count > 3 ? '' : ''}`;
              },
            },
            {
              field: 'totalOrders' as keyof Customer,
              label: 'Total de pedidos',
              render: (value) => value?.toString() || '0',
            },
            {
              field: 'totalSpent' as keyof Customer,
              label: 'Total gastado',
              render: (value) => formatCurrency((value as number) || 0),
            },
            {
              field: 'lastInteraction' as keyof Customer,
              label: 'ltima interaccin',
              render: (value) =>
                value
                  ? new Date(value as string).toLocaleString()
                  : 'Sin interacciones',
            },
            {
              field: 'whatsappMessageCount' as keyof Customer,
              label: 'Mensajes de WhatsApp',
              render: (value) => `${value || 0} mensajes`,
            },
            {
              field: 'lastWhatsappMessageTime' as keyof Customer,
              label: 'ltimo mensaje WhatsApp',
              render: (value) =>
                value
                  ? new Date(value as string).toLocaleString()
                  : 'Sin mensajes',
            },
          ]}
        />

        <ConfirmationModal
          visible={showDeleteConfirmation}
          title="Confirmar Eliminacin"
          message="Ests seguro de que quieres eliminar este cliente? Esta accin no se puede deshacer."
          confirmText="Eliminar"
          cancelText="Cancelar"
          confirmButtonColor={theme.colors.error}
          onConfirm={handleConfirmDelete}
          onCancel={() => {
            setShowDeleteConfirmation(false);
            setCustomerToDelete(null);
          }}
          onDismiss={() => {
            setShowDeleteConfirmation(false);
            setCustomerToDelete(null);
          }}
        />
      </Portal>
    </SafeAreaView>
  );
}

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    rightContent: {
      flexDirection: 'column',
      alignItems: 'flex-end',
      gap: theme.spacing.xs,
    },
    activeChip: {
      backgroundColor: theme.colors.primaryContainer,
    },
    inactiveChip: {
      backgroundColor: theme.colors.errorContainer,
    },
    statsChip: {
      backgroundColor: theme.colors.surfaceVariant,
    },
    subtitleText: {
      opacity: 0.7,
    },
    infoRow: {
      flexDirection: 'row',
      gap: 8,
      marginTop: 2,
    },
  });

export default CustomersScreen;

================
File: app/src/modules/menu/schema/category.schema.ts
================
import { z } from 'zod';
import type { Category } from '../../../app/schemas/domain/category.schema';
import { type Photo } from '../../../app/schemas/domain/photo.schema';

const categoryBaseSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().nullable().optional(),
  isActive: z.boolean(),
  photoId: z.union([z.string().uuid(), z.null(), z.undefined()]).optional(),
  sortOrder: z.number().default(0),
});

export const createCategoryDtoSchema = categoryBaseSchema.extend({
  isActive: z.boolean().default(true),
  sortOrder: z.number().default(0),
});

export const updateCategoryDtoSchema = categoryBaseSchema.partial();

export const categoryFormSchema = categoryBaseSchema
  .extend({
    sortOrder: z.number().optional().default(0),
    imageUri: z
      .union([
        z.string().url(),
        z.string().startsWith('file://'),
        z.string().startsWith('http://'),
        z.string().startsWith('https://'),
        z.null(),
      ])
      .optional(),
  })
  .omit({ photoId: true })
  .transform((data) => ({
    ...data,
    sortOrder: data.sortOrder ?? 0,
  }));
export type CreateCategoryDto = z.infer<typeof createCategoryDtoSchema>;
export type UpdateCategoryDto = z.infer<typeof updateCategoryDtoSchema>;
export type CategoryFormData = z.infer<typeof categoryFormSchema>;

export type { Category, Photo };

================
File: app/src/modules/menu/services/fileService.ts
================
import apiClient from '../../../app/services/apiClient';
import { ApiError } from '../../../app/lib/errors';
import { Platform } from 'react-native';
import { API_PATHS } from '../../../app/constants/apiPaths';
import NetInfo from '@react-native-community/netinfo';

export interface FileUploadResponse {
  file: {
    id: string;
    path: string;
  };
  presignedUrl?: string;
}

export interface FileObject {
  uri: string;
  name: string;
  type: string;
}

const checkNetworkConnection = async (): Promise<boolean> => {
  const state = await NetInfo.fetch();
  return state.isConnected === true && state.isInternetReachable !== false;
};

export const uploadFile = async (
  fileToUpload: FileObject,
  maxRetries: number = 3,
): Promise<FileUploadResponse> => {
  const isConnected = await checkNetworkConnection();
  if (!isConnected) {
    throw new ApiError(
      'NETWORK_ERROR',
      'Sin conexin a internet. Verifica tu conexin e intenta nuevamente.',
      0,
    );
  }

  const formData = new FormData();
  formData.append('file', {
    uri:
      Platform.OS === 'android'
        ? fileToUpload.uri
        : fileToUpload.uri.replace('file://', ''),
    name: fileToUpload.name,
    type: fileToUpload.type,
  } as any);

  let lastError: any;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const response = await apiClient.post<FileUploadResponse>(
        API_PATHS.FILES_UPLOAD,
        formData,
        {
          headers: {
            'Content-Type': 'multipart/form-data',
            'Cache-Control': 'no-cache',
          },
          timeout: 120000,
          maxContentLength: Infinity,
          maxBodyLength: Infinity,
        },
      );

      return response.data;
    } catch (error) {
      lastError = error;

      if (
        error instanceof ApiError &&
        error.status >= 400 &&
        error.status < 500
      ) {
        throw error;
      }

      if (attempt === maxRetries) {
        if (error instanceof ApiError) throw error;
        throw new ApiError(
          'UPLOAD_FAILED',
          `Error al subir archivo despus de ${maxRetries} intentos: ${error instanceof Error ? error.message : 'Error desconocido'}`,
          500,
        );
      }

      const delay = Math.min(1000 * Math.pow(2, attempt - 1), 5000);
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
  }

  throw (
    lastError ||
    new ApiError('UPLOAD_FAILED', 'Error desconocido al subir archivo', 500)
  );
};

const fileService = {
  uploadFile,
  uploadImage: uploadFile,
};

export default fileService;

================
File: app/src/modules/modifiers/components/ModifierFormModal.tsx
================
import React, { useMemo, useCallback } from 'react';
import { z } from 'zod';
import { useMutation, useQueryClient } from '@tanstack/react-query';

import { useSnackbarStore } from '@/app/store/snackbarStore';
import { getApiErrorMessage } from '@/app/lib/errorMapping';
import GenericFormModal, {
  FormFieldConfig,
} from '@/app/components/crud/GenericFormModal';
import { modifierService } from '../services/modifierService';
import { ModifierFormInputs } from '../schema/modifier.schema';
import {
  Modifier,
  modifierFormValidationSchema,
  CreateModifierInput,
  UpdateModifierInput,
} from '../schema/modifier.schema';

interface Props {
  visible: boolean;
  onDismiss: () => void;
  onSaveSuccess: () => void;
  initialData?: Modifier | null;
  groupId: string;
}

const formFields: FormFieldConfig<ModifierFormInputs>[] = [
  { name: 'name', label: 'Nombre *', type: 'text', required: true },
  {
    name: 'description',
    label: 'Descripcin (Opcional)',
    type: 'textarea',
    numberOfLines: 3,
  },
  {
    name: 'price',
    label: 'Precio Adicional (Opcional)',
    type: 'number',
    inputProps: { keyboardType: 'numeric' },
  },
  {
    name: 'sortOrder',
    label: 'Orden de Visualizacin',
    type: 'number',
    defaultValue: 0,
    inputProps: { keyboardType: 'numeric' },
  },
  {
    name: 'isDefault',
    label: 'Seleccionado por Defecto',
    type: 'switch',
    defaultValue: false,
  },
  { name: 'isActive', label: 'Activo', type: 'switch', defaultValue: true },
];

const formSchema = modifierFormValidationSchema;

const ModifierFormModal: React.FC<Props> = ({
  visible,
  onDismiss,
  onSaveSuccess,
  initialData,
  groupId,
}) => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const isEditing = !!initialData;
  const QUERY_KEY_TO_INVALIDATE = ['modifiers', groupId];

  const mutation = useMutation<
    Modifier,
    Error,
    CreateModifierInput | UpdateModifierInput
  >({
    mutationFn: (data) => {
      if (isEditing && initialData) {
        return modifierService.update(
          initialData.id,
          data as UpdateModifierInput,
        );
      } else {
        return modifierService.create(data as CreateModifierInput);
      }
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: QUERY_KEY_TO_INVALIDATE });
      showSnackbar({
        message: `Modificador "${data.name}" ${isEditing ? 'actualizado' : 'creado'} correctamente`,
        type: 'success',
      });
      onSaveSuccess();
    },
    onError: (error) => {
      const message = getApiErrorMessage(error);
      showSnackbar({ message, type: 'error' });
    },
  });

  const handleFormSubmit = useCallback(
    async (formData: ModifierFormInputs) => {
      const baseData = {
        ...formData,
        price:
          formData.price === undefined || isNaN(Number(formData.price))
            ? null
            : Number(formData.price),
        description:
          formData.description === undefined ? null : formData.description,
        sortOrder: formData.sortOrder ?? 0,
        isDefault: formData.isDefault ?? false,
        isActive: formData.isActive ?? true,
      };

      const dataToSend: CreateModifierInput | UpdateModifierInput = isEditing
        ? baseData
        : { ...baseData, modifierGroupId: groupId };

      try {
        await mutation.mutateAsync(dataToSend);
      } catch (error) {
        // Error manejado por onError de mutation
      }
    },
    [mutation, groupId, isEditing],
  );

  return (
    <GenericFormModal<ModifierFormInputs, Modifier>
      visible={visible}
      onDismiss={onDismiss}
      onSubmit={handleFormSubmit}
      formSchema={formSchema as z.ZodSchema<ModifierFormInputs>}
      formFields={formFields}
      editingItem={initialData ?? null}
      isSubmitting={mutation.isPending}
      modalTitle={(isEditing) =>
        isEditing ? 'Editar Modificador' : 'Crear Nuevo Modificador'
      }
      initialValues={useMemo(
        () =>
          initialData
            ? {
                name: initialData.name,
                description: initialData.description,
                price: initialData.price,
                sortOrder: initialData.sortOrder,
                isDefault: initialData.isDefault,
                isActive: initialData.isActive,
              }
            : {
                name: '',
                description: null,
                price: null,
                sortOrder: 0,
                isDefault: false,
                isActive: true,
              },
        [initialData],
      )}
    />
  );
};

export default ModifierFormModal;

================
File: app/src/modules/orderFinalization/services/orderFinalizationService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import {
  OrderForFinalization,
  OrderForFinalizationList,
  FinalizeOrdersPayload,
} from '../schema/orderFinalization.schema';

export const orderFinalizationService = {
  async getOrdersForFinalizationList(): Promise<OrderForFinalizationList[]> {
    const response = await apiClient.get(
      API_PATHS.ORDERS_FOR_FINALIZATION_LIST,
    );
    return response.data;
  },

  async getOrderForFinalizationDetail(
    orderId: string,
  ): Promise<OrderForFinalization> {
    const response = await apiClient.get(
      API_PATHS.ORDERS_FOR_FINALIZATION_DETAIL.replace(':id', orderId),
    );
    return response.data;
  },

  async finalizeOrders(payload: FinalizeOrdersPayload): Promise<void> {
    await apiClient.patch(API_PATHS.ORDERS_FINALIZE_MULTIPLE, payload);
  },

  async quickFinalizeMultipleOrders(
    orderIds: string[],
  ): Promise<{ message: string; ordersWithWarnings: string[] }> {
    const response = await apiClient.post(
      API_PATHS.ORDERS_QUICK_FINALIZE_MULTIPLE,
      { orderIds },
    );
    return response.data;
  },

  async printTicket(
    orderId: string,
    params: { printerId: string; ticketType: 'GENERAL' | 'BILLING' },
  ): Promise<void> {
    await apiClient.post(
      API_PATHS.ORDERS_PRINT_TICKET.replace(':orderId', orderId),
      params,
    );
  },
};

================
File: app/src/modules/orders/components/CartButton.tsx
================
import React, { useRef, useCallback, useMemo } from 'react';
import { StyleSheet, View, Animated } from 'react-native';
import { IconButton, Badge, useTheme, MD3Theme } from 'react-native-paper';

interface CartButtonProps {
  itemCount: number;
  onPress: () => void;
}

const createStyles = (theme: MD3Theme) =>
  StyleSheet.create({
    cartButton: {
      margin: 0,
      backgroundColor: theme.colors.surfaceVariant,
      zIndex: 999,
    },
    cartBadge: {
      position: 'absolute',
      top: 0,
      right: 0,
      backgroundColor: theme.colors.error,
      zIndex: 1000,
    },
    touchableArea: {
      padding: 5,
    },
    // Estilos adicionales para eliminar inline styles
    animatedContainer: {
      // El transform se aplica dinmicamente
    },
    badgeContainer: {
      position: 'absolute',
      top: 0,
      right: 0,
      pointerEvents: 'none',
    },
  });

const CartButton = React.forwardRef(
  ({ itemCount, onPress }: CartButtonProps, ref) => {
    const theme = useTheme();
    const cartBadgeScale = useRef(new Animated.Value(1)).current;
    const cartBounceAnimation = useRef(new Animated.Value(1)).current;
    const isPressedRef = useRef(false);

    const styles = useMemo(() => createStyles(theme), [theme]);

    const animateCartButton = () => {
      Animated.sequence([
        Animated.timing(cartBounceAnimation, {
          toValue: 1.3,
          duration: 200,
          useNativeDriver: true,
        }),
        Animated.timing(cartBounceAnimation, {
          toValue: 1,
          duration: 200,
          useNativeDriver: true,
        }),
      ]).start();

      Animated.sequence([
        Animated.timing(cartBadgeScale, {
          toValue: 1.6,
          duration: 200,
          useNativeDriver: true,
        }),
        Animated.timing(cartBadgeScale, {
          toValue: 1,
          duration: 200,
          useNativeDriver: true,
        }),
      ]).start();
    };

    React.useImperativeHandle(ref, () => ({
      animate: animateCartButton,
    }));

    const handlePress = useCallback(() => {
      if (isPressedRef.current) return;

      isPressedRef.current = true;
      onPress();

      setTimeout(() => {
        isPressedRef.current = false;
      }, 150);
    }, [onPress]);

    return (
      <View style={styles.touchableArea}>
        <Animated.View
          style={[
            styles.animatedContainer,
            { transform: [{ scale: cartBounceAnimation }] },
          ]}
        >
          <IconButton
            icon="cart-outline"
            iconColor={theme.colors.primary}
            size={30}
            onPress={handlePress}
            style={styles.cartButton}
            rippleColor={theme.colors.primary + '20'}
          />
        </Animated.View>
        {itemCount > 0 && (
          <Animated.View
            style={[
              styles.badgeContainer,
              { transform: [{ scale: cartBadgeScale }] },
            ]}
          >
            <Badge style={styles.cartBadge} size={22}>
              {itemCount}
            </Badge>
          </Animated.View>
        )}
      </View>
    );
  },
);

export default CartButton;

================
File: app/src/modules/orders/components/MenuItemCard.tsx
================
import React, { useMemo } from 'react';
import { StyleSheet, View } from 'react-native';
import { Card, Title, Text, IconButton } from 'react-native-paper';
import { AutoImage } from '@/app/components/common/AutoImage';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import type { Product, Category, SubCategory } from '../schema/orders.schema';

interface MenuItemCardProps {
  item: Category | SubCategory | Product;
  onPress: () => void;
  onLongPress?: () => void;
  onInfoPress?: () => void;
  navigationLevel: 'categories' | 'subcategories' | 'products';
  disabled?: boolean;
  showPrice?: boolean;
}

const MenuItemCard = React.memo<MenuItemCardProps>(
  ({
    item,
    onPress,
    onLongPress,
    onInfoPress,
    navigationLevel,
    disabled = false,
    showPrice = true,
  }) => {
    const theme = useAppTheme();
    const { colors } = theme;
    const responsive = useResponsive();

    const blurhash =
      '|rF?hV%2WCj[ayj[a|j[az_NaeWBj@ayfRayfQfQM{M|azj[azf6fQfQfQIpWXofj[ayj[j[fQayWCoeoeaya}j[ayfQa{oLj?j[WVj[ayayj[fQoff7azayj[ayj[j[ayofayayayj[fQj[ayayj[ayfjj[j[ayjuayj[';

    const styles = useMemo(
      () =>
        StyleSheet.create({
          cardItem: {
            flex: 1,
            minWidth: 120, // Ancho mnimo para evitar cards muy pequeos
            overflow: 'hidden',
            borderRadius: theme.roundness,
            elevation: 2,
          },
          cardItemInactive: {
            opacity: 0.5,
          },
          itemImage: {
            width: '100%',
            height: responsive.getResponsiveDimension(120, 160),
          },
          imageInactive: {
            opacity: 0.6,
          },
          cardContent: {
            paddingHorizontal: responsive.spacingPreset.s,
            paddingVertical: responsive.spacingPreset.xs,
          },
          cardTitle: {
            fontSize: responsive.fontSizePreset.m,
            fontWeight: '600',
            lineHeight: responsive.fontSizePreset.m * 1.2,
            marginBottom: responsive.spacingPreset.xs,
          },
          cardHeader: {
            flexDirection: 'row',
            justifyContent: 'space-between',
            alignItems: 'flex-start',
          },
          cardHeaderTitle: {
            flex: 1,
          },
          infoButton: {
            margin: -4,
            marginTop: -6,
            marginRight: -6,
          },
          priceText: {
            color: theme.colors.primary,
            fontWeight: '600',
            fontSize: responsive.fontSizePreset.s,
            marginTop: 2,
          },
          inactiveBadge: {
            position: 'absolute',
            top: 8,
            right: 8,
            backgroundColor: colors.errorContainer,
            paddingHorizontal: 8,
            paddingVertical: 4,
            borderRadius: 4,
          },
          inactiveBadgeText: {
            fontSize: 12,
            color: colors.onErrorContainer,
            fontWeight: '600',
          },
          warningMessage: {
            backgroundColor: colors.warningContainer || colors.errorContainer,
            paddingHorizontal: responsive.spacingPreset.s,
            paddingVertical: responsive.spacingPreset.xs,
            marginTop: responsive.spacingPreset.xs,
          },
          warningMessageText: {
            fontSize: responsive.fontSizePreset.xs,
            color: colors.onWarningContainer || colors.onErrorContainer,
            textAlign: 'center',
            lineHeight: responsive.fontSizePreset.xs * 1.3,
          },
        }),
      [colors, theme, responsive],
    );

    // Determinar si el item est activo
    const isActive = item.isActive !== false;

    // Verificar si es un producto sin pantalla de preparacin
    const isProductWithoutScreen =
      navigationLevel === 'products' &&
      'preparationScreenId' in item &&
      !item.preparationScreenId;

    // Determinar si el card est deshabilitado
    const isDisabled = disabled || !isActive || isProductWithoutScreen;

    // Obtener la URL de la imagen
    const imageSource = item.photo ? item.photo.path : null;

    // Determinar si mostrar el precio
    const shouldShowPrice = () => {
      if (!showPrice) return false;
      if (
        navigationLevel === 'products' &&
        'price' in item &&
        'hasVariants' in item
      ) {
        const productItem = item as Product;
        return (
          !productItem.hasVariants &&
          productItem.price !== null &&
          productItem.price !== undefined
        );
      }
      return false;
    };

    // Determinar si mostrar el botn de informacin
    const shouldShowInfoButton = () => {
      return (
        navigationLevel === 'products' &&
        'price' in item &&
        'description' in item &&
        (item as Product).description &&
        (item as Product).description?.trim() !== '' &&
        onInfoPress
      );
    };

    // Obtener el texto del badge
    const getBadgeText = () => {
      if (!isActive) return 'INACTIVO';
      if (isProductWithoutScreen) return 'NO DISPONIBLE';
      return null;
    };

    const badgeText = getBadgeText();

    return (
      <Card
        style={[styles.cardItem, isDisabled && styles.cardItemInactive]}
        onPress={isDisabled ? undefined : onPress}
        onLongPress={isDisabled ? undefined : onLongPress}
        disabled={isDisabled}
      >
        <AutoImage
          source={imageSource}
          style={[styles.itemImage, isDisabled && styles.imageInactive]}
          contentFit="cover"
          placeholder={blurhash}
          transition={300}
          placeholderIcon="image-outline"
        />

        {badgeText && (
          <View style={styles.inactiveBadge}>
            <Text style={styles.inactiveBadgeText}>{badgeText}</Text>
          </View>
        )}

        <View style={styles.cardContent}>
          {shouldShowInfoButton() ? (
            <View style={styles.cardHeader}>
              <Title style={[styles.cardTitle, styles.cardHeaderTitle]}>
                {item.name}
              </Title>
              <IconButton
                icon="information-outline"
                size={20}
                onPress={onInfoPress}
                style={styles.infoButton}
              />
            </View>
          ) : (
            <Title style={styles.cardTitle}>{item.name}</Title>
          )}

          {shouldShowPrice() && (
            <Text style={styles.priceText}>
              ${Number((item as Product).price).toFixed(2)}
            </Text>
          )}

          {isProductWithoutScreen && (
            <View style={styles.warningMessage}>
              <Text style={styles.warningMessageText}>
                Sin pantalla de preparacin
              </Text>
            </View>
          )}
        </View>
      </Card>
    );
  },
);

MenuItemCard.displayName = 'MenuItemCard';

export default MenuItemCard;

================
File: app/src/modules/orders/components/order-creation/ShiftClosedView.tsx
================
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, Appbar } from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';

interface ShiftClosedViewProps {
  onBack: () => void;
  userCanOpenShift: boolean;
}

export const ShiftClosedView: React.FC<ShiftClosedViewProps> = ({
  onBack,
  userCanOpenShift,
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const { colors, fonts } = theme;

  const styles = StyleSheet.create({
    safeArea: {
      flex: 1,
      backgroundColor: colors.background,
    },
    appBar: {
      backgroundColor: colors.elevation.level2,
      alignItems: 'center',
    },
    appBarTitle: {
      ...fonts.titleMedium,
      color: colors.onSurface,
      fontWeight: 'bold',
      textAlign: 'center',
    },
    appBarContent: {},
    emptyStateContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.spacingPreset.l,
    },
    emptyStateTitle: {
      marginTop: responsive.spacingPreset.l,
      marginBottom: responsive.spacingPreset.m,
      textAlign: 'center',
      color: colors.onSurface,
      fontWeight: '600',
    },
    emptyStateText: {
      textAlign: 'center',
      color: colors.onSurfaceVariant,
      maxWidth: 320,
      lineHeight: 24,
    },
  });

  return (
    <SafeAreaView style={styles.safeArea} edges={['left', 'right', 'bottom']}>
      <Appbar.Header style={styles.appBar} elevated>
        <Appbar.BackAction onPress={onBack} />
        <Appbar.Content
          title="Crear Orden"
          titleStyle={styles.appBarTitle}
          style={styles.appBarContent}
        />
      </Appbar.Header>
      <View style={styles.emptyStateContainer}>
        <MaterialCommunityIcons
          name="store-alert"
          size={64}
          color={theme.colors.onSurfaceVariant}
        />
        <Text variant="headlineSmall" style={styles.emptyStateTitle}>
          Turno Cerrado
        </Text>
        <Text variant="bodyLarge" style={styles.emptyStateText}>
          {userCanOpenShift
            ? 'Para crear rdenes, primero debes abrir el turno usando el indicador en la barra superior.'
            : 'El turno debe estar abierto para crear rdenes. Contacta a un administrador.'}
        </Text>
      </View>
    </SafeAreaView>
  );
};

================
File: app/src/modules/orders/hooks/order-cart/useOrderTypeLogic.ts
================
import { useState, useCallback, useEffect } from 'react';
import { OrderTypeEnum, type OrderType } from '../../schema/orders.schema';
import type { DeliveryInfo } from '@/app/schemas/domain/delivery-info.schema';

interface OrderTypeState {
  orderType: OrderType;
  selectedAreaId: string | null;
  selectedTableId: string | null;
  isTemporaryTable: boolean;
  temporaryTableName: string;
  scheduledTime: Date | null;
  deliveryInfo: DeliveryInfo;
  orderNotes: string;
}


export const useOrderTypeLogic = (
  initialState?: Partial<OrderTypeState>,
) => {
  // Estados principales
  const [orderType, setOrderType] = useState<OrderType>(
    initialState?.orderType || OrderTypeEnum.DINE_IN,
  );
  const [selectedAreaId, setSelectedAreaId] = useState<string | null>(
    initialState?.selectedAreaId || null,
  );
  const [selectedTableId, setSelectedTableId] = useState<string | null>(
    initialState?.selectedTableId || null,
  );
  const [isTemporaryTable, setIsTemporaryTable] = useState<boolean>(
    initialState?.isTemporaryTable || false,
  );
  const [temporaryTableName, setTemporaryTableName] = useState<string>(
    initialState?.temporaryTableName || '',
  );
  const [scheduledTime, setScheduledTime] = useState<Date | null>(
    initialState?.scheduledTime || null,
  );
  const [deliveryInfo, setDeliveryInfo] = useState<DeliveryInfo>(
    initialState?.deliveryInfo || {},
  );
  const [orderNotes, setOrderNotes] = useState<string>(
    initialState?.orderNotes || '',
  );

  // Estados de validacin
  const [areaError, setAreaError] = useState<string | null>(null);
  const [tableError, setTableError] = useState<string | null>(null);
  const [recipientNameError, setRecipientNameError] = useState<string | null>(
    null,
  );
  const [recipientPhoneError, setRecipientPhoneError] = useState<string | null>(
    null,
  );
  const [addressError, setAddressError] = useState<string | null>(null);

  // Limpiar errores al cambiar tipo de orden
  useEffect(() => {
    setAreaError(null);
    setTableError(null);
    setRecipientNameError(null);
    setRecipientPhoneError(null);
    setAddressError(null);
  }, [orderType]);

  // Validacin para DINE_IN
  const validateDineIn = useCallback((): boolean => {
    let isValid = true;

    if (!isTemporaryTable) {
      if (!selectedAreaId) {
        setAreaError('Por favor selecciona un rea');
        isValid = false;
      } else {
        setAreaError(null);
      }

      if (!selectedTableId) {
        setTableError('Por favor selecciona una mesa');
        isValid = false;
      } else {
        setTableError(null);
      }
    } else {
      if (!temporaryTableName.trim()) {
        setTableError('Por favor ingresa el nombre de la mesa temporal');
        isValid = false;
      } else {
        setTableError(null);
      }

      if (!selectedAreaId) {
        setAreaError('Por favor selecciona un rea para la mesa temporal');
        isValid = false;
      } else {
        setAreaError(null);
      }
    }

    return isValid;
  }, [isTemporaryTable, selectedAreaId, selectedTableId, temporaryTableName]);

  // Validacin para DELIVERY
  const validateDelivery = useCallback((): boolean => {
    let isValid = true;

    if (!deliveryInfo.recipientName?.trim()) {
      setRecipientNameError('El nombre es requerido');
      isValid = false;
    } else {
      setRecipientNameError(null);
    }

    if (!deliveryInfo.recipientPhone?.trim()) {
      setRecipientPhoneError('El telfono es requerido');
      isValid = false;
    } else {
      setRecipientPhoneError(null);
    }

    if (!deliveryInfo.fullAddress?.trim()) {
      setAddressError('La direccin es requerida');
      isValid = false;
    } else {
      setAddressError(null);
    }

    return isValid;
  }, [deliveryInfo]);

  // Validacin para TAKE_AWAY
  const validateTakeAway = useCallback((): boolean => {
    let isValid = true;

    if (!deliveryInfo.recipientName?.trim()) {
      setRecipientNameError('El nombre es requerido');
      isValid = false;
    } else {
      setRecipientNameError(null);
    }

    if (!deliveryInfo.recipientPhone?.trim()) {
      setRecipientPhoneError('El telfono es requerido');
      isValid = false;
    } else {
      setRecipientPhoneError(null);
    }

    return isValid;
  }, [deliveryInfo]);

  // Validacin general
  const validate = useCallback((): boolean => {
    switch (orderType) {
      case OrderTypeEnum.DINE_IN:
        return validateDineIn();
      case OrderTypeEnum.DELIVERY:
        return validateDelivery();
      case OrderTypeEnum.TAKE_AWAY:
        return validateTakeAway();
      default:
        return true;
    }
  }, [orderType, validateDineIn, validateDelivery, validateTakeAway]);

  // Limpiar datos segn el tipo de orden
  const cleanOrderDataForSubmission = useCallback(
    (orderType: OrderType) => {
      const cleanedData: {
        deliveryInfo: DeliveryInfo;
        tableId?: string;
        isTemporaryTable?: boolean;
        temporaryTableName?: string;
        temporaryTableAreaId?: string;
      } = {
        deliveryInfo: {},
      };

      switch (orderType) {
        case OrderTypeEnum.DINE_IN:
          if (isTemporaryTable) {
            cleanedData.isTemporaryTable = true;
            cleanedData.temporaryTableName = temporaryTableName;
            cleanedData.temporaryTableAreaId = selectedAreaId || undefined;
          } else {
            cleanedData.tableId = selectedTableId || undefined;
          }
          break;

        case OrderTypeEnum.DELIVERY:
          cleanedData.deliveryInfo = {
            recipientName: deliveryInfo.recipientName,
            recipientPhone: deliveryInfo.recipientPhone,
            fullAddress: deliveryInfo.fullAddress,
            city: deliveryInfo.city,
            neighborhood: deliveryInfo.neighborhood,
            deliveryInstructions: deliveryInfo.deliveryInstructions,
          };
          break;

        case OrderTypeEnum.TAKE_AWAY:
          cleanedData.deliveryInfo = {
            recipientName: deliveryInfo.recipientName,
            recipientPhone: deliveryInfo.recipientPhone,
          };
          break;

        default:
          break;
      }

      return cleanedData;
    },
    [
      isTemporaryTable,
      temporaryTableName,
      selectedAreaId,
      selectedTableId,
      deliveryInfo,
    ],
  );

  return {
    // Estados
    orderType,
    selectedAreaId,
    selectedTableId,
    isTemporaryTable,
    temporaryTableName,
    scheduledTime,
    deliveryInfo,
    orderNotes,

    // Setters
    setOrderType,
    setSelectedAreaId,
    setSelectedTableId,
    setIsTemporaryTable,
    setTemporaryTableName,
    setScheduledTime,
    setDeliveryInfo,
    setOrderNotes,

    // Errores
    areaError,
    tableError,
    recipientNameError,
    recipientPhoneError,
    addressError,

    // Funciones
    validate,
    cleanOrderDataForSubmission,
  };
};

================
File: app/src/modules/orders/hooks/order-creation/useOrderCreation.ts
================
import { useState, useRef, useEffect } from 'react';
import { useNavigation } from '@react-navigation/native';
import { useCreateOrderMutation } from '../../hooks/useOrdersQueries';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { getApiErrorMessage } from '@/app/lib/errorMapping';
import type { OrderDetailsForBackend } from '../../stores/useOrderStore';

interface UseOrderCreationProps {
  hideCart: () => void;
  resetOrder: () => void;
  isCartEmpty: boolean;
}

export const useOrderCreation = ({
  hideCart,
  resetOrder,
  isCartEmpty,
}: UseOrderCreationProps) => {
  const navigation = useNavigation();
  const createOrderMutation = useCreateOrderMutation();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const [isProcessingOrder, setIsProcessingOrder] = useState(false);
  const [showExitConfirmationModal, setShowExitConfirmationModal] =
    useState(false);
  const [pendingNavigationAction, setPendingNavigationAction] = useState<
    (() => void) | null
  >(null);
  const isProcessingOrderRef = useRef(false);

  const handleConfirmOrder = async (details: OrderDetailsForBackend) => {
    if (isProcessingOrderRef.current) return;
    isProcessingOrderRef.current = true;
    setIsProcessingOrder(true);

    try {
      const createdOrder = await createOrderMutation.mutateAsync(details);

      showSnackbar({
        message: `Orden #${createdOrder.shiftOrderNumber} creada con xito`,
        type: 'success',
      });
      hideCart();
      resetOrder();

      setTimeout(() => {
        navigation.goBack();
      }, 100);
    } catch (error) {
      const message = getApiErrorMessage(error as Error);
      showSnackbar({
        message: `Error al crear orden: ${message}`,
        type: 'error',
      });
    } finally {
      setIsProcessingOrder(false);
      isProcessingOrderRef.current = false;
    }
  };

  const handleAttemptExit = (goBackAction: () => void) => {
    if (isCartEmpty) {
      goBackAction();
    } else {
      setPendingNavigationAction(() => goBackAction);
      setShowExitConfirmationModal(true);
    }
  };

  const handleConfirmExit = () => {
    setShowExitConfirmationModal(false);
    const navigationAction =
      pendingNavigationAction || (() => navigation.goBack());
    setPendingNavigationAction(null);
    navigationAction();
    setTimeout(() => {
      resetOrder();
    }, 100);
  };

  const handleCancelExit = () => {
    setShowExitConfirmationModal(false);
    setPendingNavigationAction(null);
  };

  useEffect(() => {
    const unsubscribe = navigation.addListener('beforeRemove', (e: any) => {
      if (isCartEmpty || showExitConfirmationModal || isProcessingOrder) {
        return;
      }

      e.preventDefault();
      setPendingNavigationAction(
        () => () => navigation.dispatch(e.data.action),
      );
      setShowExitConfirmationModal(true);
    });

    return unsubscribe;
  }, [navigation, isCartEmpty, showExitConfirmationModal, isProcessingOrder]);

  return {
    isProcessingOrder,
    showExitConfirmationModal,
    handleConfirmOrder,
    handleAttemptExit,
    handleConfirmExit,
    handleCancelExit,
  };
};

================
File: app/src/modules/orders/hooks/order-creation/useOrderNavigation.ts
================
import { useState, useCallback } from 'react';
import { Product } from '../../schema/orders.schema';

export type NavigationLevel = 'categories' | 'subcategories' | 'products';

export const useOrderNavigation = () => {
  const [navigationLevel, setNavigationLevel] =
    useState<NavigationLevel>('categories');
  const [selectedCategoryId, setSelectedCategoryId] = useState<string | null>(
    null,
  );
  const [selectedSubcategoryId, setSelectedSubcategoryId] = useState<
    string | null
  >(null);
  const [selectedProduct, setSelectedProduct] = useState<Product | null>(null);

  const handleCategorySelect = useCallback((categoryId: string) => {
    setSelectedCategoryId(categoryId);
    setSelectedSubcategoryId(null);
    setNavigationLevel('subcategories');
  }, []);

  const handleSubCategorySelect = useCallback((subcategoryId: string) => {
    setSelectedSubcategoryId(subcategoryId);
    setNavigationLevel('products');
  }, []);

  const handleGoBackInternal = useCallback(() => {
    if (navigationLevel === 'products') {
      setNavigationLevel('subcategories');
      setSelectedSubcategoryId(null);
    } else if (navigationLevel === 'subcategories') {
      setNavigationLevel('categories');
      setSelectedCategoryId(null);
    }
  }, [navigationLevel]);

  const resetNavigation = useCallback(() => {
    setNavigationLevel('categories');
    setSelectedCategoryId(null);
    setSelectedSubcategoryId(null);
    setSelectedProduct(null);
  }, []);

  return {
    navigationLevel,
    selectedCategoryId,
    selectedSubcategoryId,
    selectedProduct,
    setSelectedProduct,
    handleCategorySelect,
    handleSubCategorySelect,
    handleGoBackInternal,
    resetNavigation,
  };
};

================
File: app/src/modules/orders/hooks/useMenuQueries.ts
================
import { useQuery } from '@tanstack/react-query';
import { useEffect } from 'react';
// Importar desde el servicio de categoras
import { getOrderMenu } from '@/modules/menu/services/categoryService';
// Importar el tipo de men completo con relaciones anidadas
import type { FullMenuCategory } from '@/modules/orders/schema/orders.schema';
import { ApiError } from '@/app/lib/errors';
import { prefetchMenuImages } from '@/app/lib/imageCache';

// Define clave nica para la query
const orderMenuQueryKey = ['orderMenu'];

/**
 * Hook para obtener el men completo con todas las relaciones.
 * Usado para validar modificadores y configuraciones.
 */
export function useFullMenuQuery() {
  return useQuery<FullMenuCategory[], ApiError>({
    queryKey: ['fullMenu'],
    queryFn: getOrderMenu,
    staleTime: 5 * 60 * 1000, // 5 minutos
    refetchOnWindowFocus: false,
  });
}

/**
 * Hook para obtener el men en pantallas de creacin y edicin de rdenes.
 * Devuelve solo los campos necesarios para mejorar el rendimiento.
 */
export function useGetOrderMenu() {
  const query = useQuery<FullMenuCategory[], ApiError>({
    queryKey: orderMenuQueryKey,
    queryFn: getOrderMenu,
    refetchInterval: 10000, // Actualizar cada 10 segundos
    refetchIntervalInBackground: false, // No actualizar cuando la app est en background
    refetchOnWindowFocus: true,
    refetchOnMount: true,
    staleTime: 5000, // Los datos se consideran frescos por 5 segundos
    // IMPORTANTE: Mantener datos previos durante refetch para evitar parpadeos
    placeholderData: (previousData) => previousData,
    // No mostrar loading en refetch para mantener la UI estable
    notifyOnChangeProps: ['data', 'error'],
  });

  // Prefetch de imgenes cuando se cargan los datos del men
  useEffect(() => {
    if (query.data && query.data.length > 0) {
      // Prefetch en background sin bloquear la UI
      prefetchMenuImages(query.data, {
        maxConcurrent: 3, // Limitar concurrencia para no saturar la red
      }).catch(() => {
        // Silenciar errores de prefetch para no afectar la UX
      });
    }
  }, [query.data]);

  return query;
}

================
File: app/src/modules/orders/hooks/useOrderCalculations.ts
================
import { useMemo } from 'react';
import type { CartItem } from '../stores/useOrderStore';
import type { OrderAdjustment } from '../schema/adjustments.schema';
import type { Payment } from '../schema/payment.schema';
import { PaymentStatusEnum } from '../schema/payment.schema';

interface UseOrderCalculationsProps {
  items: CartItem[];
  adjustments?: OrderAdjustment[];
  payments?: Payment[];
}

interface UseOrderCalculationsReturn {
  subtotal: number;
  adjustmentTotal: number;
  total: number;
  totalPaid: number;
  remainingAmount: number;
  hasPayments: boolean;
  canMakePayment: boolean;
  calculateItemTotal: (item: CartItem) => number;
  calculateAdjustmentAmount: (
    adjustment: OrderAdjustment,
    subtotal: number,
  ) => number;
}

export const useOrderCalculations = ({
  items,
  adjustments = [],
  payments = [],
}: UseOrderCalculationsProps): UseOrderCalculationsReturn => {
  // Funcin para calcular el total de un item
  const calculateItemTotal = (item: CartItem): number => {
    // Si el item ya tiene totalPrice calculado, usarlo
    if (
      item.totalPrice !== undefined &&
      item.totalPrice !== null &&
      !isNaN(item.totalPrice)
    ) {
      return item.totalPrice;
    }

    // Si no, calcularlo basado en unitPrice
    const basePrice = item.unitPrice || 0;
    const modifiersTotal = item.modifiers.reduce(
      (sum, modifier) => sum + (modifier.price || 0),
      0,
    );
    return (basePrice + modifiersTotal) * item.quantity;
  };

  // Funcin para calcular el monto de un ajuste
  const calculateAdjustmentAmount = (
    adjustment: OrderAdjustment,
    subtotal: number,
  ): number => {
    if (adjustment.isPercentage && adjustment.value !== undefined) {
      return (subtotal * adjustment.value) / 100;
    }
    return adjustment.amount || 0;
  };

  // Calcular subtotal (suma de todos los items)
  const subtotal = useMemo(() => {
    const total = items.reduce((sum, item) => {
      const itemTotal = calculateItemTotal(item);
      // Verificar que no sea NaN
      return sum + (isNaN(itemTotal) ? 0 : itemTotal);
    }, 0);
    return isNaN(total) ? 0 : total;
  }, [items]);

  // Calcular total de ajustes
  const adjustmentTotal = useMemo(() => {
    return adjustments.reduce((total, adjustment) => {
      const amount = calculateAdjustmentAmount(adjustment, subtotal);
      return total + amount;
    }, 0);
  }, [adjustments, subtotal]);

  // Calcular total final
  const total = useMemo(() => {
    const finalTotal = subtotal + adjustmentTotal;
    return Math.max(0, finalTotal); // No permitir totales negativos
  }, [subtotal, adjustmentTotal]);

  // Calcular total pagado (solo pagos completados o pendientes)
  const totalPaid = useMemo(() => {
    return payments
      .filter(
        (payment) =>
          payment.paymentStatus === PaymentStatusEnum.COMPLETED ||
          payment.paymentStatus === PaymentStatusEnum.PENDING,
      )
      .reduce((sum, payment) => sum + payment.amount, 0);
  }, [payments]);

  // Calcular monto restante
  const remainingAmount = useMemo(() => {
    return Math.max(0, total - totalPaid);
  }, [total, totalPaid]);

  // Verificar si hay pagos
  const hasPayments = useMemo(() => {
    return payments.length > 0;
  }, [payments]);

  // Verificar si se puede hacer un pago
  const canMakePayment = useMemo(() => {
    return total > 0 && remainingAmount > 0;
  }, [total, remainingAmount]);

  return {
    subtotal,
    adjustmentTotal,
    total,
    totalPaid,
    remainingAmount,
    hasPayments,
    canMakePayment,
    calculateItemTotal,
    calculateAdjustmentAmount,
  };
};

================
File: app/src/modules/orders/hooks/useOrderDataLoader.ts
================
import { useEffect, useCallback } from 'react';
import type { CartItem } from '../stores/useOrderStore';
import type { OrderAdjustment } from '../schema/adjustments.schema';
import type { DeliveryInfo } from '@/app/schemas/domain/delivery-info.schema';
import type { OrderType } from '../schema/orders.schema';
import { useFullMenuQuery } from './useMenuQueries';

interface CartItemModifier {
  id: string;
  modifierGroupId: string;
  name: string;
  price: number;
}

interface OrderDataLoaderProps {
  isEditMode: boolean;
  orderData: any;
  visible: boolean;
  setEditOrderType: (orderType: OrderType) => void;
  setEditSelectedTableId: (tableId: string | null) => void;
  setEditScheduledTime: (time: Date | null) => void;
  setEditDeliveryInfo: (info: DeliveryInfo) => void;
  setEditOrderNotes: (notes: string) => void;
  setEditAdjustments: (adjustments: OrderAdjustment[]) => void;
  setEditSelectedAreaId: (areaId: string | null) => void;
  setEditIsTemporaryTable: (isTemporary: boolean) => void;
  setEditTemporaryTableName: (name: string) => void;
  setEditItems: (items: CartItem[]) => void;
  setOrderDataLoaded: (loaded: boolean) => void;
  setOriginalOrderState: (state: any) => void;
  setHasUnsavedChanges: (hasChanges: boolean) => void;
}

export const useOrderDataLoader = ({
  isEditMode,
  orderData,
  visible,
  setEditOrderType,
  setEditSelectedTableId,
  setEditScheduledTime,
  setEditDeliveryInfo,
  setEditOrderNotes,
  setEditAdjustments,
  setEditSelectedAreaId,
  setEditIsTemporaryTable,
  setEditTemporaryTableName,
  setEditItems,
  setOrderDataLoaded,
  setOriginalOrderState,
  setHasUnsavedChanges,
}: OrderDataLoaderProps) => {
  const { data: fullMenuData } = useFullMenuQuery();

  const findModifierById = useCallback(
    (modifierId: string) => {
      if (!fullMenuData) return null;

      for (const category of fullMenuData) {
        for (const subcategory of category.subcategories || []) {
          for (const product of subcategory.products || []) {
            for (const group of product.modifierGroups || []) {
              for (const modifier of group.productModifiers || []) {
                if (modifier.id === modifierId) {
                  return {
                    id: modifier.id,
                    modifierGroupId: group.id,
                    name: modifier.name,
                    price: modifier.price || 0,
                  };
                }
              }
            }
          }
        }
      }
      return null;
    },
    [fullMenuData],
  );

  useEffect(() => {
    if (!isEditMode || !orderData || !visible) return;

    setEditOrderType(orderData.orderType);
    setEditSelectedTableId(orderData.tableId ?? null);
    setEditScheduledTime(
      orderData.scheduledAt ? new Date(orderData.scheduledAt) : null,
    );
    setEditDeliveryInfo(orderData.deliveryInfo || {});
    setEditOrderNotes(orderData.notes ?? '');

    if (orderData.adjustments && Array.isArray(orderData.adjustments)) {
      const mappedAdjustments = orderData.adjustments.map((adj: any) => ({
        id: adj.id,
        name: adj.name,
        description: adj.description || '',
        isPercentage: adj.isPercentage,
        value: adj.value,
        amount: adj.amount,
        isDeleted: false,
        isNew: false,
      }));
      setEditAdjustments(mappedAdjustments);
    } else {
      setEditAdjustments([]);
    }

    if (orderData.tableId && orderData.table) {
      const areaId = orderData.table.areaId || orderData.table.area?.id;
      if (areaId) {
        setEditSelectedAreaId(areaId);
      }

      if (orderData.table.isTemporary) {
        setEditIsTemporaryTable(true);
        setEditTemporaryTableName(orderData.table.name || '');
      } else {
        setEditIsTemporaryTable(false);
        setEditTemporaryTableName('');
      }
    } else {
      setEditIsTemporaryTable(false);
      setEditTemporaryTableName('');
    }

    const groupedItemsMap = new Map<string, CartItem>();

    if (orderData.orderItems && Array.isArray(orderData.orderItems)) {
      orderData.orderItems.forEach((item: any) => {
        const modifiers: CartItemModifier[] = [];

        if (item.modifiers && Array.isArray(item.modifiers)) {
          item.modifiers.forEach((mod: any) => {
            modifiers.push({
              id: mod.productModifierId,
              modifierGroupId: mod.productModifier?.modifierGroupId || '',
              name: mod.productModifier?.name || 'Modificador',
              price: parseFloat(mod.price) || 0,
            });
          });
        } else if (
          item.productModifiers &&
          Array.isArray(item.productModifiers)
        ) {
          item.productModifiers.forEach((mod: any) => {
            const modifierInfo = findModifierById(mod.id) || {
              id: mod.id,
              modifierGroupId: mod.modifierGroupId || '',
              name: mod.name || 'Modificador',
              price: parseFloat(mod.price?.toString() || '0') || 0,
            };
            modifiers.push(modifierInfo);
          });
        }

        const modifiersPrice = modifiers.reduce(
          (sum: number, mod: any) => sum + (parseFloat(mod.price) || 0),
          0,
        );
        const unitPrice = parseFloat(item.basePrice || '0');

        const modifierIds = modifiers
          .map((m) => m.id)
          .sort()
          .join(',');
        const pizzaCustomizationIds = item.selectedPizzaCustomizations
          ? item.selectedPizzaCustomizations
              .map(
                (c: any) => `${c.pizzaCustomizationId}-${c.half}-${c.action}`,
              )
              .sort()
              .join(',')
          : '';
        const groupKey = `${item.productId}-${item.productVariantId || 'null'}-${modifierIds}-${pizzaCustomizationIds}-${item.preparationNotes || ''}-${item.preparationStatus || 'PENDING'}`;

        const existingItem = groupedItemsMap.get(groupKey);

        if (
          existingItem &&
          existingItem.preparationStatus === item.preparationStatus
        ) {
          existingItem.quantity += 1;
          existingItem.totalPrice =
            (unitPrice + modifiersPrice) * existingItem.quantity;
          existingItem.id = `${existingItem.id},${item.id}`;
        } else {
          const cartItem: CartItem = {
            id: item.id,
            productId: item.productId,
            productName: item.product?.name || 'Producto desconocido',
            quantity: 1,
            unitPrice,
            totalPrice: unitPrice + modifiersPrice,
            modifiers,
            variantId: item.productVariantId || undefined,
            variantName: item.productVariant?.name || undefined,
            preparationNotes: item.preparationNotes || undefined,
            preparationStatus: item.preparationStatus || 'PENDING',
            selectedPizzaCustomizations:
              item.selectedPizzaCustomizations || undefined,
          };
          groupedItemsMap.set(groupKey, cartItem);
        }
      });

      const mappedItems = Array.from(groupedItemsMap.values());
      setEditItems(mappedItems);
    }

    setOrderDataLoaded(true);

    const originalItems = Array.from(groupedItemsMap.values());
    const originalAdjustments =
      orderData.adjustments?.map((adj: any) => ({
        id: adj.id,
        name: adj.name,
        isPercentage: adj.isPercentage,
        value: adj.value,
        amount: adj.amount,
      })) || [];

    setOriginalOrderState({
      items: originalItems,
      orderType: orderData.orderType,
      tableId: orderData.tableId ?? null,
      isTemporaryTable: orderData.table?.isTemporary || false,
      temporaryTableName: orderData.table?.isTemporary
        ? orderData.table.name
        : '',
      deliveryInfo: orderData.deliveryInfo || {},
      notes: orderData.notes ?? '',
      scheduledAt: orderData.scheduledAt
        ? new Date(orderData.scheduledAt)
        : null,
      adjustments: originalAdjustments,
    });

    setHasUnsavedChanges(false);
  }, [
    isEditMode,
    orderData,
    visible,
    findModifierById,
    setEditOrderType,
    setEditSelectedTableId,
    setEditScheduledTime,
    setEditDeliveryInfo,
    setEditOrderNotes,
    setEditAdjustments,
    setEditSelectedAreaId,
    setEditIsTemporaryTable,
    setEditTemporaryTableName,
    setEditItems,
    setOrderDataLoaded,
    setOriginalOrderState,
    setHasUnsavedChanges,
  ]);

  return {
    findModifierById,
  };
};

================
File: app/src/modules/orders/hooks/useOrderState.ts
================
import { useState, useCallback } from 'react';
import { OrderTypeEnum, type OrderType } from '../schema/orders.schema';
import type { DeliveryInfo } from '@/app/schemas/domain/delivery-info.schema';
import type { CartItem } from '../stores/useOrderStore';
import type { OrderAdjustment } from '../schema/adjustments.schema';

interface OrderState {
  // Edit mode states
  editItems: CartItem[];
  editOrderType: OrderType;
  editSelectedAreaId: string | null;
  editSelectedTableId: string | null;
  editScheduledTime: Date | null;
  editDeliveryInfo: DeliveryInfo;
  editOrderNotes: string;
  editAdjustments: OrderAdjustment[];
  editIsTemporaryTable: boolean;
  editTemporaryTableName: string;

  // Processing states
  processedPendingProductsIds: string[];
  orderDataLoaded: boolean;

  // UI states
  isTimePickerVisible: boolean;
  isTimeAlertVisible: boolean;
  isConfirming: boolean;
  showExitConfirmation: boolean;
  isModalReady: boolean;
  showOptionsMenu: boolean;
  showCancelConfirmation: boolean;
  showModifyInProgressConfirmation: boolean;
  pendingModifyAction: (() => void) | null;
  modifyingItemName: string;
  showHistoryModal: boolean;
  showDetailModal: boolean;
  showPaymentModal: boolean;
  showAdjustmentModal: boolean;
  adjustmentToEdit: OrderAdjustment | null;
  hasUnsavedChanges: boolean;

  // Original order state for comparison
  originalOrderState: {
    items: CartItem[];
    orderType: OrderType;
    tableId: string | null;
    isTemporaryTable: boolean;
    temporaryTableName: string;
    deliveryInfo: DeliveryInfo;
    notes: string;
    scheduledAt: Date | null;
    adjustments: OrderAdjustment[];
  } | null;

  // Tracking states
  lastNotifiedCount: number | null;
}

interface UseOrderStateReturn extends OrderState {
  // Setters for edit mode states
  setEditItems: React.Dispatch<React.SetStateAction<CartItem[]>>;
  setEditOrderType: React.Dispatch<React.SetStateAction<OrderType>>;
  setEditSelectedAreaId: React.Dispatch<React.SetStateAction<string | null>>;
  setEditSelectedTableId: React.Dispatch<React.SetStateAction<string | null>>;
  setEditScheduledTime: React.Dispatch<React.SetStateAction<Date | null>>;
  setEditDeliveryInfo: React.Dispatch<React.SetStateAction<DeliveryInfo>>;
  setEditOrderNotes: React.Dispatch<React.SetStateAction<string>>;
  setEditAdjustments: React.Dispatch<React.SetStateAction<OrderAdjustment[]>>;
  setEditIsTemporaryTable: React.Dispatch<React.SetStateAction<boolean>>;
  setEditTemporaryTableName: React.Dispatch<React.SetStateAction<string>>;

  // Setters for processing states
  setProcessedPendingProductsIds: React.Dispatch<
    React.SetStateAction<string[]>
  >;
  setOrderDataLoaded: React.Dispatch<React.SetStateAction<boolean>>;

  // Setters for UI states
  setTimePickerVisible: React.Dispatch<React.SetStateAction<boolean>>;
  setTimeAlertVisible: React.Dispatch<React.SetStateAction<boolean>>;
  setIsConfirming: React.Dispatch<React.SetStateAction<boolean>>;
  setShowExitConfirmation: React.Dispatch<React.SetStateAction<boolean>>;
  setIsModalReady: React.Dispatch<React.SetStateAction<boolean>>;
  setShowOptionsMenu: React.Dispatch<React.SetStateAction<boolean>>;
  setShowCancelConfirmation: React.Dispatch<React.SetStateAction<boolean>>;
  setShowModifyInProgressConfirmation: React.Dispatch<
    React.SetStateAction<boolean>
  >;
  setPendingModifyAction: React.Dispatch<
    React.SetStateAction<(() => void) | null>
  >;
  setModifyingItemName: React.Dispatch<React.SetStateAction<string>>;
  setShowHistoryModal: React.Dispatch<React.SetStateAction<boolean>>;
  setShowDetailModal: React.Dispatch<React.SetStateAction<boolean>>;
  setShowPaymentModal: React.Dispatch<React.SetStateAction<boolean>>;
  setShowAdjustmentModal: React.Dispatch<React.SetStateAction<boolean>>;
  setAdjustmentToEdit: React.Dispatch<
    React.SetStateAction<OrderAdjustment | null>
  >;
  setHasUnsavedChanges: React.Dispatch<React.SetStateAction<boolean>>;

  // Setters for tracking states
  setOriginalOrderState: React.Dispatch<
    React.SetStateAction<OrderState['originalOrderState']>
  >;
  setLastNotifiedCount: React.Dispatch<React.SetStateAction<number | null>>;

  // Helper functions
  resetEditModeStates: () => void;
  showTimePicker: () => void;
  hideTimePicker: () => void;
}

export const useOrderState = (): UseOrderStateReturn => {
  // Edit mode states
  const [editItems, setEditItems] = useState<CartItem[]>([]);
  const [editOrderType, setEditOrderType] = useState<OrderType>(
    OrderTypeEnum.DINE_IN,
  );
  const [editSelectedAreaId, setEditSelectedAreaId] = useState<string | null>(
    null,
  );
  const [editSelectedTableId, setEditSelectedTableId] = useState<string | null>(
    null,
  );
  const [editScheduledTime, setEditScheduledTime] = useState<Date | null>(null);
  const [editDeliveryInfo, setEditDeliveryInfo] = useState<DeliveryInfo>({});
  const [editOrderNotes, setEditOrderNotes] = useState<string>('');
  const [editAdjustments, setEditAdjustments] = useState<OrderAdjustment[]>([]);
  const [editIsTemporaryTable, setEditIsTemporaryTable] =
    useState<boolean>(false);
  const [editTemporaryTableName, setEditTemporaryTableName] =
    useState<string>('');

  // Processing states
  const [processedPendingProductsIds, setProcessedPendingProductsIds] =
    useState<string[]>([]);
  const [orderDataLoaded, setOrderDataLoaded] = useState(false);

  // UI states
  const [isTimePickerVisible, setTimePickerVisible] = useState(false);
  const [isTimeAlertVisible, setTimeAlertVisible] = useState(false);
  const [isConfirming, setIsConfirming] = useState(false);
  const [showExitConfirmation, setShowExitConfirmation] = useState(false);
  const [isModalReady, setIsModalReady] = useState(false);
  const [showOptionsMenu, setShowOptionsMenu] = useState(false);
  const [showCancelConfirmation, setShowCancelConfirmation] = useState(false);
  const [
    showModifyInProgressConfirmation,
    setShowModifyInProgressConfirmation,
  ] = useState(false);
  const [pendingModifyAction, setPendingModifyAction] = useState<
    (() => void) | null
  >(null);
  const [modifyingItemName, setModifyingItemName] = useState<string>('');
  const [showHistoryModal, setShowHistoryModal] = useState(false);
  const [showDetailModal, setShowDetailModal] = useState(false);
  const [showPaymentModal, setShowPaymentModal] = useState(false);
  const [showAdjustmentModal, setShowAdjustmentModal] = useState(false);
  const [adjustmentToEdit, setAdjustmentToEdit] =
    useState<OrderAdjustment | null>(null);
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);

  // Original order state
  const [originalOrderState, setOriginalOrderState] =
    useState<OrderState['originalOrderState']>(null);

  // Tracking states
  const [lastNotifiedCount, setLastNotifiedCount] = useState<number | null>(
    null,
  );

  // Helper functions
  const resetEditModeStates = useCallback(() => {
    setEditOrderType(OrderTypeEnum.DINE_IN);
    setEditSelectedAreaId(null);
    setEditSelectedTableId(null);
    setEditScheduledTime(null);
    setEditDeliveryInfo({});
    setEditOrderNotes('');
    setEditItems([]);
    setEditAdjustments([]);
    setEditIsTemporaryTable(false);
    setEditTemporaryTableName('');
    setShowExitConfirmation(false);
    setIsModalReady(false);
    setOrderDataLoaded(false);
    setProcessedPendingProductsIds([]);
    setLastNotifiedCount(null);
    setOriginalOrderState(null);
    setHasUnsavedChanges(false);
  }, []);

  const showTimePicker = useCallback(() => {
    setTimePickerVisible(true);
  }, []);

  const hideTimePicker = useCallback(() => {
    setTimePickerVisible(false);
  }, []);

  return {
    // States
    editItems,
    editOrderType,
    editSelectedAreaId,
    editSelectedTableId,
    editScheduledTime,
    editDeliveryInfo,
    editOrderNotes,
    editAdjustments,
    editIsTemporaryTable,
    editTemporaryTableName,
    processedPendingProductsIds,
    orderDataLoaded,
    isTimePickerVisible,
    isTimeAlertVisible,
    isConfirming,
    showExitConfirmation,
    isModalReady,
    showOptionsMenu,
    showCancelConfirmation,
    showModifyInProgressConfirmation,
    pendingModifyAction,
    modifyingItemName,
    showHistoryModal,
    showDetailModal,
    showPaymentModal,
    showAdjustmentModal,
    adjustmentToEdit,
    hasUnsavedChanges,
    originalOrderState,
    lastNotifiedCount,

    // Setters
    setEditItems,
    setEditOrderType,
    setEditSelectedAreaId,
    setEditSelectedTableId,
    setEditScheduledTime,
    setEditDeliveryInfo,
    setEditOrderNotes,
    setEditAdjustments,
    setEditIsTemporaryTable,
    setEditTemporaryTableName,
    setProcessedPendingProductsIds,
    setOrderDataLoaded,
    setTimePickerVisible,
    setTimeAlertVisible,
    setIsConfirming,
    setShowExitConfirmation,
    setIsModalReady,
    setShowOptionsMenu,
    setShowCancelConfirmation,
    setShowModifyInProgressConfirmation,
    setPendingModifyAction,
    setModifyingItemName,
    setShowHistoryModal,
    setShowDetailModal,
    setShowPaymentModal,
    setShowAdjustmentModal,
    setAdjustmentToEdit,
    setHasUnsavedChanges,
    setOriginalOrderState,
    setLastNotifiedCount,

    // Helper functions
    resetEditModeStates,
    showTimePicker,
    hideTimePicker,
  };
};

================
File: app/src/modules/orders/hooks/useOrderType.ts
================
import { useState, useEffect, useCallback } from 'react';
import { OrderTypeEnum, type OrderType } from '../schema/orders.schema';
import type { DeliveryInfo } from '@/app/schemas/domain/delivery-info.schema';

interface UseOrderTypeProps {
  isEditMode: boolean;
  initialOrderType?: OrderType;
  onOrderTypeChange?: (orderType: OrderType) => void;
}

interface UseOrderTypeReturn {
  orderType: OrderType;
  setOrderType: (type: OrderType) => void;
  cleanOrderDataForType: (
    orderType: OrderType,
    deliveryInfo: DeliveryInfo,
    selectedTableId: string | null,
    selectedAreaId: string | null,
    isTemporaryTable: boolean,
    temporaryTableName: string,
  ) => {
    deliveryInfo: DeliveryInfo;
    tableId?: string;
    isTemporaryTable?: boolean;
    temporaryTableName?: string;
    temporaryTableAreaId?: string;
  };
}

export const useOrderType = ({
  isEditMode,
  initialOrderType = OrderTypeEnum.DINE_IN,
  onOrderTypeChange,
}: UseOrderTypeProps): UseOrderTypeReturn => {
  const [orderType, setOrderTypeState] = useState<OrderType>(initialOrderType);

  // Actualizar el tipo de orden cuando cambie el prop inicial (modo edicin)
  useEffect(() => {
    if (isEditMode && initialOrderType) {
      setOrderTypeState(initialOrderType);
    }
  }, [isEditMode, initialOrderType]);

  const setOrderType = useCallback(
    (type: OrderType) => {
      setOrderTypeState(type);
      onOrderTypeChange?.(type);
    },
    [onOrderTypeChange],
  );

  // Funcin para limpiar datos segn el tipo de orden
  const cleanOrderDataForType = useCallback(
    (
      orderType: OrderType,
      deliveryInfo: DeliveryInfo,
      selectedTableId: string | null,
      selectedAreaId: string | null,
      isTemporaryTable: boolean,
      temporaryTableName: string,
    ) => {
      const cleanedData: {
        deliveryInfo: DeliveryInfo;
        tableId?: string;
        isTemporaryTable?: boolean;
        temporaryTableName?: string;
        temporaryTableAreaId?: string;
      } = {
        deliveryInfo: {},
      };

      switch (orderType) {
        case OrderTypeEnum.DINE_IN:
          // Para comer aqu, limpiar datos de delivery
          cleanedData.deliveryInfo = {};
          if (isTemporaryTable && temporaryTableName && selectedAreaId) {
            cleanedData.isTemporaryTable = true;
            cleanedData.temporaryTableName = temporaryTableName;
            cleanedData.temporaryTableAreaId = selectedAreaId;
          } else if (selectedTableId) {
            cleanedData.tableId = selectedTableId;
          }
          break;

        case OrderTypeEnum.TAKE_AWAY:
          // Para llevar, solo mantener nombre y telfono
          cleanedData.deliveryInfo = {
            recipientName: deliveryInfo.recipientName,
            recipientPhone: deliveryInfo.recipientPhone,
          };
          break;

        case OrderTypeEnum.DELIVERY:
          // Para domicilio, mantener todos los datos
          cleanedData.deliveryInfo = deliveryInfo;
          break;
      }

      return cleanedData;
    },
    [],
  );

  return {
    orderType,
    setOrderType,
    cleanOrderDataForType,
  };
};

================
File: app/src/modules/orders/schema/orders.schema.ts
================
import { z } from 'zod';
import type { Photo } from '@/app/schemas/domain/photo.schema';
import type { Modifier } from '@/app/schemas/domain/modifier.schema';
import type { ModifierGroup } from '@/app/schemas/domain/modifier-group.schema';
import type { ProductVariant } from '@/app/schemas/domain/product-variant.schema';
import type { Product } from '@/app/schemas/domain/product.schema';
import type { SubCategory } from '@/app/schemas/domain/subcategory.schema';
import type { Category } from '@/app/schemas/domain/category.schema';
import {
  orderStatusSchema,
  orderTypeSchema,
} from '@/app/schemas/domain/order.schema';
import type {
  OrderItemModifier,
  OrderItem,
  OrderStatus,
  OrderType,
  Order,
} from '@/app/schemas/domain/order.schema';

// Re-exportar tipos de dominio
export type {
  Photo,
  Modifier,
  ModifierGroup,
  ProductVariant,
  Product,
  SubCategory,
  Category,
  OrderItemModifier,
  OrderItem,
  OrderStatus,
  OrderType,
  Order,
};

// Exportar los valores de los enums para uso en runtime
export const OrderStatusEnum = orderStatusSchema.enum;
export const OrderTypeEnum = orderTypeSchema.enum;

// --- Interfaces especficas del mdulo de rdenes ---

// Tipos extendidos para el men completo con relaciones anidadas
export interface FullMenuModifierGroup extends ModifierGroup {
  productModifiers?: Modifier[];
}

export interface FullMenuProduct extends Product {
  variants?: ProductVariant[];
  modifierGroups?: FullMenuModifierGroup[];
}

export interface FullMenuSubCategory extends SubCategory {
  products?: FullMenuProduct[];
}

export interface FullMenuCategory extends Category {
  subcategories?: FullMenuSubCategory[];
}

// Schema para filtrar rdenes
export const findAllOrdersDtoSchema = z.object({
  userId: z.string().uuid().optional(),
  tableId: z.string().uuid().optional(),
  orderStatus: z
    .union([orderStatusSchema, z.array(orderStatusSchema)])
    .optional(),
  orderType: orderTypeSchema.optional(),
  startDate: z.string().optional(),
  endDate: z.string().optional(),
  page: z.number().int().positive().optional(),
  limit: z.number().int().positive().optional(),
});

export type FindAllOrdersDto = z.infer<typeof findAllOrdersDtoSchema>;

// Schema para orden en lista abierta
export const orderOpenListSchema = z.object({
  id: z.string().uuid(),
  orderNumber: z.string(),
  status: orderStatusSchema,
  type: orderTypeSchema,
  totalAmount: z.number(),
  tableNumber: z.number().nullable(),
  customerName: z.string().nullable(),
  itemCount: z.number(),
  createdAt: z.string(),
  updatedAt: z.string(),
  table: z
    .object({
      id: z.string().uuid(),
      number: z.number(),
      name: z.string(),
      isTemporary: z.boolean(),
      area: z
        .object({
          name: z.string(),
        })
        .optional(),
    })
    .nullable()
    .optional(),
  deliveryInfo: z
    .object({
      recipientName: z.string(),
      recipientPhone: z.string().nullable(),
      address: z
        .object({
          id: z.string().uuid(),
          name: z.string(),
          street: z.string(),
          number: z.string(),
          interiorNumber: z.string().nullable(),
          neighborhood: z.string(),
          latitude: z.number().nullable(),
          longitude: z.number().nullable(),
        })
        .nullable(),
    })
    .nullable()
    .optional(),
  customer: z
    .object({
      id: z.string().uuid(),
      firstName: z.string(),
      lastName: z.string(),
      whatsappPhoneNumber: z.string(),
    })
    .nullable()
    .optional(),
});

export type OrderOpenList = z.infer<typeof orderOpenListSchema>;

// Schema para crear orden
export const createOrderSchema = z.object({
  type: orderTypeSchema,
  orderItems: z.array(z.any()), // Definir ms especficamente si es necesario
  payments: z.array(z.any()).optional(),
  adjustments: z.array(z.any()).optional(),
  tableId: z.string().uuid().optional(),
  customerId: z.string().uuid().optional(),
  deliveryInfo: z.any().optional(), // Definir ms especficamente si es necesario
});

export type CreateOrderDto = z.infer<typeof createOrderSchema>;

// Schema para orden con inclusiones
export const orderWithIncludesSchema = z.object({
  includeItems: z.boolean().optional(),
  includePayments: z.boolean().optional(),
  includeAdjustments: z.boolean().optional(),
  includeUser: z.boolean().optional(),
  includeCustomer: z.boolean().optional(),
  includeTable: z.boolean().optional(),
});

export type OrderWithIncludes = z.infer<typeof orderWithIncludesSchema>;

// Schema para parmetros de audio
export const audioOrderParamsSchema = z.object({
  audioFileUri: z.string(),
  duration: z.number(),
  tableNumber: z.number().optional(),
  areaId: z.string().uuid().optional(),
  customerPhone: z.string().optional(),
  orderType: orderTypeSchema.optional(),
});

export type AudioOrderParams = z.infer<typeof audioOrderParamsSchema>;

// Schema para respuesta de audio
export const audioOrderResponseSchema = z.object({
  success: z.boolean(),
  parsedOrder: z
    .object({
      items: z.array(
        z.object({
          productName: z.string(),
          variantName: z.string().nullable(),
          quantity: z.number(),
          modifiers: z.array(z.string()),
          specialInstructions: z.string().nullable(),
        }),
      ),
      tableNumber: z.number().nullable(),
      customerPhone: z.string().nullable(),
      orderType: orderTypeSchema,
      specialRequests: z.string().nullable(),
      deliveryAddress: z.string().nullable(),
    })
    .optional(),
  error: z.string().optional(),
  transcription: z.string().optional(),
});

export type AudioOrderResponse = z.infer<typeof audioOrderResponseSchema>;

================
File: app/src/modules/orders/services/adjustmentService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import type { Adjustment } from '@/app/schemas/domain/adjustment.schema';
import type { OrderAdjustmentDto } from '../schema/update-order.schema';

export const adjustmentService = {
  /**
   * Crea mltiples ajustes para una orden
   */
  createBulkAdjustments: async (
    adjustments: OrderAdjustmentDto[],
  ): Promise<Adjustment[]> => {
    const response = await apiClient.post<Adjustment[]>(
      API_PATHS.ADJUSTMENTS + '/bulk',
      adjustments,
    );
    return response.data;
  },

  /**
   * Obtiene los ajustes de una orden
   */
  getOrderAdjustments: async (orderId: string): Promise<Adjustment[]> => {
    const response = await apiClient.get<Adjustment[]>(
      API_PATHS.ADJUSTMENTS + '/order/' + orderId,
    );
    return response.data;
  },

  /**
   * Elimina un ajuste (solo admin)
   */
  deleteAdjustment: async (adjustmentId: string): Promise<void> => {
    await apiClient.delete<void>(
      API_PATHS.ADJUSTMENTS_BY_ID.replace(':id', adjustmentId),
    );
  },

  /**
   * Obtiene el total de ajustes de una orden
   */
  getOrderAdjustmentsTotal: async (
    orderId: string,
  ): Promise<{ total: number }> => {
    const response = await apiClient.get<{ total: number }>(
      API_PATHS.ADJUSTMENTS + '/order/' + orderId + '/total',
    );
    return response.data;
  },
};

================
File: app/src/modules/orders/stores/useModalStore.ts
================
import { create } from 'zustand';
import type { OrderAdjustment } from '../schema/adjustments.schema';
import type { CartItem } from './useOrderStore';

export type ModalType =
  | 'timePicker'
  | 'timeAlert'
  | 'exitConfirmation'
  | 'cancelConfirmation'
  | 'modifyInProgressConfirmation'
  | 'deletePrepaymentConfirm'
  | 'productCustomization'
  | 'orderDetail'
  | 'orderHistory'
  | 'payment'
  | 'adjustment'
  | 'prepayment'
  | null;

interface ModalState {
  modalType: ModalType;
  modalProps: any;
  isVisible: boolean;
}

interface ModalActions {
  showModal: (type: ModalType, props?: any) => void;
  hideModal: () => void;
  updateModalProps: (props: any) => void;
}

export interface ModalStore extends ModalState, ModalActions {}

export const useModalStore = create<ModalStore>((set) => ({
  modalType: null,
  modalProps: {},
  isVisible: false,

  showModal: (type: ModalType, props = {}) => {
    set({
      modalType: type,
      modalProps: props,
      isVisible: true,
    });
  },

  hideModal: () => {
    set({
      modalType: null,
      modalProps: {},
      isVisible: false,
    });
  },

  updateModalProps: (props: any) => {
    set((state) => ({
      modalProps: { ...state.modalProps, ...props },
    }));
  },
}));

export const modalHelpers = {
  showTimePicker: (props: {
    scheduledTime: Date | null;
    orderType: string;
    onTimeConfirm: (date: Date) => void;
    hideTimePicker: () => void;
  }) => {
    useModalStore.getState().showModal('timePicker', props);
  },

  showTimeAlert: () => {
    useModalStore.getState().showModal('timeAlert');
  },

  showExitConfirmation: (props: { onClose?: () => void }) => {
    useModalStore.getState().showModal('exitConfirmation', props);
  },

  showCancelConfirmation: (props: {
    orderNumber?: number;
    onCancelOrder?: () => void;
  }) => {
    useModalStore.getState().showModal('cancelConfirmation', props);
  },

  showModifyInProgressConfirmation: (props: {
    modifyingItemName: string;
    pendingModifyAction: (() => void) | null;
    setPendingModifyAction: (action: (() => void) | null) => void;
    setModifyingItemName: (name: string) => void;
  }) => {
    useModalStore.getState().showModal('modifyInProgressConfirmation', props);
  },

  showDeletePrepaymentConfirm: (props: {
    confirmDeletePrepayment: () => Promise<void>;
  }) => {
    useModalStore.getState().showModal('deletePrepaymentConfirm', props);
  },

  showProductCustomization: (props: {
    editingProduct: any;
    editingItemFromList: CartItem | null;
    clearEditingState: () => void;
    handleUpdateEditedItem: (
      itemId: string,
      quantity: number,
      modifiers: any[],
      preparationNotes?: string,
      variantId?: string,
      variantName?: string,
      unitPrice?: number,
      selectedPizzaCustomizations?: any[],
      pizzaExtraCost?: number,
    ) => void;
  }) => {
    useModalStore.getState().showModal('productCustomization', props);
  },

  showOrderDetail: (props: {
    orderId?: string | null;
    orderNumber?: number;
    orderData?: any;
  }) => {
    useModalStore.getState().showModal('orderDetail', props);
  },

  showOrderHistory: (props: {
    orderId?: string | null;
    orderNumber?: number;
  }) => {
    useModalStore.getState().showModal('orderHistory', props);
  },

  showPayment: (props: {
    orderId?: string;
    orderTotal: number;
    orderNumber?: number;
    orderStatus?: string;
    onOrderCompleted?: () => void;
    onClose?: () => void;
  }) => {
    useModalStore.getState().showModal('payment', props);
  },

  showAdjustment: (props: {
    adjustmentToEdit: OrderAdjustment | null;
    setAdjustmentToEdit: (adjustment: OrderAdjustment | null) => void;
    handleAddAdjustment: (adjustment: OrderAdjustment) => void;
    handleUpdateAdjustment: (id: string, adjustment: OrderAdjustment) => void;
    subtotal: number;
  }) => {
    useModalStore.getState().showModal('adjustment', props);
  },

  showPrepayment: (props: {
    orderTotal: number;
    prepaymentId: string | null;
    handlePrepaymentCreated: (
      prepaymentIdCreated: string,
      amount: number,
      method: 'CASH' | 'CARD' | 'TRANSFER',
    ) => void;
    handlePrepaymentDeleted: () => void;
  }) => {
    useModalStore.getState().showModal('prepayment', props);
  },

  hideModal: () => {
    useModalStore.getState().hideModal();
  },
};

================
File: app/src/modules/pizzaCustomizations/components/PizzaCustomizationDetailModal.tsx
================
import React from 'react';
import GenericDetailModal from '@/app/components/crud/GenericDetailModal';
import {
  CustomizationTypeEnum,
  PizzaCustomization,
} from '../schema/pizzaCustomization.schema';

interface PizzaCustomizationDetailModalProps {
  visible: boolean;
  onDismiss: () => void;
  customization: PizzaCustomization | null;
  onEdit?: (customization: PizzaCustomization) => void;
  onDelete?: (customization: PizzaCustomization) => void;
  isDeleting?: boolean;
}

export function PizzaCustomizationDetailModal({
  visible,
  onDismiss,
  customization,
  onEdit,
  onDelete,
  isDeleting = false,
}: PizzaCustomizationDetailModalProps) {
  if (!customization) return null;

  const handleEdit = () => {
    if (onEdit) {
      onEdit(customization);
    }
  };

  const handleDelete = () => {
    if (onDelete) {
      onDelete(customization);
    }
  };

  // Configurar campos dinmicamente segn el tipo
  const fieldsToDisplay: Array<{
    field: keyof PizzaCustomization;
    label: string;
    render?: (value: any, item: PizzaCustomization) => React.ReactNode;
  }> = [
    {
      field: 'type' as keyof PizzaCustomization,
      label: 'Tipo',
      render: (type: string) =>
        type === CustomizationTypeEnum.FLAVOR ? 'Sabor' : 'Ingrediente',
    },
    // Solo mostrar ingredientes si es tipo FLAVOR
    ...(customization.type === CustomizationTypeEnum.FLAVOR
      ? [
          {
            field: 'ingredients' as keyof PizzaCustomization,
            label: 'Ingredientes',
            render: (ingredients: string | null) => ingredients || 'Sin ingredientes',
          },
        ]
      : []),
    {
      field: 'toppingValue' as keyof PizzaCustomization,
      label: 'Valor de topping',
      render: (value: number) => value?.toString() || '0',
    },
    {
      field: 'sortOrder' as keyof PizzaCustomization,
      label: 'Orden de visualizacin',
      render: (value: number) => value?.toString() || '0',
    },
    {
      field: 'products' as keyof PizzaCustomization,
      label: 'Asociado a productos',
      render: (products: Array<{ id: string; name: string }> | undefined) => {
        if (!products || products.length === 0) {
          return 'No asociado a ningn producto';
        }
        const productNames = products.map((p) => p.name).join(', ');
        return `${products.length} producto${products.length > 1 ? 's' : ''}: ${productNames}`;
      },
    },
  ];

  return (
    <GenericDetailModal
      visible={visible}
      onDismiss={onDismiss}
      item={customization}
      titleField="name"
      statusConfig={{
        field: 'isActive',
        activeValue: true,
        activeLabel: 'Activo',
        inactiveLabel: 'Inactivo',
      }}
      fieldsToDisplay={fieldsToDisplay}
      onEdit={onEdit ? handleEdit : undefined}
      onDelete={onDelete ? handleDelete : undefined}
      isDeleting={isDeleting}
    />
  );
}

================
File: app/src/modules/pizzaCustomizations/components/PizzaCustomizationsTab.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, TouchableOpacity } from 'react-native';
import {
  Text,
  Searchbar,
  ActivityIndicator,
  Menu,
  IconButton,
  Badge,
  Chip,
  Surface,
} from 'react-native-paper';
import { FlashList } from '@shopify/flash-list';
import { useAppTheme } from '@/app/styles/theme';
import {
  usePizzaCustomizationsList,
  useDeletePizzaCustomization,
} from '../hooks/usePizzaCustomizationsQueries';
import { PizzaCustomizationDetailModal } from './PizzaCustomizationDetailModal';
import { PizzaCustomizationFormModal } from './PizzaCustomizationFormModal';
import {
  CustomizationType,
  CustomizationTypeEnum,
  PizzaCustomization,
} from '../schema/pizzaCustomization.schema';
import EmptyState from '@/app/components/common/EmptyState';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';

export function PizzaCustomizationsTab() {
  const theme = useAppTheme();

  const [searchQuery, setSearchQuery] = useState('');
  const [selectedType, setSelectedType] = useState<CustomizationType | 'all'>(
    'all',
  );
  const [filterMenuVisible, setFilterMenuVisible] = useState(false);
  const [selectedCustomization, setSelectedCustomization] =
    useState<PizzaCustomization | null>(null);
  const [detailModalVisible, setDetailModalVisible] = useState(false);
  const [deleteConfirmVisible, setDeleteConfirmVisible] = useState(false);
  const [customizationToDelete, setCustomizationToDelete] =
    useState<PizzaCustomization | null>(null);
  const [formModalVisible, setFormModalVisible] = useState(false);
  const [editingCustomizationId, setEditingCustomizationId] = useState<
    string | undefined
  >();

  const deleteMutation = useDeletePizzaCustomization();

  const {
    data,
    isLoading,
    isError: _isError,
    refetch,
  } = usePizzaCustomizationsList({
    search: searchQuery || undefined,
    type: selectedType === 'all' ? undefined : selectedType,
    limit: 100, // Aumentar el lmite para obtener todos los registros
  });

  const filteredData = data?.data || [];
  const hasActiveFilter = selectedType !== 'all';

  const handleItemPress = (item: PizzaCustomization) => {
    setSelectedCustomization(item);
    setDetailModalVisible(true);
  };

  const handleEdit = (customization: PizzaCustomization) => {
    setDetailModalVisible(false);
    setEditingCustomizationId(customization.id);
    setFormModalVisible(true);
  };

  const handleDelete = (customization: PizzaCustomization) => {
    setCustomizationToDelete(customization);
    setDetailModalVisible(false);
    setDeleteConfirmVisible(true);
  };

  const confirmDelete = async () => {
    if (customizationToDelete) {
      await deleteMutation.mutateAsync(customizationToDelete.id);
      setDeleteConfirmVisible(false);
      setCustomizationToDelete(null);
    }
  };

  const renderItem = ({ item }: { item: any }) => (
    <TouchableOpacity onPress={() => handleItemPress(item)}>
      <Surface
        style={[
          styles.cardWrapper,
          !item.isActive && styles.cardWrapperInactive,
        ]}
        elevation={1}
      >
        <View style={styles.cardContent}>
          <View style={styles.cardHeader}>
            <View style={styles.titleRow}>
              <View style={styles.titleContainer}>
                <Text
                  variant="titleMedium"
                  style={[
                    styles.cardTitle,
                    !item.isActive && styles.textInactive,
                  ]}
                  numberOfLines={1}
                >
                  {item.name}
                </Text>
                {!item.isActive && (
                  <Badge style={styles.inactiveBadge} size={16}>
                    Inactivo
                  </Badge>
                )}
              </View>
              <Chip
                mode="flat"
                compact
                icon={
                  item.type === CustomizationTypeEnum.FLAVOR ? 'pizza' : 'cheese'
                }
                style={[
                  styles.typeChip,
                  {
                    backgroundColor:
                      item.type === CustomizationTypeEnum.FLAVOR
                        ? theme.colors.errorContainer
                        : theme.colors.secondaryContainer,
                  },
                  !item.isActive && styles.chipInactive,
                ]}
                textStyle={styles.chipText}
              >
                {item.type === CustomizationTypeEnum.FLAVOR
                  ? 'Sabor'
                  : 'Ingrediente'}
              </Chip>
            </View>
            <View style={styles.statsContainer}>
              <View
                style={[
                  styles.statusIndicator,
                  item.isActive ? styles.statusActive : styles.statusInactive,
                ]}
              />
              <Text
                variant="bodySmall"
                style={[styles.statText, !item.isActive && styles.textInactive]}
              >
                Orden: {item.sortOrder || 0}
              </Text>
              <Text
                variant="bodySmall"
                style={[styles.statText, !item.isActive && styles.textInactive]}
              >
                 Valor: {item.toppingValue || 0}
              </Text>
              <Text
                variant="bodySmall"
                style={[styles.statText, !item.isActive && styles.textInactive]}
              >
                 {item.products?.length || 0} pizzas
              </Text>
            </View>
          </View>

          {item.ingredients && (
            <Text
              variant="bodySmall"
              style={[
                styles.ingredientsText,
                !item.isActive && styles.textInactive,
              ]}
              numberOfLines={1}
            >
              {item.ingredients}
            </Text>
          )}
        </View>
      </Surface>
    </TouchableOpacity>
  );

  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    header: {
      padding: theme.spacing.m,
      backgroundColor: theme.colors.background,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    searchRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
    },
    searchbar: {
      flex: 1,
      backgroundColor: theme.colors.elevation.level2,
    },
    filterButtonContainer: {
      position: 'relative',
    },
    filterIconButton: {
      margin: 0,
      backgroundColor: theme.colors.elevation.level2,
    },
    filterBadge: {
      position: 'absolute',
      top: 4,
      right: 4,
      backgroundColor: theme.colors.primary,
    },
    menuContent: {
      backgroundColor: theme.colors.elevation.level3,
      marginTop: theme.spacing.xs,
    },
    content: {
      flex: 1,
    },
    listContainer: {
      padding: theme.spacing.s,
    },
    cardWrapper: {
      marginHorizontal: theme.spacing.m,
      marginVertical: theme.spacing.xs,
      borderRadius: theme.roundness * 2,
      overflow: 'hidden',
    },
    cardWrapperInactive: {
      opacity: 0.7,
    },
    cardContent: {
      padding: theme.spacing.s,
      paddingHorizontal: theme.spacing.m,
    },
    cardHeader: {
      marginBottom: theme.spacing.xs,
    },
    titleRow: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      gap: theme.spacing.s,
    },
    titleContainer: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
    },
    cardTitle: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: 16,
    },
    textInactive: {
      color: theme.colors.onSurfaceVariant,
    },
    inactiveBadge: {
      backgroundColor: theme.colors.errorContainer,
      color: theme.colors.onErrorContainer,
      fontSize: 10,
      fontWeight: '600',
    },
    typeChip: {
      height: 24,
    },
    chipInactive: {
      opacity: 0.6,
    },
    chipText: {
      fontSize: 11,
      marginHorizontal: theme.spacing.xs,
      marginVertical: 0,
    },
    statsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
      marginTop: theme.spacing.xs,
    },
    statusIndicator: {
      width: 8,
      height: 8,
      borderRadius: 4,
    },
    statusActive: {
      backgroundColor: theme.colors.primary,
    },
    statusInactive: {
      backgroundColor: theme.colors.error,
    },
    statText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    ingredientsText: {
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      fontSize: 12,
      marginTop: theme.spacing.xs,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
    activeMenuTitle: {
      color: theme.colors.primary,
      fontWeight: '600',
    },
  });

  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <View style={styles.searchRow}>
          <Searchbar
            placeholder="Buscar personalizacin..."
            onChangeText={setSearchQuery}
            value={searchQuery}
            style={styles.searchbar}
            elevation={0}
            inputStyle={{ color: theme.colors.onSurface }}
            placeholderTextColor={theme.colors.onSurfaceVariant}
            iconColor={theme.colors.onSurfaceVariant}
          />
          <View style={styles.filterButtonContainer}>
            <Menu
              visible={filterMenuVisible}
              onDismiss={() => setFilterMenuVisible(false)}
              anchor={
                <IconButton
                  icon={
                    selectedType === 'all'
                      ? 'filter-variant'
                      : selectedType === CustomizationTypeEnum.FLAVOR
                        ? 'pizza'
                        : 'cheese'
                  }
                  mode="contained-tonal"
                  size={24}
                  onPress={() => setFilterMenuVisible(true)}
                  style={styles.filterIconButton}
                  iconColor={
                    selectedType !== 'all'
                      ? theme.colors.primary
                      : theme.colors.onSurfaceVariant
                  }
                />
              }
              anchorPosition="bottom"
              contentStyle={styles.menuContent}
            >
              <Menu.Item
                onPress={() => {
                  setSelectedType('all');
                  setFilterMenuVisible(false);
                }}
                title="Todas"
                leadingIcon="filter-variant"
                trailingIcon={selectedType === 'all' ? 'check' : undefined}
                titleStyle={
                  selectedType === 'all' ? styles.activeMenuTitle : undefined
                }
              />
              <Menu.Item
                onPress={() => {
                  setSelectedType(CustomizationTypeEnum.FLAVOR);
                  setFilterMenuVisible(false);
                }}
                title="Sabores"
                leadingIcon="pizza"
                trailingIcon={
                  selectedType === CustomizationTypeEnum.FLAVOR
                    ? 'check'
                    : undefined
                }
                titleStyle={
                  selectedType === CustomizationTypeEnum.FLAVOR
                    ? styles.activeMenuTitle
                    : undefined
                }
              />
              <Menu.Item
                onPress={() => {
                  setSelectedType(CustomizationTypeEnum.INGREDIENT);
                  setFilterMenuVisible(false);
                }}
                title="Ingredientes"
                leadingIcon="cheese"
                trailingIcon={
                  selectedType === CustomizationTypeEnum.INGREDIENT
                    ? 'check'
                    : undefined
                }
                titleStyle={
                  selectedType === CustomizationTypeEnum.INGREDIENT
                    ? styles.activeMenuTitle
                    : undefined
                }
              />
            </Menu>
            {hasActiveFilter && <Badge style={styles.filterBadge} size={8} />}
          </View>
        </View>
      </View>

      <View style={styles.content}>
        <FlashList
          data={filteredData}
          renderItem={renderItem}
          estimatedItemSize={120}
          ListEmptyComponent={
            <EmptyState
              title="No hay personalizaciones"
              message={
                selectedType === CustomizationTypeEnum.FLAVOR
                  ? 'No hay sabores disponibles'
                  : selectedType === CustomizationTypeEnum.INGREDIENT
                    ? 'No hay ingredientes disponibles'
                    : 'No hay personalizaciones disponibles'
              }
              icon="cheese"
            />
          }
          contentContainerStyle={styles.listContainer}
          keyExtractor={(item) => item.id}
          refreshing={isLoading}
          onRefresh={refetch}
        />
      </View>

      <PizzaCustomizationDetailModal
        visible={detailModalVisible}
        onDismiss={() => {
          setDetailModalVisible(false);
          setSelectedCustomization(null);
        }}
        customization={selectedCustomization}
        onEdit={handleEdit}
        onDelete={handleDelete}
        isDeleting={deleteMutation.isPending}
      />

      <ConfirmationModal
        visible={deleteConfirmVisible}
        title="Eliminar personalizacin"
        message={`Ests seguro de que quieres eliminar "${customizationToDelete?.name}"?`}
        confirmText="Eliminar"
        cancelText="Cancelar"
        confirmButtonColor={theme.colors.error}
        onConfirm={confirmDelete}
        onCancel={() => {
          setDeleteConfirmVisible(false);
          setCustomizationToDelete(null);
        }}
        onDismiss={() => {
          setDeleteConfirmVisible(false);
          setCustomizationToDelete(null);
        }}
      />

      <PizzaCustomizationFormModal
        visible={formModalVisible}
        onDismiss={() => {
          setFormModalVisible(false);
          setEditingCustomizationId(undefined);
        }}
        customizationId={editingCustomizationId}
        onSuccess={() => {
          refetch();
        }}
      />
    </View>
  );
}

================
File: app/src/modules/pizzaCustomizations/services/pizzaConfigurationsService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import type { PizzaConfiguration } from '../schema/pizzaConfiguration.schema';
import type {
  PizzaConfigurationFormInputs,
  UpdatePizzaConfigurationInputs,
} from '../schema/pizzaConfiguration.schema';

async function findByProductId(
  productId: string,
): Promise<PizzaConfiguration | null> {
  try {
    const response = await apiClient.get<PizzaConfiguration>(
      API_PATHS.PIZZA_CONFIGURATIONS + '/product/' + productId,
    );
    return response.data;
  } catch (error: any) {
    // Si es un error 404, retornar null en lugar de lanzar error
    if (error.status === 404) {
      return null;
    }
    // Para otros errores, re-lanzar para que el interceptor los maneje
    throw error;
  }
}

async function create(
  data: PizzaConfigurationFormInputs,
): Promise<PizzaConfiguration> {
  const response = await apiClient.post<PizzaConfiguration>(
    API_PATHS.PIZZA_CONFIGURATIONS,
    data,
  );
  return response.data;
}

async function update(
  id: string,
  data: UpdatePizzaConfigurationInputs,
): Promise<PizzaConfiguration> {
  const response = await apiClient.patch<PizzaConfiguration>(
    API_PATHS.PIZZA_CONFIGURATIONS_BY_ID.replace(':id', id),
    data,
  );
  return response.data;
}

async function remove(id: string): Promise<void> {
  await apiClient.delete(
    API_PATHS.PIZZA_CONFIGURATIONS_BY_ID.replace(':id', id),
  );
}

export const pizzaConfigurationsService = {
  findByProductId,
  create,
  update,
  remove,
};

================
File: app/src/modules/preparationScreens/components/PreparationScreenFormModal.tsx
================
import React, { useState, useEffect } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  TextInput,
  Button,
  Switch,
  HelperText,
  Surface,
  List,
  Divider,
} from 'react-native-paper';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { User, RoleEnum } from '@/modules/users/schema/user.schema';
import { useGetUsers } from '@/modules/users/hooks/useUsers';
import {
  PreparationScreen,
  CreatePreparationScreenDto,
  UpdatePreparationScreenDto,
  CreatePreparationScreenSchema,
  UpdatePreparationScreenSchema,
} from '../schema/preparationScreen.schema';
import {
  useCreatePreparationScreen,
  useUpdatePreparationScreen,
  useGetPreparationScreens,
} from '../hooks/usePreparationScreensQueries';

interface PreparationScreenFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  editingItem: PreparationScreen | null;
  onSubmitSuccess?: () => void;
}

type FormData = CreatePreparationScreenDto | UpdatePreparationScreenDto;

const PreparationScreenFormModal: React.FC<PreparationScreenFormModalProps> = ({
  visible,
  onDismiss,
  editingItem,
  onSubmitSuccess,
}) => {
  const theme = useAppTheme();
  const styles = getStyles(theme);
  const isEditing = !!editingItem;
  const [showUserDropdown, setShowUserDropdown] = useState(false);
  const [selectedUser, setSelectedUser] = useState<User | null>(null);

  // Obtener todos los usuarios activos
  const { data: usersData, isLoading: isLoadingUsers } = useGetUsers({
    filters: {
      isActive: true,
    },
  });

  // Obtener todas las pantallas de preparacin para verificar usuarios asignados
  const { data: screensData } = useGetPreparationScreens(
    {},
    { page: 1, limit: 100 }, // Obtener todas las pantallas
  );

  // Crear mapa de usuarios asignados a pantallas
  const userAssignments = React.useMemo(() => {
    if (!screensData?.data) return new Map<string, string>();

    const assignments = new Map<string, string>();
    screensData.data.forEach((screen) => {
      // Excluir la pantalla actual al editar
      if (editingItem && screen.id === editingItem.id) return;

      if (screen.users && screen.users.length > 0) {
        screen.users.forEach((user) => {
          assignments.set(user.id, screen.name);
        });
      }
    });
    return assignments;
  }, [screensData, editingItem]);

  // Todos los usuarios, ordenados con los de cocina primero y disponibles al inicio
  const allUsers = React.useMemo(() => {
    if (!usersData?.data) return [];

    return usersData.data.sort((a, b) => {
      // Primero ordenar por disponibilidad
      const aAssigned = userAssignments.has(a.id);
      const bAssigned = userAssignments.has(b.id);
      if (!aAssigned && bAssigned) return -1;
      if (aAssigned && !bAssigned) return 1;

      // Luego por rol de cocina
      const aIsKitchen = a.role?.id === RoleEnum.KITCHEN;
      const bIsKitchen = b.role?.id === RoleEnum.KITCHEN;
      if (aIsKitchen && !bIsKitchen) return -1;
      if (!aIsKitchen && bIsKitchen) return 1;

      return 0;
    });
  }, [usersData, userAssignments]);

  // Hooks de mutacin
  const createScreen = useCreatePreparationScreen();
  const updateScreen = useUpdatePreparationScreen();

  // Configuracin del formulario
  const formSchema = isEditing
    ? UpdatePreparationScreenSchema
    : CreatePreparationScreenSchema;

  const {
    control,
    handleSubmit,
    formState: { errors },
    reset,
    setValue,
  } = useForm<FormData>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      name: '',
      description: undefined,
      isActive: true,
      userId: '',
    },
  });

  // Efecto para cargar datos al editar
  useEffect(() => {
    if (editingItem) {
      reset({
        name: editingItem.name,
        description: editingItem.description ?? undefined,
        isActive: editingItem.isActive,
        userId:
          editingItem.users && editingItem.users.length > 0
            ? editingItem.users[0].id
            : '', // Siempre string vaco para activar validacin
      });
      setSelectedUser(
        editingItem.users && editingItem.users.length > 0
          ? (editingItem.users[0] as User)
          : null,
      );
    } else {
      reset({
        name: '',
        description: undefined,
        isActive: true,
        userId: '',
      });
      setSelectedUser(null);
    }
  }, [editingItem, reset]);

  // Manejo del envo del formulario
  const onSubmit = async (data: FormData) => {
    try {
      if (isEditing && editingItem) {
        await updateScreen.mutateAsync({
          id: editingItem.id,
          data: data as UpdatePreparationScreenDto,
        });
      } else {
        await createScreen.mutateAsync(data as CreatePreparationScreenDto);
      }
      onSubmitSuccess?.();
      onDismiss();
    } catch (error: any) {
      // No mostrar snackbar aqu porque el hook ya lo hace
      // Solo hacer log para debugging
    }
  };

  // Manejo de seleccin de usuario
  const handleUserSelect = (user: User) => {
    setSelectedUser(user);
    setValue('userId', user.id);
    setShowUserDropdown(false);
  };

  const handleClearUser = () => {
    setSelectedUser(null);
    setValue('userId', '');
  };

  const isSubmitting = createScreen.isPending || updateScreen.isPending;

  // Funciones auxiliares para roles
  const getRoleLabel = (roleId?: number) => {
    switch (roleId) {
      case RoleEnum.ADMIN:
        return 'Administrador';
      case RoleEnum.MANAGER:
        return 'Gerente';
      case RoleEnum.CASHIER:
        return 'Cajero';
      case RoleEnum.WAITER:
        return 'Mesero';
      case RoleEnum.KITCHEN:
        return 'Cocina';
      case RoleEnum.DELIVERY:
        return 'Repartidor';
      default:
        return 'Sin rol';
    }
  };

  const getIconForRole = (roleId?: number) => {
    switch (roleId) {
      case RoleEnum.ADMIN:
        return 'shield-account';
      case RoleEnum.MANAGER:
        return 'account-tie';
      case RoleEnum.CASHIER:
        return 'cash-register';
      case RoleEnum.WAITER:
        return 'room-service';
      case RoleEnum.KITCHEN:
        return 'chef-hat';
      case RoleEnum.DELIVERY:
        return 'moped';
      default:
        return 'account';
    }
  };

  return (
    <>
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onDismiss}
          contentContainerStyle={styles.modalContent}
        >
          <ScrollView>
            <Surface style={styles.surface}>
              <Text variant="headlineSmall" style={styles.title}>
                {isEditing
                  ? 'Editar Pantalla de Preparacin'
                  : 'Crear Nueva Pantalla'}
              </Text>

              <View style={styles.form}>
                {/* Campo Nombre */}
                <Controller
                  control={control}
                  name="name"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.field}>
                      <TextInput
                        label="Nombre de la Pantalla *"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.name}
                        disabled={isSubmitting}
                        placeholder="Ej: Cocina Principal, Barra Fra"
                        mode="outlined"
                      />
                      {errors.name && (
                        <HelperText type="error" visible={!!errors.name}>
                          {errors.name.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />

                {/* Campo Descripcin */}
                <Controller
                  control={control}
                  name="description"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.field}>
                      <TextInput
                        label="Descripcin (Opcional)"
                        value={value || ''}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.description}
                        disabled={isSubmitting}
                        placeholder="Ej: Pantalla para rdenes de cocina caliente"
                        mode="outlined"
                        multiline
                        numberOfLines={3}
                      />
                      {errors.description && (
                        <HelperText type="error" visible={!!errors.description}>
                          {errors.description.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />

                {/* Campo Usuario */}
                <Controller
                  control={control}
                  name="userId"
                  render={() => (
                    <View style={styles.field}>
                      <TextInput
                        label="Usuario de Cocina *"
                        value={
                          selectedUser
                            ? `${selectedUser.firstName || ''} ${selectedUser.lastName || ''}`.trim() ||
                              selectedUser.username
                            : ''
                        }
                        mode="outlined"
                        error={!!errors.userId}
                        disabled={isSubmitting || isLoadingUsers}
                        onPressOut={() => {
                          if (
                            !isSubmitting &&
                            !isLoadingUsers &&
                            allUsers.length > 0
                          ) {
                            setShowUserDropdown(true);
                          }
                        }}
                        showSoftInputOnFocus={false}
                        editable={false}
                        right={
                          selectedUser ? (
                            <TextInput.Icon
                              icon="close"
                              onPress={() => {
                                handleClearUser();
                              }}
                              disabled={isSubmitting}
                            />
                          ) : (
                            <TextInput.Icon
                              icon={isLoadingUsers ? 'loading' : 'chevron-down'}
                              disabled={isSubmitting || isLoadingUsers}
                              onPress={() => {
                                if (!isSubmitting && !isLoadingUsers) {
                                  setShowUserDropdown(true);
                                }
                              }}
                            />
                          )
                        }
                      />
                      {errors.userId && (
                        <HelperText type="error" visible={!!errors.userId}>
                          {errors.userId.message}
                        </HelperText>
                      )}
                      {!errors.userId && (
                        <HelperText type="info" visible={true}>
                          Nota: Un usuario solo puede estar asignado a una
                          pantalla a la vez
                        </HelperText>
                      )}
                    </View>
                  )}
                />

                {/* Campo Activa */}
                <Controller
                  control={control}
                  name="isActive"
                  render={({ field: { onChange, value } }) => (
                    <View style={styles.switchField}>
                      <Text variant="bodyLarge">Est activa?</Text>
                      <Switch
                        value={value}
                        onValueChange={onChange}
                        disabled={isSubmitting}
                        color={theme.colors.primary}
                      />
                    </View>
                  )}
                />
              </View>

              <View style={styles.actions}>
                <Button mode="text" onPress={onDismiss} disabled={isSubmitting}>
                  Cancelar
                </Button>
                <Button
                  mode="contained"
                  onPress={handleSubmit(onSubmit)}
                  loading={isSubmitting}
                  disabled={isSubmitting}
                >
                  {isEditing ? 'Actualizar' : 'Crear'}
                </Button>
              </View>
            </Surface>
          </ScrollView>
        </Modal>
      </Portal>

      {/* Dropdown de usuarios */}
      <Portal>
        <Modal
          visible={showUserDropdown}
          onDismiss={() => setShowUserDropdown(false)}
          contentContainerStyle={[
            styles.dropdownModal,
            styles.dropdownModalMaxHeight,
          ]}
        >
          <Surface style={styles.dropdownContent}>
            <View style={styles.dropdownHeader}>
              <Text variant="titleMedium" style={styles.dropdownTitle}>
                Seleccionar Usuario de Cocina
              </Text>
              <Text variant="bodySmall" style={styles.dropdownSubtitle}>
                Solo los usuarios con rol de cocina pueden ser seleccionados
              </Text>
            </View>
            <Divider />
            <ScrollView>
              {isLoadingUsers ? (
                <View style={styles.loadingContainer}>
                  <Text>Cargando usuarios...</Text>
                </View>
              ) : allUsers.length === 0 ? (
                <View style={styles.emptyContainer}>
                  <Text>No hay usuarios disponibles</Text>
                </View>
              ) : (
                allUsers.map((user) => {
                  const displayName =
                    `${user.firstName || ''} ${user.lastName || ''}`.trim() ||
                    user.username;
                  const isKitchenUser = user.role?.id === RoleEnum.KITCHEN;
                  const roleLabel = getRoleLabel(user.role?.id);
                  const assignedScreen = userAssignments.get(user.id);
                  const isAssigned = !!assignedScreen;
                  const isSelectable = isKitchenUser && !isAssigned;

                  return (
                    <List.Item
                      key={user.id}
                      title={displayName}
                      description={
                        isAssigned
                          ? `Asignado a: ${assignedScreen}`
                          : `${user.username !== displayName ? user.username + '  ' : ''}${roleLabel}`
                      }
                      onPress={
                        isSelectable ? () => handleUserSelect(user) : undefined
                      }
                      left={(props) => (
                        <List.Icon
                          {...props}
                          icon={getIconForRole(user.role?.id)}
                          color={
                            isAssigned ? theme.colors.outline : props.color
                          }
                        />
                      )}
                      style={[
                        styles.dropdownItem,
                        !isSelectable && styles.disabledDropdownItem,
                      ]}
                      disabled={!isSelectable}
                      titleStyle={!isSelectable && styles.disabledText}
                      descriptionStyle={[
                        !isSelectable && styles.disabledText,
                        isAssigned && { color: theme.colors.error },
                      ]}
                    />
                  );
                })
              )}
            </ScrollView>
          </Surface>
        </Modal>
      </Portal>
    </>
  );
};

const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    modalContent: {
      margin: 20,
    },
    surface: {
      borderRadius: theme.roundness * 2,
      overflow: 'hidden',
    },
    title: {
      padding: 24,
      paddingBottom: 16,
      color: theme.colors.onSurface,
    },
    form: {
      paddingHorizontal: 24,
    },
    field: {
      marginBottom: 16,
    },
    switchField: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 16,
      paddingVertical: 8,
    },
    actions: {
      flexDirection: 'row',
      justifyContent: 'flex-end',
      padding: 16,
      paddingTop: 8,
      gap: 8,
      borderTopWidth: 1,
      borderTopColor: theme.colors.surfaceVariant,
    },
    dropdownModal: {
      margin: 20,
      marginTop: '30%',
    },
    dropdownModalMaxHeight: {
      maxHeight: 300,
    },
    dropdownContent: {
      borderRadius: theme.roundness * 2,
      overflow: 'hidden',
    },
    dropdownHeader: {
      padding: 16,
      paddingBottom: 12,
    },
    dropdownTitle: {
      marginBottom: 4,
    },
    dropdownSubtitle: {
      color: theme.colors.onSurfaceVariant,
    },
    dropdownItem: {
      paddingHorizontal: 16,
    },
    disabledDropdownItem: {
      opacity: 0.5,
      backgroundColor: theme.colors.surfaceDisabled,
    },
    disabledText: {
      color: theme.colors.onSurfaceDisabled,
    },
    loadingContainer: {
      padding: 20,
      alignItems: 'center',
    },
    emptyContainer: {
      padding: 20,
      alignItems: 'center',
    },
  });

export default PreparationScreenFormModal;

================
File: app/src/modules/printers/schema/printer.schema.ts
================
import { z } from 'zod';
import { baseListQuerySchema } from '../../../app/types/query.types';

export const PrinterConnectionTypeSchema = z.enum([
  'NETWORK',
  'USB',
  'SERIAL',
  'BLUETOOTH',
]);
export type PrinterConnectionType = z.infer<typeof PrinterConnectionTypeSchema>;

const macRegex = /^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$/i;

const printerBaseSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido').max(100),
  connectionType: PrinterConnectionTypeSchema,
  ipAddress: z
    .string()
    .ip({ version: 'v4', message: 'IP invlida' })
    .optional(),
  port: z.coerce
    .number()
    .int()
    .positive('El puerto debe ser un nmero positivo')
    .optional(),
  path: z.string().optional(),
  isActive: z.boolean().optional().default(true),
  macAddress: z.string().regex(macRegex, 'MAC invlida').optional(),
  isDefaultPrinter: z.boolean().optional().default(false),
  autoDeliveryPrint: z.boolean().optional().default(false),
  autoPickupPrint: z.boolean().optional().default(false),
  paperWidth: z
    .number()
    .min(58, 'El ancho del papel debe ser de al menos 58mm')
    .optional()
    .default(80),
  charactersPerLine: z
    .number()
    .min(32, 'Debe tener al menos 32 caracteres por lnea')
    .optional()
    .default(48),
  cutPaper: z.boolean().optional().default(true),
  feedLines: z
    .number()
    .min(0, 'No puede ser menor a 0 lneas')
    .max(50, 'No puede ser mayor a 50 lneas')
    .optional()
    .default(3),
});

export const thermalPrinterSchema = printerBaseSchema
  .omit({
    ipAddress: true,
    port: true,
    path: true,
    macAddress: true,
  })
  .extend({
    id: z.string().uuid(),
    ipAddress: z.string().ip({ version: 'v4' }).nullable(),
    port: z.number().int().positive().nullable(),
    path: z.string().nullable(),
    macAddress: z
      .string()
      .regex(macRegex, 'MAC invlida')
      .nullable()
      .optional(),
    createdAt: z.string().datetime().optional(),
    updatedAt: z.string().datetime().optional(),
    deletedAt: z.string().datetime().nullable().optional(),
  });

export type ThermalPrinter = z.infer<typeof thermalPrinterSchema>;

const refinePrinterDto = (
  data: Partial<z.infer<typeof printerBaseSchema>>,
  ctx: z.RefinementCtx,
) => {
  if (data.connectionType === undefined) return;

  if (data.connectionType === 'NETWORK') {
    if (!data.ipAddress) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'La direccin IP es requerida para conexin NETWORK',
        path: ['ipAddress'],
      });
    }
    if (!data.port) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'El puerto es requerido para conexin NETWORK',
        path: ['port'],
      });
    }
    if (data.path !== undefined && data.path !== null) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'La ruta debe estar vaca para conexin NETWORK',
        path: ['path'],
      });
    }
  } else {
    if (!data.path) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message:
          'La ruta/identificador es requerido para este tipo de conexin',
        path: ['path'],
      });
    }
    if (data.ipAddress !== undefined && data.ipAddress !== null) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'La IP debe estar vaca para este tipo de conexin',
        path: ['ipAddress'],
      });
    }
    if (data.port !== undefined && data.port !== null) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'El puerto debe estar vaco para este tipo de conexin',
        path: ['port'],
      });
    }
  }
};

export const createThermalPrinterDtoSchema =
  printerBaseSchema.superRefine(refinePrinterDto);

export type CreateThermalPrinterDto = z.infer<
  typeof createThermalPrinterDtoSchema
>;

export const updateThermalPrinterDtoSchema = printerBaseSchema
  .partial()
  .superRefine(refinePrinterDto);

export type UpdateThermalPrinterDto = z.infer<
  typeof updateThermalPrinterDtoSchema
>;

export const findAllThermalPrintersFilterSchema = baseListQuerySchema.extend({
  name: z.string().optional(),
  connectionType: PrinterConnectionTypeSchema.optional(),
  isActive: z.boolean().optional(),
});

export type FindAllThermalPrintersDto = z.infer<
  typeof findAllThermalPrintersFilterSchema
>;

export const printerFormSchema = createThermalPrinterDtoSchema;
export type PrinterFormData = z.input<typeof printerFormSchema>;

export const discoveredPrinterSchema = z.object({
  ip: z.string().ip({ version: 'v4' }),
  port: z.number().int().positive(),
  name: z.string().optional(),
  model: z.string().optional(),
  type: z.string(),
  mac: z.string().regex(macRegex, 'MAC invlida').optional(),
});

export type DiscoveredPrinter = z.infer<typeof discoveredPrinterSchema>;

================
File: app/src/modules/printers/types/printer.types.ts
================
export type {
  PrinterConnectionType,
  ThermalPrinter,
  CreateThermalPrinterDto,
  UpdateThermalPrinterDto,
  FindAllThermalPrintersDto,
  PrinterFormData,
  DiscoveredPrinter,
} from '../schema/printer.schema';

================
File: app/src/modules/settings/navigation/SettingsStackNavigator.tsx
================
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { ServerSettingsScreen } from '../screens/ServerSettingsScreen';
import { getStackHeaderOptions } from '@/app/navigation/options';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import type { SettingsStackParamList } from './types';

const Stack = createNativeStackNavigator<SettingsStackParamList>();

export function SettingsStackNavigator() {
  const theme = useAppTheme();
  const responsive = useResponsive();

  return (
    <Stack.Navigator
      screenOptions={{
        ...getStackHeaderOptions(theme, responsive),
        headerShown: false,
      }}
    >
      <Stack.Screen
        name="ServerSettings"
        component={ServerSettingsScreen}
        options={{
          title: 'Configuracin del Servidor',
        }}
      />
    </Stack.Navigator>
  );
}

================
File: app/src/modules/shiftAudit/hooks/useShiftOrders.ts
================
import { useQuery } from '@tanstack/react-query';
import { shiftsService } from '@/services/shifts';
import type { Order } from '@/app/schemas/domain/order.schema';
import type { Shift, ShiftSummary } from '../types';

export const useShiftOrders = (shiftId: string | undefined) => {
  return useQuery<Order[], Error>({
    queryKey: ['shifts', shiftId, 'orders'],
    queryFn: () => shiftsService.getOrdersByShift(shiftId!),
    enabled: !!shiftId,
    staleTime: 300000, // 5 minutos
  });
};

export const useShiftSummary = (shiftId: string | undefined) => {
  const shiftQuery = useQuery<Shift, Error>({
    queryKey: ['shifts', shiftId],
    queryFn: async () => {
      const data = await shiftsService.getById(shiftId!);
      return {
        ...data,
        status:
          data.status === 'OPEN' ? ('open' as const) : ('closed' as const),
        openedBy: data.openedBy || {
          id: '',
          firstName: '',
          lastName: '',
          email: '',
        },
        closedBy: data.closedBy,
        createdAt: data.openedAt,
        updatedAt: data.closedAt || data.openedAt,
      };
    },
    enabled: !!shiftId,
  });

  const ordersQuery = useQuery<Order[], Error>({
    queryKey: ['shifts', shiftId, 'orders'],
    queryFn: () => shiftsService.getOrdersByShift(shiftId!),
    enabled: !!shiftId && shiftQuery.isSuccess,
  });

  const summary: ShiftSummary | undefined =
    shiftQuery.data && ordersQuery.data
      ? shiftsService.calculateShiftSummary(
          // Convertir de vuelta al tipo del servicio para calculateShiftSummary
          {
            ...shiftQuery.data,
            status: shiftQuery.data.status === 'open' ? 'OPEN' : 'CLOSED',
          } as any,
          ordersQuery.data,
        )
      : undefined;

  return {
    summary,
    isLoading: shiftQuery.isLoading || ordersQuery.isLoading,
    error: shiftQuery.error || ordersQuery.error,
  };
};

================
File: app/src/modules/sync/screens/SyncStatusScreen.tsx
================
import React, { useState } from 'react';
import { ScrollView, RefreshControl, View, StyleSheet } from 'react-native';
import {
  Card,
  List,
  Text,
  ActivityIndicator,
  Divider,
  Icon,
  Chip,
  Surface,
} from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useQuery } from '@tanstack/react-query';
import { formatDistanceToNow } from 'date-fns';
import { es } from 'date-fns/locale';
import { syncService } from '../services/syncService';
import {
  SyncActivityType,
  SyncActivityTypeEnum,
  SYNC_TYPE_LABELS,
  SYNC_DIRECTION_LABELS,
} from '../schema/sync.schema';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';

export function SyncStatusScreen() {
  const theme = useAppTheme();
  const { isTablet } = useResponsive();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const [refreshing, setRefreshing] = useState(false);

  const contentPadding = isTablet ? theme.spacing.l : theme.spacing.m;
  const {
    data: syncStatus,
    isLoading: isLoadingStatus,
    error: statusError,
    refetch: refetchStatus,
  } = useQuery({
    queryKey: ['sync-status'],
    queryFn: () => syncService.getSyncStatus(),
    refetchInterval: 30000,
  });
  const {
    data: syncActivity,
    isLoading: isLoadingActivity,
    error: activityError,
    refetch: refetchActivity,
  } = useQuery({
    queryKey: ['sync-activity'],
    queryFn: () => syncService.getSyncActivity(20),
    refetchInterval: 30000,
  });

  const handleRefresh = async () => {
    setRefreshing(true);
    try {
      await Promise.all([refetchStatus(), refetchActivity()]);
    } catch (error) {
      showSnackbar({
        message: 'Error al actualizar informacin',
        type: 'error',
      });
    } finally {
      setRefreshing(false);
    }
  };

  const formatTimestamp = (timestamp: string) => {
    try {
      return formatDistanceToNow(new Date(timestamp), {
        addSuffix: true,
        locale: es,
      });
    } catch {
      return 'Fecha invlida';
    }
  };

  const getActivityIcon = (type: SyncActivityType) => {
    switch (type) {
      case SyncActivityTypeEnum.PULL_CHANGES:
        return 'cloud-download';
      case SyncActivityTypeEnum.RESTAURANT_DATA:
        return 'store';
      case SyncActivityTypeEnum.ORDER_STATUS:
        return 'check-circle';
      default:
        return 'sync';
    }
  };

  const getStatusColor = (success: boolean) => {
    return success ? theme.colors.success : theme.colors.error;
  };

  const styles = React.useMemo(
    () => createStyles(theme, isTablet),
    [theme, isTablet],
  );

  if (isLoadingStatus || isLoadingActivity) {
    return (
      <SafeAreaView style={styles.container}>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
          <Text style={styles.loadingText}>Cargando informacin...</Text>
        </View>
      </SafeAreaView>
    );
  }

  if (statusError || activityError) {
    return (
      <SafeAreaView style={styles.container}>
        <View style={styles.errorContainer}>
          <Icon source="alert-circle" size={48} color={theme.colors.error} />
          <Text style={styles.errorText}>
            Error al cargar informacin de sincronizacin
          </Text>
        </View>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView style={styles.container}>
      <ScrollView
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={handleRefresh}
            colors={[theme.colors.primary]}
            tintColor={theme.colors.primary}
          />
        }
        contentContainerStyle={[
          styles.scrollContent,
          { padding: contentPadding },
          isTablet && styles.scrollContentTablet,
        ]}
      >
        <Card style={styles.card} mode="elevated">
          <Card.Title
            title="Estado del Servicio"
            titleVariant="headlineSmall"
            left={(props) => <Icon {...props} source="information" />}
          />
          <Card.Content>
            <List.Item
              title="Sincronizacin"
              titleStyle={styles.listItemTitle}
              description={syncStatus?.enabled ? 'Habilitada' : 'Deshabilitada'}
              descriptionStyle={styles.listItemDescription}
              left={(props) => (
                <List.Icon
                  {...props}
                  icon={syncStatus?.enabled ? 'check-circle' : 'close-circle'}
                  color={
                    syncStatus?.enabled
                      ? theme.colors.success
                      : theme.colors.error
                  }
                />
              )}
            />
            <List.Item
              title="WebSocket"
              titleStyle={styles.listItemTitle}
              description={
                syncStatus?.webSocketEnabled
                  ? syncStatus?.webSocketConnected
                    ? 'Conectado'
                    : syncStatus?.webSocketFailed
                      ? 'Conexin fallida'
                      : 'Intentando conectar...'
                  : 'Deshabilitado'
              }
              descriptionStyle={[
                styles.listItemDescription,
                syncStatus?.webSocketFailed && { color: theme.colors.error },
              ]}
              left={(props) => (
                <List.Icon
                  {...props}
                  icon={
                    syncStatus?.webSocketFailed
                      ? 'access-point-off'
                      : 'access-point'
                  }
                  color={
                    syncStatus?.webSocketConnected
                      ? theme.colors.success
                      : syncStatus?.webSocketFailed
                        ? theme.colors.error
                        : syncStatus?.webSocketEnabled
                          ? theme.colors.warning
                          : theme.colors.outline
                  }
                />
              )}
            />
            {syncStatus?.remoteUrl && (
              <List.Item
                title="Servidor Remoto"
                titleStyle={styles.listItemTitle}
                description={syncStatus.remoteUrl}
                descriptionStyle={styles.listItemDescription}
                left={(props) => <List.Icon {...props} icon="server" />}
              />
            )}
            <List.Item
              title="Modo"
              titleStyle={styles.listItemTitle}
              description="Pull (bajo demanda)"
              descriptionStyle={styles.listItemDescription}
              left={(props) => <List.Icon {...props} icon="download" />}
            />
          </Card.Content>
        </Card>

        <Card style={styles.card} mode="elevated">
          <Card.Title
            title="Actividad Reciente"
            titleVariant="headlineSmall"
            subtitle={`ltimas ${syncActivity?.length || 0} sincronizaciones`}
            left={(props) => <Icon {...props} source="history" />}
          />
          <Card.Content>
            {syncActivity && syncActivity.length > 0 ? (
              syncActivity.map((activity, index) => (
                <React.Fragment key={activity.id}>
                  <Surface
                    style={[
                      styles.activityItem,
                      !activity.success && styles.activityItemError,
                    ]}
                    elevation={0}
                  >
                    <View style={styles.activityHeader}>
                      <View style={styles.activityLeft}>
                        <Icon
                          source={getActivityIcon(activity.type)}
                          size={24}
                          color={getStatusColor(activity.success)}
                        />
                        <View style={styles.activityInfo}>
                          <Text
                            variant="bodyMedium"
                            style={styles.activityType}
                          >
                            {SYNC_TYPE_LABELS[activity.type]}
                          </Text>
                          <Text variant="bodySmall" style={styles.activityTime}>
                            {formatTimestamp(activity.timestamp)}
                          </Text>
                        </View>
                      </View>
                      <View style={styles.activityRight}>
                        <Chip
                          compact
                          mode="flat"
                          textStyle={[
                            styles.chipText,
                            {
                              color:
                                activity.direction === 'IN'
                                  ? theme.colors.onInfoContainer
                                  : theme.colors.onSuccessContainer,
                            },
                          ]}
                          style={[
                            styles.directionChip,
                            activity.direction === 'IN'
                              ? styles.chipIn
                              : styles.chipOut,
                          ]}
                        >
                          {SYNC_DIRECTION_LABELS[activity.direction]}
                        </Chip>
                        <Icon
                          source={activity.success ? 'check' : 'close'}
                          size={20}
                          color={getStatusColor(activity.success)}
                        />
                      </View>
                    </View>
                  </Surface>
                  {index < syncActivity.length - 1 && (
                    <Divider style={styles.divider} />
                  )}
                </React.Fragment>
              ))
            ) : (
              <View style={styles.emptyState}>
                <Icon
                  source="cloud-off-outline"
                  size={48}
                  color={theme.colors.outline}
                />
                <Text
                  variant="bodyMedium"
                  style={[styles.emptyText, { color: theme.colors.outline }]}
                >
                  No hay actividad reciente
                </Text>
              </View>
            )}
          </Card.Content>
        </Card>

        <Card style={[styles.card, styles.infoCard]} mode="contained">
          <Card.Content>
            <View style={styles.infoRow}>
              <Icon
                source="information-outline"
                size={20}
                color={theme.colors.onInfoContainer}
              />
              <Text variant="bodySmall" style={styles.infoText}>
                La sincronizacin se ejecuta automticamente cuando hay cambios
                pendientes. No es necesaria ninguna accin manual.
              </Text>
            </View>
          </Card.Content>
        </Card>
      </ScrollView>
    </SafeAreaView>
  );
}

const createStyles = (
  theme: ReturnType<typeof useAppTheme>,
  isTablet: boolean,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    scrollContent: {
      paddingBottom: theme.spacing.xl,
    },
    scrollContentTablet: {
      maxWidth: 800,
      alignSelf: 'center',
      width: '100%',
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
    loadingText: {
      marginTop: theme.spacing.m,
      color: theme.colors.onSurfaceVariant,
    },
    errorContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.xl,
    },
    errorText: {
      marginTop: theme.spacing.m,
      textAlign: 'center',
      color: theme.colors.onSurfaceVariant,
    },
    card: {
      marginBottom: theme.spacing.m,
      elevation: 2,
    },
    listItemTitle: {
      fontSize: isTablet ? 16 : 14,
      color: theme.colors.onSurface,
    },
    listItemDescription: {
      fontSize: isTablet ? 14 : 12,
      color: theme.colors.onSurfaceVariant,
    },
    activityItem: {
      padding: theme.spacing.m,
      borderRadius: theme.roundness,
      marginVertical: theme.spacing.xs,
      backgroundColor: theme.colors.surfaceVariant,
    },
    activityItemError: {
      backgroundColor: theme.colors.errorContainer,
    },
    activityHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    activityLeft: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
    },
    activityInfo: {
      marginLeft: theme.spacing.m,
      flex: 1,
    },
    activityType: {
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    activityTime: {
      opacity: 0.7,
      marginTop: 2,
      color: theme.colors.onSurfaceVariant,
    },
    activityRight: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.s,
    },
    directionChip: {
      height: 24,
    },
    chipText: {
      fontSize: isTablet ? 12 : 11,
      marginVertical: 0,
      marginHorizontal: theme.spacing.s,
    },
    chipIn: {
      backgroundColor: theme.colors.infoContainer,
    },
    chipOut: {
      backgroundColor: theme.colors.successContainer,
    },
    divider: {
      marginVertical: theme.spacing.xs,
    },
    emptyState: {
      alignItems: 'center',
      padding: theme.spacing.xl,
    },
    emptyText: {
      marginTop: theme.spacing.m,
    },
    infoCard: {
      backgroundColor: theme.colors.infoContainer,
    },
    infoRow: {
      flexDirection: 'row',
      alignItems: 'flex-start',
    },
    infoText: {
      marginLeft: theme.spacing.s,
      flex: 1,
      lineHeight: 20,
      color: theme.colors.onInfoContainer,
    },
  });

================
File: app/src/modules/users/schema/user.schema.ts
================
import { z } from 'zod';
import {
  userSchema as domainUserSchema,
  emergencyContactSchema,
  GenderEnum,
  RoleEnum,
  type User,
  type Role,
} from '@/app/schemas/domain/user.schema';

// Re-exportar tipos de dominio
export type { User, Role };
export { GenderEnum, RoleEnum };

// Esquema para crear usuario
export const createUserDtoSchema = z.object({
  email: z.string().email().nullable().optional(),
  username: z.string().min(1, 'El nombre de usuario es requerido'),
  password: z.string().min(6, 'La contrasea debe tener al menos 6 caracteres'),
  firstName: z.string().min(1, 'El nombre es requerido'),
  lastName: z.string().min(1, 'El apellido es requerido'),
  birthDate: z.string().nullable().optional(),
  gender: z.nativeEnum(GenderEnum).nullable().optional(),
  phoneNumber: z.string().nullable().optional(),
  address: z.string().nullable().optional(),
  city: z.string().nullable().optional(),
  state: z.string().nullable().optional(),
  country: z.string().nullable().optional(),
  zipCode: z.string().nullable().optional(),
  emergencyContact: emergencyContactSchema,
  role: z.object({
    id: z.number(),
  }),
});

// Esquema para actualizar usuario (todos los campos opcionales excepto validaciones especficas)
export const updateUserDtoSchema = domainUserSchema
  .omit({ id: true, createdAt: true, updatedAt: true, preparationScreen: true })
  .extend({
    password: z
      .string()
      .min(6, 'La contrasea debe tener al menos 6 caracteres')
      .optional(),
    role: z
      .object({
        id: z.number(),
      })
      .optional(),
  })
  .partial();

// Esquema para consultas de usuarios
export const usersQuerySchema = z.object({
  page: z.number().optional(),
  limit: z.number().optional(),
  filters: z
    .object({
      isActive: z.boolean().optional(),
      roles: z.array(z.object({ id: z.number() })).optional(),
    })
    .optional(),
  search: z.string().optional(),
  sortBy: z.string().optional(),
  sortOrder: z.enum(['ASC', 'DESC']).optional(),
});

// Esquema para respuesta de usuarios
export const usersResponseSchema = z.object({
  data: z.array(domainUserSchema),
  hasNextPage: z.boolean(),
});

// Exportar tipos inferidos
export type CreateUserDto = z.infer<typeof createUserDtoSchema>;
export type UpdateUserDto = z.infer<typeof updateUserDtoSchema>;
export type UsersQuery = z.infer<typeof usersQuerySchema>;
export type UsersResponse = z.infer<typeof usersResponseSchema>;

================
File: app/src/app/components/common/AutoImage.tsx
================
import { useState, useEffect, useMemo } from 'react';
import {
  StyleSheet,
  View,
  ActivityIndicator,
  StyleProp,
  ViewStyle,
  DimensionValue,
} from 'react-native';
import { Platform } from 'react-native';
import { Image, ImageProps as ExpoImageProps } from 'expo-image';
import { Icon } from 'react-native-paper';
import { getCachedImageUri } from '../../lib/imageCache';
import { getImageUrlSync } from '../../lib/imageUtils';
import { serverConnectionService } from '@/services/serverConnectionService';
import { useAppTheme, AppTheme } from '../../styles/theme';

export interface AutoImageProps
  extends Omit<ExpoImageProps, 'source' | 'style'> {
  source: string | null | undefined;
  maxWidth?: number;
  maxHeight?: number;
  useCache?: boolean;
  placeholder?: ExpoImageProps['placeholder'];
  placeholderIcon?: string;
  contentFit?: ExpoImageProps['contentFit'];
  transition?: ExpoImageProps['transition'];
  style?: StyleProp<ViewStyle>;
}

function useAutoImageSize(
  maxWidth?: number,
  maxHeight?: number,
): { width?: number | string; height?: number | string } {
  return {
    width: maxWidth ?? '100%',
    height: maxHeight ?? '100%',
  };
}

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      overflow: 'hidden',
      justifyContent: 'center',
      alignItems: 'center',
      backgroundColor: theme.colors.surfaceVariant,
    },
    loadingIndicator: {
      position: 'absolute',
    },
    image: {
      width: '100%',
      height: '100%',
    },
  });

export const AutoImage = ({
  source: originalSourceProp,
  maxWidth,
  maxHeight,
  useCache = true,
  style,
  placeholder,
  placeholderIcon = 'image-off-outline',
  contentFit = 'cover',
  transition = 300,
  ...restExpoImageProps
}: AutoImageProps) => {
  const theme = useAppTheme();
  const [processedUri, setProcessedUri] = useState<string | null>(null);
  const [isLoadingUri, setIsLoadingUri] = useState(true);

  const { width, height } = useAutoImageSize(maxWidth, maxHeight);

  const fullImageUrl = useMemo(() => {
    if (!originalSourceProp) return null;

    const serverUrl = serverConnectionService.getCurrentUrl();
    if (!serverUrl) return null;

    return getImageUrlSync(originalSourceProp, serverUrl);
  }, [originalSourceProp]);

  useEffect(() => {
    let isMounted = true;
    setIsLoadingUri(true);
    setProcessedUri(null);

    if (!fullImageUrl) {
      if (isMounted) {
        setIsLoadingUri(false);
      }
      return;
    }

    const processSource = async () => {
      // Si NO se usa cach, o es web, o es una URI local, usar la URL construida directamente
      if (
        !useCache ||
        Platform.OS === 'web' ||
        fullImageUrl.startsWith('file://')
      ) {
        if (isMounted) {
          setProcessedUri(fullImageUrl);
          setIsLoadingUri(false);
        }
        return;
      }

      try {
        const cachedUri = await getCachedImageUri(fullImageUrl);
        if (isMounted) {
          setProcessedUri(cachedUri ?? fullImageUrl);
          setIsLoadingUri(false);
        }
      } catch (error) {
        if (isMounted) {
          setProcessedUri(fullImageUrl);
          setIsLoadingUri(false);
        }
      }
    };

    processSource();

    return () => {
      isMounted = false;
    };
  }, [fullImageUrl, useCache]);

  const styles = useMemo(() => createStyles(theme), [theme]);

  const containerStyle: StyleProp<ViewStyle> = useMemo(
    () => [
      styles.container,
      { width: width as DimensionValue, height: height as DimensionValue },
      style,
    ],
    [styles, width, height, style],
  );

  const iconSize = useMemo(() => {
    if (typeof width === 'number' && typeof height === 'number') {
      return Math.min(width, height) * 0.4;
    }
    return 48; // Default size
  }, [width, height]);

  return (
    <View style={containerStyle}>
      {processedUri ? (
        <>
          <Image
            source={{ uri: processedUri }}
            style={styles.image}
            placeholder={placeholder}
            contentFit={contentFit}
            transition={transition}
            cachePolicy="memory-disk"
            {...restExpoImageProps}
          />
          {isLoadingUri && originalSourceProp && (
            <ActivityIndicator
              style={styles.loadingIndicator}
              animating={true}
              color={theme.colors.primary}
              size="small"
            />
          )}
        </>
      ) : (
        !isLoadingUri && (
          <Icon
            source={placeholderIcon}
            size={iconSize}
            color={theme.colors.onSurfaceVariant}
          />
        )
      )}
    </View>
  );
};

export default AutoImage;

================
File: app/src/app/components/common/ConfirmationModal.tsx
================
import { ResponsiveConfirmModal } from '../responsive/ResponsiveModal';

interface ConfirmationModalProps {
  visible: boolean;
  title: string;
  message: string;
  onConfirm: () => void;
  onCancel?: () => void;
  onDismiss?: () => void;
  confirmText?: string;
  cancelText?: string;
  confirmButtonColor?: string;
}

const ConfirmationModal = ({
  visible,
  title,
  message,
  onConfirm,
  onCancel,
  onDismiss,
  confirmText = 'Confirmar',
  cancelText = 'Cancelar',
  confirmButtonColor,
}: ConfirmationModalProps) => {
  // Determinar si es destructivo basado en el color del botn
  const destructive =
    confirmButtonColor &&
    (confirmButtonColor.includes('error') ||
      confirmButtonColor === '#f44336' ||
      confirmButtonColor === '#F44336' ||
      confirmButtonColor === 'error');

  return (
    <ResponsiveConfirmModal
      visible={visible}
      onDismiss={onDismiss || (() => {})}
      title={title}
      message={message}
      onConfirm={onConfirm}
      onCancel={onCancel}
      confirmText={confirmText}
      cancelText={cancelText}
      destructive={!!destructive}
      maxWidth={450}
      widthTablet="70%"
      widthMobile="90%"
    />
  );
};

export default ConfirmationModal;

================
File: app/src/app/components/common/EmptyState.tsx
================
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, Button, Icon } from 'react-native-paper';
import { useAppTheme, AppTheme } from '../../styles/theme';
import { useResponsive } from '../../hooks/useResponsive';

interface EmptyStateProps {
  icon?: string;
  title: string;
  message?: string;
  actionLabel?: string;
  onAction?: () => void;
}

const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.isTablet
        ? responsive.spacingPreset.l
        : theme.spacing.xl,
    },
    iconContainer: {
      marginBottom: responsive.isTablet
        ? responsive.spacingPreset.m
        : theme.spacing.l,
    },
    title: {
      textAlign: 'center',
      marginBottom: theme.spacing.s,
      color: theme.colors.onSurface,
    },
    message: {
      textAlign: 'center',
      marginBottom: responsive.isTablet
        ? responsive.spacingPreset.m
        : theme.spacing.l,
      color: theme.colors.onSurfaceVariant,
      paddingHorizontal: responsive.isTablet
        ? responsive.spacingPreset.l
        : theme.spacing.xl,
      fontSize: responsive.isTablet ? 14 : 16,
      lineHeight: responsive.isTablet ? 20 : 24,
    },
    button: {
      marginTop: responsive.isTablet
        ? responsive.spacingPreset.s
        : theme.spacing.m,
    },
  });

const EmptyState: React.FC<EmptyStateProps> = ({
  icon = 'folder-open',
  title,
  message,
  actionLabel,
  onAction,
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = getStyles(theme, responsive);

  return (
    <View style={styles.container}>
      <View style={styles.iconContainer}>
        <Icon
          source={icon}
          size={responsive.isTablet ? 56 : 64}
          color={theme.colors.onSurfaceVariant}
        />
      </View>
      <Text variant="headlineSmall" style={styles.title}>
        {title}
      </Text>
      {message && (
        <Text variant="bodyLarge" style={styles.message}>
          {message}
        </Text>
      )}
      {actionLabel && onAction && (
        <Button mode="contained" onPress={onAction} style={styles.button}>
          {actionLabel}
        </Button>
      )}
    </View>
  );
};

export default EmptyState;

================
File: app/src/app/components/ConnectionIndicator.tsx
================
import { useMemo, useState, useEffect } from 'react';
import { View, StyleSheet } from 'react-native';
import { IconButton, Surface, Badge } from 'react-native-paper';
import { useAppTheme } from '../styles/theme';
import { useServerConnection } from '../hooks/useServerConnection';
import { useSnackbarStore } from '../store/snackbarStore';
import { healthMonitoringService } from '@/services/healthMonitoringService';
import { autoReconnectService } from '@/services/autoReconnectService';

export function ConnectionIndicator() {
  const theme = useAppTheme();
  const { hasWifi, isConnected, isSearching, isHealthy, error } =
    useServerConnection();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const [isChecking, setIsChecking] = useState(false);
  const [isReconnecting, setIsReconnecting] = useState(false);

  useEffect(() => {
    const unsubscribe = autoReconnectService.subscribe((state) => {
      setIsReconnecting(state.isReconnecting && state.attempts > 0);
    });

    return () => {
      unsubscribe();
    };
  }, []);

  const getConnectionStatus = () => {
    if (!hasWifi) {
      return {
        icon: 'wifi-off',
        color: theme.colors.error,
        backgroundColor: theme.colors.errorContainer,
        message: 'Sin conexin WiFi',
      };
    }

    if (isSearching || isChecking) {
      return {
        icon: 'wifi-sync',
        color: theme.colors.warning || theme.colors.tertiary,
        backgroundColor:
          theme.colors.warningContainer || theme.colors.tertiaryContainer,
        message: isChecking
          ? 'Verificando conexin...'
          : 'Buscando servidor...',
      };
    }

    if (!isConnected) {
      return {
        icon: 'wifi-alert',
        color: theme.colors.error,
        backgroundColor: theme.colors.errorContainer,
        message: error || 'Sin conexin al servidor',
      };
    }

    if (!isHealthy) {
      return {
        icon: 'wifi-strength-2-alert',
        color: theme.colors.warning || theme.colors.tertiary,
        backgroundColor:
          theme.colors.warningContainer || theme.colors.tertiaryContainer,
        message: error || 'Servidor no responde',
      };
    }

    return {
      icon: 'wifi',
      color: theme.colors.onSurfaceVariant,
      backgroundColor: 'transparent',
      message: 'Conectado',
    };
  };

  const status = getConnectionStatus();

  const handlePress = async () => {
    const iconExplanation = getIconExplanation();
    showSnackbar({
      message: iconExplanation,
      type:
        !hasWifi || !isConnected ? 'error' : !isHealthy ? 'warning' : 'info',
      duration: 4000,
    });

    if (isReconnecting) {
      const reconnectState = autoReconnectService.getState();
      setTimeout(() => {
        showSnackbar({
          message: `Reconexin en progreso - Intento #${reconnectState.attempts}`,
          type: 'info',
          duration: 3000,
        });
      }, 500);
    }

    if (isConnected && !isChecking && !isReconnecting) {
      setIsChecking(true);

      setTimeout(async () => {
        try {
          const isHealthyNow = await healthMonitoringService.forceCheck();

          showSnackbar({
            message: isHealthyNow
              ? 'Servidor funcionando correctamente '
              : 'El servidor no responde ',
            type: isHealthyNow ? 'success' : 'error',
            duration: 3000,
          });
        } catch (error) {
          showSnackbar({
            message: 'Error al verificar el servidor',
            type: 'error',
            duration: 3000,
          });
        } finally {
          setIsChecking(false);
        }
      }, 1000);
    }

    if (!isConnected && !isReconnecting && hasWifi) {
      showSnackbar({
        message: 'Iniciando proceso de reconexin...',
        type: 'info',
        duration: 2000,
      });

      setTimeout(() => {
        autoReconnectService.startAutoReconnect();
      }, 500);
    }
  };

  const getIconExplanation = () => {
    const reconnectInfo = isReconnecting
      ? '\n Reconectando automticamente...'
      : '';

    switch (status.icon) {
      case 'wifi-off':
        return (
          ' Sin WiFi - Activa el WiFi y conctate a la red' + reconnectInfo
        );
      case 'wifi-sync':
        return ' Buscando servidor en la red...' + reconnectInfo;
      case 'wifi-alert':
        return ' Sin conexin al servidor' + reconnectInfo;
      case 'wifi-strength-2-alert':
        return ' Servidor no responde' + reconnectInfo;
      case 'wifi':
        return ' Conectado al servidor';
      default:
        return status.message + reconnectInfo;
    }
  };

  const surfaceStyle = useMemo(
    () => ({
      borderRadius: 20,
      backgroundColor: status.backgroundColor,
    }),
    [status.backgroundColor],
  );

  const showBackground =
    !hasWifi || !isConnected || isSearching || !isHealthy || isChecking;

  if (showBackground) {
    return (
      <View style={styles.container}>
        <Surface style={surfaceStyle} elevation={0}>
          <IconButton
            icon={status.icon}
            iconColor={status.color}
            size={24}
            animated={isSearching || isChecking}
            onPress={handlePress}
            style={styles.iconButton}
          />
        </Surface>
        {isReconnecting && !isSearching && (
          <Badge
            size={8}
            style={[
              styles.reconnectingBadge,
              {
                backgroundColor: theme.colors.warning || theme.colors.tertiary,
              },
            ]}
          />
        )}
      </View>
    );
  }

  return (
    <View style={styles.simpleContainer}>
      <IconButton
        icon={status.icon}
        iconColor={theme.colors.onPrimary}
        size={24}
        onPress={handlePress}
      />
      {isReconnecting && (
        <Badge
          size={8}
          style={[
            styles.simpleBadge,
            {
              backgroundColor: theme.colors.warning || theme.colors.tertiary,
            },
          ]}
        />
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    marginRight: 8,
    borderRadius: 20,
    overflow: 'hidden',
  },
  iconButton: {
    margin: 0,
  },
  reconnectingBadge: {
    position: 'absolute',
    top: 4,
    right: 4,
  },
  simpleContainer: {
    marginRight: 8,
    position: 'relative',
  },
  simpleBadge: {
    position: 'absolute',
    top: 8,
    right: 8,
  },
});

================
File: app/src/app/components/crud/GenericList.tsx
================
import React, { useCallback, useMemo, useState } from 'react';
import { useIsFocused } from '@react-navigation/native';
import {
  StyleSheet,
  RefreshControl,
  ViewStyle,
  StyleProp,
  View,
  TextStyle,
} from 'react-native';
import { FlashList } from '@shopify/flash-list';
import {
  List,
  Chip,
  Text,
  Surface,
  Searchbar,
  FAB,
  Portal,
  Menu,
  IconButton,
  Badge,
} from 'react-native-paper';
import AutoImage from '../common/AutoImage';
import { useAppTheme, AppTheme } from '../../styles/theme';
import { useResponsive } from '../../hooks/useResponsive';
export interface FilterOption<TValue> {
  value: TValue;
  label: string;
  icon?: string;
  disabled?: boolean;
}

interface StatusConfig<TItem> {
  field: keyof TItem;
  activeValue: TItem[keyof TItem];
  activeLabel: string;
  inactiveLabel: string;
}

export interface RenderItemConfig<TItem> {
  titleField: keyof TItem;
  descriptionField?: keyof TItem;
  descriptionFormatter?: (value: any) => string | undefined;
  descriptionMaxLength?: number;
  priceField?: keyof TItem;
  sortOrderField?: keyof TItem;
  imageField?: keyof TItem;
  isDefaultField?: keyof TItem;
  statusConfig?: StatusConfig<TItem>;
  renderTitle?: (item: TItem) => React.ReactNode;
  renderDescription?: (item: TItem) => React.ReactNode;
}

interface GenericListProps<TItem extends { id: string }> {
  items: TItem[];
  renderConfig: RenderItemConfig<TItem>;
  onItemPress: (item: TItem) => void;
  onRefresh: () => void;
  isRefreshing: boolean;
  ListEmptyComponent: React.ComponentType<any> | React.ReactElement | null;
  isLoading?: boolean;
  listItemStyle?: StyleProp<ViewStyle>;
  listItemContentStyle?: StyleProp<ViewStyle>;
  contentContainerStyle?: StyleProp<ViewStyle>;
  imageStyle?: StyleProp<ViewStyle>;
  itemActionsContainerStyle?: StyleProp<ViewStyle>;
  renderItemActions?: (item: TItem) => React.ReactNode;
  renderItem?: ({ item }: { item: TItem }) => React.ReactElement;
  enableSearch?: boolean;
  searchPlaceholder?: string;
  searchQuery?: string;
  onSearchChange?: (query: string) => void;
  enableSort?: boolean;
  filterValue?: string | number;
  onFilterChange?: (value: string | number) => void;
  filterOptions?: FilterOption<string | number>[];
  showFab?: boolean;
  onFabPress?: () => void;
  fabIcon?: string;
  fabLabel?: string;
  fabVisible?: boolean;
  showImagePlaceholder?: boolean;
  placeholderIcon?: string;
  isModalOpen?: boolean;
  isDrawerOpen?: boolean;
  enableGrid?: boolean;
  gridColumns?: number;
  gridColumnsTablet?: number;
  minItemWidth?: number;
  itemSpacing?: number;
}

const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
  itemSpacing?: number,
) => {
  const listItemHorizontalMargin = responsive.spacing(theme.spacing.m);
  return StyleSheet.create({
    listContainer: {
      flex: 1,
    },
    searchbarContainer: {
      paddingHorizontal:
        listItemHorizontalMargin - responsive.spacing(theme.spacing.xs),
      paddingTop: responsive.spacing(theme.spacing.xs),
      paddingBottom: responsive.spacing(theme.spacing.s),
      backgroundColor: theme.colors.background,
    },
    searchRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.spacing(theme.spacing.s),
    },
    searchbar: {
      flex: 1,
      backgroundColor: theme.colors.elevation.level2,
    },
    searchbarWithFilter: {
      flex: 1,
    },
    filterButtonContainer: {
      position: 'relative',
    },
    filterIconButton: {
      margin: 0,
      backgroundColor: theme.colors.elevation.level2,
    },
    filterBadge: {
      position: 'absolute',
      top: 4,
      right: 4,
      backgroundColor: theme.colors.primary,
    },
    menuContent: {
      backgroundColor: theme.colors.elevation.level3,
      marginTop: responsive.spacing(theme.spacing.xs),
    },
    listItem: {
      backgroundColor: theme.colors.surface,
      marginVertical: responsive.isTablet
        ? responsive.spacing(3)
        : responsive.spacing(4),
      marginHorizontal: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      borderRadius: theme.roundness * 1.5,
      elevation: 1,
      overflow: 'hidden',
    },
    gridListItem: {
      backgroundColor: theme.colors.surface,
      flex: 1,
      marginHorizontal: responsive.spacing(theme.spacing.xs),
      marginVertical: responsive.spacing(theme.spacing.xs),
      borderRadius: theme.roundness * 2,
      elevation: 2,
      overflow: 'hidden',
    },
    listItemContent: {
      paddingVertical: responsive.isTablet
        ? 4
        : responsive.spacing(theme.spacing.s),
      paddingHorizontal: responsive.spacing(theme.spacing.xs),
      minHeight: responsive.isTablet ? 40 : 56,
      flexWrap: 'wrap',
      alignItems: 'flex-start',
    },
    listItemImage: {
      width: responsive.isTablet ? 36 : 40,
      height: responsive.isTablet ? 36 : 40,
      borderRadius: theme.roundness,
      marginLeft: responsive.spacing(theme.spacing.xs),
      marginRight: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
      backgroundColor: theme.colors.surfaceDisabled,
    },
    gridItemImage: {
      width: responsive.scaleWidth(64),
      height: responsive.scaleWidth(64),
      borderRadius: theme.roundness,
      marginLeft: responsive.spacing(theme.spacing.s),
      marginRight: responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surfaceDisabled,
    },
    statusChip: {
      borderRadius: theme.roundness * 1.5,
      height: responsive.isTablet ? 32 : 28,
      alignSelf: 'center',
      paddingHorizontal: responsive.spacing(theme.spacing.s),
    },
    title: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: responsive.isTablet ? 15 : 14,
      lineHeight: responsive.isTablet ? 20 : 18,
    },
    description: {
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 13 : 12,
      lineHeight: responsive.isTablet ? 18 : 16,
    },
    emptyListContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.spacing(theme.spacing.l),
    },
    defaultContentContainer: {
      paddingBottom: 80,
      paddingTop: responsive.spacing(theme.spacing.xs),
    },
    itemActionsContainer: {
      justifyContent: 'center',
      alignItems: 'center',
      paddingLeft: responsive.spacing(theme.spacing.xs),
    },
    filtersOuterContainer: {
      paddingTop: responsive.spacing(theme.spacing.s),
      paddingBottom: responsive.spacing(theme.spacing.xs),
      paddingHorizontal: responsive.spacing(theme.spacing.xs),
      backgroundColor: theme.colors.background,
    },
    segmentedButtons: {
      backgroundColor: 'transparent',
      borderRadius: theme.roundness,
      minHeight: 40,
    },
    filterButton: {
      borderWidth: 0,
      paddingVertical: responsive.spacing(theme.spacing.xs),
    },
    filterButtonLabel: {
      fontSize: 15,
      letterSpacing: 0.15,
      paddingVertical: responsive.spacing(theme.spacing.xs),
    },
    fab: {
      position: 'absolute',
      margin: 16,
      right: 0,
      bottom: 0,
    },
    chipTextStyle: {
      fontSize: responsive.isTablet ? 12 : 11,
      marginVertical: 0,
    },
    searchInputStyle: {
      color: theme.colors.onSurface,
      fontSize: 14,
      minHeight: 40,
    },
    itemSeparator: {
      height: itemSpacing || responsive.spacing(theme.spacing.m),
    },
    fabTheme: {
      colors: { primaryContainer: theme.colors.primary },
    } as any,
    rightContainer: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    selectedMenuItemTitle: {
      color: theme.colors.primary,
      fontWeight: '600',
    },
  });
};

const GenericList = <TItem extends { id: string }>({
  items,
  renderConfig,
  onItemPress,
  onRefresh,
  isRefreshing,
  ListEmptyComponent,
  listItemStyle,
  listItemContentStyle,
  contentContainerStyle,
  imageStyle,
  renderItemActions,
  itemActionsContainerStyle,
  enableSearch = false,
  searchPlaceholder = 'Buscar...',
  enableSort = false,
  filterValue,
  onFilterChange,
  filterOptions,
  searchQuery: externalSearchQuery,
  onSearchChange,
  showFab = false,
  onFabPress,
  fabIcon = 'plus',
  fabLabel,
  fabVisible = true,
  showImagePlaceholder = true,
  placeholderIcon = 'image-outline',
  isModalOpen = false,
  isDrawerOpen = false,
  renderItem,
  enableGrid = false,
  gridColumns = 1,
  gridColumnsTablet,
  minItemWidth,
  itemSpacing,
}: GenericListProps<TItem>) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = useMemo(
    () => getStyles(theme, responsive, itemSpacing),
    [theme, responsive, itemSpacing],
  );
  const [internalSearchTerm, setInternalSearchTerm] = useState('');
  const [filterMenuVisible, setFilterMenuVisible] = useState(false);
  const isSearchControlled =
    externalSearchQuery !== undefined && onSearchChange !== undefined;
  const currentSearchTerm = isSearchControlled
    ? externalSearchQuery
    : internalSearchTerm;
  const isFocused = useIsFocused();

  const processedItems = useMemo(() => {
    let processed = [...items];

    if (enableSort && renderConfig.titleField) {
      processed.sort((a, b) => {
        const titleA = String(a[renderConfig.titleField] ?? '').toLowerCase();
        const titleB = String(b[renderConfig.titleField] ?? '').toLowerCase();
        return titleA.localeCompare(titleB);
      });
    }

    if (enableSearch && !isSearchControlled && currentSearchTerm.trim()) {
      const lowerCaseSearchTerm = currentSearchTerm.toLowerCase();
      processed = processed.filter((item) => {
        const title = String(item[renderConfig.titleField] ?? '').toLowerCase();
        if (title.includes(lowerCaseSearchTerm)) {
          return true;
        }
        if (renderConfig.descriptionField) {
          const description = String(
            item[renderConfig.descriptionField] ?? '',
          ).toLowerCase();
          if (description.includes(lowerCaseSearchTerm)) {
            return true;
          }
        }
        return false;
      });
    }

    return processed;
  }, [
    items,
    enableSort,
    enableSearch,
    isSearchControlled,
    currentSearchTerm,
    renderConfig,
  ]);

  const numColumns = useMemo(() => {
    if (!enableGrid) return 1;

    if (minItemWidth) {
      const gap = itemSpacing || responsive.spacing(theme.spacing.m);
      const padding = responsive.spacing(theme.spacing.m);
      return responsive.getGridColumns(minItemWidth, gap, padding);
    }

    if (responsive.isTablet && gridColumnsTablet) {
      return gridColumnsTablet;
    }

    return gridColumns;
  }, [
    enableGrid,
    minItemWidth,
    itemSpacing,
    responsive,
    gridColumns,
    gridColumnsTablet,
    theme.spacing.m,
  ]);

  const renderGenericItem = useCallback(
    ({ item }: { item: TItem }) => {
      const title = String(item[renderConfig.titleField] ?? '');

      let description = '';
      if (
        renderConfig.descriptionField &&
        item.hasOwnProperty(renderConfig.descriptionField)
      ) {
        const fieldValue = item[renderConfig.descriptionField];
        if (renderConfig.descriptionFormatter) {
          const formattedDescription =
            renderConfig.descriptionFormatter(fieldValue);
          if (formattedDescription) {
            description = formattedDescription;
          }
        } else {
          const rawDescription = String(fieldValue || '');
          if (rawDescription && rawDescription.toLowerCase() !== 'null') {
            description = rawDescription;
          }
        }
      }

      let sortOrderString: string | null = null;
      if (
        renderConfig.sortOrderField &&
        item.hasOwnProperty(renderConfig.sortOrderField)
      ) {
        const sortOrderValue = item[renderConfig.sortOrderField];
        if (sortOrderValue !== null && sortOrderValue !== undefined) {
          sortOrderString = `Posicion: ${String(sortOrderValue)}`;
        }
      }

      let priceString: string | null = null;
      if (
        renderConfig.priceField &&
        item.hasOwnProperty(renderConfig.priceField)
      ) {
        const priceValue = item[renderConfig.priceField];
        if (priceValue !== null && priceValue !== undefined) {
          const numericPrice = Number(priceValue);
          if (!isNaN(numericPrice)) {
            priceString = `$${numericPrice.toFixed(2)}`;
          } else if (
            typeof priceValue === 'string' &&
            priceValue.trim() !== ''
          ) {
            priceString = String(priceValue);
          }
        }
      }

      let imageSource: string | undefined = undefined;
      if (
        renderConfig.imageField &&
        item.hasOwnProperty(renderConfig.imageField)
      ) {
        const imageFieldValue = item[renderConfig.imageField];
        if (
          typeof imageFieldValue === 'object' &&
          imageFieldValue !== null &&
          'path' in imageFieldValue &&
          typeof imageFieldValue.path === 'string'
        ) {
          imageSource = imageFieldValue.path;
        } else if (typeof imageFieldValue === 'string') {
          imageSource = imageFieldValue;
        }
      }

      let statusChip = null;
      if (
        renderConfig.statusConfig &&
        item.hasOwnProperty(renderConfig.statusConfig.field)
      ) {
        const { field, activeValue, activeLabel, inactiveLabel } =
          renderConfig.statusConfig;
        const isActive = item[field] === activeValue;
        const chipLabel = isActive ? activeLabel : inactiveLabel;

        statusChip = (props: {
          color: string;
          style?: StyleProp<TextStyle>;
        }) => (
          <Chip
            {...props}
            mode="flat"
            selectedColor={
              isActive ? theme.colors.success : theme.colors.onSurfaceVariant
            }
            style={[
              styles.statusChip,
              {
                backgroundColor: isActive
                  ? theme.colors.successContainer
                  : theme.colors.surfaceVariant,
              },
            ]}
            textStyle={styles.chipTextStyle}
            compact
          >
            {chipLabel}
          </Chip>
        );
      }

      const isGrid = enableGrid && numColumns > 1;

      return (
        <Surface
          style={[
            isGrid ? styles.gridListItem : styles.listItem,
            listItemStyle,
          ]}
          elevation={1}
        >
          <List.Item
            title={() =>
              renderConfig.renderTitle ? (
                renderConfig.renderTitle(item)
              ) : (
                <Text variant="bodyLarge" style={styles.title}>
                  {title}
                </Text>
              )
            }
            description={() => {
              if (renderConfig.renderDescription) {
                return renderConfig.renderDescription(item);
              }

              const parts = [];

              if (
                renderConfig.isDefaultField &&
                item.hasOwnProperty(renderConfig.isDefaultField) &&
                item[renderConfig.isDefaultField] === true
              ) {
                parts.push(' Por defecto');
              }

              if (sortOrderString) {
                parts.push(sortOrderString);
              }

              if (description) {
                parts.push(description);
              }

              if (priceString) {
                parts.push(priceString);
              }

              const combinedText = parts.join(' - ');

              if (combinedText.trim()) {
                return (
                  <Text variant="bodySmall" style={styles.description}>
                    {combinedText}
                  </Text>
                );
              }
              return null;
            }}
            left={() => {
              if (imageSource || showImagePlaceholder) {
                return (
                  <AutoImage
                    source={imageSource}
                    placeholderIcon={placeholderIcon}
                    style={[
                      isGrid ? styles.gridItemImage : styles.listItemImage,
                      imageStyle,
                    ]}
                    contentFit="cover"
                    transition={300}
                  />
                );
              } else {
                return null;
              }
            }}
            right={() => (
              <View style={styles.rightContainer}>
                {statusChip && statusChip({ color: theme.colors.onSurface })}
                {renderItemActions && (
                  <View
                    style={[
                      styles.itemActionsContainer,
                      itemActionsContainerStyle,
                    ]}
                  >
                    {renderItemActions(item)}
                  </View>
                )}
              </View>
            )}
            onPress={() => onItemPress(item)}
            style={[styles.listItemContent, listItemContentStyle]}
          />
        </Surface>
      );
    },
    [
      theme,
      renderConfig,
      onItemPress,
      styles,
      listItemStyle,
      listItemContentStyle,
      imageStyle,
      renderItemActions,
      itemActionsContainerStyle,
      enableGrid,
      numColumns,
      showImagePlaceholder,
      placeholderIcon,
    ],
  );

  const finalContentContainerStyle = useMemo(() => {
    return StyleSheet.flatten([
      styles.defaultContentContainer,
      contentContainerStyle,
    ]);
  }, [styles.defaultContentContainer, contentContainerStyle]);

  const hasActiveFilter = filterValue !== 'all' && filterValue !== undefined;

  return (
    <View style={styles.listContainer}>
      {(enableSearch ||
        (filterOptions && filterValue !== undefined && onFilterChange)) && (
        <View style={styles.searchbarContainer}>
          <View style={styles.searchRow}>
            {enableSearch && (
              <Searchbar
                placeholder={searchPlaceholder}
                onChangeText={
                  isSearchControlled ? onSearchChange : setInternalSearchTerm
                }
                value={currentSearchTerm}
                style={[
                  styles.searchbar,
                  filterOptions ? styles.searchbarWithFilter : {},
                ]}
                inputStyle={styles.searchInputStyle}
                placeholderTextColor={theme.colors.onSurfaceVariant}
                iconColor={theme.colors.onSurfaceVariant}
                clearIcon={
                  currentSearchTerm
                    ? () => <List.Icon icon="close-circle" />
                    : undefined
                }
                onClearIconPress={() =>
                  isSearchControlled
                    ? onSearchChange('')
                    : setInternalSearchTerm('')
                }
              />
            )}
            {filterOptions && filterValue !== undefined && onFilterChange && (
              <View style={styles.filterButtonContainer}>
                <Menu
                  visible={filterMenuVisible}
                  onDismiss={() => setFilterMenuVisible(false)}
                  anchor={
                    <IconButton
                      icon={hasActiveFilter ? 'filter-check' : 'filter-variant'}
                      mode="contained-tonal"
                      size={24}
                      onPress={() => setFilterMenuVisible(true)}
                      style={styles.filterIconButton}
                      iconColor={
                        hasActiveFilter
                          ? theme.colors.primary
                          : theme.colors.onSurfaceVariant
                      }
                    />
                  }
                  anchorPosition="bottom"
                  contentStyle={styles.menuContent}
                >
                  {filterOptions.map((option) => (
                    <Menu.Item
                      key={String(option.value)}
                      onPress={() => {
                        onFilterChange(option.value);
                        setFilterMenuVisible(false);
                      }}
                      title={option.label}
                      leadingIcon={option.icon}
                      trailingIcon={
                        filterValue === option.value ? 'check' : undefined
                      }
                      disabled={option.disabled}
                      titleStyle={
                        filterValue === option.value
                          ? styles.selectedMenuItemTitle
                          : undefined
                      }
                    />
                  ))}
                </Menu>
                {hasActiveFilter && (
                  <Badge style={styles.filterBadge} size={8} />
                )}
              </View>
            )}
          </View>
        </View>
      )}

      <FlashList
        data={processedItems}
        renderItem={renderItem || renderGenericItem}
        keyExtractor={(item) => item.id}
        estimatedItemSize={enableGrid && numColumns > 1 ? 150 : 80}
        numColumns={numColumns}
        contentContainerStyle={finalContentContainerStyle}
        ListEmptyComponent={
          processedItems.length === 0 ? ListEmptyComponent || null : null
        }
        ItemSeparatorComponent={
          enableGrid && numColumns > 1
            ? () => <View style={styles.itemSeparator} />
            : undefined
        }
        refreshControl={
          <RefreshControl
            refreshing={isRefreshing}
            onRefresh={() => {
              if (isSearchControlled) {
                onSearchChange('');
              } else {
                setInternalSearchTerm('');
              }
              onRefresh();
            }}
            colors={[theme.colors.primary]}
            tintColor={theme.colors.primary}
          />
        }
        keyboardShouldPersistTaps="handled"
      />
      {showFab && onFabPress && (
        <Portal>
          <FAB
            icon={fabIcon}
            style={styles.fab}
            onPress={onFabPress}
            visible={
              isFocused &&
              showFab &&
              fabVisible &&
              !isModalOpen &&
              !isDrawerOpen
            }
            label={fabLabel}
            color={theme.colors.onPrimary}
            theme={styles.fabTheme}
          />
        </Portal>
      )}
    </View>
  );
};

export default GenericList;

================
File: app/src/app/components/DateTimePickerSafe.tsx
================
import { useState, useEffect } from 'react';
import { View, StyleSheet, Platform } from 'react-native';
import { Modal, Portal, Text, Button, Surface } from 'react-native-paper';
import DateTimePicker from '@react-native-community/datetimepicker';

interface DateTimePickerSafeProps {
  visible: boolean;
  mode: 'date' | 'time' | 'datetime';
  value: Date | null;
  onConfirm: (date: Date) => void;
  onCancel: () => void;
  minimumDate?: Date;
  maximumDate?: Date;
  minuteInterval?: number;
  title?: string;
  allowManualInput?: boolean;
}

export const DateTimePickerSafe = ({
  visible,
  mode,
  value,
  onConfirm,
  onCancel,
  minimumDate,
  maximumDate,
  minuteInterval = 1,
  title,
  allowManualInput = false,
}: DateTimePickerSafeProps) => {
  const [tempDate, setTempDate] = useState<Date>(() => {
    if (value) return new Date(value);
    const now = new Date();
    if (mode === 'time' && minuteInterval && minuteInterval > 1) {
      const minutes = now.getMinutes();
      const roundedMinutes =
        Math.round(minutes / minuteInterval) * minuteInterval;
      const roundedDate = new Date(now);
      roundedDate.setMinutes(roundedMinutes, 0, 0);
      return roundedDate;
    }
    return now;
  });

  useEffect(() => {
    if (visible && value) {
      setTempDate(new Date(value));
    }
  }, [visible, value]);

  const handleChange = (_event: any, selectedDate?: Date) => {
    if (selectedDate) {
      setTempDate(new Date(selectedDate));
    }
  };

  const handleConfirm = () => {
    onConfirm(new Date(tempDate));
  };

  const getTitle = () => {
    if (title) return title;
    switch (mode) {
      case 'date':
        return 'Seleccionar Fecha';
      case 'time':
        return 'Seleccionar Hora';
      case 'datetime':
        return 'Seleccionar Fecha y Hora';
      default:
        return '';
    }
  };

  if (Platform.OS === 'ios') {
    return (
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onCancel}
          contentContainerStyle={styles.modalIOS}
        >
          <Surface style={styles.containerIOS}>
            <View style={styles.header}>
              <Button mode="text" onPress={onCancel}>
                Cancelar
              </Button>
              <Text variant="titleMedium">{getTitle()}</Text>
              <Button mode="text" onPress={handleConfirm}>
                Confirmar
              </Button>
            </View>
            <DateTimePicker
              testID="dateTimePicker"
              value={tempDate}
              mode={mode}
              display="spinner"
              onChange={handleChange}
              minimumDate={minimumDate}
              maximumDate={maximumDate}
              minuteInterval={minuteInterval as any}
              locale="es_ES"
            />
          </Surface>
        </Modal>
      </Portal>
    );
  }

  return (
    <>
      {visible && (
        <DateTimePicker
          testID="dateTimePicker"
          value={tempDate}
          mode={mode}
          onChange={(event, selectedDate) => {
            onCancel();
            if (event.type === 'set' && selectedDate) {
              onConfirm(new Date(selectedDate));
            }
          }}
          minimumDate={minimumDate}
          maximumDate={maximumDate}
          minuteInterval={minuteInterval as any}
          {...(Platform.OS === 'android' && { is24Hour: false })}
          {...(allowManualInput && Platform.OS === 'android' && mode === 'time'
            ? {
                display: 'clock' as any,
              }
            : {})}
        />
      )}
    </>
  );
};

const styles = StyleSheet.create({
  modalIOS: {
    justifyContent: 'flex-end',
    margin: 0,
  },
  containerIOS: {
    backgroundColor: 'white',
    paddingBottom: 20,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 10,
    paddingVertical: 10,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
});

export default DateTimePickerSafe;

================
File: app/src/app/components/OrientationTransition.tsx
================
import { useEffect, useState, useCallback } from 'react';
import { View, ActivityIndicator, StyleSheet, Platform } from 'react-native';
import { Text } from 'react-native-paper';
import * as ScreenOrientation from 'expo-screen-orientation';
import { useAppTheme } from '../styles/theme';

interface OrientationTransitionProps {
  children: React.ReactNode;
  targetOrientation?: ScreenOrientation.OrientationLock;
}

const TRANSITION_DELAYS = {
  UNLOCK: 100,
  LOCK: 300,
} as const;

export const OrientationTransition = ({
  children,
  targetOrientation = ScreenOrientation.OrientationLock.PORTRAIT_UP,
}: OrientationTransitionProps) => {
  const theme = useAppTheme();
  const [isTransitioning, setIsTransitioning] = useState(Platform.OS !== 'web');

  const handleOrientationChange = useCallback(async () => {
    if (Platform.OS === 'web') {
      return;
    }

    setIsTransitioning(true);

    try {
      await ScreenOrientation.unlockAsync();
      await new Promise((resolve) =>
        setTimeout(resolve, TRANSITION_DELAYS.UNLOCK),
      );
      await ScreenOrientation.lockAsync(targetOrientation);
      await new Promise((resolve) =>
        setTimeout(resolve, TRANSITION_DELAYS.LOCK),
      );
    } catch (error) {
      // Error during orientation change
    } finally {
      setIsTransitioning(false);
    }
  }, [targetOrientation]);

  useEffect(() => {
    handleOrientationChange();
  }, [handleOrientationChange]);

  if (isTransitioning && Platform.OS !== 'web') {
    return (
      <View
        style={[styles.container, { backgroundColor: theme.colors.background }]}
      >
        <ActivityIndicator size="large" color={theme.colors.primary} />
        <Text style={[styles.text, { color: theme.colors.onBackground }]}>
          Ajustando pantalla...
        </Text>
      </View>
    );
  }

  return <>{children}</>;
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    marginTop: 16,
    fontSize: 16,
  },
});

================
File: app/src/app/components/responsive/ResponsiveModal.tsx
================
import { ReactNode, useMemo } from 'react';
import { Modal, Portal, Text, IconButton } from 'react-native-paper';
import {
  ScrollView,
  ViewStyle,
  StyleProp,
  View,
  KeyboardAvoidingView,
  Platform,
  StyleSheet,
} from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useAppTheme } from '@/app/styles/theme';

interface ResponsiveModalProps {
  visible: boolean;
  onDismiss: () => void;
  children: ReactNode;

  // Header configuration
  title?: string;
  hideCloseButton?: boolean;
  headerActions?: ReactNode;
  headerStyle?: StyleProp<ViewStyle>;

  // Estilo
  contentContainerStyle?: StyleProp<ViewStyle>;
  style?: StyleProp<ViewStyle>;

  // Dimensiones responsive
  width?: number | string;
  widthMobile?: number | string;
  widthTablet?: number | string;

  maxWidth?: number | string;
  maxWidthMobile?: number | string;
  maxWidthTablet?: number | string;

  height?: number | string;
  heightMobile?: number | string;
  heightTablet?: number | string;

  maxHeight?: number | string;
  maxHeightMobile?: number | string;
  maxHeightTablet?: number | string;

  // Padding responsive
  padding?: number;
  paddingMobile?: number;
  paddingTablet?: number;

  // Comportamiento
  dismissable?: boolean;
  dismissableBackButton?: boolean;
  scrollable?: boolean;
  keyboardAvoiding?: boolean;
  fullScreen?: boolean;
  fullScreenMobile?: boolean;

  // Posicin
  position?: 'center' | 'bottom' | 'top';
  positionMobile?: 'center' | 'bottom' | 'top';
  positionTablet?: 'center' | 'bottom' | 'top';

  // Animacin
  animationType?: 'fade' | 'slide' | 'none';

  // Footer opcional
  footer?: ReactNode;
  footerStyle?: StyleProp<ViewStyle>;
  stickyFooter?: boolean;
}

export const ResponsiveModal: React.FC<ResponsiveModalProps> = ({
  visible,
  onDismiss,
  children,

  // Header
  title,
  hideCloseButton = false,
  headerActions,
  headerStyle,

  // Estilo
  contentContainerStyle,
  style,

  // Dimensiones
  width,
  widthMobile,
  widthTablet,
  maxWidth,
  maxWidthMobile,
  maxWidthTablet,
  height,
  heightMobile,
  heightTablet,
  maxHeight,
  maxHeightMobile,
  maxHeightTablet,

  // Padding
  padding,
  paddingMobile,
  paddingTablet,

  // Comportamiento
  dismissable = true,
  dismissableBackButton = true,
  scrollable = true,
  keyboardAvoiding = true,
  fullScreen = false,
  fullScreenMobile = false,

  // Posicin
  position = 'center',
  positionMobile,
  positionTablet,

  // Footer
  footer,
  footerStyle,
  stickyFooter = true,
}) => {
  const responsive = useResponsive();
  const theme = useAppTheme();
  const insets = useSafeAreaInsets();

  // Determinar si debe ser fullscreen
  const isFullScreen =
    responsive.isMobile && fullScreenMobile ? true : fullScreen;

  // Calcular posicin responsive
  const modalPosition = responsive.isTablet
    ? positionTablet || position
    : positionMobile || position;

  // Calcular dimensiones responsive
  const modalDimensions = useMemo(() => {
    const dims: ViewStyle = {};

    // Width
    if (responsive.isTablet) {
      dims.width = (widthTablet ||
        width ||
        responsive.dimensions.modalWidth) as any;
      dims.maxWidth = (maxWidthTablet || maxWidth || '90%') as any;
    } else {
      dims.width = (widthMobile ||
        width ||
        (isFullScreen ? '100%' : '95%')) as any;
      dims.maxWidth = (maxWidthMobile || maxWidth || '100%') as any;
    }

    // Height
    if (height || heightMobile || heightTablet) {
      dims.height = (
        responsive.isTablet ? heightTablet || height : heightMobile || height
      ) as any;
    }

    if (maxHeight || maxHeightMobile || maxHeightTablet) {
      dims.maxHeight = (
        responsive.isTablet
          ? maxHeightTablet || maxHeight || '95%'
          : maxHeightMobile || maxHeight || '92%'
      ) as any;
    } else {
      // Default max height
      dims.maxHeight = responsive.isTablet ? '95%' : '92%';
    }

    // Si es fullscreen, ajustar dimensiones
    if (isFullScreen) {
      dims.width = '100%';
      dims.height = '100%';
      dims.maxWidth = '100%';
      dims.maxHeight = '100%';
    }

    return dims;
  }, [
    responsive,
    width,
    widthMobile,
    widthTablet,
    maxWidth,
    maxWidthMobile,
    maxWidthTablet,
    height,
    heightMobile,
    heightTablet,
    maxHeight,
    maxHeightMobile,
    maxHeightTablet,
    isFullScreen,
  ]);

  // Calcular padding responsive
  const modalPadding = useMemo(() => {
    if (isFullScreen) return 0;

    if (responsive.isTablet) {
      return paddingTablet || padding || responsive.spacingPreset.l;
    } else {
      return paddingMobile || padding || responsive.spacingPreset.m;
    }
  }, [responsive, padding, paddingMobile, paddingTablet, isFullScreen]);

  // Estilos del modal segn posicin
  const positionStyles = useMemo(() => {
    const styles: ViewStyle = {};

    switch (modalPosition) {
      case 'bottom':
        styles.justifyContent = 'flex-end';
        break;
      case 'top':
        styles.justifyContent = 'flex-start';
        break;
      case 'center':
      default:
        styles.justifyContent = 'center';
        styles.alignItems = 'center';
        break;
    }

    return styles;
  }, [modalPosition]);

  // Estilos del contenedor
  const containerStyles = useMemo(() => {
    const baseStyles: ViewStyle = {
      backgroundColor: theme.colors.surface,
      borderRadius: isFullScreen ? 0 : theme.roundness * 2,
      overflow: 'hidden',
      ...modalDimensions,
    };

    // Ajustes segn posicin
    if (modalPosition === 'bottom' && !isFullScreen) {
      baseStyles.borderBottomLeftRadius = 0;
      baseStyles.borderBottomRightRadius = 0;
      baseStyles.width = '100%';
      baseStyles.maxWidth = '100%';
    }

    if (modalPosition === 'top' && !isFullScreen) {
      baseStyles.borderTopLeftRadius = 0;
      baseStyles.borderTopRightRadius = 0;
      baseStyles.width = '100%';
      baseStyles.maxWidth = '100%';
    }

    // Safe area para fullscreen
    if (isFullScreen) {
      baseStyles.paddingTop = insets.top;
      baseStyles.paddingBottom = insets.bottom;
    }

    return [baseStyles, contentContainerStyle];
  }, [
    theme,
    modalDimensions,
    modalPosition,
    isFullScreen,
    insets,
    contentContainerStyle,
  ]);

  // Estilos del header
  const headerStyles = useMemo(
    () => ({
      flexDirection: 'row' as const,
      alignItems: 'center' as const,
      justifyContent: 'space-between' as const,
      paddingHorizontal: modalPadding,
      paddingVertical: modalPadding * 0.75,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
    }),
    [theme, modalPadding],
  );

  // Header del modal
  const modalHeader = (title || headerActions || !hideCloseButton) && (
    <View style={[headerStyles, headerStyle]}>
      {title && (
        <Text
          variant="titleLarge"
          style={[styles.titleText, { color: theme.colors.onSurface }]}
          numberOfLines={1}
        >
          {title}
        </Text>
      )}
      <View style={styles.headerActions}>
        {headerActions}
        {!hideCloseButton && (
          <IconButton
            icon="close"
            size={24}
            onPress={onDismiss}
            style={{ marginRight: -responsive.spacingPreset.s }}
          />
        )}
      </View>
    </View>
  );

  // Contenido del modal
  const modalContent = (
    <View
      style={[
        styles.contentContainer,
        scrollable && styles.contentContainerScrollable,
        title && styles.contentContainerNoPadding,
        !title && { padding: modalPadding },
      ]}
    >
      {title && modalHeader}
      <View
        style={[
          styles.innerContent,
          scrollable && styles.innerContentScrollable,
          !title && styles.innerContentNoPadding,
          title && { padding: modalPadding },
        ]}
      >
        {scrollable ? (
          <ScrollView
            showsVerticalScrollIndicator={false}
            contentContainerStyle={styles.scrollContent}
            keyboardShouldPersistTaps="handled"
          >
            {children}
          </ScrollView>
        ) : (
          children
        )}
      </View>
    </View>
  );

  // Footer handling
  const modalFooter = footer && (
    <View
      style={[
        styles.footerContainer,
        {
          padding: modalPadding,
          paddingTop: modalPadding / 2,
          backgroundColor: theme.colors.surface,
          borderTopColor: theme.colors.surfaceVariant,
        },
        footerStyle,
      ]}
    >
      {footer}
    </View>
  );

  return (
    <>
      {visible && (
        <Portal>
          <Modal
            visible={visible}
            onDismiss={onDismiss}
            dismissable={dismissable}
            dismissableBackButton={dismissableBackButton}
            contentContainerStyle={[positionStyles, style]}
            style={[
              styles.modalContainer,
              isFullScreen && styles.modalContainerFullScreen,
            ]}
          >
            {keyboardAvoiding && Platform.OS === 'ios' ? (
              <KeyboardAvoidingView
                behavior="padding"
                style={containerStyles}
                keyboardVerticalOffset={isFullScreen ? 0 : 100}
              >
                {modalContent}
                {stickyFooter && modalFooter}
              </KeyboardAvoidingView>
            ) : (
              <View style={containerStyles}>
                {modalContent}
                {stickyFooter && modalFooter}
              </View>
            )}
          </Modal>
        </Portal>
      )}
    </>
  );
};

// Componente helper para modales de confirmacin
interface ResponsiveConfirmModalProps
  extends Omit<ResponsiveModalProps, 'children'> {
  title: string;
  message: string;
  confirmText?: string;
  cancelText?: string;
  onConfirm: () => void;
  onCancel?: () => void;
  destructive?: boolean;
}

export const ResponsiveConfirmModal: React.FC<ResponsiveConfirmModalProps> = ({
  title,
  message,
  confirmText = 'Confirmar',
  cancelText = 'Cancelar',
  onConfirm,
  onCancel,
  destructive = false,
  ...modalProps
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();

  const handleCancel = () => {
    onCancel?.();
    modalProps.onDismiss();
  };

  const handleConfirm = () => {
    onConfirm();
    modalProps.onDismiss();
  };

  return (
    <ResponsiveModal
      {...modalProps}
      scrollable={false}
      maxWidthTablet={400}
      position="center"
    >
      <View style={{ paddingVertical: responsive.spacingPreset.m }}>
        <Text
          style={[
            theme.fonts.headlineSmall,
            {
              color: theme.colors.onSurface,
              marginBottom: responsive.spacingPreset.m,
            },
          ]}
        >
          {title}
        </Text>
        <Text
          style={[
            theme.fonts.bodyMedium,
            { color: theme.colors.onSurfaceVariant },
          ]}
        >
          {message}
        </Text>
      </View>
      <View style={styles.buttonContainer}>
        <Button
          mode="text"
          onPress={handleCancel}
          style={styles.buttonMinWidth}
        >
          {cancelText}
        </Button>
        <Button
          mode="contained"
          onPress={handleConfirm}
          buttonColor={destructive ? theme.colors.error : undefined}
          style={styles.buttonMinWidth}
        >
          {confirmText}
        </Button>
      </View>
    </ResponsiveModal>
  );
};

// Estilos compartidos
const styles = StyleSheet.create({
  titleText: {
    fontWeight: '600',
    flex: 1,
  },
  headerActions: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8, // responsive.spacingPreset.s equivale a 8
  },
  contentContainer: {
    // Estilos base para el contenedor de contenido
  },
  contentContainerScrollable: {
    flex: 1,
  },
  contentContainerNoPadding: {
    padding: 0,
  },
  innerContent: {
    // Estilos base para el contenido interno
  },
  innerContentScrollable: {
    flex: 1,
  },
  innerContentNoPadding: {
    padding: 0,
  },
  scrollContent: {
    flexGrow: 1,
  },
  footerContainer: {
    borderTopWidth: 1,
  },
  modalContainer: {
    // Estilos base para el modal
  },
  modalContainerFullScreen: {
    margin: 0,
  },
  buttonContainer: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    gap: 8, // responsive.spacingPreset.s
    marginTop: 24, // responsive.spacingPreset.l
  },
  buttonMinWidth: {
    minWidth: 80,
  },
});

// Imports necesarios para los componentes de React Native Paper
import { Button } from 'react-native-paper';

================
File: app/src/app/components/ShiftIndicator.tsx
================
import { useState } from 'react';
import { TouchableOpacity, StyleSheet, Text } from 'react-native';
import { Icon, Badge } from 'react-native-paper';
import { useAppTheme } from '../styles/theme';
import { useAuthStore } from '../store/authStore';
import { canOpenShift } from '../utils/roleUtils';
import { ShiftActionModal } from '@/modules/orders/components/ShiftActionModal';
import { ShiftStatusModal } from '@/modules/orders/components/ShiftStatusModal';
import type { Shift } from '@/services/shifts';
import { useGlobalShift } from '../hooks/useGlobalShift';
import { useQueryClient } from '@tanstack/react-query';

export const ShiftIndicator = () => {
  const theme = useAppTheme();
  const user = useAuthStore((state) => state.user);
  const queryClient = useQueryClient();

  const { data: shift, isLoading: loading } = useGlobalShift();

  const [statusModalVisible, setStatusModalVisible] = useState(false);
  const [shiftModalVisible, setShiftModalVisible] = useState(false);
  const [shiftModalMode, setShiftModalMode] = useState<'open' | 'close'>(
    'open',
  );

  const userCanOpenShift = canOpenShift(user);
  const isShiftOpen = shift && (shift as Shift).status === 'OPEN';

  const handlePress = () => {
    // No refrescamos aqu porque ya se actualiza automticamente
    setStatusModalVisible(true);
  };

  const handleOpenShift = () => {
    setStatusModalVisible(false);
    setShiftModalMode('open');
    setShiftModalVisible(true);
  };

  const handleCloseShift = () => {
    setStatusModalVisible(false);
    setShiftModalMode('close');
    setShiftModalVisible(true);
  };

  const getIconColor = () => {
    if (loading) return theme.colors.onPrimary;
    return '#FFFFFF';
  };

  const getIconName = () => {
    if (loading) return 'clock-outline';
    if (isShiftOpen) return 'store-check';
    return 'store-alert';
  };

  return (
    <>
      <TouchableOpacity
        style={[
          styles.container,
          loading && styles.loadingContainer,
          isShiftOpen && !loading && styles.openContainer,
          !isShiftOpen && !loading && styles.closedContainer,
        ]}
        onPress={handlePress}
        disabled={loading}
        hitSlop={styles.hitSlop}
      >
        <Icon source={getIconName()} size={22} color={getIconColor()} />
        <Text style={[styles.statusText, { color: getIconColor() }]}>
          {loading ? 'Cargando' : isShiftOpen ? 'ABIERTO' : 'CERRADO'}
        </Text>
        {!isShiftOpen && !loading && (
          <Badge style={[styles.badge, styles.alertBadge]} size={8} />
        )}
      </TouchableOpacity>

      <ShiftStatusModal
        visible={statusModalVisible}
        onDismiss={() => setStatusModalVisible(false)}
        shift={shift ?? null}
        onOpenShift={handleOpenShift}
        onCloseShift={handleCloseShift}
        canOpenShift={userCanOpenShift}
        loading={loading}
      />

      <ShiftActionModal
        visible={shiftModalVisible}
        onDismiss={() => setShiftModalVisible(false)}
        mode={shiftModalMode}
        shift={shift}
        onShiftOpened={() => {
          queryClient.invalidateQueries({
            queryKey: ['global', 'shift', 'current'],
          });
          setShiftModalVisible(false);
        }}
        onShiftClosed={() => {
          queryClient.invalidateQueries({
            queryKey: ['global', 'shift', 'current'],
          });
          setShiftModalVisible(false);
        }}
      />
    </>
  );
};

const styles = StyleSheet.create({
  container: {
    position: 'relative',
    flexDirection: 'row',
    paddingHorizontal: 14,
    paddingVertical: 8,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 8,
    borderRadius: 24,
    gap: 6,
    elevation: 4,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    borderWidth: 2,
  },
  loadingContainer: {
    backgroundColor: 'rgba(255, 255, 255, 0.2)',
    borderColor: 'rgba(255, 255, 255, 0.3)',
  },
  openContainer: {
    backgroundColor: '#2E7D32', // Verde oscuro slido
    borderColor: '#4CAF50', // Verde ms claro para el borde
  },
  closedContainer: {
    backgroundColor: '#F57C00', // Naranja oscuro slido
    borderColor: '#FF9800', // Naranja ms claro para el borde
  },
  statusText: {
    fontSize: 14,
    fontWeight: '700',
    letterSpacing: 0.5,
  },
  badge: {
    position: 'absolute',
    top: -4,
    right: -4,
  },
  alertBadge: {
    backgroundColor: '#FF1744',
  },
  hitSlop: {
    top: 10,
    bottom: 10,
    left: 10,
    right: 10,
  },
});

================
File: app/src/app/constants/navigationPaths.ts
================
export const NAVIGATION_PATHS = {
  LOGIN: 'Login',

  MAIN_DRAWER: 'MainDrawer',

  ORDERS_STACK: 'OrdersStack',
  ORDERS: 'Orders',
  CREATE_ORDER: 'CreateOrder',
  OPEN_ORDERS: 'OpenOrders',
  ADD_PRODUCTS_TO_ORDER: 'AddProductsToOrder',

  MENU_STACK: 'MenuStack',
  CATEGORIES: 'CategoriesScreen',
  SUBCATEGORIES: 'SubcategoriesScreen',
  PRODUCTS: 'Products',

  AREAS_TABLES_STACK: 'AreasTablesStack',
  AREAS_LIST: 'AreasList',
  TABLES_LIST: 'TablesList',

  MODIFIERS_STACK: 'ModifiersStack',
  MODIFIER_GROUPS: 'ModifierGroupsScreen',
  MODIFIERS: 'ModifiersScreen',

  KITCHEN_SCREEN: 'KitchenScreen',

  RECEIPTS_STACK: 'ReceiptsStack',
  RECEIPTS_LIST: 'ReceiptsList',

  ORDER_FINALIZATION_STACK: 'OrderFinalizationStack',
  ORDER_FINALIZATION: 'OrderFinalizationScreen',

  AVAILABILITY_SCREEN: 'AvailabilityScreen',

  RESTAURANT_CONFIG_STACK: 'RestaurantConfigStack',
  RESTAURANT_CONFIG: 'RestaurantConfig',

  CUSTOMERS_STACK: 'CustomersStack',
  CUSTOMERS: 'Customers',

  PIZZA_CUSTOMIZATIONS_STACK: 'PizzaCustomizationsStack',
  PIZZA_CUSTOMIZATIONS_LIST: 'PizzaCustomizationsList',

  SYNC_STACK: 'SyncStack',
  SYNC_STATUS: 'SyncStatus',

  USERS_SCREEN: 'UsersScreen',

  SHIFT_AUDIT_STACK: 'ShiftAuditStack',
  SHIFTS_LIST: 'ShiftsList',

  PRINTERS_STACK: 'PrintersStack',
  PRINTERS_LIST: 'PrintersList',

  PREPARATION_SCREENS_STACK: 'PreparationScreensStack',
  PREPARATION_SCREENS_LIST: 'PreparationScreensList',
} as const;

export type RootStackParamList = {
  [NAVIGATION_PATHS.LOGIN]: undefined;
  [NAVIGATION_PATHS.MAIN_DRAWER]: undefined;
};

export type OrdersStackParamList = {
  [NAVIGATION_PATHS.ORDERS]: undefined;
  [NAVIGATION_PATHS.CREATE_ORDER]: undefined;
  [NAVIGATION_PATHS.OPEN_ORDERS]: undefined;
  [NAVIGATION_PATHS.ADD_PRODUCTS_TO_ORDER]: {
    orderId: number;
    orderNumber: string;
    existingOrderItemsCount: number;
    existingTempProducts?: any[];
    onProductsAdded?: () => void;
  };
};

export type MenuStackParamList = {
  [NAVIGATION_PATHS.CATEGORIES]: undefined;
  [NAVIGATION_PATHS.SUBCATEGORIES]: {
    categoryId: number;
    categoryName: string;
  };
  [NAVIGATION_PATHS.PRODUCTS]: {
    subcategoryId: number;
    subCategoryName: string;
  };
};

export type AreasTablesStackParamList = {
  [NAVIGATION_PATHS.AREAS_LIST]: undefined;
  [NAVIGATION_PATHS.TABLES_LIST]: {
    areaId: number;
    areaName: string;
  };
};

export type ModifiersStackParamList = {
  [NAVIGATION_PATHS.MODIFIER_GROUPS]: undefined;
  [NAVIGATION_PATHS.MODIFIERS]: {
    groupId: number;
    groupName: string;
  };
};

// KitchenScreen ahora es una pantalla directa, no requiere ParamList

================
File: app/src/app/hooks/useResponsive.ts
================
import { useState, useEffect, useCallback, useMemo } from 'react';
import { Dimensions, PixelRatio, ScaledSize, Platform } from 'react-native';
import {
  BREAKPOINTS,
  DEVICE_TYPES,
  getDeviceType,
  isTablet as checkIsTablet,
  scaleWidth,
  scaleHeight,
  scaleWithLimits,
  getResponsiveDimension,
  RESPONSIVE_SPACING,
  RESPONSIVE_FONT_SIZES,
  RESPONSIVE_DIMENSIONS,
  applyResponsiveStyle,
  getGridColumns,
  getOrientation as getOrientationUtil,
  maintainAspectRatio,
  normalizeDPI,
} from '@/app/styles/responsive';

export interface ResponsiveInfo {
  // Dimensiones de pantalla
  width: number;
  height: number;

  // Informacin del dispositivo
  deviceType: string;
  isTablet: boolean;
  isMobile: boolean;
  isSmallMobile: boolean;
  isWeb: boolean;
  isDesktop: boolean;

  // Orientacin
  orientation: 'portrait' | 'landscape';
  isPortrait: boolean;
  isLandscape: boolean;

  // Densidad de pxeles
  pixelRatio: number;
  fontScale: number;

  // Funciones de escalado
  scaleWidth: (size: number) => number;
  scaleHeight: (size: number) => number;
  scaleWithLimits: (
    size: number,
    minScale?: number,
    maxScale?: number,
  ) => number;
  getResponsiveDimension: (mobile: number, tablet: number) => number;

  // Spacing responsive
  spacing: (value: number) => number;
  spacingPreset: {
    xxxs: number;
    xxs: number;
    xs: number;
    s: number;
    m: number;
    l: number;
    xl: number;
    xxl: number;
  };

  // Tamaos de fuente responsive
  fontSize: (value: number) => number;
  fontSizePreset: {
    xs: number;
    s: number;
    m: number;
    l: number;
    xl: number;
    xxl: number;
    xxxl: number;
  };

  // Dimensiones comunes
  dimensions: {
    drawerWidth: number;
    modalWidth: number;
    headerHeight: number;
    buttonHeight: number;
    iconSize: {
      small: number;
      medium: number;
      large: number;
    };
    productImageSize: number;
    cardMinWidth: number;
  };

  // Utilidades
  applyResponsiveStyle: <T>(styles: {
    xs?: T;
    sm?: T;
    md?: T;
    lg?: T;
    xl?: T;
    xxl?: T;
  }) => T | undefined;
  getGridColumns: (
    minItemWidth?: number,
    gap?: number,
    padding?: number,
  ) => number;
  maintainAspectRatio: (
    originalWidth: number,
    originalHeight: number,
    maxWidth: number,
    maxHeight: number,
  ) => { width: number; height: number };
  normalizeDPI: (size: number) => number;

  // Breakpoints
  breakpoints: typeof BREAKPOINTS;

  // Helpers de comparacin
  isBreakpoint: {
    xs: boolean;
    sm: boolean;
    md: boolean;
    lg: boolean;
    xl: boolean;
    xxl: boolean;
  };
}

export const useResponsive = (): ResponsiveInfo => {
  // Estado para las dimensiones
  const [dimensions, setDimensions] = useState<ScaledSize>(() =>
    Dimensions.get('window'),
  );

  // Actualizar dimensiones cuando cambian
  useEffect(() => {
    const subscription = Dimensions.addEventListener('change', ({ window }) => {
      setDimensions(window);
    });

    return () => subscription?.remove();
  }, []);

  // Obtener informacin de pxeles
  const pixelRatio = PixelRatio.get();
  const fontScale = PixelRatio.getFontScale();

  // Calcular valores derivados
  const deviceType = useMemo(
    () => getDeviceType(dimensions.width),
    [dimensions.width],
  );
  const isWeb = Platform.OS === 'web';
  const isDesktop = useMemo(
    () => isWeb && dimensions.width >= BREAKPOINTS.lg,
    [isWeb, dimensions.width],
  );
  const isTablet = useMemo(
    () =>
      checkIsTablet(dimensions.width) ||
      (isWeb &&
        dimensions.width >= BREAKPOINTS.md &&
        dimensions.width < BREAKPOINTS.lg),
    [dimensions.width, isWeb],
  );
  const isMobile = useMemo(
    () => !isTablet && !isDesktop,
    [isTablet, isDesktop],
  );
  const isSmallMobile = useMemo(
    () => deviceType === DEVICE_TYPES.MOBILE_SMALL,
    [deviceType],
  );

  const orientation = useMemo(
    () => getOrientationUtil(dimensions.width, dimensions.height),
    [dimensions.width, dimensions.height],
  );
  const isPortrait = orientation === 'portrait';
  const isLandscape = orientation === 'landscape';

  // Funciones de escalado memoizadas
  const scaleWidthMemo = useCallback(
    (size: number) => scaleWidth(size, dimensions.width),
    [dimensions.width],
  );

  const scaleHeightMemo = useCallback(
    (size: number) => scaleHeight(size, dimensions.height),
    [dimensions.height],
  );

  const scaleWithLimitsMemo = useCallback(
    (size: number, minScale?: number, maxScale?: number) =>
      scaleWithLimits(size, minScale, maxScale, dimensions.width),
    [dimensions.width],
  );

  const getResponsiveDimensionMemo = useCallback(
    (mobile: number, tablet: number) =>
      getResponsiveDimension(mobile, tablet, dimensions.width),
    [dimensions.width],
  );

  // Spacing responsive
  const spacingPreset = useMemo(
    () => ({
      xxxs: RESPONSIVE_SPACING.xxxs(dimensions.width),
      xxs: RESPONSIVE_SPACING.xxs(dimensions.width),
      xs: RESPONSIVE_SPACING.xs(dimensions.width),
      s: RESPONSIVE_SPACING.s(dimensions.width),
      m: RESPONSIVE_SPACING.m(dimensions.width),
      l: RESPONSIVE_SPACING.l(dimensions.width),
      xl: RESPONSIVE_SPACING.xl(dimensions.width),
      xxl: RESPONSIVE_SPACING.xxl(dimensions.width),
    }),
    [dimensions.width],
  );

  // Funcin de spacing que escala valores arbitrarios
  const spacing = useCallback(
    (value: number) => {
      // Para web desktop, aumentar el spacing
      if (isDesktop) {
        return Math.round(value * 1.3); // 30% ms
      }
      // Para tablets, reducir el spacing en un 25-35%
      if (isTablet) {
        return Math.round(value * 0.7); // 30% menos
      }
      return value;
    },
    [isTablet, isDesktop],
  );

  // Tamaos de fuente responsive
  const fontSizePreset = useMemo(
    () => ({
      xs: RESPONSIVE_FONT_SIZES.xs(dimensions.width),
      s: RESPONSIVE_FONT_SIZES.s(dimensions.width),
      m: RESPONSIVE_FONT_SIZES.m(dimensions.width),
      l: RESPONSIVE_FONT_SIZES.l(dimensions.width),
      xl: RESPONSIVE_FONT_SIZES.xl(dimensions.width),
      xxl: RESPONSIVE_FONT_SIZES.xxl(dimensions.width),
      xxxl: RESPONSIVE_FONT_SIZES.xxxl(dimensions.width),
    }),
    [dimensions.width],
  );

  // Funcin de fontSize que escala valores arbitrarios
  const fontSize = useCallback(
    (value: number) => {
      // Para web desktop, aumentar las fuentes significativamente
      if (isDesktop) {
        return Math.round(value * 1.4); // 40% ms grande
      }
      // Para web tablet, aumentar un poco
      if (isWeb && isTablet) {
        return Math.round(value * 1.2); // 20% ms grande
      }
      // Para tablets nativos, reducir las fuentes en un 10-15%
      if (isTablet) {
        return Math.round(value * 0.87); // 13% menos
      }
      return value;
    },
    [isTablet, isDesktop, isWeb],
  );

  // Dimensiones comunes
  const commonDimensions = useMemo(
    () => ({
      drawerWidth: RESPONSIVE_DIMENSIONS.drawerWidth(dimensions.width),
      modalWidth: RESPONSIVE_DIMENSIONS.modalWidth(dimensions.width),
      headerHeight: RESPONSIVE_DIMENSIONS.headerHeight(dimensions.width),
      buttonHeight: RESPONSIVE_DIMENSIONS.buttonHeight(dimensions.width),
      iconSize: {
        small: RESPONSIVE_DIMENSIONS.iconSize.small(dimensions.width),
        medium: RESPONSIVE_DIMENSIONS.iconSize.medium(dimensions.width),
        large: RESPONSIVE_DIMENSIONS.iconSize.large(dimensions.width),
      },
      productImageSize: RESPONSIVE_DIMENSIONS.productImageSize(
        dimensions.width,
      ),
      cardMinWidth: RESPONSIVE_DIMENSIONS.cardMinWidth(dimensions.width),
    }),
    [dimensions.width],
  );

  // Aplicar estilos responsive
  const applyResponsiveStyleMemo = useCallback(
    <T>(styles: { xs?: T; sm?: T; md?: T; lg?: T; xl?: T; xxl?: T }) =>
      applyResponsiveStyle(dimensions.width, styles),
    [dimensions.width],
  );

  // Obtener columnas de grid
  const getGridColumnsMemo = useCallback(
    (minItemWidth?: number, gap?: number, padding?: number) =>
      getGridColumns(dimensions.width, minItemWidth, gap, padding),
    [dimensions.width],
  );

  // Helpers de breakpoint
  const isBreakpoint = useMemo(
    () => ({
      xs:
        dimensions.width >= BREAKPOINTS.xs && dimensions.width < BREAKPOINTS.sm,
      sm:
        dimensions.width >= BREAKPOINTS.sm && dimensions.width < BREAKPOINTS.md,
      md:
        dimensions.width >= BREAKPOINTS.md && dimensions.width < BREAKPOINTS.lg,
      lg:
        dimensions.width >= BREAKPOINTS.lg && dimensions.width < BREAKPOINTS.xl,
      xl:
        dimensions.width >= BREAKPOINTS.xl &&
        dimensions.width < BREAKPOINTS.xxl,
      xxl: dimensions.width >= BREAKPOINTS.xxl,
    }),
    [dimensions.width],
  );

  return {
    // Dimensiones
    width: dimensions.width,
    height: dimensions.height,

    // Informacin del dispositivo
    deviceType,
    isTablet,
    isMobile,
    isSmallMobile,
    isWeb,
    isDesktop,

    // Orientacin
    orientation,
    isPortrait,
    isLandscape,

    // Densidad de pxeles
    pixelRatio,
    fontScale,

    // Funciones de escalado
    scaleWidth: scaleWidthMemo,
    scaleHeight: scaleHeightMemo,
    scaleWithLimits: scaleWithLimitsMemo,
    getResponsiveDimension: getResponsiveDimensionMemo,

    // Spacing y dimensiones
    spacing,
    spacingPreset,
    fontSize,
    fontSizePreset,
    dimensions: commonDimensions,

    // Utilidades
    applyResponsiveStyle: applyResponsiveStyleMemo,
    getGridColumns: getGridColumnsMemo,
    maintainAspectRatio,
    normalizeDPI,

    // Breakpoints
    breakpoints: BREAKPOINTS,
    isBreakpoint,
  };
};

// Hook adicional para estilos responsive con el tema
import { useAppTheme } from '@/app/styles/theme';

export const useResponsiveStyles = <T extends Record<string, any>>(
  styleFactory: (theme: any, responsive: ResponsiveInfo) => T,
): T => {
  const theme = useAppTheme();
  const responsive = useResponsive();

  return useMemo(
    () => styleFactory(theme, responsive),
    [theme, responsive, styleFactory],
  );
};

================
File: app/src/app/hooks/useServerConnection.ts
================
import { useState, useEffect } from 'react';
import { serverConnectionService } from '@/services/serverConnectionService';

export interface ServerConnectionState {
  isSearching: boolean;
  isConnected: boolean;
  error: string | null;
  serverUrl: string | null;
  hasWifi: boolean;
  isHealthy: boolean;
  retry: () => void;
}

export function useServerConnection(): ServerConnectionState {
  const [state, setState] = useState(() => {
    const serviceState = serverConnectionService.getState();
    return {
      isSearching: serviceState.isSearching,
      isConnected: serviceState.isConnected,
      error: serviceState.error,
      serverUrl: serviceState.currentUrl,
      hasWifi: serviceState.hasWifi,
      isHealthy: serviceState.isHealthy,
      retry: () => {},
    };
  });

  useEffect(() => {
    const serviceState = serverConnectionService.getState();
    setState({
      isSearching: serviceState.isSearching,
      isConnected: serviceState.isConnected,
      error: serviceState.error,
      serverUrl: serviceState.currentUrl,
      hasWifi: serviceState.hasWifi,
      isHealthy: serviceState.isHealthy,
      retry: () => serverConnectionService.retry(),
    });

    const unsubscribe = serverConnectionService.subscribe((newState) => {
      setState({
        isSearching: newState.isSearching,
        isConnected: newState.isConnected,
        error: newState.error,
        serverUrl: newState.currentUrl,
        hasWifi: newState.hasWifi,
        isHealthy: newState.isHealthy,
        retry: () => serverConnectionService.retry(),
      });
    });

    return () => {
      unsubscribe();
    };
  }, []);

  return state;
}

================
File: app/src/app/navigation/AppNavigator.tsx
================
import { useEffect } from 'react';
import {
  NavigationContainer,
  Theme as NavigationTheme,
} from '@react-navigation/native';
import { useAuthStore } from '../store/authStore';
import { AuthStack } from './AuthStack';
import { ConditionalAppNavigator } from './ConditionalAppNavigator';
import { useAppTheme } from '../styles/theme';
import { initImageCache } from '../lib/imageCache';
import { reconnectionSnackbarService } from '@/services/reconnectionSnackbarService';
import { serverConnectionService } from '@/services/serverConnectionService';

export function AppNavigator() {
  const isAuthenticated = useAuthStore((state) => state.isAuthenticated);
  const paperTheme = useAppTheme();

  // Inicializar servicios una sola vez al montar la app
  useEffect(() => {
    initImageCache();

    // El servicio se inicializa automticamente en su constructor
    // No necesita llamada explcita a initialize()

    return () => {
      // Limpiar cuando se desmonte toda la app
      serverConnectionService.destroy();
    };
  }, []); // Sin dependencias para que solo se ejecute una vez

  // Manejar servicios de notificacin basados en autenticacin
  useEffect(() => {
    if (isAuthenticated) {
      reconnectionSnackbarService.start();
    } else {
      reconnectionSnackbarService.stop();
    }

    return () => {
      reconnectionSnackbarService.stop();
    };
  }, [isAuthenticated]);

  const navigationTheme: NavigationTheme = {
    dark: paperTheme.dark,
    colors: {
      primary: paperTheme.colors.primary,
      background: paperTheme.colors.background,
      card: paperTheme.colors.surface,
      text: paperTheme.colors.onBackground,
      border: paperTheme.colors.outline,
      notification: paperTheme.colors.error,
    },
    fonts: {
      regular: {
        ...paperTheme.fonts.bodyMedium,
        fontWeight: paperTheme.fonts.bodyMedium.fontWeight ?? 'normal',
      },
      medium: {
        ...paperTheme.fonts.titleMedium,
        fontWeight: paperTheme.fonts.titleMedium.fontWeight ?? 'normal',
      },
      bold: {
        ...paperTheme.fonts.titleLarge,
        fontWeight: paperTheme.fonts.titleLarge.fontWeight ?? 'bold',
      },
      heavy: {
        ...paperTheme.fonts.titleLarge,
        fontWeight: paperTheme.fonts.titleLarge.fontWeight ?? '900',
      },
    },
  };

  return (
    <NavigationContainer theme={navigationTheme}>
      {isAuthenticated ? <ConditionalAppNavigator /> : <AuthStack />}
    </NavigationContainer>
  );
}

================
File: app/src/app/navigation/components/WebDrawerContent.tsx
================
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { ScrollView } from 'react-native';
import {
  Drawer as PaperDrawer,
  Text,
  Divider,
  Switch,
  TouchableRipple,
  Icon,
  Surface,
  Portal,
  Dialog,
  Button,
} from 'react-native-paper';
import { useThemeStore } from '../../store/themeStore';
import { THEME_MODE } from '../../types/theme.types';
import { useAuthStore } from '../../store/authStore';
import { useAppTheme, AppTheme } from '../../styles/theme';
import { useResponsive } from '../../hooks/useResponsive';
import { clearImageCache } from '../../lib/imageCache';
import { useSnackbarStore } from '../../store/snackbarStore';
import { RoleEnum } from '@/modules/users/schema/user.schema';

interface WebDrawerContentProps {
  onClose: () => void;
}

// Traducciones de roles
const ROLE_TRANSLATIONS: Record<number, string> = {
  [RoleEnum.ADMIN]: 'Administrador',
  [RoleEnum.MANAGER]: 'Gerente',
  [RoleEnum.CASHIER]: 'Cajero',
  [RoleEnum.WAITER]: 'Mesero',
  [RoleEnum.KITCHEN]: 'Cocina',
  [RoleEnum.DELIVERY]: 'Repartidor',
};

const getRoleTranslation = (roleId?: number): string => {
  if (!roleId) return 'Desconocido';
  return ROLE_TRANSLATIONS[roleId] || 'Desconocido';
};

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.surface,
    },
    userInfoSection: {
      padding: responsive.spacing(theme.spacing.m),
    },
    title: {
      ...theme.fonts.titleMedium,
      fontSize: responsive.fontSize(theme.fonts.titleMedium.fontSize),
      color: theme.colors.onSurface,
      marginBottom: responsive.spacing(4),
    },
    caption: {
      ...theme.fonts.bodySmall,
      fontSize: responsive.fontSize(theme.fonts.bodySmall.fontSize),
      color: theme.colors.onSurfaceVariant,
      marginBottom: responsive.spacing(2),
    },
    drawerSection: {
      marginTop: responsive.spacing(theme.spacing.s),
    },
    bottomDrawerSection: {
      marginBottom: responsive.spacing(theme.spacing.m),
      marginTop: 'auto',
      borderTopColor: theme.colors.outlineVariant,
      borderTopWidth: StyleSheet.hairlineWidth,
      paddingTop: responsive.spacing(theme.spacing.s),
    },
    preference: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      paddingVertical: responsive.spacing(theme.spacing.s),
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      alignItems: 'center',
      marginHorizontal: responsive.spacing(theme.spacing.xs),
      borderRadius: theme.roundness * 2,
    },
    drawerItemLabel: {
      ...theme.fonts.labelLarge,
      fontSize: responsive.fontSize(theme.fonts.labelLarge.fontSize),
    },
    drawerItemContainer: {
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingVertical: responsive.spacing(theme.spacing.m),
      flexDirection: 'row',
      alignItems: 'center',
      borderRadius: theme.roundness * 2,
      marginHorizontal: responsive.spacing(theme.spacing.xs),
      marginVertical: responsive.spacing(theme.spacing.xxs),
    },
    drawerItemIconContainer: {
      marginRight: responsive.spacing(theme.spacing.l),
      width: responsive.isTablet ? 20 : theme.spacing.l,
      alignItems: 'center',
    },
    divider: {
      marginVertical: responsive.spacing(theme.spacing.s),
      marginHorizontal: responsive.spacing(theme.spacing.m),
    },
    configSubheader: {
      ...theme.fonts.labelLarge,
      fontSize: responsive.fontSize(theme.fonts.labelLarge.fontSize),
      color: theme.colors.onSurfaceVariant,
      paddingLeft: responsive.spacing(theme.spacing.l),
      paddingRight: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.s),
      paddingBottom: responsive.spacing(theme.spacing.xxs),
    },
    drawerContentStyle: {
      paddingTop: 0,
    },
    containerStyle: {
      flex: 1,
    },
    rowContainer: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    fullWidthRow: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      width: '100%',
    },
    pointerEventsNone: {
      pointerEvents: 'none',
    },
    dialogStyle: {
      maxWidth: 600,
      alignSelf: 'center',
    },
    dialogScrollArea: {
      maxHeight: 400,
    },
    dialogText: {
      marginBottom: 16,
    },
    dialogTextSpaced: {
      marginBottom: 8,
    },
    dialogTextIndented: {
      marginLeft: 16,
    },
  });

export function WebDrawerContent({ onClose }: WebDrawerContentProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const logout = useAuthStore((state) => state.logout);
  const setThemePreference = useThemeStore((state) => state.setThemePreference);
  const user = useAuthStore((state) => state.user);
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const [showServerSettings, setShowServerSettings] = React.useState(false);

  // Efecto para cerrar con ESC
  React.useEffect(() => {
    const handleKeyPress = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        onClose();
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [onClose]);

  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );

  const handleClearCache = async () => {
    try {
      await clearImageCache();
      showSnackbar({
        message: 'Cach de imgenes limpiado exitosamente',
        type: 'success',
      });
    } catch (error) {
      showSnackbar({
        message: 'Error al limpiar el cach',
        type: 'error',
      });
    }
  };

  return (
    <Surface style={styles.container} elevation={0}>
      <ScrollView
        contentContainerStyle={styles.drawerContentStyle}
        showsVerticalScrollIndicator={false}
      >
        <View style={styles.containerStyle}>
          <Surface style={styles.userInfoSection} elevation={0}>
            {user ? (
              <>
                <Text style={styles.title} numberOfLines={1}>
                  {`${user.firstName ?? ''} ${user.lastName ?? ''}`.trim() ||
                    user.username ||
                    'Usuario'}
                </Text>
                <Text style={styles.caption} numberOfLines={1}>
                  Rol: {getRoleTranslation(user.role?.id)}
                </Text>
                <Text style={styles.caption} numberOfLines={1}>
                  {user.email ?? ''}
                </Text>
                <Text style={styles.caption} numberOfLines={1}>
                  @{user.username ?? 'username'}
                </Text>
              </>
            ) : (
              <Text style={styles.title}>Invitado</Text>
            )}
          </Surface>
          <Divider style={styles.divider} />

          {/* Seccin de Cocina */}
          {user?.role?.id === 5 && (
            <PaperDrawer.Section style={styles.drawerSection}>
              <Text style={styles.configSubheader}>Cocina</Text>
              <TouchableRipple
                onPress={() => {
                  // No need to navigate for kitchen users
                  onClose();
                }}
                style={styles.drawerItemContainer}
                rippleColor={`${theme.colors.primary}20`}
              >
                <View style={styles.rowContainer}>
                  <View style={styles.drawerItemIconContainer}>
                    <Icon
                      source="chef-hat"
                      size={responsive.isTablet ? 20 : 24}
                      color={theme.colors.primary}
                    />
                  </View>
                  <Text
                    style={[
                      styles.drawerItemLabel,
                      { color: theme.colors.primary },
                    ]}
                  >
                    Pantalla de Preparacin
                  </Text>
                </View>
              </TouchableRipple>
            </PaperDrawer.Section>
          )}
        </View>
      </ScrollView>

      <PaperDrawer.Section style={styles.bottomDrawerSection}>
        <TouchableRipple
          onPress={() => {
            const newPreference = theme.dark
              ? THEME_MODE.LIGHT
              : THEME_MODE.DARK;
            setThemePreference(newPreference);
          }}
          style={styles.preference}
        >
          <View style={styles.fullWidthRow}>
            <View style={styles.rowContainer}>
              <View style={styles.drawerItemIconContainer}>
                <Icon
                  source={theme.dark ? 'weather-night' : 'white-balance-sunny'}
                  size={responsive.isTablet ? 20 : 24}
                  color={theme.colors.onSurfaceVariant}
                />
              </View>
              <Text
                style={[
                  styles.drawerItemLabel,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                Modo Oscuro
              </Text>
            </View>
            <View style={styles.pointerEventsNone}>
              <Switch value={theme.dark} color={theme.colors.primary} />
            </View>
          </View>
        </TouchableRipple>

        <TouchableRipple
          onPress={handleClearCache}
          style={styles.drawerItemContainer}
          rippleColor={`${theme.colors.primary}20`}
        >
          <View style={styles.rowContainer}>
            <View style={styles.drawerItemIconContainer}>
              <Icon
                source="broom"
                size={responsive.isTablet ? 20 : 24}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <Text
              style={[
                styles.drawerItemLabel,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Limpiar Cach
            </Text>
          </View>
        </TouchableRipple>

        <TouchableRipple
          onPress={() => {
            setShowServerSettings(true);
            onClose();
          }}
          style={styles.drawerItemContainer}
          rippleColor={`${theme.colors.primary}20`}
        >
          <View style={styles.rowContainer}>
            <View style={styles.drawerItemIconContainer}>
              <Icon
                source="server-network"
                size={responsive.isTablet ? 20 : 24}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <Text
              style={[
                styles.drawerItemLabel,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Configuracin del Servidor
            </Text>
          </View>
        </TouchableRipple>

        <TouchableRipple
          onPress={() => {
            logout();
          }}
          style={styles.drawerItemContainer}
          rippleColor={`${theme.colors.error}20`}
        >
          <View style={styles.rowContainer}>
            <View style={styles.drawerItemIconContainer}>
              <Icon
                source="logout"
                size={responsive.isTablet ? 20 : 24}
                color={theme.colors.error}
              />
            </View>
            <Text
              style={[styles.drawerItemLabel, { color: theme.colors.error }]}
            >
              Cerrar Sesin
            </Text>
          </View>
        </TouchableRipple>
      </PaperDrawer.Section>

      {/* Modal de configuracin del servidor */}
      {showServerSettings && (
        <Portal>
          <Dialog
            visible={showServerSettings}
            onDismiss={() => setShowServerSettings(false)}
            style={styles.dialogStyle}
          >
            <Dialog.Title>Configuracin del Servidor</Dialog.Title>
            <Dialog.ScrollArea style={styles.dialogScrollArea}>
              <Text style={styles.dialogText}>
                Para configurar el servidor en la versin web, utiliza la
                aplicacin mvil.
              </Text>
              <Text style={styles.dialogTextSpaced}>
                La configuracin del servidor incluye:
              </Text>
              <Text style={styles.dialogTextIndented}>
                 Modo de conexin (Auto/Manual)
              </Text>
              <Text style={styles.dialogTextIndented}> URL del servidor</Text>
              <Text style={styles.dialogTextIndented}>
                 Prueba de conexin
              </Text>
            </Dialog.ScrollArea>
            <Dialog.Actions>
              <Button onPress={() => setShowServerSettings(false)}>
                Cerrar
              </Button>
            </Dialog.Actions>
          </Dialog>
        </Portal>
      )}
    </Surface>
  );
}

================
File: app/src/modules/areasTables/hooks/useTablesQueries.ts
================
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { tableService } from '../services/tableService';
import {
  Table,
  CreateTableDto,
  UpdateTableDto,
  FindAllTablesDto,
} from '../schema/table.schema';
import { BaseListQuery } from '../../../app/types/query.types';
import { useSnackbarStore } from '../../../app/store/snackbarStore';
import { getApiErrorMessage } from '../../../app/lib/errorMapping';

const tablesQueryKeys = {
  all: ['tables'] as const,
  lists: () => [...tablesQueryKeys.all, 'list'] as const,
  list: (filters: FindAllTablesDto & BaseListQuery) =>
    [...tablesQueryKeys.lists(), filters] as const,
  listsByArea: (areaId: string, filters?: Omit<FindAllTablesDto, 'areaId'>) =>
    [...tablesQueryKeys.lists(), { areaId, ...filters }] as const,
  details: () => [...tablesQueryKeys.all, 'detail'] as const,
  detail: (id: string) => [...tablesQueryKeys.details(), id] as const,
};

export const useGetTables = (
  filters: FindAllTablesDto = {},
  pagination: BaseListQuery = { page: 1, limit: 10 },
) => {
  const queryKey = tablesQueryKeys.list({ ...filters, ...pagination });
  return useQuery<Table[], Error>({
    queryKey,
    queryFn: () => tableService.getTables(filters, pagination),
  });
};

export const useGetTablesByAreaId = (
  areaId: string | null,
  filters: Omit<FindAllTablesDto, 'areaId'> = {},
  options?: { enabled?: boolean },
) => {
  const queryKey = tablesQueryKeys.listsByArea(areaId!, filters);
  return useQuery<Table[], Error>({
    queryKey,
    queryFn: () => tableService.getTablesByAreaId(areaId!, filters),
    enabled: !!areaId && (options?.enabled ?? true),
  });
};

export const useGetTableById = (
  id: string | null,
  options?: { enabled?: boolean },
) => {
  const queryKey = tablesQueryKeys.detail(id!);
  return useQuery<Table, Error>({
    queryKey,
    queryFn: () => tableService.getTableById(id!),
    enabled: !!id && (options?.enabled ?? true),
  });
};

export const useCreateTable = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<Table, Error, CreateTableDto>({
    mutationFn: tableService.createTable,
    onSuccess: (_newTable) => {
      queryClient.invalidateQueries({ queryKey: tablesQueryKeys.lists() });
      showSnackbar({ message: 'Mesa creada con xito', type: 'success' });
    },
    onError: (error) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
    },
  });
};

export const useUpdateTable = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  type UpdateTableContext = { previousDetail?: Table };

  return useMutation<
    Table,
    Error,
    { id: string; data: UpdateTableDto },
    UpdateTableContext
  >({
    mutationFn: ({ id, data }) => tableService.updateTable(id, data),

    onMutate: async (variables) => {
      const { id, data } = variables;
      const detailQueryKey = tablesQueryKeys.detail(id);

      await queryClient.cancelQueries({ queryKey: detailQueryKey });

      const previousDetail = queryClient.getQueryData<Table>(detailQueryKey);

      if (previousDetail) {
        queryClient.setQueryData<Table>(
          detailQueryKey,
          (old: Table | undefined) => (old ? { ...old, ...data } : undefined),
        );
      }

      return { previousDetail };
    },

    onError: (error, variables, context) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });

      if (context?.previousDetail) {
        queryClient.setQueryData(
          tablesQueryKeys.detail(variables.id),
          context.previousDetail,
        );
      }
    },

    onSettled: (data, error, variables) => {
      queryClient.invalidateQueries({ queryKey: tablesQueryKeys.lists() });
      queryClient.invalidateQueries({
        queryKey: tablesQueryKeys.detail(variables.id),
      });

      if (!error && data) {
        showSnackbar({
          message: 'Mesa actualizada con xito',
          type: 'success',
        });
      }
    },
  });
};

export const useDeleteTable = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  type DeleteTableContext = { previousDetail?: Table };

  return useMutation<void, Error, string, DeleteTableContext>({
    mutationFn: tableService.deleteTable,

    onMutate: async (deletedId) => {
      const detailQueryKey = tablesQueryKeys.detail(deletedId);

      await queryClient.cancelQueries({ queryKey: detailQueryKey });

      const previousDetail = queryClient.getQueryData<Table>(detailQueryKey);

      queryClient.removeQueries({ queryKey: detailQueryKey });

      return { previousDetail };
    },

    onError: (error, deletedId, context) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });

      if (context?.previousDetail) {
        queryClient.setQueryData(
          tablesQueryKeys.detail(deletedId),
          context.previousDetail,
        );
      }
    },

    onSettled: (_data, error, deletedId, context) => {
      queryClient.invalidateQueries({ queryKey: tablesQueryKeys.lists() });
      if (context?.previousDetail?.areaId) {
        queryClient.invalidateQueries({
          queryKey: tablesQueryKeys.listsByArea(context.previousDetail.areaId),
        });
      }

      if (!error) {
        queryClient.removeQueries({
          queryKey: tablesQueryKeys.detail(deletedId),
        });
        showSnackbar({ message: 'Mesa eliminada con xito', type: 'success' });
      }
    },
  });
};

================
File: app/src/modules/availability/components/PizzaCustomizationAvailabilityItem.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, Switch, Divider } from 'react-native-paper';
import { PizzaCustomizationGroupAvailability } from '../schema/availability.schema';
import { useOptimisticAvailability } from '../hooks/useOptimisticAvailability';
import { useAppTheme } from '@/app/styles/theme';
import { AvailabilityListItem } from './AvailabilityListItem';

interface PizzaCustomizationAvailabilityItemProps {
  group: PizzaCustomizationGroupAvailability;
}

export function PizzaCustomizationAvailabilityItem({
  group,
}: PizzaCustomizationAvailabilityItemProps) {
  const theme = useAppTheme();
  const [expanded, setExpanded] = useState(false);
  const updateAvailability = useOptimisticAvailability();

  const handleToggle = (id: string, currentState: boolean) => {
    updateAvailability.mutate({
      type: 'pizzaCustomization',
      id,
      isActive: !currentState,
    });
  };

  const activeCount = group.items.filter((item) => item.isActive).length;
  const totalCount = group.items.length;
  const allActive = activeCount === totalCount;

  const getTypeIcon = () => {
    return group.type === 'FLAVOR' ? 'pizza' : 'cheese';
  };

  const getTypeLabel = () => {
    return group.type === 'FLAVOR' ? 'Sabores' : 'Ingredientes';
  };

  const getSubtitle = () => {
    if (allActive) return 'Todos disponibles';
    if (activeCount === 0) return 'Ninguno disponible';
    return `${activeCount} de ${totalCount} disponibles`;
  };

  return (
    <AvailabilityListItem
      title={getTypeLabel()}
      subtitle={getSubtitle()}
      icon={getTypeIcon()}
      isActive={allActive}
      isExpanded={expanded}
      onToggleExpand={() => setExpanded(!expanded)}
    >
      {group.items.map((item, index) => (
        <React.Fragment key={item.id}>
          <View style={styles.item}>
            <Text
              style={[
                styles.itemName,
                !item.isActive && styles.strikethrough,
                { color: theme.colors.onSurface },
              ]}
            >
              {item.name}
            </Text>
            <Switch
              value={item.isActive}
              onValueChange={() => handleToggle(item.id, item.isActive)}
            />
          </View>
          {index < group.items.length - 1 && <Divider style={styles.divider} />}
        </React.Fragment>
      ))}
    </AvailabilityListItem>
  );
}

const styles = StyleSheet.create({
  item: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 4,
  },
  itemName: {
    fontSize: 13,
  },
  strikethrough: {
    textDecorationLine: 'line-through',
  },
  divider: {
    marginVertical: 8,
  },
});

================
File: app/src/modules/availability/screens/AvailabilityScreen.tsx
================
import React, { useState, useMemo, useCallback } from 'react';
import { View, StyleSheet, RefreshControl, FlatList } from 'react-native';
import {
  Searchbar,
  ActivityIndicator,
  Surface,
  Text,
  Menu,
  IconButton,
} from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { CategoryAvailabilityItem } from '../components/CategoryAvailabilityItem';
import { ModifierGroupAvailabilityItem } from '../components/ModifierGroupAvailabilityItem';
import { PizzaCustomizationAvailabilityItem } from '../components/PizzaCustomizationAvailabilityItem';
import {
  useMenuAvailability,
  useModifierGroupsAvailability,
} from '../hooks/useAvailabilityQueries';
import { usePizzaCustomizationsAvailability } from '../hooks/usePizzaCustomizationsAvailability';
import EmptyState from '@/app/components/common/EmptyState';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';

export const AvailabilityScreen: React.FC = () => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const [searchQuery, setSearchQuery] = useState('');
  const [viewMode, setViewMode] = useState<
    'menu' | 'modifiers' | 'pizzaCustomizations'
  >('menu');
  const [filterMenuVisible, setFilterMenuVisible] = useState(false);

  const {
    data: menuData,
    isLoading: isLoadingMenu,
    isError: isErrorMenu,
    refetch: refetchMenu,
  } = useMenuAvailability();

  const {
    data: modifiersData,
    isLoading: isLoadingModifiers,
    isError: isErrorModifiers,
    refetch: refetchModifiers,
  } = useModifierGroupsAvailability();

  const {
    data: pizzaCustomizationsData,
    isLoading: isLoadingPizzaCustomizations,
    isError: isErrorPizzaCustomizations,
    refetch: refetchPizzaCustomizations,
  } = usePizzaCustomizationsAvailability(searchQuery);

  useRefreshModuleOnFocus('availability');

  const handleRefresh = useCallback(() => {
    if (viewMode === 'menu') {
      refetchMenu();
    } else if (viewMode === 'modifiers') {
      refetchModifiers();
    } else {
      refetchPizzaCustomizations();
    }
  }, [viewMode, refetchMenu, refetchModifiers, refetchPizzaCustomizations]);

  const filteredMenuData = useMemo(() => {
    if (!menuData) return [];

    return menuData
      .map((category) => ({
        ...category,
        subcategories: category.subcategories
          .map((subcategory) => ({
            ...subcategory,
            products: subcategory.products.filter((product) => {
              const matchesSearch = product.name
                .toLowerCase()
                .includes(searchQuery.toLowerCase());
              return matchesSearch;
            }),
          }))
          .filter((subcategory) => subcategory.products.length > 0),
      }))
      .filter((category) => category.subcategories.length > 0);
  }, [menuData, searchQuery]);

  const filteredModifiersData = useMemo(() => {
    if (!modifiersData) return [];

    return modifiersData
      .map((group) => ({
        ...group,
        modifiers: group.modifiers.filter((modifier) => {
          const matchesSearch = modifier.name
            .toLowerCase()
            .includes(searchQuery.toLowerCase());
          return matchesSearch;
        }),
      }))
      .filter((group) => {
        const matchesSearch = group.name
          .toLowerCase()
          .includes(searchQuery.toLowerCase());
        return matchesSearch || group.modifiers.length > 0;
      });
  }, [modifiersData, searchQuery]);

  const isLoading =
    viewMode === 'menu'
      ? isLoadingMenu
      : viewMode === 'modifiers'
        ? isLoadingModifiers
        : isLoadingPizzaCustomizations;

  const isError =
    viewMode === 'menu'
      ? isErrorMenu
      : viewMode === 'modifiers'
        ? isErrorModifiers
        : isErrorPizzaCustomizations;

  const isEmpty =
    viewMode === 'menu'
      ? filteredMenuData.length === 0
      : viewMode === 'modifiers'
        ? filteredModifiersData.length === 0
        : !pizzaCustomizationsData || pizzaCustomizationsData.length === 0;

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.colors.background }]}
      edges={['top']}
    >
      <Surface style={styles.header} elevation={2}>
        <View style={styles.searchRow}>
          <Searchbar
            placeholder={`Buscar ${viewMode === 'menu' ? 'productos' : viewMode === 'modifiers' ? 'modificadores' : 'ingredientes y sabores'}...`}
            onChangeText={setSearchQuery}
            value={searchQuery}
            style={styles.searchbar}
            elevation={0}
            icon="magnify"
            inputStyle={{ color: theme.colors.onSurface }}
            placeholderTextColor={theme.colors.onSurfaceVariant}
            iconColor={theme.colors.onSurfaceVariant}
          />
          <View style={styles.filterButtonContainer}>
            <Menu
              visible={filterMenuVisible}
              onDismiss={() => setFilterMenuVisible(false)}
              anchor={
                <IconButton
                  icon={
                    viewMode === 'menu'
                      ? 'food'
                      : viewMode === 'modifiers'
                        ? 'tune'
                        : 'cheese'
                  }
                  mode="contained-tonal"
                  size={24}
                  onPress={() => setFilterMenuVisible(true)}
                  style={styles.filterIconButton}
                />
              }
              anchorPosition="bottom"
              contentStyle={styles.menuContent}
            >
              <Menu.Item
                onPress={() => {
                  setViewMode('menu');
                  setFilterMenuVisible(false);
                }}
                title="Men"
                leadingIcon="food"
                trailingIcon={viewMode === 'menu' ? 'check' : undefined}
                titleStyle={
                  viewMode === 'menu' ? styles.activeMenuTitle : undefined
                }
              />
              <Menu.Item
                onPress={() => {
                  setViewMode('modifiers');
                  setFilterMenuVisible(false);
                }}
                title="Modificadores"
                leadingIcon="tune"
                trailingIcon={viewMode === 'modifiers' ? 'check' : undefined}
                titleStyle={
                  viewMode === 'modifiers' ? styles.activeMenuTitle : undefined
                }
              />
              <Menu.Item
                onPress={() => {
                  setViewMode('pizzaCustomizations');
                  setFilterMenuVisible(false);
                }}
                title="Ingredientes Pizza"
                leadingIcon="cheese"
                trailingIcon={
                  viewMode === 'pizzaCustomizations' ? 'check' : undefined
                }
                titleStyle={
                  viewMode === 'pizzaCustomizations'
                    ? styles.activeMenuTitle
                    : undefined
                }
              />
            </Menu>
          </View>
        </View>
      </Surface>

      <View style={styles.content}>
        {isLoading ? (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
            <Text
              style={[
                styles.loadingText,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Cargando{' '}
              {viewMode === 'menu'
                ? 'categoras'
                : viewMode === 'modifiers'
                  ? 'modificadores'
                  : 'ingredientes'}
              ...
            </Text>
          </View>
        ) : isError ? (
          <EmptyState
            title="Error al cargar datos"
            message="No se pudieron cargar los datos. Verifica tu conexin."
            icon="alert-circle-outline"
            actionLabel="Reintentar"
            onAction={handleRefresh}
          />
        ) : isEmpty ? (
          <EmptyState
            title="No se encontraron resultados"
            message={
              searchQuery
                ? 'Intenta con otros trminos de bsqueda'
                : 'No hay elementos para mostrar'
            }
            icon="magnify"
          />
        ) : viewMode === 'menu' ? (
          <FlatList
            data={filteredMenuData}
            keyExtractor={(item) => item.id}
            renderItem={({ item }) => (
              <CategoryAvailabilityItem category={item} />
            )}
            refreshControl={
              <RefreshControl
                refreshing={isLoading}
                onRefresh={handleRefresh}
                colors={[theme.colors.primary]}
              />
            }
            contentContainerStyle={styles.listContent}
            showsVerticalScrollIndicator={false}
            ItemSeparatorComponent={() => (
              <View style={{ height: responsive.spacing(theme.spacing.s) }} />
            )}
          />
        ) : viewMode === 'modifiers' ? (
          <FlatList
            data={filteredModifiersData}
            keyExtractor={(item) => item.id}
            renderItem={({ item }) => (
              <ModifierGroupAvailabilityItem modifierGroup={item} />
            )}
            refreshControl={
              <RefreshControl
                refreshing={isLoading}
                onRefresh={handleRefresh}
                colors={[theme.colors.primary]}
              />
            }
            contentContainerStyle={styles.listContent}
            showsVerticalScrollIndicator={false}
            ItemSeparatorComponent={() => (
              <View style={{ height: responsive.spacing(theme.spacing.s) }} />
            )}
          />
        ) : (
          <FlatList
            data={pizzaCustomizationsData || []}
            keyExtractor={(item) => item.type}
            renderItem={({ item }) => (
              <PizzaCustomizationAvailabilityItem group={item} />
            )}
            refreshControl={
              <RefreshControl
                refreshing={isLoading}
                onRefresh={handleRefresh}
                colors={[theme.colors.primary]}
              />
            }
            contentContainerStyle={styles.listContent}
            showsVerticalScrollIndicator={false}
            ItemSeparatorComponent={() => (
              <View style={{ height: responsive.spacing(theme.spacing.s) }} />
            )}
          />
        )}
      </View>
    </SafeAreaView>
  );
};

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
    },
    header: {
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.m),
      paddingBottom: responsive.spacing(theme.spacing.m),
      borderBottomLeftRadius: 24,
      borderBottomRightRadius: 24,
    },
    searchRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.spacing(theme.spacing.s),
    },
    searchbar: {
      flex: 1,
      borderRadius: 12,
      height: responsive.isTablet ? 42 : 48,
    },
    filterButtonContainer: {
      position: 'relative',
    },
    filterIconButton: {
      margin: 0,
    },
    menuContent: {
      marginTop: responsive.spacing(4),
    },
    content: {
      flex: 1,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
    loadingText: {
      marginTop: responsive.spacing(theme.spacing.m),
      fontSize: responsive.fontSize(14),
    },
    listContent: {
      paddingVertical: responsive.spacing(theme.spacing.m),
    },
    activeMenuTitle: {
      color: theme.colors.primary,
      fontWeight: '600',
    },
  });

================
File: app/src/modules/customers/components/LocationPicker.tsx
================
import { useState } from 'react';
import { View, StyleSheet, Alert } from 'react-native';
import { Text, Button, TextInput, Chip, HelperText } from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { ResponsiveModal } from '@/app/components/responsive/ResponsiveModal';

interface LocationPickerProps {
  visible: boolean;
  onDismiss: () => void;
  onConfirm: (location: {
    latitude: number;
    longitude: number;
    geocodedAddress?: string;
  }) => void;
  initialLocation?: {
    latitude: number;
    longitude: number;
  };
  address?: string;
}

export default function LocationPicker({
  visible,
  onDismiss,
  onConfirm,
  initialLocation,
  address,
}: LocationPickerProps) {
  const theme = useAppTheme();
  const styles = getStyles(theme);

  const [latitude, setLatitude] = useState(
    initialLocation?.latitude?.toString() || '',
  );
  const [longitude, setLongitude] = useState(
    initialLocation?.longitude?.toString() || '',
  );
  const [geocodedAddress, setGeocodedAddress] = useState(address || '');
  const [latitudeError, setLatitudeError] = useState('');
  const [longitudeError, setLongitudeError] = useState('');

  const validateCoordinates = () => {
    let isValid = true;
    setLatitudeError('');
    setLongitudeError('');

    const lat = parseFloat(latitude);
    const lng = parseFloat(longitude);

    if (!latitude || isNaN(lat)) {
      setLatitudeError('Latitud invlida');
      isValid = false;
    } else if (lat < -90 || lat > 90) {
      setLatitudeError('La latitud debe estar entre -90 y 90');
      isValid = false;
    }

    if (!longitude || isNaN(lng)) {
      setLongitudeError('Longitud invlida');
      isValid = false;
    } else if (lng < -180 || lng > 180) {
      setLongitudeError('La longitud debe estar entre -180 y 180');
      isValid = false;
    }

    return isValid;
  };

  const handleConfirm = () => {
    if (validateCoordinates()) {
      onConfirm({
        latitude: parseFloat(latitude),
        longitude: parseFloat(longitude),
        geocodedAddress: geocodedAddress || undefined,
      });
    }
  };

  const handleUseCurrentLocation = () => {
    Alert.alert(
      'Funcin no disponible',
      'La funcin de mapas est temporalmente deshabilitada. Por favor, ingrese las coordenadas manualmente.',
      [{ text: 'OK' }],
    );
  };

  const footerActions = (
    <View style={styles.actions}>
      <Button mode="text" onPress={onDismiss} style={styles.button}>
        Cancelar
      </Button>
      <Button
        mode="contained"
        onPress={handleConfirm}
        disabled={!latitude || !longitude}
        style={styles.button}
      >
        Confirmar
      </Button>
    </View>
  );

  return (
    <ResponsiveModal
      visible={visible}
      onDismiss={onDismiss}
      title="Ubicacin"
      maxWidthTablet={400}
      scrollable={false}
      footer={footerActions}
    >
      <View style={styles.content}>
        <Text variant="bodyMedium" style={styles.helperText}>
          Ingrese las coordenadas de la ubicacin o use el botn para obtener su
          ubicacin actual.
        </Text>

        <View style={styles.coordinatesRow}>
          <View style={styles.coordinateInput}>
            <TextInput
              mode="outlined"
              label="Latitud"
              value={latitude}
              onChangeText={setLatitude}
              keyboardType="numeric"
              placeholder="19.4326"
              error={!!latitudeError}
            />
            {latitudeError ? (
              <HelperText type="error" visible={!!latitudeError}>
                {latitudeError}
              </HelperText>
            ) : null}
          </View>

          <View style={styles.coordinateInput}>
            <TextInput
              mode="outlined"
              label="Longitud"
              value={longitude}
              onChangeText={setLongitude}
              keyboardType="numeric"
              placeholder="-99.1332"
              error={!!longitudeError}
            />
            {longitudeError ? (
              <HelperText type="error" visible={!!longitudeError}>
                {longitudeError}
              </HelperText>
            ) : null}
          </View>
        </View>

        <Button
          mode="outlined"
          onPress={handleUseCurrentLocation}
          icon="crosshairs-gps"
          style={styles.locationButton}
        >
          Usar mi ubicacin actual
        </Button>

        <TextInput
          mode="outlined"
          label="Direccin (opcional)"
          value={geocodedAddress}
          onChangeText={setGeocodedAddress}
          multiline
          numberOfLines={2}
          placeholder="Calle, nmero, colonia, ciudad..."
          style={styles.addressInput}
        />

        {latitude && longitude && !latitudeError && !longitudeError && (
          <View style={styles.previewContainer}>
            <Text variant="labelMedium" style={styles.previewLabel}>
              Vista previa de coordenadas:
            </Text>
            <View style={styles.chipsContainer}>
              <Chip icon="map-marker" compact mode="flat">
                {parseFloat(latitude).toFixed(6)},{' '}
                {parseFloat(longitude).toFixed(6)}
              </Chip>
            </View>
          </View>
        )}
      </View>
    </ResponsiveModal>
  );
}

const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    content: {},
    helperText: {
      color: theme.colors.onSurfaceVariant,
      marginBottom: theme.spacing.m,
    },
    coordinatesRow: {
      flexDirection: 'row',
      gap: theme.spacing.m,
      marginBottom: theme.spacing.m,
    },
    coordinateInput: {
      flex: 1,
    },
    locationButton: {
      marginBottom: theme.spacing.m,
    },
    addressInput: {
      marginBottom: theme.spacing.m,
    },
    previewContainer: {
      marginTop: theme.spacing.s,
    },
    previewLabel: {
      color: theme.colors.onSurfaceVariant,
      marginBottom: theme.spacing.s,
    },
    chipsContainer: {
      flexDirection: 'row',
      flexWrap: 'wrap',
      gap: theme.spacing.s,
    },
    actions: {
      flexDirection: 'row',
      justifyContent: 'flex-end',
      gap: theme.spacing.s,
    },
    button: {
      minWidth: 100,
    },
  });

================
File: app/src/modules/customers/hooks/useCustomersQueries.ts
================
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';

import { customersService } from '../services/customersService';
import {
  FindAllCustomersQuery,
  ChatMessage,
  Address,
  CreateCustomerInput,
  UpdateCustomerInput,
} from '../schema/customer.schema';

export const customerKeys = {
  all: ['customers'] as const,
  lists: () => [...customerKeys.all, 'list'] as const,
  list: (filters?: FindAllCustomersQuery) =>
    [...customerKeys.lists(), filters] as const,
  details: () => [...customerKeys.all, 'detail'] as const,
  detail: (id: string) => [...customerKeys.details(), id] as const,
  activeRecent: (daysAgo: number) =>
    [...customerKeys.all, 'active-recent', daysAgo] as const,
  addresses: (customerId: string) =>
    [...customerKeys.all, 'addresses', customerId] as const,
};

export function useCustomers(filters?: FindAllCustomersQuery) {
  return useQuery({
    queryKey: customerKeys.list(filters),
    queryFn: () => customersService.findAll(filters),
  });
}

export function useCustomer(id: string, enabled = true) {
  return useQuery({
    queryKey: customerKeys.detail(id),
    queryFn: () => customersService.findOne(id),
    enabled: enabled && !!id,
  });
}

export function useCreateCustomer() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data: CreateCustomerInput) => customersService.create(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: customerKeys.lists() });
    },
  });
}

export function useUpdateCustomer() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: UpdateCustomerInput }) =>
      customersService.update(id, data),
    onSuccess: (updatedCustomer) => {
      queryClient.setQueryData(
        customerKeys.detail(updatedCustomer.id),
        updatedCustomer,
      );
      queryClient.invalidateQueries({ queryKey: customerKeys.lists() });
    },
  });
}

export function useDeleteCustomer() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id: string) => customersService.remove(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: customerKeys.lists() });
    },
  });
}

export function useAppendChatMessage() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      customerId,
      message,
    }: {
      customerId: string;
      message: Omit<ChatMessage, 'timestamp'>;
    }) => customersService.appendChatMessage(customerId, message),
    onSuccess: (updatedCustomer) => {
      queryClient.setQueryData(
        customerKeys.detail(updatedCustomer.id),
        updatedCustomer,
      );
    },
  });
}

export function useUpdateRelevantChatHistory() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      customerId,
      relevantHistory,
    }: {
      customerId: string;
      relevantHistory: ChatMessage[];
    }) =>
      customersService.updateRelevantChatHistory(customerId, relevantHistory),
    onSuccess: (updatedCustomer) => {
      queryClient.setQueryData(
        customerKeys.detail(updatedCustomer.id),
        updatedCustomer,
      );
    },
  });
}

export function useUpdateCustomerStats() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      customerId,
      stats,
    }: {
      customerId: string;
      stats: { totalOrders?: number; totalSpent?: number };
    }) => customersService.updateCustomerStats(customerId, stats),
    onSuccess: (updatedCustomer) => {
      queryClient.setQueryData(
        customerKeys.detail(updatedCustomer.id),
        updatedCustomer,
      );
      queryClient.invalidateQueries({ queryKey: customerKeys.lists() });
    },
  });
}

export function useActiveCustomersWithRecentInteraction(daysAgo = 30) {
  return useQuery({
    queryKey: customerKeys.activeRecent(daysAgo),
    queryFn: () => customersService.getActiveWithRecentInteraction(daysAgo),
  });
}

export function useGetAddressesByCustomer(
  customerId: string,
  options?: { enabled?: boolean },
) {
  return useQuery({
    queryKey: customerKeys.addresses(customerId),
    queryFn: async () => {
      try {
        const response = await apiClient.get<Address[]>(
          `${API_PATHS.CUSTOMERS}/${customerId}/addresses`,
        );
        return response.data;
      } catch (error) {
        return [];
      }
    },
    enabled: options?.enabled ?? true,
  });
}

================
File: app/src/modules/kitchen/components/OrderItemRow.tsx
================
import React from 'react';
import { View, StyleSheet, TouchableOpacity } from 'react-native';
import { Text, useTheme } from 'react-native-paper';
import { KitchenOrderItem, PreparationStatus } from '../schema/kitchen.schema';
import { useResponsive } from '@/app/hooks/useResponsive';

interface OrderItemRowProps {
  item: KitchenOrderItem;
  onPress?: () => void;
  onTogglePrepared?: (itemId: string, currentStatus: boolean) => void;
  isOrderInPreparation?: boolean;
}

export const OrderItemRow = React.memo<OrderItemRowProps>(
  ({ item, onTogglePrepared, isOrderInPreparation }) => {
    const theme = useTheme();
    const responsive = useResponsive();

    const isPrepared = item.preparationStatus === PreparationStatus.READY;
    const isInProgress =
      item.preparationStatus === PreparationStatus.IN_PROGRESS;
    const isDisabled = !item.belongsToMyScreen;
    const canToggle =
      isOrderInPreparation &&
      (isInProgress || isPrepared) &&
      item.belongsToMyScreen &&
      onTogglePrepared;

    const buildItemName = () => {
      const displayName = item.variantName || item.productName;
      return `${item.quantity}x ${displayName}`;
    };

    const buildItemDetails = () => {
      const details: string[] = [];

      const allCustoms: string[] = [];

      if (item.modifiers.length > 0) {
        allCustoms.push(...item.modifiers);
      }

      if (item.pizzaCustomizations && item.pizzaCustomizations.length > 0) {
        const customizations = item.pizzaCustomizations.map((pc) => {
          let text = pc.customizationName;
          if (pc.action) text += ` (${pc.action})`;
          if (pc.half) text += ` - ${pc.half}`;
          return text;
        });
        allCustoms.push(...customizations);
      }

      if (allCustoms.length > 0) {
        details.push(allCustoms.join(', '));
      }

      if (item.preparationNotes) {
        details.push(` ${item.preparationNotes}`);
      }

      return details;
    };

    const styles = StyleSheet.create({
      container: {
        paddingHorizontal: responsive.isWeb
          ? responsive.spacingPreset.m
          : responsive.spacingPreset.s,
        paddingVertical: responsive.isWeb
          ? responsive.spacingPreset.s
          : responsive.spacingPreset.xs,
        minHeight: responsive.isWeb ? 52 : responsive.isTablet ? 40 : 36,
        display: 'flex',
        justifyContent: 'center',
      },
      disabled: {
        opacity: 0.5,
      },
      row: {
        flexDirection: 'row',
        alignItems: 'center',
        flex: 1,
      },
      content: {
        flex: 1,
      },
      withBorder: {
        borderRadius: theme.roundness / 2,
        borderWidth: 1,
        borderColor: theme.colors.outline,
        borderStyle: 'dashed',
      },
      clickable: {
        backgroundColor: 'rgba(0, 0, 0, 0.02)',
      },
      itemName: {
        fontWeight: '500',
        fontSize: responsive.isWeb ? 16 : responsive.isTablet ? 13 : 14,
        lineHeight: responsive.isWeb ? 24 : responsive.isTablet ? 18 : 20,
      },
      detail: {
        color: theme.colors.onSurfaceVariant,
        marginTop: responsive.isWeb ? 2 : -1,
        fontSize: responsive.isWeb ? 14 : responsive.isTablet ? 11 : 12,
        lineHeight: responsive.isWeb ? 20 : responsive.isTablet ? 14 : 16,
      },
      strikethrough: {
        textDecorationLine: 'line-through',
        textDecorationStyle: 'solid',
        textDecorationColor: theme.colors.error,
        opacity: 0.7,
      },
      disabledText: {
        color: theme.colors.onSurfaceDisabled || '#999',
      },
      itemNameContainer: {
        flexDirection: 'row',
        alignItems: 'center',
        gap: responsive.spacingPreset.xs,
      },
    });

    const handlePress = () => {
      if (canToggle) {
        onTogglePrepared(item.id, isPrepared);
      }
    };

    const Container = canToggle ? TouchableOpacity : View;

    return (
      <Container
        onPress={canToggle ? handlePress : undefined}
        activeOpacity={0.7}
        style={[
          styles.container,
          styles.withBorder,
          isDisabled && styles.disabled,
          canToggle && styles.clickable,
        ]}
      >
        <View style={styles.row}>
          <View style={styles.content}>
            <View style={styles.itemNameContainer}>
              <Text
                variant="bodyMedium"
                style={[
                  styles.itemName,
                  isPrepared && styles.strikethrough,
                  isDisabled && styles.disabledText,
                ]}
              >
                {buildItemName()}
              </Text>
            </View>
            {buildItemDetails().map((detail, index) => (
              <Text
                key={index}
                variant="labelSmall"
                style={[
                  styles.detail,
                  isPrepared && styles.strikethrough,
                  isDisabled && styles.disabledText,
                ]}
              >
                {detail}
              </Text>
            ))}
          </View>
        </View>
      </Container>
    );
  },
);

OrderItemRow.displayName = 'OrderItemRow';

================
File: app/src/modules/kitchen/store/kitchenStore.ts
================
import { create } from 'zustand';
import { createJSONStorage, persist } from 'zustand/middleware';
import EncryptedStorage from '@/app/services/secureStorageService';
import { KitchenFilters } from '../schema/kitchen.schema';

const KITCHEN_FILTERS_STORAGE_KEY = 'kitchen_filters_preferences';

interface KitchenStore {
  filters: KitchenFilters;
  setFilters: (filters: KitchenFilters) => void;
  resetFilters: () => void;
}

const defaultFilters: KitchenFilters = {
  orderType: undefined,
  showPrepared: true,
  showAllProducts: true,
  ungroupProducts: false,
};

export const useKitchenStore = create<KitchenStore>()(
  persist(
    (set) => ({
      filters: defaultFilters,
      setFilters: (filters) => set({ filters }),
      resetFilters: () => set({ filters: defaultFilters }),
    }),
    {
      name: KITCHEN_FILTERS_STORAGE_KEY,
      storage: createJSONStorage(() => EncryptedStorage),
      partialize: (state) => ({ filters: state.filters }),
      onRehydrateStorage: () => {
        return (state, error) => {
          if (error) {
            return;
          }
          if (!state) {
            return;
          }
        };
      },
    },
  ),
);

================
File: app/src/modules/menu/components/ProductFormModal.tsx
================
import React, { useEffect, useMemo, useState, useCallback } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Button,
  TextInput,
  Text,
  ActivityIndicator,
  Switch,
  HelperText,
  Divider,
  IconButton,
  Card,
  Checkbox,
  TouchableRipple,
} from 'react-native-paper';
import {
  useForm,
  Controller,
  useFieldArray,
  SubmitHandler,
} from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';

import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import {
  ProductFormInputs,
  productSchema,
  updateProductSchema,
  ProductVariant,
  Product,
} from '../schema/products.schema';
import { ModifierGroup } from '../../modifiers/schema/modifierGroup.schema';
import { getApiErrorMessage } from '@/app/lib/errorMapping';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import VariantFormModal from './VariantFormModal';
import CustomImagePicker, {
  FileObject,
} from '@/app/components/common/CustomImagePicker';
import { ImageUploadService } from '@/app/lib/imageUploadService';
import { getImageUrl } from '@/app/lib/imageUtils';
import { useModifierGroupsQuery } from '../../modifiers/hooks/useModifierGroupsQuery';
import { modifierService } from '../../modifiers/services/modifierService';
import { useGetPreparationScreens } from '../../preparationScreens/hooks/usePreparationScreensQueries';
import { Menu } from 'react-native-paper';

interface ProductFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSubmit: (
    data: ProductFormInputs,
    photoId: string | null | undefined,
    file?: FileObject | null,
  ) => Promise<void>;
  initialData?: Product | null;
  isSubmitting: boolean;
  productId?: string | null;
  subcategoryId: string;
}

function ProductFormModal({
  visible,
  onDismiss,
  onSubmit,
  initialData,
  isSubmitting,
  productId,
  subcategoryId,
}: ProductFormModalProps): React.ReactElement {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const isEditing = !!productId && !!initialData;

  const [isVariantModalVisible, setIsVariantModalVisible] = useState(false);
  const [editingVariantIndex, setEditingVariantIndex] = useState<number | null>(
    null,
  );
  const [localSelectedFile, setLocalSelectedFile] = useState<FileObject | null>(
    null,
  );
  const [isInternalImageUploading, setIsInternalImageUploading] =
    useState(false);
  const [groupModifiers, setGroupModifiers] = useState<Record<string, any[]>>(
    {},
  );
  const [priceInputValue, setPriceInputValue] = useState<string>('');
  const [preparationScreenMenuVisible, setPreparationScreenMenuVisible] =
    useState(false);

  const defaultValues = useMemo(
    (): ProductFormInputs => ({
      name: '',
      description: null,
      price: null,
      hasVariants: false,
      isActive: true,
      isPizza: false,
      subcategoryId: subcategoryId,
      photoId: null,
      estimatedPrepTime: 10,
      preparationScreenId: null,
      sortOrder: 0,
      variants: [],
      variantsToDelete: [],
      imageUri: null,
      modifierGroupIds: [],
    }),
    [subcategoryId],
  );

  const {
    control,
    handleSubmit,
    reset,
    watch,
    setValue,
    formState: { errors },
  } = useForm<ProductFormInputs>({
    resolver: zodResolver(initialData ? updateProductSchema : productSchema),
    defaultValues: defaultValues,
  });

  const {
    fields: variantFields,
    append: appendVariant,
    remove: removeVariant,
    update: updateVariant,
  } = useFieldArray({
    control,
    name: 'variants',
  });

  useEffect(() => {
    const loadInitialData = async () => {
      if (visible) {
        if (isEditing && initialData) {
          const initialPrice = initialData.price;
          const parsedPrice =
            initialPrice !== null &&
            initialPrice !== undefined &&
            !isNaN(parseFloat(String(initialPrice)))
              ? parseFloat(String(initialPrice))
              : null;

          let imageUrl = null;
          if (initialData.photo?.path) {
            try {
              imageUrl = await getImageUrl(initialData.photo.path);
            } catch (error) {
              imageUrl = initialData.photo.path;
            }
          }

          reset({
            name: initialData.name,
            description: initialData.description || null,
            price: parsedPrice,
            hasVariants: initialData.hasVariants,
            isActive: initialData.isActive,
            isPizza: initialData.isPizza ?? false,
            subcategoryId: initialData.subcategoryId,
            photoId: initialData.photo?.id ?? null,
            estimatedPrepTime: initialData.estimatedPrepTime,
            preparationScreenId: initialData.preparationScreenId || null,
            sortOrder: initialData.sortOrder ?? 0,
            variants: initialData.variants || [],
            variantsToDelete: [],
            imageUri: imageUrl,
            modifierGroupIds: [],
          });
          setLocalSelectedFile(null);
        } else {
          reset(defaultValues);
          setLocalSelectedFile(null);
        }
      }
    };

    loadInitialData();
  }, [visible, isEditing, initialData, reset, defaultValues, subcategoryId]);

  const hasVariants = watch('hasVariants');
  const currentImageUri = watch('imageUri');
  const priceValue = watch('price');

  useEffect(() => {
    setPriceInputValue(
      priceValue !== null && priceValue !== undefined
        ? priceValue.toString()
        : '',
    );
  }, [priceValue]);

  const { data: modifierGroupsResponse, isLoading: isLoadingGroups } =
    useModifierGroupsQuery({ isActive: true });

  const { data: preparationScreensResponse } = useGetPreparationScreens(
    {},
    { page: 1, limit: 50 },
  );
  const preparationScreens = preparationScreensResponse?.data || [];

  const allModifierGroups = useMemo(
    () => modifierGroupsResponse?.data || [],
    [modifierGroupsResponse?.data],
  );

  useEffect(() => {
    const loadModifiers = async () => {
      const modifiersMap: Record<string, any[]> = {};

      for (const group of allModifierGroups) {
        try {
          const modifiers = await modifierService.findByGroupId(group.id);
          modifiersMap[group.id] = modifiers.filter((mod) => mod.isActive);
        } catch (error) {
          modifiersMap[group.id] = [];
        }
      }

      setGroupModifiers(modifiersMap);
    };

    if (allModifierGroups.length > 0) {
      loadModifiers();
    }
  }, [allModifierGroups]);

  useEffect(() => {
    if (visible) {
      if (isEditing && initialData?.modifierGroups) {
        if (Array.isArray(initialData.modifierGroups)) {
          const assignedIds = initialData.modifierGroups.map(
            (group: ModifierGroup) => group.id,
          );
          setValue('modifierGroupIds', assignedIds);
        } else {
          setValue('modifierGroupIds', []);
        }
      } else if (!isEditing) {
        setValue('modifierGroupIds', []);
      } else if (isEditing && !initialData?.modifierGroups) {
        setValue('modifierGroupIds', []);
      }
    }
  }, [visible, isEditing, initialData, setValue, reset, defaultValues]);

  const handleImageSelected = useCallback(
    (uri: string, file: FileObject) => {
      setValue('imageUri', uri, { shouldValidate: true, shouldDirty: true });
      setLocalSelectedFile(file);
    },
    [setValue],
  );

  const handleImageRemoved = useCallback(() => {
    setValue('imageUri', null, { shouldValidate: true, shouldDirty: true });
    setLocalSelectedFile(null);
  }, [setValue]);

  const processSubmit: SubmitHandler<ProductFormInputs> = async (formData) => {
    if (isSubmitting || isInternalImageUploading) return;

    let finalPhotoId: string | null | undefined = undefined;

    if (localSelectedFile) {
      setIsInternalImageUploading(true);
      try {
        const uploadResult =
          await ImageUploadService.uploadImage(localSelectedFile);
        if (uploadResult.success && uploadResult.photoId) {
          finalPhotoId = uploadResult.photoId;
        } else {
          throw new Error(
            uploadResult.error || 'La subida de la imagen fall.',
          );
        }
      } catch (error) {
        showSnackbar({
          message: `Error al subir imagen: ${getApiErrorMessage(error)}`,
          type: 'error',
        });
        setIsInternalImageUploading(false);
        return;
      } finally {
        setIsInternalImageUploading(false);
      }
    } else {
      finalPhotoId = await ImageUploadService.determinePhotoId(
        currentImageUri,
        initialData ?? undefined,
      );
    }

    const finalData = {
      ...formData,
      price: hasVariants ? null : formData.price,
      variants: hasVariants ? formData.variants : [],
    };

    await onSubmit(finalData, finalPhotoId, localSelectedFile);
    setLocalSelectedFile(null);
  };

  const showVariantModal = (index: number | null = null) => {
    setEditingVariantIndex(index);
    setIsVariantModalVisible(true);
  };

  const handleVariantSubmit = (variantData: ProductVariant) => {
    if (editingVariantIndex !== null) {
      const originalVariantId =
        initialData?.variants?.[editingVariantIndex]?.id;
      const priceAsNumber = Number(variantData.price);
      const dataToUpdate = {
        ...variantData,
        price: isNaN(priceAsNumber) ? 0 : priceAsNumber,
        ...(originalVariantId && { id: originalVariantId }),
      };
      const finalDataToUpdate =
        !originalVariantId && 'id' in dataToUpdate
          ? (({ id, ...rest }) => rest)(dataToUpdate)
          : dataToUpdate;

      updateVariant(editingVariantIndex, finalDataToUpdate as ProductVariant);
    } else {
      const { id, price, ...restNewVariantData } = variantData;
      const newPriceAsNumber = Number(price);
      const newVariantData = {
        ...restNewVariantData,
        price: isNaN(newPriceAsNumber) ? 0 : newPriceAsNumber,
      };
      appendVariant(newVariantData as ProductVariant);
    }
    setIsVariantModalVisible(false);
    setEditingVariantIndex(null);
  };

  const handleRemoveVariant = (index: number) => {
    const variantToRemove = variantFields[index];
    if (variantToRemove.id) {
      const currentToDelete = watch('variantsToDelete') || [];
      setValue('variantsToDelete', [...currentToDelete, variantToRemove.id]);
    }
    removeVariant(index);
  };

  const variantInitialData =
    editingVariantIndex !== null
      ? (variantFields[editingVariantIndex] as ProductVariant)
      : undefined;

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalSurface}
        dismissable={!isSubmitting && !isInternalImageUploading}
      >
        <View style={styles.modalHeader}>
          <Text variant="titleLarge" style={styles.modalTitle}>
            {isEditing ? 'Editar Producto' : 'Nuevo Producto'}
          </Text>
        </View>

        <ScrollView contentContainerStyle={styles.scrollContent}>
          <Card style={styles.card}>
            <Card.Content>
              <View style={styles.imagePickerContainer}>
                <CustomImagePicker
                  value={currentImageUri}
                  onImageSelected={handleImageSelected}
                  onImageRemoved={handleImageRemoved}
                  isLoading={isInternalImageUploading}
                  disabled={isSubmitting}
                  size={150}
                  placeholderIcon="food-outline"
                  placeholderText="Imagen del producto"
                />
                {errors.imageUri && (
                  <HelperText type="error">
                    {errors.imageUri.message}
                  </HelperText>
                )}
              </View>

              <Controller
                control={control}
                name="name"
                render={({ field: { onChange, onBlur, value } }) => (
                  <TextInput
                    label="Nombre del Producto *"
                    value={value}
                    onChangeText={onChange}
                    onBlur={onBlur}
                    error={!!errors.name}
                    style={styles.input}
                    disabled={isSubmitting}
                  />
                )}
              />
              {errors.name && (
                <HelperText type="error" visible={!!errors.name}>
                  {errors.name.message}
                </HelperText>
              )}

              <Controller
                control={control}
                name="description"
                render={({ field: { onChange, onBlur, value } }) => (
                  <TextInput
                    label="Descripcin"
                    value={value || ''}
                    onChangeText={onChange}
                    onBlur={onBlur}
                    error={!!errors.description}
                    style={styles.input}
                    disabled={isSubmitting}
                    multiline
                    numberOfLines={3}
                  />
                )}
              />
              {errors.description && (
                <HelperText type="error" visible={!!errors.description}>
                  {errors.description.message}
                </HelperText>
              )}

              <View style={styles.switchContainer}>
                <Text style={styles.label}>Tiene Variantes?</Text>
                <Controller
                  control={control}
                  name="hasVariants"
                  render={({ field: { onChange, value } }) => (
                    <Switch
                      value={value}
                      onValueChange={(newValue) => {
                        onChange(newValue);
                        if (newValue) {
                          setValue('price', null, { shouldValidate: true });
                        }
                      }}
                      disabled={isSubmitting}
                    />
                  )}
                />
              </View>

              {hasVariants && errors.price && (
                <HelperText type="error" visible={!!errors.price}>
                  {errors.price.message}
                </HelperText>
              )}

              {!hasVariants && (
                <>
                  <Controller
                    control={control}
                    name="price"
                    render={({ field }) => (
                      <TextInput
                        mode="outlined"
                        label="Precio *"
                        keyboardType="decimal-pad"
                        value={priceInputValue}
                        onChangeText={(text) => {
                          const formattedText = text.replace(/,/g, '.');

                          if (/^(\d*\.?\d*)$/.test(formattedText)) {
                            setPriceInputValue(formattedText);
                            if (formattedText === '') {
                              field.onChange(null);
                            } else if (formattedText !== '.') {
                              field.onChange(parseFloat(formattedText));
                            }
                          }
                        }}
                        error={!!errors.price}
                        disabled={isSubmitting || hasVariants}
                        style={styles.input}
                      />
                    )}
                  />
                  {errors.price && (
                    <HelperText type="error" visible={!!errors.price}>
                      {errors.price?.message || 'Precio invlido'}
                    </HelperText>
                  )}
                </>
              )}

              {hasVariants && (
                <View style={styles.variantsSection}>
                  <Divider style={styles.divider} />
                  <View style={styles.variantsHeader}>
                    <Text variant="titleMedium">Variantes</Text>
                    <Button
                      mode="contained-tonal"
                      icon="plus"
                      onPress={() => showVariantModal()}
                      disabled={isSubmitting}
                    >
                      Aadir
                    </Button>
                  </View>
                  {variantFields.length === 0 && (
                    <Text style={styles.noVariantsText}>
                      An no hay variantes aadidas.
                    </Text>
                  )}
                  {variantFields.map((field, index) => (
                    <Card
                      key={field.id || `new-${index}`}
                      style={[
                        styles.variantCard,
                        field.isActive === false && styles.variantCardInactive,
                      ]}
                    >
                      <View style={styles.variantContent}>
                        <View style={styles.variantInfo}>
                          <View style={styles.variantHeader}>
                            <Text
                              style={[
                                styles.variantName,
                                field.isActive === false &&
                                  styles.variantNameInactive,
                              ]}
                              numberOfLines={1}
                              ellipsizeMode="tail"
                            >
                              {field.name || 'Nueva Variante'}
                            </Text>
                            {field.isActive === false && (
                              <View style={styles.inactiveBadge}>
                                <Text style={styles.inactiveBadgeText}>
                                  Inactiva
                                </Text>
                              </View>
                            )}
                          </View>
                          <Text style={styles.variantPrice}>
                            $
                            {!isNaN(Number(field.price))
                              ? Number(field.price).toFixed(2)
                              : '0.00'}
                          </Text>
                        </View>
                        <View style={styles.variantActions}>
                          <IconButton
                            icon="pencil"
                            size={24}
                            onPress={() => showVariantModal(index)}
                            disabled={isSubmitting}
                            style={styles.variantActionButton}
                          />
                          <IconButton
                            icon="delete"
                            size={24}
                            onPress={() => handleRemoveVariant(index)}
                            iconColor={theme.colors.error}
                            disabled={isSubmitting}
                            style={styles.variantActionButton}
                          />
                        </View>
                      </View>
                    </Card>
                  ))}
                  {errors.variants?.message && (
                    <HelperText
                      type="error"
                      visible={!!errors.variants.message}
                    >
                      {errors.variants.message as string}
                    </HelperText>
                  )}
                  {errors.variants?.root?.message && (
                    <HelperText
                      type="error"
                      visible={!!errors.variants.root.message}
                    >
                      {errors.variants.root.message as string}
                    </HelperText>
                  )}
                </View>
              )}

              <Divider style={styles.divider} />

              <Controller
                control={control}
                name="estimatedPrepTime"
                render={({ field: { onChange, onBlur, value } }) => (
                  <TextInput
                    label="Tiempo Prep. Estimado (min)"
                    value={
                      value !== null && value !== undefined ? String(value) : ''
                    }
                    onChangeText={(text) =>
                      onChange(text ? parseInt(text, 10) : 0)
                    }
                    onBlur={onBlur}
                    error={!!errors.estimatedPrepTime}
                    style={styles.input}
                    keyboardType="numeric"
                    disabled={isSubmitting}
                  />
                )}
              />
              {errors.estimatedPrepTime && (
                <HelperText type="error" visible={!!errors.estimatedPrepTime}>
                  {errors.estimatedPrepTime.message}
                </HelperText>
              )}

              <Controller
                control={control}
                name="preparationScreenId"
                render={({ field: { onChange, value } }) => (
                  <View>
                    <Menu
                      visible={preparationScreenMenuVisible}
                      onDismiss={() => setPreparationScreenMenuVisible(false)}
                      anchor={
                        <TextInput
                          label="Pantalla de Preparacin"
                          value={
                            preparationScreens.find(
                              (screen) => screen.id === value,
                            )?.name || ''
                          }
                          onPress={() => setPreparationScreenMenuVisible(true)}
                          right={
                            value ? (
                              <TextInput.Icon
                                icon="close"
                                onPress={() => {
                                  onChange(null);
                                }}
                              />
                            ) : (
                              <TextInput.Icon
                                icon="chevron-down"
                                onPress={() =>
                                  setPreparationScreenMenuVisible(true)
                                }
                              />
                            )
                          }
                          editable={false}
                          error={!!errors.preparationScreenId}
                          style={styles.input}
                          disabled={isSubmitting}
                        />
                      }
                    >
                      {preparationScreens.map((screen) => (
                        <Menu.Item
                          key={screen.id}
                          onPress={() => {
                            onChange(screen.id);
                            setPreparationScreenMenuVisible(false);
                          }}
                          title={screen.name}
                        />
                      ))}
                    </Menu>
                  </View>
                )}
              />
              {errors.preparationScreenId && (
                <HelperText type="error" visible={!!errors.preparationScreenId}>
                  {errors.preparationScreenId.message}
                </HelperText>
              )}

              <Controller
                control={control}
                name="sortOrder"
                render={({ field: { onChange, onBlur, value } }) => (
                  <TextInput
                    label="Orden de visualizacin"
                    value={
                      value !== null && value !== undefined ? String(value) : ''
                    }
                    onChangeText={(text) =>
                      onChange(text ? parseInt(text, 10) : 0)
                    }
                    onBlur={onBlur}
                    error={!!errors.sortOrder}
                    style={styles.input}
                    keyboardType="numeric"
                    disabled={isSubmitting}
                  />
                )}
              />
              {errors.sortOrder && (
                <HelperText type="error" visible={!!errors.sortOrder}>
                  {errors.sortOrder.message}
                </HelperText>
              )}

              <View style={styles.switchContainer}>
                <Text style={styles.label}>Activo</Text>
                <Controller
                  control={control}
                  name="isActive"
                  render={({ field: { onChange, value } }) => (
                    <Switch
                      value={value}
                      onValueChange={onChange}
                      disabled={isSubmitting}
                    />
                  )}
                />
              </View>

              <View style={styles.switchContainer}>
                <Text style={styles.label}>Es Pizza</Text>
                <Controller
                  control={control}
                  name="isPizza"
                  render={({ field: { onChange, value } }) => (
                    <Switch
                      value={value}
                      onValueChange={onChange}
                      disabled={isSubmitting}
                    />
                  )}
                />
              </View>

              <Divider style={styles.divider} />

              <View style={styles.modifierGroupSection}>
                <Text variant="titleMedium" style={styles.sectionTitle}>
                  Grupos de Modificadores
                </Text>
                {isLoadingGroups ? (
                  <ActivityIndicator
                    animating={true}
                    style={{
                      marginVertical: responsive.spacing(theme.spacing.m),
                    }}
                  />
                ) : allModifierGroups.length === 0 ? (
                  <Text style={styles.noItemsText}>
                    No hay grupos de modificadores disponibles.
                  </Text>
                ) : (
                  <Controller
                    control={control}
                    name="modifierGroupIds"
                    render={({ field: { onChange, value } }) => {
                      const currentIds = Array.isArray(value) ? value : []; // Asegurar que sea array
                      const availableGroups = allModifierGroups; // Ya es un array de ModifierGroup

                      return (
                        <>
                          {availableGroups.map((group: ModifierGroup) => {
                            const isSelected = currentIds.includes(group.id);
                            const modifiers = groupModifiers[group.id] || [];

                            return (
                              <TouchableRipple
                                key={group.id}
                                onPress={() => {
                                  const newIds = isSelected
                                    ? currentIds.filter((id) => id !== group.id)
                                    : [...currentIds, group.id];
                                  onChange(newIds);
                                }}
                                disabled={isSubmitting}
                                style={styles.modifierGroupTouchable}
                              >
                                <View style={styles.modifierGroupContent}>
                                  <Checkbox
                                    status={
                                      isSelected ? 'checked' : 'unchecked'
                                    }
                                    disabled={isSubmitting}
                                  />
                                  <View
                                    style={styles.modifierGroupTextContainer}
                                  >
                                    <Text style={styles.modifierGroupName}>
                                      {group.name}
                                    </Text>
                                    {modifiers.length > 0 && (
                                      <View
                                        style={styles.modifiersListContainer}
                                      >
                                        {modifiers.map((modifier, index) => (
                                          <Text
                                            key={modifier.id}
                                            style={styles.modifierItem}
                                          >
                                            {modifier.isDefault && ' '}
                                            {modifier.name}
                                            {index < modifiers.length - 1 &&
                                              ', '}
                                          </Text>
                                        ))}
                                      </View>
                                    )}
                                    {modifiers.length === 0 && (
                                      <Text style={styles.noModifiersText}>
                                        Sin modificadores activos
                                      </Text>
                                    )}
                                  </View>
                                </View>
                              </TouchableRipple>
                            );
                          })}
                        </>
                      );
                    }}
                  />
                )}
                {errors.modifierGroupIds && (
                  <HelperText type="error" visible={!!errors.modifierGroupIds}>
                    {errors.modifierGroupIds.message as string}
                  </HelperText>
                )}
              </View>
            </Card.Content>
          </Card>
        </ScrollView>

        {(isSubmitting || isInternalImageUploading) && (
          <View style={styles.loadingOverlay}>
            <ActivityIndicator
              animating={true}
              size="large"
              color={theme.colors.primary}
            />
          </View>
        )}

        <View style={styles.modalActions}>
          <Button
            mode="outlined"
            onPress={onDismiss}
            style={[styles.formButton, styles.cancelButton]}
            disabled={isSubmitting || isInternalImageUploading}
          >
            Cancelar
          </Button>
          <Button
            mode="contained"
            onPress={handleSubmit(processSubmit)}
            loading={isSubmitting || isInternalImageUploading}
            disabled={isSubmitting || isInternalImageUploading}
            style={styles.formButton}
          >
            {isEditing ? 'Guardar' : 'Crear'}
          </Button>
        </View>
      </Modal>

      <VariantFormModal
        visible={isVariantModalVisible}
        onDismiss={() => setIsVariantModalVisible(false)}
        onSubmit={handleVariantSubmit}
        initialData={variantInitialData}
      />
    </Portal>
  );
}

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    modalSurface: {
      padding: 0,
      margin: responsive.spacing(20),
      marginHorizontal: responsive.isTablet
        ? responsive.spacing(40)
        : responsive.spacing(20),
      borderRadius: theme.roundness * 2,
      elevation: 4,
      backgroundColor: theme.colors.background,
      maxHeight: responsive.isTablet ? '92%' : '90%',
      minHeight: responsive.isTablet ? 650 : undefined,
      maxWidth: responsive.isTablet ? 700 : 500,
      alignSelf: 'center',
      width: responsive.isTablet ? '85%' : '90%',
      overflow: 'hidden',
    },
    modalHeader: {
      backgroundColor: theme.colors.primary,
      paddingVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      paddingHorizontal: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
      borderTopLeftRadius: theme.roundness * 2,
      borderTopRightRadius: theme.roundness * 2,
    },
    modalTitle: {
      color: theme.colors.onPrimary,
      fontWeight: 'bold',
      textAlign: 'center',
      fontSize: responsive.isTablet ? 20 : 22,
    },
    scrollContent: {
      padding: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
      paddingBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.l)
        : responsive.spacing(theme.spacing.xl),
    },
    card: {
      backgroundColor: theme.colors.surface,
      elevation: 1,
    },
    input: {
      marginBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surfaceVariant,
    },
    switchContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
    },
    label: {
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 14 : 16,
      marginRight: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
    },
    divider: {
      marginVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
    },
    variantsSection: {
      marginTop: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
    },
    variantsHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
    },
    variantCard: {
      marginBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
      backgroundColor: theme.colors.elevation.level1,
      paddingVertical: responsive.isTablet
        ? 6
        : responsive.spacing(theme.spacing.xs),
      paddingLeft: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      paddingRight: responsive.isTablet
        ? 4
        : responsive.spacing(theme.spacing.xs),
    },
    variantCardInactive: {
      opacity: 0.7,
      backgroundColor: theme.colors.surfaceVariant,
    },
    variantContent: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
    },
    variantInfo: {
      flex: 1,
      marginRight: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
    },
    variantHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: responsive.isTablet ? 1 : 2,
    },
    variantName: {
      fontSize: responsive.isTablet ? 13 : 15,
      fontWeight: '500',
      color: theme.colors.onSurface,
      flex: 1,
    },
    variantNameInactive: {
      color: theme.colors.onSurfaceVariant,
    },
    variantPrice: {
      fontSize: responsive.isTablet ? 12 : 14,
      color: theme.colors.primary,
      fontWeight: '600',
    },
    inactiveBadge: {
      backgroundColor: theme.colors.errorContainer,
      paddingHorizontal: responsive.isTablet
        ? 6
        : responsive.spacing(theme.spacing.xs),
      paddingVertical: responsive.isTablet ? 1 : 2,
      borderRadius: 4,
      marginLeft: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.xs),
    },
    inactiveBadgeText: {
      fontSize: responsive.isTablet ? 9 : 10,
      color: theme.colors.onErrorContainer,
      fontWeight: '600',
    },
    variantActions: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.isTablet ? 4 : 8,
    },
    variantActionButton: {
      margin: 0,
    },
    noVariantsText: {
      textAlign: 'center',
      color: theme.colors.onSurfaceVariant,
      marginVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
      fontStyle: 'italic',
      fontSize: responsive.isTablet ? 13 : 14,
    },
    imagePickerContainer: {
      alignItems: 'center',
      marginBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
    },
    modifierGroupSection: {
      marginTop: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
    },
    sectionTitle: {
      marginBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
      marginLeft: responsive.isTablet
        ? 4
        : responsive.spacing(theme.spacing.xs),
      fontSize: responsive.isTablet ? 16 : 18,
    },
    noItemsText: {
      textAlign: 'center',
      color: theme.colors.onSurfaceVariant,
      marginVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
      fontStyle: 'italic',
      fontSize: responsive.isTablet ? 13 : 14,
    },
    modifierGroupTouchable: {
      paddingVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
      paddingHorizontal: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      marginHorizontal: responsive.isTablet
        ? -responsive.spacing(theme.spacing.s)
        : -responsive.spacing(theme.spacing.m),
    },
    modifierGroupContent: {
      flexDirection: 'row',
      alignItems: 'flex-start',
    },
    modifierGroupTextContainer: {
      flex: 1,
      marginLeft: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
    },
    modifierGroupName: {
      fontSize: responsive.isTablet ? 13 : 15,
      color: theme.colors.onSurface,
    },
    modifiersList: {
      fontSize: responsive.isTablet ? 11 : 12,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      marginTop: responsive.isTablet ? 1 : 2,
    },
    modifiersListContainer: {
      marginTop: responsive.isTablet ? 2 : 4,
      flexDirection: 'row',
      flexWrap: 'wrap',
      gap: responsive.isTablet ? 2 : 4,
    },
    modifierItem: {
      fontSize: responsive.isTablet ? 11 : 13,
      color: theme.colors.onSurfaceVariant,
      lineHeight: responsive.isTablet ? 15 : 18,
    },
    noModifiersText: {
      fontSize: responsive.isTablet ? 11 : 12,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      marginTop: responsive.isTablet ? 2 : 4,
      opacity: 0.7,
    },
    modalActions: {
      flexDirection: 'row',
      justifyContent: 'center',
      paddingVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      paddingHorizontal: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
      gap: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
    },
    formButton: {
      borderRadius: theme.roundness * 2,
      paddingHorizontal: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
      minWidth: responsive.isTablet ? 100 : 120,
    },
    cancelButton: {
      marginRight: 0,
    },
    loadingOverlay: {
      ...StyleSheet.absoluteFillObject,
      backgroundColor: 'rgba(0, 0, 0, 0.3)',
      justifyContent: 'center',
      alignItems: 'center',
      zIndex: 10,
      borderRadius: theme.roundness * 2,
    },
  });

export default ProductFormModal;

================
File: app/src/modules/menu/hooks/useSubcategoriesQueries.ts
================
import {
  useQuery,
  useMutation,
  useQueryClient,
  type UseQueryResult,
  type UseMutationResult,
} from '@tanstack/react-query';
import { subcategoriesService } from '../services/subcategoriesService';
import {
  SubCategory,
  CreateSubCategoryDto,
  UpdateSubCategoryDto,
  FindAllSubcategoriesDto,
} from '../schema/subcategories.schema';
import { PaginatedResponse } from '../../../app/types/api.types';
import { ApiError } from '../../../app/lib/errors';
import {
  useSnackbarStore,
  type SnackbarState,
} from '../../../app/store/snackbarStore';
import { getApiErrorMessage } from '../../../app/lib/errorMapping';

const subcategoryKeys = {
  all: ['subcategories'] as const,
  lists: () => [...subcategoryKeys.all, 'list'] as const,
  list: (filters: FindAllSubcategoriesDto) =>
    [...subcategoryKeys.lists(), filters] as const,
  details: () => [...subcategoryKeys.all, 'detail'] as const,
  detail: (id: string) => [...subcategoryKeys.details(), id] as const,
};

export const useFindAllSubcategories = (
  params: FindAllSubcategoriesDto = { page: 1, limit: 10 },
  enabled: boolean = true,
): UseQueryResult<PaginatedResponse<SubCategory>, ApiError> => {
  const queryKey = subcategoryKeys.list(params);
  return useQuery<PaginatedResponse<SubCategory>, ApiError>({
    queryKey: queryKey,
    queryFn: () => subcategoriesService.findAllSubcategories(params),
    enabled: enabled,
  });
};

export const useFindOneSubcategory = (
  id: string | undefined,
  enabled: boolean = true,
): UseQueryResult<SubCategory, ApiError> => {
  const queryKey = subcategoryKeys.detail(id!);
  return useQuery<SubCategory, ApiError>({
    queryKey: queryKey,
    queryFn: () => subcategoriesService.findOneSubcategory(id!),
    enabled: enabled && !!id,
  });
};

type UpdateSubcategoryContext = {
  previousDetail?: SubCategory;
};

export const useCreateSubcategory = (): UseMutationResult<
  SubCategory,
  ApiError,
  CreateSubCategoryDto
> => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore(
    (state: SnackbarState) => state.showSnackbar,
  );

  return useMutation<SubCategory, ApiError, CreateSubCategoryDto>({
    mutationFn: subcategoriesService.createSubcategory,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: subcategoryKeys.lists() });
      showSnackbar({
        message: 'Subcategora creada con xito',
        type: 'success',
      });
    },
    onError: (error) => {
      const message = getApiErrorMessage(error);
      showSnackbar({ message, type: 'error' });
    },
  });
};

export const useUpdateSubcategory = (): UseMutationResult<
  SubCategory,
  ApiError,
  { id: string; data: UpdateSubCategoryDto },
  UpdateSubcategoryContext
> => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore(
    (state: SnackbarState) => state.showSnackbar,
  );

  return useMutation<
    SubCategory,
    ApiError,
    { id: string; data: UpdateSubCategoryDto },
    UpdateSubcategoryContext
  >({
    mutationFn: ({ id, data }) =>
      subcategoriesService.updateSubcategory(id, data),

    onMutate: async (variables) => {
      const { id, data } = variables;
      const detailQueryKey = subcategoryKeys.detail(id);

      await queryClient.cancelQueries({ queryKey: detailQueryKey });

      const previousDetail =
        queryClient.getQueryData<SubCategory>(detailQueryKey);

      if (previousDetail) {
        queryClient.setQueryData<SubCategory>(
          detailQueryKey,
          (old: SubCategory | undefined) =>
            old ? { ...old, ...data } : undefined,
        );
      }

      return { previousDetail };
    },

    onError: (error, variables, context) => {
      const message = getApiErrorMessage(error);
      showSnackbar({ message, type: 'error' });

      if (context?.previousDetail) {
        queryClient.setQueryData(
          subcategoryKeys.detail(variables.id),
          context.previousDetail,
        );
      }
    },

    onSettled: (data, error, variables) => {
      queryClient.invalidateQueries({ queryKey: subcategoryKeys.lists() });
      queryClient.invalidateQueries({
        queryKey: subcategoryKeys.detail(variables.id),
      });

      if (!error && data) {
        showSnackbar({
          message: 'Subcategora actualizada con xito',
          type: 'success',
        });
      }
    },
  });
};

export const useRemoveSubcategory = (): UseMutationResult<
  void,
  ApiError,
  string,
  { previousDetail?: SubCategory }
> => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore(
    (state: SnackbarState) => state.showSnackbar,
  );

  type DeleteSubcategoryContext = { previousDetail?: SubCategory };

  return useMutation<void, ApiError, string, DeleteSubcategoryContext>({
    mutationFn: subcategoriesService.removeSubcategory,

    onMutate: async (deletedId) => {
      const detailQueryKey = subcategoryKeys.detail(deletedId);

      await queryClient.cancelQueries({ queryKey: detailQueryKey });

      const previousDetail =
        queryClient.getQueryData<SubCategory>(detailQueryKey);

      queryClient.removeQueries({ queryKey: detailQueryKey });

      return { previousDetail };
    },

    onError: (error, deletedId, context) => {
      const message = getApiErrorMessage(error);
      showSnackbar({ message, type: 'error' });

      if (context?.previousDetail) {
        queryClient.setQueryData(
          subcategoryKeys.detail(deletedId),
          context.previousDetail,
        );
      }
    },

    onSettled: (_data, error, deletedId) => {
      queryClient.invalidateQueries({ queryKey: subcategoryKeys.lists() });

      if (!error) {
        queryClient.removeQueries({
          queryKey: subcategoryKeys.detail(deletedId),
        });
        showSnackbar({
          message: 'Subcategora eliminada con xito',
          type: 'success',
        });
      }
    },
  });
};

================
File: app/src/modules/menu/schema/subcategories.schema.ts
================
import { z } from 'zod';
import { baseListQuerySchema } from '../../../app/types/query.types';
import { type Photo } from '../../../app/schemas/domain/photo.schema';
import type { SubCategory } from '../../../app/schemas/domain/subcategory.schema';

const subCategoryBaseSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  description: z.string().nullable().optional(),
  isActive: z.boolean(),
  categoryId: z.string().min(1, 'Debe seleccionar una categora vlida'),
  photoId: z.union([z.string().uuid(), z.null(), z.undefined()]).optional(),
  sortOrder: z.number(),
});

export const createSubCategoryDtoSchema = subCategoryBaseSchema.extend({
  isActive: z.boolean().default(true),
  sortOrder: z.number().default(0),
  imageUri: z
    .union([
      z.string().url(),
      z.string().startsWith('file://'),
      z.string().startsWith('http://'),
      z.string().startsWith('https://'),
      z.null(),
    ])
    .optional(),
});
export type CreateSubCategoryDto = z.infer<typeof createSubCategoryDtoSchema>;

export const updateSubCategoryDtoSchema = subCategoryBaseSchema.partial().extend({
  imageUri: z
    .union([
      z.string().url(),
      z.string().startsWith('file://'),
      z.string().startsWith('http://'),
      z.string().startsWith('https://'),
      z.null(),
    ])
    .optional(),
});
export type UpdateSubCategoryDto = z.infer<typeof updateSubCategoryDtoSchema>;

export const findAllSubcategoriesDtoSchema = baseListQuerySchema.extend({
  categoryId: z.string().optional(),
  isActive: z.boolean().optional(),
});
export type FindAllSubcategoriesDto = z.infer<
  typeof findAllSubcategoriesDtoSchema
>;

export type SubCategoryFormInputs = CreateSubCategoryDto;
export type UpdateSubCategoryFormInputs = UpdateSubCategoryDto;

export type { Photo, SubCategory };

================
File: app/src/modules/menu/services/categoryService.ts
================
import apiClient from '../../../app/services/apiClient';
import { API_PATHS } from '../../../app/constants/apiPaths';
import type {
  Category,
  CreateCategoryDto,
  UpdateCategoryDto,
} from '../schema/category.schema';
import { PaginatedResponse } from '../../../app/types/api.types';

export const getCategories = async (params?: {
  isActive?: boolean;
  page?: number;
  limit?: number;
}): Promise<PaginatedResponse<Category>> => {
  const response = await apiClient.get<{
    items: Category[];
    total: number;
    page: number;
    limit: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  }>(API_PATHS.CATEGORIES, { params });

  return {
    data: response.data.items,
    total: response.data.total,
    page: response.data.page,
    limit: response.data.limit,
    totalPages: Math.ceil(response.data.total / response.data.limit),
  };
};

export const getCategory = async (id: string): Promise<Category> => {
  const response = await apiClient.get<Category>(
    API_PATHS.CATEGORIES_BY_ID.replace(':id', id),
  );
  return response.data;
};

export const createCategory = async (
  data: CreateCategoryDto,
): Promise<Category> => {
  const response = await apiClient.post<Category>(API_PATHS.CATEGORIES, data);
  return response.data;
};

export const updateCategory = async (
  id: string,
  data: UpdateCategoryDto,
): Promise<Category> => {
  const response = await apiClient.patch<Category>(
    API_PATHS.CATEGORIES_BY_ID.replace(':id', id),
    data,
  );
  return response.data;
};

export const deleteCategory = async (id: string): Promise<void> => {
  await apiClient.delete(API_PATHS.CATEGORIES_BY_ID.replace(':id', id));
};

export async function getOrderMenu(): Promise<Category[]> {
  const response = await apiClient.get<Category[]>(
    API_PATHS.CATEGORIES_ORDER_MENU,
  );
  return response.data;
}

const categoryService = {
  getCategories,
  getCategory,
  createCategory,
  updateCategory,
  deleteCategory,
  getOrderMenu,
};

export default categoryService;

================
File: app/src/modules/modifiers/components/ModifierGroupFormModal.tsx
================
import React, { useEffect, useMemo } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  TextInput,
  Switch,
  HelperText,
  ActivityIndicator,
} from 'react-native-paper';
import { useForm, Controller, SubmitHandler } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { useMutation, useQueryClient } from '@tanstack/react-query';

import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { getApiErrorMessage } from '@/app/lib/errorMapping';
import { modifierGroupService } from '../services/modifierGroupService';
import {
  ModifierGroup,
  ModifierGroupFormInputs,
  modifierGroupSchema,
  createModifierGroupSchema,
  CreateModifierGroupInput,
  UpdateModifierGroupInput,
} from '../schema/modifierGroup.schema';

interface Props {
  visible: boolean;
  onDismiss: () => void;
  onSaveSuccess: () => void;
  initialData?: ModifierGroup | null;
}

const QUERY_KEY_TO_INVALIDATE = ['modifierGroups'];

const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    modalSurface: {
      padding: 0,
      margin: theme.spacing.l,
      borderRadius: theme.roundness * 2,
      elevation: 4,
      backgroundColor: theme.colors.background,
      maxHeight: '90%',
      overflow: 'hidden',
    },
    modalHeader: {
      backgroundColor: theme.colors.primary,
      paddingVertical: theme.spacing.m,
      paddingHorizontal: theme.spacing.l,
    },
    modalTitle: {
      color: theme.colors.onPrimary,
      fontWeight: '700',
      textAlign: 'center',
      fontSize: 20,
    },
    formContainer: {
      maxHeight: '100%',
    },
    scrollViewContent: {
      padding: theme.spacing.l,
      paddingBottom: theme.spacing.xl,
    },
    input: {
      marginBottom: theme.spacing.m,
      backgroundColor: theme.colors.surfaceVariant,
    },
    row: {
      flexDirection: 'row',
      marginHorizontal: -theme.spacing.xs,
      marginBottom: theme.spacing.m,
    },
    column: {
      flex: 1,
      paddingHorizontal: theme.spacing.xs,
    },
    switchComponentContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      marginBottom: theme.spacing.m,
      paddingVertical: theme.spacing.s,
    },
    switchLabel: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 16,
      flexShrink: 1,
      marginRight: theme.spacing.m,
    },
    modalActions: {
      flexDirection: 'row',
      justifyContent: 'flex-end',
      paddingVertical: theme.spacing.m,
      paddingHorizontal: theme.spacing.l,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
    },
    formButton: {
      borderRadius: theme.roundness,
      paddingHorizontal: theme.spacing.m,
    },
    cancelButton: {
      marginRight: theme.spacing.m,
    },
    loadingOverlay: {
      ...StyleSheet.absoluteFillObject,
      backgroundColor: 'rgba(0, 0, 0, 0.3)',
      justifyContent: 'center',
      alignItems: 'center',
      zIndex: 10,
      borderRadius: theme.roundness * 2,
    },
    helperText: {
      marginTop: -theme.spacing.s,
      marginBottom: theme.spacing.s,
    },
    divider: {
      marginVertical: theme.spacing.m,
      backgroundColor: theme.colors.outlineVariant,
    },
    disabledRow: {
      opacity: 0.5,
    },
  });

const ModifierGroupFormModal: React.FC<Props> = ({
  visible,
  onDismiss,
  onSaveSuccess,
  initialData,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => getStyles(theme), [theme]);
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const isEditing = !!initialData;

  const {
    control,
    handleSubmit,
    reset,
    watch,
    formState: { errors, isSubmitting },
  } = useForm<ModifierGroupFormInputs>({
    resolver: zodResolver(modifierGroupSchema),
    defaultValues: {
      name: '',
      description: null,
      minSelections: 0,
      maxSelections: 2,
      isRequired: false,
      allowMultipleSelections: false,
      isActive: true,
      sortOrder: 0,
    },
  });

  const watchedAllowMultipleSelections = watch('allowMultipleSelections');

  useEffect(() => {
    if (visible) {
      if (initialData) {
        reset({
          name: initialData.name,
          description: initialData.description,
          minSelections: initialData.minSelections ?? 0,
          maxSelections: initialData.maxSelections ?? 1,
          isRequired: initialData.isRequired ?? false,
          allowMultipleSelections: initialData.allowMultipleSelections ?? false,
          isActive: initialData.isActive ?? true,
          sortOrder: initialData.sortOrder ?? 0,
        });
      } else {
        reset({
          name: '',
          description: null,
          minSelections: 0,
          maxSelections: 2,
          isRequired: false,
          allowMultipleSelections: false,
          isActive: true,
          sortOrder: 0,
        });
      }
    }
  }, [initialData, visible, reset]);

  const mutation = useMutation<
    ModifierGroup,
    Error,
    CreateModifierGroupInput | UpdateModifierGroupInput
  >({
    mutationFn: (data) => {
      if (isEditing && initialData) {
        return modifierGroupService.update(
          initialData.id,
          data as UpdateModifierGroupInput,
        );
      } else {
        const createData = createModifierGroupSchema.parse(
          data as ModifierGroupFormInputs,
        );
        return modifierGroupService.create(createData);
      }
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: QUERY_KEY_TO_INVALIDATE });
      showSnackbar({
        message: `Grupo "${data.name}" ${
          isEditing ? 'actualizado' : 'creado'
        } correctamente`,
        type: 'success',
      });
      onSaveSuccess();
    },
    onError: (error) => {
      const message = getApiErrorMessage(error);
      showSnackbar({ message, type: 'error' });
    },
  });

  const onSubmit: SubmitHandler<ModifierGroupFormInputs> = (formData) => {
    mutation.mutate(formData);
  };

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalSurface}
        dismissable={!isSubmitting}
      >
        <View style={styles.formContainer}>
          <View style={styles.modalHeader}>
            <Text variant="titleLarge" style={styles.modalTitle}>
              {isEditing
                ? 'Editar Grupo de Modificadores'
                : 'Crear Nuevo Grupo'}
            </Text>
          </View>

          <ScrollView contentContainerStyle={styles.scrollViewContent}>
            <Controller
              name="name"
              control={control}
              render={({ field: { onChange, onBlur, value } }) => (
                <TextInput
                  label="Nombre *"
                  value={value}
                  onChangeText={onChange}
                  onBlur={onBlur}
                  error={!!errors.name}
                  style={styles.input}
                  disabled={isSubmitting}
                  mode="outlined"
                />
              )}
            />
            {errors.name && (
              <HelperText
                type="error"
                visible={!!errors.name}
                style={styles.helperText}
              >
                {errors.name.message}
              </HelperText>
            )}

            <Controller
              name="description"
              control={control}
              render={({ field: { onChange, onBlur, value } }) => (
                <TextInput
                  label="Descripcin (Opcional)"
                  value={value ?? ''}
                  onChangeText={onChange}
                  onBlur={onBlur}
                  error={!!errors.description}
                  style={styles.input}
                  multiline
                  numberOfLines={3}
                  disabled={isSubmitting}
                  mode="outlined"
                />
              )}
            />
            {errors.description && (
              <HelperText
                type="error"
                visible={!!errors.description}
                style={styles.helperText}
              >
                {errors.description.message}
              </HelperText>
            )}

            <View style={styles.switchComponentContainer}>
              <Text style={styles.switchLabel}>
                Permitir Mltiples Selecciones
              </Text>
              <Controller
                name="allowMultipleSelections"
                control={control}
                render={({ field: { onChange, value } }) => (
                  <Switch
                    value={value}
                    onValueChange={onChange}
                    disabled={isSubmitting}
                  />
                )}
              />
            </View>
            {errors.allowMultipleSelections && (
              <HelperText
                type="error"
                visible={!!errors.allowMultipleSelections}
                style={styles.helperText}
              >
                {errors.allowMultipleSelections.message}
              </HelperText>
            )}

            <View
              style={[
                styles.row,
                !watchedAllowMultipleSelections && styles.disabledRow,
              ]}
            >
              <View style={styles.column}>
                <Controller
                  name="minSelections"
                  control={control}
                  render={({ field: { onChange, onBlur, value } }) => (
                    <TextInput
                      label="Mn. Selecciones"
                      value={String(value ?? 0)}
                      onChangeText={(text) => onChange(parseInt(text, 10) || 0)}
                      onBlur={onBlur}
                      error={!!errors.minSelections}
                      style={styles.input}
                      keyboardType="numeric"
                      disabled={!watchedAllowMultipleSelections || isSubmitting}
                      mode="outlined"
                    />
                  )}
                />
                {errors.minSelections && (
                  <HelperText
                    type="error"
                    visible={!!errors.minSelections}
                    style={styles.helperText}
                  >
                    {errors.minSelections.message}
                  </HelperText>
                )}
              </View>
              <View style={styles.column}>
                <Controller
                  name="maxSelections"
                  control={control}
                  render={({ field: { onChange, onBlur, value } }) => (
                    <TextInput
                      label="Mx. Selecciones *"
                      value={String(value ?? 1)}
                      onChangeText={(text) => onChange(parseInt(text, 10) || 1)}
                      onBlur={onBlur}
                      error={!!errors.maxSelections}
                      style={styles.input}
                      keyboardType="numeric"
                      disabled={!watchedAllowMultipleSelections || isSubmitting}
                      mode="outlined"
                    />
                  )}
                />
                {errors.maxSelections && (
                  <HelperText
                    type="error"
                    visible={!!errors.maxSelections}
                    style={styles.helperText}
                  >
                    {errors.maxSelections.message}
                  </HelperText>
                )}
              </View>
            </View>

            <View style={styles.switchComponentContainer}>
              <Text style={styles.switchLabel}>Es Requerido</Text>
              <Controller
                name="isRequired"
                control={control}
                render={({ field: { onChange, value } }) => (
                  <Switch
                    value={value}
                    onValueChange={onChange}
                    disabled={isSubmitting}
                  />
                )}
              />
            </View>
            {errors.isRequired && (
              <HelperText
                type="error"
                visible={!!errors.isRequired}
                style={styles.helperText}
              >
                {errors.isRequired.message}
              </HelperText>
            )}

            <Controller
              name="sortOrder"
              control={control}
              render={({ field: { onChange, onBlur, value } }) => (
                <TextInput
                  label="Orden de visualizacin"
                  value={String(value ?? 0)}
                  onChangeText={(text) => onChange(parseInt(text, 10) || 0)}
                  onBlur={onBlur}
                  error={!!errors.sortOrder}
                  style={styles.input}
                  keyboardType="numeric"
                  disabled={isSubmitting}
                  mode="outlined"
                />
              )}
            />
            {errors.sortOrder && (
              <HelperText
                type="error"
                visible={!!errors.sortOrder}
                style={styles.helperText}
              >
                {errors.sortOrder.message}
              </HelperText>
            )}

            <View style={styles.switchComponentContainer}>
              <Text style={styles.switchLabel}>Est Activo</Text>
              <Controller
                name="isActive"
                control={control}
                render={({ field: { onChange, value } }) => (
                  <Switch
                    value={value}
                    onValueChange={onChange}
                    disabled={isSubmitting}
                  />
                )}
              />
            </View>
            {errors.isActive && (
              <HelperText
                type="error"
                visible={!!errors.isActive}
                style={styles.helperText}
              >
                {errors.isActive.message}
              </HelperText>
            )}
          </ScrollView>

          {isSubmitting && (
            <View style={styles.loadingOverlay}>
              <ActivityIndicator
                animating={true}
                size="large"
                color={theme.colors.primary}
              />
            </View>
          )}

          <View style={styles.modalActions}>
            <Button
              mode="outlined"
              onPress={onDismiss}
              style={[styles.formButton, styles.cancelButton]}
              disabled={isSubmitting}
            >
              Cancelar
            </Button>
            <Button
              mode="contained"
              onPress={handleSubmit(onSubmit)}
              style={styles.formButton}
              loading={isSubmitting}
              disabled={isSubmitting}
            >
              {isEditing ? 'Actualizar' : 'Crear'}
            </Button>
          </View>
        </View>
      </Modal>
    </Portal>
  );
};

export default ModifierGroupFormModal;

================
File: app/src/modules/modifiers/screens/ModifierGroupsScreen.tsx
================
import { useMemo, useState } from 'react';
import { StyleSheet } from 'react-native';
import { Text, IconButton } from 'react-native-paper';
import { useQuery } from '@tanstack/react-query';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useNavigation } from '@react-navigation/native';
import { useDrawerStatus } from '@react-navigation/drawer';

import { modifierGroupService } from '../services/modifierGroupService';
import { ModifierGroup } from '../schema/modifierGroup.schema';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import debounce from 'lodash.debounce';
import ModifierGroupFormModal from '../components/ModifierGroupFormModal';
import GenericList, {
  RenderItemConfig,
  FilterOption,
} from '@/app/components/crud/GenericList';
import GenericDetailModal, {
  DisplayFieldConfig,
} from '@/app/components/crud/GenericDetailModal';
import { useCrudScreenLogic } from '@/app/hooks/useCrudScreenLogic';
import { PaginatedResponse } from '@/app/types/api.types';
import { useListState } from '@/app/hooks/useListState';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';

type NavigationProps = {
  navigate: (screen: string, params?: any) => void;
};

type StatusFilter = 'all' | 'active' | 'inactive';

const QUERY_KEY = ['modifierGroups'];

const ModifierGroupsScreen = () => {
  const theme = useAppTheme();
  const navigation = useNavigation<NavigationProps>();
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';

  const [statusFilter, setStatusFilter] = useState<StatusFilter>('all');
  const [searchQuery, setSearchQuery] = useState('');
  const [debouncedSearchQuery, setDebouncedSearchQuery] = useState('');

  const debouncedSetSearch = useMemo(
    () => debounce((query: string) => setDebouncedSearchQuery(query), 300),
    [setDebouncedSearchQuery],
  );

  const handleSearchChange = (query: string) => {
    setSearchQuery(query);
    debouncedSetSearch(query);
  };

  const queryParams = useMemo(() => {
    const params: Parameters<typeof modifierGroupService.findAll>[0] = {};
    if (statusFilter !== 'all') {
      params.isActive = statusFilter === 'active';
    }
    if (debouncedSearchQuery) {
      params.search = debouncedSearchQuery;
    }
    return params;
  }, [statusFilter, debouncedSearchQuery]);

  const {
    data: paginatedData,
    isLoading,
    isError,
    refetch,
    isRefetching,
  } = useQuery<PaginatedResponse<ModifierGroup>, Error>({
    queryKey: [QUERY_KEY[0], queryParams],
    queryFn: () => modifierGroupService.findAll(queryParams),
  });

  useRefreshModuleOnFocus('modifierGroups');

  const modifierGroups = paginatedData?.data || [];

  const {
    isFormModalVisible,
    isDetailModalVisible,
    editingItem,
    selectedItem,
    isDeleting,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
    deleteConfirmation,
  } = useCrudScreenLogic<ModifierGroup>({
    entityName: 'Grupo de Modificadores',
    queryKey: [QUERY_KEY[0], queryParams],
    deleteMutationFn: modifierGroupService.remove,
  });

  const handleNavigateToModifiers = (groupId: string, groupName: string) => {
    navigation.navigate('ModifiersScreen', { groupId, groupName });
  };

  const handleFormSaveSuccess = () => {
    handleCloseModals();
  };

  const handleFilterChange = (value: string | number) => {
    if (value === 'all' || value === 'active' || value === 'inactive') {
      setStatusFilter(value as StatusFilter);
    } else {
      setStatusFilter('all');
    }
  };

  const handleRefresh = () => {
    refetch();
  };

  const listRenderConfig: RenderItemConfig<ModifierGroup> = {
    titleField: 'name',
    descriptionField: 'description',
    sortOrderField: 'sortOrder',
    statusConfig: {
      field: 'isActive',
      activeValue: true,
      activeLabel: 'Activo',
      inactiveLabel: 'Inactivo',
    },
    renderDescription: (item) => {
      const parts = [];

      if (item.sortOrder !== undefined && item.sortOrder !== null) {
        parts.push(`Orden: ${item.sortOrder}`);
      }

      parts.push(`Requerido: ${item.isRequired ? 'S' : 'No'}`);
      parts.push(`Mltiples: ${item.allowMultipleSelections ? 'S' : 'No'}`);

      if (item.description) {
        parts.push(item.description);
      }

      return <Text style={styles.descriptionText}>{parts.join('  ')}</Text>;
    },
  };

  const detailFields: DisplayFieldConfig<ModifierGroup>[] = [
    { field: 'sortOrder', label: 'Orden de Visualizacin' },
    { field: 'minSelections', label: 'Mn. Selecciones' },
    { field: 'maxSelections', label: 'Mx. Selecciones' },
    {
      field: 'isRequired',
      label: 'Requerido',
      render: (value) => (
        <Text style={{ color: theme.colors.onSurface }}>
          {value ? 'S' : 'No'}
        </Text>
      ),
    },
    {
      field: 'allowMultipleSelections',
      label: 'Permite Mltiples',
      render: (value) => (
        <Text style={{ color: theme.colors.onSurface }}>
          {value ? 'S' : 'No'}
        </Text>
      ),
    },
  ];

  const styles = useMemo(() => createStyles(theme), [theme]);

  const filterOptions: FilterOption<StatusFilter>[] = [
    { value: 'all', label: 'Todos' },
    { value: 'active', label: 'Activos' },
    { value: 'inactive', label: 'Inactivos' },
  ];

  const { ListEmptyComponent } = useListState({
    isLoading: isLoading && !isRefetching,
    isError,
    data: modifierGroups,
    emptyConfig: {
      title: searchQuery
        ? 'No se encontraron grupos'
        : 'No hay grupos de modificadores',
      message: searchQuery
        ? `No se encontraron grupos para "${searchQuery}"`
        : statusFilter !== 'all'
          ? `No hay grupos de modificadores ${statusFilter === 'active' ? 'activos' : 'inactivos'}.`
          : 'No hay grupos de modificadores registrados. Presiona el botn + para crear el primero.',
      icon: 'folder-multiple-outline',
    },
    errorConfig: {
      title: 'Error al cargar grupos',
      message:
        'No se pudieron cargar los grupos de modificadores. Verifica tu conexin.',
      icon: 'alert-circle-outline',
      onAction: refetch,
    },
  });

  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      <GenericList<ModifierGroup>
        items={modifierGroups}
        renderConfig={listRenderConfig}
        onItemPress={handleOpenDetailModal}
        onRefresh={handleRefresh}
        isRefreshing={isRefetching}
        ListEmptyComponent={ListEmptyComponent}
        isLoading={isLoading}
        enableSearch={true}
        searchQuery={searchQuery}
        onSearchChange={handleSearchChange}
        searchPlaceholder="Buscar grupos..."
        filterValue={statusFilter}
        onFilterChange={handleFilterChange}
        filterOptions={filterOptions}
        showFab={true}
        onFabPress={handleOpenCreateModal}
        isModalOpen={isFormModalVisible || isDetailModalVisible}
        showImagePlaceholder={false}
        isDrawerOpen={isDrawerOpen}
        renderItemActions={(item) => (
          <IconButton
            icon="format-list-bulleted"
            size={24}
            onPress={(e) => {
              e.stopPropagation();
              handleNavigateToModifiers(item.id, item.name);
            }}
          />
        )}
      />

      <ModifierGroupFormModal
        visible={isFormModalVisible}
        onDismiss={handleCloseModals}
        onSaveSuccess={handleFormSaveSuccess}
        initialData={editingItem}
      />

      <GenericDetailModal<ModifierGroup>
        visible={isDetailModalVisible}
        onDismiss={handleCloseModals}
        item={selectedItem}
        titleField="name"
        descriptionField="description"
        statusConfig={listRenderConfig.statusConfig}
        fieldsToDisplay={detailFields}
        onEdit={() => {
          if (selectedItem) {
            handleOpenEditModal(selectedItem);
          }
        }}
        deleteConfirmation={deleteConfirmation}
        isDeleting={isDeleting}
        editButtonLabel="Editar"
        deleteButtonLabel="Eliminar"
        showImage={false}
      ></GenericDetailModal>
    </SafeAreaView>
  );
};

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    centered: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: 20,
    },
    emptyText: {
      textAlign: 'center',
      fontSize: 18,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 8,
    },
    errorText: {
      color: theme.colors.error,
      marginBottom: 10,
      textAlign: 'center',
    },
    detailActionButton: {
      marginTop: theme.spacing.m,
      alignSelf: 'stretch',
      borderRadius: theme.roundness,
    },
    descriptionText: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 12,
    },
  });

export default ModifierGroupsScreen;

================
File: app/src/modules/orders/components/order-cart/DeliveryForm.tsx
================
import React, {
  useState,
  useImperativeHandle,
  forwardRef,
  useCallback,
} from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, HelperText } from 'react-native-paper';
import AnimatedLabelSelector from '@/app/components/common/AnimatedLabelSelector';
import SpeechRecognitionInput from '@/app/components/common/SpeechRecognitionInput';
import { useAppTheme } from '@/app/styles/theme';
import { useOrderStore } from '../../stores/useOrderStore';
import { format } from 'date-fns';

interface DeliveryFormProps {
  onScheduleTimePress: () => void;
}

export interface DeliveryFormRef {
  validate: () => boolean;
}

export const DeliveryForm = forwardRef<DeliveryFormRef, DeliveryFormProps>(
  ({ onScheduleTimePress }, ref) => {
    const {
      deliveryInfo,
      orderNotes,
      scheduledTime,
      setDeliveryInfo,
      setOrderNotes,
      setScheduledTime,
    } = useOrderStore();

    const formattedScheduledTime = scheduledTime
      ? format(scheduledTime, 'h:mm a').toLowerCase()
      : '';
    const theme = useAppTheme();
    const styles = React.useMemo(() => createStyles(theme), [theme]);
    const [addressError, setAddressError] = useState<string | null>(null);
    const [recipientNameError, setRecipientNameError] = useState<string | null>(
      null,
    );
    const [recipientPhoneError, setRecipientPhoneError] = useState<
      string | null
    >(null);
    const handleScheduleTimeClear = () => {
      setScheduledTime(null);
    };
    React.useEffect(() => {
      if (deliveryInfo.fullAddress?.trim()) {
        setAddressError(null);
      }
    }, [deliveryInfo.fullAddress]);

    React.useEffect(() => {
      if (deliveryInfo.recipientName?.trim()) {
        setRecipientNameError(null);
      }
    }, [deliveryInfo.recipientName]);

    React.useEffect(() => {
      if (deliveryInfo.recipientPhone?.trim()) {
        setRecipientPhoneError(null);
      }
    }, [deliveryInfo.recipientPhone]);
    const validate = useCallback(() => {
      let isValid = true;
      if (!deliveryInfo.fullAddress?.trim()) {
        setAddressError('Por favor ingresa la direccin de entrega');
        isValid = false;
      }
      if (!deliveryInfo.recipientName?.trim()) {
        setRecipientNameError('Por favor ingresa el nombre del cliente');
        isValid = false;
      }
      if (!deliveryInfo.recipientPhone?.trim()) {
        setRecipientPhoneError('Por favor ingresa el telfono del cliente');
        isValid = false;
      }

      return isValid;
    }, [
      deliveryInfo.fullAddress,
      deliveryInfo.recipientName,
      deliveryInfo.recipientPhone,
    ]);
    useImperativeHandle(
      ref,
      () => ({
        validate,
      }),
      [validate],
    );

    return (
      <>
        <View style={[styles.section, styles.fieldContainer]}>
          <SpeechRecognitionInput
            key="address-input-delivery"
            label="Direccin de Entrega *"
            value={deliveryInfo.fullAddress || ''}
            onChangeText={(text) => {
              setDeliveryInfo({ ...deliveryInfo, fullAddress: text });
              if (addressError) setAddressError(null);
            }}
            error={!!addressError}
            speechLang="es-MX"
            multiline
            isInModal={true}
          />
          {addressError && (
            <HelperText type="error" visible={true} style={styles.helperText}>
              {addressError}
            </HelperText>
          )}
        </View>

        <View style={[styles.section, styles.fieldContainer]}>
          <SpeechRecognitionInput
            key="recipient-name-input-delivery"
            label="Nombre del Cliente *"
            value={deliveryInfo.recipientName || ''}
            onChangeText={(text) => {
              setDeliveryInfo({ ...deliveryInfo, recipientName: text });
              if (recipientNameError) setRecipientNameError(null);
            }}
            error={!!recipientNameError}
            speechLang="es-MX"
            autoCapitalize="words"
            autoCorrect={false}
          />
          {recipientNameError && (
            <HelperText type="error" visible={true} style={styles.helperText}>
              {recipientNameError}
            </HelperText>
          )}
        </View>

        <View style={[styles.section, styles.fieldContainer]}>
          <SpeechRecognitionInput
            key="phone-input-delivery"
            label="Telfono *"
            value={deliveryInfo.recipientPhone || ''}
            onChangeText={(text) => {
              setDeliveryInfo({ ...deliveryInfo, recipientPhone: text });
              if (recipientPhoneError) {
                setRecipientPhoneError(null);
              }
            }}
            keyboardType="phone-pad"
            error={!!recipientPhoneError}
            speechLang="es-MX"
            autoCorrect={false}
          />
          <View style={styles.phoneHelperContainer}>
            {recipientPhoneError ? (
              <HelperText
                type="error"
                visible={true}
                style={[styles.helperText, styles.recipientPhoneError]}
              >
                {recipientPhoneError}
              </HelperText>
            ) : (
              (deliveryInfo.recipientPhone || '').length > 0 && (
                <Text style={styles.digitCounter}>
                  {
                    (deliveryInfo.recipientPhone || '').replace(/\D/g, '')
                      .length
                  }{' '}
                  dgitos
                </Text>
              )
            )}
          </View>
        </View>

        <View style={[styles.section, styles.fieldContainer]}>
          <SpeechRecognitionInput
            key="notes-input-delivery"
            label="Notas de la Orden (Opcional)"
            value={orderNotes}
            onChangeText={setOrderNotes}
            multiline
            speechLang="es-MX"
          />
        </View>

        <View style={[styles.section, styles.fieldContainer]}>
          <AnimatedLabelSelector
            label="Programar Hora Entrega (Opcional)"
            value={formattedScheduledTime}
            onPress={onScheduleTimePress}
            onClear={handleScheduleTimeClear}
          />
        </View>
      </>
    );
  },
);

DeliveryForm.displayName = 'DeliveryForm';

const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    section: {
      paddingVertical: theme.spacing.xs,
      paddingHorizontal: theme.spacing.xs,
      marginBottom: theme.spacing.xs,
    },
    fieldContainer: {
      marginBottom: theme.spacing.xs,
    },
    helperText: {
      fontSize: 12,
      paddingHorizontal: 0,
      paddingTop: 0,
      marginTop: -4,
    },
    phoneHelperContainer: {
      marginTop: 2,
    },
    recipientPhoneError: {
      marginBottom: 0,
    },
    digitCounter: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginLeft: 14,
    },
  });

================
File: app/src/modules/orders/components/order-cart/index.ts
================
export { OrderTypeSelector } from './OrderTypeSelector';
export { DineInForm, type DineInFormRef } from './DineInForm';
export { TakeAwayForm, type TakeAwayFormRef } from './TakeAwayForm';
export { DeliveryForm, type DeliveryFormRef } from './DeliveryForm';
export { OrderItemsList } from './OrderItemsList';
export { OrderSummary } from './OrderSummary';
export { OrderAdjustments } from './OrderAdjustments';
export { PrepaymentSection } from './PrepaymentSection';
export { ModalsContainer } from './ModalsContainer';

================
File: app/src/modules/orders/components/order-cart/TakeAwayForm.tsx
================
import React, {
  useState,
  useImperativeHandle,
  forwardRef,
  useCallback,
} from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, HelperText } from 'react-native-paper';
import AnimatedLabelSelector from '@/app/components/common/AnimatedLabelSelector';
import SpeechRecognitionInput from '@/app/components/common/SpeechRecognitionInput';
import { useAppTheme } from '@/app/styles/theme';
import { useOrderStore } from '../../stores/useOrderStore';
import { format } from 'date-fns';

interface TakeAwayFormProps {
  onScheduleTimePress: () => void;
}

export interface TakeAwayFormRef {
  validate: () => boolean;
}

export const TakeAwayForm = forwardRef<TakeAwayFormRef, TakeAwayFormProps>(
  ({ onScheduleTimePress }, ref) => {
    const {
      deliveryInfo,
      orderNotes,
      scheduledTime,
      setDeliveryInfo,
      setOrderNotes,
      setScheduledTime,
    } = useOrderStore();

    const formattedScheduledTime = scheduledTime
      ? format(scheduledTime, 'h:mm a').toLowerCase()
      : '';
    const theme = useAppTheme();
    const styles = React.useMemo(() => createStyles(theme), [theme]);
    const [recipientNameError, setRecipientNameError] = useState<string | null>(
      null,
    );
    const [recipientPhoneError, setRecipientPhoneError] = useState<
      string | null
    >(null);
    const handleScheduleTimeClear = () => {
      setScheduledTime(null);
    };
    React.useEffect(() => {
      if (deliveryInfo.recipientName?.trim()) {
        setRecipientNameError(null);
      }
    }, [deliveryInfo.recipientName]);

    React.useEffect(() => {
      if (deliveryInfo.recipientPhone?.trim()) {
        setRecipientPhoneError(null);
      }
    }, [deliveryInfo.recipientPhone]);
    const validate = useCallback(() => {
      let isValid = true;
      if (!deliveryInfo.recipientName?.trim()) {
        setRecipientNameError('Por favor ingresa el nombre del cliente');
        isValid = false;
      }

      return isValid;
    }, [deliveryInfo.recipientName]);
    useImperativeHandle(
      ref,
      () => ({
        validate,
      }),
      [validate],
    );

    return (
      <>
        <View style={[styles.section, styles.fieldContainer]}>
          <SpeechRecognitionInput
            key="customer-name-input-takeaway"
            label="Nombre del Cliente *"
            value={deliveryInfo.recipientName || ''}
            onChangeText={(text) => {
              setDeliveryInfo({ ...deliveryInfo, recipientName: text });
              if (recipientNameError) setRecipientNameError(null);
            }}
            error={!!recipientNameError}
            speechLang="es-MX"
            autoCapitalize="words"
            autoCorrect={false}
          />
          {recipientNameError && (
            <HelperText type="error" visible={true} style={styles.helperText}>
              {recipientNameError}
            </HelperText>
          )}
        </View>

        <View style={[styles.section, styles.fieldContainer]}>
          <View style={styles.phoneInputWrapper}>
            <SpeechRecognitionInput
              key="phone-input-takeaway"
              label="Telfono (Opcional)"
              value={deliveryInfo.recipientPhone || ''}
              onChangeText={(text) => {
                setDeliveryInfo({ ...deliveryInfo, recipientPhone: text });
                if (recipientPhoneError) setRecipientPhoneError(null);
              }}
              keyboardType="phone-pad"
              error={!!recipientPhoneError}
              speechLang="es-MX"
              autoCorrect={false}
            />
            {(deliveryInfo.recipientPhone || '').length > 0 &&
              !recipientPhoneError && (
                <Text style={styles.digitCounterAbsolute}>
                  {
                    (deliveryInfo.recipientPhone || '').replace(/\D/g, '')
                      .length
                  }{' '}
                  dgitos
                </Text>
              )}
          </View>
          {recipientPhoneError && (
            <HelperText type="error" visible={true} style={styles.helperText}>
              {recipientPhoneError}
            </HelperText>
          )}
        </View>

        <View style={[styles.section, styles.fieldContainer]}>
          <SpeechRecognitionInput
            key="notes-input-takeaway"
            label="Notas de la Orden (Opcional)"
            value={orderNotes}
            onChangeText={setOrderNotes}
            multiline
            speechLang="es-MX"
          />
        </View>

        <View style={[styles.section, styles.fieldContainer]}>
          <AnimatedLabelSelector
            label="Programar Hora Recoleccin (Opcional)"
            value={formattedScheduledTime}
            onPress={onScheduleTimePress}
            onClear={handleScheduleTimeClear}
          />
        </View>
      </>
    );
  },
);

TakeAwayForm.displayName = 'TakeAwayForm';

const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    section: {
      paddingVertical: theme.spacing.xs,
      paddingHorizontal: theme.spacing.xs,
      marginBottom: theme.spacing.xs,
    },
    fieldContainer: {
      marginBottom: theme.spacing.xs,
    },
    helperText: {
      fontSize: 12,
      paddingHorizontal: 0,
      paddingTop: 0,
      marginTop: -4,
    },
    phoneInputWrapper: {
      position: 'relative',
    },
    digitCounterAbsolute: {
      position: 'absolute',
      right: 12,
      bottom: 20,
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
  });

================
File: app/src/modules/orders/hooks/order-creation/useAudioOrder.ts
================
import { useState, useCallback } from 'react';
import {
  audioOrderService,
  type AIOrderItem,
} from '@/services/audioOrderService';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { Product, FullMenuModifierGroup } from '../../schema/orders.schema';
import { CartItemModifier } from '../../stores/useOrderStore';

interface UseAudioOrderProps {
  menu: any;
  handleAddItem: (
    product: Product,
    quantity: number,
    selectedVariantId?: string,
    selectedModifiers?: CartItemModifier[],
    preparationNotes?: string,
    selectedPizzaCustomizations?: any[],
    pizzaExtraCost?: number,
  ) => void;
  setDeliveryInfo?: (info: any) => void;
  setOrderType?: (type: 'DELIVERY' | 'TAKE_AWAY' | 'DINE_IN') => void;
  cartButtonRef: React.RefObject<{ animate: () => void } | null>;
}

export const useAudioOrder = ({
  menu,
  handleAddItem,
  setDeliveryInfo,
  setOrderType,
  cartButtonRef,
}: UseAudioOrderProps) => {
  const [showAudioModal, setShowAudioModal] = useState(false);
  const [audioOrderData, setAudioOrderData] = useState<any>(null);
  const [isProcessingAudio, setIsProcessingAudio] = useState(false);
  const [audioError, setAudioError] = useState<string | undefined>();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const handleAudioRecordingComplete = useCallback(
    async (audioUri: string, transcription: string) => {
      setIsProcessingAudio(true);
      setShowAudioModal(true);
      setAudioError(undefined);

      try {
        const response = await audioOrderService.processAudioOrder(
          audioUri,
          transcription,
        );

        if (response.success && response.data) {
          setAudioOrderData(response.data);
        } else {
          setAudioError(response.error?.message || 'Error procesando la orden');
        }
      } catch (error) {
        setAudioError('Error al procesar la orden por voz');
      } finally {
        setIsProcessingAudio(false);
      }
    },
    [],
  );

  const handleAudioError = useCallback(
    (error: string) => {
      showSnackbar({
        message: error,
        type: 'error',
      });
    },
    [showSnackbar],
  );

  const handleConfirmAudioOrder = async (
    items: AIOrderItem[],
    deliveryInfo?: any,
    scheduledDelivery?: any,
    orderType?: 'DELIVERY' | 'TAKE_AWAY' | 'DINE_IN',
  ) => {
    try {
      if (!menu) {
        throw new Error('El men no est disponible');
      }

      let addedCount = 0;
      let failedCount = 0;

      for (const item of items) {
        let foundProduct: Product | null = null;

        outer: for (const category of menu) {
          for (const subcategory of category.subcategories || []) {
            for (const product of subcategory.products || []) {
              if (product.id === item.productId) {
                foundProduct = product;
                break outer;
              }
            }
          }
        }

        if (foundProduct) {
          const selectedModifiers: CartItemModifier[] = [];
          if (item.modifiers && item.modifiers.length > 0) {
            for (const modName of item.modifiers) {
              for (const modGroup of foundProduct.modifierGroups || []) {
                const modifier = (modGroup as FullMenuModifierGroup).productModifiers?.find(
                  (m) => m.name === modName,
                );
                if (modifier) {
                  selectedModifiers.push({
                    id: modifier.id,
                    modifierGroupId: modGroup.id,
                    name: modifier.name,
                    price: modifier.price || 0,
                  });
                  break;
                }
              }
            }
          }

          const pizzaCustomizations = item.pizzaCustomizations?.map((pc) => ({
            pizzaCustomizationId: pc.customizationId,
            half: pc.half as any,
            action: pc.action as any,
          }));

          handleAddItem(
            foundProduct,
            item.quantity,
            item.variantId,
            selectedModifiers,
            undefined,
            pizzaCustomizations,
            0,
          );

          addedCount++;
        } else {
          failedCount++;
        }
      }

      if (addedCount > 0 && failedCount === 0) {
        showSnackbar({
          message: `Se agregaron ${addedCount} producto${addedCount > 1 ? 's' : ''} al carrito`,
          type: 'success',
        });
      } else if (addedCount > 0 && failedCount > 0) {
        showSnackbar({
          message: `Se agregaron ${addedCount} producto${addedCount > 1 ? 's' : ''}, ${failedCount} no se encontraron`,
          type: 'warning',
        });
      } else {
        showSnackbar({
          message: 'No se pudieron agregar los productos al carrito',
          type: 'error',
        });
      }

      if (
        deliveryInfo &&
        Object.keys(deliveryInfo).length > 0 &&
        setDeliveryInfo
      ) {
        setDeliveryInfo(deliveryInfo);
      }

      if (orderType && setOrderType) {
        setOrderType(orderType);
      }

      setShowAudioModal(false);
      setAudioOrderData(null);

      if (addedCount > 0) {
        cartButtonRef.current?.animate();
      }
    } catch (error) {
      showSnackbar({
        message: 'Error al agregar los productos al carrito',
        type: 'error',
      });
    }
  };

  return {
    showAudioModal,
    audioOrderData,
    isProcessingAudio,
    audioError,
    handleAudioRecordingComplete,
    handleAudioError,
    handleConfirmAudioOrder,
    setShowAudioModal,
    setAudioOrderData,
    setAudioError,
  };
};

================
File: app/src/modules/orders/hooks/order-creation/useProductSelection.ts
================
import { useState, useCallback, useRef } from 'react';
import { Product } from '../../schema/orders.schema';
import { CartItem, CartItemModifier } from '../../stores/useOrderStore';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import type { SelectedPizzaCustomization } from '@/app/schemas/domain/order.schema';

interface UseProductSelectionProps {
  menu: any;
  showCart: () => void;
  hideCart: () => void;
  isCartEmpty: boolean;
  addItem: (
    product: Product,
    quantity: number,
    selectedVariantId?: string,
    selectedModifiers?: CartItemModifier[],
    preparationNotes?: string,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost?: number,
  ) => void;
  updateItem: (
    itemId: string,
    quantity: number,
    modifiers: CartItemModifier[],
    preparationNotes?: string,
    variantId?: string,
    variantName?: string,
    unitPrice?: number,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost?: number,
  ) => void;
}

export const useProductSelection = ({
  menu,
  showCart,
  hideCart,
  isCartEmpty,
  addItem: originalAddItem,
  updateItem,
}: UseProductSelectionProps) => {
  const [editingItem, setEditingItem] = useState<CartItem | null>(null);
  const [selectedProductForDescription, setSelectedProductForDescription] =
    useState<Product | null>(null);
  const [isDescriptionModalVisible, setIsDescriptionModalVisible] =
    useState(false);
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const cartButtonRef = useRef<{ animate: () => void }>(null);

  const productNeedsCustomization = useCallback((product: Product): boolean => {
    if (!product) return false;
    const hasVariants =
      product.hasVariants &&
      product.variants &&
      Array.isArray(product.variants) &&
      product.variants.length > 0;
    const hasModifiers =
      product.modifierGroups &&
      Array.isArray(product.modifierGroups) &&
      product.modifierGroups.length > 0;
    return Boolean(hasVariants || hasModifiers);
  }, []);

  const handleAddItem = useCallback(
    (
      product: Product,
      quantity: number,
      selectedVariantId?: string,
      selectedModifiers?: CartItemModifier[],
      preparationNotes?: string,
      selectedPizzaCustomizations?: SelectedPizzaCustomization[],
      pizzaExtraCost?: number,
    ) => {
      originalAddItem(
        product,
        quantity,
        selectedVariantId,
        selectedModifiers,
        preparationNotes,
        selectedPizzaCustomizations,
        pizzaExtraCost,
      );
      cartButtonRef.current?.animate();
    },
    [originalAddItem],
  );

  const handleProductSelect = useCallback(
    (
      product: Product,
      setSelectedProduct: (product: Product | null) => void,
    ) => {
      if (productNeedsCustomization(product)) {
        setSelectedProduct(product);
      } else {
        handleAddItem(product, 1);
      }
    },
    [productNeedsCustomization, handleAddItem],
  );

  const handleCloseProductModal = useCallback(
    (setSelectedProduct: (product: Product | null) => void) => {
      setSelectedProduct(null);
      setEditingItem(null);
      if (editingItem && !isCartEmpty) {
        showCart();
      }
    },
    [editingItem, isCartEmpty, showCart],
  );

  const handleEditItem = useCallback(
    (item: CartItem, setSelectedProduct: (product: Product | null) => void) => {
      if (!menu || !Array.isArray(menu)) {
        showSnackbar({
          message:
            'El men an se est cargando. Por favor, intenta nuevamente.',
          type: 'info',
        });
        return;
      }

      let product: Product | undefined;

      for (const category of menu) {
        if (category.subcategories && Array.isArray(category.subcategories)) {
          for (const subcategory of category.subcategories) {
            if (subcategory.products && Array.isArray(subcategory.products)) {
              product = subcategory.products.find(
                (p: Product) => p.id === item.productId,
              );
              if (product) break;
            }
          }
        }
        if (product) break;
      }

      if (product) {
        setEditingItem(item);
        setSelectedProduct(product);
        hideCart();
      } else {
        showSnackbar({
          message:
            'No se pudo encontrar el producto. Por favor, recarga la pantalla.',
          type: 'error',
        });
      }
    },
    [menu, showSnackbar, hideCart],
  );

  const handleShowProductDescription = useCallback((product: Product) => {
    setSelectedProductForDescription(product);
    setIsDescriptionModalVisible(true);
  }, []);

  const handleCloseDescriptionModal = useCallback(() => {
    setIsDescriptionModalVisible(false);
    setSelectedProductForDescription(null);
  }, []);

  return {
    editingItem,
    selectedProductForDescription,
    isDescriptionModalVisible,
    cartButtonRef,
    productNeedsCustomization,
    handleAddItem,
    handleProductSelect,
    handleCloseProductModal,
    handleEditItem,
    handleShowProductDescription,
    handleCloseDescriptionModal,
    updateItem,
  };
};

================
File: app/src/modules/orders/hooks/useOrdersQueries.ts
================
import { useMemo } from 'react';

import {
  useMutation,
  useQuery,
  useQueryClient,
  UseQueryResult,
} from '@tanstack/react-query';
import { orderService } from '../services/orderService';
import type { Order } from '../../../app/schemas/domain/order.schema';
import type { OrderDetailsForBackend } from '../stores/useOrderStore';
import type { FindAllOrdersDto, OrderOpenList } from '../schema/orders.schema';
import { ApiError } from '@/app/lib/errors';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { getApiErrorMessage } from '@/app/lib/errorMapping';
import type { UpdateOrderPayload } from '../schema/update-order.schema';

// Query Keys
const orderKeys = {
  all: ['orders'] as const,
  lists: () => [...orderKeys.all, 'list'] as const,
  list: (filters: FindAllOrdersDto) => [...orderKeys.lists(), filters] as const,
  openOrdersList: () => [...orderKeys.all, 'list', 'open-orders-list'] as const,
  details: () => [...orderKeys.all, 'detail'] as const,
  detail: (id: string) => [...orderKeys.details(), id] as const,
};

/**
 * Hook para crear una nueva orden.
 */
export const useCreateOrderMutation = () => {
  const queryClient = useQueryClient();

  return useMutation<Order, ApiError, OrderDetailsForBackend>({
    mutationFn: orderService.createOrder,
    onSuccess: () => {
      // Invalidar queries relevantes si es necesario (ej. lista de rdenes)
      queryClient.invalidateQueries({ queryKey: orderKeys.lists() });
      // Invalidar queries de mesas para reflejar cambios de disponibilidad
      queryClient.invalidateQueries({ queryKey: ['tables'] });
      // El mensaje de xito se maneja en el componente que llama a la mutacin
    },
    onError: (_error) => {
      // El mensaje de error se maneja en el componente que llama a la mutacin
    },
  });
};

/**
 * Hook para actualizar una orden existente.
 */
export const useUpdateOrderMutation = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  // Definir el tipo de las variables de la mutacin
  type UpdateVariables = { orderId: string; payload: UpdateOrderPayload };

  return useMutation<Order, ApiError, UpdateVariables>({
    mutationFn: ({ orderId, payload }) =>
      orderService.updateOrder(orderId, payload),
    onSuccess: (updatedOrder, variables) => {
      // Invalidar queries relevantes para refrescar datos
      queryClient.invalidateQueries({ queryKey: orderKeys.lists() });
      queryClient.invalidateQueries({ queryKey: orderKeys.openOrdersList() });
      queryClient.invalidateQueries({
        queryKey: [...orderKeys.details(), variables.orderId],
      });

      // Invalidar queries de mesas para reflejar cambios de disponibilidad
      queryClient.invalidateQueries({ queryKey: ['tables'] });

      showSnackbar({
        message: `Orden #${updatedOrder.shiftOrderNumber} actualizada`,
        type: 'success',
      });
    },
    onError: (error, variables) => {
      const message = getApiErrorMessage(error);
      showSnackbar({
        message: `Error al actualizar orden #${variables.orderId}: ${message}`,
        type: 'error',
      });
    },
  });
};

/**
 * Hook para cancelar una orden.
 */
export const useCancelOrderMutation = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<Order, ApiError, string>({
    mutationFn: (orderId) => orderService.cancelOrder(orderId),
    onSuccess: (cancelledOrder, orderId) => {
      // Invalidar queries relevantes
      queryClient.invalidateQueries({ queryKey: orderKeys.lists() });
      queryClient.invalidateQueries({ queryKey: orderKeys.openOrdersList() });
      queryClient.invalidateQueries({
        queryKey: [...orderKeys.details(), orderId],
      });
      // Invalidar queries de mesas para reflejar cambios de disponibilidad
      queryClient.invalidateQueries({ queryKey: ['tables'] });

      showSnackbar({
        message: `Orden #${cancelledOrder.shiftOrderNumber} cancelada`,
        type: 'info',
      });
    },
    onError: (error) => {
      const message = getApiErrorMessage(error);
      showSnackbar({
        message: `Error al cancelar orden: ${message}`,
        type: 'error',
      });
    },
  });
};

/**
 * Hook para completar una orden (cambiar estado a COMPLETED).
 */
export const useCompleteOrderMutation = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<Order, ApiError, string>({
    mutationFn: (orderId) =>
      orderService.updateOrder(orderId, { orderStatus: 'COMPLETED' }),
    onSuccess: (completedOrder, orderId) => {
      // Invalidar queries relevantes
      queryClient.invalidateQueries({ queryKey: orderKeys.lists() });
      queryClient.invalidateQueries({ queryKey: orderKeys.openOrdersList() });
      queryClient.invalidateQueries({
        queryKey: [...orderKeys.details(), orderId],
      });

      showSnackbar({
        message: `Orden #${completedOrder.shiftOrderNumber} finalizada exitosamente`,
        type: 'success',
      });
    },
    onError: (error) => {
      const message = getApiErrorMessage(error);
      showSnackbar({
        message: `Error al finalizar orden: ${message}`,
        type: 'error',
      });
    },
  });
};

/**
 * Hook optimizado para obtener las rdenes abiertas con campos mnimos.
 */
export const useGetOpenOrdersListQuery = (options?: {
  enabled?: boolean;
}): UseQueryResult<OrderOpenList[], ApiError> => {
  const queryKey = orderKeys.openOrdersList();

  return useQuery<OrderOpenList[], ApiError>({
    queryKey: queryKey,
    queryFn: () => orderService.getOpenOrdersList(),
    enabled: options?.enabled ?? true,
    refetchInterval: 10000, // Actualizar cada 10 segundos
    refetchIntervalInBackground: false,
    refetchOnWindowFocus: true,
    refetchOnMount: true,
    staleTime: 5000,
    gcTime: 10 * 60 * 1000,
    placeholderData: (previousData) => previousData,
  });
};

/**
 * Hook para obtener los detalles completos de una orden por su ID.
 */
export const useGetOrderByIdQuery = (
  orderId: string | null | undefined,
  options?: { enabled?: boolean },
): UseQueryResult<Order, ApiError> => {
  // Definir la clave de detalle usando el orderId
  const detailQueryKey = useMemo(
    () =>
      orderId ? [...orderKeys.details(), orderId] : [...orderKeys.details()],
    [orderId],
  );

  return useQuery<Order, ApiError>({
    queryKey: detailQueryKey,
    queryFn: async () => {
      if (!orderId) {
        // Si no hay orderId, no intentar hacer fetch y devolver un error o estado inicial
        return Promise.reject(new Error('Order ID no proporcionado'));
      }
      const order = await orderService.getOrderById(orderId);
      return order;
    },
    enabled: !!orderId && (options?.enabled ?? true), // Habilitar solo si hay orderId y est habilitado externamente
    staleTime: 0, // Los datos del detalle de la orden siempre deben estar frescos
    gcTime: 0, // No mantener en cach - siempre refetchear cuando se necesite
    refetchOnMount: 'always', // Siempre refetchear cuando el componente se monta
    refetchOnWindowFocus: true, // Refetchear cuando la ventana recupera el foco
  });
};

================
File: app/src/modules/orders/hooks/useOrderValidation.ts
================
import { useState, useCallback } from 'react';
import { OrderTypeEnum, type OrderType } from '../schema/orders.schema';
import type { DeliveryInfo } from '@/app/schemas/domain/delivery-info.schema';
import type { CartItem } from '../stores/useOrderStore';

interface ValidationErrors {
  areaError: string | null;
  tableError: string | null;
  recipientNameError: string | null;
  recipientPhoneError: string | null;
  addressError: string | null;
}

interface UseOrderValidationProps {
  orderType: OrderType;
  items: CartItem[];
  selectedAreaId: string | null;
  selectedTableId: string | null;
  isTemporaryTable: boolean;
  temporaryTableName: string;
  deliveryInfo: DeliveryInfo;
}

interface UseOrderValidationReturn extends ValidationErrors {
  setAreaError: (error: string | null) => void;
  setTableError: (error: string | null) => void;
  setRecipientNameError: (error: string | null) => void;
  setRecipientPhoneError: (error: string | null) => void;
  setAddressError: (error: string | null) => void;
  validateOrder: () => boolean;
  clearAllErrors: () => void;
}

export const useOrderValidation = ({
  orderType,
  items,
  selectedAreaId,
  selectedTableId,
  isTemporaryTable,
  temporaryTableName,
  deliveryInfo,
}: UseOrderValidationProps): UseOrderValidationReturn => {
  const [areaError, setAreaError] = useState<string | null>(null);
  const [tableError, setTableError] = useState<string | null>(null);
  const [recipientNameError, setRecipientNameError] = useState<string | null>(
    null,
  );
  const [recipientPhoneError, setRecipientPhoneError] = useState<string | null>(
    null,
  );
  const [addressError, setAddressError] = useState<string | null>(null);

  const clearAllErrors = useCallback(() => {
    setAreaError(null);
    setTableError(null);
    setRecipientNameError(null);
    setRecipientPhoneError(null);
    setAddressError(null);
  }, []);

  const validateOrder = useCallback((): boolean => {
    // Limpiar errores previos
    clearAllErrors();

    // Validar que haya items
    if (items.length === 0) {
      return false;
    }

    let isValid = true;

    // Validaciones especficas por tipo de orden
    switch (orderType) {
      case OrderTypeEnum.DINE_IN:
        // Validar rea
        if (!selectedAreaId) {
          setAreaError('Por favor selecciona un rea');
          isValid = false;
        }

        // Validar mesa o mesa temporal
        if (isTemporaryTable) {
          if (!temporaryTableName.trim()) {
            setTableError('Por favor ingresa el nombre de la mesa');
            isValid = false;
          }
        } else {
          if (!selectedTableId) {
            setTableError('Por favor selecciona una mesa');
            isValid = false;
          }
        }
        break;

      case OrderTypeEnum.TAKE_AWAY:
        // Validar nombre del cliente
        if (!deliveryInfo.recipientName?.trim()) {
          setRecipientNameError('Por favor ingresa el nombre del cliente');
          isValid = false;
        }

        // Validar telfono solo si se proporciona (es opcional)
        if (
          deliveryInfo.recipientPhone?.trim() &&
          !isValidPhoneNumber(deliveryInfo.recipientPhone)
        ) {
          setRecipientPhoneError('Por favor ingresa un telfono vlido');
          isValid = false;
        }
        break;

      case OrderTypeEnum.DELIVERY:
        // Validar telfono
        if (!deliveryInfo.recipientPhone?.trim()) {
          setRecipientPhoneError('Por favor ingresa el telfono');
          isValid = false;
        } else if (!isValidPhoneNumber(deliveryInfo.recipientPhone)) {
          setRecipientPhoneError('Por favor ingresa un telfono vlido');
          isValid = false;
        }

        // Validar direccin - usar fullAddress en lugar de address
        if (!deliveryInfo.fullAddress?.trim()) {
          setAddressError('Por favor ingresa la direccin de entrega');
          isValid = false;
        }
        break;
    }

    return isValid;
  }, [
    orderType,
    items,
    selectedAreaId,
    selectedTableId,
    isTemporaryTable,
    temporaryTableName,
    deliveryInfo,
    clearAllErrors,
  ]);

  return {
    areaError,
    tableError,
    recipientNameError,
    recipientPhoneError,
    addressError,
    setAreaError,
    setTableError,
    setRecipientNameError,
    setRecipientPhoneError,
    setAddressError,
    validateOrder,
    clearAllErrors,
  };
};

// Funcin auxiliar para validar nmeros de telfono
function isValidPhoneNumber(phone: string): boolean {
  // Eliminar espacios y caracteres especiales
  const cleanPhone = phone.replace(/[\s\-()]/g, '');

  // Validar que solo tenga nmeros y opcionalmente un + al inicio
  const phoneRegex = /^\+?\d{7,15}$/;

  return phoneRegex.test(cleanPhone);
}

================
File: app/src/modules/orders/hooks/usePrepayment.ts
================
import { useState, useCallback } from 'react';
import { prepaymentService } from '@/modules/payments/services/prepaymentService';
import { useSnackbarStore } from '@/app/store/snackbarStore';

interface UsePrepaymentProps {
  initialPrepaymentId?: string | null;
  initialPaymentAmount?: string;
  initialPaymentMethod?: 'CASH' | 'CARD' | 'TRANSFER' | null;
}

interface UsePrepaymentReturn {
  prepaymentId: string | null;
  paymentAmount: string;
  paymentMethod: 'CASH' | 'CARD' | 'TRANSFER' | null;
  showPrepaymentModal: boolean;
  showDeletePrepaymentConfirm: boolean;
  setPrepaymentId: (id: string | null) => void;
  setPaymentAmount: (amount: string) => void;
  setPaymentMethod: (method: 'CASH' | 'CARD' | 'TRANSFER' | null) => void;
  setShowPrepaymentModal: (show: boolean) => void;
  setShowDeletePrepaymentConfirm: (show: boolean) => void;
  handlePrepaymentCreated: (
    prepaymentIdCreated: string,
    amount: number,
    method: 'CASH' | 'CARD' | 'TRANSFER',
  ) => void;
  handleDeletePrepayment: () => void;
  confirmDeletePrepayment: () => Promise<void>;
  handlePrepaymentDeleted: () => void;
}

export const usePrepayment = ({
  initialPrepaymentId = null,
  initialPaymentAmount = '',
  initialPaymentMethod = 'CASH',
}: UsePrepaymentProps = {}): UsePrepaymentReturn => {
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const [prepaymentId, setPrepaymentId] = useState<string | null>(
    initialPrepaymentId,
  );
  const [paymentAmount, setPaymentAmount] = useState(initialPaymentAmount);
  const [paymentMethod, setPaymentMethod] = useState<
    'CASH' | 'CARD' | 'TRANSFER' | null
  >(initialPaymentMethod);
  const [showPrepaymentModal, setShowPrepaymentModal] = useState(false);
  const [showDeletePrepaymentConfirm, setShowDeletePrepaymentConfirm] =
    useState(false);

  const handlePrepaymentCreated = useCallback(
    (
      prepaymentIdCreated: string,
      amount: number,
      method: 'CASH' | 'CARD' | 'TRANSFER',
    ) => {
      const isUpdate = prepaymentId === prepaymentIdCreated;
      setPrepaymentId(prepaymentIdCreated);
      setPaymentAmount(amount.toFixed(2));
      setPaymentMethod(method);
      setShowPrepaymentModal(false);

      showSnackbar({
        message: isUpdate
          ? 'Pago actualizado correctamente'
          : 'Pago registrado correctamente',
        type: 'success',
      });
    },
    [prepaymentId, showSnackbar],
  );

  const handleDeletePrepayment = useCallback(() => {
    if (!prepaymentId) return;
    setShowDeletePrepaymentConfirm(true);
  }, [prepaymentId]);

  const confirmDeletePrepayment = useCallback(async () => {
    if (!prepaymentId) return;

    try {
      await prepaymentService.deletePrepayment(prepaymentId);
      setPrepaymentId(null);
      setPaymentAmount('');
      setPaymentMethod(null);

      showSnackbar({
        message: 'Prepago eliminado correctamente',
        type: 'success',
      });
    } catch (error: any) {
      let errorMessage = 'Error al eliminar el prepago';

      if (error?.response?.status === 404) {
        errorMessage = 'El prepago ya no existe o fue eliminado previamente';
        setPrepaymentId(null);
        setPaymentAmount('');
        setPaymentMethod(null);
      } else if (error?.response?.data?.message) {
        errorMessage = error.response.data.message;
      }

      showSnackbar({
        message: errorMessage,
        type: 'error',
      });
    } finally {
      setShowDeletePrepaymentConfirm(false);
    }
  }, [prepaymentId, showSnackbar]);

  const handlePrepaymentDeleted = useCallback(() => {
    setPrepaymentId(null);
    setPaymentAmount('');
    setPaymentMethod('CASH');
    setShowPrepaymentModal(false);

    showSnackbar({
      message: 'Pago eliminado correctamente',
      type: 'success',
    });
  }, [showSnackbar]);

  return {
    prepaymentId,
    paymentAmount,
    paymentMethod,
    showPrepaymentModal,
    showDeletePrepaymentConfirm,
    setPrepaymentId,
    setPaymentAmount,
    setPaymentMethod,
    setShowPrepaymentModal,
    setShowDeletePrepaymentConfirm,
    handlePrepaymentCreated,
    handleDeletePrepayment,
    confirmDeletePrepayment,
    handlePrepaymentDeleted,
  };
};

================
File: app/src/modules/orders/services/paymentService.ts
================
import apiClient from '../../../app/services/apiClient';
import { API_PATHS } from '../../../app/constants/apiPaths';
import type {
  Payment,
  CreatePaymentDto,
  UpdatePaymentDto,
  PaymentMethod,
  PaymentStatus,
} from '../schema/payment.schema';

class PaymentService {
  async createPayment(dto: CreatePaymentDto): Promise<Payment> {
    const response = await apiClient.post<Payment>(API_PATHS.PAYMENTS, dto);
    return response.data;
  }

  async getPayments(filters?: {
    orderId?: string;
    paymentMethod?: PaymentMethod;
    paymentStatus?: PaymentStatus;
  }): Promise<Payment[]> {
    const response = await apiClient.get<Payment[]>(API_PATHS.PAYMENTS, {
      params: filters,
    });
    return response.data;
  }

  async getPaymentById(id: string): Promise<Payment> {
    const response = await apiClient.get<Payment>(
      API_PATHS.PAYMENTS_BY_ID.replace(':paymentId', id),
    );
    return response.data;
  }

  async getPaymentsByOrderId(orderId: string): Promise<Payment[]> {
    const response = await apiClient.get<Payment[]>(
      API_PATHS.PAYMENTS_BY_ORDER.replace(':orderId', orderId),
    );
    return response.data;
  }

  async updatePayment(id: string, dto: UpdatePaymentDto): Promise<Payment> {
    const response = await apiClient.patch<Payment>(
      API_PATHS.PAYMENTS_BY_ID.replace(':paymentId', id),
      dto,
    );
    return response.data;
  }

  async deletePayment(id: string): Promise<void> {
    await apiClient.delete(API_PATHS.PAYMENTS_BY_ID.replace(':paymentId', id));
  }
}

export const paymentService = new PaymentService();

================
File: app/src/modules/payments/services/prepaymentService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import type { Payment } from '../../orders/schema/payment.schema';

interface CreatePrepaymentDto {
  paymentMethod: 'CASH' | 'CARD' | 'TRANSFER';
  amount: number;
}

interface UpdatePrepaymentDto {
  paymentMethod?: 'CASH' | 'CARD' | 'TRANSFER';
  amount?: number;
}

export const prepaymentService = {
  /**
   * Crear un pre-pago (pago sin orden asociada)
   */
  createPrepayment: async (data: CreatePrepaymentDto): Promise<Payment> => {
    const response = await apiClient.post<Payment>(
      API_PATHS.PAYMENTS_PREPAYMENT,
      data,
    );
    return response.data;
  },

  /**
   * Actualizar un pre-pago existente
   */
  updatePrepayment: async (
    paymentId: string,
    data: UpdatePrepaymentDto,
  ): Promise<Payment> => {
    const response = await apiClient.patch<Payment>(
      API_PATHS.PAYMENTS_BY_ID.replace(':paymentId', paymentId),
      data,
    );
    return response.data;
  },

  /**
   * Asociar un pre-pago a una orden
   */
  associateToOrder: async (
    paymentId: string,
    orderId: string,
  ): Promise<Payment> => {
    const response = await apiClient.patch<Payment>(
      API_PATHS.PAYMENTS_ASSOCIATE.replace(':paymentId', paymentId).replace(
        ':orderId',
        orderId,
      ),
    );
    return response.data;
  },

  /**
   * Eliminar un pre-pago
   */
  deletePrepayment: async (paymentId: string): Promise<void> => {
    await apiClient.delete(
      API_PATHS.PAYMENTS_BY_ID.replace(':paymentId', paymentId),
    );
  },
};

================
File: app/src/modules/pizzaCustomizations/components/AssociatePizzaToppingsModal.tsx
================
import React, { useState, useEffect, useMemo } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Portal,
  Modal,
  Text,
  Checkbox,
  Button,
  IconButton,
  Chip,
  Divider,
  ActivityIndicator,
} from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { productsService } from '@/modules/menu/services/productsService';
import { pizzaCustomizationsService } from '../services/pizzaCustomizationsService';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { CustomizationTypeEnum } from '../schema/pizzaCustomization.schema';
import type { Product } from '@/modules/menu/schema/products.schema';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';

interface AssociatePizzaToppingsModalProps {
  visible: boolean;
  onDismiss: () => void;
  product: Product | null;
}

export function AssociatePizzaToppingsModal({
  visible,
  onDismiss,
  product,
}: AssociatePizzaToppingsModalProps) {
  const theme = useAppTheme();
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const [selectedToppings, setSelectedToppings] = useState<Set<string>>(
    new Set(),
  );
  const [hasChanges, setHasChanges] = useState(false);
  const [filterType, setFilterType] = useState<
    'all' | 'flavors' | 'ingredients'
  >('all');
  const [showConfirmation, setShowConfirmation] = useState(false);

  // Query para obtener todos los toppings (sabores e ingredientes)
  const { data: allToppings, isLoading: isLoadingToppings } = useQuery({
    queryKey: ['pizza-toppings-modal'],
    queryFn: async () => {
      const response = await pizzaCustomizationsService.findAll({
        page: 1,
        limit: 100,
        isActive: true,
      });
      return response.data;
    },
    enabled: visible,
  });

  // Query para obtener los toppings asociados al producto
  const { data: associatedToppings, isLoading: isLoadingAssociated } = useQuery(
    {
      queryKey: ['product-pizza-toppings', product?.id],
      queryFn: async () => {
        if (!product?.id) return [];
        const result = await productsService.getPizzaCustomizations(product.id);
        return result || [];
      },
      enabled: !!product?.id && visible,
    },
  );

  // Inicializar selecciones cuando se cargan los datos
  useEffect(() => {
    if (associatedToppings && visible && product) {
      const associatedIds = new Set(associatedToppings.map((t) => t.id));
      setSelectedToppings(associatedIds);
      setHasChanges(false);
    }
  }, [associatedToppings, visible, product]);

  // Mutation para actualizar asociaciones
  const updateMutation = useMutation({
    mutationFn: async () => {
      if (!product) throw new Error('No hay producto seleccionado');

      await productsService.updatePizzaCustomizations(
        product.id,
        Array.from(selectedToppings),
      );
    },
    onSuccess: () => {
      showSnackbar({
        message: 'Sabores e ingredientes actualizados exitosamente',
        type: 'success',
      });
      queryClient.invalidateQueries({
        queryKey: ['product-pizza-toppings', product?.id],
      });
      queryClient.invalidateQueries({ queryKey: ['pizza-products'] });
      queryClient.invalidateQueries({ queryKey: ['pizza-configurations'] });
      setHasChanges(false);
      onDismiss();
    },
    onError: (error) => {
      showSnackbar({
        message: error instanceof Error ? error.message : 'Error al actualizar',
        type: 'error',
      });
    },
  });

  const toggleTopping = (toppingId: string) => {
    setSelectedToppings((prev) => {
      const newSet = new Set(prev);
      if (newSet.has(toppingId)) {
        newSet.delete(toppingId);
      } else {
        newSet.add(toppingId);
      }
      return newSet;
    });
    setHasChanges(true);
  };

  const toggleAll = () => {
    if (!allToppings) return;

    if (selectedToppings.size === allToppings.length) {
      setSelectedToppings(new Set());
    } else {
      setSelectedToppings(new Set(allToppings.map((t) => t.id)));
    }
    setHasChanges(true);
  };

  const filteredToppings = useMemo(() => {
    if (!allToppings || !Array.isArray(allToppings)) {
      return {
        flavors: [],
        ingredients: [],
        displayFlavors: [],
        displayIngredients: [],
      };
    }

    const flavors = allToppings.filter(
      (t) => t.type === CustomizationTypeEnum.FLAVOR,
    );
    const ingredients = allToppings.filter(
      (t) => t.type === CustomizationTypeEnum.INGREDIENT,
    );

    return {
      flavors,
      ingredients,
      displayFlavors: filterType === 'ingredients' ? [] : flavors,
      displayIngredients: filterType === 'flavors' ? [] : ingredients,
    };
  }, [allToppings, filterType]);

  const isLoading = isLoadingToppings || isLoadingAssociated;

  const styles = StyleSheet.create({
    modal: {
      backgroundColor: theme.colors.background,
      margin: theme.spacing.m,
      marginTop: theme.spacing.xl * 2,
      borderRadius: theme.roundness * 2,
      height: '90%',
      maxHeight: '90%',
    },
    header: {
      backgroundColor: theme.colors.elevation.level1,
      borderTopLeftRadius: theme.roundness * 2,
      borderTopRightRadius: theme.roundness * 2,
      paddingHorizontal: theme.spacing.m,
      paddingTop: theme.spacing.m,
      paddingBottom: theme.spacing.s,
    },
    headerContent: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
    },
    titleContainer: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    titleIcon: {
      margin: 0,
      marginRight: theme.spacing.xs,
    },
    title: {
      fontSize: 20,
      fontWeight: '700',
      color: theme.colors.onSurface,
    },
    subtitle: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
      marginTop: theme.spacing.xs,
      marginLeft: theme.spacing.xl + theme.spacing.m,
    },
    closeButton: {
      margin: 0,
    },
    filterContainer: {
      backgroundColor: theme.colors.background,
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.m,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    filterButtons: {
      flexDirection: 'row',
      gap: theme.spacing.xs,
      justifyContent: 'space-between',
    },
    filterChip: {
      flex: 1,
      backgroundColor: theme.colors.surface,
      borderColor: theme.colors.outlineVariant,
      height: 32,
    },
    filterChipActive: {
      backgroundColor: theme.colors.primaryContainer,
      borderColor: theme.colors.primary,
    },
    filterChipText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    filterChipTextActive: {
      color: theme.colors.primary,
      fontWeight: '600',
    },
    content: {
      flex: 1,
      minHeight: 200,
    },
    scrollContent: {
      padding: theme.spacing.m,
      paddingBottom: theme.spacing.xl * 2,
    },
    selectAllContainer: {
      marginBottom: theme.spacing.l,
      paddingTop: theme.spacing.s,
    },
    selectAllButton: {
      borderRadius: theme.roundness,
      marginBottom: theme.spacing.xs,
    },
    selectAllContent: {
      paddingVertical: theme.spacing.xs,
    },
    selectionCount: {
      fontSize: 13,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      textAlign: 'center',
      marginTop: theme.spacing.xs,
    },
    section: {
      marginBottom: theme.spacing.l,
    },
    sectionTitle: {
      fontSize: 14,
      fontWeight: '700',
      color: theme.colors.onSurface,
      marginBottom: theme.spacing.m,
      marginTop: theme.spacing.m,
      textTransform: 'uppercase',
      letterSpacing: 1,
    },
    toppingItem: {
      marginBottom: theme.spacing.xs,
    },
    checkbox: {
      paddingVertical: theme.spacing.s,
      paddingHorizontal: 0,
      marginHorizontal: 0,
    },
    checkboxLabel: {
      textAlign: 'left',
      marginLeft: theme.spacing.xs,
    },
    ingredientsText: {
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      marginLeft: theme.spacing.xl * 2,
      marginTop: -theme.spacing.xs,
      marginBottom: theme.spacing.s,
      fontSize: 12,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      minHeight: 200,
    },
    emptyState: {
      padding: theme.spacing.xl,
      alignItems: 'center',
    },
    emptyText: {
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
    },
    actions: {
      flexDirection: 'row',
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.m,
      gap: theme.spacing.m,
    },
    actionButton: {
      flex: 1,
      borderWidth: 1,
      borderColor: theme.colors.outline,
    },
    cancelButton: {
      borderColor: theme.colors.outlineVariant,
    },
    saveButton: {
      borderWidth: 0,
    },
    buttonContent: {
      paddingVertical: 6,
    },
  });

  if (!product) return null;

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={() => {
          if (hasChanges) {
            setShowConfirmation(true);
          } else {
            onDismiss();
          }
        }}
        contentContainerStyle={styles.modal}
        dismissable={true}
      >
        <View style={styles.header}>
          <View style={styles.headerContent}>
            <View style={styles.titleContainer}>
              <IconButton
                icon="food-variant"
                size={20}
                iconColor={theme.colors.primary}
                style={styles.titleIcon}
              />
              <Text style={styles.title}>Personalizar Producto</Text>
            </View>
            <IconButton
              icon="close"
              size={24}
              onPress={() => {
                if (hasChanges) {
                  setShowConfirmation(true);
                } else {
                  onDismiss();
                }
              }}
              style={styles.closeButton}
            />
          </View>
          <Text style={styles.subtitle}>{product.name}</Text>
        </View>

        <View style={styles.filterContainer}>
          <View style={styles.filterButtons}>
            <Chip
              mode={filterType === 'all' ? 'flat' : 'outlined'}
              onPress={() => setFilterType('all')}
              style={[
                styles.filterChip,
                filterType === 'all' && styles.filterChipActive,
              ]}
              textStyle={[
                styles.filterChipText,
                filterType === 'all' && styles.filterChipTextActive,
              ]}
              icon="format-list-bulleted"
              compact
            >
              Todos
            </Chip>
            <Chip
              mode={filterType === 'flavors' ? 'flat' : 'outlined'}
              onPress={() => setFilterType('flavors')}
              style={[
                styles.filterChip,
                filterType === 'flavors' && styles.filterChipActive,
              ]}
              textStyle={[
                styles.filterChipText,
                filterType === 'flavors' && styles.filterChipTextActive,
              ]}
              icon="pizza"
              compact
            >
              Sabores
            </Chip>
            <Chip
              mode={filterType === 'ingredients' ? 'flat' : 'outlined'}
              onPress={() => setFilterType('ingredients')}
              style={[
                styles.filterChip,
                filterType === 'ingredients' && styles.filterChipActive,
              ]}
              textStyle={[
                styles.filterChipText,
                filterType === 'ingredients' && styles.filterChipTextActive,
              ]}
              icon="food-variant"
              compact
            >
              Ingredientes
            </Chip>
          </View>
        </View>

        <View style={styles.content}>
          {isLoading ? (
            <View style={styles.loadingContainer}>
              <ActivityIndicator size="large" color={theme.colors.primary} />
            </View>
          ) : (
            <ScrollView
              contentContainerStyle={styles.scrollContent}
              showsVerticalScrollIndicator={true}
            >
              <View style={styles.selectAllContainer}>
                <Button
                  mode="contained-tonal"
                  onPress={toggleAll}
                  style={styles.selectAllButton}
                  icon={
                    selectedToppings.size === allToppings?.length
                      ? 'checkbox-marked'
                      : 'checkbox-blank-outline'
                  }
                  contentStyle={styles.selectAllContent}
                >
                  {selectedToppings.size === allToppings?.length
                    ? 'Quitar seleccin'
                    : 'Seleccionar todo'}
                </Button>
                <Text style={styles.selectionCount}>
                  {selectedToppings.size} de {allToppings?.length || 0}{' '}
                  seleccionados
                </Text>
              </View>

              {filteredToppings.displayFlavors.length > 0 && (
                <View style={styles.section}>
                  <Text style={styles.sectionTitle}>
                    Sabores ({filteredToppings.displayFlavors.length})
                  </Text>
                  {filteredToppings.displayFlavors.map((flavor) => (
                    <View key={flavor.id} style={styles.toppingItem}>
                      <Checkbox.Item
                        label={flavor.name}
                        status={
                          selectedToppings.has(flavor.id)
                            ? 'checked'
                            : 'unchecked'
                        }
                        onPress={() => toggleTopping(flavor.id)}
                        labelStyle={styles.checkboxLabel}
                        style={styles.checkbox}
                        position="leading"
                      />
                      {flavor.ingredients && (
                        <Text style={styles.ingredientsText}>
                          {flavor.ingredients}
                        </Text>
                      )}
                    </View>
                  ))}
                </View>
              )}

              {filteredToppings.displayIngredients.length > 0 && (
                <View style={styles.section}>
                  <Text style={styles.sectionTitle}>
                    Ingredientes ({filteredToppings.displayIngredients.length})
                  </Text>
                  {filteredToppings.displayIngredients.map((ingredient) => (
                    <View key={ingredient.id} style={styles.toppingItem}>
                      <Checkbox.Item
                        label={ingredient.name}
                        status={
                          selectedToppings.has(ingredient.id)
                            ? 'checked'
                            : 'unchecked'
                        }
                        onPress={() => toggleTopping(ingredient.id)}
                        labelStyle={styles.checkboxLabel}
                        style={styles.checkbox}
                        position="leading"
                      />
                    </View>
                  ))}
                </View>
              )}

              {filteredToppings.displayFlavors.length === 0 &&
                filteredToppings.displayIngredients.length === 0 && (
                  <View style={styles.emptyState}>
                    <Text style={styles.emptyText}>
                      No hay sabores ni ingredientes disponibles
                    </Text>
                  </View>
                )}
            </ScrollView>
          )}
        </View>

        <Divider />

        <View>
          <View style={styles.actions}>
            <Button
              mode="outlined"
              onPress={() => {
                if (hasChanges) {
                  setShowConfirmation(true);
                } else {
                  onDismiss();
                }
              }}
              style={[styles.actionButton, styles.cancelButton]}
              contentStyle={styles.buttonContent}
            >
              Cancelar
            </Button>
            <Button
              mode="contained"
              onPress={() => updateMutation.mutate()}
              loading={updateMutation.isPending}
              disabled={!hasChanges}
              style={[styles.actionButton, styles.saveButton]}
              contentStyle={styles.buttonContent}
            >
              Guardar
            </Button>
          </View>
        </View>
      </Modal>

      <ConfirmationModal
        visible={showConfirmation}
        title="Salir sin guardar?"
        message="Los cambios se perdern"
        confirmText="Salir"
        cancelText="Cancelar"
        confirmButtonColor={theme.colors.error}
        onConfirm={() => {
          setShowConfirmation(false);
          setHasChanges(false);
          onDismiss();
        }}
        onCancel={() => setShowConfirmation(false)}
        onDismiss={() => setShowConfirmation(false)}
      />
    </Portal>
  );
}

================
File: app/src/modules/pizzaCustomizations/components/PizzaConfigurationModal.tsx
================
import React, { useState, useEffect } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Portal,
  Modal,
  Text,
  TextInput,
  Button,
  IconButton,
  HelperText,
  Divider,
} from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { Controller, useForm } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { z } from 'zod';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { pizzaConfigurationsService } from '../services/pizzaConfigurationsService';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import type { Product } from '@/modules/menu/schema/products.schema';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';

interface PizzaConfigurationModalProps {
  visible: boolean;
  onDismiss: () => void;
  product: Product | null;
}

const configurationSchema = z.object({
  includedToppings: z.number().int().min(0),
  extraToppingCost: z.number().min(0),
});

type ConfigurationFormData = z.infer<typeof configurationSchema>;

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    modal: {
      backgroundColor: theme.colors.background,
      margin: responsive.spacing(theme.spacing.l),
      borderRadius: theme.roundness * 2,
      maxHeight: responsive.isTablet ? '85%' : '80%',
      maxWidth: responsive.isTablet ? 650 : 500,
      width: responsive.isTablet ? '85%' : '100%',
      alignSelf: 'center',
    },
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      padding: responsive.spacing(theme.spacing.m),
      paddingBottom: 0,
    },
    title: {
      fontSize: responsive.fontSize(20),
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    closeButton: {
      margin: 0,
    },
    content: {
      padding: responsive.spacing(theme.spacing.m),
    },
    productInfo: {
      backgroundColor: theme.colors.surfaceVariant,
      padding: responsive.spacing(theme.spacing.m),
      borderRadius: theme.roundness,
      marginBottom: responsive.spacing(theme.spacing.l),
    },
    productName: {
      fontWeight: '600',
      marginBottom: responsive.spacing(theme.spacing.xs),
      fontSize: responsive.fontSize(16),
    },
    section: {
      marginBottom: responsive.spacing(theme.spacing.l),
    },
    sectionTitle: {
      marginBottom: responsive.spacing(theme.spacing.m),
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: responsive.fontSize(16),
    },
    input: {
      marginBottom: responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surface,
    },
    helperText: {
      marginTop: -responsive.spacing(theme.spacing.s),
      marginBottom: responsive.spacing(theme.spacing.m),
      fontSize: responsive.fontSize(12),
    },
    infoBox: {
      backgroundColor: theme.colors.primaryContainer,
      padding: responsive.spacing(theme.spacing.m),
      borderRadius: theme.roundness,
      marginBottom: responsive.spacing(theme.spacing.m),
    },
    infoText: {
      color: theme.colors.onPrimaryContainer,
      fontSize: responsive.fontSize(12),
    },
    example: {
      marginTop: responsive.spacing(theme.spacing.m),
      padding: responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: theme.roundness,
    },
    exampleTitle: {
      fontWeight: '600',
      marginBottom: responsive.spacing(theme.spacing.xs),
      fontSize: responsive.fontSize(14),
    },
    exampleText: {
      fontSize: responsive.fontSize(12),
      color: theme.colors.onSurfaceVariant,
    },
    actions: {
      flexDirection: 'row',
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.s),
      gap: responsive.spacing(theme.spacing.m),
    },
    actionButton: {
      flex: 1,
      borderWidth: 1,
      borderColor: theme.colors.outline,
      maxWidth: responsive.isTablet ? 180 : 160,
    },
    cancelButton: {
      borderColor: theme.colors.outlineVariant,
    },
    saveButton: {
      borderWidth: 0,
    },
    buttonLabel: {
      fontSize: responsive.fontSize(14),
      fontWeight: '600',
    },
    buttonContent: {
      paddingVertical: responsive.isTablet ? 4 : 6,
    },
  });

export function PizzaConfigurationModal({
  visible,
  onDismiss,
  product,
}: PizzaConfigurationModalProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const [showConfirmation, setShowConfirmation] = useState(false);
  const [extraCostText, setExtraCostText] = useState('20.00');

  // Query para obtener la configuracin existente
  const { data: configuration, isLoading: _isLoading } = useQuery({
    queryKey: ['pizza-configuration', product?.id],
    queryFn: async () => {
      if (!product?.id) return null;
      try {
        return await pizzaConfigurationsService.findByProductId(product.id);
      } catch (error) {
        return null;
      }
    },
    enabled: !!product?.id && visible,
  });

  // Form
  const {
    control,
    handleSubmit,
    formState: { errors, isDirty },
    reset,
    setValue,
    getValues: _getValues,
  } = useForm<ConfigurationFormData>({
    resolver: zodResolver(configurationSchema),
    defaultValues: {
      includedToppings: 4,
      extraToppingCost: 20,
    },
  });

  // Cargar datos de configuracin existente
  useEffect(() => {
    if (visible && product) {
      if (
        configuration &&
        configuration.extraToppingCost !== undefined &&
        configuration.extraToppingCost !== null
      ) {
        const cost = Number(configuration.extraToppingCost);
        const toppings = Number(configuration.includedToppings) || 4;
        reset({
          includedToppings: toppings,
          extraToppingCost: cost,
        });
        setExtraCostText(cost.toFixed(2));
        // Asegurar que el valor est sincronizado
        setValue('extraToppingCost', cost, { shouldValidate: false });
      } else {
        // Reset a valores por defecto cuando se abre el modal sin configuracin
        const defaultCost = 20;
        const defaultToppings = 4;
        reset({
          includedToppings: defaultToppings,
          extraToppingCost: defaultCost,
        });
        setExtraCostText(defaultCost.toFixed(2));
        // Asegurar que el valor est sincronizado
        setValue('extraToppingCost', defaultCost, { shouldValidate: false });
      }
    }
  }, [configuration, reset, visible, product, setValue]);

  // Mutation para guardar
  const saveMutation = useMutation({
    mutationFn: async (data: ConfigurationFormData) => {
      if (!product) throw new Error('No product selected');

      if (configuration) {
        return await pizzaConfigurationsService.update(configuration.id, data);
      } else {
        return await pizzaConfigurationsService.create({
          ...data,
          productId: product.id,
        });
      }
    },
    onSuccess: () => {
      showSnackbar({
        message: 'Configuracin guardada exitosamente',
        type: 'success',
      });
      queryClient.invalidateQueries({
        queryKey: ['pizza-configuration', product?.id],
      });
      queryClient.invalidateQueries({ queryKey: ['pizza-configurations'] });
      onDismiss();
    },
    onError: (error) => {
      showSnackbar({
        message: error instanceof Error ? error.message : 'Error al guardar',
        type: 'error',
      });
    },
  });

  const onSubmit = (data: ConfigurationFormData) => {
    saveMutation.mutate(data);
  };

  if (!product) return null;

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={() => {
          if (isDirty) {
            setShowConfirmation(true);
          } else {
            onDismiss();
          }
        }}
        contentContainerStyle={styles.modal}
        dismissable={true}
      >
        <View style={styles.header}>
          <Text style={styles.title}>Configuracin de Pizza</Text>
          <IconButton
            icon="close"
            size={24}
            onPress={() => {
              if (isDirty) {
                setShowConfirmation(true);
              } else {
                onDismiss();
              }
            }}
            style={styles.closeButton}
          />
        </View>

        <Divider />

        <ScrollView style={styles.content}>
          <View style={styles.productInfo}>
            <Text variant="titleMedium" style={styles.productName}>
              {product.name}
            </Text>
            <Text variant="bodySmall">
              {product.variants?.length || 0} variantes disponibles
            </Text>
          </View>

          <View style={styles.section}>
            <View style={styles.infoBox}>
              <Text style={styles.infoText}>
                 Esta configuracin determina cuntos toppings estn incluidos
                en el precio base y cunto se cobra por cada topping adicional.
              </Text>
            </View>

            <Controller
              control={control}
              name="includedToppings"
              render={({ field: { onChange, onBlur, value } }) => (
                <TextInput
                  label="Toppings incluidos en el precio base *"
                  value={value?.toString() || ''}
                  onChangeText={(text) => {
                    // Solo permitir nmeros enteros
                    const cleanText = text.replace(/[^0-9]/g, '');
                    if (cleanText === '') {
                      onChange(0);
                    } else {
                      const num = parseInt(cleanText, 10);
                      onChange(isNaN(num) ? 0 : num);
                    }
                  }}
                  onBlur={onBlur}
                  mode="outlined"
                  style={styles.input}
                  keyboardType="number-pad"
                  error={!!errors.includedToppings}
                />
              )}
            />
            {errors.includedToppings && (
              <HelperText type="error" visible style={styles.helperText}>
                Debe ser un nmero entero mayor o igual a 0
              </HelperText>
            )}
            <HelperText type="info" visible style={styles.helperText}>
              Cantidad de toppings que el cliente puede elegir sin costo
              adicional
            </HelperText>

            <Controller
              control={control}
              name="extraToppingCost"
              render={({ field: { onChange, onBlur } }) => (
                <TextInput
                  label="Costo por topping adicional *"
                  value={extraCostText}
                  onChangeText={(text) => {
                    // Permitir nmeros y punto decimal
                    let cleanText = text.replace(/[^0-9.]/g, '');

                    // Evitar mltiples puntos decimales
                    const parts = cleanText.split('.');
                    if (parts.length > 2) {
                      cleanText = parts[0] + '.' + parts.slice(1).join('');
                    }

                    // Limitar a 2 decimales
                    if (parts.length === 2 && parts[1].length > 2) {
                      cleanText = parts[0] + '.' + parts[1].substring(0, 2);
                    }

                    // Actualizar el texto mostrado
                    setExtraCostText(cleanText);

                    // Convertir a nmero y actualizar el formulario
                    const numValue = parseFloat(cleanText);
                    if (!isNaN(numValue)) {
                      onChange(numValue);
                      setValue('extraToppingCost', numValue, {
                        shouldValidate: true,
                      });
                    } else if (cleanText === '' || cleanText === '.') {
                      onChange(0);
                      setValue('extraToppingCost', 0, { shouldValidate: true });
                    }
                  }}
                  onBlur={() => {
                    onBlur();
                    // Formatear al perder el foco
                    const numValue = parseFloat(extraCostText);
                    if (!isNaN(numValue)) {
                      setExtraCostText(numValue.toFixed(2));
                      setValue('extraToppingCost', numValue, {
                        shouldValidate: true,
                      });
                    } else {
                      setExtraCostText('0.00');
                      setValue('extraToppingCost', 0, { shouldValidate: true });
                    }
                  }}
                  mode="outlined"
                  style={styles.input}
                  keyboardType="decimal-pad"
                  error={!!errors.extraToppingCost}
                  left={<TextInput.Affix text="$" />}
                />
              )}
            />
            {errors.extraToppingCost && (
              <HelperText type="error" visible style={styles.helperText}>
                {errors.extraToppingCost.message ||
                  'Debe ser un nmero mayor o igual a 0'}
              </HelperText>
            )}
            <HelperText type="info" visible style={styles.helperText}>
              Precio que se cobra por cada topping despus de los incluidos
            </HelperText>

            <View style={styles.example}>
              <Text variant="labelLarge" style={styles.exampleTitle}>
                Ejemplo de clculo:
              </Text>
              <Text style={styles.exampleText}>
                Si configuras 4 toppings incluidos y $20 por extra:{'\n'}
                Cliente elige 4 toppings: Sin costo adicional{'\n'} Cliente
                elige 6 toppings: +$40 (2 extras  $20)
              </Text>
            </View>
          </View>
        </ScrollView>

        <Divider />

        <View style={styles.actions}>
          <Button
            mode="outlined"
            onPress={() => {
              if (isDirty) {
                setShowConfirmation(true);
              } else {
                onDismiss();
              }
            }}
            style={[styles.actionButton, styles.cancelButton]}
            contentStyle={styles.buttonContent}
            labelStyle={styles.buttonLabel}
          >
            Cancelar
          </Button>
          <Button
            mode="contained"
            onPress={handleSubmit(onSubmit)}
            loading={saveMutation.isPending}
            style={[styles.actionButton, styles.saveButton]}
            contentStyle={styles.buttonContent}
            labelStyle={styles.buttonLabel}
          >
            Guardar
          </Button>
        </View>
      </Modal>

      <ConfirmationModal
        visible={showConfirmation}
        title="Salir sin guardar?"
        message="Los cambios se perdern"
        confirmText="Salir"
        cancelText="Cancelar"
        confirmButtonColor={theme.colors.error}
        onConfirm={() => {
          setShowConfirmation(false);
          reset();
          setExtraCostText('20.00');
          onDismiss();
        }}
        onCancel={() => setShowConfirmation(false)}
        onDismiss={() => setShowConfirmation(false)}
      />
    </Portal>
  );
}

================
File: app/src/modules/pizzaCustomizations/services/pizzaCustomizationsService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import type { PaginatedResponse } from '@/app/types/api.types';
import type { PizzaCustomization } from '../schema/pizzaCustomization.schema';
import type {
  PizzaCustomizationFormInputs,
  FindAllPizzaCustomizationsQuery,
} from '../schema/pizzaCustomization.schema';

async function findAll(
  params?: FindAllPizzaCustomizationsQuery,
): Promise<PaginatedResponse<PizzaCustomization>> {
  const response = await apiClient.get<{
    items: PizzaCustomization[];
    total: number;
    page: number;
    limit: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  }>(API_PATHS.PIZZA_CUSTOMIZATIONS, { params });

  return {
    data: response.data.items,
    total: response.data.total,
    page: response.data.page,
    limit: response.data.limit,
    totalPages: Math.ceil(response.data.total / response.data.limit),
  };
}

async function findOne(id: string): Promise<PizzaCustomization> {
  const response = await apiClient.get<PizzaCustomization>(
    API_PATHS.PIZZA_CUSTOMIZATIONS_BY_ID.replace(':id', id),
  );
  return response.data;
}

async function create(
  data: PizzaCustomizationFormInputs,
): Promise<PizzaCustomization> {
  const response = await apiClient.post<PizzaCustomization>(
    API_PATHS.PIZZA_CUSTOMIZATIONS,
    data,
  );
  return response.data;
}

async function update(
  id: string,
  data: Partial<PizzaCustomizationFormInputs>,
): Promise<PizzaCustomization> {
  const response = await apiClient.patch<PizzaCustomization>(
    API_PATHS.PIZZA_CUSTOMIZATIONS_BY_ID.replace(':id', id),
    data,
  );
  return response.data;
}

async function remove(id: string): Promise<void> {
  await apiClient.delete(
    API_PATHS.PIZZA_CUSTOMIZATIONS_BY_ID.replace(':id', id),
  );
}

async function updateSortOrder(
  updates: { id: string; sortOrder: number }[],
): Promise<void> {
  await apiClient.patch(API_PATHS.PIZZA_CUSTOMIZATIONS_SORT_ORDER, { updates });
}

export const pizzaCustomizationsService = {
  findAll,
  findOne,
  create,
  update,
  remove,
  updateSortOrder,
};

================
File: app/src/modules/preparationScreens/components/PreparationScreenDetailModalSimple.tsx
================
import React, { useMemo } from 'react';
import { View, StyleSheet } from 'react-native';
import {
  Text,
  Button,
  Chip,
  ActivityIndicator,
  Divider,
} from 'react-native-paper';
import { MaterialCommunityIcons as Icon } from '@expo/vector-icons';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { PreparationScreen } from '../schema/preparationScreen.schema';
import { ResponsiveModal } from '@/app/components/responsive/ResponsiveModal';

interface PreparationScreenDetailModalProps {
  visible: boolean;
  onDismiss: () => void;
  item: PreparationScreen | null;
  onEdit?: (item: PreparationScreen) => void;
  onDelete?: (id: string) => void;
  onManageProducts?: (item: PreparationScreen) => void;
  isDeleting?: boolean;
  deleteConfirmation?: {
    visible: boolean;
    title: string;
    message: string;
    onConfirm: () => void;
    onCancel: () => void;
    show: (id: string) => void;
  };
}

const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    descriptionContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: theme.spacing.m,
      paddingBottom: theme.spacing.m,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    iconContainer: {
      width: 48,
      height: 48,
      borderRadius: 24,
      justifyContent: 'center',
      alignItems: 'center',
      marginRight: theme.spacing.m,
    },
    description: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
      flex: 1,
      marginLeft: theme.spacing.m,
    },
    statusChip: {
      marginLeft: theme.spacing.s,
    },
    section: {
      padding: theme.spacing.m,
    },
    sectionTitle: {
      fontSize: 16,
      fontWeight: '600',
      marginBottom: theme.spacing.m,
      color: theme.colors.onSurface,
    },
    infoRow: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingVertical: theme.spacing.s,
    },
    infoIcon: {
      marginRight: theme.spacing.m,
    },
    infoText: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
      flex: 1,
    },
    userChip: {
      marginRight: theme.spacing.xs,
      marginBottom: theme.spacing.xs,
    },
    userChipsContainer: {
      flexDirection: 'row',
      flexWrap: 'wrap',
      marginTop: theme.spacing.s,
    },
    productCard: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      padding: theme.spacing.m,
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: theme.roundness,
      marginTop: theme.spacing.s,
    },
    productInfo: {
      flex: 1,
    },
    productCount: {
      fontSize: 24,
      fontWeight: 'bold',
      color: theme.colors.primary,
    },
    productLabel: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    emptyState: {
      alignItems: 'center',
      paddingVertical: theme.spacing.l,
    },
    emptyText: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 14,
      marginTop: theme.spacing.s,
    },
    actionContainer: {
      // ResponsiveModal maneja padding y background
    },
    actionButtons: {
      flexDirection: 'row',
      gap: theme.spacing.m,
    },
    actionButton: {
      flex: 1,
      borderRadius: theme.roundness,
    },
    loadingContainer: {
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.xl * 2,
    },
    headerActionsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    statusChipText: {
      fontSize: 12,
    },
  });

const PreparationScreenDetailModal: React.FC<
  PreparationScreenDetailModalProps
> = ({
  visible,
  onDismiss,
  item,
  onEdit,
  onDelete,
  onManageProducts,
  isDeleting = false,
  deleteConfirmation,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => getStyles(theme), [theme]);

  // Get color based on screen name
  const getColor = () => {
    if (!item) return theme.colors.primary;
    const name = item.name.toLowerCase();
    if (name.includes('pizza')) return '#FF6B6B';
    if (name.includes('hamburguesa')) return '#4ECDC4';
    if (name.includes('bar')) return '#667EEA';
    return theme.colors.primary;
  };

  // Get icon based on screen name
  const getIcon = () => {
    if (!item) return 'monitor-dashboard';
    const name = item.name.toLowerCase();
    if (name.includes('pizza')) return 'pizza';
    if (name.includes('hamburguesa')) return 'hamburger';
    if (name.includes('bar')) return 'glass-cocktail';
    return 'monitor-dashboard';
  };

  const renderContent = () => {
    if (!item) {
      return (
        <View style={styles.loadingContainer}>
          <ActivityIndicator
            animating={true}
            size="large"
            color={theme.colors.primary}
          />
        </View>
      );
    }

    const userCount = item.users?.length || 0;
    const productCount = item.products?.length || 0;
    const color = getColor();

    return (
      <>
        {/* Informacin adicional del header */}
        {item.description && (
          <View style={styles.descriptionContainer}>
            <View
              style={[styles.iconContainer, { backgroundColor: `${color}20` }]}
            >
              <Icon name={getIcon()} size={24} color={color} />
            </View>
            <Text style={styles.description} numberOfLines={2}>
              {item.description}
            </Text>
          </View>
        )}

        {/* Seccin de usuarios */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>
            <Icon name="account-group" size={16} /> Usuarios Asignados (
            {userCount})
          </Text>

          {userCount > 0 ? (
            <View style={styles.userChipsContainer}>
              {item.users?.map((user: any) => (
                <Chip
                  key={user.id}
                  style={styles.userChip}
                  icon="account"
                  compact
                  mode="outlined"
                >
                  {`${user.firstName || ''} ${user.lastName || ''}`.trim() ||
                    user.username}
                </Chip>
              ))}
            </View>
          ) : (
            <View style={styles.emptyState}>
              <Icon
                name="account-off-outline"
                size={32}
                color={theme.colors.onSurfaceVariant}
              />
              <Text style={styles.emptyText}>Sin usuarios asignados</Text>
            </View>
          )}
        </View>

        <Divider />

        {/* Seccin de productos */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>
            <Icon name="food" size={16} /> Productos Asociados
          </Text>

          <View style={styles.productCard}>
            <View style={styles.productInfo}>
              <Text style={styles.productCount}>{productCount}</Text>
              <Text style={styles.productLabel}>
                {productCount === 1 ? 'Producto' : 'Productos'}
              </Text>
            </View>

            {onManageProducts && (
              <Button
                mode="contained-tonal"
                onPress={() => onManageProducts(item)}
                icon="link-variant"
                compact
              >
                Gestionar
              </Button>
            )}
          </View>
        </View>
      </>
    );
  };

  const headerActions = item && (
    <View style={styles.headerActionsContainer}>
      <Chip
        mode="flat"
        compact
        style={styles.statusChip}
        textStyle={styles.statusChipText}
        selected={item.isActive}
      >
        {item.isActive ? 'Activa' : 'Inactiva'}
      </Chip>
    </View>
  );

  const footerActions = item && (
    <View style={styles.actionContainer}>
      <View style={styles.actionButtons}>
        {onEdit && (
          <Button
            icon="pencil"
            mode="contained"
            onPress={() => onEdit(item)}
            disabled={isDeleting}
            style={styles.actionButton}
            buttonColor={theme.colors.primary}
          >
            Editar
          </Button>
        )}
        {onDelete && (
          <Button
            icon="delete"
            mode="contained-tonal"
            onPress={() => onDelete(item.id)}
            loading={isDeleting}
            disabled={isDeleting}
            style={styles.actionButton}
            buttonColor={theme.colors.errorContainer}
            textColor={theme.colors.error}
          >
            Eliminar
          </Button>
        )}
      </View>
    </View>
  );

  return (
    <ResponsiveModal
      visible={visible}
      onDismiss={onDismiss}
      title={item?.name}
      headerActions={headerActions}
      hideCloseButton={isDeleting}
      dismissable={!isDeleting}
      maxHeightTablet="90%"
      scrollable={true}
      footer={footerActions}
    >
      {renderContent()}
    </ResponsiveModal>
  );
};

export default PreparationScreenDetailModal;

================
File: app/src/modules/printers/services/printerService.ts
================
import apiClient from '../../../app/services/apiClient';
import { API_PATHS } from '../../../app/constants/apiPaths';
import {
  DiscoveredPrinter,
  ThermalPrinter,
  CreateThermalPrinterDto,
  UpdateThermalPrinterDto,
  FindAllThermalPrintersDto,
} from '../types/printer.types';
import { PaginatedResponse } from '../../../app/types/api.types';

const discoverPrinters = async (
  duration: number = 10000,
): Promise<DiscoveredPrinter[]> => {
  const response = await apiClient.get<DiscoveredPrinter[]>(
    API_PATHS.THERMAL_PRINTERS_DISCOVER,
    { params: { duration } },
  );
  return response.data;
};

const findAllPrinters = async (
  params: FindAllThermalPrintersDto = { page: 1, limit: 10 },
): Promise<PaginatedResponse<ThermalPrinter>> => {
  const { page = 1, limit = 10, ...filters } = params;
  const queryParams = Object.entries({ ...filters, page, limit }).reduce(
    (acc, [key, value]) => {
      if (value !== undefined) {
        if (key === 'isActive' && typeof value === 'boolean') {
          acc[key] = String(value);
        } else {
          acc[key] = value;
        }
      }
      return acc;
    },
    {} as Record<string, any>,
  );

  type FindAllPrintersApiResponse = {
    items: ThermalPrinter[];
    total: number;
    page: number;
    limit: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  };

  const response = await apiClient.get<FindAllPrintersApiResponse>(
    API_PATHS.THERMAL_PRINTERS,
    { params: queryParams },
  );

  return {
    data: response.data.items,
    total: response.data.total,
    page: response.data.page,
    limit: response.data.limit,
    totalPages: Math.ceil(response.data.total / response.data.limit),
  };
};

const findOnePrinter = async (id: string): Promise<ThermalPrinter> => {
  const response = await apiClient.get<ThermalPrinter>(
    API_PATHS.THERMAL_PRINTERS_BY_ID.replace(':id', id),
  );
  return response.data;
};

const createPrinter = async (
  data: CreateThermalPrinterDto,
): Promise<ThermalPrinter> => {
  const response = await apiClient.post<ThermalPrinter>(
    API_PATHS.THERMAL_PRINTERS,
    data,
  );
  return response.data;
};

const updatePrinter = async (
  id: string,
  data: UpdateThermalPrinterDto,
): Promise<ThermalPrinter> => {
  const response = await apiClient.patch<ThermalPrinter>(
    API_PATHS.THERMAL_PRINTERS_BY_ID.replace(':id', id),
    data,
  );
  return response.data;
};

const deletePrinter = async (id: string): Promise<void> => {
  await apiClient.delete(API_PATHS.THERMAL_PRINTERS_BY_ID.replace(':id', id));
};

const pingPrinter = async (id: string): Promise<{ status: string }> => {
  const response = await apiClient.get<{ status: string }>(
    API_PATHS.THERMAL_PRINTERS_PING.replace(':id', id),
  );
  return response.data;
};

const testPrintDiscoveredPrinter = async (
  printer: DiscoveredPrinter,
): Promise<{ success: boolean; message?: string }> => {
  const response = await apiClient.post<{
    success: boolean;
    message?: string;
  }>(API_PATHS.THERMAL_PRINTERS_TEST_PRINT, {
    ip: printer.ip,
    port: printer.port,
    connectionType: 'NETWORK',
  });
  return response.data;
};

const testPrintPrinter = async (
  id: string,
): Promise<{ success: boolean; message?: string }> => {
  const printer = await findOnePrinter(id);

  const printerInfo: any = {
    connectionType: printer.connectionType,
  };

  if (printer.connectionType === 'NETWORK') {
    printerInfo.ip = printer.ipAddress;
    printerInfo.port = printer.port;
  } else {
    printerInfo.path = printer.path;
  }

  const response = await apiClient.post<{
    success: boolean;
    message?: string;
  }>(API_PATHS.THERMAL_PRINTERS_TEST_PRINT, printerInfo);
  return response.data;
};

export const printerService = {
  discoverPrinters,
  findAllPrinters,
  findOnePrinter,
  createPrinter,
  updatePrinter,
  deletePrinter,
  pingPrinter,
  testPrintDiscoveredPrinter,
  testPrintPrinter,
};

================
File: app/src/modules/shiftAudit/components/ShiftSalesSummaryView.tsx
================
import { useState } from 'react';
import { View, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';
import {
  Text,
  IconButton,
  Divider,
  ActivityIndicator,
  DataTable,
  ProgressBar,
  Appbar,
} from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { formatCurrency } from '@/app/lib/formatters';
import { useShiftSalesSummary } from '../hooks/useShiftSalesSummary';
import type {
  CategorySalesSummary,
  SubcategorySalesSummary,
} from '../hooks/useShiftSalesSummary';

interface Props {
  shiftId: string;
  shiftNumber?: number;
  onBack: () => void;
}

export function ShiftSalesSummaryView({ shiftId, shiftNumber, onBack }: Props) {
  const theme = useAppTheme();
  const [expandedCategories, setExpandedCategories] = useState<Set<string>>(
    new Set(),
  );
  const [expandedSubcategories, setExpandedSubcategories] = useState<
    Set<string>
  >(new Set());

  const { data: summary, isLoading, error } = useShiftSalesSummary(shiftId);

  const toggleCategory = (categoryId: string) => {
    const newExpanded = new Set(expandedCategories);
    if (newExpanded.has(categoryId)) {
      newExpanded.delete(categoryId);
    } else {
      newExpanded.add(categoryId);
    }
    setExpandedCategories(newExpanded);
  };

  const toggleSubcategory = (subcategoryId: string) => {
    const newExpanded = new Set(expandedSubcategories);
    if (newExpanded.has(subcategoryId)) {
      newExpanded.delete(subcategoryId);
    } else {
      newExpanded.add(subcategoryId);
    }
    setExpandedSubcategories(newExpanded);
  };

  const renderHeader = () => (
    <Appbar.Header elevated>
      <Appbar.BackAction onPress={onBack} />
      <Appbar.Content
        title={`Resumen de Ventas - Turno #${shiftNumber || summary?.shiftNumber || 'N/A'}`}
        titleStyle={styles.headerTitle}
      />
    </Appbar.Header>
  );

  const renderSummaryCards = () => {
    if (!summary) return null;

    return (
      <View style={styles.summaryCardsContainer}>
        <View style={styles.summaryRow}>
          <View style={styles.summaryCard}>
            <Text style={styles.summaryCardLabel}>VENTAS</Text>
            <Text style={styles.summaryCardValue}>
              {formatCurrency(summary.totalSales)}
            </Text>
          </View>

          <View style={styles.summaryCard}>
            <Text style={styles.summaryCardLabel}>RDENES</Text>
            <Text style={styles.summaryCardValue}>
              {summary.completedOrders}
            </Text>
          </View>
        </View>

        <View style={styles.summaryRow}>
          <View style={styles.summaryCard}>
            <Text style={styles.summaryCardLabel}>PRODUCTOS</Text>
            <Text style={styles.summaryCardValue}>{summary.totalQuantity}</Text>
          </View>

          <View style={styles.summaryCard}>
            <Text style={styles.summaryCardLabel}>PROMEDIO</Text>
            <Text style={styles.summaryCardValue}>
              {formatCurrency(summary.averageTicket)}
            </Text>
          </View>
        </View>

        <Text style={styles.adjustmentNote}>
          * Los totales incluyen ajustes aplicados (descuentos y cargos)
        </Text>
      </View>
    );
  };

  const renderCategoryItem = (category: CategorySalesSummary) => {
    const isExpanded = expandedCategories.has(category.categoryId);

    return (
      <View key={category.categoryId}>
        <TouchableOpacity
          onPress={() => toggleCategory(category.categoryId)}
          activeOpacity={0.7}
        >
          <View style={styles.categoryItem}>
            <View style={styles.categoryHeader}>
              <View style={styles.categoryInfo}>
                <View style={styles.categoryTitleRow}>
                  <Text style={styles.categoryName}>
                    {category.categoryName}
                  </Text>
                  <Text style={styles.categoryPercentage}>
                    {category.percentage.toFixed(1)}%
                  </Text>
                </View>
                <View style={styles.categoryStatsRow}>
                  <Text style={styles.categoryQuantity}>
                    {category.quantity} productos vendidos
                  </Text>
                  <Text style={styles.categoryAmount}>
                    {formatCurrency(category.totalAmount)}
                  </Text>
                </View>
                <ProgressBar
                  progress={category.percentage / 100}
                  style={styles.progressBar}
                  color={theme.colors.primary}
                />
              </View>
              <IconButton
                icon={isExpanded ? 'chevron-up' : 'chevron-down'}
                size={24}
                iconColor={theme.colors.onSurfaceVariant}
                style={styles.expandIcon}
              />
            </View>
          </View>
        </TouchableOpacity>

        {isExpanded && category.subcategories.length > 0 && (
          <View style={styles.subcategoriesContainer}>
            {category.subcategories.map((subcategory) =>
              renderSubcategoryItem(subcategory),
            )}
          </View>
        )}
      </View>
    );
  };

  const renderSubcategoryItem = (subcategory: SubcategorySalesSummary) => {
    const isExpanded = expandedSubcategories.has(subcategory.subcategoryId);

    return (
      <View key={subcategory.subcategoryId}>
        <TouchableOpacity
          onPress={() => toggleSubcategory(subcategory.subcategoryId)}
          activeOpacity={0.7}
        >
          <View style={styles.subcategoryItem}>
            <View style={styles.subcategoryHeader}>
              <View style={styles.subcategoryInfo}>
                <Text style={styles.subcategoryName}>
                  {subcategory.subcategoryName}
                </Text>
                <Text style={styles.subcategoryStats}>
                  {subcategory.quantity} productos {' '}
                  {formatCurrency(subcategory.totalAmount)}
                </Text>
              </View>
              <IconButton
                icon={isExpanded ? 'chevron-up' : 'chevron-down'}
                size={18}
                iconColor={theme.colors.onSurfaceVariant}
              />
            </View>
          </View>
        </TouchableOpacity>

        {isExpanded && subcategory.products.length > 0 && (
          <View style={styles.productsContainer}>
            {subcategory.products.map((product) => (
              <View key={product.productId} style={styles.productItem}>
                <Text style={styles.productName}>{product.productName}</Text>
                <View style={styles.productStats}>
                  <Text style={styles.productQuantity}>
                    {product.quantity}x
                  </Text>
                  <Text style={styles.productAmount}>
                    {formatCurrency(product.totalAmount)}
                  </Text>
                </View>
              </View>
            ))}
          </View>
        )}
      </View>
    );
  };

  const renderTopProducts = () => {
    if (!summary || !summary.topProducts || summary.topProducts.length === 0) {
      return null;
    }

    return (
      <View style={styles.topProductsSection}>
        <Text style={styles.sectionTitle}>Top 10 Productos Ms Vendidos</Text>
        <View style={styles.topProductsTable}>
          <DataTable>
            <DataTable.Header>
              <DataTable.Title style={styles.rankColumn}>#</DataTable.Title>
              <DataTable.Title style={styles.productColumn}>
                Producto
              </DataTable.Title>
              <DataTable.Title numeric style={styles.quantityColumn}>
                Cant.
              </DataTable.Title>
              <DataTable.Title numeric style={styles.amountColumn}>
                Total
              </DataTable.Title>
            </DataTable.Header>

            {summary.topProducts.slice(0, 10).map((product, index) => (
              <DataTable.Row key={product.productId}>
                <DataTable.Cell style={styles.rankColumn}>
                  <Text style={styles.rankNumber}>{index + 1}</Text>
                </DataTable.Cell>
                <DataTable.Cell style={styles.productColumn}>
                  <Text style={styles.topProductName} numberOfLines={2}>
                    {product.productName}
                  </Text>
                </DataTable.Cell>
                <DataTable.Cell numeric style={styles.quantityColumn}>
                  {product.quantity}
                </DataTable.Cell>
                <DataTable.Cell numeric style={styles.amountColumn}>
                  {formatCurrency(product.totalAmount)}
                </DataTable.Cell>
              </DataTable.Row>
            ))}
          </DataTable>
        </View>
      </View>
    );
  };

  const renderContent = () => {
    if (isLoading) {
      return (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" />
          <Text style={styles.loadingText}>Cargando resumen de ventas...</Text>
        </View>
      );
    }

    if (error) {
      return (
        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>
            Error al cargar el resumen de ventas
          </Text>
        </View>
      );
    }

    if (!summary) {
      return (
        <View style={styles.emptyContainer}>
          <Text style={styles.emptyText}>No hay datos disponibles</Text>
        </View>
      );
    }

    return (
      <ScrollView
        contentContainerStyle={styles.scrollContent}
        showsVerticalScrollIndicator={false}
      >
        {renderSummaryCards()}

        <Divider style={styles.sectionDivider} />

        <View style={styles.categoriesSection}>
          <Text style={styles.sectionTitle}>Ventas por Categora</Text>
          {summary.categories.map(renderCategoryItem)}
        </View>

        <Divider style={styles.sectionDivider} />

        {renderTopProducts()}
      </ScrollView>
    );
  };

  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    scrollContent: {
      paddingBottom: theme.spacing.xl,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.xl,
    },
    loadingText: {
      marginTop: theme.spacing.m,
      color: theme.colors.onSurfaceVariant,
    },
    errorContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.xl,
    },
    errorText: {
      color: theme.colors.error,
      fontSize: 16,
    },
    emptyContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.xl,
    },
    emptyText: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 16,
    },
    summaryCardsContainer: {
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.s,
    },
    summaryRow: {
      flexDirection: 'row',
      gap: theme.spacing.s,
      marginBottom: theme.spacing.s,
    },
    summaryCard: {
      flex: 1,
      paddingVertical: theme.spacing.s,
      paddingHorizontal: theme.spacing.m,
      borderRadius: theme.roundness,
      backgroundColor: theme.colors.surfaceVariant,
      alignItems: 'center',
    },
    summaryCardLabel: {
      fontSize: 10,
      fontWeight: '600',
      color: theme.colors.onSurfaceVariant,
      letterSpacing: 0.3,
    },
    summaryCardValue: {
      fontSize: 16,
      fontWeight: '700',
      color: theme.colors.onSurface,
      marginTop: 2,
    },
    adjustmentNote: {
      fontSize: 11,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      textAlign: 'center',
      marginTop: theme.spacing.s,
      paddingHorizontal: theme.spacing.m,
    },
    sectionDivider: {
      marginVertical: theme.spacing.s,
      marginHorizontal: theme.spacing.m,
    },
    categoriesSection: {
      paddingHorizontal: theme.spacing.m,
    },
    sectionTitle: {
      fontSize: 18,
      fontWeight: '700',
      color: theme.colors.onSurface,
      marginBottom: theme.spacing.m,
    },
    categoryItem: {
      marginBottom: theme.spacing.s,
      padding: theme.spacing.m,
      borderRadius: theme.roundness * 2,
      backgroundColor: theme.colors.surface,
      elevation: 1,
    },
    categoryHeader: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    categoryInfo: {
      flex: 1,
    },
    categoryTitleRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.xs,
    },
    categoryName: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    categoryPercentage: {
      fontSize: 18,
      fontWeight: '700',
      color: theme.colors.primary,
    },
    categoryStatsRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.s,
    },
    categoryQuantity: {
      fontSize: 13,
      color: theme.colors.onSurfaceVariant,
    },
    categoryAmount: {
      fontSize: 15,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    expandIcon: {
      marginLeft: theme.spacing.xs,
    },
    progressBar: {
      height: 4,
      borderRadius: 2,
      backgroundColor: theme.colors.surfaceVariant,
    },
    subcategoriesContainer: {
      paddingLeft: theme.spacing.m,
      paddingBottom: theme.spacing.s,
    },
    subcategoryItem: {
      marginBottom: theme.spacing.xs,
      marginHorizontal: theme.spacing.xs,
      padding: theme.spacing.m,
      borderRadius: theme.roundness,
      backgroundColor: theme.colors.background,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
    },
    subcategoryHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    subcategoryInfo: {
      flex: 1,
    },
    subcategoryName: {
      fontSize: 14,
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    subcategoryStats: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginTop: 4,
    },
    productsContainer: {
      paddingLeft: theme.spacing.m,
      paddingTop: theme.spacing.xs,
    },
    productItem: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingVertical: theme.spacing.s,
      paddingHorizontal: theme.spacing.m,
      marginHorizontal: theme.spacing.s,
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness,
      marginBottom: theme.spacing.xs,
    },
    productName: {
      flex: 1,
      fontSize: 12,
      color: theme.colors.onSurface,
    },
    productStats: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.m,
    },
    productQuantity: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      fontWeight: '500',
      minWidth: 30,
      textAlign: 'right',
    },
    productAmount: {
      fontSize: 12,
      fontWeight: '600',
      color: theme.colors.primary,
      minWidth: 60,
      textAlign: 'right',
    },
    topProductsSection: {
      paddingHorizontal: theme.spacing.m,
      paddingBottom: theme.spacing.m,
    },
    topProductsTable: {
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness * 2,
      overflow: 'hidden',
    },
    rankColumn: {
      flex: 0.5,
    },
    productColumn: {
      flex: 3,
    },
    quantityColumn: {
      flex: 1,
    },
    amountColumn: {
      flex: 1.5,
    },
    rankNumber: {
      fontWeight: '700',
      color: theme.colors.primary,
    },
    topProductName: {
      fontSize: 13,
      color: theme.colors.onSurface,
    },
    headerTitle: {
      fontSize: 18,
    },
  });

  return (
    <View style={styles.container}>
      {renderHeader()}
      {renderContent()}
    </View>
  );
}

================
File: app/src/modules/shiftAudit/hooks/useShifts.ts
================
import { useQuery } from '@tanstack/react-query';
import { shiftsService } from '@/services/shifts';
import type { Shift } from '../types';

export const useShifts = (params?: {
  startDate?: string;
  endDate?: string;
}) => {
  return useQuery<Shift[], Error>({
    queryKey: ['shifts', 'history', params],
    queryFn: async () => {
      const data = await shiftsService.getHistory(params);
      return data.map((shift) => ({
        ...shift,
        status:
          shift.status === 'OPEN' ? ('open' as const) : ('closed' as const),
        openedBy: shift.openedBy || {
          id: '',
          firstName: '',
          lastName: '',
          email: '',
        },
        closedBy: shift.closedBy,
        createdAt: shift.openedAt,
        updatedAt: shift.closedAt || shift.openedAt,
      }));
    },
    staleTime: 0,
    gcTime: 0,
    refetchOnWindowFocus: false,
    refetchOnMount: true,
  });
};

export const useCurrentShift = () => {
  return useQuery<Shift | null, Error>({
    queryKey: ['shifts', 'current'],
    queryFn: async () => {
      const data = await shiftsService.getCurrentShift();
      if (!data) return null;
      return {
        ...data,
        status:
          data.status === 'OPEN' ? ('open' as const) : ('closed' as const),
        openedBy: data.openedBy || {
          id: '',
          firstName: '',
          lastName: '',
          email: '',
        },
        closedBy: data.closedBy,
        createdAt: data.openedAt,
        updatedAt: data.closedAt || data.openedAt,
      };
    },
    staleTime: 30000,
    refetchInterval: 60000,
    refetchOnWindowFocus: true,
    refetchOnMount: true,
  });
};

export const useShiftDetail = (shiftId: string | undefined) => {
  return useQuery<Shift, Error>({
    queryKey: ['shifts', shiftId],
    queryFn: async () => {
      const data = await shiftsService.getById(shiftId!);
      return {
        ...data,
        status:
          data.status === 'OPEN' ? ('open' as const) : ('closed' as const),
        openedBy: data.openedBy || {
          id: '',
          firstName: '',
          lastName: '',
          email: '',
        },
        closedBy: data.closedBy,
        createdAt: data.openedAt,
        updatedAt: data.closedAt || data.openedAt,
      };
    },
    enabled: !!shiftId,
    staleTime: 300000,
    refetchOnWindowFocus: false,
    refetchOnMount: false,
  });
};

================
File: app/src/modules/shiftAudit/hooks/useShiftSalesSummary.ts
================
import { useQuery } from '@tanstack/react-query';
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';

export interface ProductSalesSummary {
  productId: string;
  productName: string;
  quantity: number;
  totalAmount: number;
  averagePrice: number;
}

export interface SubcategorySalesSummary {
  subcategoryId: string;
  subcategoryName: string;
  quantity: number;
  totalAmount: number;
  products: ProductSalesSummary[];
}

export interface CategorySalesSummary {
  categoryId: string;
  categoryName: string;
  quantity: number;
  totalAmount: number;
  percentage: number;
  subcategories: SubcategorySalesSummary[];
}

export interface ShiftSalesSummary {
  shiftId: string;
  shiftNumber: number;
  date: string;
  totalSales: number;
  totalQuantity: number;
  completedOrders: number;
  averageTicket: number;
  categories: CategorySalesSummary[];
  topProducts: ProductSalesSummary[];
  startTime: string;
  endTime: string | null;
}

export function useShiftSalesSummary(shiftId: string | null) {
  return useQuery({
    queryKey: ['shiftSalesSummary', shiftId],
    queryFn: async () => {
      if (!shiftId) return null;

      const response = await apiClient.get<ShiftSalesSummary>(
        API_PATHS.ORDERS_BY_SHIFT_SALES_SUMMARY.replace(':shiftId', shiftId),
      );

      return response.data;
    },
    enabled: !!shiftId,
  });
}

================
File: app/src/modules/users/services/usersApi.service.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import type {
  User,
  CreateUserDto,
  UpdateUserDto,
  UsersQuery,
  UsersResponse,
} from '../schema/user.schema';

export const usersApiService = {
  async findAll(params?: UsersQuery): Promise<UsersResponse> {
    const queryParams: Record<string, any> = {};

    if (params?.page) queryParams.page = params.page.toString();
    if (params?.limit) queryParams.limit = params.limit.toString();
    if (params?.search) queryParams.search = params.search;
    if (params?.sortBy) queryParams.sortBy = params.sortBy;
    if (params?.sortOrder) queryParams.sortOrder = params.sortOrder;

    if (params?.filters) {
      if (params.filters.isActive !== undefined) {
        queryParams['filters[isActive]'] = params.filters.isActive.toString();
      }
      if (params.filters.roles && params.filters.roles.length > 0) {
        queryParams['filters[roles]'] = JSON.stringify(params.filters.roles);
      }
    }

    const response = await apiClient.get(API_PATHS.USERS, {
      params: queryParams,
    });

    return response.data;
  },

  async findOne(id: string): Promise<User> {
    const response = await apiClient.get(
      API_PATHS.USERS_BY_ID.replace(':id', id),
    );
    return response.data;
  },

  async create(data: CreateUserDto): Promise<User> {
    const response = await apiClient.post(API_PATHS.USERS, data);
    return response.data;
  },

  async update(id: string, data: UpdateUserDto): Promise<User> {
    const response = await apiClient.patch(
      API_PATHS.USERS_BY_ID.replace(':id', id),
      data,
    );
    return response.data;
  },

  async remove(id: string): Promise<void> {
    await apiClient.delete(API_PATHS.USERS_BY_ID.replace(':id', id));
  },

  async resetPassword(id: string, newPassword: string): Promise<User> {
    const response = await apiClient.patch(
      API_PATHS.USERS_BY_ID.replace(':id', id),
      {
        password: newPassword,
      },
    );
    return response.data;
  },

  async toggleActive(id: string, isActive: boolean): Promise<User> {
    const response = await apiClient.patch(
      API_PATHS.USERS_BY_ID.replace(':id', id),
      {
        isActive,
      },
    );
    return response.data;
  },
};

================
File: app/src/services/serverConnectionService.ts
================
import { discoveryService } from '../app/services/discoveryService';
import { healthMonitoringService } from './healthMonitoringService';
import { autoReconnectService } from './autoReconnectService';
import EncryptedStorage from '../app/services/secureStorageService';
import NetInfo from '@react-native-community/netinfo';

export type ConnectionMode = 'auto' | 'manual' | 'remote';

interface ConnectionState {
  isConnected: boolean;
  isConnecting: boolean;
  lastError: string | null;
  mode: ConnectionMode;
  currentUrl: string | null;
  hasWifi: boolean;
  isHealthy: boolean;
  isSearching: boolean;
  error: string | null;
}

class ServerConnectionService {
  private state: ConnectionState = {
    isConnected: false,
    isConnecting: false,
    lastError: null,
    mode: 'auto',
    currentUrl: null,
    hasWifi: false,
    isHealthy: false,
    isSearching: false,
    error: null,
  };

  private listeners: Array<(state: ConnectionState) => void> = [];
  private connectionPromise: Promise<void> | null = null;
  private healthUnsubscribe: (() => void) | null = null;
  private reconnectUnsubscribe: (() => void) | null = null;
  private netInfoUnsubscribe: (() => void) | null = null;

  constructor() {
    this.loadConnectionMode();
    this.initializeListeners();

    setTimeout(() => {
      if (!this.state.isConnected && !this.state.isConnecting) {
        this.connect().catch(() => {});
      }
    }, 1000);
  }

  private async loadConnectionMode() {
    try {
      const savedMode = (await EncryptedStorage.getItem(
        'connection_mode',
      )) as ConnectionMode;
      if (savedMode) {
        this.state.mode = savedMode;
      }
    } catch (error) {}
  }

  private initializeListeners() {
    this.netInfoUnsubscribe = NetInfo.addEventListener((state) => {
      const hasWifi =
        !!state.isConnected &&
        (state.type === 'wifi' || state.type === 'ethernet');

      const previousHasWifi = this.state.hasWifi;

      if (!hasWifi && previousHasWifi) {
        this.updateState({
          hasWifi: false,
          isConnected: false,
          isHealthy: false,
          error: 'Sin conexin WiFi',
        });
        healthMonitoringService.stopMonitoring();
      } else if (hasWifi && !previousHasWifi) {
        this.updateState({ hasWifi });
        setTimeout(() => {
          if (!this.state.isConnected && !this.state.isConnecting) {
            this.connect().catch(() => {});
          }
        }, 1000);
      } else {
        this.updateState({ hasWifi });
      }
    });

    this.healthUnsubscribe = healthMonitoringService.subscribe(
      (healthState: any) => {
        const previousHealthy = this.state.isHealthy;
        this.updateState({
          isHealthy: healthState.isAvailable,
          error: healthState.message || this.state.error,
        });

        if (!previousHealthy && healthState.isAvailable && this.state.hasWifi) {
          this.updateState({
            isConnected: true,
            isHealthy: true,
            error: null,
            isSearching: false,
          });
        }
      },
    );

    this.reconnectUnsubscribe = autoReconnectService.subscribe(
      (reconnectState: any) => {
        this.updateState({
          isSearching: reconnectState.isReconnecting,
          error: reconnectState.lastError || this.state.error,
        });
      },
    );

    autoReconnectService.on('reconnected', async () => {
      const apiUrl = await discoveryService.getApiUrl();

      const { reinitializeApiClient } = await import(
        '../app/services/apiClient'
      );
      await reinitializeApiClient(apiUrl || undefined);

      this.updateState({
        isConnected: true,
        isConnecting: false,
        currentUrl: apiUrl,
        isHealthy: true,
        error: null,
        lastError: null,
        isSearching: false,
      });
      healthMonitoringService.startMonitoring();
    });

    healthMonitoringService.on('recovered', async () => {
      const apiUrl = await discoveryService.getApiUrl();

      const { reinitializeApiClient } = await import(
        '../app/services/apiClient'
      );
      await reinitializeApiClient(apiUrl || undefined);

      this.updateState({
        isConnected: true,
        isConnecting: false,
        currentUrl: apiUrl,
        isHealthy: true,
        error: null,
        lastError: null,
        isSearching: false,
      });

      if (!healthMonitoringService.isMonitoring()) {
        healthMonitoringService.startMonitoring();
      }
    });

    NetInfo.fetch().then((state) => {
      const hasWifi =
        !!state.isConnected &&
        (state.type === 'wifi' || state.type === 'ethernet');
      this.updateState({ hasWifi });

      if (hasWifi && !this.state.isConnected && !this.state.isConnecting) {
        setTimeout(() => {
          this.connect().catch(() => {});
        }, 1000);
      }
    });
  }

  async setConnectionMode(mode: ConnectionMode) {
    this.state.mode = mode;

    if (mode === 'manual') {
      const url = await discoveryService.getApiUrl();
      if (url) {
        this.updateState({ currentUrl: url });
      }
    }

    this.notifyListeners();
  }

  getConnectionMode(): ConnectionMode {
    return this.state.mode;
  }

  async connect(): Promise<void> {
    if (this.connectionPromise) {
      return this.connectionPromise;
    }

    this.connectionPromise = this.performConnection();

    try {
      await this.connectionPromise;
    } finally {
      this.connectionPromise = null;
    }
  }

  private async performConnection(): Promise<void> {
    this.updateState({ isConnecting: true, lastError: null });

    try {
      let apiUrl: string | null = null;

      switch (this.state.mode) {
        case 'auto':
          apiUrl = await discoveryService.getLastKnownUrl();
          if (apiUrl) {
            const isHealthy =
              await healthMonitoringService.checkHealthWithUrl(apiUrl);
            if (!isHealthy) {
              apiUrl = await discoveryService.discoverServer();
            }
          } else {
            apiUrl = await discoveryService.discoverServer();
          }
          break;

        case 'manual':
          apiUrl = await discoveryService.getApiUrl();
          if (!apiUrl) {
            throw new Error('No se ha configurado una URL manual');
          }
          break;

        case 'remote':
          apiUrl = await discoveryService.getApiUrl();
          if (!apiUrl) {
            throw new Error('No se ha configurado una URL remota');
          }
          break;
      }

      if (!apiUrl) {
        throw new Error('No se pudo establecer conexin con el servidor');
      }

      if (this.state.mode === 'auto') {
        await discoveryService.setServerUrl(apiUrl, false);
      }

      const isHealthy =
        await healthMonitoringService.checkHealthWithUrl(apiUrl);
      if (!isHealthy) {
        throw new Error('El servidor no est respondiendo correctamente');
      }

      healthMonitoringService.startMonitoring();

      const { reinitializeApiClient } = await import(
        '../app/services/apiClient'
      );
      await reinitializeApiClient(apiUrl || undefined);

      this.updateState({
        isConnected: true,
        isConnecting: false,
        currentUrl: apiUrl,
        isHealthy: true,
        error: null,
      });
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : 'Error desconocido';
      this.updateState({
        isConnected: false,
        isConnecting: false,
        lastError: errorMessage,
        error: errorMessage,
        isHealthy: false,
      });
      throw error;
    }
  }

  async reconnect(): Promise<void> {
    return this.connect();
  }

  retry(): void {
    if (!this.state.isConnected && this.state.hasWifi) {
      autoReconnectService.startAutoReconnect();
    } else if (!this.state.hasWifi) {
      this.updateState({
        error: 'Sin conexin WiFi',
        lastError: 'Sin conexin WiFi',
      });
    }
  }

  async disconnect(): Promise<void> {
    healthMonitoringService.stopMonitoring();
    autoReconnectService.stopAutoReconnect();
    this.updateState({
      isConnected: false,
      isConnecting: false,
      currentUrl: null,
      isHealthy: false,
    });
  }

  destroy() {
    if (this.healthUnsubscribe) {
      this.healthUnsubscribe();
    }
    if (this.reconnectUnsubscribe) {
      this.reconnectUnsubscribe();
    }
    if (this.netInfoUnsubscribe) {
      this.netInfoUnsubscribe();
    }
    autoReconnectService.off('reconnected');
    healthMonitoringService.off('recovered');
  }

  subscribe(listener: (state: ConnectionState) => void): () => void {
    this.listeners.push(listener);
    listener(this.state);

    return () => {
      this.listeners = this.listeners.filter((l) => l !== listener);
    };
  }

  getState(): ConnectionState {
    return { ...this.state };
  }

  isConnected(): boolean {
    return this.state.isConnected;
  }

  getCurrentUrl(): string | null {
    return this.state.currentUrl;
  }

  private updateState(updates: Partial<ConnectionState>): void {
    this.state = { ...this.state, ...updates };
    this.notifyListeners();
  }

  private notifyListeners(): void {
    this.listeners.forEach((listener) => listener(this.state));
  }
}

export const serverConnectionService = new ServerConnectionService();

================
File: app/src/app/components/common/AnimatedLabelInput.tsx
================
import { useState, useRef, useEffect, forwardRef, useMemo } from 'react';
import {
  View,
  TextInput,
  Animated,
  StyleSheet,
  TextInputProps,
  StyleProp,
  ViewStyle,
  TextStyle,
  TouchableWithoutFeedback,
  Easing,
} from 'react-native';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';

interface AnimatedLabelInputProps extends TextInputProps {
  label: string;
  containerStyle?: StyleProp<ViewStyle>;
  inputStyle?: StyleProp<TextStyle>;
  labelStyle?: StyleProp<TextStyle>;
  activeLabelColor?: string;
  inactiveLabelColor?: string;
  borderColor?: string;
  activeBorderColor?: string;
  error?: boolean;
  errorColor?: string;
  disabled?: boolean;
}

const AnimatedLabelInput = forwardRef<TextInput, AnimatedLabelInputProps>(
  (
    {
      label,
      value,
      onChangeText,
      onFocus,
      onBlur,
      style,
      containerStyle,
      inputStyle,
      labelStyle,
      activeLabelColor,
      inactiveLabelColor,
      borderColor: defaultBorderColor,
      activeBorderColor: focusedBorderColor,
      error = false,
      errorColor: customErrorColor,
      multiline,
      disabled = false, // Aadir disabled a las props destructuradas
      ...rest
    },
    ref,
  ) => {
    const theme = useAppTheme();
    const responsive = useResponsive();
    const [isFocused, setIsFocused] = useState(false);
    const animation = useRef(new Animated.Value(value ? 1 : 0)).current;

    const isActive = isFocused || (value != null && value !== '');

    const finalActiveLabelColor = activeLabelColor || theme.colors.primary;
    const finalInactiveLabelColor =
      inactiveLabelColor || theme.colors.onSurfaceVariant;
    const finalBorderColor = defaultBorderColor || theme.colors.outline;
    const finalActiveBorderColor = focusedBorderColor || theme.colors.primary;
    const finalErrorColor = customErrorColor || theme.colors.error;

    useEffect(() => {
      Animated.timing(animation, {
        toValue: isActive ? 1 : 0,
        duration: 150,
        useNativeDriver: false,
        easing: Easing.bezier(0.4, 0.0, 0.2, 1), // Material Design easing
      }).start();
    }, [isActive, animation]);

    const handleFocus = (e: any) => {
      setIsFocused(true);
      onFocus?.(e);
    };

    const handleBlur = (e: any) => {
      setIsFocused(false);
      onBlur?.(e);
    };

    // Usar ref externa o crear una nueva
    const inputRef = useRef<TextInput>(null);
    const finalRef = ref || inputRef;

    const labelScale = animation.interpolate({
      inputRange: [0, 1],
      outputRange: [1, 0.8], // Escala ms sutil
    });

    const labelColor = animation.interpolate({
      inputRange: [0, 1],
      outputRange: [finalInactiveLabelColor, finalActiveLabelColor],
    });

    const currentBorderColor = error
      ? finalErrorColor
      : isFocused
        ? finalActiveBorderColor
        : finalBorderColor;

    const styles = useMemo(
      () =>
        createStyles(theme, responsive, {
          multiline,
          disabled,
          finalInactiveLabelColor,
        }),
      [theme, responsive, multiline, disabled, finalInactiveLabelColor],
    );

    const animatedTranslateY = animation.interpolate({
      inputRange: [0, 1],
      outputRange: [0, -28],
    });

    const animatedTranslateX = animation.interpolate({
      inputRange: [0, 1],
      outputRange: [0, -4],
    });

    const animatedLabelStyle = {
      position: 'absolute' as const,
      top: 20,
      left: 12,
      zIndex: 10, // Aumentar z-index para mejor visibilidad
      transform: [
        { translateX: animatedTranslateX },
        { translateY: animatedTranslateY },
        { scale: labelScale },
      ],
      color: labelColor,
      backgroundColor: theme.colors.background,
      maxWidth: isActive ? ('85%' as `${number}%`) : ('90%' as `${number}%`),
    };

    // Estilos estticos que no deben ser animados
    const staticLabelStyle = {
      paddingHorizontal: isActive ? 4 : 0,
      paddingVertical: isActive ? 1 : 0,
    };

    const handleContainerPress = () => {
      if (
        !disabled &&
        finalRef &&
        typeof finalRef !== 'function' &&
        finalRef.current
      ) {
        finalRef.current.focus();
      }
    };

    return (
      <TouchableWithoutFeedback
        onPress={handleContainerPress}
        disabled={disabled}
      >
        <View
          style={[
            styles.container,
            { borderColor: currentBorderColor },
            containerStyle,
          ]}
        >
          {/* Lnea de fondo para crear efecto de muesca en el borde */}
          <Animated.View
            style={[
              styles.backgroundLine,
              {
                backgroundColor: theme.colors.background,
                opacity: animation.interpolate({
                  inputRange: [0, 0.5, 1],
                  outputRange: [0, 0.8, 1],
                }),
                transform: [
                  {
                    scaleX: animation.interpolate({
                      inputRange: [0, 1],
                      outputRange: [0, 1],
                    }),
                  },
                ],
                width: Math.min(label.length * 6.5 + 16, 200), // Ancho fijo basado en el texto con lmite mximo
              },
            ]}
          />
          <Animated.Text
            style={[
              styles.label,
              staticLabelStyle,
              labelStyle,
              animatedLabelStyle,
            ]}
            numberOfLines={1}
            ellipsizeMode="tail"
          >
            {label}
          </Animated.Text>
          <View style={[styles.inputContainer, styles.inputBoxNone]}>
            <TextInput
              ref={finalRef}
              value={value}
              onChangeText={onChangeText}
              onFocus={handleFocus}
              onBlur={handleBlur}
              style={[styles.input, inputStyle, style]}
              placeholder=""
              editable={!disabled}
              pointerEvents={disabled ? 'none' : 'auto'}
              underlineColorAndroid="transparent"
              placeholderTextColor={finalInactiveLabelColor}
              multiline={multiline}
              autoCorrect={false}
              keyboardAppearance={theme.dark ? 'dark' : 'light'}
              {...rest}
            />
          </View>
        </View>
      </TouchableWithoutFeedback>
    );
  },
);

AnimatedLabelInput.displayName = 'AnimatedLabelInput';

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
  props: {
    multiline?: boolean;
    disabled: boolean;
    finalInactiveLabelColor: string;
  },
) =>
  StyleSheet.create({
    container: {
      borderWidth: 1,
      borderRadius: theme.roundness,
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      position: 'relative',
      backgroundColor: theme.colors.background,
      minHeight: responsive.isTablet ? 52 : 58,
    },
    inputContainer: {
      flexDirection: 'row',
      alignItems: props.multiline ? 'flex-start' : 'center',
      paddingTop: responsive.isTablet ? 16 : 18,
      paddingBottom: responsive.isTablet ? 4 : 6,
      minHeight: responsive.isTablet ? 36 : 40,
    },
    label: {
      fontSize: responsive.fontSize(16),
      color: props.finalInactiveLabelColor,
    },
    input: {
      flex: 1,
      fontSize: responsive.fontSize(16),
      color: props.disabled
        ? theme.colors.onSurfaceDisabled
        : theme.colors.onSurface,
      paddingVertical: 0,
      paddingHorizontal: 0,
      margin: 0,
      borderWidth: 0,
      backgroundColor: 'transparent',
      textAlignVertical: props.multiline ? 'top' : 'center',
    },
    backgroundLine: {
      position: 'absolute',
      top: -1, // Sobre el borde superior
      left: 10,
      height: 2, // Mismo grosor que el borde
      zIndex: 5,
    },
    inputBoxNone: {
      pointerEvents: 'box-none',
    },
  });

export default AnimatedLabelInput;

================
File: app/src/app/components/common/GlobalSnackbar.tsx
================
import { useEffect } from 'react';
import { Snackbar, Portal, Text } from 'react-native-paper';
import { StyleSheet } from 'react-native';
import { useSnackbarStore, SnackbarType } from '@/app/store/snackbarStore';
import { useAppTheme } from '@/app/styles/theme';

const GlobalSnackbar = () => {
  const { visible, message, type, duration, hideSnackbar } = useSnackbarStore();
  const theme = useAppTheme();

  useEffect(() => {
    if (visible && message) {
      const timer = setTimeout(() => {
        hideSnackbar();
      }, duration || 2500);

      return () => clearTimeout(timer);
    }
  }, [visible, message, duration, hideSnackbar]);

  const getBackgroundColor = (snackbarType: SnackbarType) => {
    switch (snackbarType) {
      case 'success':
        return theme.colors.successContainer;
      case 'error':
        return theme.colors.errorContainer;
      case 'warning':
        return theme.colors.warningContainer || theme.colors.tertiaryContainer;
      case 'info':
        return theme.colors.infoContainer || theme.colors.surfaceVariant;
      default:
        return theme.colors.inverseSurface;
    }
  };

  const getTextColor = (snackbarType: SnackbarType) => {
    const defaultTextColor = theme.dark
      ? theme.colors.surface
      : theme.colors.onSurface;

    switch (snackbarType) {
      case 'success':
        return theme.colors.onSuccessContainer || defaultTextColor;
      case 'error':
        return theme.colors.onErrorContainer;
      case 'warning':
        return (
          theme.colors.onWarningContainer || theme.colors.onTertiaryContainer
        );
      case 'info':
        return theme.colors.onInfoContainer || theme.colors.onSurfaceVariant;
      default:
        return theme.colors.inverseOnSurface;
    }
  };

  const backgroundColor = getBackgroundColor(type);
  const textColor = getTextColor(type);

  return (
    <Portal>
      <Snackbar
        visible={visible}
        onDismiss={hideSnackbar}
        duration={duration || 2500}
        style={[
          styles.snackbar,
          {
            backgroundColor,
          },
        ]}
        theme={{
          ...theme,
          colors: {
            ...theme.colors,
            inversePrimary: textColor,
            inverseOnSurface: textColor,
          },
        }}
      >
        <Text style={styles.messageText}>{message || ''}</Text>
      </Snackbar>
    </Portal>
  );
};

const styles = StyleSheet.create({
  snackbar: {
    marginHorizontal: 16,
    borderRadius: 8,
    elevation: 6,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 3,
    },
    shadowOpacity: 0.27,
    shadowRadius: 4.65,
    marginBottom: 40,
  },
  messageText: {
    textAlign: 'center',
    width: '100%',
  },
});

export default GlobalSnackbar;

================
File: app/src/app/components/crud/GenericFormModal.tsx
================
import { useEffect, useMemo, useState, useCallback, useRef } from 'react';
import {
  View,
  StyleSheet,
  Alert,
  ScrollView,
  StyleProp,
  ViewStyle,
} from 'react-native';
import {
  Text,
  TextInput,
  Button,
  Switch,
  HelperText,
  ActivityIndicator,
} from 'react-native-paper';
import {
  useForm,
  Controller,
  SubmitHandler,
  FieldValues,
  Path,
  UseFormReturn,
  DeepPartial,
  DefaultValues,
  Control,
  FieldError, // Importar FieldError
} from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { z } from 'zod';
import { useAppTheme, AppTheme } from '../../styles/theme';
import CustomImagePicker, { FileObject } from '../common/CustomImagePicker';
import {
  ImageUploadService,
  EntityWithOptionalPhoto,
} from '../../lib/imageUploadService';
import { ResponsiveModal } from '../responsive/ResponsiveModal';
import { useResponsive } from '../../hooks/useResponsive';

type FieldType =
  | 'text'
  | 'textarea'
  | 'switch'
  | 'number'
  | 'email'
  | 'password';

export interface FormFieldConfig<TFormData extends FieldValues> {
  name: Path<TFormData>;
  label: string;
  type: FieldType;
  placeholder?: string;
  required?: boolean;
  defaultValue?: any;
  inputProps?: any;
  switchProps?: Partial<React.ComponentProps<typeof Switch>>;
  numberOfLines?: number;
  switchLabel?: string;
}

export interface ImagePickerConfig<TFormData extends FieldValues> {
  imageUriField: Path<TFormData>;
  onImageUpload: (file: FileObject) => Promise<{ id: string } | null>;
  determineFinalPhotoId?: (
    currentImageUri: string | null,
    editingItem: EntityWithOptionalPhoto | undefined,
  ) => string | null | undefined;
  imagePickerSize?: number;
  placeholderIcon?: string;
  placeholderText?: string;
}

interface GenericFormModalProps<
  TFormData extends FieldValues,
  TItem extends { id: string },
> {
  visible: boolean;
  onDismiss: () => void;
  onSubmit: (
    data: TFormData,
    photoId: string | null | undefined,
  ) => Promise<void>;
  formSchema: z.ZodType<TFormData>;
  formFields: FormFieldConfig<TFormData>[];
  imagePickerConfig?: ImagePickerConfig<TFormData>;
  initialValues?: DeepPartial<TFormData>;
  editingItem: (TItem & Partial<EntityWithOptionalPhoto>) | null;
  isSubmitting: boolean;
  modalTitle: (isEditing: boolean) => string;
  submitButtonLabel?: (isEditing: boolean) => string;
  cancelButtonLabel?: string;
  modalStyle?: StyleProp<ViewStyle>;
  formContainerStyle?: StyleProp<ViewStyle>;
  onFileSelected?: (file: FileObject | null) => void;
}

// Componente separado para manejar campos numricos correctamente
interface NumericInputProps {
  value: number | null | undefined;
  onChange: (value: number | null) => void;
  onBlur: () => void;
  label: string;
  placeholder?: string;
  keyboardType?: any; // Permitir cualquier KeyboardTypeOptions
  error?: boolean;
  disabled?: boolean;
  inputProps?: any;
}

const NumericInput = ({
  value,
  onChange,
  onBlur,
  label,
  placeholder,
  keyboardType = 'decimal-pad',
  error,
  disabled,
  inputProps,
}: NumericInputProps) => {
  const [inputValue, setInputValue] = useState<string>(
    value === null || value === undefined ? '' : String(value),
  );

  useEffect(() => {
    const stringValue =
      value === null || value === undefined ? '' : String(value);
    if (stringValue !== inputValue) {
      const numericValueFromInput = parseFloat(inputValue);
      if (
        !(inputValue.endsWith('.') && numericValueFromInput === value) &&
        !(inputValue === '.' && value === null)
      ) {
        setInputValue(stringValue);
      }
    }
  }, [value, inputValue]);

  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = getStyles(theme, responsive);

  return (
    <TextInput
      label={label}
      value={inputValue}
      onChangeText={(text) => {
        const formattedText = text.replace(/,/g, '.');
        if (/^(\d*\.?\d*)$/.test(formattedText)) {
          setInputValue(formattedText);

          if (formattedText === '' || formattedText === '.') {
            if (value !== null) onChange(null);
          } else {
            const numericValue = parseFloat(formattedText);
            if (!isNaN(numericValue) && numericValue !== value) {
              onChange(numericValue);
            } else if (isNaN(numericValue) && value !== null) {
              onChange(null);
            }
          }
        }
      }}
      onBlur={onBlur}
      mode="outlined"
      style={styles.input}
      placeholder={placeholder}
      keyboardType={keyboardType}
      error={error}
      disabled={disabled}
      {...inputProps}
    />
  );
};

const getDefaultValueForType = (
  type: FieldType,
): string | number | boolean | null | undefined => {
  switch (type) {
    case 'text':
    case 'textarea':
    case 'email':
    case 'password':
      return '';
    case 'number':
      return null;
    case 'switch':
      return false;
    default:
      return undefined;
  }
};

const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    modalSurface: {
      padding: 0,
      margin: responsive.spacing(20),
      marginHorizontal: responsive.isTablet
        ? responsive.spacing(40)
        : responsive.spacing(20),
      borderRadius: theme.roundness * 2,
      elevation: 4,
      backgroundColor: theme.colors.background,
      maxHeight: responsive.isTablet ? '92%' : '90%',
      maxWidth: responsive.isTablet ? 600 : 500,
      alignSelf: 'center',
      width: responsive.isTablet ? '85%' : '90%',
      overflow: 'hidden',
    },
    modalHeader: {
      backgroundColor: theme.colors.primary,
      paddingVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      paddingHorizontal: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
    },
    formContainer: {
      maxHeight: '100%',
    },
    scrollViewContent: {
      padding: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
      paddingBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.l)
        : responsive.spacing(theme.spacing.xl),
    },
    modalTitle: {
      color: theme.colors.onPrimary,
      fontWeight: '700',
      textAlign: 'center',
    },
    input: {
      marginBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: theme.roundness,
    },
    switchLabel: {
      color: theme.colors.onSurfaceVariant,
      marginRight: responsive.spacing(theme.spacing.m),
      fontSize: responsive.isTablet ? 14 : 16,
      flexShrink: 1,
    },
    switchComponentContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'flex-start',
      marginBottom: responsive.spacing(theme.spacing.m),
      paddingVertical: responsive.spacing(theme.spacing.s),
    },
    imagePickerContainer: {
      alignItems: 'center',
      marginBottom: responsive.spacing(theme.spacing.l),
    },
    modalActions: {
      flexDirection: 'row',
      justifyContent: 'center',
      paddingTop: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
      paddingBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.l)
        : responsive.spacing(theme.spacing.xl),
      paddingHorizontal: responsive.isTablet
        ? responsive.spacing(theme.spacing.m)
        : responsive.spacing(theme.spacing.l),
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
      gap: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      minHeight: responsive.isTablet ? 70 : 80,
    },
    formButton: {
      borderRadius: theme.roundness,
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      flex: 1,
      maxWidth: 200,
      minWidth: responsive.isTablet ? 120 : 140,
    },
    cancelButton: {},
    loadingOverlay: {
      ...StyleSheet.absoluteFillObject,
      backgroundColor: 'rgba(0, 0, 0, 0.3)',
      justifyContent: 'center',
      alignItems: 'center',
      borderRadius: theme.roundness * 2,
      zIndex: 10,
    },
    helperText: {
      marginTop: -responsive.spacing(theme.spacing.s),
      marginBottom: responsive.spacing(theme.spacing.s),
    },
  });

const GenericFormModal = <
  TFormData extends FieldValues,
  TItem extends { id: string },
>({
  visible,
  onDismiss,
  onSubmit,
  formSchema,
  formFields,
  imagePickerConfig,
  initialValues,
  editingItem,
  isSubmitting: isParentSubmitting,
  modalTitle,
  submitButtonLabel = (isEditing: boolean) => (isEditing ? 'Guardar' : 'Crear'),
  cancelButtonLabel = 'Cancelar',
  modalStyle,
  formContainerStyle,
  onFileSelected,
}: GenericFormModalProps<TFormData, TItem>) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = useMemo(
    () => getStyles(theme, responsive),
    [theme, responsive],
  );
  const [isInternalImageUploading, setIsInternalImageUploading] =
    useState(false);
  const [localSelectedFile, setLocalSelectedFile] = useState<FileObject | null>(
    null,
  );
  const prevVisibleRef = useRef(visible);
  const prevEditingItemIdRef = useRef(editingItem?.id);

  const isEditing = !!editingItem;
  const isActuallySubmitting = isParentSubmitting || isInternalImageUploading;

  const {
    control,
    handleSubmit,
    reset,
    setValue,
    watch,
    getValues: _getValues,
    formState: { errors },
  }: UseFormReturn<TFormData> = useForm<TFormData>({
    resolver: zodResolver(formSchema) as any,
    defaultValues: useMemo((): DefaultValues<TFormData> => {
      const defaults = formFields.reduce(
        (acc: DefaultValues<TFormData>, field) => {
          acc[field.name] =
            field.defaultValue ?? getDefaultValueForType(field.type);
          return acc;
        },
        {} as DefaultValues<TFormData>,
      );
      return { ...defaults, ...(initialValues as DefaultValues<TFormData>) };
    }, [formFields, initialValues]),
  });

  const watchedImageUri = imagePickerConfig
    ? watch(imagePickerConfig.imageUriField)
    : undefined;
  const currentImageUri =
    typeof watchedImageUri === 'string' ? watchedImageUri : null;

  useEffect(() => {
    const loadInitialData = async () => {
      const justOpened = visible && !prevVisibleRef.current;
      const itemChanged =
        visible && editingItem?.id !== prevEditingItemIdRef.current;

      if (visible) {
        const defaultFormValues = formFields.reduce(
          (acc: DefaultValues<TFormData>, field) => {
            acc[field.name] =
              field.defaultValue ?? getDefaultValueForType(field.type);
            return acc;
          },
          {} as DefaultValues<TFormData>,
        );

        const resetValues = {
          ...defaultFormValues,
          ...(initialValues as DefaultValues<TFormData>),
        };

        reset(resetValues, { keepDirtyValues: !justOpened && !itemChanged });

        if (justOpened || itemChanged) {
          setLocalSelectedFile(null);
          onFileSelected?.(null);
          setIsInternalImageUploading(false);
        }
      }

      prevVisibleRef.current = visible;
      prevEditingItemIdRef.current = editingItem?.id;
    };

    loadInitialData();
  }, [
    visible,
    editingItem?.id,
    reset,
    formFields,
    initialValues,
    onFileSelected,
    imagePickerConfig,
  ]);

  const handleImageSelected = useCallback(
    (uri: string, file: FileObject) => {
      if (imagePickerConfig) {
        const fieldName = imagePickerConfig.imageUriField;
        setValue(fieldName, uri as any, {
          shouldValidate: true,
          shouldDirty: true,
          shouldTouch: true,
        });
        setLocalSelectedFile(file);
        onFileSelected?.(file);
      }
    },
    [setValue, imagePickerConfig, onFileSelected],
  );

  const handleImageRemoved = useCallback(() => {
    if (imagePickerConfig) {
      setValue(imagePickerConfig.imageUriField, null as any, {
        shouldValidate: true,
      });
      setLocalSelectedFile(null);
      onFileSelected?.(null);
    }
  }, [setValue, imagePickerConfig, onFileSelected]);

  const processSubmit: SubmitHandler<TFormData> = async (formData) => {
    if (isActuallySubmitting) return;

    let finalPhotoId: string | null | undefined = undefined;

    if (imagePickerConfig) {
      const formImageUri = imagePickerConfig.imageUriField
        ? formData[imagePickerConfig.imageUriField]
        : null;

      const isNewLocalImage =
        typeof formImageUri === 'string' && formImageUri.startsWith('file://');
      if (isNewLocalImage && localSelectedFile) {
        setIsInternalImageUploading(true);
        try {
          const uploadResult =
            await imagePickerConfig.onImageUpload(localSelectedFile);
          if (uploadResult?.id) {
            finalPhotoId = uploadResult.id;
          } else {
            throw new Error('La subida de la imagen no devolvi un ID.');
          }
        } catch (error) {
          Alert.alert(
            'Error',
            `No se pudo subir la imagen: ${error instanceof Error ? error.message : 'Error desconocido'}`,
          );
          setIsInternalImageUploading(false);
          return;
        } finally {
          setIsInternalImageUploading(false);
        }
      } else {
        const determineFn =
          imagePickerConfig.determineFinalPhotoId ??
          ImageUploadService.determinePhotoId;
        const entityForPhotoCheck = editingItem ?? undefined;
        finalPhotoId = await determineFn(formImageUri, entityForPhotoCheck);
      }
    }

    await onSubmit(formData, finalPhotoId);
  };

  const renderFormField = (fieldConfig: FormFieldConfig<TFormData>) => {
    const fieldName = fieldConfig.name;
    const fieldError = errors[fieldName] as FieldError | undefined;
    const errorMessage = fieldError?.message;

    switch (fieldConfig.type) {
      case 'textarea':
      case 'text':
      case 'number':
      case 'email':
      case 'password':
        return (
          <View key={String(fieldName)}>
            {/* Controller para campos numricos con manejo de string local y decimales */}
            <Controller
              name={fieldName}
              control={control as Control<FieldValues>}
              render={({ field: { onChange, onBlur, value } }) => {
                if (fieldConfig.type === 'number') {
                  return (
                    <NumericInput
                      value={value}
                      onChange={onChange}
                      onBlur={onBlur}
                      label={fieldConfig.label}
                      placeholder={fieldConfig.placeholder}
                      keyboardType={
                        fieldConfig.inputProps?.keyboardType ?? 'decimal-pad'
                      }
                      error={!!errorMessage}
                      disabled={isActuallySubmitting}
                      inputProps={fieldConfig.inputProps}
                    />
                  );
                } else {
                  return (
                    <TextInput
                      label={fieldConfig.label}
                      value={value ?? ''}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      mode="outlined"
                      style={styles.input}
                      placeholder={fieldConfig.placeholder}
                      secureTextEntry={fieldConfig.type === 'password'}
                      keyboardType={
                        fieldConfig.type === 'email'
                          ? 'email-address'
                          : 'default'
                      }
                      multiline={fieldConfig.type === 'textarea'}
                      numberOfLines={
                        fieldConfig.numberOfLines ??
                        (fieldConfig.type === 'textarea' ? 3 : 1)
                      }
                      error={!!errorMessage}
                      disabled={isActuallySubmitting}
                      {...fieldConfig.inputProps}
                    />
                  );
                }
              }}
            />
            {errorMessage && (
              <HelperText
                type="error"
                visible={!!errorMessage}
                style={styles.helperText}
              >
                {errorMessage}
              </HelperText>
            )}
          </View>
        );
      case 'switch':
        return (
          <View key={String(fieldName)} style={styles.switchComponentContainer}>
            <Text variant="bodyLarge" style={styles.switchLabel}>
              {fieldConfig.switchLabel ?? fieldConfig.label}
            </Text>
            <Controller
              name={fieldName}
              control={control as Control<FieldValues>}
              render={({ field: { onChange, value } }) => (
                <Switch
                  value={value}
                  onValueChange={onChange}
                  disabled={isActuallySubmitting}
                  style={{ transform: [{ scaleX: 1.5 }, { scaleY: 1.5 }] }}
                  {...fieldConfig.switchProps}
                />
              )}
            />
            {errorMessage && (
              <HelperText
                type="error"
                visible={!!errorMessage}
                style={styles.helperText}
              >
                {errorMessage}
              </HelperText>
            )}
          </View>
        );
      default:
        return null;
    }
  };

  return (
    <ResponsiveModal
      visible={visible}
      onDismiss={onDismiss}
      title={modalTitle(isEditing)}
      dismissable={!isActuallySubmitting}
      scrollable={false}
      style={modalStyle}
      contentContainerStyle={styles.modalSurface}
      footer={
        <View style={styles.modalActions}>
          <Button
            mode="outlined"
            onPress={onDismiss}
            style={[styles.formButton, styles.cancelButton]}
            disabled={isActuallySubmitting}
          >
            {cancelButtonLabel}
          </Button>
          <Button
            mode="contained"
            onPress={() => {
              handleSubmit(processSubmit)();
            }}
            loading={isActuallySubmitting}
            disabled={isActuallySubmitting}
            style={styles.formButton}
          >
            {submitButtonLabel(isEditing)}
          </Button>
        </View>
      }
    >
      <View style={[styles.formContainer, formContainerStyle]}>
        <ScrollView
          contentContainerStyle={styles.scrollViewContent}
          showsVerticalScrollIndicator={false}
        >
          {imagePickerConfig && (
            <View style={styles.imagePickerContainer}>
              <CustomImagePicker
                value={currentImageUri}
                onImageSelected={handleImageSelected}
                onImageRemoved={handleImageRemoved}
                isLoading={isInternalImageUploading}
                disabled={isParentSubmitting}
                size={
                  imagePickerConfig.imagePickerSize ??
                  responsive.getResponsiveDimension(150, 200)
                }
                placeholderIcon={imagePickerConfig.placeholderIcon}
                placeholderText={imagePickerConfig.placeholderText}
              />
              {(
                errors[imagePickerConfig.imageUriField] as
                  | FieldError
                  | undefined
              )?.message && (
                <HelperText
                  type="error"
                  visible={!!errors[imagePickerConfig.imageUriField]}
                  style={styles.helperText}
                >
                  {
                    (
                      errors[imagePickerConfig.imageUriField] as
                        | FieldError
                        | undefined
                    )?.message
                  }
                </HelperText>
              )}
            </View>
          )}

          {formFields.map(renderFormField)}
        </ScrollView>

        {isActuallySubmitting && (
          <View style={styles.loadingOverlay}>
            <ActivityIndicator
              animating={true}
              size="large"
              color={theme.colors.primary}
            />
          </View>
        )}
      </View>
    </ResponsiveModal>
  );
};

export default GenericFormModal;

================
File: app/src/app/components/ServerConfigModal.tsx
================
import { useEffect, useState } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  ActivityIndicator,
  Platform,
} from 'react-native';
import {
  Text,
  Modal,
  Portal,
  Surface,
  RadioButton,
  TextInput,
  Button,
  HelperText,
  Chip,
  IconButton,
  useTheme,
} from 'react-native-paper';
import { useSnackbar } from '@/hooks/useSnackbar';
import { ConnectionMode } from '@/services/serverConnectionService';
import { discoveryService } from '@/app/services/discoveryService';
import EncryptedStorage from '@/app/services/secureStorageService';
import axios from 'axios';

const STORAGE_KEYS = {
  CONNECTION_MODE: 'connection_mode',
  MANUAL_URL: 'manual_server_url',
};

interface ServerConfigModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSuccess?: () => void;
}

export function ServerConfigModal({
  visible,
  onDismiss,
  onSuccess,
}: ServerConfigModalProps) {
  const theme = useTheme();
  const { showSnackbar } = useSnackbar();

  const [mode, setMode] = useState<ConnectionMode>('auto');
  const [manualUrl, setManualUrl] = useState('');
  const [currentUrl, setCurrentUrl] = useState<string | null>(null);
  const [testing, setTesting] = useState(false);
  const [loading, setLoading] = useState(true);
  const [remoteUrlAvailable, setRemoteUrlAvailable] = useState<string | null>(
    null,
  );

  useEffect(() => {
    if (visible) {
      loadSettings();
    }
  }, [visible]);

  const loadSettings = async () => {
    try {
      setLoading(true);
      const savedMode = (await EncryptedStorage.getItem(
        STORAGE_KEYS.CONNECTION_MODE,
      )) as ConnectionMode;
      const savedUrl = await EncryptedStorage.getItem(STORAGE_KEYS.MANUAL_URL);
      const currentApiUrl = await discoveryService.getApiUrl();

      if (savedMode) setMode(savedMode);
      if (savedUrl) setManualUrl(savedUrl);
      if (currentApiUrl) setCurrentUrl(currentApiUrl);

      if (currentApiUrl) {
        try {
          const response = await axios.get(`${currentApiUrl}/api/v1/discovery`);
          if (response.data.remoteUrl) {
            setRemoteUrlAvailable(response.data.remoteUrl);
          }
        } catch (error) {}
      }
    } catch (error) {
      // Error loading settings
    } finally {
      setLoading(false);
    }
  };

  const normalizeUrl = (url: string): string => {
    if (!url.startsWith('http://') && !url.startsWith('https://')) {
      url = 'http://' + url;
    }

    try {
      const parsed = new URL(url);
      if (
        !parsed.port &&
        (parsed.hostname.startsWith('192.168.') ||
          parsed.hostname.startsWith('10.') ||
          parsed.hostname.startsWith('172.') ||
          parsed.hostname === 'localhost' ||
          /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(parsed.hostname))
      ) {
        parsed.port = '3737';
      }
      return `${parsed.protocol}//${parsed.host}`;
    } catch {
      return url;
    }
  };

  const validateUrl = (url: string): boolean => {
    try {
      const normalized = normalizeUrl(url);
      const parsed = new URL(normalized);
      return ['http:', 'https:'].includes(parsed.protocol);
    } catch {
      return false;
    }
  };

  const testConnection = async () => {
    if (mode === 'manual' && !validateUrl(manualUrl)) {
      showSnackbar('Por favor ingresa una URL vlida', 'error');
      return;
    }

    setTesting(true);
    try {
      let urlToTest = '';

      if (mode === 'auto') {
        // Probar auto-descubrimiento
        const discovered = await discoveryService.discoverServer();
        if (!discovered) {
          throw new Error('No se pudo encontrar el servidor en la red local');
        }
        urlToTest = discovered;
      } else if (mode === 'remote' && remoteUrlAvailable) {
        urlToTest = remoteUrlAvailable;
      } else {
        urlToTest = normalizeUrl(manualUrl);
      }

      // Verificar conexin
      const response = await axios.get(`${urlToTest}/api/v1/discovery`, {
        timeout: 5000,
      });

      if (response.data.type !== 'cloudbite-api') {
        throw new Error('El servidor no es compatible');
      }

      showSnackbar('Conexin exitosa', 'success');
      setCurrentUrl(urlToTest);
    } catch (error: any) {
      showSnackbar(
        error.message || 'Error al conectar con el servidor',
        'error',
      );
    } finally {
      setTesting(false);
    }
  };

  const saveSettings = async () => {
    try {
      // Guardar modo de conexin
      await EncryptedStorage.setItem(STORAGE_KEYS.CONNECTION_MODE, mode);

      // Guardar URL manual si aplica
      if (mode === 'manual') {
        if (!validateUrl(manualUrl)) {
          showSnackbar('Por favor ingresa una URL vlida', 'error');
          return;
        }
        const normalizedUrl = normalizeUrl(manualUrl);
        await EncryptedStorage.setItem(STORAGE_KEYS.MANUAL_URL, normalizedUrl);
        await discoveryService.setServerUrl(normalizedUrl, true);

        // En web, verificar la conexin inmediatamente
        if (Platform.OS === 'web') {
          try {
            const response = await axios.get(
              `${normalizedUrl}/api/v1/discovery`,
              {
                timeout: 5000,
              },
            );
            if (response.data.type === 'cloudbite-api') {
              // El servicio detectar automticamente el cambio de URL
            }
          } catch (error) {
            // Error verificando conexin despus de guardar
          }
        }
      } else if (mode === 'remote' && remoteUrlAvailable) {
        await discoveryService.setServerUrl(remoteUrlAvailable, true);
      } else {
        // Modo automtico - limpiar URL manual
        await discoveryService.setServerUrl(null, true);
      }

      // La reconexin se manejar en el onSuccess callback

      showSnackbar('Configuracin guardada', 'success');
      onSuccess?.();
      onDismiss();
    } catch (error: any) {
      showSnackbar(
        error.message || 'Error al guardar la configuracin',
        'error',
      );
    }
  };

  const styles = StyleSheet.create({
    modal: {
      justifyContent: 'center',
      alignItems: 'center',
      margin: 20,
    },
    container: {
      width: '100%',
      maxWidth: 500,
      maxHeight: '90%',
      backgroundColor: theme.colors.surface,
      borderRadius: 16,
      overflow: 'hidden',
    },
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: 16,
      paddingVertical: 12,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    title: {
      fontSize: 20,
      fontWeight: 'bold',
      color: theme.colors.onSurface,
    },
    content: {
      padding: 16,
    },
    loadingContainer: {
      padding: 40,
      alignItems: 'center',
    },
    statusContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 8,
      marginBottom: 16,
    },
    successChip: {
      backgroundColor: theme.colors.primaryContainer,
    },
    errorChip: {
      backgroundColor: theme.colors.errorContainer,
    },
    urlText: {
      flex: 1,
      marginLeft: 8,
      color: theme.colors.onSurfaceVariant,
      fontSize: 12,
    },
    section: {
      marginBottom: 16,
    },
    sectionTitle: {
      fontSize: 16,
      fontWeight: '600',
      marginBottom: 8,
      color: theme.colors.onSurface,
    },
    manualConfig: {
      marginTop: 8,
      marginLeft: 32,
    },
    actions: {
      flexDirection: 'row',
      justifyContent: 'flex-end',
      gap: 8,
      padding: 16,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
    },
  });

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modal}
        dismissable={!testing}
      >
        <Surface style={styles.container}>
          <View style={styles.header}>
            <Text style={styles.title}>Configuracin del Servidor</Text>
            <IconButton
              icon="close"
              size={24}
              onPress={onDismiss}
              disabled={testing}
            />
          </View>

          <ScrollView style={styles.content}>
            {loading ? (
              <View style={styles.loadingContainer}>
                <ActivityIndicator size="large" />
              </View>
            ) : (
              <>
                {/* Estado actual */}
                <View style={styles.section}>
                  <Text style={styles.sectionTitle}>Estado de Conexin</Text>
                  {currentUrl ? (
                    <View style={styles.statusContainer}>
                      <Chip
                        icon="check-circle"
                        mode="flat"
                        style={styles.successChip}
                      >
                        Conectado
                      </Chip>
                      <Text
                        variant="bodySmall"
                        style={styles.urlText}
                        numberOfLines={1}
                      >
                        {currentUrl}
                      </Text>
                    </View>
                  ) : (
                    <View style={styles.statusContainer}>
                      <Chip
                        icon="alert-circle"
                        mode="flat"
                        style={styles.errorChip}
                      >
                        Sin conexin
                      </Chip>
                    </View>
                  )}
                </View>

                {/* Modo de conexin */}
                <View style={styles.section}>
                  <Text style={styles.sectionTitle}>Modo de Conexin</Text>
                  <RadioButton.Group
                    onValueChange={(value) => setMode(value as ConnectionMode)}
                    value={mode}
                  >
                    <RadioButton.Item
                      label="Automtico (Red Local)"
                      value="auto"
                      status={mode === 'auto' ? 'checked' : 'unchecked'}
                    />
                    <HelperText type="info" visible={mode === 'auto'}>
                      Busca automticamente el servidor en tu red local
                    </HelperText>

                    {remoteUrlAvailable && (
                      <>
                        <RadioButton.Item
                          label="Remoto (Internet)"
                          value="remote"
                          status={mode === 'remote' ? 'checked' : 'unchecked'}
                        />
                        <HelperText type="info" visible={mode === 'remote'}>
                          Usa el servidor remoto: {remoteUrlAvailable}
                        </HelperText>
                      </>
                    )}

                    <RadioButton.Item
                      label="Manual"
                      value="manual"
                      status={mode === 'manual' ? 'checked' : 'unchecked'}
                    />

                    {mode === 'manual' && (
                      <View style={styles.manualConfig}>
                        <TextInput
                          label="URL del Servidor"
                          value={manualUrl}
                          onChangeText={setManualUrl}
                          placeholder="192.168.1.230 o http://192.168.1.230:3737"
                          mode="outlined"
                          autoCapitalize="none"
                          autoCorrect={false}
                          keyboardType="url"
                          error={manualUrl !== '' && !validateUrl(manualUrl)}
                        />
                        <HelperText
                          type="info"
                          visible={mode === 'manual' && manualUrl === ''}
                        >
                          Puedes ingresar solo la IP. El puerto 3737 se agregar
                          automticamente.
                        </HelperText>
                        <HelperText
                          type="error"
                          visible={manualUrl !== '' && !validateUrl(manualUrl)}
                        >
                          URL invlida
                        </HelperText>
                      </View>
                    )}
                  </RadioButton.Group>
                </View>
              </>
            )}
          </ScrollView>

          <View style={styles.actions}>
            <Button mode="text" onPress={onDismiss} disabled={testing}>
              Cancelar
            </Button>
            <Button
              mode="outlined"
              onPress={testConnection}
              loading={testing}
              disabled={testing || loading}
              icon="connection"
            >
              Probar
            </Button>
            <Button
              mode="contained"
              onPress={saveSettings}
              disabled={testing || loading}
              icon="content-save"
            >
              Guardar
            </Button>
          </View>
        </Surface>
      </Modal>
    </Portal>
  );
}

================
File: app/src/app/constants/apiPaths.ts
================
export const API_PATHS = {
  SUBCATEGORIES: '/api/v1/subcategories',
  SUBCATEGORIES_BY_ID: '/api/v1/subcategories/:id',
  PRODUCTS: '/api/v1/products',
  PRODUCTS_BY_ID: '/api/v1/products/:id',
  PRODUCTS_MODIFIER_GROUPS: '/api/v1/products/:productId/modifier-groups',
  PRODUCTS_PIZZA_CUSTOMIZATIONS:
    '/api/v1/products/:productId/pizza-customizations',
  PRODUCTS_PIZZAS_CUSTOMIZATIONS_BULK:
    '/api/v1/products/pizzas/customizations/bulk',
  CATEGORIES: '/api/v1/categories',
  CATEGORIES_BY_ID: '/api/v1/categories/:id',
  CATEGORIES_ORDER_MENU: '/api/v1/categories/order-menu',
  FILES_UPLOAD: '/api/v1/files/upload',

  PREPARATION_SCREENS: '/api/v1/preparation-screens',
  PREPARATION_SCREENS_BY_ID: '/api/v1/preparation-screens/:id',
  PREPARATION_SCREENS_PRODUCTS: '/api/v1/preparation-screens/:id/products',
  PREPARATION_SCREENS_MENU_WITH_ASSOCIATIONS:
    '/api/v1/preparation-screens/:id/menu-with-associations',

  AUTH_EMAIL_LOGIN: '/api/v1/auth/email/login',
  AUTH_EMAIL_REGISTER: '/api/v1/auth/email/register',
  AUTH_ME: '/api/v1/auth/me',
  AUTH_REFRESH: '/api/v1/auth/refresh',

  AREAS: '/api/v1/areas',
  AREAS_BY_ID: '/api/v1/areas/:id',
  TABLES: '/api/v1/tables',
  TABLES_BY_ID: '/api/v1/tables/:id',
  TABLES_BY_AREA: '/api/v1/tables/area/:areaId',

  MODIFIERS: '/api/v1/product-modifiers',
  MODIFIERS_BY_ID: '/api/v1/product-modifiers/:id',
  MODIFIERS_BY_GROUP: '/api/v1/product-modifiers/by-group/:modifierGroupId',
  MODIFIER_GROUPS: '/api/v1/modifier-groups',
  MODIFIER_GROUPS_BY_ID: '/api/v1/modifier-groups/:id',

  ORDERS: '/api/v1/orders',
  ORDERS_BY_ID: '/api/v1/orders/:orderId',
  ORDERS_OPEN_CURRENT_SHIFT: '/api/v1/orders/open-current-shift',
  ORDERS_OPEN_ORDERS_LIST: '/api/v1/orders/open-orders-list',
  ORDERS_FOR_FINALIZATION_LIST: '/api/v1/orders/for-finalization/list',
  ORDERS_FOR_FINALIZATION_DETAIL: '/api/v1/orders/for-finalization/:id',
  ORDERS_FINALIZE_MULTIPLE: '/api/v1/orders/finalize-multiple',
  ORDERS_DETAIL: '/api/v1/orders/:orderId/detail',
  ORDERS_RECEIPTS_LIST: '/api/v1/orders/receipts-list',
  ORDERS_RECEIPTS_BY_ID: '/api/v1/orders/receipts/:id',
  ORDERS_RECOVER: '/api/v1/orders/:id/recover',
  PRINT_ORDER_TICKET: '/api/v1/print/order',

  THERMAL_PRINTERS: '/api/v1/thermal-printers',
  THERMAL_PRINTERS_BY_ID: '/api/v1/thermal-printers/:id',
  THERMAL_PRINTERS_DISCOVER: '/api/v1/thermal-printers/discover',
  THERMAL_PRINTERS_PING: '/api/v1/thermal-printers/:id/ping',
  THERMAL_PRINTERS_TEST_PRINT: '/api/v1/thermal-printers/test-print',

  ADJUSTMENTS: '/api/v1/adjustments',
  ADJUSTMENTS_BY_ID: '/api/v1/adjustments/:id',

  RESTAURANT_CONFIG: '/api/v1/restaurant-config',

  AVAILABILITY_MENU: '/api/v1/availability/menu',
  AVAILABILITY_MODIFIER_GROUPS: '/api/v1/availability/modifier-groups',
  AVAILABILITY_PIZZA_CUSTOMIZATIONS:
    '/api/v1/availability/pizza-customizations',
  AVAILABILITY_UPDATE: '/api/v1/availability/update',
  AVAILABILITY_BULK_UPDATE: '/api/v1/availability/bulk-update',

  PAYMENTS: '/api/v1/payments',
  PAYMENTS_BY_ID: '/api/v1/payments/:paymentId',
  PAYMENTS_BY_ORDER: '/api/v1/payments/order/:orderId',
  PAYMENTS_PREPAYMENT: '/api/v1/payments/prepayment',
  PAYMENTS_ASSOCIATE: '/api/v1/payments/:paymentId/associate/:orderId',

  PIZZA_CUSTOMIZATIONS: '/api/v1/pizza-customizations',
  PIZZA_CUSTOMIZATIONS_BY_ID: '/api/v1/pizza-customizations/:id',
  PIZZA_CUSTOMIZATIONS_SORT_ORDER: '/api/v1/pizza-customizations/sort-order',
  PIZZA_CONFIGURATIONS: '/api/v1/pizza-configurations',
  PIZZA_CONFIGURATIONS_BY_ID: '/api/v1/pizza-configurations/:id',
  PRODUCTS_PIZZAS: '/api/v1/products/pizzas/all',

  CUSTOMERS: '/api/v1/customers',
  CUSTOMERS_BY_ID: '/api/v1/customers/:id',
  CUSTOMERS_CHAT_MESSAGE: '/api/v1/customers/:customerId/chat-message',
  CUSTOMERS_CHAT_HISTORY: '/api/v1/customers/:customerId/relevant-chat-history',
  CUSTOMERS_STATS: '/api/v1/customers/:customerId/stats',
  CUSTOMERS_ACTIVE_RECENT: '/api/v1/customers/active/recent',
  ADDRESSES: '/api/v1/addresses',
  ADDRESSES_BY_ID: '/api/v1/addresses/:id',
  ADDRESSES_BY_CUSTOMER: '/api/v1/customers/:customerId/addresses',

  KITCHEN_ORDERS: '/api/v1/kitchen/orders',
  KITCHEN_ORDERS_START_PREPARATION:
    '/api/v1/kitchen/orders/:orderId/start-preparation',
  KITCHEN_ORDERS_CANCEL_PREPARATION:
    '/api/v1/kitchen/orders/:orderId/cancel-preparation',
  KITCHEN_ORDERS_COMPLETE_PREPARATION:
    '/api/v1/kitchen/orders/:orderId/complete-preparation',
  KITCHEN_MARK_PREPARED: '/api/v1/kitchen/order-items/:itemId/prepare',
  KITCHEN_MARK_UNPREPARED: '/api/v1/kitchen/order-items/:itemId/unprepare',
  KITCHEN_MY_SCREEN: '/api/v1/kitchen/my-screen',

  SHIFTS: '/api/v1/shifts',
  SHIFTS_OPEN: '/api/v1/shifts/open',
  SHIFTS_CLOSE: '/api/v1/shifts/close',
  SHIFTS_CURRENT: '/api/v1/shifts/current',
  SHIFTS_HISTORY: '/api/v1/shifts/history',
  SHIFTS_DETAIL: '/api/v1/shifts/:id',
  ORDERS_BY_SHIFT: '/api/v1/orders/shift/:shiftId',
  ORDERS_BY_SHIFT_SALES_SUMMARY: '/api/v1/orders/shift/:shiftId/sales-summary',

  USERS: '/api/v1/users',
  USERS_BY_ID: '/api/v1/users/:id',

  APP_CONFIG: '/api/v1/app-config',

  SYNC_STATUS: '/api/v1/sync-local/status',
  SYNC_ACTIVITY: '/api/v1/sync-local/activity',

  ORDERS_HISTORY: '/api/v1/orders/:orderId/history',
  ORDERS_QUICK_FINALIZE_MULTIPLE: '/api/v1/orders/quick-finalize-multiple',
  ORDERS_PRINT_TICKET: '/api/v1/orders/:orderId/print-ticket',

  FILES_CHECK: '/api/v1/files/',

  AUDIO_ORDERS_PROCESS: '/api/v1/audio-orders/process',
  AUDIO_ORDERS_HEALTH: '/api/v1/audio-orders/health',

  HEALTH: '/api/v1/health',
  DISCOVERY: '/api/v1/discovery',
} as const;

================
File: app/src/app/services/secureStorageService.ts
================
import * as SecureStore from 'expo-secure-store';
import { Platform } from 'react-native';

/**
 * Servicio de almacenamiento seguro usando expo-secure-store
 * Reemplaza a react-native-encrypted-storage
 */
class SecureStorageService {
  private isAvailable(): boolean {
    // SecureStore no est disponible en web
    return Platform.OS !== 'web';
  }

  async setItem(key: string, value: string): Promise<void> {
    if (!this.isAvailable()) {
      // Fallback para web: usar localStorage (no seguro)
      if (typeof window !== 'undefined' && window.localStorage) {
        window.localStorage.setItem(key, value);
      }
      return;
    }

    await SecureStore.setItemAsync(key, value);
  }

  async getItem(key: string): Promise<string | null> {
    if (!this.isAvailable()) {
      // Fallback para web
      if (typeof window !== 'undefined' && window.localStorage) {
        return window.localStorage.getItem(key);
      }
      return null;
    }

    try {
      return await SecureStore.getItemAsync(key);
    } catch (error) {
      // Error retrieving secure item
      return null;
    }
  }

  async removeItem(key: string): Promise<void> {
    if (!this.isAvailable()) {
      // Fallback para web
      if (typeof window !== 'undefined' && window.localStorage) {
        window.localStorage.removeItem(key);
      }
      return;
    }

    await SecureStore.deleteItemAsync(key);
  }

  async clear(): Promise<void> {
    // expo-secure-store no tiene un mtodo clear()
    // Necesitamos eliminar las claves conocidas manualmente
    const keysToRemove = [
      'auth_token',
      'refresh_token',
      'user_info',
      'last_known_api_url',
      'kitchen_filters_preferences',
      'app_theme_preference',
      'user_credentials',
      'remember_me_preference',
      'connection_mode',
      'manual_server_url',
    ];

    for (const key of keysToRemove) {
      try {
        await this.removeItem(key);
      } catch (error) {
        // Error removing key
      }
    }
  }
}

// Exportar una instancia nica para mantener compatibilidad con EncryptedStorage
const secureStorage = new SecureStorageService();

// Exportar con el mismo nombre que EncryptedStorage para facilitar la migracin
export default {
  setItem: (key: string, value: string) => secureStorage.setItem(key, value),
  getItem: (key: string) => secureStorage.getItem(key),
  removeItem: (key: string) => secureStorage.removeItem(key),
  clear: () => secureStorage.clear(),
};

// Tambin exportar la clase por si se necesita
export { SecureStorageService };

================
File: app/src/components/AudioRecorderWidget.tsx
================
import React, { useEffect, useRef, useState } from 'react';
import {
  View,
  TouchableOpacity,
  StyleSheet,
  Animated,
  Easing,
  Text,
  Platform,
} from 'react-native';
import { MaterialIcons, MaterialCommunityIcons } from '@expo/vector-icons';
import { useTheme } from 'react-native-paper';
import { useAudioRecorder } from '../hooks/useAudioRecorder';
import {
  audioServiceHealth,
  type AudioServiceHealthStatus,
} from '../services/audioServiceHealth';
import { serverConnectionService } from '../services/serverConnectionService';

interface AudioRecorderWidgetProps {
  onRecordingComplete: (audioUri: string, transcription: string) => void;
  onError: (error: string) => void;
}

export const AudioRecorderWidget: React.FC<AudioRecorderWidgetProps> = ({
  onRecordingComplete,
  onError,
}) => {
  const theme = useTheme();
  const {
    isRecording,
    isPreparing,
    isProcessing,
    audioUri,
    transcription,
    startRecording,
    stopRecording,
    resetRecording,
    error,
  } = useAudioRecorder();

  const [recordingTime, setRecordingTime] = useState(0);
  const recordingInterval = useRef<NodeJS.Timeout | null>(null);

  const [serviceHealth, setServiceHealth] = useState<AudioServiceHealthStatus>(
    audioServiceHealth.getStatus(),
  );
  const [isServiceAvailable, setIsServiceAvailable] = useState(false);
  const [isServerReady, setIsServerReady] = useState(false);

  const scaleAnim = useRef(new Animated.Value(1)).current;
  const rotateAnim = useRef(new Animated.Value(0)).current;
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const waveAnim1 = useRef(new Animated.Value(0.8)).current;
  const waveAnim2 = useRef(new Animated.Value(0.8)).current;
  const waveAnim3 = useRef(new Animated.Value(0.8)).current;
  const bounceAnim = useRef(new Animated.Value(0)).current;
  const glowAnim = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    const checkServerConnection = () => {
      const connectionState = serverConnectionService.getState();
      const ready = connectionState.isConnected && !!connectionState.currentUrl;
      setIsServerReady(ready);
    };

    checkServerConnection();

    const unsubscribeServer = serverConnectionService.subscribe(
      checkServerConnection,
    );

    return unsubscribeServer;
  }, []);

  useEffect(() => {
    if (!isServerReady) return;

    const unsubscribe = audioServiceHealth.subscribe((status) => {
      setServiceHealth(status);
      setIsServiceAvailable(status.isAvailable);
    });

    audioServiceHealth.startPeriodicCheck();

    return () => {
      unsubscribe();
      audioServiceHealth.stopPeriodicCheck();
    };
  }, [isServerReady]);

  useEffect(() => {
    Animated.spring(bounceAnim, {
      toValue: 1,
      friction: 4,
      tension: 40,
      useNativeDriver: true,
    }).start();
  }, [bounceAnim]);

  useEffect(() => {
    if (isRecording) {
      recordingInterval.current = setInterval(() => {
        setRecordingTime((prev) => prev + 1);
      }, 1000);

      const wave1 = Animated.loop(
        Animated.sequence([
          Animated.timing(waveAnim1, {
            toValue: 1.5,
            duration: 2000,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
          Animated.timing(waveAnim1, {
            toValue: 0.8,
            duration: 2000,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
        ]),
      );

      const wave2 = Animated.loop(
        Animated.sequence([
          Animated.timing(waveAnim2, {
            toValue: 1.8,
            duration: 2500,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
          Animated.timing(waveAnim2, {
            toValue: 0.8,
            duration: 2500,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
        ]),
      );

      const wave3 = Animated.loop(
        Animated.sequence([
          Animated.timing(waveAnim3, {
            toValue: 2.1,
            duration: 3000,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
          Animated.timing(waveAnim3, {
            toValue: 0.8,
            duration: 3000,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
        ]),
      );

      const glow = Animated.loop(
        Animated.sequence([
          Animated.timing(glowAnim, {
            toValue: 1,
            duration: 1500,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
          Animated.timing(glowAnim, {
            toValue: 0,
            duration: 1500,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
        ]),
      );

      wave1.start();
      wave2.start();
      wave3.start();
      glow.start();

      Animated.timing(fadeAnim, {
        toValue: 1,
        duration: 300,
        useNativeDriver: true,
      }).start();

      return () => {
        wave1.stop();
        wave2.stop();
        wave3.stop();
        glow.stop();
        if (recordingInterval.current) {
          clearInterval(recordingInterval.current);
        }
        setRecordingTime(0);
      };
    } else {
      Animated.timing(fadeAnim, {
        toValue: 0,
        duration: 300,
        useNativeDriver: true,
      }).start();
      waveAnim1.setValue(0.8);
      waveAnim2.setValue(0.8);
      waveAnim3.setValue(0.8);
      glowAnim.setValue(0);
    }
  }, [isRecording, fadeAnim, glowAnim, waveAnim1, waveAnim2, waveAnim3]);

  useEffect(() => {
    if (isProcessing || isPreparing) {
      const spin = Animated.loop(
        Animated.timing(rotateAnim, {
          toValue: 1,
          duration: 1500,
          easing: Easing.bezier(0.645, 0.045, 0.355, 1),
          useNativeDriver: true,
        }),
      );
      spin.start();
      return () => {
        spin.stop();
        rotateAnim.setValue(0);
      };
    }
  }, [isProcessing, isPreparing, rotateAnim]);

  const hasCompletedRef = useRef(false);

  useEffect(() => {
    if (
      audioUri &&
      transcription &&
      !isProcessing &&
      !hasCompletedRef.current
    ) {
      hasCompletedRef.current = true;

      resetRecording();

      onRecordingComplete(audioUri, transcription);

      setTimeout(() => {
        hasCompletedRef.current = false;
      }, 1000);
    }
  }, [
    audioUri,
    transcription,
    isProcessing,
    onRecordingComplete,
    resetRecording,
  ]);

  useEffect(() => {
    if (error) {
      onError(error);
    }
  }, [error, onError]);

  const handlePress = async () => {
    if (!isServiceAvailable) {
      Animated.sequence([
        Animated.timing(scaleAnim, {
          toValue: 1.1,
          duration: 100,
          useNativeDriver: true,
        }),
        Animated.timing(scaleAnim, {
          toValue: 0.9,
          duration: 100,
          useNativeDriver: true,
        }),
        Animated.timing(scaleAnim, {
          toValue: 1.1,
          duration: 100,
          useNativeDriver: true,
        }),
        Animated.timing(scaleAnim, {
          toValue: 1,
          duration: 100,
          useNativeDriver: true,
        }),
      ]).start();

      onError(serviceHealth.message || 'Servicio de voz no disponible');
      return;
    }

    if (isProcessing || isPreparing) {
      return;
    }

    Animated.sequence([
      Animated.spring(scaleAnim, {
        toValue: 0.85,
        friction: 3,
        tension: 40,
        useNativeDriver: true,
      }),
      Animated.spring(scaleAnim, {
        toValue: 1,
        friction: 3,
        tension: 40,
        useNativeDriver: true,
      }),
    ]).start();

    try {
      if (isRecording) {
        await stopRecording();
      } else {
        await startRecording();
      }
    } catch (err) {}
  };

  const rotateInterpolate = rotateAnim.interpolate({
    inputRange: [0, 1],
    outputRange: ['0deg', '360deg'],
  });

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
  };

  const getIcon = () => {
    if (isRecording) {
      return <MaterialIcons name="stop" size={30} color="white" />;
    }
    return <MaterialIcons name="mic" size={30} color="white" />;
  };

  const getBackgroundColor = () => {
    if (!isServiceAvailable) return '#B0B0B0';
    if (isProcessing || isPreparing) return theme.colors.secondary;
    if (isRecording) return RECORDING_COLOR;
    return theme.colors.primary;
  };

  return (
    <Animated.View
      style={[
        styles.container,
        {
          transform: [
            {
              translateY: bounceAnim.interpolate({
                inputRange: [0, 1],
                outputRange: [100, 0],
              }),
            },
            { scale: bounceAnim },
          ],
          opacity: bounceAnim.interpolate({
            inputRange: [0, 1],
            outputRange: [0, isServiceAvailable ? 1 : 0.8],
          }),
        },
      ]}
    >
      {/* Ondas animadas de fondo */}
      {isRecording && (
        <View style={styles.wavesContainer}>
          <Animated.View
            style={[
              styles.wave,
              {
                transform: [{ scale: waveAnim1 }],
                opacity: fadeAnim.interpolate({
                  inputRange: [0, 1],
                  outputRange: [0, 0.1],
                }),
                backgroundColor: theme.colors.primary,
              },
            ]}
          />
          <Animated.View
            style={[
              styles.wave,
              {
                transform: [{ scale: waveAnim2 }],
                opacity: fadeAnim.interpolate({
                  inputRange: [0, 1],
                  outputRange: [0, 0.15],
                }),
                backgroundColor: theme.colors.primary,
              },
            ]}
          />
          <Animated.View
            style={[
              styles.wave,
              {
                transform: [{ scale: waveAnim3 }],
                opacity: fadeAnim.interpolate({
                  inputRange: [0, 1],
                  outputRange: [0, 0.2],
                }),
                backgroundColor: theme.colors.primary,
              },
            ]}
          />
        </View>
      )}

      {/* Contador de tiempo */}
      {isRecording && (
        <Animated.View
          style={[
            styles.timerContainer,
            {
              opacity: fadeAnim,
              transform: [
                {
                  translateY: fadeAnim.interpolate({
                    inputRange: [0, 1],
                    outputRange: [-10, 0],
                  }),
                },
              ],
            },
          ]}
        >
          <View style={[styles.timerBadge, styles.timerBadgeRecording]}>
            <View style={styles.recordingDot} />
            <Text style={styles.timerText}>{formatTime(recordingTime)}</Text>
          </View>
        </Animated.View>
      )}

      {/* Indicador de servicio no disponible */}
      {!isServiceAvailable && (
        <View
          style={[
            styles.disabledIndicator,
            { backgroundColor: theme.colors.error },
          ]}
        >
          <MaterialIcons name="cloud-off" size={14} color="white" />
        </View>
      )}

      <TouchableOpacity
        onPress={handlePress}
        disabled={isProcessing || isPreparing || !isServiceAvailable}
        activeOpacity={0.9}
      >
        <Animated.View
          style={[
            styles.buttonContainer,
            {
              transform: [{ scale: scaleAnim }],
            },
          ]}
        >
          {/* Brillo de fondo cuando graba */}
          {isRecording && (
            <Animated.View
              style={[
                styles.glowEffect,
                styles.glowRecording,
                {
                  opacity: glowAnim.interpolate({
                    inputRange: [0, 1],
                    outputRange: [0.3, 0.6],
                  }),
                  transform: [
                    {
                      scale: glowAnim.interpolate({
                        inputRange: [0, 1],
                        outputRange: [1, 1.2],
                      }),
                    },
                  ],
                },
              ]}
            />
          )}

          <View
            style={[
              styles.button,
              {
                backgroundColor: getBackgroundColor(),
                ...Platform.select({
                  web: {
                    boxShadow: !isServiceAvailable
                      ? 'none'
                      : isRecording
                        ? '0px 2px 8px rgba(255, 59, 48, 0.4)'
                        : `0px 2px 8px ${theme.colors.primary}40`,
                  },
                  default: {
                    shadowColor: !isServiceAvailable
                      ? 'transparent'
                      : isRecording
                        ? RECORDING_COLOR
                        : theme.colors.primary,
                    shadowOpacity: !isServiceAvailable
                      ? 0
                      : isRecording
                        ? 0.4
                        : 0.25,
                  },
                }),
              },
            ]}
          >
            {isProcessing || isPreparing ? (
              <Animated.View
                style={{
                  transform: [{ rotate: rotateInterpolate }],
                }}
              >
                <MaterialCommunityIcons name="brain" size={30} color="white" />
              </Animated.View>
            ) : (
              getIcon()
            )}
          </View>
        </Animated.View>
      </TouchableOpacity>
    </Animated.View>
  );
};

const RECORDING_COLOR = '#FF3B30';

const styles = StyleSheet.create({
  container: {
    position: 'absolute',
    bottom: 30,
    right: 20,
    alignItems: 'center',
    justifyContent: 'center',
  },
  wavesContainer: {
    position: 'absolute',
    alignItems: 'center',
    justifyContent: 'center',
  },
  wave: {
    position: 'absolute',
    width: 120,
    height: 120,
    borderRadius: 60,
  },
  buttonContainer: {
    alignItems: 'center',
    justifyContent: 'center',
  },
  button: {
    width: 72,
    height: 72,
    borderRadius: 36,
    alignItems: 'center',
    justifyContent: 'center',
    elevation: 8,
    ...Platform.select({
      web: {
        boxShadow: '0px 2px 8px rgba(0, 0, 0, 0.25)',
      },
      default: {
        shadowOffset: { width: 0, height: 2 },
        shadowRadius: 8,
      },
    }),
    zIndex: 10,
  },
  glowEffect: {
    position: 'absolute',
    width: 80,
    height: 80,
    borderRadius: 40,
    zIndex: 5,
  },
  timerContainer: {
    position: 'absolute',
    top: -45,
    alignItems: 'center',
  },
  timerBadge: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 20,
    gap: 6,
  },
  recordingDot: {
    width: 6,
    height: 6,
    borderRadius: 3,
    backgroundColor: 'white',
    opacity: 0.9,
  },
  timerText: {
    color: 'white',
    fontSize: 12,
    fontWeight: '600',
  },
  disabledIndicator: {
    position: 'absolute',
    top: 0,
    right: 0,
    width: 26,
    height: 26,
    borderRadius: 13,
    alignItems: 'center',
    justifyContent: 'center',
    zIndex: 20,
    elevation: 12,
    borderWidth: 2,
    borderColor: 'white',
  },
  timerBadgeRecording: {
    backgroundColor: RECORDING_COLOR,
  },
  glowRecording: {
    backgroundColor: RECORDING_COLOR,
  },
});

================
File: app/src/modules/areasTables/hooks/useAreasQueries.ts
================
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { areaService } from '../services/areaService';
import {
  Area,
  CreateAreaDto,
  UpdateAreaDto,
  FindAllAreasDto,
} from '../schema/area.schema';
import { BaseListQuery } from '../../../app/types/query.types';
import { useSnackbarStore } from '../../../app/store/snackbarStore';
import { getApiErrorMessage } from '../../../app/lib/errorMapping';

const areasQueryKeys = {
  all: ['areas'] as const,
  lists: () => [...areasQueryKeys.all, 'list'] as const,
  list: (filters: FindAllAreasDto & BaseListQuery) =>
    [...areasQueryKeys.lists(), filters] as const,
  details: () => [...areasQueryKeys.all, 'detail'] as const,
  detail: (id: string) => [...areasQueryKeys.details(), id] as const,
};

export const useGetAreas = (
  filters: FindAllAreasDto = {},
  pagination: BaseListQuery = { page: 1, limit: 10 },
) => {
  const queryKey = areasQueryKeys.list({ ...filters, ...pagination });
  return useQuery<Area[], Error>({
    queryKey,
    queryFn: () => areaService.getAreas(filters, pagination),
  });
};

export const useGetAreaById = (
  id: string | null,
  options?: { enabled?: boolean },
) => {
  const queryKey = areasQueryKeys.detail(id!); // Use non-null assertion as it's enabled conditionally
  return useQuery<Area, Error>({
    queryKey,
    queryFn: () => areaService.getAreaById(id!),
    enabled: !!id && (options?.enabled ?? true),
  });
};

export const useCreateArea = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  return useMutation<Area, Error, CreateAreaDto>({
    mutationFn: areaService.createArea,
    onSuccess: (_newArea) => {
      queryClient.invalidateQueries({ queryKey: areasQueryKeys.lists() });
      showSnackbar({ message: 'rea creada con xito', type: 'success' });
    },
    onError: (error) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });
    },
  });
};

export const useUpdateArea = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  type UpdateAreaContext = { previousAreas?: Area[]; previousDetail?: Area };

  return useMutation<
    Area,
    Error,
    { id: string; data: UpdateAreaDto },
    UpdateAreaContext
  >({
    mutationFn: ({ id, data }) => areaService.updateArea(id, data),

    onMutate: async (variables) => {
      const { id, data } = variables;
      const listQueryKey = areasQueryKeys.lists();
      const detailQueryKey = areasQueryKeys.detail(id);

      await queryClient.cancelQueries({ queryKey: listQueryKey });
      await queryClient.cancelQueries({ queryKey: detailQueryKey });

      const previousAreas = queryClient.getQueryData<Area[]>(listQueryKey);
      const previousDetail = queryClient.getQueryData<Area>(detailQueryKey);

      if (previousAreas) {
        queryClient.setQueryData<Area[]>(
          listQueryKey,
          (old) =>
            old?.map((area) =>
              area.id === id ? { ...area, ...data } : area,
            ) ?? [],
        );
      }

      if (previousDetail) {
        queryClient.setQueryData<Area>(
          detailQueryKey,
          (old: Area | undefined) => (old ? { ...old, ...data } : undefined),
        );
      }

      return { previousAreas, previousDetail };
    },

    onError: (error, variables, context) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });

      if (context?.previousAreas) {
        queryClient.setQueryData(areasQueryKeys.lists(), context.previousAreas);
      }
      if (context?.previousDetail) {
        queryClient.setQueryData(
          areasQueryKeys.detail(variables.id),
          context.previousDetail,
        );
      }
    },

    onSettled: (data, error, variables, _context) => {
      queryClient.invalidateQueries({ queryKey: areasQueryKeys.lists() });
      queryClient.invalidateQueries({
        queryKey: areasQueryKeys.detail(variables.id),
      });

      if (!error && data) {
        showSnackbar({
          message: 'rea actualizada con xito',
          type: 'success',
        });
      }
    },
  });
};

export const useDeleteArea = () => {
  const queryClient = useQueryClient();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  type DeleteAreaContext = { previousDetail?: Area };

  return useMutation<void, Error, string, DeleteAreaContext>({
    mutationFn: areaService.deleteArea,

    onMutate: async (deletedId) => {
      const detailQueryKey = areasQueryKeys.detail(deletedId);

      await queryClient.cancelQueries({ queryKey: detailQueryKey });

      const previousDetail = queryClient.getQueryData<Area>(detailQueryKey);

      queryClient.removeQueries({ queryKey: detailQueryKey });

      return { previousDetail };
    },

    onError: (error, deletedId, context) => {
      const errorMessage = getApiErrorMessage(error);
      showSnackbar({ message: errorMessage, type: 'error' });

      if (context?.previousDetail) {
        queryClient.setQueryData(
          areasQueryKeys.detail(deletedId),
          context.previousDetail,
        );
      }
    },

    onSettled: (_data, error, deletedId) => {
      queryClient.invalidateQueries({ queryKey: areasQueryKeys.lists() });
      if (!error) {
        queryClient.removeQueries({
          queryKey: areasQueryKeys.detail(deletedId),
        });
        showSnackbar({ message: 'rea eliminada con xito', type: 'success' });
      }
    },
  });
};

================
File: app/src/modules/areasTables/screens/TablesScreen.tsx
================
import React, { useMemo, useCallback } from 'react';
import { StyleSheet } from 'react-native';
import { Text } from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useDrawerStatus } from '@react-navigation/drawer';

import GenericList, {
  RenderItemConfig,
  FilterOption,
} from '../../../app/components/crud/GenericList';
import GenericDetailModal, {
  DisplayFieldConfig,
} from '../../../app/components/crud/GenericDetailModal';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { useResponsive } from '../../../app/hooks/useResponsive';
import { useCrudScreenLogic } from '../../../app/hooks/useCrudScreenLogic';
import { useListState } from '../../../app/hooks/useListState';
import { useRefreshModuleOnFocus } from '../../../app/hooks/useRefreshOnFocus';

import TableFormModal from '../components/TableFormModal';
import {
  useGetTablesByAreaId,
  useCreateTable,
  useUpdateTable,
  useDeleteTable,
} from '../hooks/useTablesQueries';
import { Table, CreateTableDto, UpdateTableDto } from '../schema/table.schema';
import { TablesListScreenProps } from '../navigation/types';

const TablesScreen: React.FC<TablesListScreenProps> = ({ route }) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => getStyles(theme, responsive),
    [theme, responsive],
  );
  const { areaId, areaName } = route.params;
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';

  const [searchQuery, setSearchQuery] = React.useState('');
  const [filterStatus, setFilterStatus] = React.useState<string>('all');

  const {
    data: tablesData = [],
    isLoading: isLoadingTables,
    isError: isErrorTables,
    refetch: refetchTables,
    isRefetching,
  } = useGetTablesByAreaId(
    areaId,
    {
      name: searchQuery || undefined,
      isActive: filterStatus === 'all' ? undefined : filterStatus === 'true',
    },
    { enabled: !!areaId },
  );

  useRefreshModuleOnFocus('tables');

  const createTableMutation = useCreateTable();
  const updateTableMutation = useUpdateTable();
  const { mutateAsync: deleteTable } = useDeleteTable();

  const {
    isFormModalVisible,
    isDetailModalVisible,
    editingItem,
    selectedItem,
    isDeleting,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
    deleteConfirmation,
  } = useCrudScreenLogic<Table & { id: string }>({
    entityName: 'Mesa',
    queryKey: [
      'tables',
      'list',
      {
        areaId,
        name: searchQuery || undefined,
        isActive: filterStatus === 'all' ? undefined : filterStatus === 'true',
      },
    ],
    deleteMutationFn: deleteTable,
  });

  const isSubmitting =
    createTableMutation.isPending || updateTableMutation.isPending;

  const handleFormSubmit = async (data: CreateTableDto | UpdateTableDto) => {
    try {
      const dataWithAreaId = { ...data, areaId: areaId };

      if (editingItem) {
        await updateTableMutation.mutateAsync({
          id: editingItem.id,
          data: dataWithAreaId as UpdateTableDto,
        });
      } else {
        await createTableMutation.mutateAsync(dataWithAreaId as CreateTableDto);
      }
      handleCloseModals();
    } catch (error) {
      // Error handled by mutation
    }
  };

  const listRenderConfig: RenderItemConfig<Table> = useMemo(
    () => ({
      titleField: 'name',
      descriptionField: 'capacity',
      descriptionFormatter: (capacity) =>
        capacity
          ? `Capacidad: ${capacity} ${capacity === 1 ? 'persona' : 'personas'}`
          : undefined,
      descriptionMaxLength: 30,
      statusConfig: {
        field: 'isActive',
        activeValue: true,
        activeLabel: 'Activa',
        inactiveLabel: 'Inactiva',
      },
    }),
    [],
  );

  const tableDetailFields: DisplayFieldConfig<Table>[] = useMemo(
    () => [
      {
        field: 'capacity',
        label: 'Capacidad',
        render: (value) => (
          <Text style={styles.fieldValueText}>
            {value !== null && value !== undefined
              ? String(value)
              : 'No especificada'}
          </Text>
        ),
      },
    ],
    [styles.fieldValueText],
  );

  const tableDetailStatusConfig = listRenderConfig.statusConfig;

  const filterOptions: FilterOption<string>[] = useMemo(
    () => [
      { label: 'Todas', value: 'all' },
      { label: 'Activas', value: 'true' },
      { label: 'Inactivas', value: 'false' },
    ],
    [],
  );

  const handleFilterChange = (value: string | number) => {
    setFilterStatus(String(value));
  };

  const handleSearchChange = (query: string) => {
    setSearchQuery(query);
  };

  const handleRefresh = useCallback(() => {
    setSearchQuery('');
    setFilterStatus('all');
    refetchTables();
  }, [refetchTables]);


  const { ListEmptyComponent } = useListState({
    isLoading: isLoadingTables,
    isError: isErrorTables,
    data: tablesData,
    emptyConfig: {
      title: 'No hay mesas',
      message: `No hay mesas registradas en ${areaName}. Presiona el botn + para crear la primera.`,
      icon: 'table-furniture',
    },
    errorConfig: {
      title: 'Error al cargar mesas',
      message: 'No se pudieron cargar las mesas. Verifica tu conexin.',
      icon: 'alert-circle-outline',
      onAction: refetchTables,
    },
  });

  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      <GenericList<Table>
        items={tablesData}
        renderConfig={listRenderConfig}
        onItemPress={handleOpenDetailModal}
        onRefresh={handleRefresh}
        isRefreshing={isRefetching}
        ListEmptyComponent={ListEmptyComponent}
        enableSearch={true}
        searchQuery={searchQuery}
        onSearchChange={handleSearchChange}
        filterOptions={filterOptions}
        filterValue={filterStatus}
        onFilterChange={handleFilterChange}
        showFab={true}
        onFabPress={handleOpenCreateModal}
        isModalOpen={isFormModalVisible || isDetailModalVisible}
        showImagePlaceholder={false}
        isDrawerOpen={isDrawerOpen}
      />

      <TableFormModal
        visible={isFormModalVisible}
        onDismiss={handleCloseModals}
        onSubmit={handleFormSubmit}
        editingItem={editingItem}
        isSubmitting={isSubmitting}
      />

      <GenericDetailModal<Table>
        visible={isDetailModalVisible}
        onDismiss={handleCloseModals}
        item={selectedItem}
        titleField="name"
        statusConfig={tableDetailStatusConfig}
        fieldsToDisplay={tableDetailFields}
        onEdit={() => {
          if (selectedItem) {
            handleOpenEditModal(selectedItem);
          }
        }}
        deleteConfirmation={deleteConfirmation}
        isDeleting={isDeleting}
        showImage={false}
      />
    </SafeAreaView>
  );
};

const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    fieldValueText: {
      flexShrink: 1,
      textAlign: 'right',
      color: theme.colors.onSurface,
      fontSize: responsive.fontSize(14),
    },
  });

export default TablesScreen;

================
File: app/src/modules/auth/components/RegisterForm.tsx
================
import { useState } from 'react';
import { View, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';
import {
  Portal,
  Modal,
  Text,
  TextInput,
  Button,
  HelperText,
  Surface,
  IconButton,
  Chip,
  Avatar,
  Divider,
  Icon,
} from 'react-native-paper';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useMutation } from '@tanstack/react-query';
import { authService } from '../services/authService';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { getApiErrorMessage } from '@/app/lib/errorMapping';
import { registerSchema, RegisterFormInputs } from '../schema/auth.schema';

interface RegisterModalProps {
  visible: boolean;
  onDismiss: () => void;
  onRegisterSuccess?: (username: string, password: string) => void;
}

export function RegisterModal({
  visible,
  onDismiss,
  onRegisterSuccess,
}: RegisterModalProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = getStyles(theme, responsive);
  const [showPassword, setShowPassword] = useState(false);
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const {
    control,
    handleSubmit,
    formState: { errors },
    reset,
  } = useForm<RegisterFormInputs>({
    resolver: zodResolver(registerSchema),
    defaultValues: {
      username: '',
      email: '',
      password: '',
      firstName: '',
      lastName: '',
      phoneNumber: '',
      role: 4, // Default a Mesero
    },
  });

  const { mutate: register, isPending } = useMutation({
    mutationFn: (data: RegisterFormInputs) => {
      const registerData = {
        username: data.username,
        email: data.email,
        password: data.password,
        firstName: data.firstName,
        lastName: data.lastName,
        phoneNumber: data.phoneNumber || undefined,
        role: { id: data.role },
        isActive: true,
      };
      return authService.register(registerData);
    },
    onSuccess: (_, variables) => {
      showSnackbar({
        message: 'Registro exitoso. Ya puedes iniciar sesin.',
        type: 'success',
      });

      // Pasar los datos al formulario de login
      if (onRegisterSuccess) {
        onRegisterSuccess(variables.username, variables.password);
      }

      reset();
      onDismiss();
    },
    onError: (error: unknown) => {
      const userMessage = getApiErrorMessage(error);
      showSnackbar({
        message: userMessage,
        type: 'error',
        duration: 5000,
      });
    },
  });

  const onSubmit = (data: RegisterFormInputs) => {
    register(data);
  };

  const handleDismiss = () => {
    reset();
    setShowPassword(false);
    onDismiss();
  };

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={handleDismiss}
        contentContainerStyle={styles.modalContainer}
      >
        <Surface style={styles.modalContent} elevation={5}>
          <View
            style={[
              styles.headerContainer,
              { backgroundColor: theme.colors.primary },
            ]}
          >
            <View style={styles.headerLeft}>
              <Avatar.Icon
                size={32}
                icon="account-plus"
                style={[
                  styles.headerIcon,
                  { backgroundColor: theme.colors.onPrimary + '20' },
                ]}
                color={theme.colors.onPrimary}
              />
              <View style={styles.headerTextContainer}>
                <Text
                  style={[styles.modalTitle, { color: theme.colors.onPrimary }]}
                  variant="titleMedium"
                >
                  Crear cuenta
                </Text>
              </View>
            </View>
            <IconButton
              icon="close"
              size={24}
              onPress={handleDismiss}
              disabled={isPending}
              iconColor={theme.colors.onPrimary}
            />
          </View>

          <ScrollView
            style={styles.formContainer}
            showsVerticalScrollIndicator={false}
            keyboardShouldPersistTaps="handled"
          >
            <View style={styles.sectionContainer}>
              <View style={styles.sectionHeader}>
                <Icon
                  source="account-key"
                  size={20}
                  color={theme.colors.primary}
                />
                <Text style={styles.sectionTitle} variant="titleMedium">
                  Informacin de Cuenta
                </Text>
                <Chip
                  mode="flat"
                  compact
                  icon="check"
                  style={styles.requiredChip}
                  textStyle={styles.requiredChipText}
                >
                  Requerido
                </Chip>
              </View>

              <Controller
                control={control}
                name="username"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Nombre de usuario"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.username}
                      mode="outlined"
                      placeholder="usuario123"
                      autoCapitalize="none"
                      left={<TextInput.Icon icon="account" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.username && (
                      <HelperText type="error" visible={!!errors.username}>
                        {errors.username.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />

              <Controller
                control={control}
                name="email"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Email"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.email}
                      mode="outlined"
                      placeholder="usuario@ejemplo.com"
                      keyboardType="email-address"
                      autoCapitalize="none"
                      left={<TextInput.Icon icon="email" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.email && (
                      <HelperText type="error" visible={!!errors.email}>
                        {errors.email.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />

              <Controller
                control={control}
                name="password"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Contrasea"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.password}
                      mode="outlined"
                      placeholder=""
                      secureTextEntry={!showPassword}
                      autoCapitalize="none"
                      left={<TextInput.Icon icon="lock" />}
                      right={
                        <TextInput.Icon
                          icon={showPassword ? 'eye-off' : 'eye'}
                          onPress={() => setShowPassword(!showPassword)}
                        />
                      }
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.password && (
                      <HelperText type="error" visible={!!errors.password}>
                        {errors.password.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />

              <Controller
                control={control}
                name="role"
                render={({ field: { onChange, value } }) => (
                  <View style={styles.inputContainer}>
                    <View style={styles.fieldLabelContainer}>
                      <Icon
                        source="badge-account"
                        size={20}
                        color={theme.colors.primary}
                      />
                      <Text style={styles.sectionTitle} variant="titleMedium">
                        Tipo de cuenta
                      </Text>
                    </View>
                    <View style={styles.rolesContainer}>
                      {[
                        {
                          value: 4,
                          label: 'Mesero',
                          icon: 'room-service',
                          description: 'Tomar y gestionar rdenes',
                        },
                        {
                          value: 6,
                          label: 'Repartidor',
                          icon: 'moped',
                          description: 'Entregar pedidos',
                        },
                      ].map((role) => (
                        <Surface
                          key={role.value}
                          style={[
                            styles.roleCard,
                            value === role.value && styles.roleCardActive,
                          ]}
                          elevation={value === role.value ? 2 : 0}
                        >
                          <TouchableOpacity
                            onPress={() => onChange(role.value)}
                            style={styles.roleCardContent}
                          >
                            <Icon
                              source={role.icon}
                              size={24}
                              color={
                                value === role.value
                                  ? theme.colors.primary
                                  : theme.colors.onSurfaceVariant
                              }
                            />
                            <Text
                              style={[
                                styles.roleLabel,
                                value === role.value && styles.roleLabelActive,
                              ]}
                              variant="labelMedium"
                            >
                              {role.label}
                            </Text>
                            <Text
                              style={styles.roleDescription}
                              variant="bodySmall"
                              numberOfLines={2}
                            >
                              {role.description}
                            </Text>
                          </TouchableOpacity>
                        </Surface>
                      ))}
                    </View>
                  </View>
                )}
              />
            </View>

            <Divider style={styles.divider} />

            <View style={styles.sectionContainer}>
              <View style={styles.sectionHeader}>
                <Icon
                  source="account-circle"
                  size={20}
                  color={theme.colors.primary}
                />
                <Text style={styles.sectionTitle} variant="titleMedium">
                  Informacin Personal
                </Text>
                <Chip
                  mode="flat"
                  compact
                  icon="check"
                  style={styles.requiredChip}
                  textStyle={styles.requiredChipText}
                >
                  Requerido
                </Chip>
              </View>

              <Controller
                control={control}
                name="firstName"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Nombre"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.firstName}
                      mode="outlined"
                      placeholder="Juan"
                      left={<TextInput.Icon icon="account" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.firstName && (
                      <HelperText type="error" visible={!!errors.firstName}>
                        {errors.firstName.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />

              <Controller
                control={control}
                name="lastName"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Apellido"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.lastName}
                      mode="outlined"
                      placeholder="Prez"
                      left={<TextInput.Icon icon="account" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.lastName && (
                      <HelperText type="error" visible={!!errors.lastName}>
                        {errors.lastName.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />

              <Controller
                control={control}
                name="phoneNumber"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Telfono (opcional)"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.phoneNumber}
                      mode="outlined"
                      placeholder="+52 55 1234 5678"
                      keyboardType="phone-pad"
                      left={<TextInput.Icon icon="phone" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.phoneNumber && (
                      <HelperText type="error" visible={!!errors.phoneNumber}>
                        {errors.phoneNumber.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />
            </View>
          </ScrollView>

          <Surface style={styles.buttonContainer} elevation={2}>
            <Button
              onPress={handleDismiss}
              disabled={isPending}
              style={[styles.button, styles.cancelButton]}
              textColor={theme.colors.onSecondaryContainer}
            >
              Cancelar
            </Button>
            <Button
              mode="contained"
              onPress={handleSubmit(onSubmit)}
              disabled={isPending}
              loading={isPending}
              style={styles.button}
              buttonColor={theme.colors.primary}
            >
              Registrarse
            </Button>
          </Surface>
        </Surface>
      </Modal>
    </Portal>
  );
}

const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    modalContainer: {
      margin: responsive.isTablet ? 20 : 12,
      maxWidth: responsive.isTablet ? 600 : '100%',
      alignSelf: 'center',
      width: responsive.isTablet ? '80%' : '94%',
    },
    modalContent: {
      borderRadius: responsive.isTablet
        ? theme.roundness * 3
        : theme.roundness * 2,
      backgroundColor: theme.colors.surface,
      maxHeight: responsive.isTablet ? '90%' : '92%',
      minHeight: responsive.isTablet ? 600 : 550,
      overflow: 'hidden',
    },
    headerContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingHorizontal: responsive.spacingPreset.m,
      paddingVertical: responsive.spacingPreset.s,
      borderTopLeftRadius: theme.roundness * 3,
      borderTopRightRadius: theme.roundness * 3,
    },
    headerLeft: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
    },
    headerIcon: {
      marginRight: responsive.spacingPreset.s,
    },
    headerTextContainer: {
      flex: 1,
    },
    modalTitle: {
      fontWeight: '700',
    },
    formContainer: {
      flex: 1,
      paddingHorizontal: responsive.isTablet
        ? responsive.spacingPreset.m
        : responsive.spacingPreset.s,
      paddingTop: responsive.isTablet
        ? responsive.spacingPreset.s
        : responsive.spacingPreset.xs,
      paddingBottom: responsive.spacingPreset.xs,
    },
    sectionContainer: {
      marginBottom: responsive.isTablet
        ? responsive.spacingPreset.s
        : responsive.spacingPreset.xs,
    },
    sectionHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: responsive.isTablet ? responsive.spacingPreset.xs : 6,
      gap: responsive.isTablet ? responsive.spacingPreset.xs : 6,
    },
    sectionTitle: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: responsive.isTablet ? 14 : 13,
      flex: 1,
    },
    requiredChip: {
      backgroundColor: theme.colors.primary + '20',
      borderWidth: 1,
      borderColor: theme.colors.primary + '40',
    },
    requiredChipText: {
      color: theme.colors.primary,
      fontSize: responsive.isTablet ? 11 : 10,
      fontWeight: '600',
    },
    inputContainer: {
      marginBottom: responsive.isTablet ? responsive.spacingPreset.xs : 6,
    },
    inputOutline: {
      borderRadius: theme.roundness * 2,
      borderWidth: 1,
    },
    input: {
      fontSize: responsive.isTablet ? 14 : 13,
      backgroundColor: theme.colors.surface,
      height: responsive.isTablet ? 48 : 44,
    },
    inputContent: {
      paddingVertical: responsive.isTablet ? 4 : 2,
      fontSize: responsive.isTablet ? 14 : 13,
      fontFamily: 'System',
    },
    fieldLabelContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.isTablet ? responsive.spacingPreset.xs : 6,
      marginBottom: responsive.isTablet
        ? responsive.spacingPreset.s
        : responsive.spacingPreset.xs,
    },
    rolesContainer: {
      flexDirection: 'row',
      gap: responsive.isTablet
        ? responsive.spacingPreset.s
        : responsive.spacingPreset.xs,
      justifyContent: 'center',
    },
    roleCard: {
      borderRadius: theme.roundness * 2,
      padding: responsive.isTablet
        ? responsive.spacingPreset.s
        : responsive.spacingPreset.xs,
      backgroundColor: theme.colors.surface,
      minWidth: responsive.isTablet ? 140 : 125,
      borderWidth: 1.5,
      borderColor: theme.colors.outlineVariant,
      elevation: 1,
    },
    roleCardActive: {
      backgroundColor: theme.colors.primaryContainer,
      borderColor: theme.colors.primary,
      elevation: 3,
    },
    roleCardContent: {
      alignItems: 'center',
    },
    roleLabel: {
      color: theme.colors.onSurfaceVariant,
      marginTop: responsive.isTablet ? responsive.spacingPreset.xs : 4,
      fontWeight: '500',
      fontSize: responsive.isTablet ? 14 : 13,
    },
    roleLabelActive: {
      color: theme.colors.onPrimaryContainer,
      fontWeight: '700',
    },
    roleDescription: {
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
      fontSize: responsive.isTablet ? 11 : 10,
      textAlign: 'center',
    },
    divider: {
      marginVertical: responsive.isTablet
        ? responsive.spacingPreset.s
        : responsive.spacingPreset.xs,
      marginHorizontal: responsive.isTablet
        ? -responsive.spacingPreset.m
        : -responsive.spacingPreset.s,
    },
    buttonContainer: {
      flexDirection: 'row',
      justifyContent: 'center',
      padding: responsive.isTablet
        ? responsive.spacingPreset.s
        : responsive.spacingPreset.xs,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      gap: responsive.isTablet
        ? responsive.spacingPreset.s
        : responsive.spacingPreset.xs,
    },
    button: {
      flex: 1,
      maxWidth: responsive.isTablet ? 150 : 140,
    },
    cancelButton: {
      backgroundColor: theme.colors.secondaryContainer,
    },
  });

================
File: app/src/modules/auth/schema/auth.schema.ts
================
import { z } from 'zod';

export const loginSchema = z.object({
  emailOrUsername: z
    .string()
    .min(1, 'El correo o nombre de usuario es requerido'),
  password: z.string().min(6, 'La contrasea debe tener al menos 6 caracteres'),
});

export type LoginFormInputs = z.infer<typeof loginSchema>;

export const authEmailLoginDtoSchema = z.object({
  email: z.string().email().optional(),
  username: z.string().optional(),
  password: z.string(),
});
export type AuthEmailLoginDto = z.infer<typeof authEmailLoginDtoSchema>;

import { userSchema } from '../../../app/schemas/domain/user.schema';
export type { User } from '../../../app/schemas/domain/user.schema';
export { userSchema };

export const loginResponseDtoSchema = z.object({
  token: z.string(),
  refreshToken: z.string(),
  tokenExpires: z.number(),
  user: userSchema,
});
export type LoginResponseDto = z.infer<typeof loginResponseDtoSchema>;

export const registerSchema = z.object({
  email: z.string().email('Correo electrnico invlido').optional(),
  username: z
    .string()
    .min(3, 'El nombre de usuario debe tener al menos 3 caracteres')
    .max(20, 'El nombre de usuario no puede exceder 20 caracteres')
    .regex(/^[a-zA-Z0-9_]+$/, 'Solo se permiten letras, nmeros y guin bajo'),
  password: z.string().min(6, 'La contrasea debe tener al menos 6 caracteres'),
  firstName: z
    .string()
    .min(2, 'El nombre debe tener al menos 2 caracteres')
    .max(50, 'El nombre no puede exceder 50 caracteres'),
  lastName: z
    .string()
    .min(2, 'El apellido debe tener al menos 2 caracteres')
    .max(50, 'El apellido no puede exceder 50 caracteres'),
  phoneNumber: z
    .union([
      z.string().regex(/^\+?[0-9\s-]+$/, 'Nmero de telfono invlido'),
      z.literal(''),
    ])
    .optional(),
  role: z.number(),
});

export type RegisterFormInputs = z.infer<typeof registerSchema>;

================
File: app/src/modules/auth/services/authService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import {
  AuthEmailLoginDto,
  LoginResponseDto,
  LoginFormInputs,
} from '../schema/auth.schema';

async function login(loginData: LoginFormInputs): Promise<LoginResponseDto> {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  const isEmail = emailRegex.test(loginData.emailOrUsername);
  const sanitizedInput = loginData.emailOrUsername.trim().toLowerCase();

  const payload: AuthEmailLoginDto = {
    password: loginData.password,
    ...(isEmail ? { email: sanitizedInput } : { username: sanitizedInput }),
  };

  const response = await apiClient.post<LoginResponseDto>(
    API_PATHS.AUTH_EMAIL_LOGIN,
    payload,
  );

  return response.data;
}

interface RegisterData {
  username: string;
  email?: string;
  password: string;
  firstName: string;
  lastName: string;
  phoneNumber?: string;
  role: { id: number };
  isActive: boolean;
}

async function register(data: RegisterData): Promise<void> {
  await apiClient.post<{ message?: string }>(
    API_PATHS.AUTH_EMAIL_REGISTER,
    data,
  );
}

async function verifyToken(): Promise<boolean> {
  try {
    const response = await apiClient.get(API_PATHS.AUTH_ME);
    return response.status === 200;
  } catch (error) {
    return false;
  }
}

export const authService = {
  login,
  register,
  verifyToken,
};

================
File: app/src/modules/availability/components/CategoryAvailabilityItem.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, Switch, Divider, IconButton } from 'react-native-paper';
import { CategoryAvailability } from '../schema/availability.schema';
import { useOptimisticAvailability } from '../hooks/useOptimisticAvailability';
import { useAppTheme } from '@/app/styles/theme';
import { AvailabilityListItem } from './AvailabilityListItem';

interface CategoryAvailabilityItemProps {
  category: CategoryAvailability;
}

export const CategoryAvailabilityItem: React.FC<
  CategoryAvailabilityItemProps
> = ({ category }) => {
  const theme = useAppTheme();
  const [expanded, setExpanded] = useState(false);
  const updateAvailability = useOptimisticAvailability();

  const handleCategoryToggle = (value: boolean) => {
    updateAvailability.mutate({
      type: 'category',
      id: category.id,
      isActive: value,
      cascade: true,
    });
  };

  const handleSubcategoryToggle = (subcategoryId: string, value: boolean) => {
    updateAvailability.mutate({
      type: 'subcategory',
      id: subcategoryId,
      isActive: value,
      cascade: true,
    });
  };

  const handleProductToggle = (productId: string, value: boolean) => {
    updateAvailability.mutate({
      type: 'product',
      id: productId,
      isActive: value,
    });
  };

  const totalProducts = category.subcategories.reduce(
    (acc, sub) => acc + sub.products.length,
    0,
  );
  const activeProducts = category.subcategories.reduce(
    (acc, sub) => acc + sub.products.filter((p) => p.isActive).length,
    0,
  );

  return (
    <AvailabilityListItem
      title={category.name}
      subtitle={`${activeProducts}/${totalProducts} productos activos`}
      icon="folder-outline"
      isActive={category.isActive}
      onToggle={handleCategoryToggle}
      isExpanded={expanded}
      onToggleExpand={() => setExpanded(!expanded)}
    >
      {category.subcategories.map((subcategory, index) => (
        <View key={subcategory.id}>
          {index > 0 && <Divider style={styles.divider} />}
          <View
            style={[
              styles.subcategoryHeader,
              subcategory.isActive
                ? styles.activeSubcategory
                : styles.inactiveSubcategory,
            ]}
          >
            <View style={styles.subcategoryLeft}>
              <IconButton
                icon="folder-open-outline"
                size={16}
                iconColor={
                  subcategory.isActive
                    ? theme.colors.primary
                    : theme.colors.outline
                }
                style={styles.subcategoryIcon}
              />
              <Text
                style={[
                  styles.subcategoryTitle,
                  { color: theme.colors.onSurface },
                ]}
              >
                {subcategory.name}
              </Text>
            </View>
            <Switch
              value={subcategory.isActive}
              onValueChange={(value) =>
                handleSubcategoryToggle(subcategory.id, value)
              }
              disabled={!category.isActive}
            />
          </View>
          <View style={styles.productsContainer}>
            {subcategory.products.map((product) => (
              <View
                key={product.id}
                style={[
                  styles.productItem,
                  product.isActive
                    ? styles.activeProduct
                    : styles.inactiveProduct,
                ]}
              >
                <Text
                  style={[
                    styles.productTitle,
                    !product.isActive && styles.strikethrough,
                    { color: theme.colors.onSurface },
                  ]}
                >
                  {product.name}
                </Text>
                <Switch
                  value={product.isActive}
                  onValueChange={(value) =>
                    handleProductToggle(product.id, value)
                  }
                  disabled={!category.isActive || !subcategory.isActive}
                />
              </View>
            ))}
          </View>
        </View>
      ))}
    </AvailabilityListItem>
  );
};

const styles = StyleSheet.create({
  divider: {
    marginVertical: 8,
  },
  subcategoryHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 8,
  },
  subcategoryLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  subcategoryTitle: {
    fontSize: 14,
    fontWeight: '500',
  },
  productsContainer: {
    paddingLeft: 16,
  },
  productItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 4,
  },
  productTitle: {
    fontSize: 13,
  },
  strikethrough: {
    textDecorationLine: 'line-through',
  },
  activeSubcategory: {
    opacity: 1,
  },
  inactiveSubcategory: {
    opacity: 0.6,
  },
  subcategoryIcon: {
    margin: 0,
    marginRight: 8,
  },
  activeProduct: {
    opacity: 1,
  },
  inactiveProduct: {
    opacity: 0.5,
  },
});

================
File: app/src/modules/customers/schema/customer.schema.ts
================
import { z } from 'zod';

// Pure TypeScript interfaces that can't be represented by Zod
export interface ChatMessage {
  role: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: Date;
}

// Schema base para direccin
export const addressBaseSchema = z.object({
  name: z.string().min(1, 'El nombre de la direccin es requerido').max(100),
  street: z.string().min(1, 'La calle es requerida'),
  number: z.string().min(1, 'El nmero es requerido'),
  interiorNumber: z.string().optional(),
  neighborhood: z.string().optional(),
  city: z.string().optional(),
  state: z.string().optional(),
  zipCode: z.string().optional(),
  country: z.string().optional().default('Mxico'),
  deliveryInstructions: z.string().optional(),
  latitude: z.number().min(-90).max(90).optional(),
  longitude: z.number().min(-180).max(180).optional(),
  isDefault: z.boolean().optional(),
});

export const addressSchema = addressBaseSchema;

// Schema base para cliente con campos comunes
export const customerBaseSchema = z.object({
  firstName: z.string().min(1, 'El nombre es requerido').max(100),
  lastName: z.string().min(1, 'El apellido es requerido').max(100),
  whatsappPhoneNumber: z.string().min(1, 'El nmero de WhatsApp es requerido'),
  email: z
    .string()
    .email('El correo electrnico no es vlido')
    .optional()
    .or(z.literal(''))
    .transform((val) => (val === '' ? undefined : val)),
  birthDate: z
    .string()
    .regex(/^\d{4}-\d{2}-\d{2}$/, 'La fecha debe tener el formato YYYY-MM-DD')
    .optional()
    .or(z.literal(''))
    .transform((val) => (val === '' ? undefined : val)),
});

// Schema para crear cliente - derivado del base
export const createCustomerSchema = customerBaseSchema.extend({
  isActive: z.boolean().optional(),
  isBanned: z.boolean().optional(),
  addresses: z.array(addressBaseSchema).optional(),
});

// Schema para actualizar cliente - derivado del base con todos los campos opcionales
export const updateCustomerSchema = customerBaseSchema.partial().extend({
  isActive: z.boolean().optional(),
  isBanned: z.boolean().optional(),
  addresses: z.array(addressBaseSchema).optional(),
});

// Schema para formularios - derivado del schema de creacin con campos adicionales para UI
export const customerFormSchema = createCustomerSchema.extend({
  isActive: z.boolean().default(true),
  isBanned: z.boolean().default(false),
  banReason: z.string().optional().or(z.literal('')),
});

// Types derivados de los schemas
export type AddressFormInputs = z.infer<typeof addressSchema>;
export type CustomerFormInputs = z.infer<typeof customerFormSchema>;
export type CreateCustomerInput = z.infer<typeof createCustomerSchema>;
export type UpdateCustomerInput = z.infer<typeof updateCustomerSchema>;

// Schema completo para Address - derivado del base
export const addressEntitySchema = addressBaseSchema.extend({
  id: z.string().uuid(),
  customerId: z.string().uuid(),
  createdAt: z.date(),
  updatedAt: z.date(),
  deletedAt: z.date().nullable().optional(),
});

export type Address = z.infer<typeof addressEntitySchema>;

// Schema completo para Customer - derivado del base con campos adicionales
export const customerEntitySchema = customerBaseSchema
  .omit({ email: true, birthDate: true })
  .extend({
    id: z.string().uuid(),
    email: z.string().email().nullable().optional(),
    birthDate: z.date().nullable().optional(),
    stripeCustomerId: z.string().nullable().optional(),
    fullChatHistory: z.array(z.custom<ChatMessage>()).nullable().optional(),
    relevantChatHistory: z.array(z.custom<ChatMessage>()).nullable().optional(),
    lastInteraction: z.date().nullable().optional(),
    totalOrders: z.number().int().nonnegative(),
    totalSpent: z.number().nonnegative(),
    isActive: z.boolean(),
    isBanned: z.boolean(),
    bannedAt: z.date().nullable().optional(),
    banReason: z.string().nullable().optional(),
    whatsappMessageCount: z.number().int().nonnegative(),
    lastWhatsappMessageTime: z.date().nullable().optional(),
    addresses: z.array(addressEntitySchema),
    createdAt: z.date(),
    updatedAt: z.date(),
    deletedAt: z.date().nullable().optional(),
  });

export type Customer = z.infer<typeof customerEntitySchema>;

// Schema para FindAllCustomersQuery - derivado del base con campos de paginacin
export const findAllCustomersQuerySchema = customerBaseSchema
  .pick({
    firstName: true,
    lastName: true,
    email: true,
    whatsappPhoneNumber: true,
  })
  .partial()
  .extend({
    isActive: z.boolean().optional(),
    isBanned: z.boolean().optional(),
    lastInteractionAfter: z.date().optional(),
    page: z.number().int().positive().optional(),
    limit: z.number().int().positive().optional(),
  });

export type FindAllCustomersQuery = z.infer<typeof findAllCustomersQuerySchema>;

================
File: app/src/modules/customers/services/addressesService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import { Address, AddressFormInputs } from '../schema/customer.schema';

async function create(
  customerId: string,
  data: AddressFormInputs,
): Promise<Address> {
  const response = await apiClient.post<Address>(
    API_PATHS.ADDRESSES_BY_CUSTOMER.replace(':customerId', customerId),
    data,
  );
  return response.data;
}

async function update(
  addressId: string,
  data: Partial<AddressFormInputs>,
): Promise<Address> {
  const response = await apiClient.patch<Address>(
    API_PATHS.ADDRESSES_BY_ID.replace(':id', addressId),
    data,
  );
  return response.data;
}

async function remove(addressId: string): Promise<void> {
  await apiClient.delete(API_PATHS.ADDRESSES_BY_ID.replace(':id', addressId));
}

export const addressesService = {
  create,
  update,
  remove,
};

================
File: app/src/modules/kitchen/hooks/useKitchenOrders.ts
================
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { kitchenService } from '../services/kitchenService';
import { KitchenFilters } from '../schema/kitchen.schema';
import { useKitchenSnackbar } from './useKitchenSnackbar';

export const KITCHEN_ORDERS_KEY = 'kitchen-orders';

/**
 * Hook principal para obtener rdenes de cocina
 * Optimizado con refetch cada 30 segundos para balance entre actualizacin y rendimiento
 */
export function useKitchenOrders(filters: Partial<KitchenFilters> = {}) {
  return useQuery({
    queryKey: [KITCHEN_ORDERS_KEY, filters],
    queryFn: () => kitchenService.getKitchenOrders(filters),
    refetchInterval: 30000, // Refetch cada 30 segundos - balance ptimo
    refetchIntervalInBackground: false,
    refetchOnWindowFocus: true,
    refetchOnMount: true,
    staleTime: 25000, // Datos frescos por 25 segundos
    gcTime: 5 * 60 * 1000, // Cache por 5 minutos
    placeholderData: (previousData) => previousData, // Evitar parpadeos durante refetch
    notifyOnChangeProps: ['data', 'error'],
  });
}

/**
 * Hook para marcar items como preparados con actualizacin optimista granular
 * No invalida toda la query, solo actualiza el item especfico
 */
export function useUpdateKitchenItem() {
  const queryClient = useQueryClient();
  const { showError } = useKitchenSnackbar();

  const updateAllQueriesForItem = (itemId: string, isPrepared: boolean) => {
    const queryCache = queryClient.getQueryCache();
    const queries = queryCache.getAll();
    const previousData: any[] = [];

    queries.forEach((query) => {
      const queryKey = query.queryKey;
      if (Array.isArray(queryKey) && queryKey[0] === KITCHEN_ORDERS_KEY) {
        const oldData = query.state.data;
        if (oldData) {
          previousData.push([queryKey, oldData]);

          queryClient.setQueryData(queryKey, (old: any) => {
            if (!old || !Array.isArray(old)) return old;

            return old.map((order: any) => ({
              ...order,
              items: order.items?.map((item: any) =>
                item.id === itemId
                  ? {
                      ...item,
                      preparationStatus: isPrepared ? 'READY' : 'IN_PROGRESS',
                      preparedAt: isPrepared ? new Date().toISOString() : null,
                    }
                  : item,
              ),
            }));
          });
        }
      }
    });

    return previousData;
  };

  const rollbackAllQueries = (previousData: any[]) => {
    previousData.forEach(([queryKey, data]) => {
      queryClient.setQueryData(queryKey, data);
    });
  };

  return useMutation({
    mutationFn: ({
      itemId,
      isPrepared,
    }: {
      itemId: string;
      isPrepared: boolean;
    }) => kitchenService.markItemPrepared(itemId, isPrepared),

    onMutate: async ({ itemId, isPrepared }) => {
      await queryClient.cancelQueries({ queryKey: [KITCHEN_ORDERS_KEY] });
      const previousData = updateAllQueriesForItem(itemId, isPrepared);
      return { previousData };
    },

    onError: (error: any, _variables, context) => {
      if (context?.previousData) {
        rollbackAllQueries(context.previousData);
      }
      showError(error.response?.data?.message || 'Error al actualizar el item');
    },

    // NO invalidar inmediatamente - dejar que el background refetch se encargue
    onSettled: () => {
      // Invalidar despus de 2 segundos para permitir ver el cambio optimista
      setTimeout(() => {
        queryClient.invalidateQueries({
          queryKey: [KITCHEN_ORDERS_KEY],
          refetchType: 'none', // Solo marcar como stale, no refetch inmediato
        });
      }, 2000);
    },
  });
}

/**
 * Hook para iniciar preparacin de rdenes con actualizacin optimista granular
 */
export function useUpdateKitchenOrderStatus() {
  const queryClient = useQueryClient();
  const { showError } = useKitchenSnackbar();

  const updateAllQueriesForOrder = (
    orderId: string,
    status: string,
    extraUpdates?: any,
  ) => {
    const queryCache = queryClient.getQueryCache();
    const queries = queryCache.getAll();
    const previousData: any[] = [];

    queries.forEach((query) => {
      const queryKey = query.queryKey;
      if (Array.isArray(queryKey) && queryKey[0] === KITCHEN_ORDERS_KEY) {
        const oldData = query.state.data;
        if (oldData) {
          previousData.push([queryKey, oldData]);

          queryClient.setQueryData(queryKey, (old: any) => {
            if (!old || !Array.isArray(old)) return old;

            return old.map((order: any) =>
              order.id === orderId
                ? {
                    ...order,
                    myScreenStatus: status,
                    preparationStartedAt:
                      status === 'IN_PREPARATION'
                        ? new Date().toISOString()
                        : order.preparationStartedAt,
                    preparationCompletedAt:
                      status === 'READY'
                        ? new Date().toISOString()
                        : order.preparationCompletedAt,
                    // Si se cancela, resetear items
                    items:
                      status === 'PENDING'
                        ? order.items?.map((item: any) => ({
                            ...item,
                            preparationStatus: item.belongsToMyScreen
                              ? 'IN_PROGRESS'
                              : item.preparationStatus,
                            preparedAt: item.belongsToMyScreen
                              ? null
                              : item.preparedAt,
                          }))
                        : order.items,
                    ...extraUpdates,
                  }
                : order,
            );
          });
        }
      }
    });

    return previousData;
  };

  const rollbackAllQueries = (previousData: any[]) => {
    previousData.forEach(([queryKey, data]) => {
      queryClient.setQueryData(queryKey, data);
    });
  };

  return {
    // Funcin genrica para actualizar status
    updateStatus: useMutation({
      mutationFn: ({
        serverAction,
      }: {
        orderId: string;
        status: string;
        serverAction: () => Promise<any>;
      }) => serverAction(),

      onMutate: async ({ orderId, status }) => {
        await queryClient.cancelQueries({ queryKey: [KITCHEN_ORDERS_KEY] });
        const previousData = updateAllQueriesForOrder(orderId, status);
        return { previousData };
      },

      onError: (error: any, _variables, context) => {
        if (context?.previousData) {
          rollbackAllQueries(context.previousData);
        }
        showError(error.response?.data?.message || 'Error al actualizar orden');
      },

      onSettled: () => {
        setTimeout(() => {
          queryClient.invalidateQueries({
            queryKey: [KITCHEN_ORDERS_KEY],
            refetchType: 'none',
          });
        }, 2000);
      },
    }),

    // Helpers especficos
    startPreparation: (orderId: string) => ({
      orderId,
      status: 'IN_PREPARATION',
      serverAction: () => kitchenService.startOrderPreparation(orderId),
    }),

    cancelPreparation: (orderId: string) => ({
      orderId,
      status: 'PENDING',
      serverAction: () => kitchenService.cancelOrderPreparation(orderId),
    }),

    completePreparation: (orderId: string) => ({
      orderId,
      status: 'READY',
      serverAction: () => kitchenService.completeOrderPreparation(orderId),
    }),
  };
}

/**
 * Hook de conveniencia para iniciar preparacin
 */
export function useStartOrderPreparation() {
  const { updateStatus, startPreparation } = useUpdateKitchenOrderStatus();

  return useMutation({
    mutationFn: (orderId: string) => {
      const params = startPreparation(orderId);
      return updateStatus.mutateAsync(params);
    },
  });
}

/**
 * Hook de conveniencia para cancelar preparacin
 */
export function useCancelOrderPreparation() {
  const { updateStatus, cancelPreparation } = useUpdateKitchenOrderStatus();

  return useMutation({
    mutationFn: (orderId: string) => {
      const params = cancelPreparation(orderId);
      return updateStatus.mutateAsync(params);
    },
  });
}

/**
 * Hook de conveniencia para completar preparacin
 */
export function useCompleteOrderPreparation() {
  const { updateStatus, completePreparation } = useUpdateKitchenOrderStatus();

  return useMutation({
    mutationFn: (orderId: string) => {
      const params = completePreparation(orderId);
      return updateStatus.mutateAsync(params);
    },
  });
}

/**
 * Hook de conveniencia para marcar items como preparados
 * Mantiene la API existente para compatibilidad
 */
export function useMarkItemPrepared() {
  const updateItem = useUpdateKitchenItem();

  return useMutation({
    mutationFn: ({
      itemId,
      isPrepared,
    }: {
      itemId: string;
      isPrepared: boolean;
    }) => {
      return updateItem.mutateAsync({ itemId, isPrepared });
    },
  });
}

================
File: app/src/modules/kitchen/services/kitchenService.ts
================
import apiClient from '@/app/services/apiClient';
import { KitchenOrder, KitchenFilters } from '../schema/kitchen.schema';
import { API_PATHS } from '@/app/constants/apiPaths';

class KitchenService {
  async getKitchenOrders(
    filters: Partial<KitchenFilters> = {},
  ): Promise<KitchenOrder[]> {
    // Construir query string manualmente para evitar problemas de serializacin
    const queryParams = new URLSearchParams();

    // Solo enviar orderType si tiene un valor (no es undefined)
    if (filters.orderType) {
      queryParams.append('orderType', filters.orderType);
    }
    if (filters.showPrepared !== undefined) {
      queryParams.append('showPrepared', String(filters.showPrepared));
    }
    if (filters.showAllProducts !== undefined) {
      queryParams.append('showAllProducts', String(filters.showAllProducts));
    }
    if (filters.ungroupProducts !== undefined) {
      queryParams.append('ungroupProducts', String(filters.ungroupProducts));
    }
    if (filters.screenId !== undefined) {
      queryParams.append('screenId', filters.screenId);
    }

    const queryString = queryParams.toString();
    const url = queryString
      ? `${API_PATHS.KITCHEN_ORDERS}?${queryString}`
      : API_PATHS.KITCHEN_ORDERS;

    const response = await apiClient.get<KitchenOrder[]>(url);
    return response.data;
  }

  async markItemPrepared(
    itemId: string,
    isPrepared: boolean = true,
  ): Promise<void> {
    await apiClient.patch(
      API_PATHS.KITCHEN_MARK_PREPARED.replace(':itemId', itemId),
      {
        isPrepared,
      },
    );
  }

  async unmarkItemPrepared(itemId: string): Promise<void> {
    await apiClient.patch(
      API_PATHS.KITCHEN_MARK_UNPREPARED.replace(':itemId', itemId),
    );
  }

  async startOrderPreparation(orderId: string): Promise<void> {
    await apiClient.patch(
      API_PATHS.KITCHEN_ORDERS_START_PREPARATION.replace(':orderId', orderId),
    );
  }

  async cancelOrderPreparation(orderId: string): Promise<void> {
    await apiClient.patch(
      API_PATHS.KITCHEN_ORDERS_CANCEL_PREPARATION.replace(':orderId', orderId),
    );
  }

  async completeOrderPreparation(orderId: string): Promise<void> {
    await apiClient.patch(
      API_PATHS.KITCHEN_ORDERS_COMPLETE_PREPARATION.replace(
        ':orderId',
        orderId,
      ),
    );
  }
}

export const kitchenService = new KitchenService();

================
File: app/src/modules/menu/schema/products.schema.ts
================
import { z } from 'zod';
import { baseListQuerySchema } from '../../../app/types/query.types';
import { type Photo } from '../../../app/schemas/domain/photo.schema';
import {
  productVariantSchema,
  type ProductVariant,
} from '../../../app/schemas/domain/product-variant.schema';
import {
  productSchema as domainProductSchema,
  type Product,
} from '../../../app/schemas/domain/product.schema';
const productVariantFormSchema = productVariantSchema
  .omit({ id: true })
  .extend({
    id: z.string().optional(),
    sortOrder: z.number().optional().default(0),
  });

const productFormBaseSchema = domainProductSchema
  .omit({
    id: true,
    photo: true,
    variants: true,
    modifierGroups: true,
    pizzaCustomizations: true,
    pizzaConfiguration: true,
    createdAt: true,
    updatedAt: true,
  })
  .extend({
    id: z.string().optional(), // ID opcional para creacin/formulario
    photoId: z.union([z.string().uuid(), z.null(), z.undefined()]).optional(), // ID de la foto guardada en backend
    imageUri: z // Campo temporal para el formulario
      .string()
      .url()
      .or(z.string().startsWith('file://'))
      .optional()
      .nullable(),
    variants: z.array(productVariantFormSchema).optional(), // Usa el schema del formulario
    variantsToDelete: z.array(z.string()).optional(), // Para manejar eliminacin en edicin
    modifierGroupIds: z.array(z.string()).optional(), // IDs para asignar/actualizar
  });

export const productSchema = productFormBaseSchema.superRefine((data, ctx) =>
  addVariantValidation(data, ctx, false),
);

export type ProductFormInputs = z.infer<typeof productSchema>;

const addVariantValidation = (
  data: any,
  ctx: z.RefinementCtx,
  isPartial = false,
) => {
  const checkVariants = isPartial ? data.hasVariants !== undefined : true;

  if (checkVariants && data.hasVariants) {
    if (data.variants !== undefined && data.variants.length === 0) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'Debe aadir al menos una variante si marca esta opcin.',
        path: ['variants'],
      });
    }
    if (data.price !== null && data.price !== undefined) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message:
          'El precio principal debe estar vaco si el producto tiene variantes.',
        path: ['price'],
      });
    }
  } else if (checkVariants && data.hasVariants === false) {
    if (data.price === null || data.price === undefined) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'El precio es requerido si el producto no tiene variantes.',
        path: ['price'],
      });
    }
    if (data.variants && data.variants.length > 0) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message:
          'No debe haber variantes si el producto no est marcado como "Tiene Variantes".',
        path: ['variants'],
      });
    }
  }
};

export const updateProductSchema = productFormBaseSchema
  .partial()
  .superRefine((data, ctx) => addVariantValidation(data, ctx, true));

export type UpdateProductFormInputs = z.infer<typeof updateProductSchema>;

export const productResponseSchema = domainProductSchema;
export const productsListResponseSchema = z.tuple([
  z.array(productResponseSchema), // Usa el schema de respuesta definido arriba
  z.number(), // Count
]);
export type ProductsListResponse = z.infer<typeof productsListResponseSchema>;

export const findAllProductsQuerySchema = baseListQuerySchema.extend({
  subcategoryId: z.string().optional(),
  hasVariants: z.boolean().optional(),
  isActive: z.boolean().optional(),
  search: z.string().optional(),
});
export type FindAllProductsQuery = z.infer<typeof findAllProductsQuerySchema>;

export const assignModifierGroupsSchema = z.object({
  modifierGroupIds: z
    .array(z.string())
    .min(1, 'Se requiere al menos un ID de grupo'),
});
export type AssignModifierGroupsInput = z.infer<
  typeof assignModifierGroupsSchema
>;

export type { Photo, ProductVariant, Product };

================
File: app/src/modules/menu/screens/CategoriesScreen.tsx
================
import React, { useState, useMemo, useCallback, useEffect } from 'react';
import { StyleSheet } from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { useDrawerStatus } from '@react-navigation/drawer';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Portal, IconButton } from 'react-native-paper';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
import { useAppTheme } from '../../../app/styles/theme';
import { useSnackbarStore } from '../../../app/store/snackbarStore';
import { getApiErrorMessage } from '../../../app/lib/errorMapping';
import { useListState } from '../../../app/hooks/useListState';
import GenericList from '../../../app/components/crud/GenericList';
import { FilterOption } from '../../../app/components/crud/GenericList';
import GenericDetailModal from '../../../app/components/crud/GenericDetailModal';
import GenericFormModal, {
  FormFieldConfig,
  ImagePickerConfig,
} from '../../../app/components/crud/GenericFormModal';
import {
  ImageUploadService,
  FileObject,
} from '../../../app/lib/imageUploadService';
import categoryService from '../services/categoryService';
import {
  Category,
  CategoryFormData,
  CreateCategoryDto,
  UpdateCategoryDto,
  categoryFormSchema,
} from '../schema/category.schema';
import { useRefreshModuleOnFocus } from '../../../app/hooks/useRefreshOnFocus';

type RootStackParamList = {
  Categories: undefined;
  SubcategoriesScreen: { categoryId: string; categoryName?: string };
};
type CategoriesScreenNavigationProp = NativeStackNavigationProp<
  RootStackParamList,
  'Categories'
>;

const CategoriesScreen: React.FC = () => {
  const theme = useAppTheme();
  const queryClient = useQueryClient();
  const navigation = useNavigation<CategoriesScreenNavigationProp>();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';

  const [modalVisible, setModalVisible] = useState(false);
  const [detailModalVisible, setDetailModalVisible] = useState(false);
  const [editingCategory, setEditingCategory] = useState<Category | null>(null);
  const [selectedCategory, setSelectedCategory] = useState<Category | null>(
    null,
  );
  const [activeFilter, setActiveFilter] = useState<string | number>('all');
  const [isUploadingImage, setIsUploadingImage] = useState(false);
  const [showDeleteConfirmation, setShowDeleteConfirmation] = useState(false);
  const [categoryToDelete, setCategoryToDelete] = useState<string | null>(null);

  const {
    data: categoriesResponse,
    isLoading: isLoadingCategories,
    isError: isErrorCategories,
    refetch: refetchCategories,
    isFetching: isFetchingCategories,
  } = useQuery({
    queryKey: ['categories', { filter: activeFilter }],
    queryFn: () =>
      categoryService.getCategories({
        isActive:
          activeFilter === 'all' ? undefined : activeFilter === 'active',
      }),
  });

  useRefreshModuleOnFocus('categories');

  const { ListEmptyComponent } = useListState({
    isLoading: isLoadingCategories,
    isError: isErrorCategories,
    data: categoriesResponse?.data,
    emptyConfig: {
      title: 'No hay categoras',
      message:
        activeFilter !== 'all'
          ? `No hay categoras ${activeFilter === 'active' ? 'activas' : 'inactivas'} registradas.`
          : 'No hay categoras registradas. Presiona el botn + para crear la primera.',
      icon: 'folder-outline',
    },
    errorConfig: {
      title: 'Error al cargar categoras',
      message: 'No se pudieron cargar las categoras. Verifica tu conexin.',
      icon: 'alert-circle-outline',
      onAction: refetchCategories,
    },
  });

  const commonMutationOptions = {
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['categories'] });
      closeModals();
    },
    onError: (error: unknown) => {
      const message = getApiErrorMessage(error);
      showSnackbar({ message, type: 'error' });
      setIsUploadingImage(false);
    },
  };

  const createCategoryMutation = useMutation({
    mutationFn: (data: CreateCategoryDto) =>
      categoryService.createCategory(data),
    ...commonMutationOptions,
    onSuccess: () => {
      commonMutationOptions.onSuccess();
      showSnackbar({
        message: 'Categora creada exitosamente',
        type: 'success',
      });
    },
  });

  const updateCategoryMutation = useMutation({
    mutationFn: ({ id, data }: { id: string; data: UpdateCategoryDto }) =>
      categoryService.updateCategory(id, data),
    ...commonMutationOptions,
    onSuccess: () => {
      commonMutationOptions.onSuccess();
      showSnackbar({
        message: 'Categora actualizada exitosamente',
        type: 'success',
      });
    },
  });

  const deleteCategoryMutation = useMutation({
    mutationFn: (id: string) => categoryService.deleteCategory(id),
    ...commonMutationOptions,
    onSuccess: () => {
      commonMutationOptions.onSuccess();
      showSnackbar({ message: 'Categora eliminada', type: 'success' });
    },
  });
  const openAddModal = useCallback(() => {
    setEditingCategory(null);
    setModalVisible(true);
  }, []);

  const openEditModal = useCallback((category: Category) => {
    setEditingCategory(category);
    setDetailModalVisible(false);
    setModalVisible(true);
  }, []);

  const openDetailModal = useCallback((category: Category) => {
    setSelectedCategory(category);
    setDetailModalVisible(true);
  }, []);

  const closeModals = useCallback(() => {
    setModalVisible(false);
    setDetailModalVisible(false);
    setEditingCategory(null);
    setSelectedCategory(null);
    setIsUploadingImage(false);
  }, []);

  const handleFilterChange = (value: string | number) => {
    setActiveFilter(value);
  };

  const handleFormSubmit = async (
    formData: CategoryFormData,
    photoId: string | null | undefined,
  ) => {
    const { imageUri, ...dataToSubmit } = formData;
    const finalData: any = {
      ...dataToSubmit,
    };

    if (photoId !== undefined) {
      finalData.photoId = photoId;
    }

    if (editingCategory) {
      updateCategoryMutation.mutate({
        id: editingCategory.id,
        data: finalData as UpdateCategoryDto,
      });
    } else {
      createCategoryMutation.mutate(finalData as CreateCategoryDto);
    }
  };

  const handleDelete = (id: string) => {
    setCategoryToDelete(id);
    setShowDeleteConfirmation(true);
  };

  const handleConfirmDelete = () => {
    if (categoryToDelete) {
      deleteCategoryMutation.mutate(categoryToDelete);
      setShowDeleteConfirmation(false);
      setCategoryToDelete(null);
    }
  };

  const categories = useMemo(() => {
    return categoriesResponse?.data ?? [];
  }, [categoriesResponse?.data]);

  const styles = useMemo(
    () =>
      StyleSheet.create({
        container: { flex: 1, backgroundColor: theme.colors.background },
        iconButton: { margin: 0 },
      }),
    [theme],
  );

  const [formInitialValues, setFormInitialValues] = useState<CategoryFormData>({
    name: '',
    description: null,
    isActive: true,
    sortOrder: 0,
    imageUri: null,
  });

  useEffect(() => {
    const loadFormData = async () => {
      if (editingCategory) {
        let imageUrl = null;
        if (editingCategory.photo?.path) {
          try {
            const { getImageUrl } = await import('@/app/lib/imageUtils');
            imageUrl = await getImageUrl(editingCategory.photo.path);
          } catch (error) {
            imageUrl = editingCategory.photo.path;
          }
        }

        setFormInitialValues({
          name: editingCategory.name,
          description: editingCategory.description ?? null,
          isActive: editingCategory.isActive,
          sortOrder: editingCategory.sortOrder ?? 0,
          imageUri: imageUrl,
        });
      } else {
        setFormInitialValues({
          name: '',
          description: null,
          isActive: true,
          sortOrder: 0,
          imageUri: null,
        });
      }
    };

    loadFormData();
  }, [editingCategory]);

  const selectedCategoryMapped = useMemo(() => {
    if (!selectedCategory) return null;
    return selectedCategory;
  }, [selectedCategory]);

  const filterOptions: FilterOption<string | number>[] = [
    { value: 'all', label: 'Todas' },
    { value: 'active', label: 'Activas' },
    { value: 'inactive', label: 'Inactivas' },
  ];

  const listRenderConfig = {
    titleField: 'name' as keyof Category,
    descriptionField: 'description' as keyof Category,
    descriptionMaxLength: 60,
    imageField: 'photo' as keyof Category,
    sortOrderField: 'sortOrder' as keyof Category,
    statusConfig: {
      field: 'isActive' as keyof Category,
      activeValue: true,
      activeLabel: 'Activa',
      inactiveLabel: 'Inactiva',
    },
  };

  const formFieldsConfig: FormFieldConfig<CategoryFormData>[] = [
    { name: 'name', label: 'Nombre', type: 'text', required: true },
    {
      name: 'description',
      label: 'Descripcin',
      type: 'textarea',
      numberOfLines: 3,
    },
    {
      name: 'sortOrder',
      label: 'Orden de visualizacin',
      type: 'number',
      placeholder: '0',
    },
    {
      name: 'isActive',
      label: 'Estado',
      type: 'switch',
      switchLabel: 'Activa',
    },
  ];

  const imagePickerConfig: ImagePickerConfig<CategoryFormData> = {
    imageUriField: 'imageUri',
    onImageUpload: async (file: FileObject) => {
      setIsUploadingImage(true);
      try {
        const result = await ImageUploadService.uploadImage(file);
        if (result.success && result.photoId) {
          return { id: result.photoId };
        }
        throw new Error(result.error || 'Error desconocido al subir imagen');
      } finally {
        setIsUploadingImage(false);
      }
    },
    determineFinalPhotoId: (formImageUri) => {
      // Para mantener compatibilidad, retornamos la URI del formulario
      return formImageUri;
    },
    imagePickerSize: 150,
    placeholderIcon: 'folder-outline',
    placeholderText: 'Imagen de categora',
  };

  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      <GenericList
        items={categories}
        enableSort={true}
        enableSearch={true}
        searchPlaceholder="Buscar categoras..."
        filterValue={activeFilter}
        onFilterChange={handleFilterChange}
        filterOptions={filterOptions}
        renderItemActions={(item: Category) => (
          <IconButton
            icon="format-list-bulleted"
            size={28}
            onPress={() =>
              navigation.navigate('SubcategoriesScreen', {
                categoryId: item.id,
                categoryName: item.name,
              })
            }
            style={styles.iconButton}
          />
        )}
        renderConfig={listRenderConfig}
        onItemPress={openDetailModal}
        onRefresh={refetchCategories}
        isRefreshing={isFetchingCategories && !isLoadingCategories}
        ListEmptyComponent={ListEmptyComponent}
        showFab={true}
        onFabPress={openAddModal}
        isModalOpen={modalVisible || detailModalVisible}
        showImagePlaceholder={true}
        placeholderIcon="folder-outline"
        isDrawerOpen={isDrawerOpen}
      />

      <Portal>
        <GenericFormModal
          visible={modalVisible}
          onDismiss={closeModals}
          onSubmit={handleFormSubmit}
          formSchema={categoryFormSchema}
          formFields={formFieldsConfig}
          imagePickerConfig={imagePickerConfig}
          initialValues={formInitialValues}
          editingItem={editingCategory}
          isSubmitting={
            createCategoryMutation.isPending ||
            updateCategoryMutation.isPending ||
            isUploadingImage
          }
          modalTitle={(isEditing) =>
            isEditing ? 'Editar Categora' : 'Nueva Categora'
          }
          submitButtonLabel={(isEditing) => (isEditing ? 'Guardar' : 'Crear')}
        />

        <GenericDetailModal
          visible={detailModalVisible}
          onDismiss={closeModals}
          item={selectedCategoryMapped}
          titleField="name"
          imageField="photo"
          descriptionField="description"
          statusConfig={listRenderConfig.statusConfig}
          fieldsToDisplay={[
            {
              field: 'sortOrder',
              label: 'Orden de visualizacin',
              render: (value) => value ?? '0',
            },
          ]}
          onEdit={openEditModal as (item: any) => void}
          onDelete={handleDelete}
          isDeleting={deleteCategoryMutation.isPending}
          showImage={true}
        />

        <ConfirmationModal
          visible={showDeleteConfirmation}
          title="Confirmar Eliminacin"
          message="Ests seguro de que quieres eliminar esta categora? Esta accin no se puede deshacer."
          confirmText="Eliminar"
          cancelText="Cancelar"
          confirmButtonColor={theme.colors.error}
          onConfirm={handleConfirmDelete}
          onCancel={() => {
            setShowDeleteConfirmation(false);
            setCategoryToDelete(null);
          }}
          onDismiss={() => {
            setShowDeleteConfirmation(false);
            setCategoryToDelete(null);
          }}
        />
      </Portal>
    </SafeAreaView>
  );
};

export default CategoriesScreen;

================
File: app/src/modules/menu/screens/SubcategoriesScreen.tsx
================
import React, { useCallback, useMemo, useEffect, useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { Portal, IconButton } from 'react-native-paper';
import {
  useFocusEffect,
  useRoute,
  RouteProp,
  useNavigation,
} from '@react-navigation/native';
import { useDrawerStatus } from '@react-navigation/drawer';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import GenericList from '../../../app/components/crud/GenericList';
import GenericDetailModal from '../../../app/components/crud/GenericDetailModal';
import GenericFormModal, {
  FormFieldConfig,
  ImagePickerConfig,
} from '../../../app/components/crud/GenericFormModal';
import { FilterOption } from '../../../app/components/crud/GenericList';
import { useCrudScreenLogic } from '../../../app/hooks/useCrudScreenLogic';
import { useListState } from '../../../app/hooks/useListState';

import {
  ImageUploadService,
  FileObject,
} from '../../../app/lib/imageUploadService';
import {
  useFindAllSubcategories,
  useCreateSubcategory,
  useUpdateSubcategory,
  useRemoveSubcategory,
} from '../hooks/useSubcategoriesQueries';
import {
  SubCategory,
  createSubCategoryDtoSchema,
  updateSubCategoryDtoSchema,
  SubCategoryFormInputs,
  UpdateSubCategoryFormInputs,
  FindAllSubcategoriesDto,
} from '../schema/subcategories.schema';
import { MenuStackParamList } from '@/modules/menu/navigation/types';

type SubcategoriesScreenRouteProp = RouteProp<
  MenuStackParamList,
  'SubcategoriesScreen'
>;
type SubcategoriesScreenNavigationProp = NativeStackNavigationProp<
  MenuStackParamList,
  'SubcategoriesScreen'
>;

type StatusFilter = 'all' | 'active' | 'inactive';

const SubcategoriesScreen: React.FC = () => {
  const theme = useAppTheme();
  const route = useRoute<SubcategoriesScreenRouteProp>();
  const navigation = useNavigation<SubcategoriesScreenNavigationProp>();
  const { categoryId, categoryName } = route.params;
  const styles = useMemo(() => createStyles(theme), [theme]);
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';

  const [statusFilter, setStatusFilter] = React.useState<StatusFilter>('all');

  const [formInitialValues, setFormInitialValues] = useState<
    SubCategoryFormInputs | UpdateSubCategoryFormInputs
  >({
    name: '',
    description: '',
    isActive: true,
    categoryId: categoryId,
    sortOrder: 0,
    imageUri: null,
  });

  const queryParams = useMemo((): FindAllSubcategoriesDto => {
    let isActive: boolean | undefined;
    if (statusFilter === 'active') isActive = true;
    if (statusFilter === 'inactive') isActive = false;

    const params: FindAllSubcategoriesDto = { categoryId, page: 1, limit: 100 };
    if (isActive !== undefined) {
      params.isActive = isActive;
    }
    return params;
  }, [statusFilter, categoryId]);

  const {
    data: subcategoriesData,
    isLoading: isLoadingList,
    isFetching: isFetchingList,
    refetch: refetchList,
    error: listError,
  } = useFindAllSubcategories(queryParams);

  const createMutation = useCreateSubcategory();
  const updateMutation = useUpdateSubcategory();
  const { mutateAsync: removeSubcategory } = useRemoveSubcategory();

  const {
    isFormModalVisible,
    isDetailModalVisible,
    editingItem,
    selectedItem,
    isDeleting,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
    deleteConfirmation,
  } = useCrudScreenLogic<SubCategory>({
    entityName: 'Subcategora',
    queryKey: ['subcategories', queryParams],
    deleteMutationFn: removeSubcategory,
  });

  const handleRefresh = useCallback(() => {
    refetchList();
  }, [refetchList]);

  useEffect(() => {
    const loadFormData = async () => {
      if (editingItem) {
        let imageUrl = null;
        if (editingItem.photo?.path) {
          try {
            const { getImageUrl } = await import('@/app/lib/imageUtils');
            imageUrl = await getImageUrl(editingItem.photo.path);
          } catch (error) {
            imageUrl = editingItem.photo.path;
          }
        }

        setFormInitialValues({
          name: editingItem.name,
          description: editingItem.description ?? '',
          isActive: editingItem.isActive,
          categoryId: editingItem.categoryId,
          sortOrder: editingItem.sortOrder ?? 0,
          imageUri: imageUrl,
        });
      } else {
        setFormInitialValues({
          name: '',
          description: '',
          isActive: true,
          categoryId: categoryId,
          sortOrder: 0,
          imageUri: null,
        });
      }
    };

    loadFormData();
  }, [editingItem, categoryId]);

  useFocusEffect(
    useCallback(() => {
      refetchList();
    }, [refetchList]),
  );

  const handleFormSubmit = async (
    formData: SubCategoryFormInputs | UpdateSubCategoryFormInputs,
    photoId: string | null | undefined,
  ) => {
    const { imageUri, ...dataToSubmit } = formData;
    const finalData = {
      ...dataToSubmit,
      ...(photoId !== undefined && { photoId }),
    };

    if (finalData.photoId === undefined && !editingItem) {
      delete (finalData as any).photoId;
    }

    try {
      if (editingItem) {
        await updateMutation.mutateAsync({
          id: editingItem.id,
          data: finalData as UpdateSubCategoryFormInputs,
        });
      } else {
        await createMutation.mutateAsync(finalData as SubCategoryFormInputs);
      }
      handleCloseModals();
    } catch (error) {}
  };

  const listRenderConfig = {
    titleField: 'name' as keyof SubCategory,
    descriptionField: 'description' as keyof SubCategory,
    imageField: 'photo' as keyof SubCategory,
    sortOrderField: 'sortOrder' as keyof SubCategory,
    statusConfig: {
      field: 'isActive' as keyof SubCategory,
      activeValue: true,
      activeLabel: 'Activa',
      inactiveLabel: 'Inactiva',
    },
  };

  const formatDate = (value: string | Date) => {
    if (!value) return 'N/A';
    const date = new Date(value);
    return date.toLocaleDateString('es-ES', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  const detailFieldsToDisplay: Array<{
    field: keyof SubCategory;
    label: string;
    render?: (value: any) => string;
  }> = [
    {
      field: 'sortOrder',
      label: 'Orden de visualizacin',
      render: (value) => value ?? '0',
    },
    {
      field: 'createdAt',
      label: 'Fecha de creacin',
      render: formatDate,
    },
    {
      field: 'updatedAt',
      label: 'ltima actualizacin',
      render: formatDate,
    },
  ];

  const filterOptions: FilterOption<StatusFilter>[] = [
    { value: 'all', label: 'Todas' },
    { value: 'active', label: 'Activas' },
    { value: 'inactive', label: 'Inactivas' },
  ];

  const formFields: FormFieldConfig<
    SubCategoryFormInputs | UpdateSubCategoryFormInputs
  >[] = [
    { name: 'name', label: 'Nombre *', type: 'text', required: true },
    {
      name: 'description',
      label: 'Descripcin',
      type: 'textarea',
      numberOfLines: 3,
    },
    {
      name: 'sortOrder',
      label: 'Orden de visualizacin',
      type: 'number',
      placeholder: '0',
    },
    {
      name: 'isActive',
      label: 'Activo',
      type: 'switch',
      switchLabel: 'Activo',
      defaultValue: true,
    },
  ];

  const imagePickerConfig: ImagePickerConfig<
    SubCategoryFormInputs | UpdateSubCategoryFormInputs
  > = {
    imageUriField: 'imageUri',
    onImageUpload: async (file: FileObject) => {
      const result = await ImageUploadService.uploadImage(file);
      if (result.success && result.photoId) {
        return { id: result.photoId };
      }
      throw new Error(result.error || 'Error desconocido al subir imagen');
    },
    determineFinalPhotoId: ImageUploadService.determinePhotoId,
    imagePickerSize: 150,
    placeholderIcon: 'folder-open-outline',
    placeholderText: 'Imagen de subcategora',
  };

  const renderSubcategoryActions = (item: SubCategory) => (
    <IconButton
      icon="chevron-right"
      size={28}
      onPress={() =>
        navigation.navigate('Products', {
          subcategoryId: item.id,
          subCategoryName: item.name,
        })
      }
      style={styles.iconButton}
    />
  );

  const { ListEmptyComponent } = useListState({
    isLoading: isLoadingList,
    isError: !!listError,
    data: subcategoriesData?.data,
    emptyConfig: {
      title: 'No hay subcategoras',
      message: `No hay subcategoras registradas para ${categoryName}. Presiona el botn + para crear la primera.`,
      icon: 'folder-outline',
    },
    errorConfig: {
      title: 'Error al cargar subcategoras',
      message: 'No se pudieron cargar las subcategoras. Verifica tu conexin.',
      icon: 'alert-circle-outline',
      onRetry: refetchList,
    },
  });

  const handleFilterChange = (value: string | number) => {
    if (value === 'all' || value === 'active' || value === 'inactive') {
      setStatusFilter(value);
    } else {
      setStatusFilter('all');
    }
  };

  return (
    <View style={styles.container}>
      <GenericList<SubCategory>
        items={subcategoriesData?.data ?? []}
        enableSort={true}
        enableSearch={true}
        searchPlaceholder="Buscar subcategoras..."
        filterValue={statusFilter}
        onFilterChange={handleFilterChange}
        filterOptions={filterOptions}
        renderConfig={listRenderConfig}
        onItemPress={handleOpenDetailModal}
        onRefresh={handleRefresh}
        isRefreshing={isFetchingList && !isLoadingList}
        ListEmptyComponent={ListEmptyComponent}
        isLoading={isLoadingList}
        contentContainerStyle={styles.listContentContainer}
        renderItemActions={renderSubcategoryActions}
        showFab={true}
        onFabPress={handleOpenCreateModal}
        isModalOpen={isDetailModalVisible || isFormModalVisible}
        showImagePlaceholder={true}
        placeholderIcon="folder-open-outline"
        isDrawerOpen={isDrawerOpen}
      />

      <Portal>
        <GenericDetailModal<SubCategory>
          visible={isDetailModalVisible}
          onDismiss={handleCloseModals}
          item={selectedItem}
          titleField="name"
          imageField="photo"
          descriptionField="description"
          statusConfig={listRenderConfig.statusConfig}
          fieldsToDisplay={detailFieldsToDisplay}
          onEdit={() => {
            if (selectedItem) {
              handleOpenEditModal(selectedItem);
            }
          }}
          deleteConfirmation={deleteConfirmation}
          isDeleting={isDeleting}
          showImage={true}
        />

        <GenericFormModal<
          SubCategoryFormInputs | UpdateSubCategoryFormInputs,
          SubCategory
        >
          visible={isFormModalVisible}
          onDismiss={handleCloseModals}
          onSubmit={handleFormSubmit}
          formSchema={
            editingItem
              ? updateSubCategoryDtoSchema
              : createSubCategoryDtoSchema
          }
          formFields={formFields}
          imagePickerConfig={imagePickerConfig}
          initialValues={formInitialValues}
          editingItem={editingItem}
          isSubmitting={createMutation.isPending || updateMutation.isPending}
          modalTitle={(editing) =>
            editing ? 'Editar Subcategora' : 'Crear Subcategora'
          }
        />
      </Portal>
    </View>
  );
};

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    listContentContainer: {
      paddingBottom: 80,
    },
    iconButton: {
      margin: 0,
    },
  });

export default SubcategoriesScreen;

================
File: app/src/modules/menu/services/productsService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import {
  Product,
  ProductFormInputs,
  FindAllProductsQuery,
  AssignModifierGroupsInput,
} from '../schema/products.schema';
import { PaginatedResponse } from '@/app/types/api.types';

async function findAll(
  params: FindAllProductsQuery,
): Promise<PaginatedResponse<Product>> {
  const response = await apiClient.get<{
    items: Product[];
    total: number;
    page: number;
    limit: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  }>(API_PATHS.PRODUCTS, { params });

  return {
    data: response.data.items,
    total: response.data.total,
    page: response.data.page,
    limit: response.data.limit,
    totalPages: Math.ceil(response.data.total / response.data.limit),
  };
}

async function findOne(id: string): Promise<Product> {
  const response = await apiClient.get<Product>(
    API_PATHS.PRODUCTS_BY_ID.replace(':id', id),
  );
  return response.data;
}

async function create(data: ProductFormInputs): Promise<Product> {
  const response = await apiClient.post<Product>(API_PATHS.PRODUCTS, data);
  return response.data;
}

async function update(
  id: string,
  data: Partial<ProductFormInputs>,
): Promise<Product> {
  const response = await apiClient.patch<Product>(
    API_PATHS.PRODUCTS_BY_ID.replace(':id', id),
    data,
  );
  return response.data;
}

async function remove(id: string): Promise<void> {
  await apiClient.delete(API_PATHS.PRODUCTS_BY_ID.replace(':id', id));
}

async function assignModifierGroups(
  productId: string,
  data: AssignModifierGroupsInput,
): Promise<Product> {
  const response = await apiClient.post<Product>(
    API_PATHS.PRODUCTS_MODIFIER_GROUPS.replace(':productId', productId),
    data,
  );
  return response.data;
}

async function getModifierGroups(productId: string): Promise<Product> {
  const response = await apiClient.get<Product>(
    API_PATHS.PRODUCTS_MODIFIER_GROUPS.replace(':productId', productId),
  );
  return response.data;
}

async function removeModifierGroups(
  productId: string,
  data: AssignModifierGroupsInput,
): Promise<Product> {
  const response = await apiClient.delete<Product>(
    API_PATHS.PRODUCTS_MODIFIER_GROUPS.replace(':productId', productId),
    { data },
  );
  return response.data;
}

async function findAllPizzas(): Promise<Product[]> {
  const response = await apiClient.get<Product[]>(API_PATHS.PRODUCTS_PIZZAS);
  return response.data;
}

async function getPizzaCustomizations(productId: string): Promise<any[]> {
  const response = await apiClient.get<any[]>(
    API_PATHS.PRODUCTS_PIZZA_CUSTOMIZATIONS.replace(':productId', productId),
  );
  return response.data;
}

async function updatePizzaCustomizations(
  productId: string,
  pizzaCustomizationIds: string[],
): Promise<Product> {
  const response = await apiClient.put<Product>(
    API_PATHS.PRODUCTS_PIZZA_CUSTOMIZATIONS.replace(':productId', productId),
    pizzaCustomizationIds,
  );
  return response.data;
}

async function bulkUpdatePizzaCustomizations(
  updates: Array<{ productId: string; customizationIds: string[] }>,
): Promise<void> {
  await apiClient.put(API_PATHS.PRODUCTS_PIZZAS_CUSTOMIZATIONS_BULK, {
    updates,
  });
}

export const productsService = {
  findAll,
  findOne,
  create,
  update,
  remove,
  assignModifierGroups,
  getModifierGroups,
  removeModifierGroups,
  findAllPizzas,
  getPizzaCustomizations,
  updatePizzaCustomizations,
  bulkUpdatePizzaCustomizations,
};

================
File: app/src/modules/menu/services/subcategoriesService.ts
================
import apiClient from '../../../app/services/apiClient';
import { API_PATHS } from '../../../app/constants/apiPaths';
import {
  SubCategory,
  CreateSubCategoryDto,
  UpdateSubCategoryDto,
  FindAllSubcategoriesDto,
} from '../schema/subcategories.schema';
import { PaginatedResponse } from '../../../app/types/api.types';

const createSubcategory = async (
  data: CreateSubCategoryDto,
): Promise<SubCategory> => {
  const response = await apiClient.post<SubCategory>(
    API_PATHS.SUBCATEGORIES,
    data,
  );
  return response.data;
};

const findAllSubcategories = async (
  params: FindAllSubcategoriesDto,
): Promise<PaginatedResponse<SubCategory>> => {
  const queryParams = Object.entries(params).reduce(
    (acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = value;
      }
      return acc;
    },
    {} as Record<string, any>,
  );

  const response = await apiClient.get<{
    items: SubCategory[];
    total: number;
    page: number;
    limit: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  }>(API_PATHS.SUBCATEGORIES, { params: queryParams });

  return {
    data: response.data.items,
    total: response.data.total,
    page: response.data.page,
    limit: response.data.limit,
    totalPages: Math.ceil(response.data.total / response.data.limit),
  };
};

const findOneSubcategory = async (id: string): Promise<SubCategory> => {
  const response = await apiClient.get<SubCategory>(
    API_PATHS.SUBCATEGORIES_BY_ID.replace(':id', id),
  );
  return response.data;
};

const updateSubcategory = async (
  id: string,
  data: UpdateSubCategoryDto,
): Promise<SubCategory> => {
  const response = await apiClient.patch<SubCategory>(
    API_PATHS.SUBCATEGORIES_BY_ID.replace(':id', id),
    data,
  );
  return response.data;
};

const removeSubcategory = async (id: string): Promise<void> => {
  await apiClient.delete(API_PATHS.SUBCATEGORIES_BY_ID.replace(':id', id));
};

export const subcategoriesService = {
  createSubcategory,
  findAllSubcategories,
  findOneSubcategory,
  updateSubcategory,
  removeSubcategory,
};

================
File: app/src/modules/modifiers/screens/ModifiersScreen.tsx
================
import React, { useLayoutEffect, useMemo, useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, Portal, Button } from 'react-native-paper';
import { useQuery } from '@tanstack/react-query';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useNavigation, useRoute, RouteProp } from '@react-navigation/native';
import { useDrawerStatus } from '@react-navigation/drawer';

import { modifierService } from '../services/modifierService';
import { Modifier } from '../schema/modifier.schema';
import { useAppTheme } from '@/app/styles/theme';
import debounce from 'lodash.debounce';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';
import { useCrudScreenLogic } from '@/app/hooks/useCrudScreenLogic';

import ModifierFormModal from '../components/ModifierFormModal';
import GenericList, {
  RenderItemConfig,
  FilterOption,
} from '@/app/components/crud/GenericList';
import GenericDetailModal, {
  DisplayFieldConfig,
} from '@/app/components/crud/GenericDetailModal';
import { useListState } from '@/app/hooks/useListState';

type StatusFilter = 'all' | 'active' | 'inactive';

type ModifiersScreenRouteParams = {
  groupId: string;
  groupName: string;
};

type ModifiersScreenRouteProp = RouteProp<
  { params: ModifiersScreenRouteParams },
  'params'
>;

type NavigationProps = {
  goBack: () => void;
  setOptions: (options: object) => void;
};

const ModifiersScreen = () => {
  const theme = useAppTheme();
  const navigation = useNavigation<NavigationProps>();
  const route = useRoute<ModifiersScreenRouteProp>();
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';

  const { groupId, groupName } = route.params ?? {};

  const [statusFilter, setStatusFilter] = useState<StatusFilter>('all');
  const [searchQuery, setSearchQuery] = useState('');
  const [debouncedSearchQuery, setDebouncedSearchQuery] = useState('');

  const QUERY_KEY = ['modifiers', groupId];

  const debouncedSetSearch = useMemo(
    () => debounce((query: string) => setDebouncedSearchQuery(query), 300),
    [setDebouncedSearchQuery],
  );

  const handleSearchChange = (query: string) => {
    setSearchQuery(query);
    debouncedSetSearch(query);
  };

  useLayoutEffect(() => {
    if (groupName) {
      navigation.setOptions({
        headerTitle: `Modificadores: ${groupName}`,
      });
    }
  }, [navigation, groupName]);

  const queryParams = useMemo(() => {
    const params: Parameters<typeof modifierService.findByGroupId>[1] = {};
    if (statusFilter !== 'all') {
      params.isActive = statusFilter === 'active';
    }
    if (debouncedSearchQuery) {
      params.search = debouncedSearchQuery;
    }
    return params;
  }, [statusFilter, debouncedSearchQuery]);

  const {
    data: modifiers = [],
    isLoading,
    isError,
    refetch,
    isRefetching,
  } = useQuery<Modifier[], Error>({
    queryKey: [QUERY_KEY[0], groupId, queryParams],
    queryFn: () => modifierService.findByGroupId(groupId, queryParams),
    enabled: !!groupId,
  });

  useRefreshModuleOnFocus('modifiers');

  const {
    isFormModalVisible,
    isDetailModalVisible,
    editingItem,
    selectedItem,
    isDeleting,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
    deleteConfirmation,
  } = useCrudScreenLogic<Modifier>({
    entityName: 'Modificador',
    queryKey: QUERY_KEY,
    deleteMutationFn: modifierService.remove,
  });

  const handleFormModalSave = () => {
    handleCloseModals();
  };

  const handleEditFromDetails = (modifier: Modifier) => {
    handleOpenEditModal(modifier);
  };

  const handleFilterChange = (value: string | number) => {
    if (value === 'all' || value === 'active' || value === 'inactive') {
      setStatusFilter(value as StatusFilter);
    } else {
      setStatusFilter('all');
    }
  };

  const styles = React.useMemo(() => createStyles(theme), [theme]);

  const { ListEmptyComponent } = useListState({
    isLoading,
    isError,
    data: modifiers,
    emptyConfig: {
      title: searchQuery
        ? 'No se encontraron modificadores'
        : 'No hay modificadores',
      message: searchQuery
        ? `No se encontraron modificadores para "${searchQuery}"`
        : statusFilter !== 'all'
          ? `No hay modificadores ${statusFilter === 'active' ? 'activos' : 'inactivos'} en este grupo.`
          : `No hay modificadores en "${groupName}". Presiona el botn + para crear el primero.`,
      icon: 'format-list-bulleted',
    },
    errorConfig: {
      title: 'Error al cargar modificadores',
      message: 'No se pudieron cargar los modificadores. Verifica tu conexin.',
      icon: 'alert-circle-outline',
      onAction: refetch,
    },
  });

  if (!groupId) {
    return (
      <View style={styles.centered}>
        <Text style={styles.errorText}>
          Error: No se proporcion ID del grupo.
        </Text>
        <Button onPress={() => navigation.goBack()}>Volver</Button>
      </View>
    );
  }

  const listRenderConfig: RenderItemConfig<Modifier> = {
    titleField: 'name',
    priceField: 'price',
    sortOrderField: 'sortOrder',
    isDefaultField: 'isDefault',
    statusConfig: {
      field: 'isActive',
      activeValue: true,
      activeLabel: 'Activo',
      inactiveLabel: 'Inactivo',
    },
  };

  const detailFields: DisplayFieldConfig<Modifier>[] = [
    {
      field: 'price',
      label: 'Precio Adicional',
      render: (value) => (
        <Text style={styles.fieldValue}>
          {value !== null ? `$${Number(value).toFixed(2)}` : 'N/A'}
        </Text>
      ),
    },
    {
      field: 'sortOrder',
      label: 'Orden',
    },
    {
      field: 'isDefault',
      label: 'Por Defecto',
    },
  ];

  const filterOptions: FilterOption<StatusFilter>[] = [
    { value: 'all', label: 'Todos' },
    { value: 'active', label: 'Activos' },
    { value: 'inactive', label: 'Inactivos' },
  ];

  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      <GenericList<Modifier>
        items={modifiers}
        renderConfig={listRenderConfig}
        onItemPress={handleOpenDetailModal}
        onRefresh={refetch}
        isRefreshing={isRefetching}
        ListEmptyComponent={ListEmptyComponent}
        isLoading={isLoading && !isRefetching}
        enableSearch={true}
        searchQuery={searchQuery}
        onSearchChange={handleSearchChange}
        searchPlaceholder="Buscar modificadores..."
        filterValue={statusFilter}
        onFilterChange={handleFilterChange}
        filterOptions={filterOptions}
        showFab={true}
        onFabPress={handleOpenCreateModal}
        fabLabel="Aadir Modificador"
        isModalOpen={isFormModalVisible || isDetailModalVisible}
        showImagePlaceholder={false}
        isDrawerOpen={isDrawerOpen}
      />

      <Portal>
        <ModifierFormModal
          visible={isFormModalVisible}
          onDismiss={handleCloseModals}
          onSaveSuccess={handleFormModalSave}
          initialData={editingItem}
          groupId={groupId}
        />

        <GenericDetailModal<Modifier>
          visible={isDetailModalVisible}
          onDismiss={handleCloseModals}
          item={selectedItem}
          titleField="name"
          descriptionField="description"
          statusConfig={listRenderConfig.statusConfig}
          fieldsToDisplay={detailFields}
          onEdit={handleEditFromDetails}
          deleteConfirmation={deleteConfirmation}
          isDeleting={isDeleting}
          showImage={false}
        />
      </Portal>
    </SafeAreaView>
  );
};

const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    centered: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: 20,
    },
    emptyText: {
      textAlign: 'center',
      fontSize: 18,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 8,
    },
    emptySubText: {
      textAlign: 'center',
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    errorText: {
      color: theme.colors.error,
      marginBottom: 10,
      textAlign: 'center',
    },
    fieldValue: {
      flexShrink: 1,
      textAlign: 'right',
      color: theme.colors.onSurface,
    },
  });

export default ModifiersScreen;

================
File: app/src/modules/modifiers/services/modifierGroupService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import {
  ModifierGroup,
  CreateModifierGroupInput,
  UpdateModifierGroupInput,
  modifierGroupApiSchema,
} from '../schema/modifierGroup.schema';
import { z } from 'zod';
import { PaginatedResponse } from '@/app/types/api.types';

const paginatedModifierGroupsSchema = z.object({
  items: z.array(modifierGroupApiSchema),
  total: z.number(),
  page: z.number(),
  limit: z.number(),
  hasNextPage: z.boolean(),
  hasPrevPage: z.boolean(),
});

interface FindAllParams {
  page?: number;
  limit?: number;
  isActive?: boolean;
  search?: string;
}

export const modifierGroupService = {
  async findAll(
    params: FindAllParams = {},
  ): Promise<PaginatedResponse<ModifierGroup>> {
    const queryParams = {
      page: params.page ?? 1,
      limit: params.limit ?? 10,
      ...(params.isActive !== undefined && { isActive: params.isActive }),
      ...(params.search && { search: params.search }),
    };
    const response = await apiClient.get<unknown>(API_PATHS.MODIFIER_GROUPS, {
      params: queryParams,
    });

    const paginatedResult = paginatedModifierGroupsSchema.safeParse(
      response.data,
    );
    if (paginatedResult.success) {
      return {
        data: paginatedResult.data.items,
        total: paginatedResult.data.total,
        page: paginatedResult.data.page,
        limit: paginatedResult.data.limit,
        totalPages: Math.ceil(
          paginatedResult.data.total / paginatedResult.data.limit,
        ),
      };
    }

    throw new Error('Received invalid data format for modifier groups.');
  },

  async findOne(id: string): Promise<ModifierGroup> {
    const response = await apiClient.get<unknown>(
      API_PATHS.MODIFIER_GROUPS_BY_ID.replace(':id', id),
    );

    const validationResult = modifierGroupApiSchema.safeParse(response.data);
    if (!validationResult.success) {
      throw new Error(`Received invalid data format for modifier group ${id}.`);
    }
    return validationResult.data;
  },

  async create(data: CreateModifierGroupInput): Promise<ModifierGroup> {
    const response = await apiClient.post<unknown>(
      API_PATHS.MODIFIER_GROUPS,
      data,
    );

    const validationResult = modifierGroupApiSchema.safeParse(response.data);
    if (!validationResult.success) {
      throw new Error(
        'Received invalid data format after creating modifier group.',
      );
    }
    return validationResult.data;
  },

  async update(
    id: string,
    data: UpdateModifierGroupInput,
  ): Promise<ModifierGroup> {
    const response = await apiClient.patch<unknown>(
      API_PATHS.MODIFIER_GROUPS_BY_ID.replace(':id', id),
      data,
    );

    const validationResult = modifierGroupApiSchema.safeParse(response.data);
    if (!validationResult.success) {
      throw new Error(
        `Received invalid data format after updating modifier group ${id}.`,
      );
    }
    return validationResult.data;
  },

  async remove(id: string): Promise<void> {
    await apiClient.delete(API_PATHS.MODIFIER_GROUPS_BY_ID.replace(':id', id));
  },
};

================
File: app/src/modules/orders/components/order-cart/OrderAdjustments.tsx
================
import React, { useMemo } from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, IconButton, List } from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import type { OrderAdjustment } from '../../schema/adjustments.schema';

interface OrderAdjustmentsProps {
  adjustments: OrderAdjustment[];
  subtotal: number;
  onAddAdjustment?: () => void;
  onEditAdjustment?: (adjustment: OrderAdjustment) => void;
  onRemoveAdjustment?: (id: string) => void;
  disabled?: boolean;
  canManageAdjustments?: boolean;
}

export const OrderAdjustments: React.FC<OrderAdjustmentsProps> = ({
  adjustments,
  subtotal,
  onAddAdjustment,
  onEditAdjustment,
  onRemoveAdjustment,
  disabled = false,
  canManageAdjustments = false,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);

  const calculateAdjustmentAmount = (adjustment: OrderAdjustment): number => {
    if (adjustment.isPercentage && adjustment.value) {
      return (subtotal * adjustment.value) / 100;
    }
    return adjustment.amount || 0;
  };

  if (!canManageAdjustments && adjustments.length === 0) {
    return null;
  }

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.headerText}>Ajustes y Descuentos</Text>
        {canManageAdjustments && !disabled && (
          <IconButton
            icon="plus"
            size={20}
            onPress={onAddAdjustment}
            style={styles.addButton}
          />
        )}
      </View>

      {adjustments.length === 0 ? (
        <Text style={styles.emptyText}>No hay ajustes aplicados</Text>
      ) : (
        <View>
          {adjustments.map((adjustment) => {
            const amount = calculateAdjustmentAmount(adjustment);
            return (
              <List.Item
                key={adjustment.id}
                title={adjustment.name}
                right={() => (
                  <View style={styles.rightContent}>
                    <Text style={styles.amountText}>-${amount.toFixed(2)}</Text>
                    {adjustment.isPercentage && (
                      <Text style={styles.percentageText}>
                        ({adjustment.value}%)
                      </Text>
                    )}
                    {canManageAdjustments && !disabled && (
                      <View style={styles.actionButtons}>
                        <IconButton
                          icon="pencil"
                          size={16}
                          onPress={() => onEditAdjustment?.(adjustment)}
                        />
                        <IconButton
                          icon="delete"
                          size={16}
                          onPress={() => adjustment.id && onRemoveAdjustment?.(adjustment.id)}
                        />
                      </View>
                    )}
                  </View>
                )}
                style={styles.adjustmentItem}
              />
            );
          })}
        </View>
      )}
    </View>
  );
};

const createStyles = (theme: any) =>
  StyleSheet.create({
    container: {
      marginVertical: theme.spacing.m,
    },
    header: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.s,
    },
    headerText: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    addButton: {
      margin: -theme.spacing.s,
    },
    emptyText: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      paddingVertical: theme.spacing.m,
      textAlign: 'center',
    },
    adjustmentItem: {
      backgroundColor: theme.colors.surfaceVariant,
      marginBottom: theme.spacing.xs,
      borderRadius: theme.roundness,
    },
    rightContent: {
      alignItems: 'flex-end',
      justifyContent: 'center',
    },
    amountText: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.primary,
    },
    percentageText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    actionButtons: {
      flexDirection: 'row',
      marginTop: theme.spacing.xs,
    },
  });

================
File: app/src/modules/orders/components/order-cart/OrderTypeSelector.tsx
================
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { RadioButton } from 'react-native-paper';
import { OrderTypeEnum, type OrderType } from '../../schema/orders.schema';
import { useAppTheme } from '@/app/styles/theme';

interface OrderTypeSelectorProps {
  value: OrderType;
  onValueChange: (type: OrderType) => void;
  disabled?: boolean;
}

export const OrderTypeSelector: React.FC<OrderTypeSelectorProps> = ({
  value,
  onValueChange,
  disabled = false,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);

  return (
    <View style={styles.container}>
      <RadioButton.Group
        onValueChange={(newValue) => onValueChange(newValue as OrderType)}
        value={value}
      >
        <View style={styles.radioGroup}>
          <RadioButton.Item
            label="COMER AQU"
            value={OrderTypeEnum.DINE_IN}
            style={styles.radioButtonItem}
            labelStyle={styles.radioLabel}
            position="leading"
            disabled={disabled}
          />
          <RadioButton.Item
            label="PARA LLEVAR"
            value={OrderTypeEnum.TAKE_AWAY}
            style={styles.radioButtonItem}
            labelStyle={styles.radioLabel}
            position="leading"
            disabled={disabled}
          />
          <RadioButton.Item
            label="DOMICILIO"
            value={OrderTypeEnum.DELIVERY}
            style={styles.radioButtonItem}
            labelStyle={styles.radioLabel}
            position="leading"
            disabled={disabled}
          />
        </View>
      </RadioButton.Group>
    </View>
  );
};

const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    container: {
      paddingVertical: theme.spacing.xs,
      paddingHorizontal: theme.spacing.xs,
      marginBottom: theme.spacing.xs,
    },
    radioGroup: {
      flexDirection: 'row',
      justifyContent: 'space-around',
      alignItems: 'center',
    },
    radioButtonItem: {
      flex: 1,
      paddingVertical: 0,
      paddingHorizontal: 0,
      marginHorizontal: theme.spacing.xxs,
    },
    radioLabel: {
      fontSize: 13,
      fontWeight: '600',
      textAlign: 'center',
      marginLeft: 4,
    },
  });

================
File: app/src/modules/orders/components/order-creation/CategoryGrid.tsx
================
import React, { useMemo, useCallback, useRef } from 'react';
import { View, StyleSheet, FlatList, Animated, Pressable } from 'react-native';
import {
  Card,
  Title,
  Text,
  IconButton,
  ActivityIndicator,
  Appbar,
} from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { AutoImage } from '@/app/components/common/AutoImage';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { Category, SubCategory, Product, FullMenuCategory } from '../../schema/orders.schema';
import CartButton from '../CartButton';
import { useOrderStore, CartItem } from '../../stores/useOrderStore';
import { CategoryQuickAccess } from './CategoryQuickAccess';

interface CategoryGridProps {
  isLoading: boolean;
  navigationLevel: 'categories' | 'subcategories' | 'products';
  items: (Category | SubCategory | Product)[];
  title: string;
  onItemSelect: (item: Category | SubCategory | Product) => void;
  onBack: () => void;
  onProductInfo?: (product: Product) => void;
  showCartButton: boolean;
  cartButtonRef: React.RefObject<{ animate: () => void } | null>;
  totalItemsCount: number;
  onViewCart: () => void;
  cartItems?: CartItem[];
  categories?: FullMenuCategory[];
  selectedCategoryId?: string | null;
  onCategoryQuickSelect?: (categoryId: string) => void;
}

const AnimatedItem: React.FC<{
  item: Category | SubCategory | Product;
  styles: any;
  onPress: () => void;
  children: React.ReactNode;
  disabled?: boolean;
}> = ({ item: _item, styles, onPress, children, disabled }) => {
  const scaleValue = useRef(new Animated.Value(1)).current;
  const opacityValue = useRef(new Animated.Value(1)).current;

  const handlePressIn = () => {
    Animated.parallel([
      Animated.spring(scaleValue, {
        toValue: 0.92,
        useNativeDriver: true,
        speed: 30,
        bounciness: 0,
      }),
      Animated.timing(opacityValue, {
        toValue: 0.8,
        duration: 100,
        useNativeDriver: true,
      }),
    ]).start();
  };

  const handlePressOut = () => {
    Animated.parallel([
      Animated.spring(scaleValue, {
        toValue: 1,
        useNativeDriver: true,
        speed: 15,
        bounciness: 12,
      }),
      Animated.timing(opacityValue, {
        toValue: 1,
        duration: 200,
        useNativeDriver: true,
      }),
    ]).start();
  };

  const handlePress = () => {
    Animated.sequence([
      Animated.parallel([
        Animated.timing(scaleValue, {
          toValue: 1.08,
          duration: 120,
          useNativeDriver: true,
        }),
        Animated.timing(opacityValue, {
          toValue: 0.9,
          duration: 120,
          useNativeDriver: true,
        }),
      ]),
      Animated.parallel([
        Animated.spring(scaleValue, {
          toValue: 1,
          useNativeDriver: true,
          speed: 12,
          bounciness: 18,
        }),
        Animated.timing(opacityValue, {
          toValue: 1,
          duration: 300,
          useNativeDriver: true,
        }),
      ]),
    ]).start();

    setTimeout(() => {
      onPress();
    }, 180);
  };

  return (
    <Animated.View
      style={[
        {
          transform: [{ scale: scaleValue }],
          opacity: opacityValue,
        },
        styles.animatedContainer,
      ]}
    >
      <Pressable
        onPressIn={handlePressIn}
        onPressOut={handlePressOut}
        onPress={handlePress}
        disabled={disabled}
        style={styles.pressableStyle}
      >
        {children}
      </Pressable>
    </Animated.View>
  );
};

export const CategoryGrid: React.FC<CategoryGridProps> = ({
  isLoading,
  navigationLevel,
  items,
  title,
  onItemSelect,
  onBack,
  onProductInfo,
  showCartButton,
  cartButtonRef,
  totalItemsCount,
  onViewCart,
  cartItems,
  categories,
  selectedCategoryId,
  onCategoryQuickSelect,
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const { colors, fonts } = theme;
  const storeCartItems = useOrderStore((state) => state.items);
  const activeCartItems = cartItems || storeCartItems;
  const getProductCount = useCallback(
    (productId: string) => {
      return activeCartItems
        .filter((item) => item.productId === productId)
        .reduce((sum, item) => sum + item.quantity, 0);
    },
    [activeCartItems],
  );

  const numColumns = useMemo(() => {
    if (responsive.width >= 600) {
      if (responsive.width >= 1200) return 6;
      if (responsive.width >= 900) return 5;
      if (responsive.width >= 768) return 4;
      return 3;
    }
    if (responsive.width >= 480) return 3;
    if (responsive.width >= 360) return 2;
    return 2;
  }, [responsive.width]);

  const itemWidth = useMemo(() => {
    const padding = responsive.spacing(theme.spacing.m);
    const totalPadding = padding * 2;
    const gap = responsive.spacing(8);
    const totalGaps = gap * (numColumns - 1);
    const availableWidth = responsive.width - totalPadding - totalGaps;
    return Math.floor(availableWidth / numColumns);
  }, [responsive, numColumns, theme.spacing.m]);

  const styles = useMemo(
    () =>
      StyleSheet.create({
        safeArea: {
          flex: 1,
          backgroundColor: colors.background,
        },
        appBar: {
          backgroundColor: colors.elevation.level2,
          alignItems: 'center',
        },
        appBarTitle: {
          ...fonts.titleMedium,
          color: colors.onSurface,
          fontWeight: 'bold',
          textAlign: 'center',
        },
        appBarContent: {},
        spacer: {
          width: 48,
        },
        content: {
          flex: 1,
        },
        loadingContainer: {
          flex: 1,
          justifyContent: 'center',
          alignItems: 'center',
        },
        gridContainer: {
          padding: responsive.spacing(theme.spacing.m),
          paddingBottom: 60,
        },
        row: {
          justifyContent: 'flex-start',
          paddingHorizontal: 0,
          marginBottom: responsive.spacing(8),
          gap: responsive.spacing(8),
        },
        cardItem: {
          width: itemWidth,
          marginHorizontal: 0,
          marginVertical: 0,
          overflow: 'hidden',
          borderRadius: theme.roundness * 2,
          elevation: 2,
          backgroundColor: colors.surface,
          aspectRatio: 0.85,
        },
        cardItemInactive: {
          opacity: 0.5,
        },
        itemImage: {
          width: '100%',
          height: itemWidth * 0.65,
        },
        imageInactive: {
          opacity: 0.6,
        },
        cardContent: {
          paddingHorizontal: responsive.spacing(theme.spacing.s),
          paddingVertical: responsive.spacing(theme.spacing.xs),
          height: itemWidth * 0.35,
          justifyContent: 'center',
        },
        cardTitle: {
          fontSize: responsive.fontSize(responsive.width >= 600 ? 16 : 15),
          fontWeight: '600',
          lineHeight:
            responsive.fontSize(responsive.width >= 600 ? 16 : 15) * 1.2,
          marginBottom: responsive.spacing(2),
        },
        cardHeader: {
          flexDirection: 'row',
          justifyContent: 'space-between',
          alignItems: 'flex-start',
        },
        infoButton: {
          margin: -8,
          marginTop: -12,
          marginRight: -12,
        },
        priceText: {
          color: theme.colors.primary,
          fontWeight: '600',
          fontSize: responsive.fontSize(responsive.width >= 600 ? 14 : 13),
          marginTop: 2,
        },
        noItemsText: {
          textAlign: 'center',
          marginTop: 40,
          fontSize: 16,
          color: '#666',
        },
        inactiveBadge: {
          position: 'absolute',
          top: 8,
          right: 8,
          backgroundColor: colors.errorContainer,
          paddingHorizontal: 8,
          paddingVertical: 4,
          borderRadius: 4,
        },
        inactiveBadgeText: {
          fontSize: 12,
          color: colors.onErrorContainer,
          fontWeight: '600',
        },
        animatedContainer: {
          elevation: 3,
          shadowColor: '#000',
          shadowOffset: {
            width: 0,
            height: 2,
          },
          shadowOpacity: 0.15,
          shadowRadius: 3.84,
        },
        productBadge: {
          position: 'absolute',
          top: 8,
          left: 8,
          backgroundColor: colors.primary,
          minWidth: 24,
          height: 24,
          borderRadius: 12,
          justifyContent: 'center',
          alignItems: 'center',
          paddingHorizontal: 6,
        },
        productBadgeText: {
          color: colors.onPrimary,
          fontSize: 12,
          fontWeight: 'bold',
        },
        pressableStyle: {
          flex: 1,
        },
        flexOne: {
          flex: 1,
        },
      }),
    [colors, fonts, theme, responsive, itemWidth],
  );

  const blurhash =
    '|rF?hV%2WCj[ayj[a|j[az_NaeWBj@ayfRayfQfQM{M|azj[azf6fQfQfQIpWXofj[ayj[j[fQayWCoeoeaya}j[ayfQa{oLj?j[WVj[ayayj[fQoff7azayj[ayj[j[ayofayayayj[fQj[ayayj[ayfjj[j[ayjuayj[';

  const renderItem = useCallback(
    ({ item }: { item: Category | SubCategory | Product }) => {
      const imageSource = item.photo ? item.photo.path : null;
      const isActive = item.isActive !== false;
      const isProductWithoutScreen =
        navigationLevel === 'products' &&
        'preparationScreenId' in item &&
        !item.preparationScreenId;
      const productCount =
        navigationLevel === 'products' && 'price' in item
          ? getProductCount(item.id)
          : 0;

      const handlePress = () => {
        if (!isActive || isProductWithoutScreen) return;
        onItemSelect(item);
      };

      const renderPrice = () => {
        if (
          navigationLevel === 'products' &&
          'price' in item &&
          'hasVariants' in item
        ) {
          const productItem = item as Product;
          if (
            !productItem.hasVariants &&
            productItem.price !== null &&
            productItem.price !== undefined
          ) {
            return (
              <Text style={styles.priceText}>
                ${Number(productItem.price).toFixed(2)}
              </Text>
            );
          }
        }
        return null;
      };

      return (
        <AnimatedItem
          item={item}
          styles={styles}
          onPress={handlePress}
          disabled={!isActive || isProductWithoutScreen}
        >
          <Card
            style={[
              styles.cardItem,
              (!isActive || isProductWithoutScreen) && styles.cardItemInactive,
            ]}
          >
            <AutoImage
              source={imageSource}
              style={[
                styles.itemImage,
                (!isActive || isProductWithoutScreen) && styles.imageInactive,
              ]}
              contentFit="cover"
              placeholder={blurhash}
              transition={300}
              placeholderIcon="image-outline"
            />
            {!isActive && (
              <View style={styles.inactiveBadge}>
                <Text style={styles.inactiveBadgeText}>INACTIVO</Text>
              </View>
            )}
            {isProductWithoutScreen && (
              <View style={styles.inactiveBadge}>
                <Text style={styles.inactiveBadgeText}>SIN PANTALLA</Text>
              </View>
            )}
            {productCount > 0 && (
              <View style={styles.productBadge}>
                <Text style={styles.productBadgeText}>{productCount}</Text>
              </View>
            )}
            <View style={styles.cardContent}>
              {navigationLevel === 'products' &&
              'price' in item &&
              (item as Product).description &&
              onProductInfo ? (
                <View style={styles.cardHeader}>
                  <Title
                    style={[styles.cardTitle, styles.flexOne]}
                    numberOfLines={2}
                    ellipsizeMode="tail"
                  >
                    {item.name}
                  </Title>
                  <IconButton
                    icon="information-outline"
                    size={20}
                    onPress={() => onProductInfo(item as Product)}
                    style={styles.infoButton}
                  />
                </View>
              ) : (
                <Title
                  style={styles.cardTitle}
                  numberOfLines={2}
                  ellipsizeMode="tail"
                >
                  {item.name}
                </Title>
              )}
              {renderPrice()}
            </View>
          </Card>
        </AnimatedItem>
      );
    },
    [
      navigationLevel,
      onItemSelect,
      onProductInfo,
      styles,
      blurhash,
      getProductCount,
    ],
  );

  return (
    <SafeAreaView style={styles.safeArea} edges={['left', 'right', 'bottom']}>
      <Appbar.Header style={styles.appBar} elevated>
        <Appbar.BackAction onPress={onBack} />
        <Appbar.Content
          title={title}
          titleStyle={styles.appBarTitle}
          style={styles.appBarContent}
        />
        {showCartButton ? (
          <CartButton
            ref={cartButtonRef}
            itemCount={totalItemsCount}
            onPress={onViewCart}
          />
        ) : (
          <View style={styles.spacer} />
        )}
      </Appbar.Header>

      {navigationLevel !== 'categories' &&
        categories &&
        selectedCategoryId &&
        onCategoryQuickSelect && (
          <CategoryQuickAccess
            categories={categories}
            selectedCategoryId={selectedCategoryId}
            onCategorySelect={onCategoryQuickSelect}
          />
        )}

      <View style={styles.content}>
        {isLoading ? (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color="#2e7d32" />
            <Text>Cargando...</Text>
          </View>
        ) : items.length > 0 ? (
          <FlatList
            data={items}
            renderItem={renderItem}
            keyExtractor={(item) => item.id}
            numColumns={numColumns}
            key={numColumns}
            contentContainerStyle={styles.gridContainer}
            columnWrapperStyle={numColumns > 1 ? styles.row : undefined}
            showsVerticalScrollIndicator={false}
          />
        ) : (
          <Text style={styles.noItemsText}>
            {navigationLevel === 'products'
              ? 'No hay productos disponibles'
              : navigationLevel === 'subcategories'
                ? 'No hay subcategoras disponibles'
                : 'No hay categoras disponibles'}
          </Text>
        )}
      </View>
    </SafeAreaView>
  );
};

================
File: app/src/modules/orders/components/order-creation/CategoryQuickAccess.tsx
================
import { memo, useMemo } from 'react';
import { View, StyleSheet, Pressable } from 'react-native';
import { Text } from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { Category } from '../../schema/orders.schema';

interface CategoryQuickAccessProps {
  categories: Category[];
  selectedCategoryId: string | null;
  onCategorySelect: (categoryId: string) => void;
}

export const CategoryQuickAccess = memo<CategoryQuickAccessProps>(
  ({ categories, selectedCategoryId, onCategorySelect }) => {
    const theme = useAppTheme();

    const styles = useMemo(
      () =>
        StyleSheet.create({
          container: {
            backgroundColor: theme.colors.background,
            paddingTop: theme.spacing.s,
            paddingBottom: 0,
            paddingHorizontal: theme.spacing.m,
          },
          scrollContent: {
            flexDirection: 'row',
            alignItems: 'center',
            gap: theme.spacing.xs,
          },
          categoryChip: {},
          categoryChipInner: {
            paddingHorizontal: theme.spacing.m,
            paddingVertical: theme.spacing.s,
            borderRadius: theme.roundness,
            borderWidth: 1,
            borderColor: theme.colors.surfaceVariant,
            backgroundColor: theme.colors.surface,
            alignItems: 'center',
            justifyContent: 'center',
            minHeight: 40,
          },
          categoryChipSelected: {
            backgroundColor: theme.colors.primaryContainer,
            borderColor: theme.colors.primary,
            elevation: 2,
          },
          categoryChipInactive: {
            opacity: 0.5,
          },
          categoryText: {
            fontSize: 17,
            fontWeight: 'bold',
            textAlign: 'center',
            color: theme.colors.onSurface,
          },
          categoryTextSelected: {
            color: theme.colors.primary,
            fontWeight: 'bold',
          },
          categoryTextInactive: {
            color: theme.colors.onSurfaceDisabled,
          },
          flexOne: {
            flex: 1,
          },
        }),
      [theme],
    );

    const activeCategories = useMemo(
      () => categories.filter((cat) => cat.isActive !== false),
      [categories],
    );

    if (activeCategories.length === 0) {
      return null;
    }

    const categoryRows = [];
    for (let i = 0; i < activeCategories.length; i += 4) {
      categoryRows.push(activeCategories.slice(i, i + 4));
    }

    return (
      <View style={styles.container}>
        {categoryRows.map((row, rowIndex) => (
          <View key={rowIndex} style={styles.scrollContent}>
            {row.map((category) => {
              const isSelected = category.id === selectedCategoryId;
              const isInactive = category.isActive === false;

              return (
                <Pressable
                  key={category.id}
                  style={[styles.categoryChip, styles.flexOne]}
                  onPress={() => !isInactive && onCategorySelect(category.id)}
                  disabled={isInactive}
                >
                  <View
                    style={[
                      styles.categoryChipInner,
                      isSelected && styles.categoryChipSelected,
                      isInactive && styles.categoryChipInactive,
                    ]}
                  >
                    <Text
                      style={[
                        styles.categoryText,
                        isSelected && styles.categoryTextSelected,
                        isInactive && styles.categoryTextInactive,
                      ]}
                      numberOfLines={1}
                      ellipsizeMode="tail"
                    >
                      {category.name}
                    </Text>
                  </View>
                </Pressable>
              );
            })}
          </View>
        ))}
      </View>
    );
  },
);

================
File: app/src/modules/orders/components/PizzaCustomizationSection.tsx
================
import { useState, useMemo, useCallback, memo } from 'react';
import { View, StyleSheet } from 'react-native';
import {
  Text,
  Card,
  ActivityIndicator,
  Surface,
  Switch,
  IconButton,
  TouchableRipple,
  RadioButton,
} from 'react-native-paper';
import type { SelectedPizzaCustomization } from '@/app/schemas/domain/order.schema';
import type { PizzaCustomization } from '@/modules/pizzaCustomizations/schema/pizzaCustomization.schema';
import type { PizzaConfiguration } from '@/modules/pizzaCustomizations/schema/pizzaConfiguration.schema';
import { CustomizationTypeEnum } from '@/modules/pizzaCustomizations/schema/pizzaCustomization.schema';
import { useAppTheme } from '@/app/styles/theme';

// Extraer tipos del SelectedPizzaCustomization
type PizzaHalf = SelectedPizzaCustomization['half'];
type CustomizationAction = SelectedPizzaCustomization['action'];

// Constantes para los valores
const PIZZA_HALF = {
  FULL: 'FULL' as PizzaHalf,
  HALF_1: 'HALF_1' as PizzaHalf,
  HALF_2: 'HALF_2' as PizzaHalf,
} as const;

const CUSTOMIZATION_ACTION = {
  ADD: 'ADD' as CustomizationAction,
  REMOVE: 'REMOVE' as CustomizationAction,
} as const;

interface PizzaCustomizationSectionProps {
  pizzaCustomizations: PizzaCustomization[];
  pizzaConfiguration: PizzaConfiguration | null;
  selectedPizzaCustomizations: SelectedPizzaCustomization[];
  onCustomizationChange: (customizations: SelectedPizzaCustomization[]) => void;
  loading?: boolean;
}

interface FlavorItemProps {
  flavor: PizzaCustomization;
  isSelected: boolean;
  isDisabled: boolean;
  onToggle: (flavorId: string) => void;
  styles: any;
  theme: any;
}

const FlavorItem = memo<FlavorItemProps>(
  ({ flavor, isSelected, isDisabled, onToggle, styles }) => (
    <Surface
      style={[
        styles.flavorChip,
        isSelected && styles.flavorChipSelected,
        isDisabled && styles.flavorChipDisabled,
      ]}
      elevation={isSelected ? 2 : 0}
    >
      <TouchableRipple
        onPress={() => !isDisabled && onToggle(flavor.id)}
        disabled={isDisabled}
        style={styles.touchableRippleStyle}
      >
        <View style={styles.flavorItemContainer}>
          <RadioButton
            value={flavor.id}
            status={isSelected ? 'checked' : 'unchecked'}
            disabled={isDisabled}
            onPress={() => !isDisabled && onToggle(flavor.id)}
          />
          <View style={styles.flavorContentContainer}>
            <View style={styles.flavorTitleContainer}>
              <Text
                style={[
                  styles.flavorLabel,
                  isDisabled && styles.flavorLabelDisabled,
                ]}
              >
                {flavor.name}
              </Text>
              <Text
                style={[
                  styles.toppingValue,
                  isDisabled && styles.flavorLabelDisabled,
                ]}
              >
                ({flavor.toppingValue})
              </Text>
            </View>
            {flavor.ingredients && (
              <Text
                style={[
                  styles.ingredientsText,
                  isDisabled && styles.flavorLabelDisabled,
                ]}
              >
                {flavor.ingredients}
              </Text>
            )}
          </View>
        </View>
      </TouchableRipple>
    </Surface>
  ),
);

const PizzaCustomizationSection = memo<PizzaCustomizationSectionProps>(
  ({
    pizzaCustomizations,
    pizzaConfiguration,
    selectedPizzaCustomizations,
    onCustomizationChange,
    loading = false,
  }) => {
    const theme = useAppTheme();
    const styles = useMemo(() => createStyles(theme), [theme]);
    const [manualHalvesMode, setManualHalvesMode] = useState(false);
    const [expandedIngredients, setExpandedIngredients] = useState<{
      full: boolean;
      half1: boolean;
      half2: boolean;
    }>({
      full: false,
      half1: false,
      half2: false,
    });
    const [expandedFlavors, setExpandedFlavors] = useState(true);

    // Separar sabores e ingredientes
    const flavors = useMemo(
      () =>
        pizzaCustomizations.filter(
          (c) => c.type === CustomizationTypeEnum.FLAVOR,
        ),
      [pizzaCustomizations],
    );

    const ingredients = useMemo(
      () =>
        pizzaCustomizations.filter(
          (c) => c.type === CustomizationTypeEnum.INGREDIENT,
        ),
      [pizzaCustomizations],
    );

    // Obtener sabores seleccionados
    const selectedFlavors = useMemo(
      () =>
        selectedPizzaCustomizations.filter(
          (sc) =>
            sc.action === CUSTOMIZATION_ACTION.ADD &&
            flavors.some((f) => f.id === sc.pizzaCustomizationId),
        ),
      [selectedPizzaCustomizations, flavors],
    );

    // Obtener el nombre del sabor por ID
    const getFlavorName = useCallback(
      (flavorId: string) => {
        const flavor = flavors.find((f) => f.id === flavorId);
        return flavor?.name || '';
      },
      [flavors],
    );

    const handleFlavorToggle = useCallback(
      (flavorId: string) => {
        const isSelected = selectedPizzaCustomizations.some(
          (sc) =>
            sc.pizzaCustomizationId === flavorId &&
            sc.action === CUSTOMIZATION_ACTION.ADD,
        );

        if (isSelected) {
          // Deseleccionar
          const remainingFlavorSelections = selectedPizzaCustomizations.filter(
            (sc) =>
              !(
                sc.pizzaCustomizationId === flavorId &&
                sc.action === CUSTOMIZATION_ACTION.ADD
              ),
          );

          // Si queda solo un sabor despus de deseleccionar, cambiar su half a FULL
          const remainingFlavors = remainingFlavorSelections.filter(
            (sc) =>
              sc.action === CUSTOMIZATION_ACTION.ADD &&
              flavors.some((f) => f.id === sc.pizzaCustomizationId),
          );

          if (remainingFlavors.length === 1) {
            const otherFlavorId = remainingFlavors[0].pizzaCustomizationId;
            const nonFlavorSelections = remainingFlavorSelections.filter(
              (sc) =>
                !flavors.some((f) => f.id === sc.pizzaCustomizationId) ||
                sc.action !== CUSTOMIZATION_ACTION.ADD,
            );

            onCustomizationChange([
              ...nonFlavorSelections,
              {
                pizzaCustomizationId: otherFlavorId,
                half: PIZZA_HALF.FULL,
                action: CUSTOMIZATION_ACTION.ADD,
              },
            ]);
          } else {
            onCustomizationChange(remainingFlavorSelections);
          }
        } else {
          // Seleccionar
          const currentFlavors = selectedPizzaCustomizations.filter(
            (sc) =>
              sc.action === CUSTOMIZATION_ACTION.ADD &&
              flavors.some((f) => f.id === sc.pizzaCustomizationId),
          );

          if (currentFlavors.length >= 2) {
            return; // No permitir ms de 2
          }

          const nonFlavorSelections = selectedPizzaCustomizations.filter(
            (sc) =>
              !flavors.some((f) => f.id === sc.pizzaCustomizationId) ||
              sc.action !== CUSTOMIZATION_ACTION.ADD,
          );

          if (currentFlavors.length === 0) {
            // Primer sabor - va completo o a mitad 1 si est el modo manual
            if (manualHalvesMode) {
              onCustomizationChange([
                ...nonFlavorSelections,
                {
                  pizzaCustomizationId: flavorId,
                  half: PIZZA_HALF.HALF_1,
                  action: CUSTOMIZATION_ACTION.ADD,
                },
              ]);
            } else {
              onCustomizationChange([
                ...nonFlavorSelections,
                {
                  pizzaCustomizationId: flavorId,
                  half: PIZZA_HALF.FULL,
                  action: CUSTOMIZATION_ACTION.ADD,
                },
              ]);
            }
          } else if (currentFlavors.length === 1) {
            // Segundo sabor - convertir a mitades
            const existingFlavor = currentFlavors[0];

            // Cambiar el sabor existente a mitad 1
            nonFlavorSelections.push({
              pizzaCustomizationId: existingFlavor.pizzaCustomizationId,
              half: PIZZA_HALF.HALF_1,
              action: CUSTOMIZATION_ACTION.ADD,
            });

            // Agregar el nuevo sabor a mitad 2
            nonFlavorSelections.push({
              pizzaCustomizationId: flavorId,
              half: PIZZA_HALF.HALF_2,
              action: CUSTOMIZATION_ACTION.ADD,
            });

            onCustomizationChange(nonFlavorSelections);
          }
        }
      },
      [
        selectedPizzaCustomizations,
        flavors,
        onCustomizationChange,
        manualHalvesMode,
      ],
    );

    const toggleIngredient = useCallback(
      (
        ingredientId: string,
        half: PizzaHalf,
        action: CustomizationAction,
      ) => {
        const existingIndex = selectedPizzaCustomizations.findIndex(
          (sc) =>
            sc.pizzaCustomizationId === ingredientId &&
            sc.half === half &&
            sc.action === action,
        );

        let newSelections: SelectedPizzaCustomization[];

        if (existingIndex >= 0) {
          newSelections = selectedPizzaCustomizations.filter(
            (_, index) => index !== existingIndex,
          );
        } else {
          // Remover cualquier accin previa del mismo ingrediente en la misma mitad
          newSelections = selectedPizzaCustomizations.filter(
            (sc) =>
              !(sc.pizzaCustomizationId === ingredientId && sc.half === half),
          );

          newSelections.push({
            pizzaCustomizationId: ingredientId,
            half,
            action,
          });
        }

        onCustomizationChange(newSelections);
      },
      [selectedPizzaCustomizations, onCustomizationChange],
    );

    const isIngredientSelected = useCallback(
      (
        ingredientId: string,
        half: PizzaHalf,
        action: CustomizationAction,
      ): boolean => {
        return selectedPizzaCustomizations.some(
          (sc) =>
            sc.pizzaCustomizationId === ingredientId &&
            sc.half === half &&
            sc.action === action,
        );
      },
      [selectedPizzaCustomizations],
    );

    // Determinar si mostrar modo mitades (2 sabores o modo manual activado)
    const showHalvesMode =
      selectedFlavors.length === 2 ||
      (manualHalvesMode && selectedFlavors.length <= 1);

    // Returns condicionales al final, despus de todos los hooks
    if (loading) {
      return (
        <View style={styles.loadingContainer}>
          <ActivityIndicator animating size="large" />
          <Text style={styles.loadingText}>Cargando opciones de pizza...</Text>
        </View>
      );
    }

    if (!pizzaConfiguration || pizzaCustomizations.length === 0) {
      return null;
    }

    // Renderizar seccin de personalizacin
    const renderCustomizationSection = (
      half: PizzaHalf,
      sectionTitle: string,
      flavorName?: string,
    ) => {
      const sectionKey =
        half === PIZZA_HALF.FULL
          ? 'full'
          : half === PIZZA_HALF.HALF_1
            ? 'half1'
            : 'half2';
      const isExpanded = expandedIngredients[sectionKey];

      // Construir el ttulo dinmico con el formato completo
      const getDynamicTitle = () => {
        const customizationsForHalf = selectedPizzaCustomizations.filter(
          (sc) => sc.half === half,
        );

        const parts: string[] = [];

        // Agregar el sabor si existe
        if (flavorName) {
          parts.push(flavorName);
        } else if (half !== PIZZA_HALF.FULL) {
          // Para mitades sin sabor
          parts.push('Sin sabor');
        }

        // Filtrar ingredientes
        const addedIngredients: string[] = [];
        const removedIngredients: string[] = [];

        customizationsForHalf.forEach((sc) => {
          const customization = ingredients.find(
            (c) => c.id === sc.pizzaCustomizationId,
          );
          if (customization) {
            if (sc.action === CUSTOMIZATION_ACTION.ADD) {
              addedIngredients.push(customization.name);
            } else {
              removedIngredients.push(customization.name);
            }
          }
        });

        if (addedIngredients.length > 0) {
          parts.push(`con: ${addedIngredients.join(', ')}`);
        }
        if (removedIngredients.length > 0) {
          parts.push(`sin: ${removedIngredients.join(', ')}`);
        }

        return parts.length > 0
          ? parts.join(' - ')
          : flavorName || 'Sin personalizar';
      };

      return (
        <Card style={styles.optionCard}>
          <Card.Content style={styles.cardContentStyle}>
            <View style={styles.sectionHeader}>
              <Text style={styles.sectionTitle}>
                {sectionTitle}:{' '}
                <Text style={styles.pizzaFormat}>{getDynamicTitle()}</Text>
              </Text>
            </View>

            <Surface style={styles.subsectionSurface} elevation={1}>
              <TouchableRipple
                onPress={() =>
                  setExpandedIngredients((prev) => ({
                    ...prev,
                    [sectionKey]: !prev[sectionKey],
                  }))
                }
                style={styles.subsectionTouchableStyle}
              >
                <View style={styles.subsectionHeader}>
                  <Text style={styles.subsectionTitle}>
                    Personalizar Ingredientes
                  </Text>
                  <IconButton
                    icon={isExpanded ? 'chevron-up' : 'chevron-down'}
                    size={20}
                    style={styles.iconButtonStyle}
                  />
                </View>
              </TouchableRipple>

              {isExpanded && (
                <View style={styles.ingredientsContainer}>
                  {ingredients.map((ingredient) => {
                    const isAddSelected = isIngredientSelected(
                      ingredient.id,
                      half,
                      CUSTOMIZATION_ACTION.ADD,
                    );
                    const isRemoveSelected = isIngredientSelected(
                      ingredient.id,
                      half,
                      CUSTOMIZATION_ACTION.REMOVE,
                    );
                    const isSelected = isAddSelected || isRemoveSelected;
                    const currentAction = isAddSelected
                      ? CUSTOMIZATION_ACTION.ADD
                      : CUSTOMIZATION_ACTION.REMOVE;

                    return (
                      <Surface
                        key={ingredient.id}
                        style={styles.ingredientItem}
                        elevation={0}
                      >
                        <TouchableRipple
                          onPress={() => {
                            if (isSelected) {
                              toggleIngredient(
                                ingredient.id,
                                half,
                                currentAction,
                              );
                            } else {
                              toggleIngredient(
                                ingredient.id,
                                half,
                                CUSTOMIZATION_ACTION.ADD,
                              );
                            }
                          }}
                          style={styles.ingredientTouchableStyle}
                        >
                          <View style={styles.ingredientRowContainer}>
                            <View style={styles.ingredientInfoContainer}>
                              <View style={styles.ingredientNameContainer}>
                                <Text style={styles.ingredientLabel}>
                                  {ingredient.name}
                                </Text>
                                <Text style={styles.toppingValueSmall}>
                                  ({ingredient.toppingValue})
                                </Text>
                              </View>
                            </View>
                            {isSelected && (
                              <View style={styles.actionToggle}>
                                <Text
                                  style={[
                                    styles.toggleLabel,
                                    currentAction ===
                                      CUSTOMIZATION_ACTION.ADD &&
                                      styles.activeLabel,
                                  ]}
                                >
                                  Agregar
                                </Text>
                                <Switch
                                  value={
                                    currentAction ===
                                    CUSTOMIZATION_ACTION.REMOVE
                                  }
                                  onValueChange={(value) => {
                                    const newAction = value
                                      ? CUSTOMIZATION_ACTION.REMOVE
                                      : CUSTOMIZATION_ACTION.ADD;
                                    toggleIngredient(
                                      ingredient.id,
                                      half,
                                      newAction,
                                    );
                                  }}
                                  style={styles.switch}
                                />
                                <Text
                                  style={[
                                    styles.toggleLabel,
                                    currentAction ===
                                      CUSTOMIZATION_ACTION.REMOVE &&
                                      styles.activeLabel,
                                  ]}
                                >
                                  Quitar
                                </Text>
                              </View>
                            )}
                            <RadioButton
                              value={ingredient.id}
                              status={isSelected ? 'checked' : 'unchecked'}
                              onPress={() => {
                                if (isSelected) {
                                  toggleIngredient(
                                    ingredient.id,
                                    half,
                                    currentAction,
                                  );
                                } else {
                                  toggleIngredient(
                                    ingredient.id,
                                    half,
                                    CUSTOMIZATION_ACTION.ADD,
                                  );
                                }
                              }}
                            />
                          </View>
                        </TouchableRipple>
                      </Surface>
                    );
                  })}
                </View>
              )}
            </Surface>
          </Card.Content>
        </Card>
      );
    };

    return (
      <View style={styles.container}>
        {/* Seleccin de Sabores */}
        <Card style={styles.optionCard}>
          <Card.Content style={styles.cardContentStyle}>
            <TouchableRipple
              onPress={() => setExpandedFlavors(!expandedFlavors)}
              style={[
                styles.dynamicMarginBottom,
                expandedFlavors
                  ? styles.expandedMarginBottom
                  : styles.collapsedMarginBottom,
              ]}
            >
              <View style={styles.sectionHeaderWithSwitch}>
                <View style={styles.flavorSectionContainer}>
                  <View style={styles.flavorHeaderContainer}>
                    <Text style={styles.sectionTitle}>
                      Sabores
                      {selectedFlavors.length > 0 && (
                        <Text style={styles.pizzaFormat}>
                          {' - '}
                          {selectedFlavors
                            .map((sf) => {
                              const flavor = flavors.find(
                                (f) => f.id === sf.pizzaCustomizationId,
                              );
                              return flavor?.name || '';
                            })
                            .join(' / ')}
                        </Text>
                      )}
                    </Text>
                    <IconButton
                      icon={expandedFlavors ? 'chevron-up' : 'chevron-down'}
                      size={20}
                      style={styles.iconButtonStyle}
                    />
                  </View>
                  {expandedFlavors && (
                    <Text style={styles.helperText}>
                      Selecciona hasta 2 sabores
                    </Text>
                  )}
                </View>
                {expandedFlavors && selectedFlavors.length <= 1 && (
                  <View style={styles.halvesSwitch}>
                    <Text style={styles.switchLabel}>Dividir mitades</Text>
                    <Switch
                      value={manualHalvesMode}
                      onValueChange={(value) => {
                        setManualHalvesMode(value);

                        // Si se activa el modo mitades, convertir las personalizaciones de FULL a HALF_1
                        if (value && selectedFlavors.length <= 1) {
                          const updatedCustomizations =
                            selectedPizzaCustomizations.map((sc) => {
                              if (sc.half === PIZZA_HALF.FULL) {
                                return { ...sc, half: PIZZA_HALF.HALF_1 };
                              }
                              return sc;
                            });
                          onCustomizationChange(updatedCustomizations);
                        }
                        // Si se desactiva el modo mitades y solo hay un sabor, convertir todo a FULL
                        else if (!value && selectedFlavors.length === 1) {
                          const updatedCustomizations =
                            selectedPizzaCustomizations.map((sc) => {
                              if (
                                sc.half === PIZZA_HALF.HALF_1 ||
                                sc.half === PIZZA_HALF.HALF_2
                              ) {
                                return { ...sc, half: PIZZA_HALF.FULL };
                              }
                              return sc;
                            });
                          onCustomizationChange(updatedCustomizations);
                        }
                      }}
                    />
                  </View>
                )}
              </View>
            </TouchableRipple>
            {expandedFlavors && (
              <View style={styles.flavorsGrid}>
                {flavors.map((flavor) => {
                  const isSelected = selectedFlavors.some(
                    (sf) => sf.pizzaCustomizationId === flavor.id,
                  );
                  const isDisabled = selectedFlavors.length >= 2 && !isSelected;

                  return (
                    <FlavorItem
                      key={flavor.id}
                      flavor={flavor}
                      isSelected={isSelected}
                      isDisabled={isDisabled}
                      onToggle={handleFlavorToggle}
                      styles={styles}
                      theme={theme}
                    />
                  );
                })}
              </View>
            )}
          </Card.Content>
        </Card>

        {/* Secciones de Personalizacin */}
        {showHalvesMode ? (
          // Modo mitades (2 sabores o modo manual)
          <>
            {renderCustomizationSection(
              PIZZA_HALF.HALF_1,
              'Mitad 1',
              selectedFlavors[0]
                ? getFlavorName(selectedFlavors[0].pizzaCustomizationId)
                : undefined,
            )}
            {renderCustomizationSection(
              PIZZA_HALF.HALF_2,
              'Mitad 2',
              selectedFlavors[1]
                ? getFlavorName(selectedFlavors[1].pizzaCustomizationId)
                : undefined,
            )}
          </>
        ) : (
          // Modo completo (sin sabores o 1 sabor)
          renderCustomizationSection(
            PIZZA_HALF.FULL,
            'Pizza Completa',
            selectedFlavors[0]
              ? getFlavorName(selectedFlavors[0].pizzaCustomizationId)
              : undefined,
          )
        )}
      </View>
    );
  },
);

const createStyles = (theme: any) =>
  StyleSheet.create({
    container: {
      gap: 8,
    },
    loadingContainer: {
      padding: 32,
      alignItems: 'center',
    },
    loadingText: {
      marginTop: 16,
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    optionCard: {
      backgroundColor: theme.colors.surface,
      borderRadius: 12,
      elevation: 1,
    },
    pizzaFormat: {
      fontSize: 16,
      fontWeight: 'normal',
      color: theme.colors.primary,
    },
    sectionHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 12,
    },
    sectionHeaderWithSwitch: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
    },
    halvesSwitch: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 8,
    },
    switchLabel: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    sectionTitle: {
      fontSize: 18,
      fontWeight: 'bold',
      color: theme.colors.onSurface,
    },
    flavorInline: {
      fontSize: 16,
      fontWeight: 'normal',
      color: theme.colors.primary,
    },
    helperText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 12,
    },
    flavorsGrid: {
      gap: 8,
    },
    flavorChip: {
      backgroundColor: theme.colors.surface,
      borderRadius: 8,
      borderWidth: 1,
      borderColor: theme.colors.outline,
      elevation: 0,
      overflow: 'hidden',
    },
    flavorChipSelected: {
      backgroundColor: theme.colors.primaryContainer,
      borderColor: theme.colors.primary,
    },
    flavorChipDisabled: {
      opacity: 0.5,
    },
    flavorLabel: {
      fontSize: 14,
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    flavorLabelDisabled: {
      color: theme.colors.onSurfaceDisabled,
    },
    ingredientsText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
    },
    toppingValue: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      opacity: 0.6,
    },
    toppingValueSmall: {
      fontSize: 11,
      color: theme.colors.onSurfaceVariant,
      opacity: 0.5,
    },
    subsectionSurface: {
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: 8,
      marginTop: 8,
    },
    subsectionHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    subsectionTitle: {
      fontSize: 16,
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    ingredientItem: {
      backgroundColor: 'transparent',
      marginTop: 4,
    },
    ingredientLabel: {
      fontSize: 14,
      color: theme.colors.onSurface,
    },
    actionToggle: {
      flexDirection: 'row',
      alignItems: 'center',
      marginRight: 8,
    },
    toggleLabel: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
      fontWeight: '500',
    },
    activeLabel: {
      color: theme.colors.primary,
      fontWeight: 'bold',
    },
    switch: {
      marginHorizontal: 8,
      transform: [{ scale: 1.2 }],
    },
    priceInfoText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    touchableRippleStyle: {
      paddingVertical: 12,
      paddingHorizontal: 16,
      borderRadius: 8,
    },
    flavorItemContainer: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    flavorContentContainer: {
      flex: 1,
      marginLeft: 8,
    },
    flavorTitleContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 8,
    },
    cardContentStyle: {
      paddingVertical: 16,
      paddingHorizontal: 16,
    },
    subsectionTouchableStyle: {
      paddingVertical: 12,
      paddingHorizontal: 16,
    },
    iconButtonStyle: {
      margin: -8,
    },
    ingredientsContainer: {
      paddingHorizontal: 16,
      paddingBottom: 12,
    },
    ingredientTouchableStyle: {
      paddingVertical: 8,
      paddingHorizontal: 8,
    },
    ingredientRowContainer: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    ingredientInfoContainer: {
      flex: 1,
    },
    ingredientNameContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 6,
    },
    dynamicMarginBottom: {
      // Base style for dynamic margin
    },
    expandedMarginBottom: {
      marginBottom: 12,
    },
    collapsedMarginBottom: {
      marginBottom: 0,
    },
    flavorSectionContainer: {
      flex: 1,
    },
    flavorHeaderContainer: {
      flexDirection: 'row',
      alignItems: 'center',
    },
  });

PizzaCustomizationSection.displayName = 'PizzaCustomizationSection';

export default PizzaCustomizationSection;

================
File: app/src/modules/orders/stores/useOrderStore.ts
================
import { create } from 'zustand';
import type { Product } from '../schema/orders.schema';
import type { SelectedPizzaCustomization } from '../../../app/schemas/domain/order.schema';
import { OrderTypeEnum, type OrderType } from '../schema/orders.schema';
import type { DeliveryInfo } from '../../../app/schemas/domain/delivery-info.schema';
import type { OrderAdjustment } from '../schema/adjustments.schema';
import type { OrderItemDtoForBackend } from '../schema/update-order.schema';

const generateId = () => {
  const timestamp = Date.now().toString();
  const random1 = Math.floor(Math.random() * 1000000).toString();
  const random2 = Math.floor(Math.random() * 1000000).toString();
  return `${timestamp}-${random1}-${random2}`;
};

export interface CartItemModifier {
  id: string;
  modifierGroupId: string;
  name: string;
  price: number;
}

export interface CartItem {
  id: string;
  productId: string;
  productName: string;
  quantity: number;
  unitPrice: number;
  totalPrice: number;
  modifiers: CartItemModifier[];
  variantId?: string;
  variantName?: string;
  preparationNotes?: string;
  notes?: string;
  preparationStatus?:
    | 'NEW'
    | 'PENDING'
    | 'IN_PROGRESS'
    | 'READY'
    | 'DELIVERED'
    | 'CANCELLED';
  selectedPizzaCustomizations?: SelectedPizzaCustomization[];
  pizzaExtraCost?: number;
}

export interface OrderDetailsForBackend {
  userId?: string;
  orderType: OrderType;
  subtotal: number;
  total: number;
  items: OrderItemDtoForBackend[];
  tableId?: string;
  isTemporaryTable?: boolean;
  temporaryTableName?: string;
  temporaryTableAreaId?: string;
  scheduledAt?: Date;
  deliveryInfo: DeliveryInfo;
  notes?: string;
  payment?: {
    amount: number;
    method: 'CASH' | 'CARD' | 'TRANSFER';
  };
  adjustments?: {
    orderId?: string;
    name: string;
    isPercentage: boolean;
    value?: number;
    amount?: number;
  }[];
  prepaymentId?: string;
}

interface OrderState {
  id: string | null; // ID de la orden que se est editando
  isEditMode: boolean;
  items: CartItem[];
  orderType: OrderType;
  selectedAreaId: string | null;
  selectedTableId: string | null;
  isTemporaryTable: boolean;
  temporaryTableName: string;
  scheduledTime: Date | null;
  deliveryInfo: DeliveryInfo;
  orderNotes: string;
  adjustments: OrderAdjustment[];
  prepaymentId: string | null;
  prepaymentAmount: string;
  prepaymentMethod: 'CASH' | 'CARD' | 'TRANSFER' | null;
  isCartVisible: boolean;
  isLoading: boolean;
  isConfirming: boolean;
  hasUnsavedChanges: boolean;
  orderDataLoaded: boolean;
  originalState: {
    items: CartItem[];
    orderType: OrderType;
    tableId: string | null;
    isTemporaryTable: boolean;
    temporaryTableName: string;
    deliveryInfo: DeliveryInfo;
    notes: string;
    scheduledAt: Date | null;
    adjustments: OrderAdjustment[];
  } | null;
  addItem: (
    product: Product,
    quantity?: number,
    variantId?: string,
    modifiers?: CartItemModifier[],
    preparationNotes?: string,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost?: number,
  ) => void;
  removeItem: (itemId: string) => void;
  updateItemQuantity: (itemId: string, quantity: number) => void;
  updateItem: (
    itemId: string,
    quantity: number,
    modifiers: CartItemModifier[],
    preparationNotes?: string,
    variantId?: string,
    variantName?: string,
    unitPrice?: number,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost?: number,
  ) => void;
  setItems: (items: CartItem[]) => void;
  setOrderType: (type: OrderType) => void;
  setSelectedAreaId: (id: string | null) => void;
  setSelectedTableId: (id: string | null) => void;
  setIsTemporaryTable: (isTemp: boolean) => void;
  setTemporaryTableName: (name: string) => void;
  setScheduledTime: (time: Date | null) => void;
  setDeliveryInfo: (info: DeliveryInfo) => void;
  setOrderNotes: (notes: string) => void;
  setAdjustments: (adjustments: OrderAdjustment[]) => void;
  addAdjustment: (adjustment: OrderAdjustment) => void;
  updateAdjustment: (id: string, adjustment: Partial<OrderAdjustment>) => void;
  removeAdjustment: (id: string) => void;
  setPrepaymentId: (id: string | null) => void;
  setPrepaymentAmount: (amount: string) => void;
  setPrepaymentMethod: (method: 'CASH' | 'CARD' | 'TRANSFER' | null) => void;
  showCart: () => void;
  hideCart: () => void;
  setIsLoading: (loading: boolean) => void;
  setIsConfirming: (confirming: boolean) => void;
  loadOrderForEditing: (orderData: any, fullMenuData?: any) => void;
  checkForUnsavedChanges: () => void;
  resetOrder: () => void;
  resetToOriginalState: () => void;
  prepareOrderForBackend: () => OrderDetailsForBackend | null;
  validateForConfirmation: () => { isValid: boolean; errorMessage?: string };
  getValidationErrors: () => string[];
  confirmOrder: (
    userId: string,
    onConfirmOrder: (details: OrderDetailsForBackend) => Promise<void>,
  ) => Promise<void>;
}

const calculateTotalPrice = (
  unitPrice: number,
  modifiers: CartItemModifier[],
  pizzaExtraCost: number,
  quantity: number,
) => {
  const modifiersPrice = modifiers.reduce(
    (sum, mod) => sum + (mod.price || 0),
    0,
  );
  return (unitPrice + modifiersPrice + pizzaExtraCost) * quantity;
};

const findModifierById = (modifierId: string, fullMenuData: any) => {
  if (!fullMenuData) return null;

  for (const product of fullMenuData) {
    for (const group of product.modifierGroups || []) {
      for (const modifier of group.modifiers || []) {
        if (modifier.id === modifierId) {
          return {
            id: modifier.id,
            modifierGroupId: group.id,
            name: modifier.name,
            price: modifier.price,
          };
        }
      }
    }
  }
  return null;
};

export const useOrderStore = create<OrderState>((set, get) => ({
  id: null,
  isEditMode: false,
  items: [],
  orderType: OrderTypeEnum.DINE_IN,
  selectedAreaId: null,
  selectedTableId: null,
  isTemporaryTable: false,
  temporaryTableName: '',
  scheduledTime: null,
  deliveryInfo: {},
  orderNotes: '',
  adjustments: [],
  prepaymentId: null,
  prepaymentAmount: '',
  prepaymentMethod: null,
  isCartVisible: false,
  isLoading: false,
  isConfirming: false,
  hasUnsavedChanges: false,
  orderDataLoaded: false,
  originalState: null,

  addItem: (
    product: Product,
    quantity: number = 1,
    variantId?: string,
    modifiers: CartItemModifier[] = [],
    preparationNotes?: string,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost: number = 0,
  ) => {
    const { items, isEditMode } = get();

    const variantToAdd = variantId
      ? product.variants?.find((v) => v.id === variantId)
      : undefined;

    const unitPrice = variantToAdd
      ? Number(variantToAdd.price)
      : Number(product.price);

    if (isEditMode) {
      const newItem: CartItem = {
        id: `new-${Date.now()}-${Math.floor(Math.random() * 1000000)}`,
        productId: product.id,
        productName: product.name,
        quantity,
        unitPrice,
        totalPrice: calculateTotalPrice(
          unitPrice,
          modifiers,
          pizzaExtraCost,
          quantity,
        ),
        modifiers,
        variantId,
        variantName: variantToAdd?.name,
        preparationNotes,
        selectedPizzaCustomizations,
        pizzaExtraCost,
        preparationStatus: 'NEW' as const,
      };

      set({ items: [...items, newItem] });
      get().checkForUnsavedChanges();
      return;
    }

    const existingItemIndex = items.findIndex((item) => {
      if (item.productId !== product.id) return false;
      if (item.variantId !== variantId) return false;
      if (item.preparationNotes !== preparationNotes) return false;
      if (item.modifiers.length !== modifiers.length) return false;

      const sortedExistingModifiers = [...item.modifiers].sort((a, b) =>
        a.id.localeCompare(b.id),
      );
      const sortedNewModifiers = [...modifiers].sort((a, b) =>
        a.id.localeCompare(b.id),
      );

      for (let i = 0; i < sortedExistingModifiers.length; i++) {
        if (sortedExistingModifiers[i].id !== sortedNewModifiers[i].id) {
          return false;
        }
      }

      const existingCustomizations = item.selectedPizzaCustomizations || [];
      const newCustomizations = selectedPizzaCustomizations || [];

      if (existingCustomizations.length !== newCustomizations.length)
        return false;

      const sortedExistingCustomizations = [...existingCustomizations].sort(
        (a, b) =>
          `${a.pizzaCustomizationId}-${a.half}-${a.action}`.localeCompare(
            `${b.pizzaCustomizationId}-${b.half}-${b.action}`,
          ),
      );
      const sortedNewCustomizations = [...newCustomizations].sort((a, b) =>
        `${a.pizzaCustomizationId}-${a.half}-${a.action}`.localeCompare(
          `${b.pizzaCustomizationId}-${b.half}-${b.action}`,
        ),
      );

      for (let i = 0; i < sortedExistingCustomizations.length; i++) {
        if (
          sortedExistingCustomizations[i].pizzaCustomizationId !==
            sortedNewCustomizations[i].pizzaCustomizationId ||
          sortedExistingCustomizations[i].half !==
            sortedNewCustomizations[i].half ||
          sortedExistingCustomizations[i].action !==
            sortedNewCustomizations[i].action
        ) {
          return false;
        }
      }

      return true;
    });

    if (existingItemIndex !== -1) {
      const updatedItems = [...items];
      const existingItem = updatedItems[existingItemIndex];
      const newQuantity = existingItem.quantity + quantity;

      updatedItems[existingItemIndex] = {
        ...existingItem,
        quantity: newQuantity,
        totalPrice: calculateTotalPrice(
          existingItem.unitPrice,
          modifiers,
          pizzaExtraCost,
          newQuantity,
        ),
        pizzaExtraCost,
      };

      set({ items: updatedItems });
    } else {
      const newItem: CartItem = {
        id: generateId(),
        productId: product.id,
        productName: product.name,
        quantity,
        unitPrice,
        totalPrice: calculateTotalPrice(
          unitPrice,
          modifiers,
          pizzaExtraCost,
          quantity,
        ),
        modifiers,
        variantId,
        variantName: variantToAdd?.name,
        preparationNotes,
        selectedPizzaCustomizations,
        pizzaExtraCost,
      };

      set({ items: [...items, newItem] });
    }
  },

  removeItem: (itemId: string) => {
    const { items } = get();
    set({ items: items.filter((item) => item.id !== itemId) });
    get().checkForUnsavedChanges();
  },

  updateItemQuantity: (itemId: string, quantity: number) => {
    const { items, removeItem } = get();

    if (quantity <= 0) {
      removeItem(itemId);
      return;
    }

    const updatedItems = items.map((item) => {
      if (item.id === itemId) {
        return {
          ...item,
          quantity,
          totalPrice: calculateTotalPrice(
            item.unitPrice,
            item.modifiers,
            item.pizzaExtraCost || 0,
            quantity,
          ),
        };
      }
      return item;
    });

    set({ items: updatedItems });
    get().checkForUnsavedChanges();
  },

  updateItem: (
    itemId: string,
    quantity: number,
    modifiers: CartItemModifier[],
    preparationNotes?: string,
    variantId?: string,
    variantName?: string,
    unitPrice?: number,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost: number = 0,
  ) => {
    const { items } = get();

    const updatedItems = items.map((item) => {
      if (item.id === itemId) {
        const finalUnitPrice =
          unitPrice !== undefined ? unitPrice : item.unitPrice;
        return {
          ...item,
          quantity,
          modifiers,
          preparationNotes:
            preparationNotes !== undefined
              ? preparationNotes
              : item.preparationNotes,
          variantId: variantId !== undefined ? variantId : item.variantId,
          variantName:
            variantName !== undefined ? variantName : item.variantName,
          unitPrice: finalUnitPrice,
          totalPrice: calculateTotalPrice(
            finalUnitPrice,
            modifiers,
            pizzaExtraCost,
            quantity,
          ),
          selectedPizzaCustomizations:
            selectedPizzaCustomizations !== undefined
              ? selectedPizzaCustomizations
              : item.selectedPizzaCustomizations,
          pizzaExtraCost,
        };
      }
      return item;
    });

    set({ items: updatedItems });
    get().checkForUnsavedChanges();
  },

  setItems: (items: CartItem[]) => {
    set({ items });
    get().checkForUnsavedChanges();
  },

  // --- Form Actions ---
  setOrderType: (type: OrderType) => {
    set((state) => {
      const newState: Partial<OrderState> = { orderType: type };

      if (type !== OrderTypeEnum.DINE_IN) {
        newState.selectedAreaId = null;
        newState.selectedTableId = null;
        newState.isTemporaryTable = false;
        newState.temporaryTableName = '';
      }

      if (type === OrderTypeEnum.DINE_IN) {
        newState.deliveryInfo = {};
      }

      if (type === OrderTypeEnum.TAKE_AWAY) {
        newState.deliveryInfo = {
          recipientName: state.deliveryInfo.recipientName || '',
          recipientPhone: state.deliveryInfo.recipientPhone || '',
        };
      }

      return newState;
    });
    get().checkForUnsavedChanges();
  },

  setSelectedAreaId: (id: string | null) => {
    set({ selectedAreaId: id });
    get().checkForUnsavedChanges();
  },

  setSelectedTableId: (id: string | null) => {
    set((_state) => {
      const newState: Partial<OrderState> = { selectedTableId: id };

      // Si se selecciona una mesa existente, desmarcar mesa temporal
      if (id) {
        newState.isTemporaryTable = false;
        newState.temporaryTableName = '';
      }

      return newState;
    });
    get().checkForUnsavedChanges();
  },

  setIsTemporaryTable: (isTemp: boolean) => {
    set((_state) => {
      const newState: Partial<OrderState> = { isTemporaryTable: isTemp };

      // Si se desmarca mesa temporal, limpiar el nombre
      if (!isTemp) {
        newState.temporaryTableName = '';
      }

      // Si se marca mesa temporal, limpiar seleccin de mesa existente
      if (isTemp) {
        newState.selectedTableId = null;
      }

      return newState;
    });
    get().checkForUnsavedChanges();
  },

  setTemporaryTableName: (name: string) => {
    set({ temporaryTableName: name });
    get().checkForUnsavedChanges();
  },

  setScheduledTime: (time: Date | null) => {
    set({ scheduledTime: time });
    get().checkForUnsavedChanges();
  },

  setDeliveryInfo: (info: DeliveryInfo) => {
    set({ deliveryInfo: info });
    get().checkForUnsavedChanges();
  },

  setOrderNotes: (notes: string) => {
    set({ orderNotes: notes });
    get().checkForUnsavedChanges();
  },

  setAdjustments: (adjustments: OrderAdjustment[]) => {
    set({ adjustments });
    get().checkForUnsavedChanges();
  },

  addAdjustment: (adjustment: OrderAdjustment) => {
    const { adjustments } = get();
    const newAdjustment = {
      ...adjustment,
      id:
        adjustment.id ||
        `new-adjustment-${Date.now()}-${Math.floor(Math.random() * 1000000)}`,
      isNew: true,
    };
    set({ adjustments: [...adjustments, newAdjustment] });
    get().checkForUnsavedChanges();
  },

  updateAdjustment: (
    id: string,
    updatedAdjustment: Partial<OrderAdjustment>,
  ) => {
    const { adjustments } = get();
    set({
      adjustments: adjustments.map((adj) =>
        adj.id === id ? { ...adj, ...updatedAdjustment } : adj,
      ),
    });
    get().checkForUnsavedChanges();
  },

  removeAdjustment: (id: string) => {
    const { adjustments } = get();
    set({ adjustments: adjustments.filter((adj) => adj.id !== id) });
    get().checkForUnsavedChanges();
  },

  // --- Prepayment Actions ---
  setPrepaymentId: (id: string | null) => {
    set({ prepaymentId: id });
  },

  setPrepaymentAmount: (amount: string) => {
    set({ prepaymentAmount: amount });
  },

  setPrepaymentMethod: (method: 'CASH' | 'CARD' | 'TRANSFER' | null) => {
    set({ prepaymentMethod: method });
  },

  // --- UI Actions ---
  showCart: () => {
    set({ isCartVisible: true });
  },

  hideCart: () => {
    set({ isCartVisible: false });
  },

  setIsLoading: (loading: boolean) => {
    set({ isLoading: loading });
  },

  setIsConfirming: (confirming: boolean) => {
    set({ isConfirming: confirming });
  },

  // --- Order Loading Actions ---
  loadOrderForEditing: (orderData: any, fullMenuData?: any) => {
    // Reset state first
    get().resetOrder();

    // Map order data to store state
    const mappedState: Partial<OrderState> = {
      id: orderData.id,
      isEditMode: true,
      orderType: orderData.orderType,
      selectedTableId: orderData.tableId ?? null,
      scheduledTime: orderData.scheduledAt
        ? new Date(orderData.scheduledAt)
        : null,
      deliveryInfo: orderData.deliveryInfo || {},
      orderNotes: orderData.notes ?? '',
    };

    // Handle adjustments
    if (orderData.adjustments && Array.isArray(orderData.adjustments)) {
      mappedState.adjustments = orderData.adjustments.map((adj: any) => ({
        id: adj.id,
        name: adj.name,
        description: adj.description || '',
        isPercentage: adj.isPercentage,
        value: adj.value,
        amount: adj.amount,
        isDeleted: false,
        isNew: false,
      }));
    }

    // Handle table data
    if (orderData.tableId && orderData.table) {
      const areaId = orderData.table.areaId || orderData.table.area?.id;
      if (areaId) {
        mappedState.selectedAreaId = areaId;
      }

      if (orderData.table.isTemporary) {
        mappedState.isTemporaryTable = true;
        mappedState.temporaryTableName = orderData.table.name || '';
      }
    }

    // Handle order items
    const groupedItemsMap = new Map<string, CartItem>();

    if (orderData.orderItems && Array.isArray(orderData.orderItems)) {
      orderData.orderItems.forEach((item: any) => {
        const modifiers: CartItemModifier[] = [];

        // Handle modifiers
        if (item.modifiers && Array.isArray(item.modifiers)) {
          item.modifiers.forEach((mod: any) => {
            modifiers.push({
              id: mod.productModifierId,
              modifierGroupId: mod.productModifier?.modifierGroupId || '',
              name: mod.productModifier?.name || 'Modificador',
              price: parseFloat(mod.price) || 0,
            });
          });
        } else if (
          item.productModifiers &&
          Array.isArray(item.productModifiers)
        ) {
          item.productModifiers.forEach((mod: any) => {
            const modifierInfo = fullMenuData
              ? findModifierById(mod.id, fullMenuData)
              : null;
            modifiers.push(
              modifierInfo || {
                id: mod.id,
                modifierGroupId: mod.modifierGroupId || '',
                name: mod.name || 'Modificador',
                price: parseFloat(mod.price) || 0,
              },
            );
          });
        }

        const unitPrice = parseFloat(item.basePrice || '0');
        const modifierIds = modifiers
          .map((m) => m.id)
          .sort()
          .join(',');
        const pizzaCustomizationIds = item.selectedPizzaCustomizations
          ? item.selectedPizzaCustomizations
              .map(
                (c: any) => `${c.pizzaCustomizationId}-${c.half}-${c.action}`,
              )
              .sort()
              .join(',')
          : '';
        const groupKey = `${item.productId}-${item.productVariantId || 'null'}-${modifierIds}-${pizzaCustomizationIds}-${item.preparationNotes || ''}-${item.preparationStatus || 'PENDING'}`;

        const existingItem = groupedItemsMap.get(groupKey);

        if (
          existingItem &&
          existingItem.preparationStatus === item.preparationStatus
        ) {
          existingItem.quantity += 1;
          existingItem.totalPrice = calculateTotalPrice(
            unitPrice,
            modifiers,
            0,
            existingItem.quantity,
          );
          existingItem.id = `${existingItem.id},${item.id}`;
        } else {
          const cartItem: CartItem = {
            id: item.id,
            productId: item.productId,
            productName: item.product?.name || 'Producto desconocido',
            quantity: 1,
            unitPrice,
            totalPrice: calculateTotalPrice(unitPrice, modifiers, 0, 1),
            modifiers,
            variantId: item.productVariantId || undefined,
            variantName: item.productVariant?.name || undefined,
            preparationNotes: item.preparationNotes || undefined,
            preparationStatus: item.preparationStatus || 'PENDING',
            selectedPizzaCustomizations:
              item.selectedPizzaCustomizations || undefined,
          };
          groupedItemsMap.set(groupKey, cartItem);
        }
      });
    }

    mappedState.items = Array.from(groupedItemsMap.values());
    mappedState.orderDataLoaded = true;

    // Save original state for comparison
    const originalState = {
      items: Array.from(groupedItemsMap.values()),
      orderType: orderData.orderType,
      tableId: orderData.tableId ?? null,
      isTemporaryTable: orderData.table?.isTemporary || false,
      temporaryTableName: orderData.table?.isTemporary
        ? orderData.table.name
        : '',
      deliveryInfo: orderData.deliveryInfo || {},
      notes: orderData.notes ?? '',
      scheduledAt: orderData.scheduledAt
        ? new Date(orderData.scheduledAt)
        : null,
      adjustments: mappedState.adjustments || [],
    };

    mappedState.originalState = originalState;
    mappedState.hasUnsavedChanges = false;

    set(mappedState);
  },

  // --- State Management Actions ---
  checkForUnsavedChanges: () => {
    const state = get();
    if (!state.isEditMode || !state.originalState) {
      set({ hasUnsavedChanges: false });
      return;
    }

    const hasChanges =
      JSON.stringify(state.items) !==
        JSON.stringify(state.originalState.items) ||
      state.orderType !== state.originalState.orderType ||
      state.selectedTableId !== state.originalState.tableId ||
      state.isTemporaryTable !== state.originalState.isTemporaryTable ||
      state.temporaryTableName !== state.originalState.temporaryTableName ||
      JSON.stringify(state.deliveryInfo) !==
        JSON.stringify(state.originalState.deliveryInfo) ||
      state.orderNotes !== state.originalState.notes ||
      (state.scheduledTime?.getTime() ?? null) !==
        (state.originalState.scheduledAt?.getTime() ?? null) ||
      JSON.stringify(state.adjustments) !==
        JSON.stringify(state.originalState.adjustments);

    set({ hasUnsavedChanges: hasChanges });
  },

  resetOrder: () => {
    set({
      id: null,
      isEditMode: false,
      items: [],
      orderType: OrderTypeEnum.DINE_IN,
      selectedAreaId: null,
      selectedTableId: null,
      isTemporaryTable: false,
      temporaryTableName: '',
      scheduledTime: null,
      deliveryInfo: {},
      orderNotes: '',
      adjustments: [],
      prepaymentId: null,
      prepaymentAmount: '',
      prepaymentMethod: null,
      isCartVisible: false,
      isLoading: false,
      isConfirming: false,
      hasUnsavedChanges: false,
      orderDataLoaded: false,
      originalState: null,
    });
  },

  resetToOriginalState: () => {
    const { originalState } = get();
    if (!originalState) return;

    set({
      items: [...originalState.items],
      orderType: originalState.orderType,
      selectedTableId: originalState.tableId,
      isTemporaryTable: originalState.isTemporaryTable,
      temporaryTableName: originalState.temporaryTableName,
      deliveryInfo: { ...originalState.deliveryInfo },
      orderNotes: originalState.notes,
      scheduledTime: originalState.scheduledAt,
      adjustments: [...originalState.adjustments],
      hasUnsavedChanges: false,
    });
  },

  // --- Order Confirmation ---
  validateForConfirmation: () => {
    const state = get();

    if (state.items.length === 0) {
      return {
        isValid: false,
        errorMessage: 'No hay productos en el carrito',
      };
    }

    if (!state.isEditMode && state.prepaymentId) {
      const subtotal = state.items.reduce(
        (sum, item) => sum + item.totalPrice,
        0,
      );
      const adjustmentTotal = state.adjustments.reduce((sum, adj) => {
        if (adj.isDeleted) return sum;
        return sum + (adj.amount || 0);
      }, 0);
      const total = subtotal - adjustmentTotal;

      if (parseFloat(state.prepaymentAmount || '0') > total) {
        return {
          isValid: false,
          errorMessage:
            'El prepago excede el total de la orden. Por favor edite el pago antes de continuar.',
        };
      }
    }

    // Validaciones especficas segn el tipo de orden
    switch (state.orderType) {
      case OrderTypeEnum.DINE_IN:
        if (!state.isTemporaryTable && !state.selectedTableId) {
          return {
            isValid: false,
            errorMessage: 'Por favor selecciona una mesa',
          };
        }
        if (state.isTemporaryTable && !state.temporaryTableName.trim()) {
          return {
            isValid: false,
            errorMessage: 'Por favor ingresa el nombre de la mesa temporal',
          };
        }
        if (state.isTemporaryTable && !state.selectedAreaId) {
          return {
            isValid: false,
            errorMessage: 'Por favor selecciona un rea para la mesa temporal',
          };
        }
        break;

      case OrderTypeEnum.DELIVERY:
        if (!state.deliveryInfo.recipientName?.trim()) {
          return {
            isValid: false,
            errorMessage: 'Por favor ingresa el nombre del cliente',
          };
        }
        if (!state.deliveryInfo.recipientPhone?.trim()) {
          return {
            isValid: false,
            errorMessage: 'Por favor ingresa el telfono del cliente',
          };
        }
        if (!state.deliveryInfo.fullAddress?.trim()) {
          return {
            isValid: false,
            errorMessage: 'Por favor ingresa la direccin de entrega',
          };
        }
        break;

      case OrderTypeEnum.TAKE_AWAY:
        if (!state.deliveryInfo.recipientName?.trim()) {
          return {
            isValid: false,
            errorMessage: 'Por favor ingresa el nombre del cliente',
          };
        }
        break;
    }

    return { isValid: true };
  },

  getValidationErrors: () => {
    const state = get();
    const errors: string[] = [];

    if (state.items.length === 0) {
      errors.push('El carrito est vaco');
    }

    // Validaciones especficas segn el tipo de orden
    switch (state.orderType) {
      case OrderTypeEnum.DINE_IN:
        if (!state.isTemporaryTable && !state.selectedTableId) {
          errors.push('Selecciona una mesa');
        }
        if (state.isTemporaryTable && !state.temporaryTableName.trim()) {
          errors.push('Ingresa el nombre de la mesa temporal');
        }
        if (state.isTemporaryTable && !state.selectedAreaId) {
          errors.push('Selecciona un rea para la mesa temporal');
        }
        break;

      case OrderTypeEnum.DELIVERY:
        if (!state.deliveryInfo.recipientName?.trim()) {
          errors.push('Ingresa el nombre del cliente');
        }
        if (!state.deliveryInfo.recipientPhone?.trim()) {
          errors.push('Ingresa el telfono del cliente');
        }
        if (!state.deliveryInfo.fullAddress?.trim()) {
          errors.push('Ingresa la direccin de entrega');
        }
        break;

      case OrderTypeEnum.TAKE_AWAY:
        if (!state.deliveryInfo.recipientName?.trim()) {
          errors.push('Ingresa el nombre del cliente');
        }
        break;
    }

    return errors;
  },

  prepareOrderForBackend: () => {
    const state = get();
    const validation = get().validateForConfirmation();

    if (!validation.isValid) {
      return null;
    }

    // Limpiar datos segn el tipo de orden
    const cleanedData = (() => {
      const base = {
        tableId: undefined as string | undefined,
        isTemporaryTable: undefined as boolean | undefined,
        temporaryTableName: undefined as string | undefined,
        temporaryTableAreaId: undefined as string | undefined,
        deliveryInfo: {} as DeliveryInfo,
      };

      switch (state.orderType) {
        case OrderTypeEnum.DINE_IN:
          if (state.isTemporaryTable) {
            return {
              ...base,
              isTemporaryTable: true,
              temporaryTableName: state.temporaryTableName,
              temporaryTableAreaId: state.selectedAreaId || undefined,
            };
          } else {
            return {
              ...base,
              tableId: state.selectedTableId || undefined,
            };
          }

        case OrderTypeEnum.DELIVERY:
          return {
            ...base,
            deliveryInfo: {
              recipientName: state.deliveryInfo.recipientName,
              recipientPhone: state.deliveryInfo.recipientPhone,
              fullAddress: state.deliveryInfo.fullAddress,
              deliveryInstructions: state.deliveryInfo.deliveryInstructions,
            },
          };

        case OrderTypeEnum.TAKE_AWAY:
          return {
            ...base,
            deliveryInfo: {
              recipientName: state.deliveryInfo.recipientName,
              recipientPhone: state.deliveryInfo.recipientPhone,
            },
          };

        default:
          return base;
      }
    })();

    const itemsForBackend: OrderItemDtoForBackend[] = [];

    state.items.forEach((item) => {
      if (state.isEditMode && item.id && !item.id.startsWith('new-')) {
        const existingIds = item.id
          .split(',')
          .filter((id) => id.trim() && !id.startsWith('new-'));
        const requiredQuantity = item.quantity;

        for (let i = 0; i < requiredQuantity; i++) {
          const isExistingItem = i < existingIds.length;

          itemsForBackend.push({
            id: isExistingItem ? existingIds[i] : undefined,
            productId: item.productId,
            productVariantId: item.variantId || null,
            quantity: 1,
            basePrice: Number(item.unitPrice),
            finalPrice: Number(item.totalPrice / item.quantity),
            preparationNotes: item.preparationNotes || null,
            productModifiers:
              item.modifiers && item.modifiers.length > 0
                ? item.modifiers.map((mod) => ({
                    modifierId: mod.id,
                  }))
                : undefined,
            selectedPizzaCustomizations:
              item.selectedPizzaCustomizations || undefined,
          });
        }
      } else {
        for (let i = 0; i < item.quantity; i++) {
          itemsForBackend.push({
            productId: item.productId,
            productVariantId: item.variantId || null,
            quantity: 1,
            basePrice: Number(item.unitPrice),
            finalPrice: Number(item.totalPrice / item.quantity),
            preparationNotes: item.preparationNotes || null,
            productModifiers:
              item.modifiers && item.modifiers.length > 0
                ? item.modifiers.map((mod) => ({
                    modifierId: mod.id,
                  }))
                : undefined,
            selectedPizzaCustomizations:
              item.selectedPizzaCustomizations || undefined,
          });
        }
      }
    });

    const subtotal = state.items.reduce(
      (sum, item) => sum + item.totalPrice,
      0,
    );
    const adjustmentTotal = state.adjustments.reduce((sum, adj) => {
      if (adj.isDeleted) return sum;
      return sum + (adj.amount || 0);
    }, 0);
    const total = Math.max(0, subtotal - adjustmentTotal);

    let formattedPhone: string | undefined = undefined;
    if (
      cleanedData.deliveryInfo.recipientPhone &&
      cleanedData.deliveryInfo.recipientPhone.trim() !== ''
    ) {
      formattedPhone = cleanedData.deliveryInfo.recipientPhone.trim();
    }

    const orderDetails: OrderDetailsForBackend = {
      orderType: state.orderType,
      subtotal,
      total,
      items: itemsForBackend,
      tableId: cleanedData.tableId,
      isTemporaryTable: cleanedData.isTemporaryTable,
      temporaryTableName: cleanedData.temporaryTableName,
      temporaryTableAreaId: cleanedData.temporaryTableAreaId,
      scheduledAt: state.scheduledTime ? state.scheduledTime : undefined,
      deliveryInfo: {
        ...cleanedData.deliveryInfo,
        recipientPhone: formattedPhone,
      },
      notes: state.orderNotes || undefined,
      adjustments: state.isEditMode
        ? state.adjustments
            .filter((adj) => !adj.isDeleted)
            .map((adj) => {
              return {
                orderId: state.id || undefined,
                name: adj.name,
                isPercentage: adj.isPercentage,
                value: adj.value,
                amount: adj.amount,
              };
            })
        : undefined,
    };

    if (!state.isEditMode && state.prepaymentId) {
      orderDetails.prepaymentId = state.prepaymentId;
    }

    return orderDetails;
  },

  confirmOrder: async (
    userId: string,
    onConfirmOrder: (details: OrderDetailsForBackend) => Promise<void>,
  ) => {
    const state = get();

    // Evitar mltiples confirmaciones
    if (state.isConfirming) {
      throw new Error('Ya se est procesando la orden');
    }

    // Validar primero
    const validation = get().validateForConfirmation();
    if (!validation.isValid) {
      throw new Error(
        validation.errorMessage ||
          'Por favor complete todos los campos requeridos',
      );
    }

    // Preparar datos para el backend
    const orderDetails = get().prepareOrderForBackend();
    if (!orderDetails) {
      throw new Error('Error al preparar la orden');
    }

    // Agregar el userId
    orderDetails.userId = userId;

    if (orderDetails.total <= 0) {
      throw new Error('El total de la orden debe ser mayor a 0');
    }

    if (
      orderDetails.payment &&
      orderDetails.payment.amount > orderDetails.total
    ) {
      throw new Error(
        'El monto del pago no puede exceder el total de la orden',
      );
    }

    set({ isConfirming: true });

    try {
      await onConfirmOrder(orderDetails);

      if (state.isEditMode) {
        const newOriginalState = {
          items: [...state.items],
          orderType: state.orderType,
          tableId: state.selectedTableId,
          isTemporaryTable: state.isTemporaryTable,
          temporaryTableName: state.temporaryTableName,
          deliveryInfo: { ...state.deliveryInfo },
          notes: state.orderNotes,
          scheduledAt: state.scheduledTime,
          adjustments: [...state.adjustments],
        };
        set({ originalState: newOriginalState, hasUnsavedChanges: false });
      } else {
        get().resetOrder();
      }
    } finally {
      set({ isConfirming: false });
    }
  },
}));

export const useOrderValidation = () =>
  useOrderStore((state) => ({
    validateForConfirmation: state.validateForConfirmation,
    getValidationErrors: state.getValidationErrors,
  }));

export const useOrderSubtotal = () =>
  useOrderStore((state) =>
    state.items.reduce((sum, item) => sum + item.totalPrice, 0),
  );

export const useOrderTotal = () => {
  const subtotal = useOrderSubtotal();
  const adjustments = useOrderStore((state) => state.adjustments);

  const adjustmentTotal = adjustments.reduce((sum, adj) => {
    if (adj.isDeleted) return sum;

    if (adj.isPercentage && adj.value) {
      // Para porcentajes, calcular basado en el subtotal
      return sum + (subtotal * adj.value) / 100;
    } else if (adj.amount) {
      // Para montos fijos
      return sum + adj.amount;
    }

    return sum;
  }, 0);

  return Math.max(0, subtotal - adjustmentTotal);
};

export const useOrderItemsCount = () =>
  useOrderStore((state) =>
    state.items.reduce((sum, item) => sum + item.quantity, 0),
  );

export const useIsOrderEmpty = () =>
  useOrderStore((state) => state.items.length === 0);

export const useOrderConfirmation = () =>
  useOrderStore((state) => ({
    confirmOrder: state.confirmOrder,
    isConfirming: state.isConfirming,
    prepareOrderForBackend: state.prepareOrderForBackend,
  }));

================
File: app/src/modules/orders/utils/formatters.ts
================
import { OrderTypeEnum, type OrderType } from '../schema/orders.schema';

/**
 * Informacin consolidada para estados de orden
 */
export const OrderStatusInfo = {
  getLabel: (status: string): string => {
    switch (status) {
      case 'PENDING':
        return 'Pendiente';
      case 'IN_PROGRESS':
        return 'En Progreso';
      case 'IN_PREPARATION':
        return 'En Preparacin';
      case 'READY':
        return 'Lista';
      case 'DELIVERED':
        return 'Entregada';
      case 'COMPLETED':
        return 'Completada';
      case 'CANCELLED':
        return 'Cancelada';
      default:
        return status;
    }
  },
  getColor: (status: string, theme: any): string => {
    switch (status) {
      case 'PENDING':
        return '#FFA000';
      case 'IN_PROGRESS':
        return theme.colors.primary;
      case 'IN_PREPARATION':
        return '#FF6B35';
      case 'READY':
        return '#4CAF50';
      case 'DELIVERED':
        return theme.colors.tertiary;
      case 'COMPLETED':
        return '#10B981';
      case 'CANCELLED':
        return theme.colors.error;
      default:
        return theme.colors.onSurfaceVariant;
    }
  },
};

/**
 * Informacin consolidada para estados de preparacin de items
 */
export const PreparationStatusInfo = {
  getLabel: (status: string | undefined): string => {
    switch (status) {
      case 'NEW':
        return 'Nuevo';
      case 'PENDING':
        return 'Pendiente';
      case 'IN_PROGRESS':
        return 'En Preparacin';
      case 'READY':
        return 'Listo';
      case 'DELIVERED':
        return 'Entregado';
      case 'CANCELLED':
        return 'Cancelado';
      default:
        return status || '';
    }
  },
  getColor: (status: string | undefined, theme: any): string => {
    switch (status) {
      case 'NEW':
        return '#2196F3';
      case 'PENDING':
        return theme.colors.error;
      case 'IN_PROGRESS':
        return '#FFA000';
      case 'READY':
        return '#4CAF50';
      case 'DELIVERED':
        return theme.colors.tertiary;
      case 'CANCELLED':
        return theme.colors.onSurfaceDisabled;
      default:
        return theme.colors.onSurfaceVariant;
    }
  },
};

/**
 * Formatea el tipo de orden a texto legible
 */
export const formatOrderType = (type: OrderType): string => {
  switch (type) {
    case OrderTypeEnum.DINE_IN:
      return 'Comer en Local';
    case OrderTypeEnum.TAKE_AWAY:
      return 'Para Llevar';
    case OrderTypeEnum.DELIVERY:
      return 'Delivery';
    default:
      return type;
  }
};

/**
 * Formatea el tipo de orden a texto corto
 */
export const formatOrderTypeShort = (type: OrderType): string => {
  switch (type) {
    case OrderTypeEnum.DINE_IN:
      return 'Local';
    case OrderTypeEnum.TAKE_AWAY:
      return 'Llevar';
    case OrderTypeEnum.DELIVERY:
      return 'Delivery';
    default:
      return type;
  }
};

/**
 * Obtiene el cono para el tipo de orden
 */
export const getOrderTypeIcon = (type: OrderType): string => {
  switch (type) {
    case OrderTypeEnum.DINE_IN:
      return 'silverware-fork-knife';
    case OrderTypeEnum.TAKE_AWAY:
      return 'bag-checked';
    case OrderTypeEnum.DELIVERY:
      return 'moped';
    default:
      return 'help-circle';
  }
};

/**
 * Formatea el mtodo de pago
 */
export const formatPaymentMethod = (method: string): string => {
  const methodMap: Record<string, string> = {
    CASH: 'Efectivo',
    CARD: 'Tarjeta',
    TRANSFER: 'Transferencia',
  };

  return methodMap[method] || method;
};

/**
 * Obtiene el cono para el mtodo de pago
 */
export const getPaymentMethodIcon = (method: string): string => {
  const iconMap: Record<string, string> = {
    CASH: 'cash',
    CARD: 'credit-card',
    TRANSFER: 'bank-transfer',
  };

  return iconMap[method] || 'help-circle';
};

/**
 * Obtiene el estado de pago basado en la informacin de la orden
 */
export const getPaymentStatus = (
  order: any,
): { status: 'paid' | 'partial' | 'unpaid'; label: string } => {
  const total = order.total || 0;
  const paidAmount = order.totalPaidAmount || 0;

  if (paidAmount >= total) {
    return { status: 'paid', label: 'Pagado' };
  } else if (paidAmount > 0) {
    return { status: 'partial', label: 'Pago Parcial' };
  } else {
    return { status: 'unpaid', label: 'Sin Pagar' };
  }
};

/**
 * Obtiene el color para el estado del pago
 */
export const getStatusColor = (
  status: 'paid' | 'partial' | 'unpaid',
  theme: any,
): string => {
  switch (status) {
    case 'paid':
      return '#4CAF50';
    case 'partial':
      return '#FF9800';
    case 'unpaid':
      return theme.colors.error;
    default:
      return theme.colors.onSurfaceVariant;
  }
};

================
File: app/src/modules/printers/screens/PrintersScreen.tsx
================
import React, { useState, useMemo, useCallback } from 'react';
import { View, StyleSheet, FlatList } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Portal, ActivityIndicator, IconButton, FAB } from 'react-native-paper';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { useResponsive } from '../../../app/hooks/useResponsive';
import PrinterDiscoveryModal from '../components/PrinterDiscoveryModal';
import PrinterFormModal from '../components/PrinterFormModal';
import PrinterListItem from '../components/PrinterListItem';
import PrinterDetailModal from '../components/PrinterDetailModal';
import {
  DiscoveredPrinter,
  ThermalPrinter,
  CreateThermalPrinterDto,
} from '../types/printer.types';
import { useListState } from '../../../app/hooks/useListState';
import {
  usePrintersQuery,
  useDeletePrinterMutation,
  usePingPrinterMutation,
  useTestPrintPrinter,
} from '../hooks/usePrintersQueries';
import { useCrudScreenLogic } from '../../../app/hooks/useCrudScreenLogic';
import { useDrawerStatus } from '@react-navigation/drawer';
import { useRefreshModuleOnFocus } from '../../../app/hooks/useRefreshOnFocus';

const PrintersScreen: React.FC = () => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';

  const [isDiscoveryModalVisible, setIsDiscoveryModalVisible] = useState(false);
  const [discoveredPrinterData, setDiscoveredPrinterData] =
    useState<Partial<CreateThermalPrinterDto> | null>(null);
  const [pingingPrinterId, setPingingPrinterId] = useState<string | null>(null);
  const [testPrintingPrinterId, setTestPrintingPrinterId] = useState<
    string | null
  >(null);
  const [fabOpen, setFabOpen] = useState(false);

  const queryParams = useMemo(
    () => ({
      isActive: undefined,
      page: 1,
      limit: 50,
    }),
    [],
  );

  const {
    data: printersResponse,
    isLoading: isLoadingList,
    isFetching: isFetchingList,
    refetch: refetchList,
    error: listError,
  } = usePrintersQuery(queryParams);

  const { mutateAsync: deletePrinter } = useDeletePrinterMutation();
  const pingPrinterMutation = usePingPrinterMutation();
  const testPrintMutation = useTestPrintPrinter();

  useRefreshModuleOnFocus('thermalPrinters');

  const {
    isFormModalVisible,
    isDetailModalVisible,
    editingItem,
    selectedItem,
    isDeleting,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
    deleteConfirmation,
  } = useCrudScreenLogic<ThermalPrinter>({
    entityName: 'Impresora',
    queryKey: ['thermalPrinters', queryParams],
    deleteMutationFn: deletePrinter,
  });
  const handlePingPrinter = useCallback(
    async (printerId: string) => {
      setPingingPrinterId(printerId);
      try {
        await pingPrinterMutation.mutateAsync(printerId);
      } catch (error) {
      } finally {
        setPingingPrinterId(null);
      }
    },
    [pingPrinterMutation],
  );

  const handleTestPrint = useCallback(
    async (printerId: string) => {
      setTestPrintingPrinterId(printerId);
      try {
        await testPrintMutation.mutateAsync(printerId);
      } catch (error) {
      } finally {
        setTestPrintingPrinterId(null);
      }
    },
    [testPrintMutation],
  );

  const handleOpenAddModal = () => {
    setDiscoveredPrinterData(null);
    handleOpenCreateModal();
  };

  const handleOpenDiscoveryModal = () => {
    setIsDiscoveryModalVisible(true);
  };

  const handleDismissDiscoveryModal = () => {
    setIsDiscoveryModalVisible(false);
  };

  const handlePrinterSelectedFromDiscovery = (printer: DiscoveredPrinter) => {
    setDiscoveredPrinterData({
      name: printer.name || `Impresora ${printer.ip}`,
      connectionType: 'NETWORK',
      ipAddress: printer.ip,
      port: printer.port,
      macAddress: printer.mac || undefined,
    });
    setIsDiscoveryModalVisible(false);
    handleOpenCreateModal();
  };

  const renderPrinter = useCallback(
    ({ item }: { item: ThermalPrinter }) => {
      const isPingingThis = pingingPrinterId === item.id;
      const canPing = item.connectionType === 'NETWORK';

      return (
        <PrinterListItem
          printer={item}
          onPress={() => handleOpenDetailModal(item)}
          renderActions={
            <View style={styles.itemActionsContainer}>
              {isPingingThis ? (
                <ActivityIndicator size={32} style={styles.pingIndicator} />
              ) : (
                <IconButton
                  icon="radar"
                  size={32}
                  onPress={() => handlePingPrinter(item.id)}
                  disabled={!canPing || pingPrinterMutation.isPending}
                  iconColor={
                    canPing
                      ? theme.colors.primary
                      : theme.colors.onSurfaceDisabled
                  }
                  style={styles.actionButton}
                />
              )}
            </View>
          }
        />
      );
    },
    [
      pingingPrinterId,
      pingPrinterMutation.isPending,
      handlePingPrinter,
      handleOpenDetailModal,
      theme.colors,
      styles,
    ],
  );

  const filteredData = useMemo(() => {
    if (!printersResponse?.data) return [];
    return printersResponse.data;
  }, [printersResponse?.data]);

  const { ListEmptyComponent } = useListState({
    isLoading: isLoadingList,
    isError: !!listError,
    data: printersResponse?.data,
    emptyConfig: {
      title: 'No hay impresoras',
      message:
        'No hay impresoras configuradas. Presiona el botn + para agregar una nueva o descubrir impresoras en la red.',
      icon: 'printer-outline',
    },
    errorConfig: {
      title: 'Error al cargar impresoras',
      message: 'No se pudieron cargar las impresoras. Verifica tu conexin.',
      icon: 'alert-circle-outline',
      onAction: refetchList,
      actionLabel: 'Reintentar',
    },
  });

  const renderEmptyList = () => {
    if (isLoadingList) {
      return (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
        </View>
      );
    }

    return ListEmptyComponent;
  };

  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      <FlatList
        data={filteredData}
        renderItem={renderPrinter}
        keyExtractor={(item) => item.id}
        onRefresh={refetchList}
        refreshing={isFetchingList && !isLoadingList}
        ListEmptyComponent={renderEmptyList()}
        contentContainerStyle={[
          styles.listPadding,
          filteredData.length === 0 && styles.emptyListContainer,
        ]}
      />

      <Portal>
        <PrinterDiscoveryModal
          visible={isDiscoveryModalVisible}
          onDismiss={handleDismissDiscoveryModal}
          onPrinterSelect={handlePrinterSelectedFromDiscovery}
        />
        <PrinterFormModal
          visible={isFormModalVisible}
          onDismiss={handleCloseModals}
          editingItem={editingItem}
          initialDataFromDiscovery={
            !editingItem ? (discoveredPrinterData ?? undefined) : undefined
          }
        />
        <PrinterDetailModal
          visible={isDetailModalVisible}
          onDismiss={handleCloseModals}
          printer={selectedItem}
          onEdit={() => selectedItem && handleOpenEditModal(selectedItem)}
          deleteConfirmation={deleteConfirmation}
          onTestPrint={() => selectedItem && handleTestPrint(selectedItem.id)}
          isDeleting={isDeleting}
          isTestPrinting={testPrintingPrinterId === selectedItem?.id}
        />
        <FAB.Group
          open={fabOpen}
          visible={
            !isFormModalVisible &&
            !isDetailModalVisible &&
            !isDiscoveryModalVisible &&
            !isDrawerOpen
          }
          icon={fabOpen ? 'close' : 'plus'}
          actions={[
            {
              icon: 'magnify-scan',
              label: 'Descubrir en Red',
              onPress: handleOpenDiscoveryModal,
              style: { backgroundColor: theme.colors.tertiaryContainer },
              color: theme.colors.onTertiaryContainer,
              labelTextColor: theme.colors.onTertiaryContainer,
              size: 'small',
            },
            {
              icon: 'plus',
              label: 'Aadir Manual',
              onPress: handleOpenAddModal,
              style: { backgroundColor: theme.colors.secondaryContainer },
              color: theme.colors.onSecondaryContainer,
              labelTextColor: theme.colors.onSecondaryContainer,
              size: 'small',
            },
          ]}
          onStateChange={({ open }) => setFabOpen(open)}
          onPress={() => {
            if (fabOpen) {
              setFabOpen(false);
            }
          }}
          fabStyle={{ backgroundColor: theme.colors.primary }}
          color={theme.colors.onPrimary}
        />
      </Portal>
    </SafeAreaView>
  );
};

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    listPadding: {
      paddingBottom: 80,
      paddingTop: responsive.spacing(theme.spacing.s),
    },
    emptyListContainer: {
      flex: 1,
      minHeight: responsive.isTablet ? 350 : 400,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.spacing(theme.spacing.xl),
    },
    itemActionsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'flex-end',
    },
    actionButton: {
      margin: 0,
      padding: 0,
      width: responsive.isTablet ? 44 : 52,
      height: responsive.isTablet ? 44 : 52,
      borderRadius: responsive.isTablet ? 22 : 26,
      backgroundColor: theme.colors.surfaceVariant,
      elevation: 2,
    },
    pingIndicator: {
      width: responsive.isTablet ? 44 : 52,
      height: responsive.isTablet ? 44 : 52,
      justifyContent: 'center',
      alignItems: 'center',
      borderRadius: responsive.isTablet ? 22 : 26,
      backgroundColor: theme.colors.primaryContainer,
      elevation: 2,
    },
    errorText: {
      color: theme.colors.error,
      textAlign: 'center',
      fontSize: responsive.fontSize(14),
    },
  });

export default PrintersScreen;

================
File: app/src/modules/shared/components/OrderHistoryModal.tsx
================
import React, { useCallback, useMemo, useState, useEffect } from 'react';
import {
  View,
  StyleSheet,
  FlatList,
  ActivityIndicator,
  TouchableOpacity,
  Platform,
} from 'react-native';
import {
  Modal,
  Text,
  Divider,
  Chip,
  Button,
  Avatar,
  Surface,
} from 'react-native-paper';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import { useAppTheme } from '@/app/styles/theme';
import { useQuery } from '@tanstack/react-query';
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import { MaterialCommunityIcons as Icon } from '@expo/vector-icons';

interface ChangeDetail {
  anterior: unknown;
  nuevo: unknown;
}

interface OrderDiff {
  summary?: string;
  order?: {
    fields?: Record<string, [unknown, unknown]>;
    deliveryInfo?: Record<string, [unknown, unknown]>;
  };
  items?: {
    added?: Array<{
      productName: string;
      variantName?: string;
      modifiers?: string[];
      customizations?: string[];
      notes?: string;
      price: number;
    }>;
    modified?: Array<{
      before: { productName: string; variantName?: string };
      after: { productName: string; variantName?: string };
    }>;
    removed?: Array<{
      productName: string;
      variantName?: string;
      price?: number;
    }>;
  };
}

interface BatchOperation {
  operation: string;
  itemDescription?: string;
  snapshot?: { itemDescription?: string };
  formattedChanges?: Record<string, ChangeDetail>;
}

interface HistoryItem {
  id: string | number;
  orderId: string;
  orderItemId?: string;
  operation: 'INSERT' | 'UPDATE' | 'DELETE' | 'BATCH';
  changedBy: string;
  changedAt: string;
  diff?: OrderDiff | null;
  snapshot?: {
    orderType?: string;
    tableId?: string;
    table?: { name?: string };
    notes?: string;
  };
  productId?: string;
  preparationStatus?: string;
  changedByUser?: {
    id?: string;
    firstName: string;
    lastName: string;
  };
  user?: {
    firstName: string;
    lastName: string;
  };
  itemDescription?: string;
  formattedChanges?: {
    'Cambios en productos'?: {
      'Productos modificados'?: Array<{ antes: string; despus: string }>;
      'Productos agregados'?: string[];
      'Productos eliminados'?: string[];
    };
    [key: string]: ChangeDetail | unknown;
  };
  batchOperations?: BatchOperation[];
  type: 'order' | 'item';
}

interface OrderHistoryModalProps {
  visible: boolean;
  onDismiss: () => void;
  orderId: string | null;
  orderNumber?: number;
}

const getOperationIcon = (
  operation: string,
  type: 'order' | 'item' = 'item',
) => {
  if (type === 'order') {
    return 'receipt';
  }
  switch (operation) {
    case 'INSERT':
      return 'plus-circle';
    case 'UPDATE':
      return 'pencil';
    case 'DELETE':
      return 'delete';
    case 'BATCH':
      return 'folder-multiple';
    default:
      return 'information';
  }
};

const getOperationLabel = (
  operation: string,
  type: 'order' | 'item' = 'item',
) => {
  if (type === 'order') {
    const orderOperationMap: Record<string, string> = {
      INSERT: 'Orden creada',
      UPDATE: 'Orden modificada',
      DELETE: 'Orden eliminada',
    };
    return orderOperationMap[operation] || operation;
  }

  const operationMap: Record<string, string> = {
    INSERT: 'Item agregado',
    UPDATE: 'Item modificado',
    DELETE: 'Item eliminado',
    BATCH: 'Cambios mltiples',
  };
  return operationMap[operation] || operation;
};

const getStatusColor = (
  status: string,
  theme: ReturnType<typeof useAppTheme>,
) => {
  switch (status) {
    case 'PENDING':
      return theme.colors.error;
    case 'IN_PROGRESS':
    case 'IN_PREPARATION':
      return theme.colors.warning;
    case 'READY':
    case 'DELIVERED':
    case 'COMPLETED':
      return theme.colors.success;
    case 'CANCELLED':
      return theme.colors.onSurfaceVariant;
    default:
      return theme.colors.onSurface;
  }
};

const formatFieldName = (field: string): string => {
  const fieldMap: Record<string, string> = {
    orderStatus: 'Estado de la orden',
    orderType: 'Tipo de orden',
    tableId: 'Mesa',
    table: 'Mesa',
    notes: 'Notas',
    deliveryInfo: 'Informacin de entrega',
    scheduledAt: 'Programado para',
    customerId: 'Cliente',
    isFromWhatsApp: 'Orden de WhatsApp',
    // Campos dentro de deliveryInfo
    recipientName: 'Destinatario',
    recipientPhone: 'Telfono',
    fullAddress: 'Direccin completa',
    deliveryInstructions: 'Instrucciones de entrega',
    street: 'Calle',
    number: 'Nmero',
    neighborhood: 'Colonia',
    city: 'Ciudad',
    state: 'Estado',
    zipCode: 'Cdigo postal',
  };
  return fieldMap[field] || field;
};

const formatValue = (field: string, value: unknown): string => {
  if (value === null || value === undefined) return 'Sin valor';

  if (field === 'orderStatus' || field === 'preparationStatus') {
    const statusMap: Record<string, string> = {
      PENDING: 'Pendiente',
      IN_PROGRESS: 'En Progreso',
      IN_PREPARATION: 'En Preparacin',
      READY: 'Lista',
      DELIVERED: 'Entregada',
      COMPLETED: 'Completada',
      CANCELLED: 'Cancelada',
    };
    return statusMap[String(value)] || String(value);
  }

  if (field === 'orderType') {
    const typeMap: Record<string, string> = {
      DINE_IN: 'Para Comer Aqu',
      TAKE_AWAY: 'Para Llevar',
      DELIVERY: 'Domicilio',
    };
    return typeMap[String(value)] || String(value);
  }

  if (field === 'table' || field === 'tableId') {
    if (typeof value === 'object' && value !== null && 'name' in value) {
      return (value as { name: string }).name || 'Sin mesa';
    }
    return String(value) || 'Sin mesa';
  }

  // Para datos de entrega
  if (field === 'recipientName') {
    return String(value) || 'Sin nombre';
  }

  if (field === 'recipientPhone') {
    return String(value) || 'Sin telfono';
  }

  if (field === 'fullAddress') {
    return String(value) || 'Sin direccin';
  }

  if (field === 'isFromWhatsApp') {
    return value ? 'S' : 'No';
  }

  if (field === 'customerId') {
    return String(value) || 'Sin cliente registrado';
  }

  if (field === 'scheduledAt') {
    return value
      ? format(new Date(value as string | number | Date), 'dd/MM/yyyy HH:mm', {
          locale: es,
        })
      : 'No programado';
  }

  return String(value);
};

const HistoryItemComponent: React.FC<{
  item: HistoryItem;
  theme: ReturnType<typeof useAppTheme>;
}> = ({ item, theme }) => {
  const [expanded, setExpanded] = useState(false);
  const styles = useMemo(() => createStyles(theme), [theme]);

  const renderChangeDetail = (change: unknown, fieldName?: string) => {
    if (
      change &&
      typeof change === 'object' &&
      change !== null &&
      'anterior' in change &&
      'nuevo' in change
    ) {
      const changeDetail = change as ChangeDetail;
      if (
        (fieldName === 'Descripcin del Item' || fieldName === 'Descripcin') &&
        (String(changeDetail.anterior).length > 30 ||
          String(changeDetail.nuevo).length > 30)
      ) {
        return (
          <View style={styles.verticalChangeContainer}>
            <View
              style={[
                styles.changeBlock,
                { backgroundColor: theme.colors.errorContainer },
              ]}
            >
              <Text
                variant="labelSmall"
                style={[
                  styles.changeBlockLabel,
                  { color: theme.colors.onErrorContainer },
                ]}
              >
                Antes:
              </Text>
              <Text
                variant="bodySmall"
                style={[
                  styles.changeBlockText,
                  { color: theme.colors.onErrorContainer },
                ]}
              >
                {String(changeDetail.anterior)}
              </Text>
            </View>
            <View
              style={[
                styles.changeBlockAfter,
                { backgroundColor: theme.colors.primaryContainer },
              ]}
            >
              <Text
                variant="labelSmall"
                style={[
                  styles.changeBlockLabel,
                  { color: theme.colors.onPrimaryContainer },
                ]}
              >
                Despus:
              </Text>
              <Text
                variant="bodySmall"
                style={[
                  styles.changeBlockText,
                  { color: theme.colors.onPrimaryContainer },
                ]}
              >
                {String(changeDetail.nuevo)}
              </Text>
            </View>
          </View>
        );
      }

      // Formato horizontal para cambios cortos
      return (
        <View style={styles.changeDetail}>
          <View
            style={[
              styles.horizontalChangeBefore,
              { backgroundColor: theme.colors.errorContainer },
            ]}
          >
            <Text
              variant="labelSmall"
              style={[
                styles.horizontalChangeText,
                { color: theme.colors.onErrorContainer },
              ]}
            >
              {String(changeDetail.anterior)}
            </Text>
          </View>
          <Icon
            name="arrow-right"
            size={16}
            color={theme.colors.onSurfaceVariant}
            style={styles.horizontalChangeArrow}
          />
          <View
            style={[
              styles.horizontalChangeAfter,
              { backgroundColor: theme.colors.primaryContainer },
            ]}
          >
            <Text
              variant="labelSmall"
              style={[
                styles.horizontalChangeText,
                { color: theme.colors.onPrimaryContainer },
              ]}
            >
              {String(changeDetail.nuevo)}
            </Text>
          </View>
        </View>
      );
    } else if (Array.isArray(change) && change.length === 2) {
      // Para el formato de array [antes, despus] - usado en cambios de orden
      const oldVal = formatValue(fieldName || '', (change as any[])[0]);
      const newVal = formatValue(fieldName || '', (change as any[])[1]);

      // Para campos largos o especiales, usar formato vertical
      if (
        fieldName &&
        ['notes', 'deliveryInfo', 'customerName', 'deliveryAddress'].includes(
          fieldName,
        )
      ) {
        return (
          <View style={styles.verticalChangeContainer}>
            <View
              style={[
                styles.changeBlock,
                { backgroundColor: theme.colors.errorContainer },
              ]}
            >
              <Text
                variant="labelSmall"
                style={[
                  styles.changeBlockLabel,
                  { color: theme.colors.onErrorContainer },
                ]}
              >
                Antes:
              </Text>
              <Text
                variant="bodySmall"
                style={[
                  styles.changeBlockText,
                  { color: theme.colors.onErrorContainer },
                ]}
              >
                {oldVal}
              </Text>
            </View>
            <View
              style={[
                styles.changeBlockAfter,
                { backgroundColor: theme.colors.primaryContainer },
              ]}
            >
              <Text
                variant="labelSmall"
                style={[
                  styles.changeBlockLabel,
                  { color: theme.colors.onPrimaryContainer },
                ]}
              >
                Despus:
              </Text>
              <Text
                variant="bodySmall"
                style={[
                  styles.changeBlockText,
                  { color: theme.colors.onPrimaryContainer },
                ]}
              >
                {newVal}
              </Text>
            </View>
          </View>
        );
      }

      // Formato horizontal para cambios cortos
      return (
        <View style={styles.changeDetail}>
          <View
            style={[
              styles.horizontalChangeBefore,
              { backgroundColor: theme.colors.errorContainer },
            ]}
          >
            <Text
              variant="labelSmall"
              style={[
                styles.horizontalChangeText,
                { color: theme.colors.onErrorContainer },
              ]}
            >
              {oldVal}
            </Text>
          </View>
          <Icon
            name="arrow-right"
            size={16}
            color={theme.colors.onSurfaceVariant}
            style={styles.horizontalChangeArrow}
          />
          <View
            style={[
              styles.horizontalChangeAfter,
              { backgroundColor: theme.colors.primaryContainer },
            ]}
          >
            <Text
              variant="labelSmall"
              style={[
                styles.horizontalChangeText,
                { color: theme.colors.onPrimaryContainer },
              ]}
            >
              {newVal}
            </Text>
          </View>
        </View>
      );
    }
    return null;
  };

  return (
    <Surface
      style={[
        styles.historyItem,
        { backgroundColor: theme.colors.surfaceVariant },
      ]}
      elevation={1}
    >
      <TouchableOpacity
        onPress={() => setExpanded(!expanded)}
        activeOpacity={0.7}
      >
        <View style={styles.historyHeader}>
          <View style={styles.historyHeaderContent}>
            <View style={styles.historyHeaderTop}>
              <Avatar.Icon
                size={24}
                icon={getOperationIcon(item.operation, item.type)}
                style={[
                  styles.operationAvatar,
                  {
                    backgroundColor:
                      item.type === 'order'
                        ? theme.colors.primary
                        : theme.colors.secondary,
                  },
                ]}
              />
              <Text
                variant="bodySmall"
                style={styles.userNameText}
                numberOfLines={1}
              >
                {item.changedByUser
                  ? `${item.changedByUser.firstName} ${item.changedByUser.lastName}`
                  : item.user
                    ? `${item.user.firstName} ${item.user.lastName}`
                    : 'Sistema'}
              </Text>
              <View
                style={[
                  styles.expandButton,
                  { backgroundColor: theme.colors.surfaceVariant },
                ]}
              >
                <Icon
                  name={expanded ? 'chevron-up' : 'chevron-down'}
                  size={20}
                  color={theme.colors.onSurfaceVariant}
                />
              </View>
            </View>

            <View style={styles.historyHeaderBottom}>
              <View
                style={[
                  styles.operationBadge,
                  {
                    backgroundColor:
                      (item.type === 'order'
                        ? theme.colors.primary
                        : theme.colors.secondary) + '15',
                  },
                ]}
              >
                <Icon
                  name={getOperationIcon(item.operation, item.type)}
                  size={10}
                  color={
                    item.type === 'order'
                      ? theme.colors.primary
                      : theme.colors.secondary
                  }
                  style={styles.operationBadgeIcon}
                />
                <Text
                  style={[
                    styles.operationBadgeText,
                    {
                      color:
                        item.type === 'order'
                          ? theme.colors.primary
                          : theme.colors.secondary,
                    },
                  ]}
                >
                  {getOperationLabel(item.operation, item.type)}
                </Text>
              </View>

              {item.preparationStatus && (
                <Chip
                  mode="flat"
                  textStyle={styles.statusChipText}
                  style={[
                    styles.statusChip,
                    {
                      backgroundColor:
                        getStatusColor(item.preparationStatus, theme) + '20',
                    },
                  ]}
                  compact
                >
                  {formatValue('preparationStatus', item.preparationStatus)}
                </Chip>
              )}

              <Text variant="labelSmall" style={styles.timestampText}>
                {format(new Date(item.changedAt), 'dd/MM/yyyy HH:mm', {
                  locale: es,
                })}
              </Text>
            </View>
          </View>
        </View>
      </TouchableOpacity>

      {expanded && (
        <View style={styles.expandedContent}>
          <Divider style={styles.dividerSpacing} />

          {item.type === 'order' && (
            <View style={styles.changesContainer}>
              {item.operation === 'INSERT' && (
                <>
                  {/* Si hay diff consolidado para INSERT, usarlo */}
                  {item.diff && (item.diff.order || item.diff.items) ? (
                    <>
                      {item.diff.summary && (
                        <Text
                          variant="bodySmall"
                          style={[
                            styles.summaryText,
                            { color: theme.colors.primary },
                          ]}
                        >
                          {String(item.diff.summary)}
                        </Text>
                      )}

                      {/* Informacin de la orden */}
                      {item.diff.order && (
                        <View
                          style={[
                            styles.orderDetailsContainer,
                            { backgroundColor: theme.colors.surface },
                          ]}
                        >
                          <Text
                            variant="labelSmall"
                            style={[
                              styles.orderDetailsTitle,
                              { color: theme.colors.primary },
                            ]}
                          >
                            Detalles de la orden:
                          </Text>

                          {item.diff.order.fields?.orderType && (
                            <Text
                              variant="bodySmall"
                              style={styles.orderDetailItem}
                            >
                              <Text style={styles.fieldLabel}>Tipo:</Text>{' '}
                              {formatValue(
                                'orderType',
                                item.diff.order.fields.orderType[1],
                              )}
                            </Text>
                          )}
                          {item.diff.order.fields?.tableId && (
                            <Text
                              variant="bodySmall"
                              style={styles.orderDetailItem}
                            >
                              <Text style={styles.fieldLabel}>Mesa:</Text>{' '}
                              {item.snapshot?.table?.name ||
                                `Mesa ${String(item.diff.order.fields.tableId[1])}`}
                            </Text>
                          )}
                          {item.diff.order.fields?.notes && (
                            <Text
                              variant="bodySmall"
                              style={styles.orderDetailItem}
                            >
                              <Text style={styles.fieldLabel}>Notas:</Text>{' '}
                              {String(item.diff.order.fields.notes[1])}
                            </Text>
                          )}

                          {/* Informacin de entrega */}
                          {item.diff.order.deliveryInfo && (
                            <>
                              {item.diff.order.deliveryInfo.recipientName && (
                                <Text
                                  variant="bodySmall"
                                  style={styles.deliveryInfoText}
                                >
                                  <Text style={styles.fieldLabel}>
                                    Cliente:
                                  </Text>{' '}
                                  {String(
                                    item.diff.order.deliveryInfo
                                      .recipientName[1],
                                  )}
                                </Text>
                              )}
                              {item.diff.order.deliveryInfo.recipientPhone && (
                                <Text
                                  variant="bodySmall"
                                  style={styles.deliveryInfoText}
                                >
                                  <Text style={styles.fieldLabel}>
                                    Telfono:
                                  </Text>{' '}
                                  {String(
                                    item.diff.order.deliveryInfo
                                      .recipientPhone[1],
                                  )}
                                </Text>
                              )}
                              {item.diff.order.deliveryInfo.fullAddress && (
                                <Text
                                  variant="bodySmall"
                                  style={styles.deliveryInfoText}
                                >
                                  <Text style={styles.fieldLabel}>
                                    Direccin:
                                  </Text>{' '}
                                  {String(
                                    item.diff.order.deliveryInfo.fullAddress[1],
                                  )}
                                </Text>
                              )}
                            </>
                          )}
                        </View>
                      )}

                      {/* Productos agregados */}
                      {item.diff.items?.added &&
                        item.diff.items.added.length > 0 && (
                          <>
                            <Text
                              variant="labelSmall"
                              style={[
                                styles.sectionTitle,
                                { color: theme.colors.primary },
                              ]}
                            >
                              Productos incluidos en la orden:
                            </Text>
                            {item.diff.items.added.map(
                              (addedItem, idx: number) => (
                                <View
                                  key={`added-${idx}`}
                                  style={[
                                    styles.productItemContainer,
                                    {
                                      borderLeftColor:
                                        theme.colors.primary + '50',
                                      backgroundColor: theme.colors.surface,
                                    },
                                  ]}
                                >
                                  <Text
                                    variant="bodySmall"
                                    style={styles.productName}
                                  >
                                    {addedItem.productName}
                                    {addedItem.variantName
                                      ? ` - ${addedItem.variantName}`
                                      : ''}
                                  </Text>
                                  {addedItem.modifiers &&
                                    addedItem.modifiers.length > 0 && (
                                      <Text
                                        variant="labelSmall"
                                        style={[
                                          styles.productDetail,
                                          {
                                            color:
                                              theme.colors.onSurfaceVariant,
                                          },
                                        ]}
                                      >
                                        Modificadores:{' '}
                                        {addedItem.modifiers.join(', ')}
                                      </Text>
                                    )}
                                  {addedItem.customizations &&
                                    addedItem.customizations.length > 0 && (
                                      <Text
                                        variant="labelSmall"
                                        style={[
                                          styles.productDetail,
                                          {
                                            color:
                                              theme.colors.onSurfaceVariant,
                                          },
                                        ]}
                                      >
                                        Personalizaciones:{' '}
                                        {addedItem.customizations.join(', ')}
                                      </Text>
                                    )}
                                  {addedItem.notes && (
                                    <Text
                                      variant="labelSmall"
                                      style={styles.productNotes}
                                    >
                                      Notas: {addedItem.notes}
                                    </Text>
                                  )}
                                  <Text
                                    variant="labelSmall"
                                    style={[
                                      styles.productPrice,
                                      { color: theme.colors.primary },
                                    ]}
                                  >
                                    Precio: ${addedItem.price}
                                  </Text>
                                </View>
                              ),
                            )}
                          </>
                        )}
                    </>
                  ) : (
                    // Fallback al formato anterior si no hay diff
                    <>
                      <Text
                        variant="bodySmall"
                        style={[
                          styles.fallbackTitle,
                          { color: theme.colors.primary },
                        ]}
                      >
                        Nueva orden creada
                      </Text>
                      {item.snapshot && (
                        <View
                          style={[
                            styles.snapshotContainer,
                            { backgroundColor: theme.colors.surface },
                          ]}
                        >
                          {item.snapshot.orderType && (
                            <Text
                              variant="bodySmall"
                              style={styles.orderDetailItem}
                            >
                              <Text style={styles.fieldLabel}>Tipo:</Text>{' '}
                              {formatValue(
                                'orderType',
                                item.snapshot.orderType,
                              )}
                            </Text>
                          )}
                          {item.snapshot.tableId && (
                            <Text
                              variant="bodySmall"
                              style={styles.orderDetailItem}
                            >
                              <Text style={styles.fieldLabel}>Mesa:</Text>{' '}
                              {item.snapshot.table?.name ||
                                'Mesa ' + item.snapshot.tableId}
                            </Text>
                          )}
                          {item.snapshot.notes && (
                            <Text variant="bodySmall">
                              <Text style={styles.fieldLabel}>Notas:</Text>{' '}
                              {item.snapshot.notes}
                            </Text>
                          )}
                        </View>
                      )}
                    </>
                  )}
                </>
              )}

              {item.operation === 'UPDATE' &&
                item.diff &&
                (() => {
                  const relevantChanges = Object.entries(item.diff)
                    .filter(([field]) => {
                      // Solo mostrar campos que rastreamos en el backend
                      const allowedFields = [
                        'orderStatus',
                        'orderType',
                        'notes',
                        'tableId',
                        'customerId',
                        'scheduledAt',
                        'deliveryInfo',
                        'isFromWhatsApp',
                      ];
                      return allowedFields.includes(field);
                    })
                    .flatMap(([field, change]) => {
                      // Si es deliveryInfo y es un objeto, expandir sus propiedades
                      if (
                        field === 'deliveryInfo' &&
                        change &&
                        typeof change === 'object' &&
                        !Array.isArray(change)
                      ) {
                        return Object.entries(change).map(
                          ([subField, subChange]: [string, unknown]) => ({
                            field: subField,
                            change: subChange,
                          }),
                        );
                      }
                      return [{ field, change }];
                    });

                  if (relevantChanges.length === 0) {
                    return (
                      <Text
                        variant="bodySmall"
                        style={[
                          styles.updateFallbackText,
                          { color: theme.colors.onSurfaceVariant },
                        ]}
                      >
                        Actualizacin de productos de la orden
                      </Text>
                    );
                  }

                  return (
                    <>
                      <Text
                        variant="bodySmall"
                        style={[
                          styles.orderChangesTitle,
                          { color: theme.colors.primary },
                        ]}
                      >
                        Cambios en la orden:
                      </Text>
                      {relevantChanges.map(({ field, change }) => (
                        <View key={field} style={styles.changeItemContainer}>
                          <Text
                            variant="labelSmall"
                            style={[
                              styles.fieldNameText,
                              { color: theme.colors.onSurfaceVariant },
                            ]}
                          >
                            {formatFieldName(field)}:
                          </Text>
                          {renderChangeDetail(change, field)}
                        </View>
                      ))}
                    </>
                  );
                })()}

              {item.operation === 'DELETE' && (
                <Text
                  variant="bodySmall"
                  style={[
                    styles.itemDeletedText,
                    { color: theme.colors.error },
                  ]}
                >
                  La orden fue eliminada
                </Text>
              )}
            </View>
          )}

          {item.diff &&
            (item.diff.order || item.diff.items || item.diff.summary) && (
              <View style={styles.changesContainer}>
                {/* Resumen de cambios */}
                {item.diff.summary && (
                  <Text
                    variant="bodySmall"
                    style={[
                      styles.summaryText,
                      { color: theme.colors.primary },
                    ]}
                  >
                    {String(item.diff.summary)}
                  </Text>
                )}

                {/* Cambios en la orden */}
                {item.diff.order?.fields && (
                  <>
                    <Text
                      variant="bodySmall"
                      style={[
                        styles.orderChangesTitle,
                        { color: theme.colors.primary },
                      ]}
                    >
                      Cambios en la orden:
                    </Text>
                    {Object.entries(item.diff.order.fields).map(
                      ([field, change]) => (
                        <View key={field} style={styles.changeItemContainer}>
                          <Text
                            variant="labelSmall"
                            style={[
                              styles.fieldNameText,
                              { color: theme.colors.onSurfaceVariant },
                            ]}
                          >
                            {formatFieldName(field)}:
                          </Text>
                          {renderChangeDetail(change, field)}
                        </View>
                      ),
                    )}
                  </>
                )}

                {/* Cambios en informacin de entrega */}
                {item.diff.order?.deliveryInfo && (
                  <>
                    <Text
                      variant="bodySmall"
                      style={[
                        styles.orderChangesTitle,
                        { color: theme.colors.primary },
                      ]}
                    >
                      Cambios en informacin de entrega:
                    </Text>
                    {Object.entries(item.diff.order.deliveryInfo).map(
                      ([field, change]) => (
                        <View key={field} style={styles.changeItemContainer}>
                          <Text
                            variant="labelSmall"
                            style={[
                              styles.fieldNameText,
                              { color: theme.colors.onSurfaceVariant },
                            ]}
                          >
                            {formatFieldName(field)}:
                          </Text>
                          {renderChangeDetail(change, field)}
                        </View>
                      ),
                    )}
                  </>
                )}

                {/* Usar formattedChanges si est disponible para mostrar cambios simplificados */}
                {item.formattedChanges &&
                  item.formattedChanges['Cambios en productos'] && (
                    <>
                      <Text
                        variant="bodySmall"
                        style={[
                          styles.orderChangesTitle,
                          { color: theme.colors.primary },
                        ]}
                      >
                        Cambios en productos:
                      </Text>

                      {/* Productos modificados - diseo mejorado */}
                      {item.formattedChanges['Cambios en productos'][
                        'Productos modificados'
                      ] && (
                        <View style={styles.modifiedProductsContainer}>
                          {(
                            item.formattedChanges['Cambios en productos'][
                              'Productos modificados'
                            ] as Array<{ antes: string; despus: string }>
                          ).map((modItem, idx: number) => (
                            <View
                              key={`mod-${idx}`}
                              style={[
                                styles.modifiedProductContainer,
                                {
                                  backgroundColor: theme.colors.surfaceVariant,
                                  borderRadius: theme.roundness * 2,
                                },
                              ]}
                            >
                              {/* Header del cambio */}
                              <View
                                style={[
                                  styles.modifiedProductHeader,
                                  {
                                    backgroundColor:
                                      theme.colors.warning + '20',
                                    borderBottomColor:
                                      theme.colors.warning + '30',
                                  },
                                ]}
                              >
                                <Icon
                                  name="pencil"
                                  size={16}
                                  color={theme.colors.warning}
                                  style={styles.modifiedProductIcon}
                                />
                                <Text
                                  variant="labelMedium"
                                  style={[
                                    styles.modifiedProductTitle,
                                    { color: theme.colors.warning },
                                  ]}
                                >
                                  Producto modificado
                                </Text>
                              </View>

                              {/* Contenido del cambio */}
                              <View style={styles.modifiedProductContent}>
                                <View
                                  style={[
                                    styles.modifiedProductComparison,
                                    {
                                      backgroundColor: theme.colors.surface,
                                      borderRadius: theme.roundness,
                                    },
                                  ]}
                                >
                                  {/* Antes */}
                                  <View style={styles.modifiedProductBefore}>
                                    <Text
                                      variant="labelSmall"
                                      style={[
                                        styles.modifiedProductLabel,
                                        { color: theme.colors.error },
                                      ]}
                                    >
                                      Antes
                                    </Text>
                                    <Text
                                      variant="bodySmall"
                                      style={[
                                        styles.modifiedProductOldValue,
                                        {
                                          color: theme.colors.onSurfaceVariant,
                                        },
                                      ]}
                                    >
                                      {modItem.antes}
                                    </Text>
                                  </View>

                                  {/* Flecha */}
                                  <View style={styles.modifiedProductArrow}>
                                    <Icon
                                      name="arrow-right-thick"
                                      size={24}
                                      color={theme.colors.primary}
                                    />
                                  </View>

                                  {/* Despus */}
                                  <View style={styles.modifiedProductAfter}>
                                    <Text
                                      variant="labelSmall"
                                      style={[
                                        styles.modifiedProductLabelAfter,
                                        { color: theme.colors.primary },
                                      ]}
                                    >
                                      Despus
                                    </Text>
                                    <Text
                                      variant="bodySmall"
                                      style={[
                                        styles.modifiedProductNewValue,
                                        { color: theme.colors.primary },
                                      ]}
                                    >
                                      {modItem.despus}
                                    </Text>
                                  </View>
                                </View>
                              </View>
                            </View>
                          ))}
                        </View>
                      )}

                      {/* Productos agregados - formato simplificado */}
                      {item.formattedChanges['Cambios en productos'][
                        'Productos agregados'
                      ] && (
                        <>
                          {(
                            item.formattedChanges['Cambios en productos'][
                              'Productos agregados'
                            ] as string[]
                          ).map((product: string, idx: number) => (
                            <View
                              key={`added-${idx}`}
                              style={[
                                styles.productChangeItem,
                                {
                                  borderLeftColor: theme.colors.success + '50',
                                },
                              ]}
                            >
                              <View style={styles.productChangeContent}>
                                <Icon
                                  name="plus-circle"
                                  size={14}
                                  color={theme.colors.success}
                                  style={styles.productChangeIcon}
                                />
                                <View style={styles.productChangeText}>
                                  <Text
                                    variant="labelSmall"
                                    style={[
                                      styles.productChangeLabel,
                                      { color: theme.colors.success },
                                    ]}
                                  >
                                    Producto agregado
                                  </Text>
                                  <Text
                                    variant="bodySmall"
                                    style={styles.productChangeValue}
                                  >
                                    {product}
                                  </Text>
                                </View>
                              </View>
                            </View>
                          ))}
                        </>
                      )}

                      {/* Productos eliminados - formato simplificado */}
                      {item.formattedChanges['Cambios en productos'][
                        'Productos eliminados'
                      ] && (
                        <>
                          {(
                            item.formattedChanges['Cambios en productos'][
                              'Productos eliminados'
                            ] as string[]
                          ).map((product: string, idx: number) => (
                            <View
                              key={`removed-${idx}`}
                              style={[
                                styles.productChangeItem,
                                { borderLeftColor: theme.colors.error + '50' },
                              ]}
                            >
                              <View style={styles.productChangeContent}>
                                <Icon
                                  name="delete"
                                  size={14}
                                  color={theme.colors.error}
                                  style={styles.productChangeIcon}
                                />
                                <View style={styles.productChangeText}>
                                  <Text
                                    variant="labelSmall"
                                    style={[
                                      styles.productChangeLabel,
                                      { color: theme.colors.error },
                                    ]}
                                  >
                                    Producto eliminado
                                  </Text>
                                  <Text
                                    variant="bodySmall"
                                    style={styles.productChangeValue}
                                  >
                                    {product}
                                  </Text>
                                </View>
                              </View>
                            </View>
                          ))}
                        </>
                      )}
                    </>
                  )}

                {/* Cambios en items - formato JSON crudo (fallback si no hay formattedChanges) */}
                {item.diff.items &&
                  !item.formattedChanges?.['Cambios en productos'] && (
                    <>
                      <Text
                        variant="bodySmall"
                        style={[
                          styles.orderChangesTitle,
                          { color: theme.colors.primary },
                        ]}
                      >
                        Cambios en productos:
                      </Text>

                      {/* Items agregados */}
                      {item.diff.items.added?.map((addedItem, idx: number) => (
                        <View
                          key={`added-${idx}`}
                          style={[
                            styles.productItemsContainer,
                            { borderLeftColor: theme.colors.success + '50' },
                          ]}
                        >
                          <View style={styles.productItemRowContent}>
                            <Icon
                              name="plus-circle"
                              size={14}
                              color={theme.colors.success}
                              style={styles.productItemIcon}
                            />
                            <View style={styles.productItemDetails}>
                              <Text
                                variant="labelSmall"
                                style={[
                                  styles.productItemLabel,
                                  { color: theme.colors.success },
                                ]}
                              >
                                Producto agregado
                              </Text>
                              <Text
                                variant="bodySmall"
                                style={styles.productItemName}
                              >
                                {addedItem.productName}
                                {addedItem.variantName
                                  ? ` - ${addedItem.variantName}`
                                  : ''}
                              </Text>
                              {addedItem.modifiers &&
                                addedItem.modifiers.length > 0 && (
                                  <Text
                                    variant="labelSmall"
                                    style={[
                                      styles.productItemModifiers,
                                      { color: theme.colors.onSurfaceVariant },
                                    ]}
                                  >
                                    Modificadores:{' '}
                                    {addedItem.modifiers.join(', ')}
                                  </Text>
                                )}
                              {addedItem.price && (
                                <Text
                                  variant="labelSmall"
                                  style={styles.productItemPrice}
                                >
                                  Precio: ${addedItem.price}
                                </Text>
                              )}
                            </View>
                          </View>
                        </View>
                      ))}

                      {/* Items modificados - Solo mostrar antes y despus */}
                      {item.diff.items.modified?.map((modItem, idx: number) => (
                        <View
                          key={`mod-${idx}`}
                          style={[
                            styles.productItemsContainer,
                            { borderLeftColor: theme.colors.warning + '50' },
                          ]}
                        >
                          <View style={styles.productItemRowContent}>
                            <Icon
                              name="pencil"
                              size={14}
                              color={theme.colors.warning}
                              style={styles.productItemIcon}
                            />
                            <View style={styles.productItemDetails}>
                              <Text
                                variant="labelSmall"
                                style={[
                                  styles.productItemLabel,
                                  { color: theme.colors.warning },
                                ]}
                              >
                                Producto modificado
                              </Text>
                              <View style={styles.productModifiedComparison}>
                                <View
                                  style={[
                                    styles.productModifiedBefore,
                                    {
                                      backgroundColor:
                                        theme.colors.errorContainer,
                                    },
                                  ]}
                                >
                                  <Text
                                    variant="bodySmall"
                                    style={[
                                      styles.productModifiedText,
                                      { color: theme.colors.onErrorContainer },
                                    ]}
                                  >
                                    {modItem.before.productName}
                                    {modItem.before.variantName
                                      ? ` - ${modItem.before.variantName}`
                                      : ''}
                                  </Text>
                                </View>
                                <Icon
                                  name="arrow-right"
                                  size={16}
                                  color={theme.colors.onSurfaceVariant}
                                  style={styles.productModifiedArrowIcon}
                                />
                                <View
                                  style={[
                                    styles.productModifiedAfter,
                                    {
                                      backgroundColor:
                                        theme.colors.primaryContainer,
                                    },
                                  ]}
                                >
                                  <Text
                                    variant="bodySmall"
                                    style={[
                                      styles.productModifiedText,
                                      {
                                        color: theme.colors.onPrimaryContainer,
                                      },
                                    ]}
                                  >
                                    {modItem.after.productName}
                                    {modItem.after.variantName
                                      ? ` - ${modItem.after.variantName}`
                                      : ''}
                                  </Text>
                                </View>
                              </View>
                            </View>
                          </View>
                        </View>
                      ))}

                      {/* Items eliminados */}
                      {item.diff.items.removed?.map(
                        (removedItem, idx: number) => (
                          <View
                            key={`removed-${idx}`}
                            style={[
                              styles.productItemsContainer,
                              { borderLeftColor: theme.colors.error + '50' },
                            ]}
                          >
                            <View style={styles.productItemRowContent}>
                              <Icon
                                name="delete"
                                size={14}
                                color={theme.colors.error}
                                style={styles.productItemIcon}
                              />
                              <View style={styles.productItemDetails}>
                                <Text
                                  variant="labelSmall"
                                  style={[
                                    styles.productItemLabel,
                                    { color: theme.colors.error },
                                  ]}
                                >
                                  Producto eliminado
                                </Text>
                                <Text
                                  variant="bodySmall"
                                  style={styles.productItemName}
                                >
                                  {removedItem.productName}
                                  {removedItem.variantName
                                    ? ` - ${removedItem.variantName}`
                                    : ''}
                                </Text>
                                {removedItem.price && (
                                  <Text
                                    variant="labelSmall"
                                    style={styles.productItemPrice}
                                  >
                                    Precio: ${removedItem.price}
                                  </Text>
                                )}
                              </View>
                            </View>
                          </View>
                        ),
                      )}
                    </>
                  )}
              </View>
            )}

          {item.type === 'item' && item.operation !== 'BATCH' && (
            <View style={styles.changesContainer}>
              {item.operation === 'INSERT' && (
                <Text
                  variant="bodySmall"
                  style={[
                    styles.orderChangesTitle,
                    { color: theme.colors.primary },
                  ]}
                >
                  Nuevo item agregado:
                </Text>
              )}
              {item.operation === 'UPDATE' && item.formattedChanges && (
                <>
                  <Text
                    variant="bodySmall"
                    style={[
                      styles.orderChangesTitle,
                      { color: theme.colors.primary },
                    ]}
                  >
                    Item modificado:
                  </Text>
                  {Object.entries(item.formattedChanges)
                    .filter(([fieldName]) => {
                      // Solo mostrar campos relevantes (no precios)
                      const allowedFields = [
                        'Descripcin del Item',
                        'Estado',
                        'Notas de preparacin',
                        'Producto',
                        'Variante',
                        'Modificadores',
                      ];
                      return allowedFields.includes(fieldName);
                    })
                    .map(([fieldName, change]) => (
                      <View key={fieldName} style={styles.changeFieldContainer}>
                        <Text
                          variant="labelSmall"
                          style={[
                            styles.changeFieldLabel,
                            { color: theme.colors.onSurfaceVariant },
                          ]}
                        >
                          {fieldName}:
                        </Text>
                        {renderChangeDetail(change, fieldName)}
                      </View>
                    ))}
                </>
              )}
              {item.operation === 'DELETE' && (
                <Text
                  variant="bodySmall"
                  style={[
                    styles.itemDeletedText,
                    { color: theme.colors.error },
                  ]}
                >
                  Item eliminado:
                </Text>
              )}
              {/* Mostrar la descripcin del item para INSERT y DELETE */}
              {(item.operation === 'INSERT' || item.operation === 'DELETE') &&
                item.itemDescription && (
                  <Text
                    variant="bodySmall"
                    style={[
                      styles.itemDescriptionContainer,
                      {
                        color: theme.colors.onSurface,
                        backgroundColor: theme.colors.surface,
                      },
                    ]}
                  >
                    {item.itemDescription}
                  </Text>
                )}
            </View>
          )}

          {item.operation === 'BATCH' && item.batchOperations && (
            <View style={styles.changesContainer}>
              <Text
                variant="bodySmall"
                style={[
                  styles.orderChangesTitle,
                  { color: theme.colors.primary },
                ]}
              >
                Cambios realizados en una sola edicin:
              </Text>
              {item.batchOperations.map((op: BatchOperation, idx: number) => (
                <View
                  key={idx}
                  style={[
                    styles.batchOperationContainer,
                    idx < item.batchOperations!.length - 1 &&
                      styles.batchOperationSpacing,
                    {
                      borderLeftColor: theme.colors.primary + '30',
                    },
                  ]}
                >
                  <View style={styles.batchOperationHeader}>
                    <Icon
                      name={getOperationIcon(op.operation)}
                      size={14}
                      color={theme.colors.primary}
                      style={styles.batchOperationIcon}
                    />
                    <View style={styles.batchOperationContent}>
                      <Text
                        variant="labelSmall"
                        style={[
                          styles.batchOperationLabel,
                          { color: theme.colors.primary },
                        ]}
                      >
                        {getOperationLabel(op.operation)}
                      </Text>

                      {/* Mostrar descripcin del item */}
                      {((op as BatchOperation).itemDescription || (op as BatchOperation).snapshot?.itemDescription) && (
                        <Text
                          variant="bodySmall"
                          style={[
                            styles.batchOperationDescription,
                            {
                              color: theme.colors.onSurface,
                              backgroundColor: theme.colors.surface,
                            },
                          ]}
                        >
                          {(op as BatchOperation).itemDescription || (op as BatchOperation).snapshot?.itemDescription}
                        </Text>
                      )}

                      {/* Para UPDATE, mostrar el cambio */}
                      {(op as BatchOperation).operation === 'UPDATE' && (op as BatchOperation).formattedChanges && (
                        <View style={styles.batchOperationChanges}>
                          {Object.entries((op as BatchOperation).formattedChanges!)
                            .filter(([fieldName]) => {
                              // Solo mostrar campos relevantes (no precios)
                              const allowedFields = [
                                'Descripcin del Item',
                                'Descripcin',
                                'Estado',
                                'Notas de preparacin',
                                'Producto',
                                'Variante',
                                'Modificadores',
                                'Estado de preparacin',
                              ];
                              return allowedFields.includes(fieldName);
                            })
                            .map(([fieldName, change]) => (
                              <View
                                key={fieldName}
                                style={styles.batchOperationFieldContainer}
                              >
                                <Text
                                  variant="labelSmall"
                                  style={[
                                    styles.batchOperationFieldLabel,
                                    { color: theme.colors.onSurfaceVariant },
                                  ]}
                                >
                                  {fieldName}:
                                </Text>
                                {renderChangeDetail(change, fieldName)}
                              </View>
                            ))}
                        </View>
                      )}
                    </View>
                  </View>
                </View>
              ))}
            </View>
          )}
        </View>
      )}
    </Surface>
  );
};

export const OrderHistoryModal: React.FC<OrderHistoryModalProps> = ({
  visible,
  onDismiss,
  orderId,
  orderNumber,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);

  const {
    data: historyData,
    isError,
    refetch,
    isLoading,
  } = useQuery({
    queryKey: ['combinedHistory', orderId],
    queryFn: async () => {
      if (!orderId) throw new Error('No order ID');

      // Obtener historial consolidado de la orden
      const orderHistoryResponse = await apiClient.get(
        API_PATHS.ORDERS_HISTORY.replace(':orderId', orderId),
        {
          params: {
            page: 1,
            limit: 100,
          },
        },
      );

      const orderHistory =
        orderHistoryResponse.status === 200 && orderHistoryResponse.data?.data
          ? orderHistoryResponse.data.data.map((item: unknown) => ({
              ...(item as Record<string, unknown>),
              type: 'order' as const,
            }))
          : [];

      // Ya no necesitamos consultar el historial de items por separado
      // Todo est consolidado en el historial de la orden

      // No es necesario agrupar ya que cada registro ya contiene cambios consolidados
      return orderHistory;
    },
    enabled: visible && !!orderId,
    staleTime: 30000,
  });

  useEffect(() => {
    if (visible && orderId) {
      refetch();
    }
  }, [visible, orderId, refetch]);

  const renderHistoryItem = useCallback(
    ({ item }: { item: HistoryItem }) => {
      return <HistoryItemComponent item={item} theme={theme} />;
    },
    [theme],
  );

  const renderEmpty = () => (
    <View style={styles.emptyContainer}>
      <Icon
        name="history"
        size={48}
        color={theme.colors.onSurfaceVariant}
        style={styles.emptyIcon}
      />
      <Text
        variant="bodyLarge"
        style={[
          styles.headerSubtitle,
          {
            color: theme.colors.onSurfaceVariant,
            marginTop: theme.spacing.m,
          },
        ]}
      >
        No hay historial disponible
      </Text>
    </View>
  );

  return (
    <Modal
      visible={visible}
      onDismiss={onDismiss}
      contentContainerStyle={styles.modalContainer}
      dismissable={true}
      dismissableBackButton={false}
    >
      <View style={styles.header}>
        <View style={styles.headerTitleContainer}>
          <Text
            variant="titleMedium"
            style={[styles.headerTitle, { color: theme.colors.onSurface }]}
            numberOfLines={1}
          >
            Historial de Orden #{orderNumber || ''}
          </Text>
          <Text
            variant="bodySmall"
            style={[
              styles.headerSubtitle,
              { color: theme.colors.onSurfaceVariant },
            ]}
          >
            {historyData?.length || 0} cambios registrados
          </Text>
        </View>
        <TouchableOpacity
          onPress={onDismiss}
          style={[
            styles.closeButton,
            { backgroundColor: theme.colors.errorContainer },
          ]}
          activeOpacity={0.8}
        >
          <Icon name="close" size={24} color={theme.colors.onErrorContainer} />
        </TouchableOpacity>
      </View>

      <Divider />

      <View style={styles.contentContainer}>
        {isError ? (
          <View style={styles.emptyContainer}>
            <Icon
              name="alert-circle"
              size={48}
              color={theme.colors.error}
              style={styles.errorIcon}
            />
            <Text
              variant="bodyLarge"
              style={[
                styles.errorText,
                {
                  color: theme.colors.error,
                  marginTop: theme.spacing.m,
                },
              ]}
            >
              Error al cargar el historial
            </Text>
            <Button
              onPress={() => refetch()}
              mode="text"
              style={styles.retryButton}
            >
              Reintentar
            </Button>
          </View>
        ) : isLoading ? (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
            <Text style={styles.loadingText}>Cargando historial...</Text>
          </View>
        ) : (
          <FlatList
            data={historyData || []}
            renderItem={renderHistoryItem}
            keyExtractor={(item) => item.id.toString()}
            contentContainerStyle={styles.listContent}
            ListEmptyComponent={renderEmpty}
            showsVerticalScrollIndicator={false}
          />
        )}
      </View>
    </Modal>
  );
};

const createStyles = (theme: ReturnType<typeof useAppTheme>) => {
  return StyleSheet.create({
    modalContainer: {
      backgroundColor: theme.colors.surface,
      margin: 20,
      marginVertical: Platform.OS === 'ios' ? 60 : 40,
      borderRadius: theme.roundness * 3,
      height: '80%',
      maxHeight: 600,
      width: '90%',
      maxWidth: 500,
      alignSelf: 'center',
      elevation: 24,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 12 },
      shadowOpacity: 0.58,
      shadowRadius: 16.0,
      overflow: 'hidden',
    },
    header: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingHorizontal: theme.spacing.l,
      paddingVertical: theme.spacing.m,
      backgroundColor: theme.colors.elevation.level2,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
      minHeight: 64,
    },
    scrollView: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    listContent: {
      padding: theme.spacing.m,
      paddingBottom: theme.spacing.xl * 2, // Ms espacio al final para evitar superposicin
    },
    loadingContainer: {
      flex: 1,
      padding: theme.spacing.xl,
      alignItems: 'center',
      justifyContent: 'center',
    },
    loadingText: {
      marginTop: theme.spacing.m,
      color: theme.colors.onSurfaceVariant,
    },
    historyItem: {
      padding: theme.spacing.s,
      marginBottom: theme.spacing.s,
      marginHorizontal: theme.spacing.xs,
      borderRadius: theme.roundness * 2,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 1 },
      shadowOpacity: 0.05,
      shadowRadius: 2,
      elevation: 2,
    },
    historyHeader: {
      // Cambio a estructura vertical para evitar encimamiento
    },
    userInfo: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
      minWidth: 0,
    },
    userDetails: {
      marginLeft: theme.spacing.s,
      flex: 1,
      minWidth: 0,
    },
    expandedContent: {
      marginTop: theme.spacing.m,
      backgroundColor: theme.colors.background,
      marginHorizontal: -theme.spacing.s,
      padding: theme.spacing.m,
      borderBottomLeftRadius: theme.roundness,
      borderBottomRightRadius: theme.roundness,
    },
    changesContainer: {
      paddingTop: theme.spacing.xs,
    },
    changeDetail: {
      flexDirection: 'row',
      alignItems: 'center',
      flexWrap: 'wrap',
      marginBottom: 4,
    },
    emptyContainer: {
      flex: 1,
      padding: theme.spacing.xl,
      alignItems: 'center',
      justifyContent: 'center',
    },
    modifiedProductContainer: {
      marginBottom: 12,
      padding: theme.spacing.s,
    },
    modifiedProductHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingVertical: theme.spacing.xs,
      paddingHorizontal: theme.spacing.s,
      borderBottomWidth: 1,
    },
    modifiedProductIcon: {
      marginRight: theme.spacing.xs,
    },
    modifiedProductTitle: {
      fontWeight: '600',
    },
    modifiedProductContent: {
      padding: theme.spacing.s,
    },
    modifiedProductComparison: {
      padding: theme.spacing.s,
    },
    modifiedProductBefore: {
      marginBottom: theme.spacing.xs,
    },
    modifiedProductArrow: {
      alignItems: 'center',
      marginVertical: theme.spacing.xs,
    },
    modifiedProductAfter: {
      marginTop: theme.spacing.xs,
    },
    modifiedProductLabel: {
      fontSize: 12,
      fontWeight: '600',
      marginBottom: 2,
    },
    modifiedProductOldValue: {
      fontSize: 13,
    },
    modifiedProductLabelAfter: {
      fontSize: 12,
      fontWeight: '600',
      marginBottom: 2,
    },
    modifiedProductNewValue: {
      fontSize: 13,
      fontWeight: '600',
    },
    productChangeItem: {
      flexDirection: 'row',
      alignItems: 'flex-start',
      marginBottom: theme.spacing.xs,
      paddingLeft: theme.spacing.s,
      borderLeftWidth: 3,
    },
    productChangeContent: {
      flexDirection: 'row',
      alignItems: 'flex-start',
      flex: 1,
    },
    productChangeIcon: {
      marginRight: theme.spacing.xs,
      marginTop: 2,
    },
    productChangeText: {
      flex: 1,
    },
    productChangeLabel: {
      fontSize: 12,
      fontWeight: '600',
      marginBottom: 2,
    },
    productChangeValue: {
      fontSize: 13,
    },
    // Nuevos estilos para reemplazar inline styles
    dividerSpacing: {
      marginBottom: 8,
    },
    deliveryInfoText: {
      marginBottom: 4,
    },
    updateFallbackText: {
      color: theme.colors.onSurfaceVariant,
    },
    modifiedProductsContainer: {
      marginTop: 8,
    },
    productItemsContainer: {
      marginBottom: 8,
      paddingLeft: 8,
      borderLeftWidth: 2,
    },
    productItemRowContent: {
      flexDirection: 'row',
      alignItems: 'flex-start',
    },
    productItemIcon: {
      marginRight: 6,
      marginTop: 2,
    },
    productItemDetails: {
      flex: 1,
    },
    productItemLabel: {
      fontWeight: '600',
    },
    productItemName: {
      marginTop: 2,
    },
    productItemModifiers: {
      marginTop: 2,
    },
    productItemPrice: {
      marginTop: 2,
      fontWeight: '600',
    },
    productModifiedComparison: {
      flexDirection: 'row',
      alignItems: 'center',
      flexWrap: 'wrap',
      marginTop: 4,
    },
    productModifiedBefore: {
      paddingHorizontal: 8,
      paddingVertical: 4,
      borderRadius: 4,
      marginRight: 6,
      marginTop: 4,
    },
    productModifiedText: {
      // Color ser aplicado desde el componente
    },
    productModifiedArrowIcon: {
      marginHorizontal: 4,
      marginTop: 4,
    },
    productModifiedAfter: {
      paddingHorizontal: 8,
      paddingVertical: 4,
      borderRadius: 4,
      marginTop: 4,
    },
    changeFieldContainer: {
      marginBottom: 8,
    },
    changeFieldLabel: {
      fontWeight: '600',
      marginBottom: 4,
    },
    itemDeletedText: {
      marginBottom: 8,
    },
    itemDescriptionContainer: {
      padding: 8,
      borderRadius: 6,
    },
    batchOperationContainer: {
      paddingLeft: 8,
      borderLeftWidth: 2,
      marginLeft: 4,
    },
    batchOperationSpacing: {
      marginBottom: 12,
    },
    batchOperationHeader: {
      flexDirection: 'row',
      alignItems: 'flex-start',
      marginBottom: 4,
    },
    batchOperationIcon: {
      marginRight: 6,
      marginTop: 2,
    },
    batchOperationContent: {
      flex: 1,
    },
    batchOperationLabel: {
      fontWeight: '500',
      marginBottom: 4,
    },
    batchOperationDescription: {
      padding: 6,
      borderRadius: 4,
    },
    batchOperationChanges: {
      marginTop: 4,
    },
    batchOperationFieldContainer: {
      marginBottom: 4,
    },
    batchOperationFieldLabel: {
      fontWeight: '500',
      fontSize: 11,
    },
    headerTitleContainer: {
      flex: 1,
    },
    headerTitle: {
      fontSize: 18,
      fontWeight: '600',
    },
    headerSubtitle: {
      marginTop: 2,
    },
    closeButton: {
      width: 44,
      height: 44,
      borderRadius: 22,
      alignItems: 'center',
      justifyContent: 'center',
      elevation: 2,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.1,
      shadowRadius: 4,
    },
    contentContainer: {
      flex: 1,
    },
    errorIcon: {
      opacity: 0.7,
    },
    errorText: {
      textAlign: 'center',
    },
    retryButton: {
      marginTop: 16,
    },
    emptyIcon: {
      opacity: 0.5,
    },
    // Estilos adicionales necesarios
    verticalChangeContainer: {
      marginVertical: theme.spacing.xs,
    },
    changeBlock: {
      padding: theme.spacing.s,
      borderRadius: theme.roundness,
      marginBottom: theme.spacing.xs,
    },
    changeBlockAfter: {
      padding: theme.spacing.s,
      borderRadius: theme.roundness,
    },
    changeBlockLabel: {
      fontSize: 11,
      fontWeight: '600',
      marginBottom: 2,
    },
    changeBlockText: {
      fontSize: 12,
    },
    horizontalChangeBefore: {
      paddingHorizontal: theme.spacing.xs,
      paddingVertical: 2,
      borderRadius: theme.roundness / 2,
      marginRight: theme.spacing.xs,
    },
    horizontalChangeAfter: {
      paddingHorizontal: theme.spacing.xs,
      paddingVertical: 2,
      borderRadius: theme.roundness / 2,
    },
    horizontalChangeText: {
      fontSize: 11,
    },
    horizontalChangeArrow: {
      marginHorizontal: theme.spacing.xs,
    },
    historyHeaderContent: {
      flex: 1,
    },
    historyHeaderTop: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: theme.spacing.xs,
    },
    historyHeaderBottom: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      flexWrap: 'wrap',
    },
    operationAvatar: {
      marginRight: theme.spacing.s,
    },
    userNameText: {
      flex: 1,
      marginRight: theme.spacing.s,
    },
    expandButton: {
      borderRadius: theme.roundness,
      padding: theme.spacing.xs,
    },
    operationBadge: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingHorizontal: theme.spacing.s,
      paddingVertical: theme.spacing.xs,
      borderRadius: theme.roundness,
      marginRight: theme.spacing.s,
    },
    operationBadgeIcon: {
      marginRight: theme.spacing.xs,
    },
    operationBadgeText: {
      fontSize: 10,
      fontWeight: '600',
    },
    statusChipText: {
      fontSize: 10,
    },
    statusChip: {
      height: 24,
      marginRight: theme.spacing.s,
    },
    timestampText: {
      fontSize: 10,
      opacity: 0.7,
    },
    summaryText: {
      marginBottom: theme.spacing.s,
      fontWeight: '500',
    },
    orderDetailsContainer: {
      padding: theme.spacing.s,
      borderRadius: theme.roundness,
      marginBottom: theme.spacing.s,
    },
    orderDetailsTitle: {
      fontWeight: '600',
      marginBottom: theme.spacing.xs,
    },
    orderDetailItem: {
      marginBottom: theme.spacing.xs,
    },
    fieldLabel: {
      fontWeight: '600',
    },
    sectionTitle: {
      fontWeight: '600',
      marginBottom: theme.spacing.s,
      marginTop: theme.spacing.s,
    },
    productItemContainer: {
      padding: theme.spacing.s,
      borderLeftWidth: 3,
      marginBottom: theme.spacing.s,
      borderRadius: theme.roundness,
    },
    productName: {
      fontWeight: '500',
      marginBottom: theme.spacing.xs,
    },
    productDetail: {
      fontSize: 11,
      marginBottom: theme.spacing.xs,
    },
    productNotes: {
      fontSize: 11,
      fontStyle: 'italic',
      marginBottom: theme.spacing.xs,
    },
    productPrice: {
      fontSize: 11,
      fontWeight: '600',
    },
    fallbackTitle: {
      fontWeight: '600',
      marginBottom: theme.spacing.s,
    },
    snapshotContainer: {
      padding: theme.spacing.s,
      borderRadius: theme.roundness,
    },
    orderChangesTitle: {
      fontWeight: '600',
      marginBottom: theme.spacing.s,
    },
    changeItemContainer: {
      marginBottom: theme.spacing.s,
    },
    fieldNameText: {
      fontWeight: '600',
      marginBottom: theme.spacing.xs,
    },
  });
};

export default OrderHistoryModal;

================
File: app/src/modules/shared/components/PrintTicketModal.tsx
================
import React, { useState, useEffect } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  ActivityIndicator,
  TouchableOpacity,
} from 'react-native';
import {
  Modal,
  Portal,
  Text,
  RadioButton,
  Button,
  Surface,
  IconButton,
  Divider,
} from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { usePrintersQuery } from '@/modules/printers/hooks/usePrintersQueries';

interface OrderBasicInfo {
  shiftOrderNumber: number;
  orderType: 'TAKE_AWAY' | 'DELIVERY' | 'DINE_IN';
}

interface PrintTicketModalProps {
  visible: boolean;
  onDismiss: () => void;
  order: OrderBasicInfo | null;
  onPrint: (
    printerId: string,
    ticketType: 'GENERAL' | 'BILLING',
  ) => Promise<void>;
}

export const PrintTicketModal: React.FC<PrintTicketModalProps> = ({
  visible,
  onDismiss,
  order,
  onPrint,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);
  const { data: printersResponse, isLoading: isLoadingPrinters } =
    usePrintersQuery({ page: 1, limit: 100 });
  const [selectedTicketType, setSelectedTicketType] = useState<
    'GENERAL' | 'BILLING'
  >('GENERAL');
  const [selectedPrinterId, setSelectedPrinterId] = useState<string>('');
  const [isPrinting, setIsPrinting] = useState(false);

  const printers = printersResponse?.data || [];
  const activePrinters = printers.filter(
    (printer: { isActive: boolean }) => printer.isActive,
  );

  useEffect(() => {
    if (activePrinters.length > 0 && !selectedPrinterId) {
      setSelectedPrinterId((activePrinters[0] as { id: string }).id);
    }
  }, [activePrinters, selectedPrinterId]);

  useEffect(() => {
    if (order) {
      if (order.orderType === 'DINE_IN') {
        setSelectedTicketType('BILLING');
      } else {
        setSelectedTicketType('GENERAL');
      }
    }
  }, [order]);

  const handlePrint = async () => {
    if (!selectedPrinterId || !order) return;

    setIsPrinting(true);
    try {
      await onPrint(selectedPrinterId, selectedTicketType);
      onDismiss();
    } catch (error) {
    } finally {
      setIsPrinting(false);
    }
  };

  if (!order) return null;

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={[
          styles.modalContent,
          { backgroundColor: theme.colors.background },
        ]}
      >
        <View style={styles.header}>
          <Text style={[styles.title, { color: theme.colors.onSurface }]}>
            Imprimir Ticket - Orden #{order.shiftOrderNumber}
          </Text>
          <IconButton
            icon="close"
            size={24}
            onPress={onDismiss}
            style={styles.closeButton}
          />
        </View>

        <Divider />

        <ScrollView style={styles.content}>
          <View style={styles.section}>
            <Text
              style={[styles.sectionTitle, { color: theme.colors.primary }]}
            >
              Tipo de Ticket
            </Text>
            <RadioButton.Group
              onValueChange={(value) =>
                setSelectedTicketType(value as 'GENERAL' | 'BILLING')
              }
              value={selectedTicketType}
            >
              <TouchableOpacity
                activeOpacity={0.7}
                onPress={() => setSelectedTicketType('GENERAL')}
              >
                <Surface
                  style={[
                    styles.radioItem,
                    { backgroundColor: theme.colors.surface },
                    selectedTicketType === 'GENERAL'
                      ? styles.selectedGeneralItem
                      : styles.unselectedGeneralItem,
                  ]}
                >
                  <View style={styles.radioContent}>
                    <RadioButton value="GENERAL" color={theme.colors.primary} />
                    <View style={styles.radioTextContainer}>
                      <Text
                        style={[
                          styles.radioLabel,
                          { color: theme.colors.onSurface },
                        ]}
                      >
                         Ticket General
                      </Text>
                      <Text
                        style={[
                          styles.radioDescription,
                          { color: theme.colors.onSurfaceVariant },
                        ]}
                      >
                        Para cocina y delivery (letras grandes)
                      </Text>
                    </View>
                  </View>
                </Surface>
              </TouchableOpacity>
              <TouchableOpacity
                activeOpacity={0.7}
                onPress={() => setSelectedTicketType('BILLING')}
              >
                <Surface
                  style={[
                    styles.radioItem,
                    { backgroundColor: theme.colors.surface },
                    selectedTicketType === 'BILLING'
                      ? styles.selectedBillingItem
                      : styles.unselectedBillingItem,
                  ]}
                >
                  <View style={styles.radioContent}>
                    <RadioButton value="BILLING" color={theme.colors.primary} />
                    <View style={styles.radioTextContainer}>
                      <Text
                        style={[
                          styles.radioLabel,
                          { color: theme.colors.onSurface },
                        ]}
                      >
                         Ticket de Cuenta
                      </Text>
                      <Text
                        style={[
                          styles.radioDescription,
                          { color: theme.colors.onSurfaceVariant },
                        ]}
                      >
                        Para cobro al cliente (formato cuenta)
                      </Text>
                    </View>
                  </View>
                </Surface>
              </TouchableOpacity>
            </RadioButton.Group>
          </View>

          <View style={styles.section}>
            <Text
              style={[styles.sectionTitle, { color: theme.colors.primary }]}
            >
              Seleccionar Impresora
            </Text>
            {isLoadingPrinters ? (
              <ActivityIndicator size="small" color={theme.colors.primary} />
            ) : activePrinters.length === 0 ? (
              <Text
                style={[styles.noPrintersText, { color: theme.colors.error }]}
              >
                No hay impresoras activas disponibles
              </Text>
            ) : (
              <RadioButton.Group
                onValueChange={(value) => setSelectedPrinterId(value)}
                value={selectedPrinterId}
              >
                {activePrinters.map((printer: any) => (
                  <TouchableOpacity
                    key={printer.id}
                    activeOpacity={0.7}
                    onPress={() => setSelectedPrinterId(printer.id)}
                  >
                    <Surface
                      style={[
                        styles.radioItem,
                        { backgroundColor: theme.colors.surface },
                        selectedPrinterId === printer.id
                          ? styles.selectedPrinterItem
                          : styles.unselectedPrinterItem,
                      ]}
                    >
                      <View style={styles.radioContent}>
                        <RadioButton
                          value={printer.id}
                          color={theme.colors.primary}
                        />
                        <View style={styles.radioTextContainer}>
                          <Text
                            style={[
                              styles.radioLabel,
                              { color: theme.colors.onSurface },
                            ]}
                          >
                             {printer.name}
                          </Text>
                          <Text
                            style={[
                              styles.radioDescription,
                              { color: theme.colors.onSurfaceVariant },
                            ]}
                          >
                            {printer.ipAddress || 'Sin IP'} - Puerto{' '}
                            {printer.port || 'N/A'}
                          </Text>
                        </View>
                      </View>
                    </Surface>
                  </TouchableOpacity>
                ))}
              </RadioButton.Group>
            )}
          </View>
        </ScrollView>

        <Divider />

        <View style={styles.footer}>
          <Button
            mode="outlined"
            onPress={onDismiss}
            textColor={theme.colors.error}
            style={[styles.footerButton, { borderColor: theme.colors.error }]}
          >
            Cancelar
          </Button>
          <Button
            mode="contained"
            onPress={handlePrint}
            loading={isPrinting}
            disabled={
              !selectedPrinterId || activePrinters.length === 0 || isPrinting
            }
            style={[styles.footerButton, styles.printButton]}
            buttonColor={theme.colors.primary}
          >
            Imprimir
          </Button>
        </View>
      </Modal>
    </Portal>
  );
};

const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    modalContent: {
      margin: 16,
      borderRadius: 16,
      maxHeight: '85%',
      overflow: 'hidden',
      elevation: 8,
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 4,
      },
      shadowOpacity: 0.3,
      shadowRadius: 8,
    },
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: 16,
      paddingVertical: 10,
    },
    title: {
      fontSize: 18,
      fontWeight: '700',
      flex: 1,
    },
    closeButton: {
      margin: -8,
    },
    content: {
      maxHeight: 400,
    },
    section: {
      paddingHorizontal: 16,
      paddingVertical: 8,
    },
    sectionTitle: {
      fontSize: 14,
      fontWeight: '600',
      marginBottom: 8,
    },
    radioItem: {
      marginBottom: 6,
      borderRadius: 10,
      elevation: 1,
      padding: 2,
    },
    radioContent: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingVertical: 8,
      paddingHorizontal: 12,
    },
    radioTextContainer: {
      flex: 1,
      marginLeft: 8,
    },
    radioLabel: {
      fontSize: 14,
      fontWeight: '600',
      marginBottom: 2,
    },
    radioDescription: {
      fontSize: 11,
      opacity: 0.7,
    },
    noPrintersText: {
      fontSize: 13,
      textAlign: 'center',
      padding: 12,
      fontWeight: '500',
    },
    footer: {
      flexDirection: 'row',
      justifyContent: 'center',
      alignItems: 'center',
      paddingVertical: 12,
      paddingHorizontal: 16,
      gap: 12,
    },
    footerButton: {
      minWidth: 100,
      borderRadius: 8,
    },
    printButton: {
      paddingHorizontal: 4,
    },
    selectedGeneralItem: {
      borderColor: theme.colors.primary,
      borderWidth: 2,
    },
    unselectedGeneralItem: {
      borderColor: 'transparent',
      borderWidth: 0,
    },
    selectedBillingItem: {
      borderColor: theme.colors.primary,
      borderWidth: 2,
    },
    unselectedBillingItem: {
      borderColor: 'transparent',
      borderWidth: 0,
    },
    selectedPrinterItem: {
      borderColor: theme.colors.primary,
      borderWidth: 2,
    },
    unselectedPrinterItem: {
      borderColor: 'transparent',
      borderWidth: 0,
    },
  });

================
File: app/src/modules/shiftAudit/components/OrderDetailsView.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';
import {
  Surface,
  Text,
  Divider,
  Appbar,
  ActivityIndicator,
  IconButton,
  Chip,
} from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import type { Receipt } from '@/modules/receipts/schema/receipt.schema';
import {
  CustomizationTypeEnum,
  PizzaHalfEnum,
  CustomizationActionEnum,
} from '@/modules/pizzaCustomizations/schema/pizzaCustomization.schema';

interface OrderDetailsViewProps {
  order: Receipt | null;
  onBack: () => void;
  onShowHistory?: () => void;
  isLoading?: boolean;
}

const formatPizzaCustomizations = (customizations: any[]): string => {
  if (!customizations || customizations.length === 0) return '';

  const groupedByHalf = customizations.reduce(
    (acc, curr) => {
      const half =
        curr.half === PizzaHalfEnum.HALF_1
          ? 'HALF_1'
          : curr.half === PizzaHalfEnum.HALF_2
            ? 'HALF_2'
            : 'FULL';

      if (!acc[half]) {
        acc[half] = {
          flavors: [],
          addedIngredients: [],
          removedIngredients: [],
        };
      }

      const name = curr.pizzaCustomization?.name || curr.pizzaCustomizationId;
      const type = curr.pizzaCustomization?.type;

      if (type === 'FLAVOR' || type === CustomizationTypeEnum.FLAVOR) {
        acc[half].flavors.push(name);
      } else if (
        type === 'INGREDIENT' ||
        type === CustomizationTypeEnum.INGREDIENT
      ) {
        if (curr.action === CustomizationActionEnum.ADD) {
          acc[half].addedIngredients.push(name);
        } else {
          acc[half].removedIngredients.push(name);
        }
      }

      return acc;
    },
    {} as Record<
      string,
      {
        flavors: string[];
        addedIngredients: string[];
        removedIngredients: string[];
      }
    >,
  );

  if (groupedByHalf.FULL) {
    const parts: string[] = [];
    if (groupedByHalf.FULL.flavors.length > 0) {
      parts.push(groupedByHalf.FULL.flavors.join(', '));
    }
    if (groupedByHalf.FULL.addedIngredients.length > 0) {
      parts.push(`con: ${groupedByHalf.FULL.addedIngredients.join(', ')}`);
    }
    if (groupedByHalf.FULL.removedIngredients.length > 0) {
      parts.push(`sin: ${groupedByHalf.FULL.removedIngredients.join(', ')}`);
    }
    return parts.join(' - ');
  } else if (groupedByHalf.HALF_1 || groupedByHalf.HALF_2) {
    const formatHalf = (halfData: {
      flavors: string[];
      addedIngredients: string[];
      removedIngredients: string[];
    }) => {
      const parts: string[] = [];
      if (halfData.flavors.length > 0) {
        parts.push(halfData.flavors.join(', '));
      }
      if (halfData.addedIngredients.length > 0) {
        parts.push(`con: ${halfData.addedIngredients.join(', ')}`);
      }
      if (halfData.removedIngredients.length > 0) {
        parts.push(`sin: ${halfData.removedIngredients.join(', ')}`);
      }
      return parts.join(' - ');
    };

    const half1 = groupedByHalf.HALF_1 ? formatHalf(groupedByHalf.HALF_1) : '';
    const half2 = groupedByHalf.HALF_2 ? formatHalf(groupedByHalf.HALF_2) : '';

    return half1 && half2 ? `(${half1} / ${half2})` : half1 || half2;
  }

  return '';
};

export const OrderDetailsView: React.FC<OrderDetailsViewProps> = ({
  order,
  onBack,
  onShowHistory,
  isLoading = false,
}) => {
  const theme = useAppTheme();
  const [showPrintHistory, setShowPrintHistory] = useState(false);

  const getOrderTypeLabel = (type: string) => {
    switch (type) {
      case 'DINE_IN':
        return ' Local';
      case 'TAKE_AWAY':
        return ' Llevar';
      case 'DELIVERY':
        return ' Envo';
      default:
        return type;
    }
  };

  const getOrderStatusLabel = (status: string) => {
    switch (status) {
      case 'PENDING':
        return 'Pendiente';
      case 'IN_PROGRESS':
        return 'En preparacin';
      case 'READY':
        return 'Listo';
      case 'DELIVERED':
        return 'Entregado';
      case 'COMPLETED':
        return 'Completado';
      case 'CANCELLED':
        return 'Cancelado';
      default:
        return status;
    }
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'PENDING':
        return '#FFA726';
      case 'IN_PROGRESS':
        return theme.colors.primary;
      case 'READY':
        return '#66BB6A';
      case 'DELIVERED':
        return '#9C27B0';
      case 'COMPLETED':
        return '#10B981';
      case 'CANCELLED':
        return theme.colors.error;
      default:
        return theme.colors.onSurfaceVariant;
    }
  };

  const getPaymentStatus = () => {
    if (
      order?.payments &&
      Array.isArray(order.payments) &&
      order.payments.length > 0
    ) {
      const totalPaid = order.payments.reduce((sum, p) => sum + p.amount, 0);
      const totalAmount =
        typeof order.total === 'string'
          ? parseFloat(order.total)
          : order.total || 0;

      if (totalPaid >= totalAmount) {
        return { label: 'Pagado', color: '#10B981' };
      } else if (totalPaid > 0) {
        return { label: 'Parcial', color: '#F59E0B' };
      }
    }
    return { label: 'Pendiente', color: '#EF4444' };
  };

  const paymentStatus = order
    ? getPaymentStatus()
    : { label: 'Pendiente', color: '#EF4444' };

  const renderItem = (item: any) => {
    const quantity = item.quantity || 1;
    const unitPrice = parseFloat(item.finalPrice);
    const totalPrice = unitPrice * quantity;
    const preparationStatusColors = {
      PENDING: '#FFA726',
      IN_PROGRESS: '#42A5F5',
      READY: '#66BB6A',
      DELIVERED: '#26A69A',
      CANCELLED: '#EF5350',
    };
    const statusColor =
      preparationStatusColors[
        item.preparationStatus as keyof typeof preparationStatusColors
      ] || theme.colors.onSurfaceVariant;

    return (
      <Surface
        key={`${item.id}`}
        style={[
          styles.itemCard,
          styles.itemCardSpacing,
          { backgroundColor: theme.colors.elevation.level1 },
        ]}
        elevation={1}
      >
        <View style={styles.itemContent}>
          <View style={styles.itemHeader}>
            <View style={styles.nameContainer}>
              <Text
                style={[styles.itemQuantity, { color: theme.colors.primary }]}
              >
                {quantity}x
              </Text>
              <Text
                style={[styles.itemName, { color: theme.colors.onSurface }]}
                numberOfLines={1}
              >
                {item.productVariant?.name || item.product.name}
              </Text>
            </View>
            {item.preparationStatus && (
              <View
                style={[styles.statusChip, { backgroundColor: statusColor }]}
              >
                <Text style={styles.statusChipText}>
                  {item.preparationStatus === 'PENDING' && 'Pendiente'}
                  {item.preparationStatus === 'IN_PROGRESS' && 'Preparando'}
                  {item.preparationStatus === 'READY' && 'Listo'}
                  {item.preparationStatus === 'DELIVERED' && 'Entregado'}
                  {item.preparationStatus === 'CANCELLED' && 'Cancelado'}
                </Text>
              </View>
            )}
          </View>

          <View style={styles.itemDetailsContainer}>
            {item.selectedPizzaCustomizations &&
              item.selectedPizzaCustomizations.length > 0 && (
                <View style={styles.customizationContainer}>
                  <Text
                    style={[
                      styles.pizzaCustomizationText,
                      { color: theme.colors.onSurfaceVariant },
                    ]}
                  >
                    {formatPizzaCustomizations(
                      item.selectedPizzaCustomizations,
                    )}
                  </Text>
                </View>
              )}

            {item.productModifiers && item.productModifiers.length > 0 && (
              <View style={styles.modifiersContainer}>
                {item.productModifiers.map((modifier: any) => (
                  <View key={modifier.id} style={styles.modifierRow}>
                    <Text
                      style={[
                        styles.modifierText,
                        { color: theme.colors.onSurfaceVariant },
                      ]}
                    >
                       {modifier.name}
                    </Text>
                    {modifier.price && Number(modifier.price) > 0 && (
                      <Text
                        style={[
                          styles.modifierPrice,
                          { color: theme.colors.tertiary },
                        ]}
                      >
                        +${Number(modifier.price).toFixed(2)}
                      </Text>
                    )}
                  </View>
                ))}
              </View>
            )}

            {item.preparationNotes && (
              <View style={styles.notesContainer}>
                <Text
                  style={[
                    styles.notesText,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                   {item.preparationNotes}
                </Text>
              </View>
            )}
          </View>

          <View style={styles.priceContainer}>
            <View style={styles.priceRow}>
              <Text
                style={[
                  styles.priceLabel,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                P. unitario:
              </Text>
              <Text
                style={[styles.priceValue, { color: theme.colors.onSurface }]}
              >
                ${unitPrice.toFixed(2)}
              </Text>
            </View>
            {quantity > 1 && (
              <View style={styles.priceRow}>
                <Text
                  style={[
                    styles.priceLabel,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                  Total {quantity}:
                </Text>
                <Text
                  style={[styles.totalPrice, { color: theme.colors.primary }]}
                >
                  ${totalPrice.toFixed(2)}
                </Text>
              </View>
            )}
          </View>
        </View>
      </Surface>
    );
  };

  if (isLoading) {
    return (
      <View style={styles.container}>
        <Appbar.Header style={styles.appbarHeader}>
          <Appbar.BackAction onPress={onBack} />
          <Appbar.Content title="Cargando..." />
        </Appbar.Header>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
          <Text
            style={[
              styles.loadingText,
              { color: theme.colors.onSurfaceVariant },
            ]}
          >
            Cargando detalles del recibo...
          </Text>
        </View>
      </View>
    );
  }

  if (!order) {
    return null;
  }

  return (
    <View
      style={[styles.container, { backgroundColor: theme.colors.background }]}
    >
      <Appbar.Header style={styles.appbarHeader}>
        <Appbar.BackAction onPress={onBack} />
        <Appbar.Content title={`Recibo #${order?.shiftOrderNumber || ''}`} />
        <Appbar.Action
          icon="history"
          size={28}
          onPress={onShowHistory}
          disabled={!onShowHistory}
        />
      </Appbar.Header>

      <View style={styles.header}>
        <View style={styles.headerInfo}>
          <View style={styles.headerTopRow}>
            <View style={styles.headerLeft}>
              <Text style={[styles.orderType, { color: theme.colors.primary }]}>
                {order ? getOrderTypeLabel(order.orderType as string) : ''}
              </Text>
            </View>
          </View>
          <View style={styles.headerBottomRow}>
            <View style={styles.chipsRow}>
              <View
                style={[
                  styles.headerStatusChip,
                  {
                    backgroundColor: order
                      ? getStatusColor(order.orderStatus as string)
                      : theme.colors.surfaceVariant,
                  },
                ]}
              >
                <Text style={styles.headerStatusChipText}>
                  {order
                    ? getOrderStatusLabel(order.orderStatus as string)
                    : ''}
                </Text>
              </View>
              {order?.preparationScreens &&
              Array.isArray(order.preparationScreens)
                ? (order.preparationScreens as any[]).map(
                    (screen: any, index: number) => (
                      <Chip
                        key={index}
                        mode="outlined"
                        compact
                        style={styles.screenChip}
                        textStyle={styles.screenChipText}
                      >
                         {screen}
                      </Chip>
                    ),
                  )
                : null}
            </View>
          </View>
          <View style={styles.headerDatesRow}>
            <Text
              style={[
                styles.headerDate,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Creado:{' '}
              {order?.createdAt
                ? format(
                    new Date(order.createdAt as string),
                    'dd/MM/yyyy HH:mm',
                    {
                      locale: es,
                    },
                  )
                : ''}
            </Text>
            {order?.finalizedAt ? (
              <Text
                style={[styles.headerDate, { color: theme.colors.primary }]}
              >
                Finalizado:{' '}
                {format(
                  new Date(order.finalizedAt as string),
                  'dd/MM/yyyy HH:mm',
                  {
                    locale: es,
                  },
                )}
              </Text>
            ) : null}
          </View>
        </View>
      </View>

      <ScrollView
        style={styles.scrollView}
        showsVerticalScrollIndicator={false}
        contentContainerStyle={styles.scrollContent}
      >
        <View style={styles.infoSection}>
          {order?.deliveryInfo &&
            typeof order.deliveryInfo === 'object' &&
            'recipientName' in order.deliveryInfo &&
            order.deliveryInfo.recipientName && (
              <View style={styles.infoRow}>
                <Text
                  style={[
                    styles.contactText,
                    { color: theme.colors.onSurface },
                  ]}
                >
                   Nombre del Cliente:{' '}
                  {String((order.deliveryInfo as any).recipientName)}
                </Text>
              </View>
            )}

          {order?.deliveryInfo &&
            typeof order.deliveryInfo === 'object' &&
            'recipientPhone' in order.deliveryInfo &&
            order.deliveryInfo.recipientPhone && (
              <View style={styles.infoRow}>
                <Text
                  style={[
                    styles.contactText,
                    { color: theme.colors.onSurface },
                  ]}
                >
                   Telfono:{' '}
                  {String((order.deliveryInfo as any).recipientPhone)}
                </Text>
              </View>
            )}

          {order?.orderType === 'DELIVERY' &&
            order?.deliveryInfo &&
            typeof order.deliveryInfo === 'object' &&
            'fullAddress' in order.deliveryInfo &&
            order.deliveryInfo.fullAddress && (
              <View style={styles.infoRow}>
                <Text
                  style={[
                    styles.addressText,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                   Direccin de Entrega:{' '}
                  {String((order.deliveryInfo as any).fullAddress)}
                </Text>
              </View>
            )}

          {order?.orderType === 'DINE_IN' &&
            order?.table &&
            typeof order.table === 'object' && (
              <View style={styles.infoRow}>
                <Text
                  style={[styles.tableText, { color: theme.colors.onSurface }]}
                >
                   Mesa: {(order.table as any)?.area?.name || 'Sin rea'} -{' '}
                  {(order.table as any)?.name}
                </Text>
              </View>
            )}

          {order?.scheduledAt && (
            <View style={styles.infoRow}>
              <Text
                style={[
                  styles.contactText,
                  styles.primaryFont,
                  { color: theme.colors.primary },
                ]}
              >
                 Hora de Entrega Programada:{' '}
                {order.scheduledAt
                  ? format(new Date(order.scheduledAt as string), 'HH:mm', {
                      locale: es,
                    })
                  : 'No especificada'}
              </Text>
            </View>
          )}

          {order?.user && (
            <View style={styles.infoRow}>
              <Text
                style={[
                  styles.contactText,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                 Atendido por: {(order.user as any)?.firstName}{' '}
                {(order.user as any)?.lastName}
              </Text>
            </View>
          )}

          {order?.notes && (
            <View style={styles.infoRow}>
              <Text
                style={[
                  styles.notesText,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                 Notas: {order.notes as string}
              </Text>
            </View>
          )}
        </View>

        <Divider style={styles.divider} />

        <View style={styles.itemsList}>
          {Array.isArray(order?.orderItems)
            ? order.orderItems.map((item: any) => renderItem(item))
            : []}
        </View>

        <Divider style={styles.divider} />

        {order?.payments &&
          Array.isArray(order.payments) &&
          order.payments.length > 0 && (
            <>
              <View style={styles.paymentsSection}>
                <View style={styles.paymentSummaryCompact}>
                  <View style={styles.summaryCompactRow}>
                    <Text
                      style={[
                        styles.summaryCompactLabel,
                        { color: theme.colors.onSurfaceVariant },
                      ]}
                    >
                      Total: $
                      {typeof order.total === 'string'
                        ? parseFloat(order.total).toFixed(2)
                        : typeof order.total === 'number'
                          ? order.total.toFixed(2)
                          : '0.00'}
                    </Text>
                    <Text
                      style={[styles.summaryCompactLabel, styles.paidTextColor]}
                    >
                      Pagado: $
                      {Array.isArray(order.payments)
                        ? order.payments
                            .reduce(
                              (sum, p) => sum + (Number(p.amount) || 0),
                              0,
                            )
                            .toFixed(2)
                        : '0.00'}
                    </Text>
                    {(() => {
                      const totalAmount =
                        typeof order.total === 'string'
                          ? parseFloat(order.total)
                          : typeof order.total === 'number'
                            ? order.total
                            : 0;
                      const totalPaid = Array.isArray(order.payments)
                        ? order.payments.reduce(
                            (sum, p) => sum + (Number(p.amount) || 0),
                            0,
                          )
                        : 0;
                      const remaining = totalAmount - totalPaid;
                      if (remaining > 0) {
                        return (
                          <Text
                            style={[
                              styles.summaryCompactLabel,
                              styles.primaryFont,
                              {
                                color: theme.colors.error,
                              },
                            ]}
                          >
                            Resta: ${remaining.toFixed(2)}
                          </Text>
                        );
                      }
                      return null;
                    })()}
                  </View>
                </View>

                {Array.isArray(order.payments)
                  ? order.payments.map((payment: any, index: number) => {
                      const getPaymentMethodLabel = (method: string) => {
                        switch (method) {
                          case 'CASH':
                          case 'cash':
                            return 'Efectivo';
                          case 'CREDIT_CARD':
                          case 'card':
                            return 'Tarjeta de Crdito';
                          case 'DEBIT_CARD':
                            return 'Tarjeta de Dbito';
                          case 'TRANSFER':
                          case 'transfer':
                            return 'Transferencia';
                          case 'OTHER':
                            return 'Otro';
                          default:
                            return method;
                        }
                      };

                      const getPaymentStatusColor = (status: string) => {
                        switch (status) {
                          case 'COMPLETED':
                            return '#10B981';
                          case 'PENDING':
                            return '#F59E0B';
                          case 'FAILED':
                            return theme.colors.error;
                          case 'REFUNDED':
                            return '#6B7280';
                          case 'CANCELLED':
                            return theme.colors.error;
                          default:
                            return theme.colors.onSurfaceVariant;
                        }
                      };

                      const getPaymentStatusLabel = (status: string) => {
                        switch (status) {
                          case 'COMPLETED':
                            return 'Completado';
                          case 'PENDING':
                            return 'Pendiente';
                          case 'FAILED':
                            return 'Fallido';
                          case 'REFUNDED':
                            return 'Reembolsado';
                          case 'CANCELLED':
                            return 'Cancelado';
                          default:
                            return status;
                        }
                      };

                      return (
                        <View
                          key={payment.id || index}
                          style={styles.paymentRowCompact}
                        >
                          <Text
                            style={[
                              styles.paymentMethodCompact,
                              { color: theme.colors.onSurface },
                            ]}
                          >
                             {getPaymentMethodLabel(payment.paymentMethod)}
                          </Text>
                          <Text
                            style={[
                              styles.paymentDateCompact,
                              { color: theme.colors.onSurfaceVariant },
                            ]}
                          >
                            {format(new Date(payment.createdAt), 'HH:mm', {
                              locale: es,
                            })}
                          </Text>
                          <View
                            style={[
                              styles.paymentStatusBadgeCompact,
                              {
                                backgroundColor:
                                  getPaymentStatusColor(payment.paymentStatus) +
                                  '20',
                              },
                            ]}
                          >
                            <Text
                              style={[
                                styles.paymentStatusTextCompact,
                                {
                                  color: getPaymentStatusColor(
                                    payment.paymentStatus,
                                  ),
                                },
                              ]}
                            >
                              {getPaymentStatusLabel(payment.paymentStatus)}
                            </Text>
                          </View>
                          <Text
                            style={[
                              styles.paymentAmountCompact,
                              { color: theme.colors.primary },
                            ]}
                          >
                            ${Number(payment.amount).toFixed(2)}
                          </Text>
                        </View>
                      );
                    })
                  : null}
              </View>
              <Divider style={styles.divider} />
            </>
          )}

        {order?.ticketImpressions &&
          Array.isArray(order.ticketImpressions) &&
          order.ticketImpressions.length > 0 && (
            <>
              <View style={styles.ticketImpressionsSection}>
                <TouchableOpacity
                  style={styles.collapsibleHeader}
                  onPress={() => setShowPrintHistory(!showPrintHistory)}
                  activeOpacity={0.7}
                >
                  <Text
                    style={[
                      styles.sectionTitle,
                      { color: theme.colors.primary },
                    ]}
                  >
                     Historial de Impresiones (
                    {Array.isArray(order.ticketImpressions)
                      ? order.ticketImpressions.length
                      : 0}
                    )
                  </Text>
                  <IconButton
                    icon={showPrintHistory ? 'chevron-up' : 'chevron-down'}
                    size={20}
                    style={styles.collapseIcon}
                  />
                </TouchableOpacity>

                {showPrintHistory && (
                  <View style={styles.collapsibleContent}>
                    {Array.isArray(order.ticketImpressions)
                      ? order.ticketImpressions.map(
                          (impression: any, index: number) => {
                            const getTicketTypeLabel = (type: string) => {
                              switch (type) {
                                case 'KITCHEN':
                                  return ' Cocina';
                                case 'BAR':
                                  return ' Barra';
                                case 'BILLING':
                                  return ' Cuenta';
                                case 'CUSTOMER_COPY':
                                  return ' Copia Cliente';
                                case 'GENERAL':
                                  return ' General';
                                default:
                                  return type;
                              }
                            };

                            return (
                              <View
                                key={impression.id || index}
                                style={styles.impressionRow}
                              >
                                <View style={styles.impressionLeft}>
                                  <Text
                                    style={[
                                      styles.impressionType,
                                      { color: theme.colors.onSurface },
                                    ]}
                                  >
                                    {getTicketTypeLabel(impression.ticketType)}
                                  </Text>
                                  <View style={styles.impressionDetails}>
                                    {impression.user && (
                                      <Text
                                        style={[
                                          styles.impressionUser,
                                          {
                                            color:
                                              theme.colors.onSurfaceVariant,
                                          },
                                        ]}
                                      >
                                        por {impression.user.firstName || ''}{' '}
                                        {impression.user.lastName || ''}
                                      </Text>
                                    )}
                                    {impression.printer && (
                                      <Text
                                        style={[
                                          styles.impressionPrinter,
                                          {
                                            color:
                                              theme.colors.onSurfaceVariant,
                                          },
                                        ]}
                                      >
                                         {impression.printer.name}
                                      </Text>
                                    )}
                                  </View>
                                </View>
                                <Text
                                  style={[
                                    styles.impressionTime,
                                    { color: theme.colors.onSurfaceVariant },
                                  ]}
                                >
                                  {format(
                                    new Date(impression.impressionTime),
                                    'HH:mm:ss',
                                    { locale: es },
                                  )}
                                </Text>
                              </View>
                            );
                          },
                        )
                      : null}
                  </View>
                )}
              </View>
            </>
          )}
      </ScrollView>

      <Divider style={styles.divider} />

      <View style={styles.footer}>
        <View style={styles.footerLeft}>
          <Text
            style={[
              styles.totalLabel,
              { color: theme.colors.onSurfaceVariant },
            ]}
          >
            Total:
          </Text>
          <Text style={[styles.totalAmount, { color: theme.colors.primary }]}>
            $
            {order
              ? typeof order.total === 'string'
                ? parseFloat(order.total).toFixed(2)
                : typeof order.total === 'number'
                  ? order.total.toFixed(2)
                  : '0.00'
              : '0.00'}
          </Text>
        </View>
        <View
          style={[
            styles.paymentBadge,
            { backgroundColor: paymentStatus.color },
          ]}
        >
          <Text style={styles.paymentBadgeText}> {paymentStatus.label}</Text>
        </View>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  appbarHeader: {
    elevation: 0,
  },
  header: {
    paddingHorizontal: 16,
    paddingTop: 10,
    paddingBottom: 6,
  },
  headerTopRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 6,
  },
  headerLeft: {
    flex: 1,
  },
  headerBottomRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 4,
  },
  itemCardSpacing: {
    marginBottom: 8,
  },
  primaryFont: {
    fontWeight: '600',
  },
  paidTextColor: {
    color: '#10B981',
  },
  headerDatesRow: {
    gap: 8,
    marginTop: 4,
  },
  chipsRow: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
    flexWrap: 'wrap',
  },
  headerSeparator: {
    fontSize: 14,
    marginHorizontal: 6,
  },
  orderType: {
    fontSize: 15,
    fontWeight: '600',
  },
  headerDate: {
    fontSize: 13,
  },
  headerInfo: {
    // Contenedor para toda la informacin del header
    flex: 1,
  },
  infoSection: {
    paddingHorizontal: 16,
    paddingTop: 4,
    paddingBottom: 6,
    gap: 4,
  },
  infoRow: {
    marginVertical: 2,
  },
  contactText: {
    fontSize: 14,
  },
  addressText: {
    fontSize: 14,
    lineHeight: 18,
  },
  tableText: {
    fontSize: 14,
  },
  screenChip: {
    height: 24,
  },
  screenChipText: {
    fontSize: 12,
    marginVertical: -2,
  },
  paymentBadge: {
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 12,
  },
  paymentBadgeText: {
    color: 'white',
    fontSize: 14,
    fontWeight: '600',
  },
  totalAmount: {
    fontSize: 18,
    fontWeight: '700',
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderTopWidth: 1,
    borderTopColor: 'rgba(0,0,0,0.08)',
    backgroundColor: 'inherit',
  },
  footerLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  totalLabel: {
    fontSize: 16,
    fontWeight: '600',
  },
  divider: {
    marginVertical: 2,
  },
  headerStatusChip: {
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 10,
  },
  headerStatusChipText: {
    color: 'white',
    fontSize: 13,
    fontWeight: '600',
  },
  scrollView: {
    flexGrow: 0,
    flexShrink: 1,
    maxHeight: '70%',
  },
  scrollContent: {
    paddingBottom: 8,
  },
  itemsList: {
    padding: 12,
    paddingBottom: 16,
  },
  itemCard: {
    borderRadius: 8,
    overflow: 'hidden',
  },
  itemContent: {
    padding: 10,
  },
  itemHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 6,
  },
  nameContainer: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    marginRight: 8,
  },
  itemQuantity: {
    fontSize: 16,
    fontWeight: '700',
    marginRight: 6,
  },
  itemName: {
    fontSize: 15,
    fontWeight: '600',
    flex: 1,
    lineHeight: 18,
  },
  statusChip: {
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 12,
  },
  statusChipText: {
    color: 'white',
    fontSize: 12,
    fontWeight: '600',
  },
  itemDetailsContainer: {
    marginBottom: 6,
  },
  customizationContainer: {
    marginBottom: 4,
  },
  pizzaCustomizationText: {
    fontSize: 13,
    fontStyle: 'italic',
    lineHeight: 16,
  },
  modifiersContainer: {
    marginTop: 2,
  },
  modifierRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 1,
  },
  modifierText: {
    fontSize: 13,
    flex: 1,
    lineHeight: 16,
  },
  modifierPrice: {
    fontSize: 13,
    fontWeight: '500',
    marginLeft: 4,
  },
  notesContainer: {
    marginTop: 4,
    paddingTop: 4,
    borderTopWidth: 1,
    borderTopColor: 'rgba(0,0,0,0.06)',
  },
  notesText: {
    fontSize: 13,
    fontStyle: 'italic',
    lineHeight: 16,
  },
  priceContainer: {
    marginTop: 6,
    paddingTop: 6,
    borderTopWidth: 1,
    borderTopColor: 'rgba(0,0,0,0.06)',
  },
  priceRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 2,
  },
  priceLabel: {
    fontSize: 13,
    opacity: 0.7,
  },
  priceValue: {
    fontSize: 14,
    fontWeight: '600',
  },
  totalPrice: {
    fontSize: 16,
    fontWeight: '700',
  },
  paymentsSection: {
    paddingHorizontal: 16,
    paddingVertical: 8,
  },
  paymentSummaryCompact: {
    marginBottom: 8,
  },
  summaryCompactRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  summaryCompactLabel: {
    fontSize: 14,
    fontWeight: '500',
  },
  paymentRowCompact: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 6,
    gap: 8,
  },
  paymentMethodCompact: {
    fontSize: 13,
    fontWeight: '500',
    flex: 1,
  },
  paymentDateCompact: {
    fontSize: 12,
  },
  paymentAmountCompact: {
    fontSize: 14,
    fontWeight: '600',
    minWidth: 50,
    textAlign: 'right',
  },
  paymentStatusBadgeCompact: {
    paddingHorizontal: 6,
    paddingVertical: 1,
    borderRadius: 10,
  },
  paymentStatusTextCompact: {
    fontSize: 11,
    fontWeight: '600',
  },
  ticketImpressionsSection: {
    paddingHorizontal: 16,
    paddingVertical: 8,
  },
  collapsibleHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingRight: 4,
  },
  collapseIcon: {
    margin: -8,
  },
  collapsibleContent: {
    marginTop: 8,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 0,
  },
  impressionRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
    paddingLeft: 8,
  },
  impressionLeft: {
    flex: 1,
    gap: 2,
  },
  impressionType: {
    fontSize: 14,
    fontWeight: '500',
  },
  impressionDetails: {
    gap: 2,
  },
  impressionUser: {
    fontSize: 13,
    opacity: 0.7,
  },
  impressionPrinter: {
    fontSize: 13,
    opacity: 0.7,
    fontStyle: 'italic',
  },
  impressionTime: {
    fontSize: 13,
    opacity: 0.7,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
  },
});

================
File: app/src/modules/shiftAudit/screens/ShiftsListScreen.tsx
================
import { useState, useMemo } from 'react';
import {
  View,
  StyleSheet,
  RefreshControl,
  TouchableOpacity,
  Modal,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import {
  Text,
  Chip,
  Card,
  Divider,
  Button,
  Menu,
  Avatar,
  ActivityIndicator,
  IconButton,
  Surface,
} from 'react-native-paper';
import { FlashList } from '@shopify/flash-list';
import { format, parseISO, subDays, startOfDay, endOfDay } from 'date-fns';
import { es } from 'date-fns/locale';
import { useAppTheme } from '@/app/styles/theme';
import { useShifts } from '../hooks/useShifts';
import { formatCurrency } from '@/app/lib/formatters';
import type { Shift } from '../types';
import { ShiftOrdersModal, ShiftSalesSummaryView } from '../components';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';
import DateTimePicker from '@react-native-community/datetimepicker';

export function ShiftsListScreen() {
  const theme = useAppTheme();
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [dateFilter, setDateFilter] = useState<
    'today' | 'yesterday' | 'last7' | 'custom'
  >('last7');
  const [showDateMenu, setShowDateMenu] = useState(false);
  const [showDateRangePicker, setShowDateRangePicker] = useState(false);
  const [customDateRange, setCustomDateRange] = useState<{
    start: Date;
    end: Date;
  }>({
    start: subDays(new Date(), 7),
    end: new Date(),
  });
  const [datePickerMode, setDatePickerMode] = useState<'start' | 'end'>(
    'start',
  );
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [selectedShiftId, setSelectedShiftId] = useState<string | null>(null);
  const [selectedShiftNumber, setSelectedShiftNumber] = useState<
    number | undefined
  >();
  const [showOrdersModal, setShowOrdersModal] = useState(false);
  const [showSalesSummaryView, setShowSalesSummaryView] = useState(false);

  const dateParams = useMemo(() => {
    const now = new Date();

    switch (dateFilter) {
      case 'today':
        return {
          startDate: format(startOfDay(now), 'yyyy-MM-dd'),
          endDate: format(endOfDay(now), 'yyyy-MM-dd'),
        };
      case 'yesterday': {
        const yesterday = subDays(now, 1);
        return {
          startDate: format(startOfDay(yesterday), 'yyyy-MM-dd'),
          endDate: format(endOfDay(yesterday), 'yyyy-MM-dd'),
        };
      }
      case 'last7':
        return {
          startDate: format(startOfDay(subDays(now, 7)), 'yyyy-MM-dd'),
          endDate: format(endOfDay(now), 'yyyy-MM-dd'),
        };
      case 'custom':
        return {
          startDate: format(startOfDay(customDateRange.start), 'yyyy-MM-dd'),
          endDate: format(endOfDay(customDateRange.end), 'yyyy-MM-dd'),
        };
      default:
        return {
          startDate: format(startOfDay(subDays(now, 7)), 'yyyy-MM-dd'),
          endDate: format(endOfDay(now), 'yyyy-MM-dd'),
        };
    }
  }, [dateFilter, customDateRange]);

  const {
    data: shifts,
    isLoading,
    error,
    refetch,
    isRefetching,
  } = useShifts(dateParams);

  useRefreshModuleOnFocus('shifts');

  const handleRefresh = async () => {
    setIsRefreshing(true);
    await refetch();
    setIsRefreshing(false);
  };

  const filteredShifts = useMemo(() => {
    if (!shifts || !Array.isArray(shifts)) {
      return [];
    }

    return shifts.filter((shift) => {
      if (!shift.openedAt) return false;

      try {
        const shiftDate = parseISO(shift.openedAt);
        const shiftDateOnly = format(shiftDate, 'yyyy-MM-dd');

        switch (dateFilter) {
          case 'today':
            return shiftDateOnly === format(new Date(), 'yyyy-MM-dd');
          case 'yesterday':
            return (
              shiftDateOnly === format(subDays(new Date(), 1), 'yyyy-MM-dd')
            );
          case 'last7': {
            const sevenDaysAgo = format(subDays(new Date(), 7), 'yyyy-MM-dd');
            const today = format(new Date(), 'yyyy-MM-dd');
            return shiftDateOnly >= sevenDaysAgo && shiftDateOnly <= today;
          }
          case 'custom': {
            const customStart = format(customDateRange.start, 'yyyy-MM-dd');
            const customEnd = format(customDateRange.end, 'yyyy-MM-dd');
            return shiftDateOnly >= customStart && shiftDateOnly <= customEnd;
          }
          default:
            return true;
        }
      } catch (e) {
        return false;
      }
    });
  }, [shifts, dateFilter, customDateRange]);

  const getDateFilterLabel = () => {
    switch (dateFilter) {
      case 'today':
        return 'Hoy';
      case 'yesterday':
        return 'Ayer';
      case 'last7':
        return 'ltimos 7 das';
      case 'custom':
        return `${format(customDateRange.start, 'dd/MM')} - ${format(customDateRange.end, 'dd/MM')}`;
      default:
        return 'ltimos 7 das';
    }
  };

  const handleDateChange = (_event: any, selectedDate?: Date) => {
    setShowDatePicker(false);
    if (selectedDate) {
      if (datePickerMode === 'start') {
        setCustomDateRange({ ...customDateRange, start: selectedDate });
      } else {
        setCustomDateRange({ ...customDateRange, end: selectedDate });
      }
    }
  };

  const handleCustomDateRange = () => {
    setDateFilter('custom');
    setShowDateMenu(false);
    setShowDateRangePicker(true);
  };

  const handleViewOrders = (shift: Shift) => {
    setSelectedShiftId(String(shift.id));
    setSelectedShiftNumber(shift.globalShiftNumber || shift.shiftNumber);
    setShowOrdersModal(true);
  };

  const handleViewSalesSummary = (shift: Shift) => {
    setSelectedShiftId(String(shift.id));
    setSelectedShiftNumber(shift.globalShiftNumber || shift.shiftNumber);
    setShowSalesSummaryView(true);
  };

  const formatShiftDate = (dateString: string) => {
    try {
      const date = parseISO(dateString);
      return format(date, "d 'de' MMMM, yyyy", { locale: es });
    } catch {
      return dateString;
    }
  };

  const formatShiftTime = (dateString: string) => {
    try {
      const date = parseISO(dateString);
      return format(date, 'HH:mm', { locale: es });
    } catch {
      return dateString;
    }
  };

  const getShiftDuration = (openedAt: string, closedAt: string | null) => {
    if (!closedAt) return 'En curso';
    try {
      const start = parseISO(openedAt);
      const end = parseISO(closedAt);
      const diffInMinutes = Math.round(
        (end.getTime() - start.getTime()) / (1000 * 60),
      );
      const hours = Math.floor(diffInMinutes / 60);
      const minutes = diffInMinutes % 60;
      return `${hours}h ${minutes}m`;
    } catch {
      return 'N/A';
    }
  };

  const renderShiftItem = ({ item: shift }: { item: Shift }) => {
    const isOpen = shift.status === 'open';

    return (
      <Card
        style={[styles.shiftCard, isOpen && styles.openShiftCard]}
        mode="contained"
      >
        <Card.Content>
          <View style={styles.shiftHeader}>
            <View style={styles.shiftTitleRow}>
              <Text style={styles.shiftNumber}>
                Turno #{shift.globalShiftNumber || shift.shiftNumber || 'N/A'}
              </Text>
              <Chip
                mode="flat"
                icon={isOpen ? 'lock-open' : 'lock'}
                style={[
                  styles.statusChip,
                  {
                    backgroundColor: isOpen
                      ? theme.colors.primaryContainer
                      : theme.colors.surfaceVariant,
                  },
                ]}
                textStyle={[
                  styles.statusChipText,
                  {
                    color: isOpen
                      ? theme.colors.onPrimaryContainer
                      : theme.colors.onSurfaceVariant,
                  },
                ]}
                compact
              >
                {isOpen ? 'Abierto' : 'Cerrado'}
              </Chip>
            </View>
            <Text style={styles.shiftDate}>
              {shift.openedAt
                ? formatShiftDate(shift.openedAt)
                : 'Fecha no disponible'}
            </Text>
          </View>

          <Divider style={styles.divider} />

          <View style={styles.shiftDetails}>
            {/* Seccin de tiempo y estadsticas en una sola lnea */}
            <View style={styles.timeSection}>
              <View style={styles.timeContainer}>
                <Text style={styles.timeText}>
                  {shift.openedAt ? formatShiftTime(shift.openedAt) : 'N/A'} -{' '}
                  {shift.closedAt
                    ? formatShiftTime(shift.closedAt)
                    : 'En curso'}
                </Text>
                <Text style={styles.durationText}>
                  {shift.openedAt
                    ? getShiftDuration(shift.openedAt, shift.closedAt)
                    : 'N/A'}
                </Text>
              </View>
            </View>

            {/* Estadsticas ms compactas */}
            <View style={styles.statsSection}>
              <Surface style={styles.statCard} elevation={0}>
                <Text style={styles.statLabel}>VENTAS</Text>
                <Text style={styles.statValue}>
                  {formatCurrency(shift.totalSales)}
                </Text>
              </Surface>

              <Surface style={styles.statCard} elevation={0}>
                <Text style={styles.statLabel}>RDENES</Text>
                <Text style={styles.statValue}>{shift.totalOrders || 0}</Text>
              </Surface>
            </View>

            {/* Seccin de efectivo ms compacta */}
            <View style={styles.cashSection}>
              <View style={styles.cashRow}>
                <Text style={styles.cashLabel}>Inicial</Text>
                <Text style={styles.cashValue}>
                  {formatCurrency(shift.initialCash)}
                </Text>
              </View>
              {shift.finalCash !== null && (
                <>
                  <View style={styles.cashRow}>
                    <Text style={styles.cashLabel}>Final</Text>
                    <Text style={styles.cashValue}>
                      {formatCurrency(shift.finalCash)}
                    </Text>
                  </View>
                  <View style={styles.cashRow}>
                    <Text style={[styles.cashLabel, styles.differenceLabel]}>
                      Diferencia
                    </Text>
                    <Text
                      style={[
                        styles.cashValue,
                        styles.differenceValue,
                        {
                          color:
                            shift.finalCash - shift.initialCash >= 0
                              ? theme.colors.tertiary
                              : theme.colors.error,
                        },
                      ]}
                    >
                      {formatCurrency(shift.finalCash - shift.initialCash)}
                    </Text>
                  </View>
                </>
              )}
            </View>

            {/* Usuarios en una lnea */}
            <View style={styles.userSection}>
              <Text style={styles.userText}>
                 {shift.openedBy?.firstName || 'N/A'}{' '}
                {shift.openedBy?.lastName || ''}
              </Text>
              {shift.closedBy && (
                <Text style={styles.userText}>
                   {shift.closedBy.firstName || 'N/A'}{' '}
                  {shift.closedBy.lastName || ''}
                </Text>
              )}
            </View>

            {/* Botones de acciones */}
            <View style={styles.actionButtonsContainer}>
              <Button
                mode="contained-tonal"
                onPress={() => handleViewOrders(shift)}
                icon="receipt"
                style={[styles.actionButton, styles.ordersButton]}
                labelStyle={styles.actionButtonLabel}
                contentStyle={styles.actionButtonContent}
                compact
              >
                rdenes ({shift.totalOrders || 0})
              </Button>
              <Button
                mode="contained-tonal"
                onPress={() => handleViewSalesSummary(shift)}
                icon="chart-bar"
                style={[styles.actionButton, styles.summaryButton]}
                labelStyle={styles.actionButtonLabel}
                contentStyle={styles.actionButtonContent}
                compact
              >
                Resumen
              </Button>
            </View>
          </View>
        </Card.Content>
      </Card>
    );
  };

  const renderFilters = () => (
    <Surface style={styles.filterContainer} elevation={1}>
      <View style={styles.filterContent}>
        <Menu
          visible={showDateMenu}
          onDismiss={() => setShowDateMenu(false)}
          anchor={
            <TouchableOpacity
              style={styles.filterButton}
              onPress={() => setShowDateMenu(true)}
              activeOpacity={0.8}
            >
              <Avatar.Icon
                icon="calendar-range"
                size={32}
                style={styles.filterIcon}
                color={theme.colors.primary}
              />
              <View style={styles.filterTextContainer}>
                <Text style={styles.filterLabel}>Filtrar por fecha</Text>
                <Text style={styles.filterValue}>{getDateFilterLabel()}</Text>
              </View>
              <Avatar.Icon
                icon="chevron-down"
                size={24}
                style={styles.filterArrow}
                color={theme.colors.onSurfaceVariant}
              />
            </TouchableOpacity>
          }
          contentStyle={styles.menuContent}
        >
          <Menu.Item
            onPress={() => {
              setDateFilter('today');
              setShowDateMenu(false);
            }}
            title="Hoy"
            leadingIcon="calendar-today"
            style={dateFilter === 'today' && styles.selectedMenuItem}
          />
          <Menu.Item
            onPress={() => {
              setDateFilter('yesterday');
              setShowDateMenu(false);
            }}
            title="Ayer"
            leadingIcon="calendar-minus"
            style={dateFilter === 'yesterday' && styles.selectedMenuItem}
          />
          <Menu.Item
            onPress={() => {
              setDateFilter('last7');
              setShowDateMenu(false);
            }}
            title="ltimos 7 das"
            leadingIcon="calendar-week"
            style={dateFilter === 'last7' && styles.selectedMenuItem}
          />
          <Divider />
          <Menu.Item
            onPress={handleCustomDateRange}
            title="Rango personalizado"
            leadingIcon="calendar-range"
            style={dateFilter === 'custom' && styles.selectedMenuItem}
          />
        </Menu>
      </View>

      {/* Modal para seleccin de rango de fechas */}
      <Modal
        visible={showDateRangePicker}
        transparent
        animationType="fade"
        onRequestClose={() => setShowDateRangePicker(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            {/* Header del modal */}
            <View style={styles.modalHeader}>
              <Avatar.Icon
                icon="calendar-range"
                size={48}
                style={styles.modalIcon}
                color={theme.colors.primary}
              />
              <Text style={styles.modalTitle}>Seleccionar rango</Text>
              <IconButton
                icon="close"
                onPress={() => setShowDateRangePicker(false)}
                size={20}
                style={styles.modalCloseButton}
                iconColor={theme.colors.onSurfaceVariant}
              />
            </View>

            {/* Seleccin de fechas */}
            <View style={styles.dateRangeContainer}>
              <TouchableOpacity
                style={styles.dateButton}
                onPress={() => {
                  setDatePickerMode('start');
                  setShowDatePicker(true);
                }}
                activeOpacity={0.8}
              >
                <View style={styles.dateButtonContent}>
                  <Avatar.Icon
                    icon="calendar-start"
                    size={36}
                    style={styles.dateButtonIcon}
                    color={theme.colors.primary}
                  />
                  <View style={styles.dateButtonTextContainer}>
                    <Text style={styles.dateButtonLabel}>DESDE</Text>
                    <Text style={styles.dateButtonValue}>
                      {format(customDateRange.start, 'd MMM yyyy', {
                        locale: es,
                      })}
                    </Text>
                  </View>
                </View>
              </TouchableOpacity>

              <View style={styles.dateArrowContainer}>
                <Avatar.Icon
                  icon="arrow-right"
                  size={20}
                  style={styles.dateArrow}
                  color={theme.colors.primary}
                />
              </View>

              <TouchableOpacity
                style={styles.dateButton}
                onPress={() => {
                  setDatePickerMode('end');
                  setShowDatePicker(true);
                }}
                activeOpacity={0.8}
              >
                <View style={styles.dateButtonContent}>
                  <Avatar.Icon
                    icon="calendar-end"
                    size={36}
                    style={styles.dateButtonIcon}
                    color={theme.colors.primary}
                  />
                  <View style={styles.dateButtonTextContainer}>
                    <Text style={styles.dateButtonLabel}>HASTA</Text>
                    <Text style={styles.dateButtonValue}>
                      {format(customDateRange.end, 'd MMM yyyy', {
                        locale: es,
                      })}
                    </Text>
                  </View>
                </View>
              </TouchableOpacity>
            </View>

            {/* Botones de accin */}
            <View style={styles.modalActions}>
              <Button
                mode="outlined"
                onPress={() => setShowDateRangePicker(false)}
                style={styles.modalButton}
                labelStyle={styles.modalButtonLabel}
              >
                Cancelar
              </Button>
              <Button
                mode="contained"
                onPress={() => {
                  setDateFilter('custom');
                  setShowDateRangePicker(false);
                }}
                style={[styles.modalButton, styles.modalButtonPrimary]}
                labelStyle={styles.modalButtonLabel}
              >
                Aplicar filtro
              </Button>
            </View>
          </View>
        </View>
      </Modal>

      {showDatePicker && (
        <DateTimePicker
          value={
            datePickerMode === 'start'
              ? customDateRange.start
              : customDateRange.end
          }
          mode="date"
          display="default"
          onChange={handleDateChange}
          maximumDate={new Date()}
        />
      )}
    </Surface>
  );

  const renderEmpty = () => (
    <View style={styles.emptyContainer}>
      <Avatar.Icon
        icon="history"
        size={80}
        style={{ backgroundColor: theme.colors.surfaceVariant }}
        color={theme.colors.onSurfaceVariant}
      />
      <Text style={styles.emptyTitle}>No se encontraron turnos</Text>
      <Text style={styles.emptyMessage}>
        {dateFilter === 'custom'
          ? 'No hay turnos en el rango seleccionado'
          : 'Prueba seleccionando otro rango de fechas'}
      </Text>
    </View>
  );

  const renderError = () => (
    <View style={styles.errorContainer}>
      <Avatar.Icon
        icon="alert-circle-outline"
        size={80}
        style={{ backgroundColor: theme.colors.errorContainer }}
        color={theme.colors.error}
      />
      <Text style={styles.errorTitle}>Error al cargar turnos</Text>
      <Text style={styles.errorMessage}>
        {error?.message || 'No se pudieron cargar los turnos'}
      </Text>
      <Button
        mode="contained"
        onPress={() => refetch()}
        style={styles.retryButton}
      >
        Reintentar
      </Button>
    </View>
  );

  const renderLoading = () => (
    <View style={styles.loadingContainer}>
      <ActivityIndicator size="large" />
      <Text style={styles.loadingText}>Cargando turnos...</Text>
    </View>
  );

  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    filterContainer: {
      backgroundColor: theme.colors.surface,
      marginHorizontal: theme.spacing.m,
      marginVertical: theme.spacing.s,
      borderRadius: theme.roundness * 2,
      elevation: 1,
    },
    filterContent: {
      padding: theme.spacing.s,
    },
    filterButton: {
      flexDirection: 'row',
      alignItems: 'center',
      padding: theme.spacing.s,
      borderRadius: theme.roundness,
    },
    filterIcon: {
      backgroundColor: theme.colors.primaryContainer,
      marginRight: theme.spacing.m,
    },
    filterTextContainer: {
      flex: 1,
    },
    filterLabel: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 2,
    },
    filterValue: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    filterArrow: {
      backgroundColor: 'transparent',
    },
    menuContent: {
      backgroundColor: theme.colors.surface,
      marginTop: 40,
      minWidth: 200,
    },
    selectedMenuItem: {
      backgroundColor: theme.colors.primaryContainer,
    },
    modalOverlay: {
      flex: 1,
      backgroundColor: 'rgba(0, 0, 0, 0.4)',
      justifyContent: 'center',
      alignItems: 'center',
    },
    modalContent: {
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness * 4,
      marginHorizontal: theme.spacing.xl,
      width: '90%',
      maxWidth: 380,
      elevation: 8,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 4 },
      shadowOpacity: 0.15,
      shadowRadius: 12,
      borderWidth: 2,
      borderColor: theme.colors.outline,
    },
    modalHeader: {
      alignItems: 'center',
      paddingTop: theme.spacing.xl,
      paddingHorizontal: theme.spacing.l,
      paddingBottom: theme.spacing.m,
      position: 'relative',
    },
    modalIcon: {
      backgroundColor: theme.colors.primaryContainer,
      marginBottom: theme.spacing.m,
    },
    modalTitle: {
      fontSize: 22,
      fontWeight: '600',
      color: theme.colors.onSurface,
      textAlign: 'center',
    },
    modalCloseButton: {
      position: 'absolute',
      top: theme.spacing.s,
      right: theme.spacing.s,
    },
    dateRangeContainer: {
      paddingHorizontal: theme.spacing.l,
      paddingVertical: theme.spacing.l,
      flexDirection: 'column',
      gap: theme.spacing.m,
    },
    dateButton: {
      backgroundColor: theme.colors.background,
      borderRadius: theme.roundness * 2,
      borderWidth: 1.5,
      borderColor: theme.colors.outline,
      overflow: 'hidden',
      elevation: 1,
    },
    dateButtonContent: {
      flexDirection: 'row',
      alignItems: 'center',
      padding: theme.spacing.m,
      gap: theme.spacing.m,
    },
    dateButtonIcon: {
      backgroundColor: theme.colors.primaryContainer,
    },
    dateButtonTextContainer: {
      flex: 1,
    },
    dateButtonLabel: {
      fontSize: 10,
      fontWeight: '700',
      color: theme.colors.onSurfaceVariant,
      letterSpacing: 1,
      marginBottom: 2,
    },
    dateButtonValue: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    dateArrowContainer: {
      alignSelf: 'center',
      paddingVertical: theme.spacing.xs,
    },
    dateArrow: {
      backgroundColor: theme.colors.surfaceVariant,
    },
    modalActions: {
      flexDirection: 'row',
      padding: theme.spacing.l,
      paddingTop: theme.spacing.m,
      gap: theme.spacing.m,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
    },
    modalButton: {
      flex: 1,
      borderRadius: theme.roundness * 2,
    },
    modalButtonPrimary: {
      elevation: 0,
    },
    modalButtonLabel: {
      fontSize: 14,
      fontWeight: '600',
      paddingVertical: 4,
    },
    listContent: {
      paddingBottom: theme.spacing.m,
    },
    shiftCard: {
      marginHorizontal: theme.spacing.m,
      marginVertical: theme.spacing.xs,
      backgroundColor: theme.colors.surface,
    },
    openShiftCard: {
      backgroundColor: theme.colors.primaryContainer,
    },
    shiftHeader: {
      marginBottom: theme.spacing.s,
    },
    shiftTitleRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
      marginBottom: 2,
    },
    shiftNumber: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
      flex: 1,
    },
    shiftDate: {
      fontSize: 13,
      color: theme.colors.onSurfaceVariant,
    },
    statusChip: {
      marginLeft: 'auto',
    },
    statusChipText: {
      fontWeight: '600',
      fontSize: 11,
    },
    divider: {
      marginVertical: theme.spacing.s,
    },
    shiftDetails: {
      gap: theme.spacing.s,
    },
    timeSection: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    label: {
      fontSize: 11,
      color: theme.colors.onSurfaceVariant,
      fontWeight: '500',
      textTransform: 'uppercase',
    },
    timeText: {
      fontSize: 14,
      color: theme.colors.onSurface,
    },
    durationText: {
      fontSize: 13,
      color: theme.colors.onSurfaceVariant,
    },
    statsSection: {
      flexDirection: 'row',
      gap: theme.spacing.s,
    },
    statCard: {
      flex: 1,
      padding: theme.spacing.s,
      borderRadius: theme.roundness,
      backgroundColor: theme.colors.surfaceVariant,
      alignItems: 'center',
      gap: 2,
    },
    statLabel: {
      fontSize: 10,
      color: theme.colors.onSurfaceVariant,
      textTransform: 'uppercase',
      letterSpacing: 0.3,
    },
    statValue: {
      fontSize: 15,
      fontWeight: '700',
      color: theme.colors.onSurface,
    },
    cashSection: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      padding: theme.spacing.s,
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: theme.roundness,
    },
    cashRow: {
      alignItems: 'center',
    },
    cashLabel: {
      fontSize: 11,
      color: theme.colors.onSurfaceVariant,
    },
    cashValue: {
      fontSize: 14,
      fontWeight: '600',
      color: theme.colors.onSurface,
      marginTop: 2,
    },
    differenceLabel: {
      fontWeight: '600',
    },
    differenceValue: {
      fontWeight: '700',
    },
    userSection: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      marginTop: theme.spacing.xs,
    },
    userText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
    },
    actionButtonsContainer: {
      flexDirection: 'row',
      marginTop: theme.spacing.s,
      gap: theme.spacing.s,
    },
    actionButton: {
      flex: 1,
      borderRadius: theme.roundness,
    },
    ordersButton: {
      // Estilo especfico para el botn de rdenes si es necesario
    },
    summaryButton: {
      // Estilo especfico para el botn de resumen si es necesario
    },
    actionButtonLabel: {
      fontSize: 12,
      fontWeight: '600',
    },
    actionButtonContent: {
      paddingHorizontal: theme.spacing.xs,
    },
    emptyContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.xl,
      gap: theme.spacing.l,
    },
    emptyTitle: {
      fontSize: 20,
      fontWeight: '600',
      color: theme.colors.onSurface,
      textAlign: 'center',
    },
    emptyMessage: {
      fontSize: 16,
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
    },
    errorContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.xl,
      gap: theme.spacing.l,
    },
    errorTitle: {
      fontSize: 20,
      fontWeight: '600',
      color: theme.colors.error,
      textAlign: 'center',
    },
    errorMessage: {
      fontSize: 16,
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
    },
    retryButton: {
      marginTop: theme.spacing.m,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      gap: theme.spacing.m,
    },
    loadingText: {
      fontSize: 16,
      color: theme.colors.onSurfaceVariant,
    },
    timeContainer: {
      flex: 1,
    },
  });

  // Renderizado principal
  if ((isLoading || isRefetching) && !shifts) {
    return (
      <SafeAreaView style={styles.container} edges={['bottom']}>
        {renderLoading()}
      </SafeAreaView>
    );
  }

  if (error && !shifts) {
    return (
      <SafeAreaView style={styles.container} edges={['bottom']}>
        {renderError()}
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView style={styles.container} edges={['bottom']}>
      <View style={styles.container}>
        {/* Filtros */}
        {renderFilters()}

        {/* Lista de turnos */}
        {filteredShifts.length === 0 ? (
          renderEmpty()
        ) : (
          <FlashList
            data={filteredShifts as Shift[]}
            renderItem={renderShiftItem}
            keyExtractor={(item) => item.id}
            estimatedItemSize={200}
            contentContainerStyle={styles.listContent}
            refreshControl={
              <RefreshControl
                refreshing={isRefreshing}
                onRefresh={handleRefresh}
                colors={[theme.colors.primary]}
              />
            }
          />
        )}

        {/* Modal de rdenes del turno */}
        {selectedShiftId && !showSalesSummaryView && (
          <ShiftOrdersModal
            visible={showOrdersModal}
            onClose={() => {
              setShowOrdersModal(false);
              setSelectedShiftId(null);
              setSelectedShiftNumber(undefined);
            }}
            shiftId={selectedShiftId}
          />
        )}

        {/* Vista de resumen de ventas */}
        {showSalesSummaryView && selectedShiftId && (
          <Modal
            visible={showSalesSummaryView}
            animationType="slide"
            presentationStyle="fullScreen"
          >
            <ShiftSalesSummaryView
              shiftId={selectedShiftId}
              shiftNumber={selectedShiftNumber}
              onBack={() => {
                setShowSalesSummaryView(false);
                setSelectedShiftId(null);
                setSelectedShiftNumber(undefined);
              }}
            />
          </Modal>
        )}
      </View>
    </SafeAreaView>
  );
}

================
File: app/src/modules/users/screens/UsersListScreen.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Portal, Chip, Text } from 'react-native-paper';
import { useDrawerStatus } from '@react-navigation/drawer';
import GenericList from '@/app/components/crud/GenericList';
import { UserFormModal } from '../components/UserFormModal';
import { UserDetailModal } from '../components/UserDetailModal';
import { useListState } from '@/app/hooks/useListState';
import { useCrudScreenLogic } from '@/app/hooks/useCrudScreenLogic';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useGetUsers, useDeleteUser } from '../hooks';
import type { User, UsersQuery } from '../schema/user.schema';
import { RoleEnum } from '../schema/user.schema';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';

export function UsersListScreen() {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const drawerStatus = useDrawerStatus();
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedFilter, setSelectedFilter] = useState('all');
  const [isRefreshing, setIsRefreshing] = useState(false);

  const deleteUserMutation = useDeleteUser();

  const {
    isFormModalVisible,
    isDetailModalVisible,
    selectedItem,
    editingItem,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
  } = useCrudScreenLogic<User>({
    entityName: 'Usuario',
    queryKey: ['users'],
    deleteMutationFn: async (id) => {
      await deleteUserMutation.mutateAsync(id);
    },
  });

  const queryParams: UsersQuery = {
    page: 1,
    limit: 100,
    search: searchQuery || undefined,
    filters:
      selectedFilter === 'all'
        ? undefined
        : selectedFilter === 'active'
          ? { isActive: true }
          : selectedFilter === 'inactive'
            ? { isActive: false }
            : selectedFilter === 'admin'
              ? { roles: [{ id: RoleEnum.ADMIN }] }
              : selectedFilter === 'user'
                ? { roles: [{ id: RoleEnum.WAITER }] }
                : undefined,
    sortBy: 'createdAt',
    sortOrder: 'DESC',
  };

  const { data, isLoading, error, refetch } = useGetUsers(queryParams);

  useRefreshModuleOnFocus('users');
  const getStatusColor = (user: User) => {
    return user.isActive ? 'success' : 'error';
  };

  const getStatusText = (user: User) => {
    return user.isActive ? 'Activo' : 'Inactivo';
  };

  const getUserDescription = (user: User) => {
    const parts = [];

    // Mostrar username primero
    parts.push(`@${user.username}`);

    // Luego el email en una nueva lnea si existe
    if (user.email) {
      parts.push(`\n${user.email}`);
    }

    // Si es usuario de cocina y tiene pantalla asignada, mostrarla
    if (user.role?.id === 5 && user.preparationScreen) {
      parts.push(`\nPantalla: ${user.preparationScreen.name}`);
    }

    return parts.join('');
  };

  const mappedUsers = React.useMemo(() => {
    const users = data?.data || [];

    return users.map((user) => {
      const displayName =
        `${user.firstName || ''} ${user.lastName || ''}`.trim() ||
        user.username;
      const displayInfo = getUserDescription(user);

      return {
        ...user,
        displayName,
        displayInfo,
        displayNameWithRole: { name: displayName, roleId: user.role?.id },
        statusText: getStatusText(user),
        statusColor: getStatusColor(user),
      };
    });
  }, [data]);

  const handleCreateUser = () => {
    handleOpenCreateModal();
  };

  const { ListEmptyComponent } = useListState({
    isLoading,
    isError: error ? true : false,
    data: mappedUsers,
    emptyConfig: {
      title: 'No hay usuarios',
      message: 'No hay usuarios registrados en el sistema',
      icon: 'account-multiple-outline',
      actionLabel: 'Agregar usuario',
      onAction: handleCreateUser,
    },
    errorConfig: {
      title: 'Error al cargar usuarios',
      message: 'No se pudieron cargar los usuarios. Verifica tu conexin.',
      icon: 'alert-circle-outline',
      onAction: refetch,
    },
  });

  const filterOptions = [
    { label: 'Todos', value: 'all' },
    { label: 'Activos', value: 'active' },
    { label: 'Inactivos', value: 'inactive' },
    { label: 'Administradores', value: 'admin' },
    { label: 'Usuarios', value: 'user' },
  ];

  const handleEditUser = (user: User) => {
    handleOpenEditModal(user);
  };

  const handleViewUser = (user: User) => {
    handleOpenDetailModal(user);
  };

  const handleRefresh = async () => {
    setIsRefreshing(true);
    await refetch();
    setIsRefreshing(false);
  };

  const getRoleChipProps = (roleId: number | undefined) => {
    switch (roleId) {
      case 1:
        return {
          label: 'Admin',
          icon: 'shield-account',
          color: theme.colors.error,
        };
      case 2:
        return {
          label: 'Gerente',
          icon: 'account-tie',
          color: theme.colors.primary,
        };
      case 3:
        return {
          label: 'Cajero',
          icon: 'cash-register',
          color: theme.colors.tertiary,
        };
      case 4:
        return {
          label: 'Mesero',
          icon: 'room-service',
          color: theme.colors.secondary,
        };
      case 5:
        return { label: 'Cocina', icon: 'chef-hat', color: '#FF6B6B' };
      case 6:
        return { label: 'Repartidor', icon: 'moped', color: '#4ECDC4' };
      default:
        return {
          label: 'Usuario',
          icon: 'account',
          color: theme.colors.onSurfaceVariant,
        };
    }
  };

  const renderDescription = (user: User) => {
    const roleProps = getRoleChipProps(user.role?.id);

    return (
      <View style={styles.descriptionContainer}>
        <View style={styles.userInfoRow}>
          <Text style={styles.username}>@{user.username}</Text>
          <Chip
            mode="flat"
            icon={roleProps.icon}
            style={[
              styles.roleChipInDescription,
              { backgroundColor: roleProps.color + '20' },
            ]}
            textStyle={[styles.roleChipText, { color: roleProps.color }]}
            compact
          >
            {roleProps.label}
          </Chip>
        </View>
        {user.email && (
          <Text style={styles.email} numberOfLines={1}>
            {user.email}
          </Text>
        )}
        {user.role?.id === 5 && user.preparationScreen && (
          <Text style={styles.screenInfo}>
            Pantalla: {user.preparationScreen.name}
          </Text>
        )}
      </View>
    );
  };

  const renderTitle = (user: User) => {
    const firstName = user.firstName || '';
    const lastName = user.lastName || '';
    const fullName = `${firstName} ${lastName}`.trim();
    const displayName = fullName || user.username;

    return (
      <View style={styles.titleContainer}>
        <Text style={styles.title} numberOfLines={1} ellipsizeMode="tail">
          {displayName}
        </Text>
      </View>
    );
  };

  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    listContainer: {
      flex: 1,
    },
    titleContainer: {
      flex: 1,
      paddingRight: responsive.isTablet ? theme.spacing.xs : theme.spacing.s,
    },
    title: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: responsive.isTablet ? 14 : 16,
      lineHeight: responsive.isTablet ? 18 : 22,
    },
    descriptionContainer: {
      flex: 1,
      gap: responsive.isTablet ? 2 : theme.spacing.xs / 2,
      paddingTop: responsive.isTablet ? 2 : theme.spacing.xs / 2,
    },
    userInfoRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.isTablet ? theme.spacing.xs : theme.spacing.s,
      flexWrap: 'wrap',
    },
    username: {
      fontSize: responsive.isTablet ? 12 : 14,
      color: theme.colors.onSurfaceVariant,
      fontWeight: '500',
    },
    email: {
      fontSize: responsive.isTablet ? 11 : 13,
      color: theme.colors.onSurfaceVariant,
      opacity: 0.8,
    },
    screenInfo: {
      fontSize: responsive.isTablet ? 11 : 13,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
    },
    roleChipInDescription: {
      minHeight: responsive.isTablet ? 20 : 28,
      height: 'auto',
      borderRadius: theme.roundness * 2,
      paddingHorizontal: responsive.isTablet ? 6 : theme.spacing.s,
      paddingVertical: responsive.isTablet ? 1 : 4,
    },
    roleChipText: {
      fontSize: responsive.isTablet ? 10 : 12,
      fontWeight: '600',
      lineHeight: responsive.isTablet ? 12 : 16,
      marginVertical: 0,
      paddingVertical: 0,
    },
    tabletListItem: {
      marginVertical: 1,
    },
    tabletListItemContent: {
      paddingVertical: 2,
      minHeight: 36,
    },
    tabletContentContainer: {
      paddingTop: 2,
      paddingBottom: 80,
    },
  });

  return (
    <SafeAreaView style={styles.container} edges={['bottom']}>
      <View style={styles.container}>
        <GenericList
          items={mappedUsers}
          isLoading={isLoading}
          isRefreshing={isRefreshing}
          onRefresh={handleRefresh}
          onItemPress={handleViewUser}
          ListEmptyComponent={ListEmptyComponent}
          listItemStyle={
            responsive.isTablet
              ? [styles.tabletListItem, { marginHorizontal: theme.spacing.xs }]
              : undefined
          }
          listItemContentStyle={
            responsive.isTablet ? styles.tabletListItemContent : undefined
          }
          contentContainerStyle={
            responsive.isTablet ? styles.tabletContentContainer : undefined
          }
          renderConfig={{
            titleField: 'displayName' as keyof User,
            descriptionField: 'displayInfo' as keyof User,
            statusConfig: {
              field: 'isActive' as keyof User,
              activeValue: true,
              activeLabel: 'Activo',
              inactiveLabel: 'Inactivo',
            },
            renderTitle: renderTitle,
            renderDescription: renderDescription,
          }}
          enableSearch={true}
          searchQuery={searchQuery}
          onSearchChange={setSearchQuery}
          searchPlaceholder="Buscar por nombre, email o usuario..."
          filterOptions={filterOptions}
          filterValue={selectedFilter}
          onFilterChange={(value) => setSelectedFilter(value as string)}
          showFab={true}
          onFabPress={handleCreateUser}
          fabIcon="account-plus"
          fabLabel="Nuevo Usuario"
          fabVisible={drawerStatus === 'closed'}
          showImagePlaceholder={false}
          isDrawerOpen={drawerStatus === 'open'}
        />
      </View>

      <Portal>
        {isFormModalVisible && (
          <UserFormModal
            visible={isFormModalVisible}
            onDismiss={handleCloseModals}
            user={editingItem}
          />
        )}

        {isDetailModalVisible && selectedItem && (
          <UserDetailModal
            visible={isDetailModalVisible}
            onDismiss={handleCloseModals}
            user={selectedItem}
            onEdit={handleEditUser}
          />
        )}
      </Portal>
    </SafeAreaView>
  );
}

================
File: app/App.tsx
================
import {} from 'react';
import { ActivityIndicator, View, StyleSheet } from 'react-native';
import { Provider as PaperProvider } from 'react-native-paper';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import {
  useThemeStore,
  useSystemThemeDetector,
} from './src/app/store/themeStore';
import { AppNavigator } from './src/app/navigation/AppNavigator';
import GlobalSnackbar from './src/app/components/common/GlobalSnackbar';
import { useInitializeAuth } from './src/app/hooks/useInitializeAuth';
import { useServerConnection } from './src/app/hooks/useServerConnection';
import { es, registerTranslation } from 'react-native-paper-dates';

registerTranslation('es', es);

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000,
      gcTime: 10 * 60 * 1000,
      refetchOnMount: false,
      refetchOnWindowFocus: false,
      refetchOnReconnect: 'always',
      retry: 0,
      refetchInterval: false,
    },
    mutations: {
      retry: 0,
    },
  },
});

function AppContent() {
  const isInitializingAuth = useInitializeAuth();
  useServerConnection();
  const activeTheme = useThemeStore((state) => state.activeTheme);

  if (isInitializingAuth) {
    return (
      <View
        style={[
          styles.loadingContainer,
          { backgroundColor: activeTheme.colors.background },
        ]}
      >
        <ActivityIndicator size="large" color={activeTheme.colors.primary} />
      </View>
    );
  }

  return (
    <>
      <AppNavigator />
      <GlobalSnackbar />
    </>
  );
}

export default function App() {
  useSystemThemeDetector();
  const activeTheme = useThemeStore((state) => state.activeTheme);

  return (
    <GestureHandlerRootView style={styles.rootContainer}>
      <SafeAreaProvider>
        <QueryClientProvider client={queryClient}>
          <PaperProvider theme={activeTheme}>
            <AppContent />
          </PaperProvider>
        </QueryClientProvider>
      </SafeAreaProvider>
    </GestureHandlerRootView>
  );
}

const styles = StyleSheet.create({
  rootContainer: {
    flex: 1,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

================
File: app/src/app/navigation/KitchenWebNavigator.tsx
================
import { useState } from 'react';
import {
  View,
  StyleSheet,
  StatusBar,
} from 'react-native';
import { WebDrawer } from './components/WebDrawer';
import { WebDrawerContent } from './components/WebDrawerContent';
import KitchenOrdersScreen from '../../modules/kitchen/screens/KitchenOrdersScreen';
import { useAppTheme } from '../styles/theme';
import { useResponsive } from '../hooks/useResponsive';
import { KitchenProvider } from '../../modules/kitchen/context/KitchenContext';
import { useKitchenHeader } from './components/KitchenHeader';

export function KitchenWebNavigator() {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const [drawerOpen, setDrawerOpen] = useState(false);

  const kitchenHeader = useKitchenHeader({
    onMenuPress: () => setDrawerOpen(true),
  });

  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    header: {
      backgroundColor: theme.colors.primary,
      height: responsive.isWeb ? 80 : responsive.dimensions.headerHeight,
      flexDirection: 'row',
      alignItems: 'center',
      paddingHorizontal: responsive.spacingPreset.m,
      elevation: 2,
    },
    headerContent: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
    },
    content: {
      flex: 1,
    },
  });

  return (
    <KitchenProvider>
      <View style={styles.container}>
        <StatusBar
          backgroundColor={theme.colors.primary}
          barStyle={theme.dark ? 'light-content' : 'dark-content'}
        />

        <WebDrawer
          open={drawerOpen}
          onClose={() => setDrawerOpen(false)}
          drawerWidth={
            responsive.isWeb ? 320 : responsive.dimensions.drawerWidth
          }
          drawerContent={
            <WebDrawerContent onClose={() => setDrawerOpen(false)} />
          }
        >
          <View style={styles.container}>
            {/* Header */}
            <View style={styles.header}>
              <kitchenHeader.MenuButton />

              <View style={styles.headerContent}>
                <kitchenHeader.Title />
                <kitchenHeader.RightActions />
              </View>
            </View>

            {/* Content */}
            <View style={styles.content}>
              <KitchenOrdersScreen />
            </View>
          </View>
        </WebDrawer>
      </View>
    </KitchenProvider>
  );
}

================
File: app/src/app/navigation/types.ts
================
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import type { DrawerScreenProps as NavigationDrawerScreenProps } from '@react-navigation/drawer';
import type { NavigatorScreenParams } from '@react-navigation/native';
import type { MenuStackParamList } from '../../modules/menu/navigation/types';
import type { PreparationScreensStackParamList } from '../../modules/preparationScreens/navigation/types';
import type { AreasTablesStackParamList } from '../../modules/areasTables/navigation/types';
import type { PrintersStackParamList } from '../../modules/printers/navigation/types'; // Importar tipos de impresoras
import type { ReceiptsStackParamList } from '../../modules/receipts/navigation/types'; // Importar tipos de recibos
import type { OrderFinalizationStackParamList } from '../../modules/orderFinalization/navigation/types';
import type { RestaurantConfigStackParamList } from '../../modules/restaurantConfig/navigation/types';
import type { CustomersStackParamList } from '../../modules/customers/navigation/CustomersStackNavigator';
import type { PizzaCustomizationsStackParamList } from '../../modules/pizzaCustomizations/navigation/types';
import type { SyncStackParamList } from '../../modules/sync/navigation/SyncStackNavigator';
import type { ShiftAuditStackParamList } from '../../modules/shiftAudit/navigation/types';
import type { SettingsStackParamList } from '../../modules/settings/navigation/types';

export type AuthStackParamList = {
  Login: undefined;
};

export type OrdersStackParamList = {
  Orders: undefined; // Pantalla principal del mdulo de rdenes
  CreateOrder: undefined; // Pantalla para crear una nueva orden
  OpenOrders: undefined; // Pantalla para ver rdenes abiertas
  AddProductsToOrder: {
    orderId: string; // ID de la orden a la que se estn agregando productos
    orderNumber: number; // Nmero de la orden
    existingOrderItemsCount?: number; // Nmero de items que ya estn en la orden
    existingTempProducts?: import('../../modules/orders/stores/useOrderStore').CartItem[]; // Productos temporales existentes
    onProductsAdded?: (
      products: import('../../modules/orders/stores/useOrderStore').CartItem[],
    ) => void; // Callback cuando se aaden productos
  }; // Pantalla para aadir productos a una orden existente
};

export type OrdersStackScreenProps<T extends keyof OrdersStackParamList> =
  NativeStackScreenProps<OrdersStackParamList, T>;

export type AuthStackScreenProps<T extends keyof AuthStackParamList> =
  NativeStackScreenProps<AuthStackParamList, T>;

export type ModifiersStackParamList = {
  ModifierGroupsScreen: undefined;
  ModifiersScreen: { groupId: string; groupName: string };
};

export type ModifiersStackScreenProps<T extends keyof ModifiersStackParamList> =
  NativeStackScreenProps<ModifiersStackParamList, T>;

export type AppDrawerParamList = {
  Welcome: undefined; // Mantener si existe una pantalla de bienvenida
  MenuStack: NavigatorScreenParams<MenuStackParamList>; // Renombrado
  ModifiersStack: NavigatorScreenParams<ModifiersStackParamList>; // Renombrado
  PreparationScreensStack: NavigatorScreenParams<PreparationScreensStackParamList>; // Renombrado para consistencia
  AreasTablesStack: NavigatorScreenParams<AreasTablesStackParamList>; // Aadir el nuevo stack al Drawer
  OrdersStack: NavigatorScreenParams<OrdersStackParamList>; // Aadir el stack de rdenes al Drawer
  PrintersStack: NavigatorScreenParams<PrintersStackParamList>; // Aadir el stack de impresoras DENTRO del bloque
  ReceiptsStack: NavigatorScreenParams<ReceiptsStackParamList>; // Aadir el stack de recibos
  AvailabilityScreen: undefined; // Pantalla directa de disponibilidad
  OrderFinalizationStack: NavigatorScreenParams<OrderFinalizationStackParamList>; // Stack de finalizacin de rdenes
  RestaurantConfigStack: NavigatorScreenParams<RestaurantConfigStackParamList>; // Stack de configuracin del restaurante
  PizzaCustomizationsStack: NavigatorScreenParams<PizzaCustomizationsStackParamList>; // Stack de personalizacin de pizzas
  CustomersStack: NavigatorScreenParams<CustomersStackParamList>; // Stack de clientes
  SyncStack: NavigatorScreenParams<SyncStackParamList>; // Stack de sincronizacin
  UsersScreen: undefined; // Pantalla directa de usuarios
  KitchenScreen: undefined; // Pantalla directa de cocina
  ShiftAuditStack: NavigatorScreenParams<ShiftAuditStackParamList>; // Stack de auditora de turnos
  SettingsStack: NavigatorScreenParams<SettingsStackParamList>; // Stack de configuracin
  ServerSettings: undefined; // Pantalla directa de configuracin del servidor
};

export type DrawerScreenProps<T extends keyof AppDrawerParamList> =
  NavigationDrawerScreenProps<AppDrawerParamList, T>;

export type DrawerNavigatorParamList = AppDrawerParamList;

declare global {
  namespace ReactNavigation {
    interface RootParamList
      extends AuthStackParamList,
        AppDrawerParamList,
        ModifiersStackParamList,
        PreparationScreensStackParamList,
        AreasTablesStackParamList,
        OrdersStackParamList,
        PrintersStackParamList,
        ReceiptsStackParamList,
        OrderFinalizationStackParamList,
        RestaurantConfigStackParamList,
        PizzaCustomizationsStackParamList,
        CustomersStackParamList,
        SyncStackParamList,
        ShiftAuditStackParamList,
        SettingsStackParamList {}
  }
}

================
File: app/src/app/store/authStore.ts
================
import { create } from 'zustand';
import EncryptedStorage from '@/app/services/secureStorageService';
import type { User } from '../schemas/domain/user.schema';
import * as ScreenOrientation from 'expo-screen-orientation';

const AUTH_TOKEN_KEY = 'auth_token';
const REFRESH_TOKEN_KEY = 'refresh_token';
const USER_INFO_KEY = 'user_info';

export interface AuthState {
  isAuthenticated: boolean;
  accessToken: string | null;
  refreshToken: string | null;
  user: User | null;
  setTokens: (
    accessToken: string,
    refreshToken: string,
    user: User | null,
  ) => Promise<void>;
  setAccessToken: (accessToken: string) => Promise<void>;
  setRefreshToken: (refreshToken: string) => Promise<void>;
  setUser: (user: User | null) => Promise<void>;
  logout: () => Promise<void>;
}

export const useAuthStore = create<AuthState>((set) => ({
  isAuthenticated: false,
  accessToken: null,
  refreshToken: null,
  user: null,

  setTokens: async (
    accessToken: string,
    refreshToken: string,
    user: User | null,
  ) => {
    // Verificar si el usuario est activo antes de guardar los tokens
    if (user && 'isActive' in user && !user.isActive) {
      throw new Error('Usuario inactivo');
    }

    await EncryptedStorage.setItem(AUTH_TOKEN_KEY, accessToken);
    await EncryptedStorage.setItem(REFRESH_TOKEN_KEY, refreshToken);
    if (user) {
      await EncryptedStorage.setItem(USER_INFO_KEY, JSON.stringify(user));
    } else {
      await EncryptedStorage.removeItem(USER_INFO_KEY);
    }
    set({
      accessToken,
      refreshToken,
      user: user ?? null,
      isAuthenticated: true,
    });
  },

  setAccessToken: async (accessToken: string) => {
    try {
      await EncryptedStorage.setItem(AUTH_TOKEN_KEY, accessToken);
      set({ accessToken, isAuthenticated: true });
    } catch (error) {
      // Error al guardar access token
    }
  },

  setRefreshToken: async (refreshToken: string) => {
    try {
      await EncryptedStorage.setItem(REFRESH_TOKEN_KEY, refreshToken);
      set({ refreshToken });
    } catch (error) {
      // Error al guardar refresh token
    }
  },

  setUser: async (user: User | null) => {
    try {
      if (user) {
        // Si el usuario se actualiza y est inactivo, cerrar sesin
        if ('isActive' in user && !user.isActive) {
          await useAuthStore.getState().logout();
          return;
        }
        await EncryptedStorage.setItem(USER_INFO_KEY, JSON.stringify(user));
      } else {
        await EncryptedStorage.removeItem(USER_INFO_KEY);
      }
      set({ user });
    } catch (error) {
      // Error al guardar informacin del usuario
    }
  },

  logout: async () => {
    const ORIENTATION_DELAYS = {
      UNLOCK: 100,
      LOCK: 200,
    };

    const clearAuthData = async () => {
      await EncryptedStorage.removeItem(AUTH_TOKEN_KEY);
      await EncryptedStorage.removeItem(REFRESH_TOKEN_KEY);
      await EncryptedStorage.removeItem(USER_INFO_KEY);
      set({
        accessToken: null,
        refreshToken: null,
        user: null,
        isAuthenticated: false,
      });
    };

    try {
      await ScreenOrientation.unlockAsync();
      await new Promise((resolve) =>
        setTimeout(resolve, ORIENTATION_DELAYS.UNLOCK),
      );
      await ScreenOrientation.lockAsync(
        ScreenOrientation.OrientationLock.PORTRAIT_UP,
      );
      await new Promise((resolve) =>
        setTimeout(resolve, ORIENTATION_DELAYS.LOCK),
      );
      await clearAuthData();
    } catch (error) {
      try {
        await clearAuthData();
      } catch (fallbackError) {
        // Silently handle critical error
      }
    }
  },
}));

export const initializeAuthStore = async () => {
  try {
    const accessToken = await EncryptedStorage.getItem(AUTH_TOKEN_KEY);
    const refreshToken = await EncryptedStorage.getItem(REFRESH_TOKEN_KEY);
    const userInfoString = await EncryptedStorage.getItem(USER_INFO_KEY);
    let user: User | null = null;
    if (userInfoString) {
      try {
        user = JSON.parse(userInfoString);
      } catch (parseError) {
        await EncryptedStorage.removeItem(USER_INFO_KEY);
      }
    }

    if (accessToken && refreshToken) {
      // Verificar si el usuario est activo antes de restaurar la sesin
      if (user && 'isActive' in user && !user.isActive) {
        await EncryptedStorage.removeItem(AUTH_TOKEN_KEY);
        await EncryptedStorage.removeItem(REFRESH_TOKEN_KEY);
        await EncryptedStorage.removeItem(USER_INFO_KEY);
        useAuthStore.setState({
          accessToken: null,
          refreshToken: null,
          user: null,
          isAuthenticated: false,
        });
        return;
      }

      // Primero establecemos el token en el estado para que el apiClient pueda usarlo
      useAuthStore.setState({
        accessToken,
        refreshToken,
        user,
        isAuthenticated: true,
      });

      // La verificacin del token se har de manera lazy cuando sea necesario
      // Esto evita el ciclo de dependencias con authService
    } else {
      useAuthStore.setState({
        accessToken: null,
        refreshToken: null,
        user: null,
        isAuthenticated: false,
      });
    }
  } catch (error) {
    useAuthStore.setState({
      accessToken: null,
      refreshToken: null,
      user: null,
      isAuthenticated: false,
    });
  }
};

================
File: app/src/modules/modifiers/services/modifierService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import {
  Modifier,
  CreateModifierInput,
  UpdateModifierInput,
  modifierApiSchema,
} from '../schema/modifier.schema';
import { z } from 'zod';
import { PaginatedResponse } from '@/app/types/api.types';

const modifiersListSchema = z.array(modifierApiSchema);

const paginatedModifiersSchema = z.object({
  items: z.array(modifierApiSchema),
  total: z.number(),
  page: z.number(),
  limit: z.number(),
  hasNextPage: z.boolean(),
  hasPrevPage: z.boolean(),
});

interface FindAllModifiersParams {
  page?: number;
  limit?: number;
  groupId?: string;
}

export const modifierService = {
  async findAll(
    params?: FindAllModifiersParams,
  ): Promise<PaginatedResponse<Modifier>> {
    const queryParams = {
      page: params?.page ?? 1,
      limit: params?.limit ?? 10,
      ...params,
    };
    const response = await apiClient.get<unknown>(API_PATHS.MODIFIERS, {
      params: queryParams,
    });

    const paginatedResult = paginatedModifiersSchema.safeParse(response.data);
    if (paginatedResult.success) {
      return {
        data: paginatedResult.data.items,
        total: paginatedResult.data.total,
        page: paginatedResult.data.page,
        limit: paginatedResult.data.limit,
        totalPages: Math.ceil(
          paginatedResult.data.total / paginatedResult.data.limit,
        ),
      };
    }

    throw new Error('Received invalid data format for modifiers.');
  },

  async findOne(id: string): Promise<Modifier> {
    const response = await apiClient.get<unknown>(
      API_PATHS.MODIFIERS_BY_ID.replace(':id', id),
    );

    const validationResult = modifierApiSchema.safeParse(response.data);
    if (!validationResult.success) {
      throw new Error(`Received invalid data format for modifier ${id}.`);
    }
    return validationResult.data;
  },

  async findByGroupId(
    modifierGroupId: string,
    params: { isActive?: boolean; search?: string } = {},
  ): Promise<Modifier[]> {
    const queryParams = {
      ...(params.isActive !== undefined && { isActive: params.isActive }),
      ...(params.search && { search: params.search }),
    };
    const response = await apiClient.get<unknown>(
      API_PATHS.MODIFIERS_BY_GROUP.replace(':modifierGroupId', modifierGroupId),
      { params: queryParams },
    );

    const validationResult = modifiersListSchema.safeParse(response.data);
    if (!validationResult.success) {
      throw new Error(
        `Received invalid data format for modifiers of group ${modifierGroupId}.`,
      );
    }
    return validationResult.data;
  },

  async create(data: CreateModifierInput): Promise<Modifier> {
    const response = await apiClient.post<unknown>(API_PATHS.MODIFIERS, data);

    const validationResult = modifierApiSchema.safeParse(response.data);
    if (!validationResult.success) {
      throw new Error('Received invalid data format after creating modifier.');
    }
    return validationResult.data;
  },

  async update(id: string, data: UpdateModifierInput): Promise<Modifier> {
    const response = await apiClient.patch<unknown>(
      API_PATHS.MODIFIERS_BY_ID.replace(':id', id),
      data,
    );

    const validationResult = modifierApiSchema.safeParse(response.data);
    if (!validationResult.success) {
      throw new Error(
        `Received invalid data format after updating modifier ${id}.`,
      );
    }
    return validationResult.data;
  },

  async remove(id: string): Promise<void> {
    await apiClient.delete(API_PATHS.MODIFIERS_BY_ID.replace(':id', id));
  },
};

================
File: app/src/modules/orderFinalization/components/OrderDetailsModal.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';
import {
  Modal,
  Portal,
  Surface,
  Text,
  Divider,
  IconButton,
  Chip,
  ActivityIndicator,
} from 'react-native-paper';
import {
  OrderForFinalization,
  OrderItemForFinalization,
} from '../schema/orderFinalization.schema';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import {
  CustomizationTypeEnum,
  PizzaHalfEnum,
  CustomizationActionEnum,
} from '@/modules/pizzaCustomizations/schema/pizzaCustomization.schema';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';

interface OrderDetailsModalProps {
  visible: boolean;
  onDismiss: () => void;
  order: OrderForFinalization | null;
  isLoading?: boolean;
  onPrintPress: (order: OrderForFinalization) => void;
}

const formatPizzaCustomizations = (customizations: any[]): string => {
  if (!customizations || customizations.length === 0) return '';

  const groupedByHalf = customizations.reduce(
    (acc, curr) => {
      const half =
        curr.half === PizzaHalfEnum.HALF_1
          ? 'HALF_1'
          : curr.half === PizzaHalfEnum.HALF_2
            ? 'HALF_2'
            : 'FULL';

      if (!acc[half]) {
        acc[half] = {
          flavors: [],
          addedIngredients: [],
          removedIngredients: [],
        };
      }

      const name = curr.pizzaCustomization?.name || curr.pizzaCustomizationId;
      const type = curr.pizzaCustomization?.type;

      if (type === 'FLAVOR' || type === CustomizationTypeEnum.FLAVOR) {
        acc[half].flavors.push(name);
      } else if (
        type === 'INGREDIENT' ||
        type === CustomizationTypeEnum.INGREDIENT
      ) {
        if (curr.action === CustomizationActionEnum.ADD) {
          acc[half].addedIngredients.push(name);
        } else {
          acc[half].removedIngredients.push(name);
        }
      }

      return acc;
    },
    {} as Record<
      string,
      {
        flavors: string[];
        addedIngredients: string[];
        removedIngredients: string[];
      }
    >,
  );

  if (groupedByHalf.FULL) {
    const parts: string[] = [];
    if (groupedByHalf.FULL.flavors.length > 0) {
      parts.push(groupedByHalf.FULL.flavors.join(', '));
    }
    if (groupedByHalf.FULL.addedIngredients.length > 0) {
      parts.push(`con: ${groupedByHalf.FULL.addedIngredients.join(', ')}`);
    }
    if (groupedByHalf.FULL.removedIngredients.length > 0) {
      parts.push(`sin: ${groupedByHalf.FULL.removedIngredients.join(', ')}`);
    }
    return parts.join(' - ');
  } else if (groupedByHalf.HALF_1 || groupedByHalf.HALF_2) {
    const formatHalf = (halfData: {
      flavors: string[];
      addedIngredients: string[];
      removedIngredients: string[];
    }) => {
      const parts: string[] = [];
      if (halfData.flavors.length > 0) {
        parts.push(halfData.flavors.join(', '));
      }
      if (halfData.addedIngredients.length > 0) {
        parts.push(`con: ${halfData.addedIngredients.join(', ')}`);
      }
      if (halfData.removedIngredients.length > 0) {
        parts.push(`sin: ${halfData.removedIngredients.join(', ')}`);
      }
      return parts.join(' - ');
    };

    const half1 = groupedByHalf.HALF_1 ? formatHalf(groupedByHalf.HALF_1) : '';
    const half2 = groupedByHalf.HALF_2 ? formatHalf(groupedByHalf.HALF_2) : '';

    return half1 && half2 ? `(${half1} / ${half2})` : half1 || half2;
  }

  return '';
};

export const OrderDetailsModal: React.FC<OrderDetailsModalProps> = ({
  visible,
  onDismiss,
  order,
  isLoading = false,
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const [showPrintHistory, setShowPrintHistory] = useState(false);

  if (!order && !isLoading) return null;

  const getOrderTypeLabel = (type: string) => {
    switch (type) {
      case 'DINE_IN':
        return ' Local';
      case 'TAKE_AWAY':
        return ' Llevar';
      case 'DELIVERY':
        return ' Envo';
      default:
        return type;
    }
  };

  const getOrderStatusLabel = (status: string) => {
    switch (status) {
      case 'PENDING':
        return 'Pendiente';
      case 'IN_PROGRESS':
        return 'En preparacin';
      case 'READY':
        return 'Listo';
      case 'DELIVERED':
        return 'Entregado';
      default:
        return status;
    }
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'PENDING':
        return '#FFA726';
      case 'IN_PROGRESS':
        return theme.colors.primary;
      case 'READY':
        return '#66BB6A';
      case 'DELIVERED':
        return '#9C27B0'; // Purple - better contrast
      default:
        return theme.colors.onSurfaceVariant;
    }
  };

  const getPaymentStatus = () => {
    if (order?.payments && order.payments.length > 0) {
      const totalPaid = order.payments.reduce((sum, p) => sum + p.amount, 0);
      const totalAmount =
        typeof order.total === 'string' ? parseFloat(order.total) : order.total;

      if (totalPaid >= totalAmount) {
        return { label: 'Pagado', color: '#10B981' };
      } else if (totalPaid > 0) {
        return { label: 'Parcial', color: '#F59E0B' };
      }
    }
    return { label: 'Pendiente', color: '#EF4444' };
  };

  const paymentStatus = order
    ? getPaymentStatus()
    : { label: 'Pendiente', color: '#EF4444' };

  const renderItem = (item: OrderItemForFinalization) => {
    const unitPrice = parseFloat(item.finalPrice);
    const totalPrice = unitPrice * item.quantity;
    const preparationStatusColors = {
      PENDING: '#FFA726',
      IN_PROGRESS: '#42A5F5',
      READY: '#66BB6A',
      DELIVERED: '#26A69A',
      CANCELLED: '#EF5350',
    };
    const statusColor =
      preparationStatusColors[
        item.preparationStatus as keyof typeof preparationStatusColors
      ] || theme.colors.onSurfaceVariant;

    return (
      <Surface
        key={`${item.product.id}-${item.productVariant?.id || ''}-${item.preparationStatus || ''}`}
        style={[styles.itemCard, styles.itemCardWithMargin]}
        elevation={1}
      >
        <View style={styles.itemContent}>
          <View style={styles.itemHeader}>
            <View style={styles.nameContainer}>
              <Text
                style={[styles.itemQuantity, { color: theme.colors.primary }]}
              >
                {item.quantity}x
              </Text>
              <Text
                style={[styles.itemName, { color: theme.colors.onSurface }]}
                numberOfLines={1}
              >
                {item.productVariant?.name || item.product.name}
              </Text>
            </View>
            {item.preparationStatus && (
              <View
                style={[styles.statusChip, { backgroundColor: statusColor }]}
              >
                <Text style={styles.statusChipText}>
                  {item.preparationStatus === 'PENDING' && 'Pendiente'}
                  {item.preparationStatus === 'IN_PROGRESS' && 'Preparando'}
                  {item.preparationStatus === 'READY' && 'Listo'}
                  {item.preparationStatus === 'DELIVERED' && 'Entregado'}
                  {item.preparationStatus === 'CANCELLED' && 'Cancelado'}
                </Text>
              </View>
            )}
          </View>

          <View style={styles.itemDetailsContainer}>
            {item.selectedPizzaCustomizations &&
              item.selectedPizzaCustomizations.length > 0 && (
                <View style={styles.customizationContainer}>
                  <Text
                    style={[
                      styles.pizzaCustomizationText,
                      { color: theme.colors.onSurfaceVariant },
                    ]}
                  >
                    {formatPizzaCustomizations(
                      item.selectedPizzaCustomizations,
                    )}
                  </Text>
                </View>
              )}

            {item.modifiers && item.modifiers.length > 0 && (
              <View style={styles.modifiersContainer}>
                {item.modifiers.map((modifier) => (
                  <View key={modifier.id} style={styles.modifierRow}>
                    <Text
                      style={[
                        styles.modifierText,
                        { color: theme.colors.onSurfaceVariant },
                      ]}
                    >
                       {modifier.name}
                    </Text>
                    {modifier.price && Number(modifier.price) > 0 && (
                      <Text
                        style={[
                          styles.modifierPrice,
                          { color: theme.colors.tertiary },
                        ]}
                      >
                        +${Number(modifier.price).toFixed(2)}
                      </Text>
                    )}
                  </View>
                ))}
              </View>
            )}

            {item.preparationNotes && (
              <View style={styles.notesContainer}>
                <Text
                  style={[
                    styles.notesText,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                   {item.preparationNotes}
                </Text>
              </View>
            )}
          </View>

          <View style={styles.priceContainer}>
            <View style={styles.priceRow}>
              <Text
                style={[
                  styles.priceLabel,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                P. unitario:
              </Text>
              <Text
                style={[styles.priceValue, { color: theme.colors.onSurface }]}
              >
                ${unitPrice.toFixed(2)}
              </Text>
            </View>
            {item.quantity > 1 && (
              <View style={styles.priceRow}>
                <Text
                  style={[
                    styles.priceLabel,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                  Total {item.quantity}:
                </Text>
                <Text
                  style={[styles.totalPrice, { color: theme.colors.primary }]}
                >
                  ${totalPrice.toFixed(2)}
                </Text>
              </View>
            )}
          </View>
        </View>
      </Surface>
    );
  };

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={[
          styles.modalContent,
          { backgroundColor: theme.colors.background },
        ]}
      >
        {isLoading || !order ? (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
            <Text
              style={[
                styles.loadingText,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Cargando detalles de la orden...
            </Text>
          </View>
        ) : (
          <>
            <View style={styles.header}>
              <View style={styles.headerInfo}>
                <View style={styles.headerTopRow}>
                  <View style={styles.headerLeft}>
                    <Text
                      style={[styles.title, { color: theme.colors.onSurface }]}
                    >
                      Orden #{order?.shiftOrderNumber || ''}
                    </Text>
                    <Text
                      style={[
                        styles.headerSeparator,
                        { color: theme.colors.onSurfaceVariant },
                      ]}
                    >
                      
                    </Text>
                    <Text
                      style={[
                        styles.orderType,
                        { color: theme.colors.primary },
                      ]}
                    >
                      {order ? getOrderTypeLabel(order.orderType) : ''}
                    </Text>
                    <Text
                      style={[
                        styles.headerSeparator,
                        { color: theme.colors.onSurfaceVariant },
                      ]}
                    >
                      
                    </Text>
                    <Text
                      style={[
                        styles.headerDate,
                        { color: theme.colors.onSurfaceVariant },
                      ]}
                    >
                      {order?.createdAt
                        ? format(new Date(order.createdAt), 'dd/MM HH:mm', {
                            locale: es,
                          })
                        : ''}
                    </Text>
                  </View>
                  <View style={styles.headerActions}>
                    <IconButton
                      icon="close"
                      size={24}
                      onPress={onDismiss}
                      style={styles.closeButton}
                    />
                  </View>
                </View>
                <View style={styles.headerBottomRow}>
                  <View style={styles.chipsRow}>
                    <View
                      style={[
                        styles.headerStatusChip,
                        {
                          backgroundColor: order
                            ? getStatusColor(order.orderStatus)
                            : theme.colors.surfaceVariant,
                        },
                      ]}
                    >
                      <Text style={styles.headerStatusChipText}>
                        {order ? getOrderStatusLabel(order.orderStatus) : ''}
                      </Text>
                    </View>
                    {order?.preparationScreens &&
                      order.preparationScreens.map((screen, index) => (
                        <Chip
                          key={index}
                          mode="outlined"
                          compact
                          style={styles.screenChip}
                          textStyle={styles.screenChipText}
                        >
                           {screen}
                        </Chip>
                      ))}
                  </View>
                </View>
              </View>
            </View>

            <ScrollView
              style={styles.scrollView}
              showsVerticalScrollIndicator={false}
              contentContainerStyle={styles.scrollContent}
            >
              <View style={styles.infoSection}>
                {order?.deliveryInfo?.recipientName && (
                  <View style={styles.infoRow}>
                    <Text
                      style={[
                        styles.contactText,
                        { color: theme.colors.onSurface },
                      ]}
                    >
                       Nombre del Cliente: {order.deliveryInfo.recipientName}
                    </Text>
                  </View>
                )}

                {order?.deliveryInfo?.recipientPhone && (
                  <View style={styles.infoRow}>
                    <Text
                      style={[
                        styles.contactText,
                        { color: theme.colors.onSurface },
                      ]}
                    >
                       Telfono: {order.deliveryInfo.recipientPhone}
                    </Text>
                  </View>
                )}

                {order?.orderType === 'DELIVERY' &&
                  order?.deliveryInfo?.fullAddress && (
                    <View style={styles.infoRow}>
                      <Text
                        style={[
                          styles.addressText,
                          { color: theme.colors.onSurfaceVariant },
                        ]}
                      >
                         Direccin de Entrega:{' '}
                        {order.deliveryInfo.fullAddress}
                      </Text>
                    </View>
                  )}

                {order?.orderType === 'DINE_IN' && order?.table && (
                  <View style={styles.infoRow}>
                    <Text
                      style={[
                        styles.tableText,
                        { color: theme.colors.onSurface },
                      ]}
                    >
                       Mesa: {order.table.area?.name || 'Sin rea'} -{' '}
                      {order.table.number}
                    </Text>
                  </View>
                )}

                {order?.scheduledAt && (
                  <View style={styles.infoRow}>
                    <Text
                      style={[styles.contactText, styles.scheduledTimeText]}
                    >
                       Hora de Entrega Programada:{' '}
                      {format(new Date(order.scheduledAt), 'HH:mm', {
                        locale: es,
                      })}
                    </Text>
                  </View>
                )}
              </View>

              <Divider style={styles.divider} />

              <View style={styles.itemsList}>
                {order?.orderItems?.map((item) => renderItem(item)) || []}
              </View>

              <Divider style={styles.divider} />

              {order?.payments && order.payments.length > 0 && (
                <>
                  <View style={styles.paymentsSection}>
                    <View style={styles.paymentSummaryCompact}>
                      <View style={styles.summaryCompactRow}>
                        <Text
                          style={[
                            styles.summaryCompactLabel,
                            { color: theme.colors.onSurfaceVariant },
                          ]}
                        >
                          Total: $
                          {typeof order.total === 'string'
                            ? parseFloat(order.total).toFixed(2)
                            : order.total.toFixed(2)}
                        </Text>
                        <Text
                          style={[
                            styles.summaryCompactLabel,
                            styles.paidAmountText,
                          ]}
                        >
                          Pagado: $
                          {order.payments
                            .reduce((sum, p) => sum + p.amount, 0)
                            .toFixed(2)}
                        </Text>
                        {(() => {
                          const totalOrder =
                            typeof order.total === 'string'
                              ? parseFloat(order.total)
                              : order.total;
                          const totalPaid = order.payments.reduce(
                            (sum, p) => sum + p.amount,
                            0,
                          );
                          const remaining = totalOrder - totalPaid;
                          if (remaining > 0) {
                            return (
                              <Text
                                style={[
                                  styles.summaryCompactLabel,
                                  styles.remainingAmountText,
                                ]}
                              >
                                Resta: ${remaining.toFixed(2)}
                              </Text>
                            );
                          }
                          return null;
                        })()}
                      </View>
                    </View>

                    {order.payments.map((payment, index) => {
                      const getPaymentMethodLabel = (method: string) => {
                        switch (method) {
                          case 'CASH':
                            return 'Efectivo';
                          case 'CREDIT_CARD':
                            return 'Tarjeta de Crdito';
                          case 'DEBIT_CARD':
                            return 'Tarjeta de Dbito';
                          case 'TRANSFER':
                            return 'Transferencia';
                          case 'OTHER':
                            return 'Otro';
                          default:
                            return method;
                        }
                      };

                      const getPaymentStatusColor = (status: string) => {
                        switch (status) {
                          case 'COMPLETED':
                            return '#10B981';
                          case 'PENDING':
                            return '#F59E0B';
                          case 'FAILED':
                            return theme.colors.error;
                          case 'REFUNDED':
                            return '#6B7280';
                          case 'CANCELLED':
                            return theme.colors.error;
                          default:
                            return theme.colors.onSurfaceVariant;
                        }
                      };

                      const getPaymentStatusLabel = (status: string) => {
                        switch (status) {
                          case 'COMPLETED':
                            return 'Completado';
                          case 'PENDING':
                            return 'Pendiente';
                          case 'FAILED':
                            return 'Fallido';
                          case 'REFUNDED':
                            return 'Reembolsado';
                          case 'CANCELLED':
                            return 'Cancelado';
                          default:
                            return status;
                        }
                      };

                      return (
                        <View
                          key={payment.id || index}
                          style={styles.paymentRowCompact}
                        >
                          <Text
                            style={[
                              styles.paymentMethodCompact,
                              { color: theme.colors.onSurface },
                            ]}
                          >
                             {getPaymentMethodLabel(payment.paymentMethod)}
                          </Text>
                          <Text
                            style={[
                              styles.paymentDateCompact,
                              { color: theme.colors.onSurfaceVariant },
                            ]}
                          >
                            {format(new Date(payment.createdAt), 'HH:mm', {
                              locale: es,
                            })}
                          </Text>
                          <View
                            style={[
                              styles.paymentStatusBadgeCompact,
                              {
                                backgroundColor:
                                  getPaymentStatusColor(payment.paymentStatus) +
                                  '20',
                              },
                            ]}
                          >
                            <Text
                              style={[
                                styles.paymentStatusTextCompact,
                                {
                                  color: getPaymentStatusColor(
                                    payment.paymentStatus,
                                  ),
                                },
                              ]}
                            >
                              {getPaymentStatusLabel(payment.paymentStatus)}
                            </Text>
                          </View>
                          <Text
                            style={[
                              styles.paymentAmountCompact,
                              { color: theme.colors.primary },
                            ]}
                          >
                            ${payment.amount.toFixed(2)}
                          </Text>
                        </View>
                      );
                    })}
                  </View>
                  <Divider style={styles.divider} />
                </>
              )}

              {order?.ticketImpressions &&
                order.ticketImpressions.length > 0 && (
                  <>
                    <View style={styles.ticketImpressionsSection}>
                      <TouchableOpacity
                        style={styles.collapsibleHeader}
                        onPress={() => setShowPrintHistory(!showPrintHistory)}
                        activeOpacity={0.7}
                      >
                        <Text
                          style={[
                            styles.sectionTitle,
                            { color: theme.colors.primary },
                          ]}
                        >
                           Historial de Impresiones (
                          {order.ticketImpressions.length})
                        </Text>
                        <IconButton
                          icon={
                            showPrintHistory ? 'chevron-up' : 'chevron-down'
                          }
                          size={20}
                          style={styles.collapseIcon}
                        />
                      </TouchableOpacity>

                      {showPrintHistory && (
                        <View style={styles.collapsibleContent}>
                          {order.ticketImpressions.map((impression, index) => {
                            const getTicketTypeLabel = (type: string) => {
                              switch (type) {
                                case 'KITCHEN':
                                  return ' Cocina';
                                case 'BAR':
                                  return ' Barra';
                                case 'BILLING':
                                  return ' Cuenta';
                                case 'CUSTOMER_COPY':
                                  return ' Copia Cliente';
                                case 'GENERAL':
                                  return ' General';
                                default:
                                  return type;
                              }
                            };

                            return (
                              <View
                                key={impression.id || index}
                                style={styles.impressionRow}
                              >
                                <View style={styles.impressionLeft}>
                                  <Text
                                    style={[
                                      styles.impressionType,
                                      { color: theme.colors.onSurface },
                                    ]}
                                  >
                                    {getTicketTypeLabel(impression.ticketType)}
                                  </Text>
                                  <View style={styles.impressionDetails}>
                                    {impression.user && (
                                      <Text
                                        style={[
                                          styles.impressionUser,
                                          {
                                            color:
                                              theme.colors.onSurfaceVariant,
                                          },
                                        ]}
                                      >
                                        por {impression.user.firstName || ''}{' '}
                                        {impression.user.lastName || ''}
                                      </Text>
                                    )}
                                    {impression.printer && (
                                      <Text
                                        style={[
                                          styles.impressionPrinter,
                                          {
                                            color:
                                              theme.colors.onSurfaceVariant,
                                          },
                                        ]}
                                      >
                                         {impression.printer.name}
                                      </Text>
                                    )}
                                  </View>
                                </View>
                                <Text
                                  style={[
                                    styles.impressionTime,
                                    { color: theme.colors.onSurfaceVariant },
                                  ]}
                                >
                                  {format(
                                    new Date(impression.impressionTime),
                                    'HH:mm:ss',
                                    { locale: es },
                                  )}
                                </Text>
                              </View>
                            );
                          })}
                        </View>
                      )}
                    </View>
                  </>
                )}
            </ScrollView>

            <Divider style={styles.divider} />

            <View style={styles.footer}>
              <View style={styles.footerLeft}>
                <Text
                  style={[
                    styles.totalLabel,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                  Por pagar:
                </Text>
                <Text
                  style={[
                    styles.totalAmount,
                    {
                      color: (() => {
                        const totalOrder =
                          typeof order.total === 'string'
                            ? parseFloat(order.total)
                            : order.total;
                        const totalPaid =
                          order.payments?.reduce(
                            (sum, p) => sum + p.amount,
                            0,
                          ) || 0;
                        const remaining = totalOrder - totalPaid;
                        return remaining > 0 ? theme.colors.error : '#10B981';
                      })(),
                    },
                  ]}
                >
                  $
                  {(() => {
                    if (!order) return '0.00';
                    const totalOrder =
                      typeof order.total === 'string'
                        ? parseFloat(order.total)
                        : order.total;
                    const totalPaid =
                      order.payments?.reduce((sum, p) => sum + p.amount, 0) ||
                      0;
                    const remaining = totalOrder - totalPaid;
                    return remaining > 0 ? remaining.toFixed(2) : '0.00';
                  })()}
                </Text>
              </View>
              <View
                style={[
                  styles.paymentBadge,
                  { backgroundColor: paymentStatus.color },
                ]}
              >
                <Text style={styles.paymentBadgeText}>
                   {paymentStatus.label}
                </Text>
              </View>
            </View>
          </>
        )}
      </Modal>
    </Portal>
  );
};

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    modalContent: {
      margin: 12,
      borderRadius: 12,
      maxHeight: '90%',
      elevation: 4,
      overflow: 'hidden',
    },
    header: {
      paddingHorizontal: 16,
      paddingTop: 10,
      paddingBottom: 6,
    },
    headerInfo: {
      flex: 1,
    },
    headerTopRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 6,
    },
    headerLeft: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      flexWrap: 'wrap',
    },
    headerBottomRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    chipsRow: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      gap: 6,
      flexWrap: 'wrap',
    },
    headerSeparator: {
      fontSize: responsive.fontSize(11),
      marginHorizontal: 6,
    },
    orderType: {
      fontSize: responsive.fontSize(12),
      fontWeight: '600',
    },
    headerDate: {
      fontSize: responsive.fontSize(11),
    },
    infoSection: {
      paddingHorizontal: 16,
      paddingTop: 4,
      paddingBottom: 6,
      gap: 4,
    },
    infoRow: {
      marginVertical: 2,
    },
    contactText: {
      fontSize: responsive.fontSize(12),
    },
    addressText: {
      fontSize: responsive.fontSize(12),
      lineHeight: 16,
    },
    tableText: {
      fontSize: responsive.fontSize(12),
    },
    screenChip: {
      height: 20,
    },
    screenChipText: {
      fontSize: responsive.fontSize(10),
      marginVertical: -2,
    },
    paymentBadge: {
      paddingHorizontal: 10,
      paddingVertical: 4,
      borderRadius: 12,
    },
    paymentBadgeText: {
      color: 'white',
      fontSize: responsive.fontSize(12),
      fontWeight: '600',
    },
    totalAmount: {
      fontSize: responsive.fontSize(16),
      fontWeight: '700',
    },
    footer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingHorizontal: 16,
      paddingVertical: 12,
      borderTopWidth: 1,
      borderTopColor: 'rgba(0,0,0,0.08)',
      backgroundColor: 'inherit',
    },
    footerLeft: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 8,
    },
    totalLabel: {
      fontSize: responsive.fontSize(14),
      fontWeight: '600',
    },
    divider: {
      marginVertical: 2,
    },
    closeButton: {
      margin: -8,
    },
    headerActions: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 16,
    },
    headerStatusChip: {
      paddingHorizontal: 8,
      paddingVertical: 2,
      borderRadius: 10,
    },
    headerStatusChipText: {
      color: 'white',
      fontSize: responsive.fontSize(11),
      fontWeight: '600',
    },
    title: {
      fontSize: responsive.fontSize(20),
      fontWeight: '700',
    },
    scrollView: {
      flexGrow: 0,
      flexShrink: 1,
      maxHeight: '70%',
    },
    scrollContent: {
      paddingBottom: 8,
    },
    itemsList: {
      padding: 12,
      paddingBottom: 16,
    },
    itemCard: {
      borderRadius: 8,
      overflow: 'hidden',
    },
    itemContent: {
      padding: 10,
    },
    itemHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 6,
    },
    nameContainer: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      marginRight: 8,
    },
    itemQuantity: {
      fontSize: responsive.fontSize(14),
      fontWeight: '700',
      marginRight: 6,
    },
    itemName: {
      fontSize: responsive.fontSize(13),
      fontWeight: '600',
      flex: 1,
      lineHeight: 16,
    },
    statusChip: {
      paddingHorizontal: 8,
      paddingVertical: 2,
      borderRadius: 12,
    },
    statusChipText: {
      color: 'white',
      fontSize: responsive.fontSize(10),
      fontWeight: '600',
    },
    itemDetailsContainer: {
      marginBottom: 6,
    },
    customizationContainer: {
      marginBottom: 4,
    },
    pizzaCustomizationText: {
      fontSize: responsive.fontSize(11),
      fontStyle: 'italic',
      lineHeight: 14,
    },
    modifiersContainer: {
      marginTop: 2,
    },
    modifierRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 1,
    },
    modifierText: {
      fontSize: responsive.fontSize(11),
      flex: 1,
      lineHeight: 14,
    },
    modifierPrice: {
      fontSize: responsive.fontSize(11),
      fontWeight: '500',
      marginLeft: 4,
    },
    notesContainer: {
      marginTop: 4,
      paddingTop: 4,
      borderTopWidth: 1,
      borderTopColor: 'rgba(0,0,0,0.06)',
    },
    notesText: {
      fontSize: responsive.fontSize(11),
      fontStyle: 'italic',
      lineHeight: 14,
    },
    priceContainer: {
      marginTop: 6,
      paddingTop: 6,
      borderTopWidth: 1,
      borderTopColor: 'rgba(0,0,0,0.06)',
    },
    priceRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 2,
    },
    priceLabel: {
      fontSize: responsive.fontSize(11),
      opacity: 0.7,
    },
    priceValue: {
      fontSize: responsive.fontSize(12),
      fontWeight: '600',
    },
    totalPrice: {
      fontSize: responsive.fontSize(14),
      fontWeight: '700',
    },
    paymentsSection: {
      paddingHorizontal: 16,
      paddingVertical: 8,
    },
    paymentSummaryCompact: {
      marginBottom: 8,
    },
    summaryCompactRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    summaryCompactLabel: {
      fontSize: responsive.fontSize(12),
      fontWeight: '500',
    },
    paymentRowCompact: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: 6,
      gap: 8,
    },
    paymentMethodCompact: {
      fontSize: responsive.fontSize(11),
      fontWeight: '500',
      flex: 1,
    },
    paymentDateCompact: {
      fontSize: responsive.fontSize(10),
    },
    paymentAmountCompact: {
      fontSize: responsive.fontSize(12),
      fontWeight: '600',
      minWidth: 50,
      textAlign: 'right',
    },
    paymentStatusBadgeCompact: {
      paddingHorizontal: 6,
      paddingVertical: 1,
      borderRadius: 10,
    },
    paymentStatusTextCompact: {
      fontSize: responsive.fontSize(9),
      fontWeight: '600',
    },
    ticketImpressionsSection: {
      paddingHorizontal: 16,
      paddingVertical: 8,
    },
    collapsibleHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingRight: 4,
    },
    collapseIcon: {
      margin: -8,
    },
    collapsibleContent: {
      marginTop: 8,
    },
    sectionTitle: {
      fontSize: responsive.fontSize(14),
      fontWeight: '600',
      marginBottom: 0,
    },
    impressionRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 8,
      paddingLeft: 8,
    },
    impressionLeft: {
      flex: 1,
      gap: 2,
    },
    impressionType: {
      fontSize: responsive.fontSize(12),
      fontWeight: '500',
    },
    impressionDetails: {
      gap: 2,
    },
    impressionUser: {
      fontSize: responsive.fontSize(11),
      opacity: 0.7,
    },
    impressionPrinter: {
      fontSize: responsive.fontSize(11),
      opacity: 0.7,
      fontStyle: 'italic',
    },
    impressionTime: {
      fontSize: responsive.fontSize(11),
      opacity: 0.7,
    },
    loadingContainer: {
      minHeight: 200,
      justifyContent: 'center',
      alignItems: 'center',
      paddingVertical: 40,
    },
    loadingText: {
      marginTop: 16,
      fontSize: responsive.fontSize(14),
    },
    itemCardWithMargin: {
      backgroundColor: theme.colors.elevation.level1,
      marginBottom: 8,
    },
    scheduledTimeText: {
      color: theme.colors.primary,
      fontWeight: '600',
    },
    paidAmountText: {
      color: '#10B981',
    },
    remainingAmountText: {
      color: theme.colors.error,
      fontWeight: '600',
    },
  });

export default OrderDetailsModal;

================
File: app/src/modules/orderFinalization/screens/OrderFinalizationScreen.tsx
================
import React, { useState, useMemo, useCallback, useEffect } from 'react';
import { View, StyleSheet, Pressable } from 'react-native';
import { FlashList } from '@shopify/flash-list';
import {
  Surface,
  Text,
  ActivityIndicator,
  Icon,
  Button,
  IconButton,
} from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { OrderCard } from '../components/OrderCard';
import { OrderDetailsModal } from '../components/OrderDetailsModal';
import { PrintTicketModal } from '@/modules/shared/components/PrintTicketModal';
import {
  useOrdersForFinalizationList,
  useOrderForFinalizationDetail,
} from '../hooks/useOrderFinalizationQueries';
import {
  OrderFinalizationFilter,
  OrderSelectionState,
  OrderForFinalizationList,
} from '../schema/orderFinalization.schema';
import EmptyState from '@/app/components/common/EmptyState';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { orderFinalizationService } from '../services/orderFinalizationService';

export const OrderFinalizationScreen: React.FC = () => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const styles = useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const [filter, setFilter] = useState<OrderFinalizationFilter>('delivery');
  const [selectionState, setSelectionState] = useState<OrderSelectionState>({
    selectedOrders: new Set(),
    totalAmount: 0,
  });
  const [selectedOrderIdForDetails, setSelectedOrderIdForDetails] = useState<
    string | null
  >(null);
  const [showConfirmationModal, setShowConfirmationModal] = useState(false);
  const [isFinalizingOrders, setIsFinalizingOrders] = useState(false);
  const [showPrintModal, setShowPrintModal] = useState(false);
  const [selectedOrderForPrint, setSelectedOrderForPrint] =
    useState<OrderForFinalizationList | null>(null);

  const {
    data: orders = [],
    isLoading,
    refetch,
  } = useOrdersForFinalizationList();

  const { data: selectedOrderDetails, isLoading: isLoadingDetails } =
    useOrderForFinalizationDetail(selectedOrderIdForDetails);

  const { data: orderForPrint } = useOrderForFinalizationDetail(
    selectedOrderForPrint?.id || null,
  );

  const filteredOrders = useMemo(() => {
    if (!orders || !Array.isArray(orders)) return [];

    return orders.filter((order) => {
      switch (filter) {
        case 'delivery':
          return order.orderType === 'DELIVERY';
        case 'take_away':
          return order.orderType === 'TAKE_AWAY';
        case 'dine_in':
          return order.orderType === 'DINE_IN';
        default:
          return false;
      }
    });
  }, [orders, filter]);

  const orderCounts = useMemo(() => {
    if (!orders || !Array.isArray(orders)) {
      return {
        delivery: 0,
        take_away: 0,
        dine_in: 0,
      };
    }

    return orders.reduce(
      (counts, order) => {
        switch (order.orderType) {
          case 'DELIVERY':
            counts.delivery++;
            break;
          case 'TAKE_AWAY':
            counts.take_away++;
            break;
          case 'DINE_IN':
            counts.dine_in++;
            break;
        }
        return counts;
      },
      { delivery: 0, take_away: 0, dine_in: 0 },
    );
  }, [orders]);

  useEffect(() => {
    setSelectionState({
      selectedOrders: new Set(),
      totalAmount: 0,
    });
  }, [filter]);

  const handleToggleOrderSelection = useCallback(
    (orderId: string) => {
      if (!orders || !Array.isArray(orders)) return;

      const order = orders.find((o) => o.id === orderId);
      if (!order) return;

      setSelectionState((prevState) => {
        const newSelectedOrders = new Set(prevState.selectedOrders);
        let newTotalAmount = prevState.totalAmount;
        const orderTotal =
          typeof order.total === 'string'
            ? parseFloat(order.total)
            : order.total;
        const paymentsSummary = order.paymentsSummary;
        const paid = paymentsSummary?.totalPaid || 0;
        const pendingAmount = orderTotal - paid;

        if (newSelectedOrders.has(orderId)) {
          newSelectedOrders.delete(orderId);
          newTotalAmount -= pendingAmount;
        } else {
          newSelectedOrders.add(orderId);
          newTotalAmount += pendingAmount;
        }

        return {
          selectedOrders: newSelectedOrders,
          totalAmount: newTotalAmount,
        };
      });
    },
    [orders],
  );

  const ordersNotReady = useMemo(() => {
    if (selectionState.selectedOrders.size === 0) return [];

    const selectedOrdersList = Array.from(selectionState.selectedOrders)
      .map((id) => orders.find((o) => o.id === id))
      .filter(Boolean) as OrderForFinalizationList[];

    return selectedOrdersList.filter((order) => order.orderStatus !== 'READY');
  }, [selectionState.selectedOrders, orders]);

  const confirmationMessage = useMemo(() => {
    let message = `Desea finalizar ${selectionState.selectedOrders.size} ${
      selectionState.selectedOrders.size === 1 ? 'orden' : 'rdenes'
    }?\n\nTotal a cobrar: $${selectionState.totalAmount.toFixed(2)}`;

    if (ordersNotReady.length > 0) {
      message += `\n\n ADVERTENCIA: ${ordersNotReady.length} ${
        ordersNotReady.length === 1 ? 'orden no est' : 'rdenes no estn'
      } en estado "Listo"`;
    }

    return message;
  }, [selectionState, ordersNotReady]);

  const handleQuickFinalizeOrders = useCallback(() => {
    if (selectionState.selectedOrders.size === 0) return;
    setShowConfirmationModal(true);
  }, [selectionState.selectedOrders.size]);

  const handleConfirmFinalization = useCallback(async () => {
    setIsFinalizingOrders(true);
    try {
      await orderFinalizationService.quickFinalizeMultipleOrders(
        Array.from(selectionState.selectedOrders),
      );

      showSnackbar({
        message: 'rdenes finalizadas exitosamente',
        type: 'success',
      });

      setSelectionState({
        selectedOrders: new Set(),
        totalAmount: 0,
      });

      setShowConfirmationModal(false);
      refetch();
    } catch (error) {
      showSnackbar({
        message: 'Error al finalizar las rdenes',
        type: 'error',
      });
    } finally {
      setIsFinalizingOrders(false);
    }
  }, [selectionState.selectedOrders, showSnackbar, refetch]);

  const handleShowOrderDetails = useCallback(
    (order: OrderForFinalizationList) => {
      setSelectedOrderIdForDetails(null);
      setTimeout(() => {
        setSelectedOrderIdForDetails(order.id);
      }, 50);
    },
    [],
  );

  const handlePrintPress = useCallback(() => {
    setShowPrintModal(true);
  }, []);

  const handlePrintFromList = useCallback(
    async (order: OrderForFinalizationList) => {
      setSelectedOrderForPrint(order);
      setShowPrintModal(true);
    },
    [],
  );

  const handlePrint = useCallback(
    async (printerId: string, ticketType: 'GENERAL' | 'BILLING') => {
      const orderToUse = orderForPrint || selectedOrderDetails;
      if (!orderToUse) return;

      try {
        await orderFinalizationService.printTicket(orderToUse.id, {
          printerId,
          ticketType,
        });

        showSnackbar({
          message: 'Ticket impreso exitosamente',
          type: 'success',
        });

        await refetch();
        setSelectedOrderForPrint(null);
      } catch (error) {
        showSnackbar({
          message: 'Error al imprimir el ticket',
          type: 'error',
        });
      }
    },
    [orderForPrint, selectedOrderDetails, showSnackbar, refetch],
  );

  const renderOrderCard = useCallback(
    ({ item }: { item: OrderForFinalizationList }) => (
      <OrderCard
        order={item}
        isSelected={selectionState.selectedOrders.has(item.id)}
        onToggleSelection={handleToggleOrderSelection}
        onShowDetails={handleShowOrderDetails}
        onPrintPress={handlePrintFromList}
      />
    ),
    [
      selectionState.selectedOrders,
      handleToggleOrderSelection,
      handleShowOrderDetails,
      handlePrintFromList,
    ],
  );

  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
        <Text
          style={[styles.loadingText, { color: theme.colors.onSurfaceVariant }]}
        >
          Cargando rdenes...
        </Text>
      </View>
    );
  }

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.colors.background }]}
      edges={['top']}
    >
      <Surface style={styles.header}>
        <View style={styles.headerContent}>
          <View style={styles.filterContainer}>
            <Pressable
              style={[
                styles.filterButton,
                filter === 'delivery' && styles.filterButtonActive,
                {
                  backgroundColor:
                    filter === 'delivery'
                      ? theme.colors.primaryContainer
                      : theme.colors.surface,
                },
              ]}
              onPress={() => setFilter('delivery')}
            >
              <Icon
                source="moped"
                size={responsive.isTablet ? 22 : 26}
                color={
                  filter === 'delivery'
                    ? theme.colors.primary
                    : theme.colors.onSurfaceVariant
                }
              />
              {orderCounts.delivery > 0 && (
                <View
                  style={[
                    styles.countBadge,
                    {
                      backgroundColor:
                        filter === 'delivery'
                          ? theme.colors.error
                          : theme.colors.errorContainer,
                      borderColor:
                        filter === 'delivery'
                          ? theme.colors.error
                          : theme.colors.outline,
                    },
                  ]}
                >
                  <Text
                    style={[
                      styles.countBadgeText,
                      {
                        color:
                          filter === 'delivery'
                            ? theme.colors.onError
                            : theme.colors.onErrorContainer,
                      },
                    ]}
                  >
                    {orderCounts.delivery}
                  </Text>
                </View>
              )}
            </Pressable>
            <Pressable
              style={[
                styles.filterButton,
                filter === 'take_away' && styles.filterButtonActive,
                {
                  backgroundColor:
                    filter === 'take_away'
                      ? theme.colors.primaryContainer
                      : theme.colors.surface,
                },
              ]}
              onPress={() => setFilter('take_away')}
            >
              <Icon
                source="bag-personal"
                size={responsive.isTablet ? 22 : 26}
                color={
                  filter === 'take_away'
                    ? theme.colors.primary
                    : theme.colors.onSurfaceVariant
                }
              />
              {orderCounts.take_away > 0 && (
                <View
                  style={[
                    styles.countBadge,
                    {
                      backgroundColor:
                        filter === 'take_away'
                          ? theme.colors.error
                          : theme.colors.errorContainer,
                      borderColor:
                        filter === 'take_away'
                          ? theme.colors.error
                          : theme.colors.outline,
                    },
                  ]}
                >
                  <Text
                    style={[
                      styles.countBadgeText,
                      {
                        color:
                          filter === 'take_away'
                            ? theme.colors.onError
                            : theme.colors.onErrorContainer,
                      },
                    ]}
                  >
                    {orderCounts.take_away}
                  </Text>
                </View>
              )}
            </Pressable>
            <Pressable
              style={[
                styles.filterButton,
                filter === 'dine_in' && styles.filterButtonActive,
                {
                  backgroundColor:
                    filter === 'dine_in'
                      ? theme.colors.primaryContainer
                      : theme.colors.surface,
                },
              ]}
              onPress={() => setFilter('dine_in')}
            >
              <Icon
                source="silverware-fork-knife"
                size={responsive.isTablet ? 22 : 26}
                color={
                  filter === 'dine_in'
                    ? theme.colors.primary
                    : theme.colors.onSurfaceVariant
                }
              />
              {orderCounts.dine_in > 0 && (
                <View
                  style={[
                    styles.countBadge,
                    {
                      backgroundColor:
                        filter === 'dine_in'
                          ? theme.colors.error
                          : theme.colors.errorContainer,
                      borderColor:
                        filter === 'dine_in'
                          ? theme.colors.error
                          : theme.colors.outline,
                    },
                  ]}
                >
                  <Text
                    style={[
                      styles.countBadgeText,
                      {
                        color:
                          filter === 'dine_in'
                            ? theme.colors.onError
                            : theme.colors.onErrorContainer,
                      },
                    ]}
                  >
                    {orderCounts.dine_in}
                  </Text>
                </View>
              )}
            </Pressable>
          </View>
          <View style={styles.refreshButtonContainer}>
            <IconButton
              icon="refresh"
              size={responsive.isTablet ? 20 : 24}
              mode="contained"
              containerColor={theme.colors.surfaceVariant}
              iconColor={theme.colors.onSurfaceVariant}
              onPress={() => refetch()}
              style={styles.refreshButton}
            />
          </View>
        </View>
      </Surface>

      <View style={styles.content}>
        {filteredOrders.length === 0 ? (
          <EmptyState
            title="No hay rdenes para finalizar"
            message="Las rdenes aparecern aqu cuando estn listas para finalizar"
            icon="clipboard-check-outline"
          />
        ) : (
          <FlashList
            data={filteredOrders}
            keyExtractor={(item) => item.id}
            renderItem={renderOrderCard}
            contentContainerStyle={styles.listContent}
            showsVerticalScrollIndicator={false}
            ItemSeparatorComponent={() => null}
            onRefresh={refetch}
            refreshing={isLoading}
            estimatedItemSize={150}
            removeClippedSubviews={true}
          />
        )}
      </View>

      {selectionState.selectedOrders.size > 0 && (
        <Surface style={styles.floatingButton} elevation={4}>
          <Button
            mode="contained"
            onPress={handleQuickFinalizeOrders}
            style={styles.finalizeButton}
            labelStyle={styles.finalizeButtonLabel}
            disabled={isFinalizingOrders}
          >
            Finalizar ({selectionState.selectedOrders.size}) - $
            {(selectionState.totalAmount || 0).toFixed(2)}
          </Button>
        </Surface>
      )}

      <OrderDetailsModal
        visible={selectedOrderIdForDetails !== null}
        onDismiss={() => setSelectedOrderIdForDetails(null)}
        order={selectedOrderDetails || null}
        isLoading={isLoadingDetails}
        onPrintPress={handlePrintPress}
      />

      <PrintTicketModal
        visible={showPrintModal}
        onDismiss={() => {
          setShowPrintModal(false);
          setSelectedOrderForPrint(null);
        }}
        order={orderForPrint || selectedOrderDetails || null}
        onPrint={handlePrint}
      />

      <ConfirmationModal
        visible={showConfirmationModal}
        title="Finalizar rdenes"
        message={confirmationMessage}
        onConfirm={handleConfirmFinalization}
        onCancel={() => setShowConfirmationModal(false)}
        onDismiss={() => setShowConfirmationModal(false)}
        confirmText={isFinalizingOrders ? 'Finalizando...' : 'Finalizar'}
        confirmButtonColor={
          ordersNotReady.length > 0 ? theme.colors.error : theme.colors.primary
        }
      />
    </SafeAreaView>
  );
};

const createStyles = (
  theme: ReturnType<typeof useAppTheme>,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
    },
    header: {
      paddingHorizontal: 0,
      paddingVertical: 0,
      backgroundColor: 'transparent',
      elevation: 0,
    },
    headerContent: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 0,
    },
    filterContainer: {
      flex: 1,
      flexDirection: 'row',
      gap: 0,
    },
    refreshButtonContainer: {
      paddingHorizontal: responsive.isTablet ? 6 : 8,
    },
    refreshButton: {
      margin: 0,
    },
    filterButton: {
      flex: 1,
      height: responsive.isTablet ? 44 : 52,
      justifyContent: 'center',
      alignItems: 'center',
      borderRadius: 0,
      elevation: 1,
      position: 'relative',
    },
    filterButtonActive: {
      elevation: 3,
    },
    countBadge: {
      position: 'absolute',
      top: responsive.isTablet ? 4 : 6,
      right: responsive.isTablet ? 4 : 6,
      minWidth: responsive.isTablet ? 18 : 22,
      height: responsive.isTablet ? 18 : 22,
      borderRadius: responsive.isTablet ? 9 : 11,
      justifyContent: 'center',
      alignItems: 'center',
      paddingHorizontal: responsive.isTablet ? 4 : 6,
      borderWidth: 1,
      elevation: 2,
    },
    countBadgeText: {
      fontSize: responsive.isTablet ? 10 : 12,
      fontWeight: '700',
    },
    floatingButton: {
      position: 'absolute',
      bottom: responsive.isTablet ? 12 : 16,
      left: responsive.isTablet ? 12 : 16,
      right: responsive.isTablet ? 12 : 16,
      borderRadius: responsive.isTablet ? 12 : 16,
      padding: responsive.isTablet ? 6 : 8,
      elevation: 8,
    },
    finalizeButton: {
      borderRadius: responsive.isTablet ? 10 : 12,
      paddingVertical: responsive.isTablet ? 3 : 4,
    },
    finalizeButtonLabel: {
      fontSize: responsive.isTablet ? 14 : 16,
      fontWeight: '700',
      letterSpacing: 0.5,
    },
    content: {
      flex: 1,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
    loadingText: {
      marginTop: responsive.isTablet ? 8 : 12,
      fontSize: responsive.isTablet ? 12 : 14,
    },
    listContent: {
      padding: responsive.isTablet ? 6 : 8,
      paddingBottom: responsive.isTablet ? 80 : 100,
    },
  });

================
File: app/src/modules/orders/components/order-cart/PrepaymentSection.tsx
================
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, IconButton, Button } from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';

interface PrepaymentSectionProps {
  isEditMode: boolean;
  prepaymentId: string | null;
  paymentAmount: string;
  paymentMethod: 'CASH' | 'CARD' | 'TRANSFER' | null;
  total: number;
  totalPaid?: number;
  pendingAmount?: number;
  canRegisterPayments?: boolean;
  onShowPrepaymentModal: () => void;
  onDeletePrepayment: () => void;
}

export const PrepaymentSection: React.FC<PrepaymentSectionProps> = ({
  isEditMode,
  prepaymentId,
  paymentAmount,
  paymentMethod,
  total,
  totalPaid,
  pendingAmount,
  canRegisterPayments = true,
  onShowPrepaymentModal,
  onDeletePrepayment,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);
  const parsedPaymentAmount = parseFloat(paymentAmount || '0');
  const exceedsTotal = parsedPaymentAmount > total;
  const remainingAmount = Math.max(0, total - parsedPaymentAmount);

  // En modo edicin, mostrar los montos pagados
  if (isEditMode) {
    return (
      <>
        <View style={styles.totalsContainer}>
          <Text style={styles.totalsText}>Pagado:</Text>
          <Text style={[styles.totalsValue, styles.paidAmount]}>
            ${(totalPaid || 0).toFixed(2)}
          </Text>
        </View>
        <View style={styles.totalsContainer}>
          <Text style={[styles.totalsText, styles.boldText]}>Restante:</Text>
          <Text
            style={[
              styles.totalsValue,
              styles.boldText,
              (pendingAmount || 0) > 0
                ? styles.errorColor
                : styles.successColor,
            ]}
          >
            ${(pendingAmount || 0).toFixed(2)}
          </Text>
        </View>
      </>
    );
  }

  // Si hay prepago registrado
  if (prepaymentId) {
    return (
      <>
        <View style={styles.prepaymentSection}>
          <View style={styles.prepaymentHeader}>
            <Text style={styles.prepaymentTitle}>Prepago registrado</Text>
            <View style={styles.prepaymentActions}>
              <IconButton
                icon="pencil"
                size={28}
                iconColor={theme.colors.primary}
                onPress={onShowPrepaymentModal}
                style={styles.prepaymentIconButton}
              />
              <IconButton
                icon="delete"
                size={28}
                iconColor={theme.colors.error}
                onPress={onDeletePrepayment}
                style={styles.prepaymentIconButton}
              />
            </View>
          </View>
          <View style={styles.totalsContainer}>
            <Text style={styles.totalsText}>Monto pagado:</Text>
            <Text style={[styles.totalsValue, styles.paidAmount]}>
              ${parsedPaymentAmount.toFixed(2)}
            </Text>
          </View>
          {exceedsTotal && (
            <View style={styles.prepaymentWarning}>
              <IconButton
                icon="alert-circle"
                size={16}
                iconColor={theme.colors.error}
                style={styles.iconButtonNoMargin}
              />
              <Text style={styles.prepaymentWarningText}>
                El prepago excede el total de la orden. Edite el pago antes de
                continuar.
              </Text>
            </View>
          )}
        </View>
        <View style={styles.totalsContainer}>
          <Text style={[styles.totalsText, styles.boldText]}>Restante:</Text>
          <Text
            style={[
              styles.totalsValue,
              styles.boldText,
              remainingAmount === 0 ? styles.successColor : styles.errorColor,
            ]}
          >
            ${remainingAmount.toFixed(2)}
          </Text>
        </View>
      </>
    );
  }

  // Si puede registrar pagos y no hay prepago
  if (canRegisterPayments) {
    return (
      <View style={styles.paymentButtonContainer}>
        <Button
          mode="outlined"
          onPress={onShowPrepaymentModal}
          style={styles.paymentButton}
          icon="credit-card"
        >
           Registrar pago con la orden
        </Button>
      </View>
    );
  }

  return null;
};

const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    prepaymentSection: {
      marginBottom: theme.spacing.s,
      paddingHorizontal: theme.spacing.xs,
    },
    prepaymentHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.xs,
    },
    prepaymentTitle: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    prepaymentActions: {
      flexDirection: 'row',
      gap: theme.spacing.xs,
    },
    prepaymentIconButton: {
      margin: 0,
    },
    prepaymentWarning: {
      flexDirection: 'row',
      alignItems: 'center',
      backgroundColor: theme.colors.errorContainer,
      borderRadius: theme.roundness,
      padding: theme.spacing.s,
      marginTop: theme.spacing.xs,
      marginBottom: theme.spacing.xs,
    },
    prepaymentWarningText: {
      flex: 1,
      fontSize: 14,
      color: theme.colors.onErrorContainer,
      marginLeft: theme.spacing.xs,
    },
    totalsContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      marginBottom: theme.spacing.xs,
      paddingHorizontal: theme.spacing.xs,
    },
    totalsText: {
      fontSize: 16,
      color: theme.colors.onSurfaceVariant,
    },
    totalsValue: {
      fontSize: 16,
      color: theme.colors.onSurface,
    },
    paidAmount: {
      color: '#4CAF50',
    },
    boldText: {
      fontWeight: 'bold',
    },
    paymentButtonContainer: {
      paddingHorizontal: theme.spacing.s,
      paddingVertical: theme.spacing.m,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
    },
    paymentButton: {
      marginVertical: theme.spacing.xs,
    },
    iconButtonNoMargin: {
      margin: 0,
    },
    errorColor: {
      color: theme.colors.error,
    },
    successColor: {
      color: '#4CAF50',
    },
  });

================
File: app/src/modules/orders/services/orderService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import type { Order } from '../../../app/schemas/domain/order.schema';
import type { FindAllOrdersDto, OrderOpenList } from '../schema/orders.schema';
import type { PaginatedResponse } from '../../../app/types/api.types';
import type { OrderDetailsForBackend } from '../stores/useOrderStore';
import type { UpdateOrderPayload } from '../schema/update-order.schema';

const createOrder = async (
  orderData: OrderDetailsForBackend,
): Promise<Order> => {
  const response = await apiClient.post<Order>(API_PATHS.ORDERS, orderData);
  return response.data;
};

export const orderService = {
  createOrder,
  getOrders: async (
    filters: FindAllOrdersDto = {},
  ): Promise<PaginatedResponse<Order>> => {
    const queryParams: Record<string, any> = {};
    for (const [key, value] of Object.entries(filters)) {
      if (value !== undefined) {
        if (key !== 'page' && key !== 'limit') {
          queryParams[key] = value;
        }
      }
    }

    const page = filters.page ?? 1;
    const limit = filters.limit ?? 10;
    queryParams.page = page;
    queryParams.limit = limit;
    const response = await apiClient.get<[Order[], number]>(API_PATHS.ORDERS, {
      params: queryParams,
    });

    const [data, total] = response.data;
    const totalPages = limit > 0 ? Math.ceil(total / limit) : 1;

    return {
      data,
      total,
      page,
      limit,
      totalPages,
    };
  },
  getOpenOrdersCurrentShift: async (): Promise<Order[]> => {
    const response = await apiClient.get<Order[]>(
      API_PATHS.ORDERS_OPEN_CURRENT_SHIFT,
    );
    return response.data;
  },
  getOpenOrdersList: async (): Promise<OrderOpenList[]> => {
    const response = await apiClient.get<OrderOpenList[]>(
      API_PATHS.ORDERS_OPEN_ORDERS_LIST,
    );
    return response.data;
  },
  printOrderTicket: async (
    orderId: string,
    printerId: string,
  ): Promise<void> => {
    const url = API_PATHS.PRINT_ORDER_TICKET;
    const body = { orderId, printerId };
    await apiClient.post<any>(url, body);
  },
  getOrderById: async (orderId: string): Promise<Order> => {
    const response = await apiClient.get<Order>(
      API_PATHS.ORDERS_BY_ID.replace(':orderId', orderId),
    );
    return response.data;
  },
  updateOrder: async (
    orderId: string,
    payload: UpdateOrderPayload,
  ): Promise<Order> => {
    const response = await apiClient.patch<Order>(
      API_PATHS.ORDERS_BY_ID.replace(':orderId', orderId),
      payload,
    );
    return response.data;
  },
  cancelOrder: async (orderId: string): Promise<Order> => {
    const payload: UpdateOrderPayload = {
      orderStatus: 'CANCELLED',
    };

    const response = await apiClient.patch<Order>(
      API_PATHS.ORDERS_BY_ID.replace(':orderId', orderId),
      payload,
    );
    return response.data;
  },
};

================
File: app/src/modules/pizzaCustomizations/components/PizzaCustomizationFormModal.tsx
================
import { useEffect } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
  Pressable,
} from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  TextInput,
  Switch,
  SegmentedButtons,
  HelperText,
  ActivityIndicator,
  IconButton,
  Surface,
} from 'react-native-paper';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import {
  pizzaCustomizationFormSchema,
  PizzaCustomizationFormInputs,
} from '../schema/pizzaCustomization.schema';
import {
  usePizzaCustomization,
  useCreatePizzaCustomization,
  useUpdatePizzaCustomization,
} from '../hooks/usePizzaCustomizationsQueries';
import { CustomizationTypeEnum } from '../schema/pizzaCustomization.schema';

interface PizzaCustomizationFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  customizationId?: string;
  onSuccess?: () => void;
}

const createStyles = (theme: any, responsive: any) => {
  const isTablet = responsive.isTablet;

  return StyleSheet.create({
    container: {
      flex: 1,
      justifyContent: 'center',
      paddingHorizontal: responsive.spacing(theme.spacing.m),
    },
    backdrop: {
      ...StyleSheet.absoluteFillObject,
      backgroundColor: 'rgba(0, 0, 0, 0.5)',
    },
    modalContent: {
      backgroundColor: theme.colors.surface,
      borderRadius: 28,
      maxHeight: isTablet ? '90%' : '85%',
      minHeight: isTablet ? 600 : undefined,
      maxWidth: isTablet ? 650 : 500,
      width: '100%',
      alignSelf: 'center',
      overflow: 'hidden',
      elevation: 24,
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 12,
      },
      shadowOpacity: 0.58,
      shadowRadius: 16.0,
    },
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingTop: responsive.spacing(theme.spacing.m),
      paddingBottom: responsive.spacing(theme.spacing.m),
      paddingHorizontal: responsive.spacing(theme.spacing.l),
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    headerTitle: {
      fontSize: responsive.fontSize(18),
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    closeButton: {
      margin: -responsive.spacing(theme.spacing.xs),
    },
    scrollContent: {
      padding: responsive.spacing(theme.spacing.l),
      paddingTop: responsive.spacing(theme.spacing.m),
    },
    formGroup: {
      marginBottom: responsive.spacing(theme.spacing.l),
    },
    label: {
      fontSize: responsive.fontSize(12),
      fontWeight: '600',
      color: theme.colors.onSurfaceVariant,
      marginBottom: responsive.spacing(theme.spacing.xs),
      marginLeft: responsive.spacing(theme.spacing.xs),
      textTransform: 'uppercase',
      letterSpacing: 0.5,
    },
    segmentedButtons: {
      marginBottom: responsive.spacing(theme.spacing.xs),
      borderRadius: 16,
    },
    row: {
      flexDirection: 'row',
      gap: responsive.spacing(theme.spacing.m),
      marginBottom: responsive.spacing(theme.spacing.l),
    },
    halfWidth: {
      flex: 1,
    },
    switchRow: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingVertical: responsive.spacing(theme.spacing.m),
      paddingHorizontal: responsive.spacing(theme.spacing.l),
      backgroundColor: theme.colors.secondaryContainer,
      borderRadius: 16,
      marginBottom: responsive.spacing(theme.spacing.l),
    },
    switchLabel: {
      fontSize: responsive.fontSize(16),
      fontWeight: '500',
      color: theme.colors.onSecondaryContainer,
    },
    footer: {
      flexDirection: 'row',
      justifyContent: 'center',
      padding: responsive.spacing(theme.spacing.l),
      paddingTop: responsive.spacing(theme.spacing.m),
      gap: responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.elevation.level1,
    },
    button: {
      borderRadius: 24,
      flex: 1,
      maxWidth: isTablet ? 180 : 160,
    },
    buttonContent: {
      paddingVertical: responsive.spacing(theme.spacing.xs),
    },
    loadingContainer: {
      padding: responsive.spacing(theme.spacing.xl * 2),
      alignItems: 'center',
    },
    inputStyle: {
      backgroundColor: theme.colors.elevation.level1,
    },
    keyboardView: {
      width: '100%',
    },
    inputOutline: {
      borderRadius: 12,
    },
    buttonLabel: {
      fontSize: responsive.fontSize(16),
      fontWeight: '600',
    },
  });
};

export function PizzaCustomizationFormModal({
  visible,
  onDismiss,
  customizationId,
  onSuccess,
}: PizzaCustomizationFormModalProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const isEditMode = !!customizationId;
  const styles = createStyles(theme, responsive);

  const { data: customization, isLoading: isLoadingCustomization } =
    usePizzaCustomization(customizationId || '');

  const createMutation = useCreatePizzaCustomization();
  const updateMutation = useUpdatePizzaCustomization();

  const {
    control,
    handleSubmit,
    formState: { errors, isSubmitting },
    reset,
    watch,
    setValue,
  } = useForm<PizzaCustomizationFormInputs>({
    resolver: zodResolver(pizzaCustomizationFormSchema),
    defaultValues: {
      name: '',
      type: CustomizationTypeEnum.INGREDIENT,
      ingredients: '',
      toppingValue: 1,
      isActive: true,
      sortOrder: 100,
    },
  });

  const watchType = watch('type');

  useEffect(() => {
    if (customization && isEditMode) {
      reset({
        name: customization.name,
        type: customization.type,
        ingredients: customization.ingredients || '',
        toppingValue: customization.toppingValue,
        isActive: customization.isActive,
        sortOrder: customization.sortOrder,
      });
    } else if (!visible) {
      reset({
        name: '',
        type: CustomizationTypeEnum.INGREDIENT,
        ingredients: '',
        toppingValue: 1,
        isActive: true,
        sortOrder: 100,
      });
    }
  }, [customization, isEditMode, reset, visible]);

  // Limpiar ingredientes cuando se cambie de FLAVOR a INGREDIENT
  useEffect(() => {
    if (watchType === CustomizationTypeEnum.INGREDIENT) {
      setValue('ingredients', '');
    }
  }, [watchType, setValue]);

  const onSubmit = async (data: PizzaCustomizationFormInputs) => {
    try {
      // Asegurar que los ingredientes estn vacos para tipo INGREDIENT
      const submissionData = {
        ...data,
        ingredients:
          data.type === CustomizationTypeEnum.INGREDIENT
            ? ''
            : data.ingredients,
      };

      if (isEditMode && customizationId) {
        await updateMutation.mutateAsync({
          id: customizationId,
          data: submissionData,
        });
      } else {
        await createMutation.mutateAsync(submissionData);
      }
      onSuccess?.();
      onDismiss();
    } catch (error) {
      // El error ya se maneja en los hooks con snackbar
    }
  };

  if (isLoadingCustomization && isEditMode) {
    return (
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onDismiss}
          contentContainerStyle={styles.container}
        >
          <Pressable style={styles.backdrop} onPress={onDismiss} />
          <Surface style={styles.modalContent} elevation={5}>
            <View style={styles.loadingContainer}>
              <ActivityIndicator size="large" color={theme.colors.primary} />
              <Text
                variant="bodyLarge"
                style={{
                  marginTop: responsive.spacing(theme.spacing.m),
                  color: theme.colors.onSurfaceVariant,
                }}
              >
                Cargando personalizacin...
              </Text>
            </View>
          </Surface>
        </Modal>
      </Portal>
    );
  }

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.container}
      >
        <Pressable style={styles.backdrop} onPress={onDismiss} />
        <KeyboardAvoidingView
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={styles.keyboardView}
        >
          <Surface style={styles.modalContent} elevation={5}>
            <View style={styles.header}>
              <Text style={styles.headerTitle}>
                {isEditMode ? 'Editar' : 'Nueva'} personalizacin
              </Text>
              <IconButton
                icon="close"
                size={20}
                onPress={onDismiss}
                iconColor={theme.colors.onSurfaceVariant}
                style={styles.closeButton}
              />
            </View>

            <ScrollView
              contentContainerStyle={styles.scrollContent}
              showsVerticalScrollIndicator={false}
            >
              <View style={styles.formGroup}>
                <Text style={styles.label}>Nombre del producto</Text>
                <Controller
                  control={control}
                  name="name"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <TextInput
                      placeholder="Ej: Pepperoni, Hawaiana"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.name}
                      mode="outlined"
                      outlineColor={theme.colors.outline}
                      activeOutlineColor={theme.colors.primary}
                      style={styles.inputStyle}
                      outlineStyle={styles.inputOutline}
                    />
                  )}
                />
                {errors.name && (
                  <HelperText type="error" visible={!!errors.name}>
                    {errors.name.message}
                  </HelperText>
                )}
              </View>

              <View style={styles.formGroup}>
                <Text style={styles.label}>Tipo de personalizacin</Text>
                <Controller
                  control={control}
                  name="type"
                  render={({ field: { onChange, value } }) => (
                    <SegmentedButtons
                      value={value}
                      onValueChange={onChange}
                      buttons={[
                        {
                          value: CustomizationTypeEnum.FLAVOR,
                          label: 'Sabor',
                          icon: 'pizza',
                          style: {
                            backgroundColor:
                              value === CustomizationTypeEnum.FLAVOR
                                ? theme.colors.primaryContainer
                                : 'transparent',
                          },
                        },
                        {
                          value: CustomizationTypeEnum.INGREDIENT,
                          label: 'Ingrediente',
                          icon: 'cheese',
                          style: {
                            backgroundColor:
                              value === CustomizationTypeEnum.INGREDIENT
                                ? theme.colors.primaryContainer
                                : 'transparent',
                          },
                        },
                      ]}
                      style={styles.segmentedButtons}
                    />
                  )}
                />
              </View>

              {watchType === CustomizationTypeEnum.FLAVOR && (
                <View style={styles.formGroup}>
                  <Text style={styles.label}>Ingredientes del sabor</Text>
                  <Controller
                    control={control}
                    name="ingredients"
                    render={({ field: { onChange, onBlur, value } }) => (
                      <TextInput
                        placeholder="Ej: Jamn, Pia, Queso"
                        value={value || ''}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.ingredients}
                        mode="outlined"
                        multiline
                        numberOfLines={2}
                        outlineColor={theme.colors.outline}
                        activeOutlineColor={theme.colors.primary}
                        style={styles.inputStyle}
                        outlineStyle={styles.inputOutline}
                      />
                    )}
                  />
                  {errors.ingredients && (
                    <HelperText type="error" visible={!!errors.ingredients}>
                      {errors.ingredients.message}
                    </HelperText>
                  )}
                </View>
              )}

              <View style={styles.row}>
                <View style={styles.halfWidth}>
                  <Text style={styles.label}>Valor del topping</Text>
                  <Controller
                    control={control}
                    name="toppingValue"
                    render={({ field: { onChange, onBlur, value } }) => (
                      <TextInput
                        placeholder="0"
                        value={value?.toString() || ''}
                        onChangeText={(text) => {
                          const num = parseInt(text, 10);
                          onChange(isNaN(num) ? 0 : num);
                        }}
                        onBlur={onBlur}
                        error={!!errors.toppingValue}
                        mode="outlined"
                        keyboardType="numeric"
                        outlineColor={theme.colors.outline}
                        activeOutlineColor={theme.colors.primary}
                        style={styles.inputStyle}
                        outlineStyle={styles.inputOutline}
                      />
                    )}
                  />
                  {errors.toppingValue && (
                    <HelperText type="error" visible={!!errors.toppingValue}>
                      {errors.toppingValue.message}
                    </HelperText>
                  )}
                </View>

                <View style={styles.halfWidth}>
                  <Text style={styles.label}>Orden de aparicin</Text>
                  <Controller
                    control={control}
                    name="sortOrder"
                    render={({ field: { onChange, onBlur, value } }) => (
                      <TextInput
                        placeholder="100"
                        value={value?.toString() || ''}
                        onChangeText={(text) => {
                          const num = parseInt(text, 10);
                          onChange(isNaN(num) ? 0 : num);
                        }}
                        onBlur={onBlur}
                        error={!!errors.sortOrder}
                        mode="outlined"
                        keyboardType="numeric"
                        outlineColor={theme.colors.outline}
                        activeOutlineColor={theme.colors.primary}
                        style={styles.inputStyle}
                        outlineStyle={styles.inputOutline}
                      />
                    )}
                  />
                  {errors.sortOrder && (
                    <HelperText type="error" visible={!!errors.sortOrder}>
                      {errors.sortOrder.message}
                    </HelperText>
                  )}
                </View>
              </View>

              <Controller
                control={control}
                name="isActive"
                render={({ field: { onChange, value } }) => (
                  <View style={styles.switchRow}>
                    <Text style={styles.switchLabel}>Activo</Text>
                    <Switch
                      value={value}
                      onValueChange={onChange}
                      color={theme.colors.primary}
                    />
                  </View>
                )}
              />
            </ScrollView>

            <View style={styles.footer}>
              <Button
                mode="contained-tonal"
                onPress={onDismiss}
                disabled={
                  isSubmitting ||
                  createMutation.isPending ||
                  updateMutation.isPending
                }
                style={styles.button}
                contentStyle={styles.buttonContent}
                labelStyle={styles.buttonLabel}
              >
                Cancelar
              </Button>
              <Button
                mode="contained"
                onPress={handleSubmit(onSubmit)}
                loading={
                  isSubmitting ||
                  createMutation.isPending ||
                  updateMutation.isPending
                }
                disabled={
                  isSubmitting ||
                  createMutation.isPending ||
                  updateMutation.isPending
                }
                style={[
                  styles.button,
                  { backgroundColor: theme.colors.primary },
                ]}
                contentStyle={styles.buttonContent}
                labelStyle={styles.buttonLabel}
                icon={isEditMode ? 'check' : 'plus'}
              >
                {isEditMode ? 'Guardar' : 'Crear'}
              </Button>
            </View>
          </Surface>
        </KeyboardAvoidingView>
      </Modal>
    </Portal>
  );
}

================
File: app/src/modules/receipts/components/ReceiptDetailsModal.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, TouchableOpacity } from 'react-native';
import {
  Surface,
  Text,
  Divider,
  IconButton,
  Chip,
  ActivityIndicator,
} from 'react-native-paper';
import { Receipt } from '../schema/receipt.schema';
import { useAppTheme } from '@/app/styles/theme';
import { ResponsiveModal } from '@/app/components/responsive/ResponsiveModal';
import {
  CustomizationTypeEnum,
  PizzaHalfEnum,
  CustomizationActionEnum,
} from '@/modules/pizzaCustomizations/schema/pizzaCustomization.schema';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import OrderHistoryModal from '@/modules/shared/components/OrderHistoryModal';
import {
  OrderStatusInfo,
  PreparationStatusInfo,
} from '@/modules/orders/utils/formatters';

interface ReceiptDetailsModalProps {
  visible: boolean;
  onDismiss: () => void;
  receipt: Receipt | null;
  isLoading?: boolean;
}

const formatPizzaCustomizations = (customizations: unknown[]): string => {
  if (!customizations || customizations.length === 0) return '';

  const groupedByHalf = customizations.reduce(
    (acc, curr) => {
      const half =
        curr.half === PizzaHalfEnum.HALF_1
          ? 'HALF_1'
          : curr.half === PizzaHalfEnum.HALF_2
            ? 'HALF_2'
            : 'FULL';

      if (!acc[half]) {
        acc[half] = {
          flavors: [],
          addedIngredients: [],
          removedIngredients: [],
        };
      }

      const name = curr.pizzaCustomization?.name || curr.pizzaCustomizationId;
      const type = curr.pizzaCustomization?.type;

      if (type === 'FLAVOR' || type === CustomizationTypeEnum.FLAVOR) {
        acc[half].flavors.push(name);
      } else if (
        type === 'INGREDIENT' ||
        type === CustomizationTypeEnum.INGREDIENT
      ) {
        if (curr.action === CustomizationActionEnum.ADD) {
          acc[half].addedIngredients.push(name);
        } else {
          acc[half].removedIngredients.push(name);
        }
      }

      return acc;
    },
    {} as Record<
      string,
      {
        flavors: string[];
        addedIngredients: string[];
        removedIngredients: string[];
      }
    >,
  );

  if (groupedByHalf.FULL) {
    const parts: string[] = [];
    if (groupedByHalf.FULL.flavors.length > 0) {
      parts.push(groupedByHalf.FULL.flavors.join(', '));
    }
    if (groupedByHalf.FULL.addedIngredients.length > 0) {
      parts.push(`con: ${groupedByHalf.FULL.addedIngredients.join(', ')}`);
    }
    if (groupedByHalf.FULL.removedIngredients.length > 0) {
      parts.push(`sin: ${groupedByHalf.FULL.removedIngredients.join(', ')}`);
    }
    return parts.join(' - ');
  } else if (groupedByHalf.HALF_1 || groupedByHalf.HALF_2) {
    const formatHalf = (halfData: {
      flavors: string[];
      addedIngredients: string[];
      removedIngredients: string[];
    }) => {
      const parts: string[] = [];
      if (halfData.flavors.length > 0) {
        parts.push(halfData.flavors.join(', '));
      }
      if (halfData.addedIngredients.length > 0) {
        parts.push(`con: ${halfData.addedIngredients.join(', ')}`);
      }
      if (halfData.removedIngredients.length > 0) {
        parts.push(`sin: ${halfData.removedIngredients.join(', ')}`);
      }
      return parts.join(' - ');
    };

    const half1 = groupedByHalf.HALF_1 ? formatHalf(groupedByHalf.HALF_1) : '';
    const half2 = groupedByHalf.HALF_2 ? formatHalf(groupedByHalf.HALF_2) : '';

    return half1 && half2 ? `(${half1} / ${half2})` : half1 || half2;
  }

  return '';
};

export const ReceiptDetailsModal: React.FC<ReceiptDetailsModalProps> = ({
  visible,
  onDismiss,
  receipt,
  isLoading = false,
}) => {
  const theme = useAppTheme();
  const [showPrintHistory, setShowPrintHistory] = useState(false);
  const [showOrderHistory, setShowOrderHistory] = useState(false);

  if (!receipt && !isLoading) return null;

  const getOrderTypeLabel = (type: string) => {
    switch (type) {
      case 'DINE_IN':
        return ' Local';
      case 'TAKE_AWAY':
        return ' Llevar';
      case 'DELIVERY':
        return ' Envo';
      default:
        return type;
    }
  };

  const getPaymentStatus = () => {
    if (receipt?.payments && receipt.payments.length > 0) {
      const totalPaid = receipt.payments.reduce((sum, p) => sum + p.amount, 0);
      const totalAmount =
        typeof receipt.total === 'string'
          ? parseFloat(receipt.total)
          : receipt.total || 0;

      if (totalPaid >= totalAmount) {
        return { label: 'Pagado', color: '#10B981' };
      } else if (totalPaid > 0) {
        return { label: 'Parcial', color: '#F59E0B' };
      }
    }
    return { label: 'Pendiente', color: '#EF4444' };
  };

  if (isLoading || !receipt) {
    return (
      <ResponsiveModal
        visible={visible}
        onDismiss={onDismiss}
        title="Cargando..."
      >
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
          <Text
            style={[
              styles.loadingText,
              { color: theme.colors.onSurfaceVariant },
            ]}
          >
            Cargando detalles del recibo...
          </Text>
        </View>
      </ResponsiveModal>
    );
  }

  const paymentStatus = getPaymentStatus();

  const headerActions = (
    <IconButton
      icon="history"
      size={24}
      onPress={() => setShowOrderHistory(true)}
      style={styles.historyButton}
    />
  );

  const modalTitle = `Recibo #${receipt?.shiftOrderNumber || ''}  ${getOrderTypeLabel(receipt?.orderType || '')}`;

  const footerContent = (
    <View style={styles.footer}>
      <View style={styles.footerLeft}>
        <Text
          style={[styles.totalLabel, { color: theme.colors.onSurfaceVariant }]}
        >
          Total:
        </Text>
        <Text style={[styles.totalAmount, { color: theme.colors.primary }]}>
          $
          {receipt
            ? typeof receipt.total === 'string'
              ? parseFloat(receipt.total).toFixed(2)
              : (receipt.total || 0).toFixed(2)
            : '0.00'}
        </Text>
      </View>
      <View
        style={[styles.paymentBadge, { backgroundColor: paymentStatus.color }]}
      >
        <Text style={styles.paymentBadgeText}> {paymentStatus.label}</Text>
      </View>
    </View>
  );

  const renderItem = (item: Receipt['orderItems'][0]) => {
    const quantity = item.quantity || 1;
    const unitPrice =
      typeof item.finalPrice === 'string'
        ? parseFloat(item.finalPrice)
        : item.finalPrice;
    const totalPrice = unitPrice * quantity;
    const statusColor = PreparationStatusInfo.getColor(
      item.preparationStatus,
      theme,
    );

    return (
      <Surface
        key={`${item.id}`}
        style={[
          styles.itemCard,
          styles.itemCardWithBackground,
          { backgroundColor: theme.colors.elevation.level1 },
        ]}
        elevation={1}
      >
        <View style={styles.itemContent}>
          <View style={styles.itemHeader}>
            <View style={styles.nameContainer}>
              <Text
                style={[styles.itemQuantity, { color: theme.colors.primary }]}
              >
                {quantity}x
              </Text>
              <Text
                style={[styles.itemName, { color: theme.colors.onSurface }]}
                numberOfLines={1}
              >
                {item.productVariant?.name || item.product.name}
              </Text>
            </View>
            {item.preparationStatus && (
              <View
                style={[styles.statusChip, { backgroundColor: statusColor }]}
              >
                <Text style={styles.statusChipText}>
                  {PreparationStatusInfo.getLabel(item.preparationStatus)}
                </Text>
              </View>
            )}
          </View>

          <View style={styles.itemDetailsContainer}>
            {item.selectedPizzaCustomizations &&
              item.selectedPizzaCustomizations.length > 0 && (
                <View style={styles.customizationContainer}>
                  <Text
                    style={[
                      styles.pizzaCustomizationText,
                      { color: theme.colors.onSurfaceVariant },
                    ]}
                  >
                    {formatPizzaCustomizations(
                      item.selectedPizzaCustomizations,
                    )}
                  </Text>
                </View>
              )}

            {item.productModifiers && item.productModifiers.length > 0 && (
              <View style={styles.modifiersContainer}>
                {item.productModifiers.map((modifier) => (
                  <View key={modifier.id} style={styles.modifierRow}>
                    <Text
                      style={[
                        styles.modifierText,
                        { color: theme.colors.onSurfaceVariant },
                      ]}
                    >
                       {modifier.name}
                    </Text>
                    {modifier.price && Number(modifier.price) > 0 && (
                      <Text
                        style={[
                          styles.modifierPrice,
                          { color: theme.colors.tertiary },
                        ]}
                      >
                        +${Number(modifier.price).toFixed(2)}
                      </Text>
                    )}
                  </View>
                ))}
              </View>
            )}

            {item.preparationNotes && (
              <View style={styles.notesContainer}>
                <Text
                  style={[
                    styles.notesText,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                   {item.preparationNotes}
                </Text>
              </View>
            )}
          </View>

          <View style={styles.priceContainer}>
            <View style={styles.priceRow}>
              <Text
                style={[
                  styles.priceLabel,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                P. unitario:
              </Text>
              <Text
                style={[styles.priceValue, { color: theme.colors.onSurface }]}
              >
                ${unitPrice.toFixed(2)}
              </Text>
            </View>
            {item.quantity > 1 && (
              <View style={styles.priceRow}>
                <Text
                  style={[
                    styles.priceLabel,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                  Total {item.quantity}:
                </Text>
                <Text
                  style={[styles.totalPrice, { color: theme.colors.primary }]}
                >
                  ${totalPrice.toFixed(2)}
                </Text>
              </View>
            )}
          </View>
        </View>
      </Surface>
    );
  };

  return (
    <>
      <ResponsiveModal
        visible={visible}
        onDismiss={onDismiss}
        title={modalTitle}
        headerActions={headerActions}
        maxHeightTablet="90%"
        scrollable={true}
        footer={footerContent}
        footerStyle={styles.footerNoPadding}
      >
        <View style={styles.headerInfo}>
          <View style={styles.chipsRow}>
            <View
              style={[
                styles.headerStatusChip,
                {
                  backgroundColor: OrderStatusInfo.getColor(
                    receipt.orderStatus,
                    theme,
                  ),
                },
              ]}
            >
              <Text style={styles.headerStatusChipText}>
                {OrderStatusInfo.getLabel(receipt.orderStatus)}
              </Text>
            </View>
            {receipt.preparationScreens &&
              receipt.preparationScreens.map((screen, index) => (
                <Chip
                  key={index}
                  mode="outlined"
                  compact
                  style={styles.screenChip}
                  textStyle={styles.screenChipText}
                >
                   {screen}
                </Chip>
              ))}
          </View>
          <View style={styles.headerDatesRow}>
            <Text
              style={[
                styles.headerDate,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Creado:{' '}
              {receipt.createdAt
                ? format(new Date(receipt.createdAt), 'dd/MM/yyyy HH:mm', {
                    locale: es,
                  })
                : ''}
            </Text>
            {receipt.finalizedAt && (
              <Text
                style={[styles.headerDate, { color: theme.colors.primary }]}
              >
                Finalizado:{' '}
                {format(new Date(receipt.finalizedAt), 'dd/MM/yyyy HH:mm', {
                  locale: es,
                })}
              </Text>
            )}
          </View>
        </View>

        <View style={styles.infoSection}>
          {receipt.deliveryInfo?.recipientName && (
            <View style={styles.infoRow}>
              <Text
                style={[styles.contactText, { color: theme.colors.onSurface }]}
              >
                 Nombre del Cliente: {receipt.deliveryInfo.recipientName}
              </Text>
            </View>
          )}

          {receipt.deliveryInfo?.recipientPhone && (
            <View style={styles.infoRow}>
              <Text
                style={[styles.contactText, { color: theme.colors.onSurface }]}
              >
                 Telfono: {receipt.deliveryInfo.recipientPhone}
              </Text>
            </View>
          )}

          {receipt.orderType === 'DELIVERY' &&
            receipt.deliveryInfo?.fullAddress && (
              <View style={styles.infoRow}>
                <Text
                  style={[
                    styles.addressText,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                >
                   Direccin de Entrega: {receipt.deliveryInfo.fullAddress}
                </Text>
              </View>
            )}

          {receipt.orderType === 'DINE_IN' && receipt.table && (
            <View style={styles.infoRow}>
              <Text
                style={[styles.tableText, { color: theme.colors.onSurface }]}
              >
                 Mesa: {receipt.table.area?.name || 'Sin rea'} -{' '}
                {receipt.table.number}
              </Text>
            </View>
          )}

          {receipt.scheduledAt && (
            <View style={styles.infoRow}>
              <Text
                style={[
                  styles.contactText,
                  styles.scheduledTimeText,
                  { color: theme.colors.primary },
                ]}
              >
                 Hora de Entrega Programada:{' '}
                {format(new Date(receipt.scheduledAt), 'HH:mm', {
                  locale: es,
                })}
              </Text>
            </View>
          )}

          {receipt.user && (
            <View style={styles.infoRow}>
              <Text
                style={[
                  styles.contactText,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                 Atendido por: {receipt.user.firstName}{' '}
                {receipt.user.lastName}
              </Text>
            </View>
          )}

          {receipt.notes && (
            <View style={styles.infoRow}>
              <Text
                style={[
                  styles.notesText,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                 Notas: {receipt.notes}
              </Text>
            </View>
          )}
        </View>

        <Divider style={styles.divider} />

        <View style={styles.itemsList}>
          {receipt.orderItems?.map((item) => renderItem(item)) || []}
        </View>

        <Divider style={styles.divider} />

        {receipt.payments && receipt.payments.length > 0 && (
          <>
            <View style={styles.paymentsSection}>
              <View style={styles.paymentSummaryCompact}>
                <View style={styles.summaryCompactRow}>
                  <Text
                    style={[
                      styles.summaryCompactLabel,
                      { color: theme.colors.onSurfaceVariant },
                    ]}
                  >
                    Total: $
                    {typeof receipt.total === 'string'
                      ? parseFloat(receipt.total).toFixed(2)
                      : (receipt.total || 0).toFixed(2)}
                  </Text>
                  <Text
                    style={[styles.summaryCompactLabel, styles.paidAmountText]}
                  >
                    Pagado: $
                    {receipt.payments
                      .reduce((sum, p) => sum + p.amount, 0)
                      .toFixed(2)}
                  </Text>
                  {(() => {
                    const totalAmount =
                      typeof receipt.total === 'string'
                        ? parseFloat(receipt.total)
                        : receipt.total || 0;
                    const totalPaid = receipt.payments.reduce(
                      (sum, p) => sum + p.amount,
                      0,
                    );
                    const remaining = totalAmount - totalPaid;
                    if (remaining > 0) {
                      return (
                        <Text
                          style={[
                            styles.summaryCompactLabel,
                            styles.remainingAmountText,
                            { color: theme.colors.error },
                          ]}
                        >
                          Resta: ${remaining.toFixed(2)}
                        </Text>
                      );
                    }
                    return null;
                  })()}
                </View>
              </View>

              {receipt.payments.map((payment, index) => {
                const getPaymentMethodLabel = (method: string) => {
                  switch (method) {
                    case 'CASH':
                    case 'cash':
                      return 'Efectivo';
                    case 'CREDIT_CARD':
                    case 'card':
                      return 'Tarjeta de Crdito';
                    case 'DEBIT_CARD':
                      return 'Tarjeta de Dbito';
                    case 'TRANSFER':
                    case 'transfer':
                      return 'Transferencia';
                    case 'OTHER':
                      return 'Otro';
                    default:
                      return method;
                  }
                };

                const getPaymentStatusColor = (status: string) => {
                  switch (status) {
                    case 'COMPLETED':
                      return '#10B981';
                    case 'PENDING':
                      return '#F59E0B';
                    case 'FAILED':
                      return theme.colors.error;
                    case 'REFUNDED':
                      return '#6B7280';
                    case 'CANCELLED':
                      return theme.colors.error;
                    default:
                      return theme.colors.onSurfaceVariant;
                  }
                };

                const getPaymentStatusLabel = (status: string) => {
                  switch (status) {
                    case 'COMPLETED':
                      return 'Completado';
                    case 'PENDING':
                      return 'Pendiente';
                    case 'FAILED':
                      return 'Fallido';
                    case 'REFUNDED':
                      return 'Reembolsado';
                    case 'CANCELLED':
                      return 'Cancelado';
                    default:
                      return status;
                  }
                };

                return (
                  <View
                    key={payment.id || index}
                    style={styles.paymentRowCompact}
                  >
                    <Text
                      style={[
                        styles.paymentMethodCompact,
                        { color: theme.colors.onSurface },
                      ]}
                    >
                       {getPaymentMethodLabel(payment.paymentMethod)}
                    </Text>
                    <Text
                      style={[
                        styles.paymentDateCompact,
                        { color: theme.colors.onSurfaceVariant },
                      ]}
                    >
                      {format(new Date(payment.createdAt), 'HH:mm', {
                        locale: es,
                      })}
                    </Text>
                    <View
                      style={[
                        styles.paymentStatusBadgeCompact,
                        {
                          backgroundColor:
                            getPaymentStatusColor(payment.paymentStatus) + '20',
                        },
                      ]}
                    >
                      <Text
                        style={[
                          styles.paymentStatusTextCompact,
                          {
                            color: getPaymentStatusColor(payment.paymentStatus),
                          },
                        ]}
                      >
                        {getPaymentStatusLabel(payment.paymentStatus)}
                      </Text>
                    </View>
                    <Text
                      style={[
                        styles.paymentAmountCompact,
                        { color: theme.colors.primary },
                      ]}
                    >
                      ${payment.amount.toFixed(2)}
                    </Text>
                  </View>
                );
              })}
            </View>
            <Divider style={styles.divider} />
          </>
        )}

        {receipt.ticketImpressions && receipt.ticketImpressions.length > 0 && (
          <>
            <View style={styles.ticketImpressionsSection}>
              <TouchableOpacity
                style={styles.collapsibleHeader}
                onPress={() => setShowPrintHistory(!showPrintHistory)}
                activeOpacity={0.7}
              >
                <Text
                  style={[styles.sectionTitle, { color: theme.colors.primary }]}
                >
                   Historial de Impresiones (
                  {receipt.ticketImpressions.length})
                </Text>
                <IconButton
                  icon={showPrintHistory ? 'chevron-up' : 'chevron-down'}
                  size={20}
                  style={styles.collapseIcon}
                />
              </TouchableOpacity>

              {showPrintHistory && (
                <View style={styles.collapsibleContent}>
                  {receipt.ticketImpressions.map((impression, index) => {
                    const getTicketTypeLabel = (type: string) => {
                      switch (type) {
                        case 'KITCHEN':
                          return ' Cocina';
                        case 'BAR':
                          return ' Barra';
                        case 'BILLING':
                          return ' Cuenta';
                        case 'CUSTOMER_COPY':
                          return ' Copia Cliente';
                        case 'GENERAL':
                          return ' General';
                        default:
                          return type;
                      }
                    };

                    return (
                      <View
                        key={impression.id || index}
                        style={styles.impressionRow}
                      >
                        <View style={styles.impressionLeft}>
                          <Text
                            style={[
                              styles.impressionType,
                              { color: theme.colors.onSurface },
                            ]}
                          >
                            {getTicketTypeLabel(impression.ticketType)}
                          </Text>
                          <View style={styles.impressionDetails}>
                            {impression.user && (
                              <Text
                                style={[
                                  styles.impressionUser,
                                  {
                                    color: theme.colors.onSurfaceVariant,
                                  },
                                ]}
                              >
                                por {impression.user.firstName || ''}{' '}
                                {impression.user.lastName || ''}
                              </Text>
                            )}
                            {impression.printer && (
                              <Text
                                style={[
                                  styles.impressionPrinter,
                                  {
                                    color: theme.colors.onSurfaceVariant,
                                  },
                                ]}
                              >
                                 {impression.printer.name}
                              </Text>
                            )}
                          </View>
                        </View>
                        <Text
                          style={[
                            styles.impressionTime,
                            {
                              color: theme.colors.onSurfaceVariant,
                            },
                          ]}
                        >
                          {format(
                            new Date(impression.impressionTime),
                            'HH:mm:ss',
                            { locale: es },
                          )}
                        </Text>
                      </View>
                    );
                  })}
                </View>
              )}
            </View>
          </>
        )}
      </ResponsiveModal>

      {receipt && (
        <OrderHistoryModal
          visible={showOrderHistory}
          onDismiss={() => setShowOrderHistory(false)}
          orderId={receipt.id}
        />
      )}
    </>
  );
};

const styles = StyleSheet.create({
  loadingContainer: {
    minHeight: 200,
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 40,
  },
  loadingText: {
    marginTop: 16,
    fontSize: 14,
  },
  historyButton: {
    margin: -8,
  },
  headerInfo: {
    paddingBottom: 16,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(0,0,0,0.08)',
    marginBottom: 16,
  },
  chipsRow: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
    flexWrap: 'wrap',
    marginBottom: 8,
  },
  headerStatusChip: {
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 10,
  },
  headerStatusChipText: {
    color: 'white',
    fontSize: 11,
    fontWeight: '600',
  },
  screenChip: {
    height: 20,
  },
  screenChipText: {
    fontSize: 10,
    marginVertical: -2,
  },
  headerDatesRow: {
    gap: 8,
  },
  headerDate: {
    fontSize: 11,
  },
  infoSection: {
    gap: 4,
    marginBottom: 16,
  },
  infoRow: {
    marginVertical: 2,
  },
  contactText: {
    fontSize: 12,
  },
  addressText: {
    fontSize: 12,
    lineHeight: 16,
  },
  tableText: {
    fontSize: 12,
  },
  divider: {
    marginVertical: 2,
  },
  itemsList: {
    marginBottom: 16,
  },
  itemCard: {
    borderRadius: 8,
    overflow: 'hidden',
  },
  itemContent: {
    padding: 10,
  },
  itemHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 6,
  },
  nameContainer: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    marginRight: 8,
  },
  itemQuantity: {
    fontSize: 14,
    fontWeight: '700',
    marginRight: 6,
  },
  itemName: {
    fontSize: 13,
    fontWeight: '600',
    flex: 1,
    lineHeight: 16,
  },
  statusChip: {
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 12,
  },
  statusChipText: {
    color: 'white',
    fontSize: 10,
    fontWeight: '600',
  },
  itemDetailsContainer: {
    marginBottom: 6,
  },
  customizationContainer: {
    marginBottom: 4,
  },
  pizzaCustomizationText: {
    fontSize: 11,
    fontStyle: 'italic',
    lineHeight: 14,
  },
  modifiersContainer: {
    marginTop: 2,
  },
  modifierRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 1,
  },
  modifierText: {
    fontSize: 11,
    flex: 1,
    lineHeight: 14,
  },
  modifierPrice: {
    fontSize: 11,
    fontWeight: '500',
    marginLeft: 4,
  },
  notesContainer: {
    marginTop: 4,
    paddingTop: 4,
    borderTopWidth: 1,
    borderTopColor: 'rgba(0,0,0,0.06)',
  },
  notesText: {
    fontSize: 11,
    fontStyle: 'italic',
    lineHeight: 14,
  },
  priceContainer: {
    marginTop: 6,
    paddingTop: 6,
    borderTopWidth: 1,
    borderTopColor: 'rgba(0,0,0,0.06)',
  },
  priceRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 2,
  },
  priceLabel: {
    fontSize: 11,
    opacity: 0.7,
  },
  priceValue: {
    fontSize: 12,
    fontWeight: '600',
  },
  totalPrice: {
    fontSize: 14,
    fontWeight: '700',
  },
  paymentsSection: {
    marginBottom: 16,
  },
  paymentSummaryCompact: {
    marginBottom: 8,
  },
  summaryCompactRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  summaryCompactLabel: {
    fontSize: 12,
    fontWeight: '500',
  },
  paymentRowCompact: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 6,
    gap: 8,
  },
  paymentMethodCompact: {
    fontSize: 11,
    fontWeight: '500',
    flex: 1,
  },
  paymentDateCompact: {
    fontSize: 10,
  },
  paymentAmountCompact: {
    fontSize: 12,
    fontWeight: '600',
    minWidth: 50,
    textAlign: 'right',
  },
  paymentStatusBadgeCompact: {
    paddingHorizontal: 6,
    paddingVertical: 1,
    borderRadius: 10,
  },
  paymentStatusTextCompact: {
    fontSize: 9,
    fontWeight: '600',
  },
  ticketImpressionsSection: {
    marginBottom: 16,
  },
  collapsibleHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingRight: 4,
  },
  collapseIcon: {
    margin: -8,
  },
  collapsibleContent: {
    marginTop: 8,
  },
  sectionTitle: {
    fontSize: 14,
    fontWeight: '600',
    marginBottom: 0,
  },
  impressionRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
    paddingLeft: 8,
  },
  impressionLeft: {
    flex: 1,
    gap: 2,
  },
  impressionType: {
    fontSize: 12,
    fontWeight: '500',
  },
  impressionDetails: {
    gap: 2,
  },
  impressionUser: {
    fontSize: 11,
    opacity: 0.7,
  },
  impressionPrinter: {
    fontSize: 11,
    opacity: 0.7,
    fontStyle: 'italic',
  },
  impressionTime: {
    fontSize: 11,
    opacity: 0.7,
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  footerLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  totalLabel: {
    fontSize: 14,
    fontWeight: '600',
  },
  totalAmount: {
    fontSize: 16,
    fontWeight: '700',
  },
  paymentBadge: {
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 12,
  },
  paymentBadgeText: {
    color: 'white',
    fontSize: 12,
    fontWeight: '600',
  },
  itemCardWithBackground: {
    marginBottom: 8,
  },
  footerNoPadding: {
    paddingTop: 0,
  },
  scheduledTimeText: {
    fontWeight: '600',
  },
  paidAmountText: {
    color: '#10B981',
  },
  remainingAmountText: {
    fontWeight: '600',
  },
});

================
File: app/src/modules/settings/screens/ServerSettingsScreen.tsx
================
import React, { useEffect, useState, useCallback } from 'react';
import { ScrollView, View, StyleSheet, ActivityIndicator } from 'react-native';
import {
  Text,
  RadioButton,
  TextInput,
  Button,
  HelperText,
  Portal,
  Dialog,
  Paragraph,
  IconButton,
  Chip,
  Surface,
  Icon,
  TouchableRipple,
  ProgressBar,
} from 'react-native-paper';
import { useSnackbar } from '@/hooks/useSnackbar';
import {
  serverConnectionService,
  ConnectionMode,
} from '@/services/serverConnectionService';
import { discoveryService } from '@/app/services/discoveryService';
import EncryptedStorage from '@/app/services/secureStorageService';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive, ResponsiveInfo } from '@/app/hooks/useResponsive';
import { useServerConnection } from '@/app/hooks/useServerConnection';

const STORAGE_KEYS = {
  CONNECTION_MODE: 'connection_mode',
  MANUAL_URL: 'manual_server_url',
} as const;

interface DiscoveryProgress {
  current: number;
  total: number;
  message: string;
}

export function ServerSettingsScreen() {
  const { showSnackbar } = useSnackbar();
  const theme = useAppTheme();
  const responsive = useResponsive();
  const { isConnected, isHealthy, serverUrl, isSearching } =
    useServerConnection();

  const [mode, setMode] = useState<ConnectionMode>('auto');
  const [manualUrl, setManualUrl] = useState('');
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [showInfo, setShowInfo] = useState(false);
  const [isDiscovering, setIsDiscovering] = useState(false);
  const [discoveryProgress, setDiscoveryProgress] = useState<DiscoveryProgress>(
    {
      current: 0,
      total: 0,
      message: '',
    },
  );

  const loadSettings = useCallback(async () => {
    try {
      const [savedMode, savedUrl] = await Promise.all([
        EncryptedStorage.getItem(
          STORAGE_KEYS.CONNECTION_MODE,
        ) as Promise<ConnectionMode>,
        EncryptedStorage.getItem(STORAGE_KEYS.MANUAL_URL),
      ]);

      if (savedMode) setMode(savedMode);

      // Si hay una URL de servidor actual (de cualquier fuente), usarla para el campo manual
      if (serverUrl) {
        try {
          const url = new URL(serverUrl);
          setManualUrl(url.hostname);
        } catch {
          // Si no es una URL vlida, intentar extraer la IP
          const cleanUrl = serverUrl.replace(/^https?:\/\//, '').split(':')[0];
          setManualUrl(cleanUrl);
        }
      } else if (savedUrl) {
        // Si no hay servidor actual pero s una URL manual guardada, usarla
        try {
          const url = new URL(savedUrl);
          setManualUrl(url.hostname);
        } catch {
          // Si no es una URL vlida, usar como est
          setManualUrl(savedUrl);
        }
      }
    } catch (error: unknown) {
    } finally {
      setLoading(false);
    }
  }, [serverUrl]);

  useEffect(() => {
    loadSettings();
  }, [loadSettings]);

  useEffect(() => {
    if (serverUrl && !loading) {
      try {
        const url = new URL(serverUrl);
        setManualUrl(url.hostname);
      } catch {
        // Si no es una URL vlida, intentar extraer la IP
        const cleanUrl = serverUrl.replace(/^https?:\/\//, '').split(':')[0];
        setManualUrl(cleanUrl);
      }
    }
  }, [serverUrl, loading]);

  const validateUrl = (url: string): boolean => {
    // Validar que sea una IP vlida o un dominio
    const ipRegex = /^(\d{1,3}\.){3}\d{1,3}$/;
    const domainRegex =
      /^[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9](?:\.[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])*$/;

    // Quitar espacios
    const trimmed = url.trim();

    // No debe incluir protocolo ni puerto
    if (
      trimmed.includes('http://') ||
      trimmed.includes('https://') ||
      trimmed.includes(':')
    ) {
      return false;
    }

    return ipRegex.test(trimmed) || domainRegex.test(trimmed);
  };

  const saveSettings = async () => {
    setSaving(true);
    try {
      if (mode === 'manual') {
        if (!validateUrl(manualUrl)) {
          showSnackbar('Por favor ingresa una URL vlida', 'error');
          setSaving(false);
          return;
        }
      }

      await EncryptedStorage.setItem(STORAGE_KEYS.CONNECTION_MODE, mode);

      if (mode === 'manual') {
        const fullUrl = `http://${manualUrl.trim()}:3737`;
        await EncryptedStorage.setItem(STORAGE_KEYS.MANUAL_URL, fullUrl);
      }

      if (mode === 'manual') {
        const fullUrl = `http://${manualUrl.trim()}:3737`;
        await discoveryService.setServerUrl(fullUrl, true);
      } else if (mode === 'auto') {
        await discoveryService.setServerUrl(null, true);
      }

      await serverConnectionService.setConnectionMode(mode);

      if (mode === 'auto') {
        setIsDiscovering(true);
        showSnackbar('Iniciando bsqueda de servidor...', 'info');

        try {
          await discoveryService.setServerUrl(null, true);

          discoveryService.setProgressCallback((progress) => {
            setDiscoveryProgress(progress);
          });

          const discoveredUrl = await discoveryService.discoverServer();

          if (discoveredUrl) {
            showSnackbar('Servidor encontrado ', 'success');
            const { healthMonitoringService } = await import(
              '@/services/healthMonitoringService'
            );
            healthMonitoringService.startMonitoring();
          } else {
            showSnackbar('No se encontr servidor en la red', 'error');
          }
        } catch (error: unknown) {
          showSnackbar('Error al buscar servidor', 'error');
        } finally {
          setIsDiscovering(false);
          discoveryService.setProgressCallback(null);
          setDiscoveryProgress({ current: 0, total: 0, message: '' });
        }
      } else {
        showSnackbar('Aplicando configuracin...', 'info');

        try {
          await serverConnectionService.reconnect();

          showSnackbar('Configuracin guardada - Conectado ', 'success');
        } catch (error: unknown) {
          showSnackbar('Verificando conexin...', 'info');

          const { healthMonitoringService } = await import(
            '@/services/healthMonitoringService'
          );

          try {
            const isHealthy = await healthMonitoringService.forceCheck();

            if (isHealthy) {
              showSnackbar(
                'Configuracin guardada - Servidor accesible ',
                'success',
              );
              healthMonitoringService.startMonitoring();
            } else {
              showSnackbar(
                'Configuracin guardada - El servidor no responde ',
                'warning',
              );
            }
          } catch (error: unknown) {
            showSnackbar(
              'Configuracin guardada - Error al verificar servidor',
              'warning',
            );
          }
        }
      }
    } catch (error: unknown) {
      const message =
        error instanceof Error
          ? error.message
          : 'Error al guardar la configuracin';
      showSnackbar(message, 'error');
    } finally {
      setSaving(false);
    }
  };

  const renderConnectionStatus = () => {
    let chipIcon = 'alert-circle';
    let chipText = 'Sin conexin';
    let chipColor = theme.colors.error;
    let chipBgColor = theme.dark
      ? 'rgba(244, 67, 54, 0.2)'
      : 'rgba(244, 67, 54, 0.1)';

    if (isSearching) {
      chipIcon = 'wifi-sync';
      chipText = 'Buscando...';
      chipColor = theme.colors.warning || '#FF9800';
      chipBgColor = theme.dark
        ? 'rgba(255, 152, 0, 0.2)'
        : 'rgba(255, 152, 0, 0.1)';
    } else if (isConnected && isHealthy) {
      chipIcon = 'check-circle';
      chipText = 'Conectado';
      chipColor = theme.colors.success || '#4CAF50';
      chipBgColor = theme.dark
        ? 'rgba(76, 175, 80, 0.2)'
        : 'rgba(76, 175, 80, 0.1)';
    }

    return (
      <Chip
        icon={chipIcon}
        mode="flat"
        compact
        style={{
          backgroundColor: chipBgColor,
          transform: [{ scale: 0.85 }],
        }}
        textStyle={[styles.chipText, { color: chipColor }]}
      >
        {chipText}
      </Chip>
    );
  };

  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </View>
    );
  }

  return (
    <ScrollView
      style={styles.container}
      contentContainerStyle={styles.scrollContent}
    >
      {/* Estado de Conexin */}
      <View style={styles.section}>
        <View style={styles.sectionHeader}>
          <Text style={styles.sectionTitle}>Estado de Conexin</Text>
          {renderConnectionStatus()}
          <View style={styles.spacer} />
          <IconButton
            icon="information"
            size={20}
            onPress={() => setShowInfo(true)}
            iconColor={theme.colors.onSurfaceVariant}
          />
        </View>

        <View>
          <Surface style={styles.infoCard} elevation={0}>
            <View style={styles.infoRow}>
              <View style={styles.infoItem}>
                <Icon
                  source="server"
                  size={20}
                  color={theme.colors.onSurfaceVariant}
                />
                <View style={styles.infoContent}>
                  <Text variant="labelSmall" style={styles.infoLabel}>
                    Servidor
                  </Text>
                  <Text variant="bodyMedium" style={styles.infoValue}>
                    {serverUrl
                      ? serverUrl.replace(/^https?:\/\//, '').split(':')[0]
                      : '-'}
                  </Text>
                </View>
              </View>

              <View style={styles.infoDivider} />

              <View style={styles.infoItem}>
                <Icon
                  source="ethernet-cable"
                  size={20}
                  color={theme.colors.onSurfaceVariant}
                />
                <View style={styles.infoContent}>
                  <Text variant="labelSmall" style={styles.infoLabel}>
                    Puerto
                  </Text>
                  <Text variant="bodyMedium" style={styles.infoValue}>
                    {serverUrl
                      ? serverUrl.split(':').pop()?.split('/')[0] || '3737'
                      : '3737'}
                  </Text>
                </View>
              </View>
            </View>

            {serverUrl && !isHealthy && isConnected && (
              <View style={styles.healthWarning}>
                <Icon
                  source="alert"
                  size={16}
                  color={theme.colors.warning || '#FF9800'}
                />
                <Text variant="labelSmall" style={styles.healthWarningText}>
                  El servidor no responde correctamente
                </Text>
              </View>
            )}
          </Surface>
        </View>
      </View>

      {/* Modo de Conexin */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Modo de Conexin</Text>

        <RadioButton.Group
          onValueChange={(value) => setMode(value as ConnectionMode)}
          value={mode}
        >
          <TouchableRipple
            onPress={() => setMode('auto')}
            style={[
              styles.radioOption,
              mode === 'auto' && styles.radioOptionActive,
            ]}
            rippleColor={`${theme.colors.primary}20`}
          >
            <View style={styles.radioContent}>
              <Icon
                source="wifi"
                size={24}
                color={
                  mode === 'auto'
                    ? theme.colors.primary
                    : theme.colors.onSurfaceVariant
                }
              />
              <View style={styles.radioTextContainer}>
                <Text
                  variant="titleMedium"
                  style={[
                    styles.radioTitle,
                    mode === 'auto' && { color: theme.colors.primary },
                  ]}
                >
                  Automtico
                </Text>
                <Text variant="bodySmall" style={styles.radioSubtitle}>
                  Busca el servidor en tu red local
                </Text>
              </View>
              <RadioButton
                value="auto"
                status={mode === 'auto' ? 'checked' : 'unchecked'}
              />
            </View>
          </TouchableRipple>

          <TouchableRipple
            onPress={() => setMode('manual')}
            style={[
              styles.radioOption,
              mode === 'manual' && styles.radioOptionActive,
              styles.lastInput,
            ]}
            rippleColor={`${theme.colors.primary}20`}
          >
            <View>
              <View style={styles.radioContent}>
                <Icon
                  source="pencil-outline"
                  size={24}
                  color={
                    mode === 'manual'
                      ? theme.colors.primary
                      : theme.colors.onSurfaceVariant
                  }
                />
                <View style={styles.radioTextContainer}>
                  <Text
                    variant="titleMedium"
                    style={[
                      styles.radioTitle,
                      mode === 'manual' && { color: theme.colors.primary },
                    ]}
                  >
                    Manual
                  </Text>
                  <Text variant="bodySmall" style={styles.radioSubtitle}>
                    Especifica la URL del servidor
                  </Text>
                </View>
                <RadioButton
                  value="manual"
                  status={mode === 'manual' ? 'checked' : 'unchecked'}
                />
              </View>
              {mode === 'manual' && (
                <View style={styles.manualInputContainer}>
                  <TextInput
                    label="Direccin IP o Dominio"
                    value={manualUrl}
                    onChangeText={setManualUrl}
                    placeholder="192.168.1.100"
                    mode="outlined"
                    autoCapitalize="none"
                    autoCorrect={false}
                    keyboardType="default"
                    error={manualUrl !== '' && !validateUrl(manualUrl)}
                    outlineColor={theme.colors.outline}
                    activeOutlineColor={theme.colors.primary}
                    style={styles.manualInput}
                  />
                  <HelperText
                    type={
                      manualUrl !== '' && !validateUrl(manualUrl)
                        ? 'error'
                        : 'info'
                    }
                    visible={true}
                  >
                    {manualUrl !== '' && !validateUrl(manualUrl)
                      ? 'Ingresa solo la IP (ej: 192.168.1.100) sin http:// ni puerto'
                      : 'Solo la direccin IP sin protocolo. El puerto 3737 se aadir automticamente.'}
                  </HelperText>
                </View>
              )}
            </View>
          </TouchableRipple>
        </RadioButton.Group>
      </View>

      {/* Indicador de progreso del discovery */}
      {isDiscovering && (
        <View style={styles.discoveryProgressContainer}>
          <Surface style={styles.discoveryProgressCard} elevation={1}>
            <View style={styles.discoveryHeader}>
              <Icon
                source="magnify-scan"
                size={24}
                color={theme.colors.primary}
              />
              <Text style={styles.discoveryTitle}>
                Buscando servidor en la red
              </Text>
            </View>
            <ProgressBar
              progress={
                discoveryProgress.total > 0
                  ? discoveryProgress.current / discoveryProgress.total
                  : 0
              }
              color={theme.colors.primary}
              style={styles.progressBar}
            />
            <Text style={styles.discoveryMessage}>
              {discoveryProgress.message || 'Iniciando bsqueda...'}
            </Text>
            {discoveryProgress.total > 0 && (
              <Text style={styles.discoveryStats}>
                {discoveryProgress.current} de {discoveryProgress.total} IPs
                escaneadas
              </Text>
            )}
          </Surface>
        </View>
      )}

      {/* Botn de guardar */}
      <View style={styles.actionButtons}>
        <Button
          mode="contained"
          onPress={saveSettings}
          loading={saving}
          disabled={saving || isDiscovering}
          icon="content-save"
          style={styles.saveButton}
          contentStyle={styles.buttonContent}
          labelStyle={styles.buttonLabel}
        >
          Guardar Configuracin
        </Button>
      </View>

      <Portal>
        <Dialog visible={showInfo} onDismiss={() => setShowInfo(false)}>
          <Dialog.Title>Informacin de Conexin</Dialog.Title>
          <Dialog.Content>
            <Paragraph style={styles.infoParagraph}>
              <Text style={styles.boldText}>Modo Automtico:</Text>
              {'\n'}Ideal para uso en el restaurante. La app busca el servidor
              en la red local.
            </Paragraph>

            <Paragraph style={styles.infoParagraph}>
              <Text style={styles.boldText}>Modo Manual:</Text>
              {'\n'}Configura manualmente la URL del servidor para casos
              especiales.
            </Paragraph>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setShowInfo(false)}>Cerrar</Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </ScrollView>
  );
}

const createStyles = (theme: AppTheme, responsive: ResponsiveInfo) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    scrollContent: {
      paddingBottom: 40,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      backgroundColor: theme.colors.background,
    },
    section: {
      marginHorizontal: 16,
      marginTop: 20,
      marginBottom: 16,
    },
    sectionHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: 16,
    },
    sectionTitle: {
      fontSize: responsive?.isWeb ? 20 : 18,
      fontWeight: '600',
      color: theme.colors.onSurface,
      marginRight: 12,
    },
    infoCard: {
      backgroundColor: theme.dark
        ? theme.colors.surfaceVariant
        : theme.colors.surface,
      borderRadius: 12,
      padding: 20,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
    },
    infoRow: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-around',
    },
    infoItem: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
      gap: 8,
    },
    infoContent: {
      flex: 1,
    },
    infoLabel: {
      color: theme.colors.onSurfaceVariant,
      marginBottom: 2,
      fontSize: responsive?.isWeb ? 12 : 11,
    },
    infoValue: {
      color: theme.colors.onSurface,
      fontWeight: '600',
      fontSize: responsive?.isWeb ? 16 : 14,
    },
    infoDivider: {
      width: 1,
      height: 40,
      backgroundColor: theme.colors.outlineVariant,
      marginHorizontal: 12,
    },
    healthWarning: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 4,
      marginTop: 12,
      paddingTop: 12,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
    },
    healthWarningText: {
      color: theme.colors.warning || '#FF9800',
      flex: 1,
    },
    radioOption: {
      marginBottom: 12,
      borderRadius: 12,
      backgroundColor: theme.colors.surface,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
      overflow: 'hidden',
    },
    radioOptionActive: {
      borderColor: theme.colors.primary,
      backgroundColor: theme.dark
        ? 'rgba(103, 80, 164, 0.08)'
        : 'rgba(103, 80, 164, 0.05)',
    },
    radioContent: {
      flexDirection: 'row',
      alignItems: 'center',
      padding: 16,
      gap: 12,
    },
    radioTextContainer: {
      flex: 1,
    },
    radioTitle: {
      color: theme.colors.onSurface,
      fontWeight: '600',
    },
    radioSubtitle: {
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
    },
    manualInputContainer: {
      paddingTop: 8,
      paddingHorizontal: 16,
      paddingBottom: 12,
    },
    manualInput: {
      backgroundColor: theme.colors.surface,
    },
    actionButtons: {
      marginHorizontal: 16,
      marginTop: 12,
      marginBottom: 20,
    },
    saveButton: {
      backgroundColor: theme.colors.primary,
    },
    buttonContent: {
      paddingVertical: 8,
    },
    buttonLabel: {
      fontSize: responsive?.isWeb ? 16 : 14,
    },
    infoParagraph: {
      marginBottom: 12,
      color: theme.colors.onSurfaceVariant,
      lineHeight: responsive?.isWeb ? 24 : 20,
    },
    boldText: {
      fontWeight: 'bold',
      color: theme.colors.onSurface,
    },
    discoveryProgressContainer: {
      marginHorizontal: 16,
      marginTop: 16,
      marginBottom: 8,
    },
    discoveryProgressCard: {
      backgroundColor: theme.colors.surface,
      borderRadius: 12,
      padding: 16,
      borderWidth: 1,
      borderColor: theme.colors.primary,
    },
    discoveryHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 8,
      marginBottom: 12,
    },
    discoveryTitle: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
      flex: 1,
    },
    progressBar: {
      height: 6,
      borderRadius: 3,
      marginBottom: 12,
    },
    discoveryMessage: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 4,
    },
    discoveryStats: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
    },
    chipText: {
      fontSize: 12,
    },
    spacer: {
      flex: 1,
    },
    lastInput: {
      marginBottom: 0,
    },
  });

================
File: app/src/services/audioOrderService.ts
================
import apiClient from '../app/services/apiClient';
import * as FileSystem from 'expo-file-system';
import { API_PATHS } from '../app/constants/apiPaths';

export interface AIOrderItem {
  productId: string;
  productName?: string;
  variantId?: string;
  variantName?: string;
  quantity: number;
  modifiers?: string[];
  pizzaCustomizations?: Array<{
    customizationId: string;
    customizationName?: string;
    half: 'FULL' | 'HALF_1' | 'HALF_2';
    action: 'ADD' | 'REMOVE';
  }>;
}

export interface DeliveryInfoData {
  fullAddress?: string;
  recipientName?: string;
  recipientPhone?: string;
}

export interface ScheduledDeliveryData {
  time?: string;
}

export interface AudioOrderResponse {
  success: boolean;
  data?: {
    orderItems?: AIOrderItem[];
    deliveryInfo?: DeliveryInfoData;
    scheduledDelivery?: ScheduledDeliveryData;
    orderType?: 'DELIVERY' | 'TAKE_AWAY' | 'DINE_IN';
    warnings?: string;
    processingTime: number;
  };
  error?: {
    code: string;
    message: string;
    type: string;
    timestamp: string;
    requestId: string;
  };
}

class AudioOrderService {
  constructor() {}

  async processAudioOrder(
    audioUri: string,
    transcription: string,
  ): Promise<AudioOrderResponse> {
    try {
      const audioBase64 = await FileSystem.readAsStringAsync(audioUri, {
        encoding: FileSystem.EncodingType.Base64,
      });

      const payload = {
        audioData: audioBase64,
        transcription: transcription,
        audioFormat: 'audio/mp4',
      };

      const response = await apiClient.post(
        API_PATHS.AUDIO_ORDERS_PROCESS,
        payload,
        { timeout: 60000 },
      );

      const responseData = response.data as any;

      if (responseData.success) {
        return {
          success: true,
          data: responseData.extractedData || {
            orderItems: [],
            deliveryInfo: {},
            scheduledDelivery: {},
            orderType: 'DELIVERY',
            warnings: undefined,
            processingTime: 0,
          },
        };
      } else {
        throw new Error(
          responseData.error?.message ||
            responseData.message ||
            'Error procesando audio',
        );
      }
    } catch (error: any) {
      return {
        success: false,
        error: {
          code: error.response?.data?.error?.code || 'PROCESSING_ERROR',
          message: this.getErrorMessage(error),
          type: 'error',
          timestamp: new Date().toISOString(),
          requestId: 'local-' + Date.now(),
        },
      };
    }
  }

  getErrorMessage(error: any): string {
    if (error.response?.data?.error) {
      const apiError = error.response.data.error;

      switch (apiError.code) {
        case 'BL015':
          return 'El archivo de audio es muy grande. Mximo 10MB.';
        case 'AUTH001':
          return 'Error de autenticacin. Contacta al administrador.';
        case 'BL016':
          return 'No se pudo procesar el audio. Intenta de nuevo.';
        case 'BL002':
          return 'Faltan datos requeridos.';
        default:
          return apiError.message || 'Error desconocido';
      }
    }

    return error.message || 'Error al procesar la orden por voz';
  }

  validateBeforeSending(
    audioFileSize: number,
    transcription: string,
  ): string[] {
    const errors: string[] = [];

    if (audioFileSize > 50 * 1024 * 1024) {
      errors.push('El archivo de audio es muy grande (mximo 50MB)');
    }

    if (!transcription || transcription.trim().length < 5) {
      errors.push('La transcripcin est vaca o es muy corta');
    }

    return errors;
  }
}

export const audioOrderService = new AudioOrderService();

================
File: app/src/services/audioServiceHealth.ts
================
import axios from 'axios';
import { serverConnectionService } from './serverConnectionService';
import { useAuthStore } from '../app/store/authStore';
import NetInfo from '@react-native-community/netinfo';
import { API_PATHS } from '../app/constants/apiPaths';

export interface AudioServiceHealthStatus {
  isAvailable: boolean;
  hasInternet: boolean;
  serviceStatus: 'ok' | 'error' | 'disabled' | 'misconfigured' | 'checking';
  message?: string;
  lastChecked: Date;
}

class AudioServiceHealthChecker {
  private static instance: AudioServiceHealthChecker;
  private healthStatus: AudioServiceHealthStatus = {
    isAvailable: false,
    hasInternet: false,
    serviceStatus: 'checking',
    lastChecked: new Date(),
  };
  private listeners: ((status: AudioServiceHealthStatus) => void)[] = [];
  private checkInterval: NodeJS.Timeout | null = null;
  private lastCheckTime: number = 0;
  private readonly CHECK_INTERVAL = 30000;
  private readonly MIN_CHECK_INTERVAL = 5000;
  private isActive: boolean = false;
  private networkListener: (() => void) | null = null;

  private constructor() {}

  static getInstance(): AudioServiceHealthChecker {
    if (!AudioServiceHealthChecker.instance) {
      AudioServiceHealthChecker.instance = new AudioServiceHealthChecker();
    }
    return AudioServiceHealthChecker.instance;
  }

  async checkHealth(force: boolean = false): Promise<AudioServiceHealthStatus> {
    const now = Date.now();

    if (!force && now - this.lastCheckTime < this.MIN_CHECK_INTERVAL) {
      return this.healthStatus;
    }

    this.lastCheckTime = now;

    try {
      const netInfo = await NetInfo.fetch();
      const hasInternet =
        netInfo.isConnected && netInfo.isInternetReachable !== false;

      if (!hasInternet) {
        this.updateStatus({
          isAvailable: false,
          hasInternet: false,
          serviceStatus: 'error',
          message: 'Sin conexin a internet',
          lastChecked: new Date(),
        });
        return this.healthStatus;
      }

      const accessToken = useAuthStore.getState().accessToken;
      if (!accessToken) {
        this.updateStatus({
          isAvailable: false,
          hasInternet: true,
          serviceStatus: 'error',
          message: 'Usuario no autenticado',
          lastChecked: new Date(),
        });
        return this.healthStatus;
      }

      const connectionState = serverConnectionService.getState();
      if (!connectionState.currentUrl || !connectionState.isConnected) {
        this.updateStatus({
          isAvailable: false,
          hasInternet: true,
          serviceStatus: 'error',
          message: 'Servidor no conectado',
          lastChecked: new Date(),
        });
        return this.healthStatus;
      }

      const apiUrl = connectionState.currentUrl.endsWith('/')
        ? connectionState.currentUrl.slice(0, -1)
        : connectionState.currentUrl;
      const response = await axios.get(
        `${apiUrl}${API_PATHS.AUDIO_ORDERS_HEALTH}`,
        {
          headers: {
            Authorization: `Bearer ${accessToken}`,
          },
          timeout: 5000,
        },
      );

      const { available, status, message } = response.data;

      this.updateStatus({
        isAvailable: available,
        hasInternet: true,
        serviceStatus: status,
        message,
        lastChecked: new Date(),
      });
    } catch (error) {
      let errorMessage = 'Servicio de voz no disponible';
      if (axios.isAxiosError(error)) {
        if (error.code === 'ECONNABORTED') {
          errorMessage = 'Tiempo de espera agotado';
        } else if (error.response?.status === 503) {
          errorMessage = 'Servicio temporalmente no disponible';
        } else if (error.response?.status === 404) {
          errorMessage = 'Servicio de voz no configurado';
        }
      }

      this.updateStatus({
        isAvailable: false,
        hasInternet: true,
        serviceStatus: 'error',
        message: errorMessage,
        lastChecked: new Date(),
      });
    }

    return this.healthStatus;
  }

  private updateStatus(status: AudioServiceHealthStatus) {
    this.healthStatus = status;
    this.notifyListeners();
  }

  private notifyListeners() {
    this.listeners.forEach((listener) => listener(this.healthStatus));
  }

  subscribe(listener: (status: AudioServiceHealthStatus) => void): () => void {
    this.listeners.push(listener);

    listener(this.healthStatus);

    return () => {
      const index = this.listeners.indexOf(listener);
      if (index > -1) {
        this.listeners.splice(index, 1);
      }
    };
  }

  startPeriodicCheck() {
    if (this.checkInterval || !this.listeners.length) {
      return;
    }

    this.isActive = true;

    if (!this.networkListener) {
      this.networkListener = NetInfo.addEventListener((state) => {
        if (
          this.isActive &&
          state.isConnected !== this.healthStatus.hasInternet
        ) {
          this.checkHealth();
        }
      });
    }

    this.checkHealth();

    this.checkInterval = setInterval(() => {
      if (this.isActive) {
        this.checkHealth();
      }
    }, this.CHECK_INTERVAL);
  }

  stopPeriodicCheck() {
    this.isActive = false;

    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
    }

    if (this.networkListener) {
      this.networkListener();
      this.networkListener = null;
    }

    this.updateStatus({
      isAvailable: false,
      hasInternet: false,
      serviceStatus: 'checking',
      message: undefined,
      lastChecked: new Date(),
    });
  }

  getStatus(): AudioServiceHealthStatus {
    return this.healthStatus;
  }
}

export const audioServiceHealth = AudioServiceHealthChecker.getInstance();

================
File: app/src/services/autoReconnectService.ts
================
import EventEmitter from 'eventemitter3';
import { healthMonitoringService } from './healthMonitoringService';
import { discoveryService } from '../app/services/discoveryService';
import NetInfo from '@react-native-community/netinfo';
import { NETWORK_CONFIG } from '../app/constants/network';

export type ReconnectStatus =
  | 'idle'
  | 'checking-network'
  | 'checking-health'
  | 'running-discovery'
  | 'connected'
  | 'no-wifi'
  | 'failed';

export interface ReconnectState {
  status: ReconnectStatus;
  isReconnecting: boolean;
  attempts: number;
  lastError: string | null;
  logs: string[];
}

class AutoReconnectService extends EventEmitter {
  private state: ReconnectState = {
    status: 'idle',
    isReconnecting: false,
    attempts: 0,
    lastError: null,
    logs: [],
  };

  private reconnectTimer: NodeJS.Timeout | null = null;
  private isRunning = false;
  private readonly MAX_LOGS = 50;

  constructor() {
    super();
  }

  getState(): ReconnectState {
    return { ...this.state };
  }

  private addLog(message: string, type: 'info' | 'error' | 'success' = 'info') {
    const timestamp = new Date().toLocaleTimeString();
    const logEntry = `[${timestamp}] ${type.toUpperCase()}: ${message}`;

    const newLogs = [logEntry, ...this.state.logs].slice(0, this.MAX_LOGS);
    this.state.logs = newLogs;

    this.emit('stateChange', { ...this.state, logs: [...newLogs] });
  }

  private updateState(updates: Partial<ReconnectState>) {
    this.state = { ...this.state, ...updates };
    this.emit('stateChange', this.state);
  }

  async startAutoReconnect() {
    if (this.isRunning) {
      return;
    }

    this.isRunning = true;
    this.updateState({
      isReconnecting: true,
      attempts: 0,
      logs: [],
      lastError: null,
      status: 'idle',
    });

    this.addLog('Iniciando proceso de reconexin automtica', 'info');

    await this.delay(100);

    await this.reconnectCycle();
  }

  stopAutoReconnect() {
    if (!this.isRunning) return;

    this.addLog('Deteniendo proceso de reconexin', 'info');
    this.isRunning = false;

    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }

    this.updateState({
      isReconnecting: false,
      status: 'idle',
    });
  }

  private async reconnectCycle() {
    while (this.isRunning) {
      this.updateState({ attempts: this.state.attempts + 1 });
      this.addLog(`CICLO DE RECONEXIN #${this.state.attempts}`, 'info');

      const hasNetwork = await this.checkNetwork();
      if (!hasNetwork) {
        this.addLog(' Sin conexin WiFi. Esperando...', 'error');
        this.updateState({
          status: 'no-wifi',
          lastError: 'No hay conexin WiFi activa',
        });

        await this.delay(NETWORK_CONFIG.RECONNECT_CYCLE_DELAY);
        continue;
      }
      this.addLog(' WiFi conectado', 'success');

      this.addLog('Verificando servidor con health checks...', 'info');
      const healthOk = await this.tryHealthChecks();

      if (healthOk) {
        this.addLog(' SERVIDOR CONECTADO!', 'success');
        this.updateState({
          status: 'connected',
          isReconnecting: false,
          lastError: null,
        });
        this.isRunning = false;

        setTimeout(() => {
          this.emit('reconnected');
        }, 100);

        break;
      }

      this.addLog(
        'Health checks fallaron. Buscando servidor en red...',
        'info',
      );
      const discoveryOk = await this.tryDiscovery();

      if (discoveryOk) {
        this.addLog(' Servidor encontrado. Verificando...', 'info');
        const postDiscoveryHealth = await this.tryHealthChecks();

        if (postDiscoveryHealth) {
          this.addLog(' RECONEXIN EXITOSA!', 'success');
          this.updateState({
            status: 'connected',
            isReconnecting: false,
            lastError: null,
          });
          this.isRunning = false;

          setTimeout(() => {
            this.emit('reconnected');
          }, 100);

          break;
        } else {
          this.addLog(' Servidor encontrado pero no responde', 'error');
        }
      }

      this.addLog(
        ` Ciclo fallido. Esperando ${NETWORK_CONFIG.RECONNECT_CYCLE_DELAY / 1000}s...`,
        'error',
      );
      this.updateState({
        status: 'failed',
        lastError: 'No se pudo establecer conexin con el servidor',
      });

      await this.delay(NETWORK_CONFIG.RECONNECT_CYCLE_DELAY);
    }
  }

  private async checkNetwork(): Promise<boolean> {
    this.updateState({ status: 'checking-network' });

    try {
      const netInfo = await NetInfo.fetch();
      const hasWifi =
        !!netInfo.isConnected &&
        (netInfo.type === 'wifi' || netInfo.type === 'ethernet');

      return hasWifi;
    } catch (error) {
      this.addLog('Error al verificar estado de red', 'error');
      return false;
    }
  }

  private async tryHealthChecks(
    maxAttempts: number = NETWORK_CONFIG.HEALTH_CHECK_ATTEMPTS,
  ): Promise<boolean> {
    this.updateState({ status: 'checking-health' });

    for (let i = 1; i <= maxAttempts; i++) {
      this.addLog(`   Health check ${i}/${maxAttempts}...`, 'info');

      try {
        const isHealthy = await healthMonitoringService.forceCheck();

        if (isHealthy) {
          this.addLog('   Health check exitoso', 'success');
          return true;
        } else {
          this.addLog('   Health check fall', 'error');
        }
      } catch (error: unknown) {
        this.addLog('   Health check fall', 'error');
      }

      if (i < maxAttempts) {
        this.addLog(`   Esperando 2s...`, 'info');
        await this.delay(2000);
      }
    }

    this.addLog('   Todos los health checks fallaron', 'error');
    return false;
  }

  private async tryDiscovery(): Promise<boolean> {
    this.updateState({ status: 'running-discovery' });

    discoveryService.setLogCallback((message: string) => {
      this.addLog(`  ${message}`, 'info');
    });

    try {
      this.addLog('   Iniciando escaneo de red...', 'info');
      this.addLog('   Buscando servidor en puerto 3737...', 'info');
      const url = await discoveryService.forceRediscovery();

      if (url) {
        this.addLog(`   Servidor encontrado!`, 'success');
        this.addLog(`   URL: ${url}`, 'success');
        return true;
      } else {
        this.addLog('   No se encontr servidor en la red', 'error');
        return false;
      }
    } catch (error: unknown) {
      const errorMessage =
        error instanceof Error ? error.message : 'Error al buscar servidor';
      this.addLog(`   Error: ${errorMessage}`, 'error');
      return false;
    } finally {
      discoveryService.setLogCallback(null);
    }
  }

  private delay(ms: number): Promise<void> {
    return new Promise((resolve) => {
      this.reconnectTimer = setTimeout(resolve, ms);
    });
  }

  subscribe(callback: (state: ReconnectState) => void): () => void {
    this.on('stateChange', callback);

    callback(this.state);

    return () => {
      this.off('stateChange', callback);
    };
  }
}

export const autoReconnectService = new AutoReconnectService();

================
File: app/src/services/healthMonitoringService.ts
================
import axios from 'axios';
import { discoveryService } from '../app/services/discoveryService';
import EventEmitter from 'eventemitter3';
import { NETWORK_CONFIG } from '../app/constants/network';
import { API_PATHS } from '../app/constants/apiPaths';

export type HealthStatus = 'ok' | 'error' | 'checking';

export interface HealthState {
  status: HealthStatus;
  isAvailable: boolean;
  message?: string;
}

class HealthMonitoringService extends EventEmitter {
  private state: HealthState = {
    status: 'checking',
    isAvailable: false,
  };

  private checkInterval: NodeJS.Timeout | null = null;
  private retryTimeout: NodeJS.Timeout | null = null;
  private isChecking = false;
  private retryCount = 0;

  constructor() {
    super();
  }

  getState(): HealthState {
    return { ...this.state };
  }

  isMonitoring(): boolean {
    return this.checkInterval !== null;
  }

  startMonitoring() {
    this.stopMonitoring();

    this.retryCount = 0;

    this.checkHealth();

    this.checkInterval = setInterval(() => {
      this.checkHealth();
    }, NETWORK_CONFIG.HEALTH_CHECK_INTERVAL);
  }

  stopMonitoring() {
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
    }

    if (this.retryTimeout) {
      clearTimeout(this.retryTimeout);
      this.retryTimeout = null;
    }
  }

  async checkHealth(): Promise<boolean> {
    if (this.isChecking) {
      return this.state.isAvailable;
    }

    this.isChecking = true;

    try {
      let apiUrl: string;
      try {
        const lastKnownUrl = await discoveryService.getLastKnownUrl();
        if (!lastKnownUrl) {
          throw new Error('No hay servidor configurado');
        }
        apiUrl = lastKnownUrl;
      } catch (error) {
        this.updateState({
          status: 'error',
          isAvailable: false,
          message: 'Servidor no configurado',
        });
        this.isChecking = false;
        return false;
      }

      const baseUrl = apiUrl.endsWith('/') ? apiUrl.slice(0, -1) : apiUrl;
      const healthUrl = `${baseUrl}${API_PATHS.HEALTH}`;

      const response = await axios.get(healthUrl, {
        timeout: NETWORK_CONFIG.HEALTH_CHECK_TIMEOUT,
      });

      if (response.data.status === 'ok') {
        const wasUnavailable = !this.state.isAvailable;

        this.updateState({
          status: 'ok',
          isAvailable: true,
          message: 'Conectado al servidor',
        });

        if (wasUnavailable) {
          setTimeout(() => {
            this.emit('recovered');
          }, 100);
        }

        this.retryCount = 0;

        if (this.retryTimeout) {
          clearTimeout(this.retryTimeout);
          this.retryTimeout = null;
        }

        this.isChecking = false;
        return true;
      } else {
        throw new Error('Backend returned unhealthy status');
      }
    } catch (error: any) {
      const isTemporaryError = this.isTemporaryError(error);

      this.updateState({
        status: 'error',
        isAvailable: false,
        message: this.getErrorMessage(error),
      });

      if (isTemporaryError && this.retryCount < 3) {
        this.scheduleRetry();
      }

      this.isChecking = false;
      return false;
    }
  }

  private scheduleRetry() {
    if (this.retryTimeout) {
      clearTimeout(this.retryTimeout);
    }

    const retryInterval =
      NETWORK_CONFIG.HEALTH_RETRY_INTERVALS[
        Math.min(
          this.retryCount,
          NETWORK_CONFIG.HEALTH_RETRY_INTERVALS.length - 1,
        )
      ];

    this.retryTimeout = setTimeout(() => {
      this.retryCount++;
      this.checkHealth();
    }, retryInterval);
  }

  private updateState(newState: HealthState) {
    this.state = newState;
    this.emit('stateChange', this.state);
  }

  private isTemporaryError(error: any): boolean {
    return (
      error.code === 'ECONNABORTED' ||
      error.code === 'ETIMEDOUT' ||
      error.message?.includes('timeout') ||
      error.code === 'ECONNRESET'
    );
  }

  private getErrorMessage(error: any): string {
    if (error.code === 'ECONNABORTED' || error.message?.includes('timeout')) {
      return 'Tiempo de espera agotado';
    }
    if (error.code === 'ENOTFOUND' || error.code === 'ECONNREFUSED') {
      return 'No se puede conectar al servidor';
    }
    if (error.message?.includes('No API URL')) {
      return 'Servidor no encontrado';
    }
    if (error.message?.includes('Servidor no configurado')) {
      return 'Servidor no configurado';
    }
    return 'Error de conexin';
  }

  subscribe(callback: (state: HealthState) => void): () => void {
    this.on('stateChange', callback);

    callback(this.state);

    return () => {
      this.off('stateChange', callback);
    };
  }

  async checkHealthWithUrl(apiUrl: string): Promise<boolean> {
    try {
      const baseUrl = apiUrl.endsWith('/') ? apiUrl.slice(0, -1) : apiUrl;
      const healthUrl = `${baseUrl}${API_PATHS.HEALTH}`;

      const response = await axios.get(healthUrl, {
        timeout: NETWORK_CONFIG.HEALTH_CHECK_TIMEOUT,
      });

      return response.data.status === 'ok';
    } catch (error) {
      return false;
    }
  }

  async forceCheck(): Promise<boolean> {
    this.retryCount = 0;
    const result = await this.checkHealth();

    this.emit('stateChange', this.state);

    return result;
  }
}

export const healthMonitoringService = new HealthMonitoringService();

================
File: app/src/app/components/crud/GenericDetailModal.tsx
================
import React, { useMemo } from 'react';
import {
  View,
  StyleSheet,
  StyleProp,
  ViewStyle,
  TextStyle,
} from 'react-native';
import {
  Text,
  Button,
  Chip,
  ActivityIndicator,
  IconButton,
} from 'react-native-paper';
import AutoImage from '../common/AutoImage';
import { useAppTheme, AppTheme } from '../../styles/theme';
import { ResponsiveModal } from '../responsive/ResponsiveModal';
import { useResponsive } from '../../hooks/useResponsive';
import ConfirmationModal from '../common/ConfirmationModal';

export interface DisplayFieldConfig<TItem> {
  field: keyof TItem;
  label: string;
  render?: (value: TItem[keyof TItem], item: TItem) => React.ReactNode;
}

interface StatusConfig<TItem> {
  field: keyof TItem;
  activeValue: TItem[keyof TItem];
  activeLabel: string;
  inactiveLabel: string;
}

interface DeleteConfirmation {
  visible: boolean;
  title: string;
  message: string;
  onConfirm: () => void;
  onCancel: () => void;
  show: (id: string) => void;
}

interface GenericDetailModalProps<TItem extends { id: string }> {
  visible: boolean;
  onDismiss: () => void;
  item: TItem | null;
  titleField: keyof TItem;
  imageField?: keyof TItem;
  descriptionField?: keyof TItem;
  statusConfig?: StatusConfig<TItem>;
  fieldsToDisplay?: DisplayFieldConfig<TItem>[];
  onEdit?: (item: TItem) => void;
  onDelete?: (id: string) => void;
  deleteConfirmation?: DeleteConfirmation;
  isDeleting?: boolean;
  editButtonLabel?: string;
  deleteButtonLabel?: string;
  closeButtonLabel?: string;
  modalStyle?: StyleProp<ViewStyle>;
  titleStyle?: StyleProp<TextStyle>;
  imageStyle?: StyleProp<ViewStyle>;
  descriptionStyle?: StyleProp<TextStyle>;
  fieldLabelStyle?: StyleProp<TextStyle>;
  fieldValueStyle?: StyleProp<TextStyle>;
  actionsContainerStyle?: StyleProp<ViewStyle>;
  showImage?: boolean;
  children?: React.ReactNode;
}

const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) => {
  return StyleSheet.create({
    modalSurface: {
      backgroundColor: theme.colors.elevation.level2,
      borderWidth: 2,
      borderColor: theme.colors.outline,
      borderRadius: theme.roundness * 2,
      elevation: 4,
      shadowColor: theme.colors.shadow,
      shadowOffset: {
        width: 0,
        height: 2,
      },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
    },
    modalTitle: {
      marginTop: responsive.spacing(theme.spacing.l),
      marginBottom: responsive.spacing(theme.spacing.m),
      textAlign: 'center',
      fontWeight: '700',
      fontSize: responsive.isTablet ? 22 : 20,
      paddingHorizontal: responsive.spacing(theme.spacing.m),
    },
    detailContent: {
      alignItems: 'center',
      marginBottom: responsive.spacing(theme.spacing.m),
      width: '100%',
      paddingHorizontal: responsive.spacing(theme.spacing.m),
    },
    detailImage: {
      width: responsive.isTablet
        ? responsive.getResponsiveDimension(120, 150)
        : responsive.getResponsiveDimension(150, 180),
      height: responsive.isTablet
        ? responsive.getResponsiveDimension(120, 150)
        : responsive.getResponsiveDimension(150, 180),
      borderRadius: theme.roundness * 2,
      marginBottom: responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surfaceDisabled,
      elevation: 2,
    },
    detailDescription: {
      marginBottom: responsive.spacing(theme.spacing.m),
      textAlign: 'center',
      lineHeight: responsive.isTablet ? 20 : 18,
      fontSize: responsive.isTablet ? 14 : 13,
      paddingHorizontal: responsive.spacing(theme.spacing.xs),
      flexWrap: 'wrap',
      width: '100%',
    },
    statusChipContainer: {
      marginBottom: responsive.spacing(theme.spacing.s),
      marginTop: responsive.spacing(theme.spacing.s),
    },
    statusChip: {
      paddingHorizontal: responsive.spacing(theme.spacing.s),
      height: responsive.isTablet ? 36 : 32,
    },
    fieldsContainer: {
      width: '100%',
      marginBottom: responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: theme.roundness * 1.5,
      padding: responsive.isTablet
        ? responsive.spacing(theme.spacing.s)
        : responsive.spacing(theme.spacing.m),
      marginHorizontal: responsive.spacing(theme.spacing.m),
      alignSelf: 'center',
      maxWidth: '90%',
    },
    fieldRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
      marginBottom: responsive.isTablet
        ? responsive.spacing(theme.spacing.xs)
        : responsive.spacing(theme.spacing.s),
      paddingVertical: responsive.isTablet
        ? responsive.spacing(theme.spacing.xxs)
        : responsive.spacing(theme.spacing.xs),
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
      flexWrap: 'wrap',
    },
    lastFieldRow: {
      marginBottom: 0,
      borderBottomWidth: 0,
    },
    fieldLabel: {
      fontWeight: '600',
      marginRight: responsive.spacing(theme.spacing.s),
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 14 : 13,
      flexBasis: '35%',
      minWidth: 100,
    },
    fieldValue: {
      flex: 1,
      textAlign: 'right',
      color: theme.colors.onSurface,
      fontSize: responsive.isTablet ? 14 : 13,
      flexWrap: 'wrap',
      maxWidth: '65%',
    },
    detailActions: {
      flexDirection: 'row',
      justifyContent: 'center',
      alignItems: 'center',
      gap: responsive.spacing(theme.spacing.s),
      marginBottom: responsive.spacing(theme.spacing.m),
      width: '100%',
      paddingHorizontal: responsive.spacing(theme.spacing.m),
    },
    closeButton: {
      alignSelf: 'center',
      borderRadius: theme.roundness,
      backgroundColor: theme.colors.surfaceVariant,
      minWidth: responsive.isTablet ? 150 : 100,
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      marginBottom: responsive.spacing(theme.spacing.l),
    },
    loadingContainer: {
      justifyContent: 'center',
      alignItems: 'center',
      minHeight: 300,
      flex: 1,
    },
    actionButton: {
      borderRadius: theme.roundness,
      paddingHorizontal: responsive.spacing(theme.spacing.s),
      flex: 1,
      maxWidth: responsive.isTablet ? 180 : '48%',
      minHeight: responsive.isTablet ? 48 : 40,
      minWidth: 100,
    },
    buttonContainer: {
      backgroundColor: theme.colors.surface,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.m),
      paddingBottom: responsive.spacing(theme.spacing.l),
    },
    closeIconButton: {
      position: 'absolute',
      top: responsive.spacing(theme.spacing.xs),
      right: responsive.spacing(theme.spacing.xs),
      zIndex: 1,
    },
    renderContainer: {
      flex: 1,
      flexDirection: 'row',
      justifyContent: 'flex-end',
    },
    buttonContent: {
      flexDirection: 'row',
    },
    buttonLabel: {
      fontSize: responsive.isTablet ? 13 : 12,
    },
    closeButtonLabel: {
      fontSize: responsive.isTablet ? 14 : 13,
    },
  });
};

function GenericDetailModal<TItem extends { id: string }>({
  visible,
  onDismiss,
  item,
  titleField,
  imageField,
  descriptionField,
  statusConfig,
  fieldsToDisplay = [],
  onEdit,
  onDelete,
  deleteConfirmation,
  isDeleting = false,
  editButtonLabel = 'Editar',
  deleteButtonLabel = 'Eliminar',
  closeButtonLabel = 'Cerrar',
  modalStyle,
  titleStyle,
  imageStyle,
  descriptionStyle,
  fieldLabelStyle,
  fieldValueStyle,
  actionsContainerStyle,
  showImage = false,
  children,
}: GenericDetailModalProps<TItem>) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = useMemo(
    () => getStyles(theme, responsive),
    [theme, responsive],
  );
  const imageSource = useMemo(() => {
    if (item && imageField && item.hasOwnProperty(imageField)) {
      const imageFieldValue = item[imageField];
      if (
        typeof imageFieldValue === 'object' &&
        imageFieldValue !== null &&
        'path' in imageFieldValue &&
        typeof imageFieldValue.path === 'string'
      ) {
        return imageFieldValue.path;
      } else if (typeof imageFieldValue === 'string') {
        return imageFieldValue;
      }
    }
    return null;
  }, [item, imageField]);

  const handleEdit = () => {
    if (onEdit && item) {
      onEdit(item);
    }
  };

  const handleDelete = () => {
    if (item) {
      if (deleteConfirmation) {
        deleteConfirmation.show(item.id);
      } else if (onDelete) {
        onDelete(item.id);
      }
    }
  };

  const renderContent = () => {
    if (!item) {
      return (
        <View style={styles.loadingContainer}>
          <ActivityIndicator animating={true} size="large" />
        </View>
      );
    }

    const title = String(item[titleField] ?? 'Detalle');
    const description =
      descriptionField && item.hasOwnProperty(descriptionField)
        ? String(item[descriptionField] ?? '')
        : null;

    let statusChip = null;
    if (statusConfig && item.hasOwnProperty(statusConfig.field)) {
      const { field, activeValue, activeLabel, inactiveLabel } = statusConfig;
      const isActive = item[field] === activeValue;
      statusChip = (
        <View style={styles.statusChipContainer}>
          <Chip
            mode="flat"
            selectedColor={
              isActive ? theme.colors.success : theme.colors.onSurfaceVariant
            }
            style={[
              styles.statusChip,
              {
                backgroundColor: isActive
                  ? theme.colors.successContainer
                  : theme.colors.surfaceVariant,
              },
            ]}
          >
            {isActive ? activeLabel : inactiveLabel}
          </Chip>
        </View>
      );
    }

    return (
      <>
        <IconButton
          icon="close"
          size={24}
          style={styles.closeIconButton}
          onPress={onDismiss}
          mode="contained-tonal"
        />
        <Text variant="headlineSmall" style={[styles.modalTitle, titleStyle]}>
          {title}
        </Text>
        <View style={styles.detailContent}>
          {showImage && (
            <AutoImage
              source={imageSource}
              placeholderIcon="image-outline"
              style={[styles.detailImage, imageStyle]}
              contentFit="contain"
              transition={300}
            />
          )}
          {statusChip}
          {description && (
            <Text
              style={[styles.detailDescription, descriptionStyle]}
              numberOfLines={4}
              ellipsizeMode="tail"
            >
              {description}
            </Text>
          )}
        </View>

        {fieldsToDisplay.length > 0 && (
          <View style={styles.fieldsContainer}>
            {fieldsToDisplay.map(({ field, label, render }, index) => {
              if (!item || !item.hasOwnProperty(field)) return null;
              const value = item[field];
              const isLastItem = index === fieldsToDisplay.length - 1;

              return (
                <View
                  key={String(field)}
                  style={[styles.fieldRow, isLastItem && styles.lastFieldRow]}
                >
                  <Text style={[styles.fieldLabel, fieldLabelStyle]}>
                    {label}
                  </Text>
                  {render ? (
                    <View style={styles.renderContainer}>
                      {(() => {
                        const rendered = render(value, item);
                        // Si el render devuelve un string o nmero, lo envolvemos en Text
                        if (
                          typeof rendered === 'string' ||
                          typeof rendered === 'number'
                        ) {
                          return (
                            <Text
                              style={[styles.fieldValue, fieldValueStyle]}
                              numberOfLines={3}
                              ellipsizeMode="tail"
                            >
                              {rendered}
                            </Text>
                          );
                        }
                        // Si ya es un elemento React, lo devolvemos tal cual
                        return rendered;
                      })()}
                    </View>
                  ) : (
                    <Text
                      style={[styles.fieldValue, fieldValueStyle]}
                      numberOfLines={3}
                      ellipsizeMode="tail"
                    >
                      {typeof value === 'boolean'
                        ? value
                          ? 'S'
                          : 'No'
                        : String(value ?? 'N/A')}
                    </Text>
                  )}
                </View>
              );
            })}
          </View>
        )}

        {children}
      </>
    );
  };

  const renderFooter = () => {
    if (!item) return null;

    return (
      <>
        {(onEdit || onDelete) && (
          <View style={[styles.detailActions, actionsContainerStyle]}>
            {onEdit && (
              <Button
                icon="pencil"
                mode="contained-tonal"
                onPress={handleEdit}
                disabled={isDeleting}
                style={styles.actionButton}
                buttonColor={theme.colors.secondaryContainer}
                textColor={theme.colors.onSecondaryContainer}
                contentStyle={styles.buttonContent}
                labelStyle={styles.buttonLabel}
                compact={!responsive.isTablet}
              >
                {editButtonLabel}
              </Button>
            )}
            {onDelete && (
              <Button
                icon="delete"
                mode="contained-tonal"
                buttonColor={theme.colors.errorContainer}
                textColor={theme.colors.error}
                onPress={handleDelete}
                loading={isDeleting}
                disabled={isDeleting}
                style={styles.actionButton}
                contentStyle={styles.buttonContent}
                labelStyle={styles.buttonLabel}
                compact={!responsive.isTablet}
              >
                {deleteButtonLabel}
              </Button>
            )}
          </View>
        )}

        <Button
          mode="contained-tonal"
          onPress={onDismiss}
          style={styles.closeButton}
          disabled={isDeleting}
          buttonColor={theme.colors.surfaceVariant}
          textColor={theme.colors.onSurfaceVariant}
          labelStyle={styles.closeButtonLabel}
          contentStyle={{
            paddingHorizontal: responsive.spacing(theme.spacing.s),
          }}
        >
          {closeButtonLabel}
        </Button>
      </>
    );
  };

  return (
    <>
      <ResponsiveModal
        visible={visible}
        onDismiss={onDismiss}
        dismissable={!isDeleting}
        dismissableBackButton={!isDeleting}
        scrollable={true}
        maxWidth={responsive.isTablet ? 480 : 400}
        maxHeight={'85%'}
        footer={renderFooter()}
        stickyFooter={true}
        contentContainerStyle={[styles.modalSurface, modalStyle]}
      >
        {renderContent()}
      </ResponsiveModal>

      {deleteConfirmation && (
        <ConfirmationModal
          visible={deleteConfirmation.visible}
          title={deleteConfirmation.title}
          message={deleteConfirmation.message}
          onConfirm={deleteConfirmation.onConfirm}
          onCancel={deleteConfirmation.onCancel}
          onDismiss={deleteConfirmation.onCancel}
          confirmText="Eliminar"
          cancelText="Cancelar"
          confirmButtonColor={theme.colors.error}
        />
      )}
    </>
  );
}

export default GenericDetailModal;

================
File: app/src/app/navigation/components/CustomDrawerContent.tsx
================
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { DrawerContentScrollView } from '@react-navigation/drawer';
import {
  Drawer as PaperDrawer,
  Text,
  Divider,
  Switch,
  TouchableRipple,
  Icon,
  Surface,
} from 'react-native-paper';
import { useThemeStore } from '../../store/themeStore';
import { THEME_MODE } from '../../types/theme.types';
import { useAuthStore } from '../../store/authStore';
import { useAppTheme, AppTheme } from '../../styles/theme';
import { useResponsive } from '../../hooks/useResponsive';
import { clearImageCache } from '../../lib/imageCache';
import { useSnackbarStore } from '../../store/snackbarStore';
import {
  hasPermission,
  DRAWER_SECTIONS,
  DrawerSection,
} from '../../constants/rolePermissions';
import { generateNavigationAction } from '../helpers/navigationHelpers';
import { RoleEnum } from '@/modules/users/schema/user.schema';

import type { DrawerContentComponentProps } from '@react-navigation/drawer';

// Traducciones de roles
const ROLE_TRANSLATIONS: Record<number, string> = {
  [RoleEnum.ADMIN]: 'Administrador',
  [RoleEnum.MANAGER]: 'Gerente',
  [RoleEnum.CASHIER]: 'Cajero',
  [RoleEnum.WAITER]: 'Mesero',
  [RoleEnum.KITCHEN]: 'Cocina',
  [RoleEnum.DELIVERY]: 'Repartidor',
};

const getRoleTranslation = (roleId?: number): string => {
  if (!roleId) return 'Desconocido';
  return ROLE_TRANSLATIONS[roleId] || 'Desconocido';
};

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
    },
    userInfoSection: {
      padding: responsive.spacing(theme.spacing.m),
    },
    title: {
      ...theme.fonts.titleMedium,
      fontSize: responsive.fontSize(theme.fonts.titleMedium.fontSize),
      color: theme.colors.onSurface,
      marginBottom: responsive.spacing(4),
    },
    caption: {
      ...theme.fonts.bodySmall,
      fontSize: responsive.fontSize(theme.fonts.bodySmall.fontSize),
      color: theme.colors.onSurfaceVariant,
      marginBottom: responsive.spacing(2),
    },
    drawerSection: {
      marginTop: responsive.spacing(theme.spacing.s),
    },
    bottomDrawerSection: {
      marginBottom: responsive.spacing(theme.spacing.m),
      marginTop: 'auto',
      borderTopColor: theme.colors.outlineVariant,
      borderTopWidth: StyleSheet.hairlineWidth,
      paddingTop: responsive.spacing(theme.spacing.s),
    },
    preference: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      paddingVertical: responsive.spacing(theme.spacing.s),
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      alignItems: 'center',
      marginHorizontal: responsive.spacing(theme.spacing.xs),
      borderRadius: theme.roundness * 2,
    },
    drawerItemLabel: {
      ...theme.fonts.labelLarge,
      fontSize: responsive.fontSize(theme.fonts.labelLarge.fontSize),
    },
    drawerItemContainer: {
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingVertical: responsive.spacing(theme.spacing.m),
      flexDirection: 'row',
      alignItems: 'center',
      borderRadius: theme.roundness * 2,
      marginHorizontal: responsive.spacing(theme.spacing.xs),
      marginVertical: responsive.spacing(theme.spacing.xxs),
    },
    drawerItemActive: {
      backgroundColor: theme.colors.primaryContainer,
    },
    drawerItemIconContainer: {
      marginRight: responsive.spacing(theme.spacing.l),
      width: responsive.isTablet ? 20 : theme.spacing.l,
      alignItems: 'center',
    },
    divider: {
      marginVertical: responsive.spacing(theme.spacing.s),
      marginHorizontal: responsive.spacing(theme.spacing.m),
    },

    configSubheader: {
      ...theme.fonts.labelLarge,
      fontSize: responsive.fontSize(theme.fonts.labelLarge.fontSize),
      color: theme.colors.onSurfaceVariant,
      paddingLeft: responsive.spacing(theme.spacing.l),
      paddingRight: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.s),
      paddingBottom: responsive.spacing(theme.spacing.xxs),
    },
    containerStyle: {
      flex: 1,
    },
    drawerContentStyle: {
      paddingTop: 0,
    },
    rowContainer: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    fullWidthRow: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      width: '100%',
    },
    pointerEventsNone: {
      pointerEvents: 'none',
    },
  });

export function CustomDrawerContent(props: DrawerContentComponentProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const logout = useAuthStore((state) => state.logout);
  const setThemePreference = useThemeStore((state) => state.setThemePreference);
  const user = useAuthStore((state) => state.user);
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );

  const getItemActive = (routeName: string) => {
    const currentRoute = props.state.routes[props.state.index];
    return currentRoute?.name === routeName;
  };

  const getItemColor = (routeName: string) => {
    return getItemActive(routeName)
      ? theme.colors.primary
      : theme.colors.onSurfaceVariant;
  };

  const renderDrawerItem = (
    routeName: string,
    label: string,
    iconName: string,
    navigateToScreen: () => void,
  ) => {
    // Verificar permisos antes de renderizar
    if (!hasPermission(user?.role?.id, routeName as DrawerSection)) {
      return null;
    }

    const isActive = getItemActive(routeName);

    return (
      <TouchableRipple
        key={routeName}
        onPress={navigateToScreen}
        style={[
          styles.drawerItemContainer,
          isActive && styles.drawerItemActive,
        ]}
        rippleColor={`${theme.colors.primary}20`}
      >
        <View style={styles.rowContainer}>
          <View style={styles.drawerItemIconContainer}>
            <Icon
              source={iconName}
              size={responsive.isTablet ? 20 : 24}
              color={getItemColor(routeName)}
            />
          </View>
          <Text
            style={[styles.drawerItemLabel, { color: getItemColor(routeName) }]}
          >
            {label}
          </Text>
        </View>
      </TouchableRipple>
    );
  };

  // Helper simplificado para renderizar items del drawer
  const renderDrawerItemSimple = (
    route: DrawerSection,
    label: string,
    icon: string,
  ) => {
    return renderDrawerItem(route, label, icon, () => {
      // For kitchen users in KitchenOnlyNavigator, handle navigation differently
      const isKitchenUser = user?.role?.id === 5;
      if (isKitchenUser && route === 'KitchenScreen') {
        // Simply navigate to the Kitchen screen without reset
        props.navigation.navigate('Kitchen');
      } else {
        const action = generateNavigationAction(route, user?.role?.id);
        if (action) {
          props.navigation.dispatch(action);
        }
      }
    });
  };

  const handleClearCache = async () => {
    try {
      await clearImageCache();
      showSnackbar({
        message: 'Cach de imgenes limpiado exitosamente',
        type: 'success',
      });
    } catch (error) {
      showSnackbar({
        message: 'Error al limpiar el cach',
        type: 'error',
      });
    }
  };

  return (
    <Surface style={styles.containerStyle} elevation={0}>
      <DrawerContentScrollView
        {...props}
        contentContainerStyle={styles.drawerContentStyle}
      >
        <View style={styles.container}>
          <Surface style={styles.userInfoSection} elevation={0}>
            {user ? (
              <>
                <Text style={styles.title} numberOfLines={1}>
                  {`${user.firstName ?? ''} ${user.lastName ?? ''}`.trim() ||
                    user.username ||
                    'Usuario'}
                </Text>
                <Text style={styles.caption} numberOfLines={1}>
                  Rol: {getRoleTranslation(user.role?.id)}
                </Text>
                <Text style={styles.caption} numberOfLines={1}>
                  {user.email ?? ''}
                </Text>
                <Text style={styles.caption} numberOfLines={1}>
                  @{user.username ?? 'username'}
                </Text>
              </>
            ) : (
              <Text style={styles.title}>Invitado</Text>
            )}
          </Surface>
          <Divider style={styles.divider} />

          {/* Seccin de Ventas - Solo visible si tiene permisos */}
          {DRAWER_SECTIONS.sales.items.some((item) =>
            hasPermission(user?.role?.id, item.route as DrawerSection),
          ) && (
            <PaperDrawer.Section style={styles.drawerSection}>
              <Text style={styles.configSubheader}>
                {DRAWER_SECTIONS.sales.title}
              </Text>
              {DRAWER_SECTIONS.sales.items.map((item) =>
                renderDrawerItemSimple(
                  item.route as DrawerSection,
                  item.label,
                  item.icon,
                ),
              )}
            </PaperDrawer.Section>
          )}

          {/* Seccin de Cocina - Solo para usuarios con rol kitchen */}
          {hasPermission(user?.role?.id, 'KitchenScreen') && (
            <PaperDrawer.Section style={styles.drawerSection}>
              <Text style={styles.configSubheader}>Cocina</Text>
              {renderDrawerItemSimple(
                'KitchenScreen',
                'Pantalla de Preparacin',
                'chef-hat',
              )}
            </PaperDrawer.Section>
          )}

          {/* Seccin de Configuracin - Solo visible si tiene permisos */}
          {DRAWER_SECTIONS.configuration.items.some((item) =>
            hasPermission(user?.role?.id, item.route as DrawerSection),
          ) && (
            <>
              <Divider style={styles.divider} />
              <PaperDrawer.Section style={styles.drawerSection}>
                <Text style={styles.configSubheader}>
                  {DRAWER_SECTIONS.configuration.title}
                </Text>
                {DRAWER_SECTIONS.configuration.items.map((item) =>
                  renderDrawerItemSimple(
                    item.route as DrawerSection,
                    item.label,
                    item.icon,
                  ),
                )}
              </PaperDrawer.Section>
            </>
          )}

          {/* Seccin de Administracin - Solo visible si tiene permisos */}
          {DRAWER_SECTIONS.administration.items.some((item) =>
            hasPermission(user?.role?.id, item.route as DrawerSection),
          ) && (
            <>
              <Divider style={styles.divider} />

              <PaperDrawer.Section style={styles.drawerSection}>
                <Text style={styles.configSubheader}>
                  {DRAWER_SECTIONS.administration.title}
                </Text>
                {DRAWER_SECTIONS.administration.items.map((item) =>
                  renderDrawerItemSimple(
                    item.route as DrawerSection,
                    item.label,
                    item.icon,
                  ),
                )}
              </PaperDrawer.Section>
            </>
          )}
        </View>
      </DrawerContentScrollView>

      <PaperDrawer.Section style={styles.bottomDrawerSection}>
        <TouchableRipple
          onPress={() => {
            const newPreference = theme.dark
              ? THEME_MODE.LIGHT
              : THEME_MODE.DARK;
            setThemePreference(newPreference);
          }}
          style={styles.preference}
        >
          <View style={styles.fullWidthRow}>
            <View style={styles.rowContainer}>
              <View style={styles.drawerItemIconContainer}>
                <Icon
                  source={theme.dark ? 'weather-night' : 'white-balance-sunny'}
                  size={responsive.isTablet ? 20 : 24}
                  color={theme.colors.onSurfaceVariant}
                />
              </View>
              <Text
                style={[
                  styles.drawerItemLabel,
                  { color: theme.colors.onSurfaceVariant },
                ]}
              >
                Modo Oscuro
              </Text>
            </View>
            <View style={styles.pointerEventsNone}>
              <Switch value={theme.dark} color={theme.colors.primary} />
            </View>
          </View>
        </TouchableRipple>

        <TouchableRipple
          onPress={handleClearCache}
          style={styles.drawerItemContainer}
          rippleColor={`${theme.colors.primary}20`}
        >
          <View style={styles.rowContainer}>
            <View style={styles.drawerItemIconContainer}>
              <Icon
                source="broom"
                size={responsive.isTablet ? 20 : 24}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <Text
              style={[
                styles.drawerItemLabel,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Limpiar Cach
            </Text>
          </View>
        </TouchableRipple>

        <TouchableRipple
          onPress={() => {
            props.navigation.navigate('ServerSettings');
          }}
          style={styles.drawerItemContainer}
          rippleColor={`${theme.colors.primary}20`}
        >
          <View style={styles.rowContainer}>
            <View style={styles.drawerItemIconContainer}>
              <Icon
                source="server-network"
                size={responsive.isTablet ? 20 : 24}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <Text
              style={[
                styles.drawerItemLabel,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Configuracin del Servidor
            </Text>
          </View>
        </TouchableRipple>

        <TouchableRipple
          onPress={() => {
            logout();
          }}
          style={styles.drawerItemContainer}
          rippleColor={`${theme.colors.error}20`}
        >
          <View style={styles.rowContainer}>
            <View style={styles.drawerItemIconContainer}>
              <Icon
                source="logout"
                size={responsive.isTablet ? 20 : 24}
                color={theme.colors.error}
              />
            </View>
            <Text
              style={[styles.drawerItemLabel, { color: theme.colors.error }]}
            >
              Cerrar Sesin
            </Text>
          </View>
        </TouchableRipple>
      </PaperDrawer.Section>
    </Surface>
  );
}

================
File: app/src/modules/areasTables/screens/AreasScreen.tsx
================
import React, { useMemo, useCallback } from 'react';
import { StyleSheet } from 'react-native';
import { IconButton } from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useDrawerStatus } from '@react-navigation/drawer';

import GenericList, {
  RenderItemConfig,
  FilterOption,
} from '../../../app/components/crud/GenericList';
import GenericDetailModal, {
  DisplayFieldConfig,
} from '../../../app/components/crud/GenericDetailModal';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { useResponsive } from '../../../app/hooks/useResponsive';
import { useCrudScreenLogic } from '../../../app/hooks/useCrudScreenLogic';
import { useListState } from '../../../app/hooks/useListState';
import { useRefreshModuleOnFocus } from '../../../app/hooks/useRefreshOnFocus';
import { NAVIGATION_PATHS } from '../../../app/constants/navigationPaths';

import AreaFormModal from '../components/AreaFormModal';
import {
  useGetAreas,
  useCreateArea,
  useUpdateArea,
  useDeleteArea,
} from '../hooks/useAreasQueries';
import { Area, CreateAreaDto, UpdateAreaDto } from '../schema/area.schema';
import { AreasListScreenProps } from '../navigation/types';

const AreasScreen: React.FC<AreasListScreenProps> = ({ navigation }) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(() => getStyles(theme), [theme]);
  const drawerStatus = useDrawerStatus();
  const isDrawerOpen = drawerStatus === 'open';

  const [searchQuery, setSearchQuery] = React.useState('');
  const [filterStatus, setFilterStatus] = React.useState<string>('all');

  const {
    data: areasData = [],
    isLoading: isLoadingAreas,
    isError: isErrorAreas,
    refetch: refetchAreas,
    isRefetching,
  } = useGetAreas(
    {
      name: searchQuery || undefined,
      isActive: filterStatus === 'all' ? undefined : filterStatus === 'true',
    },
    { page: 1, limit: 100 },
  );

  const createAreaMutation = useCreateArea();
  const updateAreaMutation = useUpdateArea();
  const { mutateAsync: deleteArea } = useDeleteArea();

  useRefreshModuleOnFocus('areas');

  const {
    isFormModalVisible,
    isDetailModalVisible,
    editingItem,
    selectedItem,
    isDeleting,
    handleOpenCreateModal,
    handleOpenEditModal,
    handleOpenDetailModal,
    handleCloseModals,
    deleteConfirmation,
  } = useCrudScreenLogic<Area>({
    entityName: 'rea',
    queryKey: [
      'areas',
      {
        name: searchQuery || undefined,
        isActive: filterStatus === 'all' ? undefined : filterStatus === 'true',
      },
    ],
    deleteMutationFn: deleteArea,
  });

  const isSubmitting =
    createAreaMutation.isPending || updateAreaMutation.isPending;

  const handleFormSubmit = async (data: CreateAreaDto | UpdateAreaDto) => {
    try {
      if (editingItem) {
        await updateAreaMutation.mutateAsync({
          id: editingItem.id,
          data: data as UpdateAreaDto,
        });
      } else {
        await createAreaMutation.mutateAsync(data as CreateAreaDto);
      }
      handleCloseModals();
    } catch (error) {
      // Error handled by mutation
    }
  };

  const handleNavigateToTables = (area: Area) => {
    navigation.navigate(NAVIGATION_PATHS.TABLES_LIST, {
      areaId: area.id,
      areaName: area.name,
    });
  };

  const listRenderConfig: RenderItemConfig<Area> = {
    titleField: 'name',
    descriptionField: 'description',
    statusConfig: {
      field: 'isActive',
      activeValue: true,
      activeLabel: 'Activa',
      inactiveLabel: 'Inactiva',
    },
  };

  const areaDetailFields: DisplayFieldConfig<Area>[] = [
    { field: 'description', label: 'Descripcin' },
  ];
  const areaDetailStatusConfig = listRenderConfig.statusConfig;

  const filterOptions: FilterOption<string>[] = useMemo(
    () => [
      { label: 'Todas', value: 'all' },
      { label: 'Activas', value: 'true' },
      { label: 'Inactivas', value: 'false' },
    ],
    [],
  );

  const handleFilterChange = (value: string | number) => {
    setFilterStatus(String(value));
  };

  const handleSearchChange = (query: string) => {
    setSearchQuery(query);
  };

  const handleRefresh = useCallback(() => {
    setSearchQuery('');
    setFilterStatus('all');
    refetchAreas();
  }, [refetchAreas]);

  const renderItemActions = (item: Area) => (
    <IconButton
      icon="format-list-bulleted"
      size={responsive.isTablet ? 24 : 28}
      onPress={() => handleNavigateToTables(item)}
      iconColor={theme.colors.primary}
    />
  );

  const { ListEmptyComponent } = useListState({
    isLoading: isLoadingAreas,
    isError: isErrorAreas,
    data: areasData,
    emptyConfig: {
      title: 'No hay reas',
      message:
        'No hay reas registradas. Presiona el botn + para crear la primera.',
      icon: 'map-marker-outline',
    },
    errorConfig: {
      title: 'Error al cargar reas',
      message: 'No se pudieron cargar las reas. Verifica tu conexin.',
      icon: 'alert-circle-outline',
      onAction: refetchAreas,
    },
  });

  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      <GenericList<Area>
        items={areasData}
        renderConfig={listRenderConfig}
        onItemPress={handleOpenDetailModal}
        onRefresh={handleRefresh}
        isRefreshing={isRefetching}
        ListEmptyComponent={ListEmptyComponent}
        enableSearch={true}
        searchQuery={searchQuery}
        onSearchChange={handleSearchChange}
        filterOptions={filterOptions}
        filterValue={filterStatus}
        onFilterChange={handleFilterChange}
        showFab={true}
        onFabPress={handleOpenCreateModal}
        renderItemActions={renderItemActions}
        isModalOpen={isFormModalVisible || isDetailModalVisible}
        isDrawerOpen={isDrawerOpen}
        showImagePlaceholder={false}
      />

      <AreaFormModal
        visible={isFormModalVisible}
        onDismiss={handleCloseModals}
        onSubmit={handleFormSubmit}
        editingItem={editingItem}
        isSubmitting={isSubmitting}
      />

      <GenericDetailModal<Area>
        visible={isDetailModalVisible}
        onDismiss={handleCloseModals}
        item={selectedItem}
        titleField="name"
        statusConfig={areaDetailStatusConfig}
        fieldsToDisplay={areaDetailFields}
        onEdit={() => {
          if (selectedItem) {
            handleOpenEditModal(selectedItem);
          }
        }}
        deleteConfirmation={deleteConfirmation}
        isDeleting={isDeleting}
        showImage={false}
      />
    </SafeAreaView>
  );
};

const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
  });

export default AreasScreen;

================
File: app/src/modules/areasTables/services/tableService.ts
================
import apiClient from '../../../app/services/apiClient';
import { API_PATHS } from '../../../app/constants/apiPaths';
import { BaseListQuery } from '../../../app/types/query.types';
import {
  Table,
  CreateTableDto,
  UpdateTableDto,
  FindAllTablesDto,
} from '../schema/table.schema';

const getTables = async (
  filterOptions: FindAllTablesDto = {},
  paginationOptions: BaseListQuery = { page: 1, limit: 10 },
): Promise<Table[]> => {
  const response = await apiClient.get<{
    items: Table[];
    total: number;
    page: number;
    limit: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  }>(API_PATHS.TABLES, {
    params: {
      ...filterOptions,
      page: paginationOptions.page,
      limit: paginationOptions.limit,
    },
  });

  return response.data.items;
};

const getTablesByAreaId = async (
  areaId: string,
  filterOptions: Omit<FindAllTablesDto, 'areaId'> = {},
  paginationOptions: BaseListQuery = { page: 1, limit: 100 },
): Promise<Table[]> => {
  const response = await apiClient.get<{
    items: Table[];
    total: number;
    page: number;
    limit: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  }>(API_PATHS.TABLES_BY_AREA.replace(':areaId', areaId), {
    params: {
      ...filterOptions,
      page: paginationOptions.page,
      limit: paginationOptions.limit,
    },
  });

  return response.data.items;
};

const getTableById = async (id: string): Promise<Table> => {
  const response = await apiClient.get<Table>(
    API_PATHS.TABLES_BY_ID.replace(':id', id),
  );

  return response.data;
};

const createTable = async (data: CreateTableDto): Promise<Table> => {
  const response = await apiClient.post<Table>(API_PATHS.TABLES, data);

  return response.data;
};

const updateTable = async (
  id: string,
  data: UpdateTableDto,
): Promise<Table> => {
  const response = await apiClient.patch<Table>(
    API_PATHS.TABLES_BY_ID.replace(':id', id),
    data,
  );

  return response.data;
};

const deleteTable = async (id: string): Promise<void> => {
  await apiClient.delete(API_PATHS.TABLES_BY_ID.replace(':id', id));
};

export const tableService = {
  getTables,
  getTablesByAreaId,
  getTableById,
  createTable,
  updateTable,
  deleteTable,
};

================
File: app/src/modules/auth/components/LoginForm.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet, Text } from 'react-native';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import {
  TextInput,
  Button,
  HelperText,
  Checkbox,
  TouchableRipple,
} from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { loginSchema, LoginFormInputs } from '../schema/auth.schema';

interface LoginFormProps {
  onSubmit: (data: LoginFormInputs, rememberMe: boolean) => void;
  isLoading: boolean;
  initialEmailOrUsername?: string;
  initialPassword?: string;
  initialRememberMe?: boolean;
}

const LoginForm: React.FC<LoginFormProps> = ({
  onSubmit,
  isLoading,
  initialEmailOrUsername = '',
  initialPassword = '',
  initialRememberMe = false,
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const [secureTextEntry, setSecureTextEntry] = useState(true);
  const [rememberMe, setRememberMe] = useState(initialRememberMe);

  const {
    control,
    handleSubmit,
    formState: { errors },
    reset,
  } = useForm<LoginFormInputs>({
    resolver: zodResolver(loginSchema),
    defaultValues: {
      emailOrUsername: initialEmailOrUsername,
      password: initialPassword,
    },
  });

  React.useEffect(() => {
    if (initialEmailOrUsername || initialPassword) {
      reset({
        emailOrUsername: initialEmailOrUsername || '',
        password: initialPassword || '',
      });
    }
  }, [initialEmailOrUsername, initialPassword, reset]);

  const toggleSecureEntry = () => {
    setSecureTextEntry(!secureTextEntry);
  };

  const styles = React.useMemo(
    () =>
      StyleSheet.create({
        container: {
          width: '100%',
        },
        input: {
          marginBottom: 8,
          fontSize: responsive.fontSizePreset.m,
        },
        firstInput: {
          marginTop: responsive.spacingPreset.xs,
        },
        button: {
          marginTop: 16,
          paddingVertical: responsive.spacingPreset.xs,
          backgroundColor: theme.colors.primary,
          borderRadius: 30,
        },
        buttonContent: {
          height: 42,
          paddingHorizontal: responsive.spacingPreset.s,
        },
        buttonLabel: {
          fontSize: responsive.fontSizePreset.m,
          fontWeight: '600',
        },
        helperText: {
          marginBottom: responsive.spacingPreset.xs,
          fontSize: responsive.fontSizePreset.s,
        },
        checkboxContainer: {
          flexDirection: 'row',
          alignItems: 'center',
          marginTop: 4,
          marginBottom: 8,
        },
        checkbox: {
          borderRadius: 4,
        },
        checkboxLabel: {
          color: theme.colors.onSurface,
          marginLeft: responsive.spacingPreset.s,
          flex: 1,
          flexShrink: 1,
          fontSize: responsive.fontSizePreset.m,
        },
      }),
    [theme, responsive],
  );

  return (
    <View style={styles.container}>
      <Controller
        control={control}
        name="emailOrUsername"
        render={({ field: { onChange, onBlur, value } }) => (
          <View>
            <TextInput
              label="Correo o Usuario"
              mode="outlined"
              onBlur={onBlur}
              onChangeText={onChange}
              value={value}
              error={!!errors.emailOrUsername}
              style={[styles.input, styles.firstInput]}
              autoCapitalize="none"
              keyboardType="email-address"
              disabled={isLoading}
            />
            {errors.emailOrUsername && (
              <HelperText
                type="error"
                visible={!!errors.emailOrUsername}
                style={styles.helperText}
              >
                <Text>{errors.emailOrUsername?.message}</Text>
              </HelperText>
            )}
          </View>
        )}
      />

      <Controller
        control={control}
        name="password"
        render={({ field: { onChange, onBlur, value } }) => (
          <View>
            <TextInput
              label="Contrasea"
              mode="outlined"
              onBlur={onBlur}
              onChangeText={onChange}
              value={value}
              secureTextEntry={secureTextEntry}
              error={!!errors.password}
              style={styles.input}
              autoCapitalize="none"
              right={
                <TextInput.Icon
                  icon={secureTextEntry ? 'eye' : 'eye-off'}
                  onPress={toggleSecureEntry}
                  forceTextInputFocus={false}
                  color={errors.password ? theme.colors.error : undefined}
                />
              }
              disabled={isLoading}
            />
            {errors.password && (
              <HelperText
                type="error"
                visible={!!errors.password}
                style={styles.helperText}
              >
                <Text>{errors.password?.message}</Text>
              </HelperText>
            )}
          </View>
        )}
      />

      <TouchableRipple
        onPress={() => !isLoading && setRememberMe(!rememberMe)}
        style={styles.checkboxContainer}
        disabled={isLoading}
      >
        <>
          <Checkbox
            status={rememberMe ? 'checked' : 'unchecked'}
            onPress={() => setRememberMe(!rememberMe)}
            disabled={isLoading}
          />
          <Text
            style={styles.checkboxLabel}
            numberOfLines={1}
            adjustsFontSizeToFit
            minimumFontScale={0.8}
          >
            Recordarme
          </Text>
        </>
      </TouchableRipple>

      <Button
        mode="contained"
        onPress={handleSubmit((data) => onSubmit(data, rememberMe))}
        loading={isLoading}
        disabled={isLoading}
        style={styles.button}
        contentStyle={styles.buttonContent}
        labelStyle={styles.buttonLabel}
      >
        {isLoading ? 'Ingresando...' : 'Ingresar'}
      </Button>
    </View>
  );
};

export default LoginForm;

================
File: app/src/modules/customers/components/CustomerFormModal.tsx
================
import { useEffect, useState } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Portal,
  Modal,
  Text,
  TextInput,
  Button,
  Switch,
  HelperText,
  Surface,
  IconButton,
  Chip,
  Avatar,
  Icon,
} from 'react-native-paper';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import {
  Customer,
  Address,
  CustomerFormInputs,
  customerFormSchema,
} from '../schema/customer.schema';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import AnimatedLabelSelector from '@/app/components/common/AnimatedLabelSelector';
import { DateTimePickerSafe } from '@/app/components/DateTimePickerSafe';
import PhoneNumberInput from '@/app/components/common/PhoneNumberInput';
import { useGetAddressesByCustomer } from '../hooks/useCustomersQueries';
import AddressFormModal from './AddressFormModal';
import { addressesService } from '../services/addressesService';
import { useSnackbarStore } from '@/app/store/snackbarStore';

interface CustomerFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSubmit: (data: CustomerFormInputs) => Promise<void>;
  editingItem: Customer | null;
  isSubmitting: boolean;
}

export default function CustomerFormModal({
  visible,
  onDismiss,
  onSubmit,
  editingItem,
  isSubmitting,
}: CustomerFormModalProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = getStyles(theme, responsive);
  const [showAddressModal, setShowAddressModal] = useState(false);
  const [editingAddress, setEditingAddress] = useState<Address | null>(null);
  const [isSubmittingAddress, setIsSubmittingAddress] = useState(false);
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [tempDate, setTempDate] = useState<Date>(new Date());
  const [dateOnChange, setDateOnChange] = useState<
    ((value: string) => void) | null
  >(null);
  const { showSnackbar } = useSnackbarStore();

  const { data: addresses = [], refetch: refetchAddresses } =
    useGetAddressesByCustomer(editingItem?.id || '', {
      enabled: !!editingItem?.id,
    });

  const {
    control,
    handleSubmit,
    formState: { errors },
    reset,
    watch,
  } = useForm<CustomerFormInputs>({
    resolver: zodResolver(customerFormSchema),
    defaultValues: {
      firstName: '',
      lastName: '',
      whatsappPhoneNumber: '',
      email: '',
      birthDate: '',
      isActive: true,
      isBanned: false,
      banReason: '',
    },
  });

  useEffect(() => {
    if (editingItem) {
      reset({
        firstName: editingItem.firstName,
        lastName: editingItem.lastName,
        whatsappPhoneNumber: editingItem.whatsappPhoneNumber || '',
        email: editingItem.email || '',
        birthDate: editingItem.birthDate
          ? new Date(editingItem.birthDate).toISOString().split('T')[0]
          : '',
        isActive: editingItem.isActive,
        isBanned: editingItem.isBanned || false,
        banReason: editingItem.banReason || '',
      });
    } else {
      reset({
        firstName: '',
        lastName: '',
        whatsappPhoneNumber: '',
        email: '',
        birthDate: '',
        isActive: true,
        isBanned: false,
        banReason: '',
      });
    }
  }, [editingItem, reset]);

  const isBanned = watch('isBanned');

  const handleAddressSubmit = async (data: any) => {
    try {
      setIsSubmittingAddress(true);
      if (editingAddress) {
        await addressesService.update(editingAddress.id, data);
        showSnackbar({ message: 'Direccin actualizada', type: 'success' });
      } else if (editingItem) {
        await addressesService.create(editingItem.id, data);
        showSnackbar({ message: 'Direccin agregada', type: 'success' });
      }
      await refetchAddresses();
      setShowAddressModal(false);
      setEditingAddress(null);
    } catch (error) {
      showSnackbar({ message: 'Error al guardar la direccin', type: 'error' });
    } finally {
      setIsSubmittingAddress(false);
    }
  };

  const handleFormSubmit = async (data: CustomerFormInputs) => {
    const cleanedData = {
      ...data,
      email: data.email || undefined,
      birthDate: data.birthDate || undefined,
      banReason: data.banReason || undefined,
    };

    await onSubmit(cleanedData);
  };

  return (
    <>
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onDismiss}
          contentContainerStyle={styles.modalContainer}
        >
          <Surface style={styles.modalContent} elevation={5}>
            <View
              style={[
                styles.headerContainer,
                { backgroundColor: theme.colors.primary },
              ]}
            >
              <View style={styles.headerLeft}>
                <Avatar.Icon
                  size={32}
                  icon={editingItem ? 'account-edit' : 'account-plus'}
                  style={[
                    styles.headerIcon,
                    { backgroundColor: theme.colors.onPrimary + '20' },
                  ]}
                  color={theme.colors.onPrimary}
                />
                <View style={styles.headerTextContainer}>
                  <Text
                    style={[
                      styles.modalTitle,
                      { color: theme.colors.onPrimary },
                    ]}
                    variant="titleMedium"
                  >
                    {editingItem ? 'Editar Cliente' : 'Nuevo Cliente'}
                  </Text>
                </View>
              </View>
              <IconButton
                icon="close"
                size={24}
                onPress={onDismiss}
                disabled={isSubmitting}
                iconColor={theme.colors.onPrimary}
              />
            </View>

            <ScrollView
              style={styles.formContainer}
              showsVerticalScrollIndicator={false}
              keyboardShouldPersistTaps="handled"
            >
              <View style={styles.sectionContainer}>
                <View style={styles.sectionHeader}>
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Informacin Personal
                  </Text>
                  <Chip
                    mode="flat"
                    compact
                    style={styles.requiredChip}
                    textStyle={styles.requiredChipText}
                  >
                    Requerido
                  </Chip>
                </View>

                <Controller
                  control={control}
                  name="firstName"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="Nombre"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.firstName}
                        mode="outlined"
                        placeholder="Ej: Juan"
                        left={<TextInput.Icon icon="account" />}
                        outlineStyle={styles.inputOutline}
                      />
                      {errors.firstName && (
                        <HelperText type="error" visible={!!errors.firstName}>
                          {errors.firstName.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />

                <Controller
                  control={control}
                  name="lastName"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="Apellido"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.lastName}
                        mode="outlined"
                        placeholder="Ej: Prez"
                        left={<TextInput.Icon icon="account" />}
                        outlineStyle={styles.inputOutline}
                      />
                      {errors.lastName && (
                        <HelperText type="error" visible={!!errors.lastName}>
                          {errors.lastName.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />
              </View>

              <View style={styles.sectionContainer}>
                <View style={styles.sectionHeader}>
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Informacin de Contacto
                  </Text>
                  <Chip
                    mode="flat"
                    compact
                    style={styles.optionalChip}
                    textStyle={styles.optionalChipText}
                  >
                    Opcional
                  </Chip>
                </View>

                <Controller
                  control={control}
                  name="whatsappPhoneNumber"
                  render={({ field: { onChange, value } }) => (
                    <View style={styles.inputContainer}>
                      <PhoneNumberInput
                        value={value || ''}
                        onChange={onChange}
                        error={!!errors.whatsappPhoneNumber}
                        helperText={errors.whatsappPhoneNumber?.message}
                        placeholder="Telfono"
                      />
                    </View>
                  )}
                />

                <Controller
                  control={control}
                  name="email"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="Correo electrnico"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.email}
                        mode="outlined"
                        placeholder="juan@example.com"
                        keyboardType="email-address"
                        autoCapitalize="none"
                        left={<TextInput.Icon icon="email" />}
                        outlineStyle={styles.inputOutline}
                      />
                      {errors.email && (
                        <HelperText type="error" visible={!!errors.email}>
                          {errors.email.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />

                <Controller
                  control={control}
                  name="birthDate"
                  render={({ field: { onChange, value } }) => (
                    <View style={styles.inputContainer}>
                      <AnimatedLabelSelector
                        label="Fecha de nacimiento"
                        value={
                          value
                            ? format(new Date(value), "d 'de' MMMM 'de' yyyy", {
                                locale: es,
                              })
                            : ''
                        }
                        onPress={() => {
                          setTempDate(value ? new Date(value) : new Date());
                          setDateOnChange(() => onChange);
                          setShowDatePicker(true);
                        }}
                        error={!!errors.birthDate}
                      />
                      {errors.birthDate && (
                        <HelperText type="error" visible={!!errors.birthDate}>
                          {errors.birthDate.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />
              </View>

              <View style={styles.sectionContainer}>
                <View style={styles.sectionHeader}>
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Estado
                  </Text>
                </View>

                <Controller
                  control={control}
                  name="isActive"
                  render={({ field: { onChange, value } }) => (
                    <Surface style={styles.switchContainer} elevation={1}>
                      <View style={styles.switchContent}>
                        <View style={styles.switchTextContainer}>
                          <Text style={styles.switchLabel} variant="bodyLarge">
                            Cliente activo
                          </Text>
                        </View>
                        <Switch
                          value={value}
                          onValueChange={onChange}
                          color={theme.colors.primary}
                        />
                      </View>
                    </Surface>
                  )}
                />

                <Controller
                  control={control}
                  name="isBanned"
                  render={({ field: { onChange, value } }) => (
                    <Surface
                      style={[styles.switchContainer, styles.bannedContainer]}
                      elevation={1}
                    >
                      <View style={styles.switchContent}>
                        <View style={styles.switchTextContainer}>
                          <Text style={styles.switchLabel} variant="bodyLarge">
                            Cliente baneado
                          </Text>
                          <Text
                            style={styles.switchDescription}
                            variant="bodySmall"
                          >
                            Los clientes baneados no pueden realizar pedidos
                          </Text>
                        </View>
                        <Switch
                          value={value}
                          onValueChange={onChange}
                          color={theme.colors.error}
                        />
                      </View>
                    </Surface>
                  )}
                />

                {isBanned && (
                  <>
                    <Controller
                      control={control}
                      name="banReason"
                      render={({ field: { onChange, onBlur, value } }) => (
                        <View
                          style={[
                            styles.inputContainer,
                            styles.banReasonContainer,
                          ]}
                        >
                          <TextInput
                            label="Razn del baneo"
                            value={value}
                            onChangeText={onChange}
                            onBlur={onBlur}
                            mode="outlined"
                            placeholder="Ej: Comportamiento inapropiado"
                            multiline
                            numberOfLines={2}
                            left={<TextInput.Icon icon="alert-circle" />}
                            outlineStyle={styles.inputOutline}
                            outlineColor={theme.colors.error}
                            activeOutlineColor={theme.colors.error}
                          />
                        </View>
                      )}
                    />

                    {editingItem?.bannedAt && (
                      <Surface style={styles.infoCard} elevation={1}>
                        <View style={styles.infoCardContent}>
                          <IconButton
                            icon="calendar-clock"
                            size={20}
                            iconColor={theme.colors.error}
                          />
                          <View style={styles.infoText}>
                            <Text
                              variant="labelMedium"
                              style={styles.infoLabel}
                            >
                              Fecha de baneo
                            </Text>
                            <Text variant="bodyMedium" style={styles.infoValue}>
                              {new Date(editingItem.bannedAt).toLocaleString()}
                            </Text>
                          </View>
                        </View>
                      </Surface>
                    )}
                  </>
                )}
              </View>

              {editingItem && (
                <View style={styles.sectionContainer}>
                  <View style={styles.sectionHeader}>
                    <Text style={styles.sectionTitle} variant="titleMedium">
                      Informacin de WhatsApp
                    </Text>
                  </View>

                  <Surface style={styles.whatsappCard} elevation={1}>
                    <View style={styles.whatsappRow}>
                      <View style={styles.whatsappStat}>
                        <Icon
                          source="message-text"
                          size={20}
                          color={theme.colors.primary}
                        />
                        <View style={styles.whatsappStatContent}>
                          <Text
                            variant="bodySmall"
                            style={styles.whatsappLabel}
                          >
                            Mensajes totales
                          </Text>
                          <Text
                            variant="titleMedium"
                            style={styles.whatsappValue}
                          >
                            {editingItem.whatsappMessageCount || 0}
                          </Text>
                        </View>
                      </View>

                      <View style={styles.whatsappDivider} />

                      <View style={styles.whatsappStat}>
                        <Icon
                          source="clock-outline"
                          size={20}
                          color={theme.colors.primary}
                        />
                        <View style={styles.whatsappStatContent}>
                          <Text
                            variant="bodySmall"
                            style={styles.whatsappLabel}
                          >
                            ltimo mensaje
                          </Text>
                          <Text
                            variant="bodyMedium"
                            style={styles.whatsappValue}
                          >
                            {editingItem.lastWhatsappMessageTime
                              ? new Date(
                                  editingItem.lastWhatsappMessageTime,
                                ).toLocaleDateString()
                              : 'Sin mensajes'}
                          </Text>
                        </View>
                      </View>
                    </View>
                  </Surface>
                </View>
              )}

              {editingItem?.stripeCustomerId && (
                <View style={styles.sectionContainer}>
                  <View style={styles.sectionHeader}>
                    <Text style={styles.sectionTitle} variant="titleMedium">
                      Informacin de Pago
                    </Text>
                  </View>

                  <Surface style={styles.stripeCard} elevation={1}>
                    <View style={styles.stripeContent}>
                      <Icon
                        source="credit-card"
                        size={24}
                        color={theme.colors.primary}
                      />
                      <View style={styles.stripeInfo}>
                        <Text variant="bodySmall" style={styles.stripeLabel}>
                          Stripe Customer ID
                        </Text>
                        <Text
                          variant="bodyMedium"
                          style={styles.stripeValue}
                          selectable
                        >
                          {editingItem.stripeCustomerId}
                        </Text>
                      </View>
                    </View>
                  </Surface>
                </View>
              )}

              {editingItem && (
                <View style={styles.sectionContainer}>
                  <View style={styles.sectionHeader}>
                    <Text style={styles.sectionTitle} variant="titleMedium">
                      Direcciones
                    </Text>
                    <Button
                      mode="text"
                      onPress={() => {
                        setEditingAddress(null);
                        setShowAddressModal(true);
                      }}
                      icon="plus"
                      compact
                    >
                      Agregar
                    </Button>
                  </View>

                  {addresses.length === 0 ? (
                    <Surface style={styles.emptyAddressContainer} elevation={0}>
                      <Text
                        style={styles.emptyAddressText}
                        variant="bodyMedium"
                      >
                        No hay direcciones registradas
                      </Text>
                    </Surface>
                  ) : (
                    <View style={styles.addressList}>
                      {addresses.map((address: Address) => (
                        <Surface
                          key={address.id}
                          style={styles.addressCard}
                          elevation={1}
                        >
                          <View style={styles.addressContent}>
                            <View style={styles.addressHeader}>
                              <IconButton
                                icon="map-marker"
                                size={20}
                                iconColor={theme.colors.primary}
                              />
                              <View style={styles.addressInfo}>
                                <Text
                                  style={styles.addressName}
                                  variant="titleSmall"
                                >
                                  {address.name}
                                </Text>
                                <Text
                                  style={styles.addressStreet}
                                  variant="bodyMedium"
                                >
                                  {address.street} {address.number}
                                  {address.interiorNumber &&
                                    `, ${address.interiorNumber}`}
                                </Text>
                                <Text
                                  style={styles.addressDetails}
                                  variant="bodySmall"
                                >
                                  {address.neighborhood}, {address.city},{' '}
                                  {address.state}
                                </Text>
                                {address.isDefault && (
                                  <Chip
                                    mode="flat"
                                    compact
                                    style={styles.defaultChip}
                                    textStyle={styles.defaultChipText}
                                  >
                                    Predeterminada
                                  </Chip>
                                )}
                              </View>
                            </View>
                            <View style={styles.addressActions}>
                              <IconButton
                                icon="pencil"
                                size={20}
                                onPress={() => {
                                  setEditingAddress(address);
                                  setShowAddressModal(true);
                                }}
                              />
                              <IconButton
                                icon="delete"
                                size={20}
                                iconColor={theme.colors.error}
                                onPress={async () => {
                                  try {
                                    await addressesService.remove(address.id);
                                    await refetchAddresses();
                                    showSnackbar({
                                      message: 'Direccin eliminada',
                                      type: 'success',
                                    });
                                  } catch (error) {
                                    showSnackbar({
                                      message: 'Error al eliminar la direccin',
                                      type: 'error',
                                    });
                                  }
                                }}
                              />
                            </View>
                          </View>
                        </Surface>
                      ))}
                    </View>
                  )}
                </View>
              )}

              <View style={styles.scrollSpacer} />
            </ScrollView>

            <Surface style={styles.buttonContainer} elevation={2}>
              <Button
                onPress={onDismiss}
                disabled={isSubmitting}
                style={[styles.button, styles.cancelButton]}
                textColor={theme.colors.onSecondaryContainer}
              >
                Cancelar
              </Button>
              <Button
                mode="contained"
                onPress={handleSubmit(handleFormSubmit)}
                disabled={isSubmitting}
                loading={isSubmitting}
                style={[styles.button, styles.confirmButton]}
                buttonColor={theme.colors.primary}
              >
                {editingItem ? 'Guardar' : 'Crear'}
              </Button>
            </Surface>
          </Surface>
        </Modal>
      </Portal>

      {editingItem && (
        <AddressFormModal
          visible={showAddressModal}
          onDismiss={() => {
            setShowAddressModal(false);
            setEditingAddress(null);
          }}
          onSubmit={handleAddressSubmit}
          editingItem={editingAddress}
          isSubmitting={isSubmittingAddress}
          customerId={editingItem.id}
        />
      )}

      <DateTimePickerSafe
        visible={showDatePicker}
        mode="date"
        value={tempDate}
        onConfirm={(date) => {
          if (dateOnChange) {
            dateOnChange(date.toISOString().split('T')[0]);
          }
          setShowDatePicker(false);
        }}
        onCancel={() => setShowDatePicker(false)}
        title="Fecha de nacimiento"
        maximumDate={new Date()}
      />
    </>
  );
}

const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    modalContainer: {
      margin: responsive.isTablet ? 20 : 10,
      justifyContent: 'center',
      alignItems: 'center',
    },
    modalContent: {
      borderRadius: theme.roundness * 2,
      backgroundColor: theme.colors.surface,
      maxHeight: '95%',
      minHeight: responsive.isTablet ? 600 : '80%',
      width: responsive.isTablet ? '85%' : '100%',
      maxWidth: responsive.isTablet ? 800 : undefined,
      overflow: 'hidden',
    },
    headerContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingHorizontal: responsive.isTablet
        ? theme.spacing.m * 0.7
        : theme.spacing.m,
      paddingVertical: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    headerLeft: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
    },
    headerIcon: {
      marginRight: responsive.isTablet
        ? theme.spacing.s * 0.7
        : theme.spacing.s,
    },
    headerTextContainer: {
      flex: 1,
    },
    modalTitle: {
      fontWeight: '700',
      fontSize: responsive.isTablet ? 16 : 18,
    },
    formContainer: {
      flex: 1,
      paddingHorizontal: responsive.isTablet
        ? theme.spacing.m * 0.7
        : theme.spacing.m,
      paddingTop: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    sectionContainer: {
      marginBottom: responsive.isTablet
        ? theme.spacing.s * 0.7
        : theme.spacing.s,
    },
    sectionHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    sectionTitle: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: responsive.isTablet ? 13 : 14,
    },
    requiredChip: {
      backgroundColor: theme.colors.errorContainer,
    },
    requiredChipText: {
      color: theme.colors.onErrorContainer,
      fontSize: responsive.isTablet ? 10 : 11,
    },
    optionalChip: {
      backgroundColor: theme.colors.surfaceVariant,
    },
    optionalChipText: {
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 10 : 11,
    },
    inputContainer: {
      marginBottom: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    inputOutline: {
      borderRadius: theme.roundness * 2,
    },
    switchContainer: {
      borderRadius: theme.roundness * 2,
      padding: responsive.isTablet ? theme.spacing.xs * 0.7 : theme.spacing.xs,
    },
    switchContent: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    switchTextContainer: {
      flex: 1,
      marginRight: responsive.isTablet
        ? theme.spacing.m * 0.7
        : theme.spacing.m,
    },
    switchLabel: {
      color: theme.colors.onSurface,
      fontWeight: '500',
      fontSize: responsive.isTablet ? 14 : 16,
    },
    switchDescription: {
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
      fontSize: responsive.isTablet ? 12 : 14,
    },
    bannedContainer: {
      marginTop: responsive.isTablet ? theme.spacing.s * 0.7 : theme.spacing.s,
    },
    banReasonContainer: {
      marginTop: responsive.isTablet ? theme.spacing.s * 0.7 : theme.spacing.s,
    },
    infoCard: {
      borderRadius: theme.roundness * 2,
      padding: responsive.isTablet ? theme.spacing.m * 0.7 : theme.spacing.m,
      marginTop: responsive.isTablet ? theme.spacing.s * 0.7 : theme.spacing.s,
      backgroundColor: theme.colors.errorContainer,
    },
    infoCardContent: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    infoText: {
      flex: 1,
      marginLeft: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    infoLabel: {
      color: theme.colors.onErrorContainer,
      opacity: 0.8,
      fontSize: responsive.isTablet ? 11 : 12,
    },
    infoValue: {
      color: theme.colors.onErrorContainer,
      fontWeight: '500',
      fontSize: responsive.isTablet ? 13 : 14,
    },
    whatsappCard: {
      borderRadius: theme.roundness * 2,
      padding: responsive.isTablet ? theme.spacing.m * 0.7 : theme.spacing.m,
      backgroundColor: theme.colors.primaryContainer + '20',
    },
    whatsappRow: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    whatsappStat: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.isTablet ? theme.spacing.s * 0.7 : theme.spacing.s,
    },
    whatsappStatContent: {
      flex: 1,
    },
    whatsappLabel: {
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 11 : 12,
    },
    whatsappValue: {
      color: theme.colors.onSurface,
      fontWeight: '600',
      marginTop: 2,
      fontSize: responsive.isTablet ? 13 : 14,
    },
    whatsappDivider: {
      width: 1,
      height: responsive.isTablet ? 35 : 40,
      backgroundColor: theme.colors.outlineVariant,
      marginHorizontal: responsive.isTablet
        ? theme.spacing.m * 0.7
        : theme.spacing.m,
    },
    stripeCard: {
      borderRadius: theme.roundness * 2,
      padding: responsive.isTablet ? theme.spacing.m * 0.7 : theme.spacing.m,
      backgroundColor: theme.colors.surfaceVariant,
    },
    stripeContent: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.isTablet ? theme.spacing.m * 0.7 : theme.spacing.m,
    },
    stripeInfo: {
      flex: 1,
    },
    stripeLabel: {
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 11 : 12,
      marginBottom: responsive.isTablet ? 3 : 4,
    },
    stripeValue: {
      color: theme.colors.onSurface,
      fontWeight: '500',
      fontFamily: 'monospace',
      fontSize: responsive.isTablet ? 13 : 14,
    },
    buttonContainer: {
      flexDirection: 'row',
      justifyContent: 'center',
      padding: responsive.isTablet ? theme.spacing.s * 0.7 : theme.spacing.s,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      gap: responsive.isTablet ? theme.spacing.s * 0.7 : theme.spacing.s,
      borderBottomLeftRadius: theme.roundness * 2,
      borderBottomRightRadius: theme.roundness * 2,
    },
    button: {
      flex: 1,
      maxWidth: 150,
    },
    cancelButton: {
      backgroundColor: theme.colors.secondaryContainer,
    },
    confirmButton: {},
    addressList: {
      gap: responsive.isTablet ? theme.spacing.s * 0.7 : theme.spacing.s,
    },
    addressCard: {
      borderRadius: theme.roundness * 2,
      padding: responsive.isTablet ? theme.spacing.s * 0.7 : theme.spacing.s,
      marginBottom: responsive.isTablet
        ? theme.spacing.xs * 0.65
        : theme.spacing.xs,
    },
    addressContent: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
    },
    addressHeader: {
      flexDirection: 'row',
      flex: 1,
    },
    addressInfo: {
      flex: 1,
      marginLeft: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    addressName: {
      fontWeight: '600',
      color: theme.colors.primary,
      fontSize: responsive.isTablet ? 13 : 14,
    },
    addressStreet: {
      fontWeight: '500',
      color: theme.colors.onSurface,
      fontSize: responsive.isTablet ? 13 : 14,
    },
    addressDetails: {
      color: theme.colors.onSurfaceVariant,
      marginTop: responsive.isTablet
        ? theme.spacing.xs * 0.65
        : theme.spacing.xs,
      fontSize: responsive.isTablet ? 12 : 13,
    },
    addressActions: {
      flexDirection: 'row',
    },
    defaultChip: {
      marginTop: responsive.isTablet
        ? theme.spacing.xs * 0.65
        : theme.spacing.xs,
      backgroundColor: theme.colors.primaryContainer,
    },
    defaultChipText: {
      color: theme.colors.onPrimaryContainer,
      fontSize: responsive.isTablet ? 9 : 10,
    },
    emptyAddressContainer: {
      padding: responsive.isTablet ? theme.spacing.l * 0.7 : theme.spacing.l,
      borderRadius: theme.roundness * 2,
      backgroundColor: theme.colors.surfaceVariant,
      alignItems: 'center',
    },
    emptyAddressText: {
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 13 : 14,
    },
    scrollSpacer: {
      height: 10,
    },
  });

================
File: app/src/modules/customers/services/customersService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import {
  Customer,
  FindAllCustomersQuery,
  ChatMessage,
  CreateCustomerInput,
  UpdateCustomerInput,
} from '../schema/customer.schema';

async function findAll(params?: FindAllCustomersQuery): Promise<Customer[]> {
  const response = await apiClient.get<Customer[]>(API_PATHS.CUSTOMERS, {
    params,
  });
  return response.data;
}

async function findOne(id: string): Promise<Customer> {
  const response = await apiClient.get<Customer>(
    API_PATHS.CUSTOMERS_BY_ID.replace(':id', id),
  );
  return response.data;
}

async function create(data: CreateCustomerInput): Promise<Customer> {
  const response = await apiClient.post<Customer>(API_PATHS.CUSTOMERS, data);
  return response.data;
}

async function update(
  id: string,
  data: UpdateCustomerInput,
): Promise<Customer> {
  const response = await apiClient.patch<Customer>(
    API_PATHS.CUSTOMERS_BY_ID.replace(':id', id),
    data,
  );
  return response.data;
}

async function remove(id: string): Promise<void> {
  await apiClient.delete(API_PATHS.CUSTOMERS_BY_ID.replace(':id', id));
}

// Mtodos especficos para chat history
async function appendChatMessage(
  customerId: string,
  message: Omit<ChatMessage, 'timestamp'>,
): Promise<Customer> {
  const response = await apiClient.post<Customer>(
    API_PATHS.CUSTOMERS_CHAT_MESSAGE.replace(':customerId', customerId),
    message,
  );
  return response.data;
}

async function updateRelevantChatHistory(
  customerId: string,
  relevantHistory: ChatMessage[],
): Promise<Customer> {
  const response = await apiClient.patch<Customer>(
    API_PATHS.CUSTOMERS_CHAT_HISTORY.replace(':customerId', customerId),
    { relevantHistory },
  );
  return response.data;
}

async function updateCustomerStats(
  customerId: string,
  stats: { totalOrders?: number; totalSpent?: number },
): Promise<Customer> {
  const response = await apiClient.patch<Customer>(
    API_PATHS.CUSTOMERS_STATS.replace(':customerId', customerId),
    stats,
  );
  return response.data;
}

async function getActiveWithRecentInteraction(
  daysAgo: number = 30,
): Promise<Customer[]> {
  const response = await apiClient.get<Customer[]>(
    API_PATHS.CUSTOMERS_ACTIVE_RECENT,
    { params: { daysAgo } },
  );
  return response.data;
}

export const customersService = {
  findAll,
  findOne,
  create,
  update,
  remove,
  appendChatMessage,
  updateRelevantChatHistory,
  updateCustomerStats,
  getActiveWithRecentInteraction,
};

================
File: app/src/modules/orders/components/order-cart/DineInForm.tsx
================
import React, {
  useState,
  useImperativeHandle,
  forwardRef,
  useCallback,
} from 'react';
import { View, StyleSheet, TouchableOpacity } from 'react-native';
import { Text, Menu, HelperText, Checkbox } from 'react-native-paper';
import AnimatedLabelSelector from '@/app/components/common/AnimatedLabelSelector';
import SpeechRecognitionInput from '@/app/components/common/SpeechRecognitionInput';
import { useAppTheme } from '@/app/styles/theme';
import type { Table } from '@/modules/areasTables/schema/table.schema';
import { useOrderStore } from '../../stores/useOrderStore';
import { useGetAreas } from '@/modules/areasTables/hooks/useAreasQueries';
import { useGetTablesByAreaId } from '@/modules/areasTables/hooks/useTablesQueries';
import { format } from 'date-fns';

interface DineInFormProps {
  onScheduleTimePress: () => void;
}

export interface DineInFormRef {
  validate: () => boolean;
}

export const DineInForm = forwardRef<DineInFormRef, DineInFormProps>(
  ({ onScheduleTimePress }, ref) => {
    const {
      selectedAreaId,
      selectedTableId,
      isTemporaryTable,
      temporaryTableName,
      orderNotes,
      scheduledTime,
      isEditMode,
      setSelectedAreaId,
      setSelectedTableId,
      setIsTemporaryTable,
      setTemporaryTableName,
      setOrderNotes,
      setScheduledTime,
    } = useOrderStore();
    const {
      data: areasData = [],
      isLoading: isLoadingAreas,
      error: errorAreas,
    } = useGetAreas();
    const {
      data: tablesData = [],
      isLoading: isLoadingTables,
      error: errorTables,
    } = useGetTablesByAreaId(selectedAreaId || '', {}, { enabled: !!selectedAreaId });
    const selectedAreaName =
      areasData.find((a: any) => a.id === selectedAreaId)?.name ||
      'Selecciona un rea';
    const selectedTableName =
      tablesData.find((t: Table) => t.id === selectedTableId)?.name ||
      'Selecciona una mesa';
    const formattedScheduledTime = scheduledTime
      ? format(scheduledTime, 'h:mm a').toLowerCase()
      : '';
    const theme = useAppTheme();
    const styles = React.useMemo(() => createStyles(theme), [theme]);
    const [areaMenuVisible, setAreaMenuVisible] = useState(false);
    const [tableMenuVisible, setTableMenuVisible] = useState(false);
    const [areaError, setAreaError] = useState<string | null>(null);
    const [tableError, setTableError] = useState<string | null>(null);
    const handleScheduleTimeClear = () => {
      setScheduledTime(null);
    };
    React.useEffect(() => {
      if (selectedAreaId) {
        setAreaError(null);
      }
    }, [selectedAreaId]);
    React.useEffect(() => {
      if (selectedTableId || (isTemporaryTable && temporaryTableName)) {
        setTableError(null);
      }
    }, [selectedTableId, isTemporaryTable, temporaryTableName]);
    const validate = useCallback(() => {
      let isValid = true;

      if (!selectedAreaId) {
        setAreaError('Por favor selecciona un rea');
        isValid = false;
      }

      if (!isTemporaryTable && !selectedTableId) {
        setTableError('Por favor selecciona una mesa');
        isValid = false;
      }

      if (isTemporaryTable && !temporaryTableName.trim()) {
        setTableError('Por favor ingresa el nombre de la mesa temporal');
        isValid = false;
      }

      return isValid;
    }, [selectedAreaId, selectedTableId, isTemporaryTable, temporaryTableName]);
    useImperativeHandle(
      ref,
      () => ({
        validate,
      }),
      [validate],
    );

    return (
      <>
        <View style={styles.selectorsRow}>
          <View style={styles.selectorContainer}>
            <Menu
              visible={areaMenuVisible}
              onDismiss={() => setAreaMenuVisible(false)}
              anchor={
                <AnimatedLabelSelector
                  label="rea *"
                  value={selectedAreaName}
                  onPress={() => setAreaMenuVisible(true)}
                  isLoading={isLoadingAreas}
                  error={!!areaError || !!errorAreas}
                  disabled={isLoadingAreas}
                />
              }
            >
              {areasData?.map((area: any) => (
                <Menu.Item
                  key={area.id}
                  onPress={() => {
                    setSelectedAreaId(area.id);
                    setAreaMenuVisible(false);
                    setAreaError(null);
                  }}
                  title={area.name}
                />
              ))}
              {errorAreas && (
                <Menu.Item title="Error al cargar reas" disabled />
              )}
            </Menu>
            {areaError && !errorAreas && (
              <HelperText type="error" visible={true} style={styles.helperText}>
                {areaError}
              </HelperText>
            )}
            {errorAreas && (
              <HelperText type="error" visible={true} style={styles.helperText}>
                Error al cargar reas
              </HelperText>
            )}
          </View>

          <View style={styles.selectorContainer}>
            <Menu
              visible={tableMenuVisible}
              onDismiss={() => setTableMenuVisible(false)}
              anchor={
                <AnimatedLabelSelector
                  label="Mesa *"
                  value={selectedTableName}
                  onPress={() => setTableMenuVisible(true)}
                  isLoading={isLoadingTables}
                  error={!!tableError || !!errorTables}
                  disabled={
                    !selectedAreaId ||
                    isLoadingTables ||
                    isLoadingAreas ||
                    isTemporaryTable
                  }
                />
              }
            >
              {tablesData?.map((table: Table) => {
                const isCurrentTable =
                  isEditMode && selectedTableId === table.id;
                const canSelect = table.isAvailable || isCurrentTable;

                return (
                  <Menu.Item
                    key={table.id}
                    onPress={() => {
                      if (canSelect) {
                        setSelectedTableId(table.id);
                        setTableMenuVisible(false);
                        setTableError(null);
                      }
                    }}
                    title={`${table.name}${!table.isAvailable && !isCurrentTable ? ' (Ocupada)' : ''}`}
                    disabled={!canSelect}
                    titleStyle={
                      !canSelect ? { color: theme.colors.error } : undefined
                    }
                  />
                );
              })}
              {selectedAreaId &&
                tablesData?.length === 0 &&
                !isLoadingTables &&
                !errorTables && <Menu.Item title="No hay mesas" disabled />}
              {errorTables && (
                <Menu.Item title="Error al cargar mesas" disabled />
              )}
            </Menu>
            {tableError && !errorTables && !isTemporaryTable && (
              <HelperText type="error" visible={true} style={styles.helperText}>
                {tableError}
              </HelperText>
            )}
            {errorTables && (
              <HelperText type="error" visible={true} style={styles.helperText}>
                Error al cargar mesas
              </HelperText>
            )}
          </View>
        </View>

        <View style={[styles.section, styles.fieldContainer]}>
          <TouchableOpacity
            onPress={() => {
              setIsTemporaryTable(!isTemporaryTable);
              if (tableError) setTableError(null);
            }}
            style={styles.checkboxContainer}
          >
            <Checkbox.Android
              status={isTemporaryTable ? 'checked' : 'unchecked'}
              onPress={() => {
                setIsTemporaryTable(!isTemporaryTable);
                if (tableError) setTableError(null);
              }}
              color={theme.colors.primary}
            />
            <Text style={styles.checkboxLabel}>
              {isEditMode && isTemporaryTable
                ? 'Mesa temporal'
                : 'Crear mesa temporal'}
            </Text>
          </TouchableOpacity>

          {isTemporaryTable && (
            <View style={styles.temporaryTableInputContainer}>
              <SpeechRecognitionInput
                key={`temporary-table-name-${isEditMode ? 'edit' : 'create'}`}
                label="Nombre de la Mesa Temporal *"
                value={temporaryTableName}
                onChangeText={(text) => {
                  setTemporaryTableName(text);
                  if (tableError) setTableError(null);
                }}
                error={!!tableError && isTemporaryTable}
                speechLang="es-MX"
                autoCapitalize="words"
                autoCorrect={false}
                placeholder="Ej: Mesa Terraza 1"
                editable={true}
              />
              {tableError && isTemporaryTable && (
                <HelperText
                  type="error"
                  visible={true}
                  style={styles.helperText}
                >
                  {tableError}
                </HelperText>
              )}
            </View>
          )}
        </View>

        <View style={[styles.section, styles.fieldContainer]}>
          <SpeechRecognitionInput
            key="notes-input-dine-in"
            label="Notas de la Orden (Opcional)"
            value={orderNotes}
            onChangeText={setOrderNotes}
            multiline
            speechLang="es-MX"
          />
        </View>

        <View style={[styles.section, styles.fieldContainer]}>
          <AnimatedLabelSelector
            label="Programar Hora (Opcional)"
            value={formattedScheduledTime}
            onPress={onScheduleTimePress}
            onClear={handleScheduleTimeClear}
          />
        </View>
      </>
    );
  },
);

DineInForm.displayName = 'DineInForm';

const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    selectorsRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      paddingHorizontal: theme.spacing.xs,
      marginBottom: theme.spacing.xs,
    },
    selectorContainer: {
      flex: 1,
      marginHorizontal: theme.spacing.xxs,
    },
    section: {
      paddingVertical: theme.spacing.xs,
      paddingHorizontal: theme.spacing.xs,
      marginBottom: theme.spacing.xs,
    },
    fieldContainer: {
      marginBottom: theme.spacing.xs,
    },
    helperText: {
      fontSize: 12,
      paddingHorizontal: 0,
      paddingTop: 0,
      marginTop: -4,
    },
    checkboxContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      marginTop: theme.spacing.s,
      marginBottom: theme.spacing.xs,
    },
    checkboxLabel: {
      fontSize: 16,
      marginLeft: theme.spacing.xs,
      color: theme.colors.onSurface,
    },
    temporaryTableInputContainer: {
      marginTop: theme.spacing.xs,
      marginBottom: theme.spacing.s,
    },
  });

================
File: app/src/modules/orders/components/order-cart/ModalsContainer.tsx
================
import React from 'react';
import { Portal } from 'react-native-paper';
import DateTimePickerSafe from '@/app/components/DateTimePickerSafe';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
import ProductCustomizationModal from '../ProductCustomizationModal';
import { OrderDetailModal } from '../OrderDetailModal';
import OrderHistoryModal from '@/modules/shared/components/OrderHistoryModal';
import PaymentModal from '../PaymentModal';
import { AdjustmentFormModal } from '../AdjustmentFormModal';
import { OrderTypeEnum } from '../../schema/orders.schema';
import type { OrderAdjustment } from '../../schema/adjustments.schema';
import { useModalStore, modalHelpers } from '../../stores/useModalStore';

export const ModalsContainer: React.FC<Record<string, never>> = () => {
  const { modalType, modalProps, isVisible } = useModalStore();
  if (!isVisible || !modalType) {
    return null;
  }

  const renderModal = () => {
    switch (modalType) {
      case 'timePicker':
        return (
          <Portal>
            <DateTimePickerSafe
              visible={true}
              mode="time"
              value={modalProps.scheduledTime}
              onConfirm={modalProps.onTimeConfirm}
              onCancel={() => {
                modalProps.hideTimePicker?.();
                modalHelpers.hideModal();
              }}
              minimumDate={new Date()}
              minuteInterval={5}
              title={
                modalProps.orderType === OrderTypeEnum.DELIVERY
                  ? 'Seleccionar Hora de Entrega'
                  : modalProps.orderType === OrderTypeEnum.TAKE_AWAY
                    ? 'Seleccionar Hora de Recoleccin'
                    : 'Seleccionar Hora'
              }
              allowManualInput={true}
            />
          </Portal>
        );

      case 'timeAlert':
        return (
          <ConfirmationModal
            visible={true}
            title="Hora Invlida"
            message="No puedes seleccionar una hora que ya ha pasado. Por favor, elige una hora futura."
            confirmText="Entendido"
            onConfirm={modalHelpers.hideModal}
          />
        );

      case 'exitConfirmation':
        return (
          <ConfirmationModal
            visible={true}
            title="Descartar cambios?"
            message="Tienes cambios sin guardar. Ests seguro de que quieres salir?"
            confirmText="Descartar"
            cancelText="Cancelar"
            onConfirm={() => {
              modalHelpers.hideModal();
              modalProps.onClose?.();
            }}
            onCancel={modalHelpers.hideModal}
          />
        );

      case 'cancelConfirmation':
        return (
          <ConfirmationModal
            visible={true}
            title="Cancelar orden?"
            message={`Ests seguro de que quieres cancelar la orden #${modalProps.orderNumber}? Esta accin no se puede deshacer.`}
            confirmText="Cancelar Orden"
            cancelText="No, mantener"
            onConfirm={() => {
              modalHelpers.hideModal();
              modalProps.onCancelOrder?.();
            }}
            onCancel={modalHelpers.hideModal}
          />
        );

      case 'modifyInProgressConfirmation':
        return (
          <ConfirmationModal
            visible={true}
            title="Modificar producto en preparacin?"
            message={`El producto "${modalProps.modifyingItemName}" est actualmente en preparacin. Ests seguro de que quieres modificarlo?`}
            confirmText="S, modificar"
            cancelText="No, cancelar"
            onConfirm={() => {
              modalHelpers.hideModal();
              if (modalProps.pendingModifyAction) {
                modalProps.pendingModifyAction();
                modalProps.setPendingModifyAction(null);
              }
              modalProps.setModifyingItemName('');
            }}
            onCancel={() => {
              modalHelpers.hideModal();
              modalProps.setPendingModifyAction(null);
              modalProps.setModifyingItemName('');
            }}
          />
        );

      case 'deletePrepaymentConfirm':
        return (
          <ConfirmationModal
            visible={true}
            title="Eliminar prepago?"
            message="Ests seguro de que deseas eliminar este prepago? Esta accin no se puede deshacer."
            confirmText="Eliminar"
            cancelText="Cancelar"
            onConfirm={async () => {
              await modalProps.confirmDeletePrepayment();
              modalHelpers.hideModal();
            }}
            onCancel={modalHelpers.hideModal}
          />
        );

      case 'productCustomization':
        return (
          <ProductCustomizationModal
            visible={true}
            product={modalProps.editingProduct}
            editingItem={modalProps.editingItemFromList}
            onDismiss={() => {
              modalProps.clearEditingState();
              modalHelpers.hideModal();
            }}
            onAddToCart={() => {}}
            onUpdateItem={modalProps.handleUpdateEditedItem}
          />
        );

      case 'orderDetail':
        return (
          <OrderDetailModal
            visible={true}
            onDismiss={modalHelpers.hideModal}
            orderId={modalProps.orderId}
            orderNumber={modalProps.orderNumber}
            orderData={modalProps.orderData}
          />
        );

      case 'orderHistory':
        return (
          <OrderHistoryModal
            visible={true}
            onDismiss={modalHelpers.hideModal}
            orderId={modalProps.orderId}
            orderNumber={modalProps.orderNumber}
          />
        );

      case 'payment':
        return (
          <PaymentModal
            visible={true}
            onDismiss={modalHelpers.hideModal}
            orderId={modalProps.orderId}
            orderTotal={modalProps.orderTotal}
            orderNumber={modalProps.orderNumber}
            orderStatus={modalProps.orderStatus}
            onOrderCompleted={() => {
              modalHelpers.hideModal();
              modalProps.onOrderCompleted?.();
            }}
          />
        );

      case 'adjustment':
        return (
          <AdjustmentFormModal
            visible={true}
            onDismiss={() => {
              modalHelpers.hideModal();
              modalProps.setAdjustmentToEdit(null);
            }}
            onSave={(adjustment: OrderAdjustment) => {
              if (modalProps.adjustmentToEdit) {
                modalProps.handleUpdateAdjustment(
                  modalProps.adjustmentToEdit.id!,
                  adjustment,
                );
              } else {
                modalProps.handleAddAdjustment(adjustment);
              }
              modalHelpers.hideModal();
              modalProps.setAdjustmentToEdit(null);
            }}
            adjustment={modalProps.adjustmentToEdit}
            orderSubtotal={modalProps.subtotal}
          />
        );

      case 'prepayment':
        return (
          <PaymentModal
            visible={true}
            onDismiss={modalHelpers.hideModal}
            orderTotal={modalProps.orderTotal}
            mode="prepayment"
            onPrepaymentCreated={modalProps.handlePrepaymentCreated}
            existingPrepaymentId={modalProps.prepaymentId || undefined}
            onPrepaymentDeleted={modalProps.handlePrepaymentDeleted}
          />
        );

      default:
        return null;
    }
  };

  return <>{renderModal()}</>;
};

================
File: app/src/modules/orders/components/order-cart/OrderItemsList.tsx
================
import React, { useMemo } from 'react';
import { View, StyleSheet, TouchableOpacity, Animated } from 'react-native';
import { Text, IconButton, List } from 'react-native-paper';
import { Swipeable } from 'react-native-gesture-handler';
import { useAppTheme } from '@/app/styles/theme';
import type { CartItem } from '../../stores/useOrderStore';
import { PreparationStatusInfo } from '../../utils/formatters';

interface OrderItemsListProps {
  items: CartItem[];
  onUpdateQuantity: (itemId: string, quantity: number) => void;
  onRemoveItem: (itemId: string) => void;
  onEditItem?: (item: CartItem) => void;
  isEditMode?: boolean;
  disabled?: boolean;
}

export const OrderItemsList: React.FC<OrderItemsListProps> = ({
  items,
  onUpdateQuantity,
  onRemoveItem,
  onEditItem,
  isEditMode = false,
  disabled = false,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);

  const renderRightActions = (
    _progress: Animated.AnimatedInterpolation<number>,
    dragX: Animated.AnimatedInterpolation<number>,
    _item: CartItem,
  ) => {
    const translateX = dragX.interpolate({
      inputRange: [-100, 0],
      outputRange: [0, 100],
      extrapolate: 'clamp',
    });

    const scale = dragX.interpolate({
      inputRange: [-100, -50, 0],
      outputRange: [1, 0.8, 0.5],
      extrapolate: 'clamp',
    });

    const opacity = dragX.interpolate({
      inputRange: [-100, -20, 0],
      outputRange: [1, 0.5, 0],
      extrapolate: 'clamp',
    });

    return (
      <Animated.View
        style={[
          styles.deleteActionContainer,
          {
            opacity,
            transform: [{ translateX }],
          },
        ]}
      >
        <Animated.View
          style={[
            styles.deleteAction,
            {
              backgroundColor: theme.colors.error,
              transform: [{ scale }],
            },
          ]}
        >
          <View style={styles.deleteIconContainer}>
            <IconButton
              icon="delete-sweep"
              size={28}
              iconColor="white"
              style={styles.deleteIcon}
            />
          </View>
          <Text style={styles.swipeActionText}>ELIMINAR</Text>
        </Animated.View>
      </Animated.View>
    );
  };

  const renderItem = (item: CartItem) => {
    const basePrice = item.unitPrice || 0;
    const modifiersPrice = item.modifiers.reduce(
      (sum, mod) => sum + (mod.price || 0),
      0,
    );
    const unitPriceWithModifiers = basePrice + modifiersPrice;
    const itemTotal = item.totalPrice || unitPriceWithModifiers * item.quantity;

    const canDelete =
      !isEditMode ||
      (item.preparationStatus !== 'READY' &&
        item.preparationStatus !== 'DELIVERED');

    const content = (
      <TouchableOpacity
        onPress={() => onEditItem && onEditItem(item)}
        disabled={disabled || !onEditItem}
        activeOpacity={0.7}
      >
        <List.Item
          title={() => (
            <View>
              <View>
                <Text style={styles.itemTitle}>
                  {item.quantity}x {item.variantName || item.productName}
                </Text>
              </View>
            </View>
          )}
          description={() => (
            <View>
              {item.modifiers.length > 0 && (
                <Text style={styles.modifiersText}>
                  {item.modifiers.map((m) => m.name).join(', ')}
                </Text>
              )}
              {item.selectedPizzaCustomizations &&
                item.selectedPizzaCustomizations.length > 0 && (
                  <Text style={styles.customizationText}>
                    {item.selectedPizzaCustomizations.length} personalizaciones
                  </Text>
                )}
              {item.preparationNotes && (
                <Text style={styles.notesText}>
                  Nota: {item.preparationNotes}
                </Text>
              )}
              {isEditMode && item.preparationStatus && (
                <View style={styles.statusContainer}>
                  <View
                    style={[
                      styles.statusBadge,
                      {
                        backgroundColor:
                          PreparationStatusInfo.getColor(
                            item.preparationStatus,
                            theme,
                          ) + '20',
                      },
                    ]}
                  >
                    <View
                      style={[
                        styles.statusDot,
                        {
                          backgroundColor: PreparationStatusInfo.getColor(
                            item.preparationStatus,
                            theme,
                          ),
                        },
                      ]}
                    />
                    <Text
                      style={[
                        styles.statusText,
                        {
                          color: PreparationStatusInfo.getColor(
                            item.preparationStatus,
                            theme,
                          ),
                        },
                      ]}
                    >
                      {PreparationStatusInfo.getLabel(item.preparationStatus)}
                    </Text>
                  </View>
                </View>
              )}
            </View>
          )}
          right={() => (
            <View style={styles.itemActionsContainer}>
              <View style={styles.quantityActions}>
                <IconButton
                  icon="minus-circle-outline"
                  size={24}
                  onPress={() => onUpdateQuantity(item.id, item.quantity - 1)}
                  disabled={
                    disabled ||
                    (isEditMode &&
                      (item.preparationStatus === 'READY' ||
                        item.preparationStatus === 'DELIVERED'))
                  }
                  style={styles.quantityButton}
                />
                <Text style={styles.quantityText}>{item.quantity}</Text>
                <IconButton
                  icon="plus-circle-outline"
                  size={24}
                  onPress={() => onUpdateQuantity(item.id, item.quantity + 1)}
                  disabled={
                    disabled ||
                    (isEditMode &&
                      (item.preparationStatus === 'READY' ||
                        item.preparationStatus === 'DELIVERED'))
                  }
                  style={styles.quantityButton}
                />
              </View>
              <View style={styles.priceContainer}>
                <Text style={styles.itemPrice}>${itemTotal.toFixed(2)}</Text>
                {item.quantity > 1 && (
                  <Text style={styles.unitPriceText}>
                    (${unitPriceWithModifiers.toFixed(2)} c/u)
                  </Text>
                )}
              </View>
            </View>
          )}
          style={styles.listItem}
        />
      </TouchableOpacity>
    );

    if (!canDelete || disabled) {
      return content;
    }

    return (
      <Swipeable
        renderRightActions={(progress, dragX) =>
          renderRightActions(progress, dragX, item)
        }
        overshootRight={false}
        friction={2}
        rightThreshold={90}
        leftThreshold={100}
        onSwipeableOpen={(direction) => {
          if (direction === 'right') {
            setTimeout(() => {
              onRemoveItem(item.id);
            }, 150);
          }
        }}
        enabled={!disabled}
      >
        {content}
      </Swipeable>
    );
  };

  return (
    <View style={styles.container}>
      {items.map((item) => (
        <View key={item.id}>{renderItem(item)}</View>
      ))}
    </View>
  );
};

const createStyles = (theme: any) =>
  StyleSheet.create({
    container: {
      marginVertical: theme.spacing.s,
    },
    listItem: {
      backgroundColor: theme.colors.surface,
      marginBottom: theme.spacing.xs,
      paddingVertical: theme.spacing.s,
      paddingHorizontal: theme.spacing.s,
      minHeight: 80,
    },
    modifiersText: {
      fontSize: 12,
      color: theme.colors.primary,
      marginTop: 2,
    },
    customizationText: {
      fontSize: 12,
      color: theme.colors.secondary,
      marginTop: 2,
    },
    notesText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      marginTop: 2,
    },
    itemActionsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'flex-end',
      flexShrink: 0,
    },
    quantityActions: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    quantityButton: {
      marginHorizontal: -4,
      padding: 0,
    },
    quantityText: {
      fontSize: 14,
      fontWeight: 'bold',
      minWidth: 20,
      textAlign: 'center',
      marginHorizontal: 2,
    },
    itemTitle: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    itemPrice: {
      alignSelf: 'center',
      marginRight: theme.spacing.xs,
      color: theme.colors.onSurfaceVariant,
      fontSize: 15,
      fontWeight: 'bold',
      minWidth: 55,
      textAlign: 'right',
    },
    priceContainer: {
      flexDirection: 'column',
      alignItems: 'flex-end',
      marginRight: theme.spacing.xs,
    },
    unitPriceText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
    },
    deleteActionContainer: {
      width: 120,
      height: '100%',
      justifyContent: 'center',
      alignItems: 'flex-end',
      paddingRight: theme.spacing.m,
    },
    deleteAction: {
      backgroundColor: theme.colors.error,
      justifyContent: 'center',
      alignItems: 'center',
      width: 90,
      height: '90%',
      borderRadius: theme.roundness * 2,
      flexDirection: 'column',
      shadowColor: theme.colors.error,
      shadowOffset: {
        width: 0,
        height: 2,
      },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
      elevation: 5,
    },
    deleteIconContainer: {
      width: 50,
      height: 50,
      borderRadius: 25,
      backgroundColor: 'rgba(255, 255, 255, 0.2)',
      justifyContent: 'center',
      alignItems: 'center',
      marginBottom: 4,
    },
    deleteIcon: {
      margin: 0,
      padding: 0,
    },
    swipeActionText: {
      color: 'white',
      fontSize: 11,
      fontWeight: '700',
      letterSpacing: 1,
      textTransform: 'uppercase',
    },
    statusContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      marginTop: 2,
      justifyContent: 'flex-start',
    },
    statusBadge: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingHorizontal: theme.spacing.s,
      paddingVertical: 2,
      borderRadius: 12,
      gap: 4,
    },
    statusDot: {
      width: 6,
      height: 6,
      borderRadius: 3,
    },
    statusText: {
      fontSize: 11,
      fontWeight: '600',
      textTransform: 'uppercase',
      letterSpacing: 0.5,
    },
  });

================
File: app/src/modules/orders/hooks/useProductValidation.ts
================
import { useMemo } from 'react';
import { Product } from '../schema/orders.schema';
import { CartItemModifier } from '../stores/useOrderStore';
import { SelectedPizzaCustomization } from '@/app/schemas/domain/order.schema';
import {
  PizzaCustomization,
  CustomizationActionEnum,
} from '@/modules/pizzaCustomizations/schema/pizzaCustomization.schema';
import { PizzaConfiguration } from '@/modules/pizzaCustomizations/schema/pizzaConfiguration.schema';

interface ValidationError {
  field: string;
  message: string;
}

interface UseProductValidationProps {
  product: Product;
  selectedVariantId?: string;
  selectedModifiersByGroup: Record<string, CartItemModifier[]>;
  selectedPizzaCustomizations: SelectedPizzaCustomization[];
  pizzaCustomizations: PizzaCustomization[];
  pizzaConfiguration: PizzaConfiguration | null;
}

export const useProductValidation = ({
  product,
  selectedVariantId,
  selectedModifiersByGroup,
  selectedPizzaCustomizations,
  pizzaCustomizations,
  pizzaConfiguration,
}: UseProductValidationProps) => {
  const validationErrors = useMemo(() => {
    const errors: ValidationError[] = [];

    // Validar variantes requeridas
    const hasVariants =
      product?.variants &&
      Array.isArray(product.variants) &&
      product.variants.length > 0;

    if (hasVariants && !selectedVariantId) {
      errors.push({
        field: 'variant',
        message: 'Selecciona una variante',
      });
    }

    // Validar pizzas - deben tener al menos un sabor o ingrediente
    if (product.isPizza && pizzaConfiguration) {
      const addedCustomizations = selectedPizzaCustomizations.filter(
        (sc) => sc.action === CustomizationActionEnum.ADD
      );

      // Verificar elementos en cada mitad (lgica igual que en handleAddToCart)
      const fullPizzaElements = addedCustomizations.filter(
        (sc) => sc.half === 'FULL'
      );
      
      const half1Elements = addedCustomizations.filter(
        (sc) => sc.half === 'HALF_1'
      );
      
      const half2Elements = addedCustomizations.filter(
        (sc) => sc.half === 'HALF_2'
      );

      // Si hay elementos en pizza completa, es vlido
      if (fullPizzaElements.length > 0) {
        // La pizza completa cubre ambas mitades - no hay errores
      } else {
        // Si no hay elementos en pizza completa, verificar que ambas mitades tengan al menos un elemento
        if (half1Elements.length === 0 && half2Elements.length === 0) {
          // Si no hay nada en ninguna parte
          errors.push({
            field: 'pizza',
            message: 'La pizza debe tener al menos un sabor o ingrediente',
          });
        } else {
          // Si hay elementos pero alguna mitad est vaca
          if (half1Elements.length === 0) {
            errors.push({
              field: 'pizza',
              message: 'La primera mitad de la pizza debe tener al menos un sabor o ingrediente',
            });
          }
          
          if (half2Elements.length === 0) {
            errors.push({
              field: 'pizza',
              message: 'La segunda mitad de la pizza debe tener al menos un sabor o ingrediente',
            });
          }
        }
      }
    }

    // Validar grupos de modificadores
    if (product.modifierGroups) {
      for (const group of product.modifierGroups) {
        const selectedInGroup = selectedModifiersByGroup[group.id] || [];
        const selectedCount = selectedInGroup.length;

        // Validar grupos requeridos y mnimo de selecciones
        if (
          group.isRequired ||
          (group.minSelections && group.minSelections > 0)
        ) {
          const minRequired = Math.max(
            group.minSelections || 0,
            group.isRequired ? 1 : 0,
          );

          if (selectedCount < minRequired) {
            const message =
              minRequired === 1
                ? `Selecciona una opcin`
                : `Selecciona al menos ${minRequired} opciones`;

            errors.push({
              field: `modifier_${group.id}`,
              message,
            });
          }
        }

        // Validar mximo de selecciones
        if (group.maxSelections && selectedCount > group.maxSelections) {
          errors.push({
            field: `modifier_${group.id}`,
            message: `Mximo ${group.maxSelections} ${group.maxSelections === 1 ? 'opcin' : 'opciones'}`,
          });
        }
      }
    }

    return errors;
  }, [
    product,
    selectedVariantId,
    selectedModifiersByGroup,
    selectedPizzaCustomizations,
    pizzaCustomizations,
    pizzaConfiguration,
  ]);

  const isValid = validationErrors.length === 0;

  const getFieldError = (field: string): string | undefined => {
    const error = validationErrors.find((e) => e.field === field);
    return error?.message;
  };

  const getGroupError = (groupId: string): string | undefined => {
    return getFieldError(`modifier_${groupId}`);
  };

  return {
    validationErrors,
    isValid,
    getFieldError,
    getGroupError,
  };
};

================
File: app/src/modules/receipts/services/receiptService.ts
================
import apiClient from '@/app/services/apiClient';
import type { QueryOptions } from '@tanstack/react-query';
import { API_PATHS } from '@/app/constants/apiPaths';
import type {
  Receipt,
  ReceiptsListResponse,
  ReceiptFilters,
} from '../schema/receipt.schema';
import {
  receiptsListResponseSchema,
  receiptSchema,
} from '../schema/receipt.schema';
import type { Order } from '@/modules/orders/schema/orders.schema';

export const receiptService = {
  getReceiptsList: async (
    params: ReceiptFilters = {},
  ): Promise<ReceiptsListResponse> => {
    const { startDate, endDate, orderType } = params;

    const queryParams: Record<string, any> = {};

    if (startDate) {
      queryParams.startDate = startDate;
    }
    if (endDate) {
      queryParams.endDate = endDate;
    }
    if (orderType) {
      queryParams.orderType = orderType;
    }

    const response = await apiClient.get(API_PATHS.ORDERS_RECEIPTS_LIST, {
      params: queryParams,
    });

    return receiptsListResponseSchema.parse(response.data);
  },

  getReceiptById: async (id: string): Promise<Receipt> => {
    const response = await apiClient.get(
      API_PATHS.ORDERS_RECEIPTS_BY_ID.replace(':id', id),
    );

    return receiptSchema.parse(response.data);
  },

  recoverOrder: async (id: string): Promise<Order> => {
    const response = await apiClient.post<Order>(
      API_PATHS.ORDERS_RECOVER.replace(':id', id),
      {},
    );

    return response.data;
  },
};

export const receiptQueryOptions = {
  receipts: (
    params: ReceiptFilters = {},
  ): QueryOptions<ReceiptsListResponse, Error> => ({
    queryKey: ['receipts', params],
    queryFn: () => receiptService.getReceiptsList(params),
  }),

  receipt: (id: string): QueryOptions<Receipt, Error> => ({
    queryKey: ['receipt', id],
    queryFn: () => receiptService.getReceiptById(id),
  }),
};

================
File: app/src/modules/shared/components/OrderSummaryCard.tsx
================
import React from 'react';
import { View, StyleSheet, TouchableOpacity } from 'react-native';
import { Text, Chip, Card, Icon } from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import { OrderTypeEnum } from '@/modules/orders/schema/orders.schema';
import {
  formatOrderTypeShort,
  getPaymentStatus,
} from '@/modules/orders/utils/formatters';

interface OrderItemType {
  id: string | number;
  shiftOrderNumber?: number;
  orderNumber?: string | number;
  orderType: (typeof OrderTypeEnum)[keyof typeof OrderTypeEnum];
  orderStatus: string;
  createdAt: string | Date;
  total?: string | number;
  table?: {
    name?: string;
    number?: number;
    isTemporary?: boolean;
    area?: { name: string };
  };
  area?: { name: string };
  deliveryInfo?: {
    recipientName?: string;
    customerName?: string;
    recipientPhone?: string;
    customerPhone?: string;
    fullAddress?: string;
    address?: string;
  };
  notes?: string;
  paymentsSummary?: { totalPaid: number };
  payments?: Array<{ amount: number }>;
  createdBy?: {
    firstName?: string;
    lastName?: string;
    username?: string;
  };
  isFromWhatsApp?: boolean;
  preparationScreenStatuses?: Array<{
    name: string;
    status: string;
  }>;
}

interface OrderSummaryCardProps {
  item: OrderItemType;
  onPress: () => void;
  renderActions?: (item: OrderItemType) => React.ReactNode;
  getStatusColor?: (status: string) => string;
  getStatusLabel?: (status: string) => string;
}

const OrderSummaryCard: React.FC<OrderSummaryCardProps> = ({
  item,
  onPress,
  renderActions,
  getStatusColor,
  getStatusLabel,
}) => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);

  let orderTitle = `#${item.shiftOrderNumber || item.orderNumber}  ${formatOrderTypeShort(item.orderType)}`;

  if (item.orderType === OrderTypeEnum.DINE_IN && item.table) {
    const tableDisplay = item.table.isTemporary
      ? item.table.name
      : `Mesa ${item.table.name || item.table.number || 'N/A'}`;
    orderTitle += `  ${item.table.area?.name || item.area?.name || 'Sin rea'}  ${tableDisplay}`;
  } else if (item.orderType === OrderTypeEnum.TAKE_AWAY) {
    if (item.deliveryInfo?.recipientName || item.deliveryInfo?.customerName) {
      orderTitle += `  ${item.deliveryInfo.recipientName || item.deliveryInfo.customerName}`;
    }
    if (item.deliveryInfo?.recipientPhone || item.deliveryInfo?.customerPhone) {
      orderTitle += `  ${item.deliveryInfo.recipientPhone || item.deliveryInfo.customerPhone}`;
    }
  } else if (item.orderType === OrderTypeEnum.DELIVERY) {
    if (item.deliveryInfo?.fullAddress || item.deliveryInfo?.address) {
      orderTitle += `  ${item.deliveryInfo.fullAddress || item.deliveryInfo.address}`;
    }
    if (item.deliveryInfo?.recipientPhone || item.deliveryInfo?.customerPhone) {
      orderTitle += `  ${item.deliveryInfo.recipientPhone || item.deliveryInfo.customerPhone}`;
    }
  }

  const totalAmount =
    typeof item.total === 'string' ? parseFloat(item.total) : item.total || 0;
  const totalPaid =
    item.paymentsSummary?.totalPaid ||
    item.payments?.reduce((sum: number, p) => sum + (p.amount || 0), 0) ||
    0;
  const pendingAmount = totalAmount - totalPaid;

  const paymentStatus = getPaymentStatus(item);
  const paymentColor =
    paymentStatus.status === 'paid'
      ? '#10B981'
      : paymentStatus.status === 'partial'
        ? '#F59E0B'
        : '#EF4444';
  const paymentIcon =
    paymentStatus.status === 'paid'
      ? ''
      : paymentStatus.status === 'partial'
        ? ''
        : '';

  const defaultGetStatusColor = (status: string) => {
    switch (status) {
      case 'COMPLETED':
        return '#4CAF50';
      case 'CANCELLED':
        return '#F44336';
      case 'IN_PROGRESS':
        return '#FF9800';
      default:
        return theme.colors.surfaceVariant;
    }
  };

  const defaultGetStatusLabel = (status: string) => {
    switch (status) {
      case 'COMPLETED':
        return 'Completada';
      case 'CANCELLED':
        return 'Cancelada';
      case 'IN_PROGRESS':
        return 'En proceso';
      default:
        return status;
    }
  };

  const statusColor = getStatusColor
    ? getStatusColor(item.orderStatus)
    : defaultGetStatusColor(item.orderStatus);
  const statusLabel = getStatusLabel
    ? getStatusLabel(item.orderStatus)
    : defaultGetStatusLabel(item.orderStatus);

  return (
    <TouchableOpacity activeOpacity={0.95} onPress={onPress}>
      <Card
        style={[
          styles.orderCard,
          {
            backgroundColor: theme.colors.surface,
          },
        ]}
        mode="elevated"
      >
        <Card.Content style={styles.cardContent}>
          <View style={styles.mainContainer}>
            <View style={styles.leftContainer}>
              <Text
                style={[styles.orderNumber, { color: theme.colors.onSurface }]}
              >
                {orderTitle}
                <Text
                  style={[
                    styles.orderPrice,
                    pendingAmount > 0 ? styles.unpaidPrice : styles.paidPrice,
                  ]}
                >
                  {'  '}
                  {pendingAmount > 0
                    ? `Por pagar: $${pendingAmount.toFixed(2)}`
                    : `Pagado: $${totalAmount.toFixed(2)}`}
                </Text>
                {item.notes && (
                  <Text
                    style={[
                      styles.notesInline,
                      { color: theme.colors.onSurfaceVariant },
                    ]}
                    numberOfLines={1}
                  >
                    {'  '}
                    {item.notes}
                  </Text>
                )}
              </Text>
              <View style={styles.timeAndPaymentRow}>
                <Text
                  style={[styles.orderTime, { color: theme.colors.primary }]}
                >
                  {format(
                    typeof item.createdAt === 'string'
                      ? new Date(item.createdAt)
                      : item.createdAt,
                    'p',
                    { locale: es },
                  )}
                </Text>

                <View
                  style={[
                    styles.miniPaymentBadge,
                    { backgroundColor: paymentColor },
                  ]}
                >
                  <Text style={styles.miniPaymentText}>{paymentIcon}</Text>
                </View>

                {item.isFromWhatsApp && (
                  <View
                    style={[
                      styles.inlinePreparationBadge,
                      styles.whatsappBadge,
                    ]}
                  >
                    <Icon source="whatsapp" size={12} color="#FFFFFF" />
                  </View>
                )}

                {item.preparationScreenStatuses &&
                  item.preparationScreenStatuses.length > 0 && (
                    <>
                      {item.preparationScreenStatuses.map(
                        (screen, index: number) => {
                          const backgroundColor =
                            screen.status === 'READY'
                              ? '#4CAF50'
                              : screen.status === 'IN_PROGRESS'
                                ? '#FFA000'
                                : theme.colors.surfaceVariant;

                          const textColor =
                            screen.status === 'READY' ||
                            screen.status === 'IN_PROGRESS'
                              ? '#FFFFFF'
                              : theme.colors.onSurfaceVariant;

                          return (
                            <View
                              key={`${item.id}-screen-${index}`}
                              style={[
                                styles.inlinePreparationBadge,
                                {
                                  backgroundColor,
                                  borderColor:
                                    backgroundColor ===
                                    theme.colors.surfaceVariant
                                      ? theme.colors.outline
                                      : backgroundColor,
                                },
                              ]}
                            >
                              <Text
                                style={[
                                  styles.inlinePreparationText,
                                  { color: textColor },
                                ]}
                              >
                                {screen.status === 'READY'
                                  ? ' '
                                  : screen.status === 'IN_PROGRESS'
                                    ? ''
                                    : ''}
                                 {screen.name}
                              </Text>
                            </View>
                          );
                        },
                      )}
                    </>
                  )}
              </View>
            </View>

            <View style={styles.rightContainer}>
              {item.createdBy && (
                <Text style={styles.createdByText} numberOfLines={1}>
                  {item.createdBy.firstName && item.createdBy.lastName
                    ? `${item.createdBy.firstName} ${item.createdBy.lastName}`
                    : item.createdBy.username}
                </Text>
              )}
              <Chip
                mode="flat"
                compact
                style={[
                  styles.statusChip,
                  {
                    backgroundColor: statusColor,
                  },
                ]}
                textStyle={styles.statusChipText}
              >
                {statusLabel}
              </Chip>

              {renderActions && (
                <View style={styles.actionsContainer}>
                  {renderActions(item)}
                </View>
              )}
            </View>
          </View>
        </Card.Content>
      </Card>
    </TouchableOpacity>
  );
};

const createStyles = (_theme: AppTheme) =>
  StyleSheet.create({
    orderCard: {
      marginBottom: 8,
    },
    cardContent: {
      paddingBottom: 8,
    },
    mainContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
    },
    leftContainer: {
      flex: 1,
      marginRight: 12,
    },
    rightContainer: {
      alignItems: 'flex-end',
      justifyContent: 'space-between',
      minHeight: 60,
    },
    orderNumber: {
      fontSize: 16,
      fontWeight: '600',
      lineHeight: 22,
      marginBottom: 4,
    },
    orderPrice: {
      fontSize: 14,
      fontWeight: '500',
    },
    notesInline: {
      fontSize: 13,
      fontStyle: 'italic',
    },
    timeAndPaymentRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 6,
      flexWrap: 'wrap',
    },
    orderTime: {
      fontSize: 13,
      fontWeight: '500',
    },
    miniPaymentBadge: {
      width: 16,
      height: 16,
      borderRadius: 8,
      justifyContent: 'center',
      alignItems: 'center',
    },
    miniPaymentText: {
      color: '#FFFFFF',
      fontSize: 10,
      fontWeight: 'bold',
    },
    inlinePreparationBadge: {
      paddingHorizontal: 6,
      paddingVertical: 2,
      borderRadius: 10,
      borderWidth: 1,
    },
    inlinePreparationText: {
      fontSize: 10,
      fontWeight: '500',
    },
    createdByText: {
      fontSize: 12,
      color: '#666',
      marginBottom: 4,
      maxWidth: 120,
    },
    statusChip: {
      marginBottom: 8,
    },
    statusChipText: {
      fontSize: 11,
      fontWeight: '600',
      color: '#FFFFFF',
    },
    actionsContainer: {
      alignItems: 'center',
    },
    unpaidPrice: {
      color: _theme.colors.error,
    },
    paidPrice: {
      color: '#10B981',
    },
    whatsappBadge: {
      backgroundColor: '#25D366',
      borderColor: '#25D366',
    },
  });

export default OrderSummaryCard;

================
File: app/src/modules/shiftAudit/components/OrderHistoryView.tsx
================
import React, { useMemo, useCallback } from 'react';
import {
  View,
  FlatList,
  ActivityIndicator,
} from 'react-native';
import {
  Text,
  Button,
  Appbar,
} from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { useQuery } from '@tanstack/react-query';
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import { HistoryItem, OrderHistoryViewProps } from '../types/orderHistory';
import { HistoryItemComponent } from './HistoryItemComponent';
import { createStyles as createOrderHistoryStyles } from '../styles/orderHistoryStyles';

export const OrderHistoryView: React.FC<OrderHistoryViewProps> = ({
  orderId,
  orderNumber,
  onBack,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createOrderHistoryStyles(theme), [theme]);

  const titleText = useMemo(
    () => `Historial de Orden #${orderNumber || ''}`,
    [orderNumber],
  );

  // Query combinado para obtener ambos historiales
  const {
    data: historyData,
    isError,
    refetch,
    isLoading,
  } = useQuery({
    queryKey: ['combinedHistory', orderId],
    queryFn: async () => {
      if (!orderId) throw new Error('No order ID');

      // Obtener historial consolidado de la orden
      const url = `${API_PATHS.ORDERS_HISTORY.replace(':orderId', orderId)}?page=1&limit=100`;
      const orderHistoryResponse = await apiClient.get(url);

      const orderHistory = orderHistoryResponse.data?.data
        ? orderHistoryResponse.data.data.map(
            (item: Record<string, unknown>) => ({
              ...item,
              type: 'order' as const,
            }),
          )
        : [];

      return orderHistory;
    },
    enabled: !!orderId,
    staleTime: 30000,
  });

  const renderHistoryItem = useCallback(
    ({ item }: { item: HistoryItem }) => {
      return <HistoryItemComponent item={item} theme={theme} />;
    },
    [theme],
  );

  const renderEmpty = useCallback(
    () => (
      <View style={styles.emptyContainer}>
        <Text
          style={[styles.emptyIcon, { color: theme.colors.onSurfaceDisabled }]}
        >
          
        </Text>
        <Text
          variant="bodyLarge"
          style={{
            color: theme.colors.onSurfaceDisabled,
            marginTop: theme.spacing.m,
          }}
        >
          No hay historial disponible
        </Text>
        <Text
          variant="bodySmall"
          style={[
            styles.emptyText,
            {
              color: theme.colors.onSurfaceVariant,
              marginTop: theme.spacing.s,
            },
          ]}
        >
          Los cambios realizados en esta orden aparecern aqu
        </Text>
      </View>
    ),
    [styles.emptyContainer, styles.emptyIcon, styles.emptyText, theme],
  );

  return (
    <View style={styles.container}>
      <Appbar.Header style={styles.header}>
        <Appbar.BackAction onPress={onBack} />
        <Appbar.Content
          title={titleText}
          subtitle={`${historyData?.length || 0} cambios registrados`}
        />
      </Appbar.Header>

      <View style={styles.content}>
        {isError ? (
          <View style={styles.emptyContainer}>
            <Text style={[styles.errorIcon, { color: theme.colors.error }]}>
              
            </Text>
            <Text
              variant="bodyLarge"
              style={[
                styles.emptyText,
                {
                  color: theme.colors.error,
                  marginTop: theme.spacing.m,
                },
              ]}
            >
              Error al cargar el historial
            </Text>
            <Button
              onPress={() => refetch()}
              mode="text"
              style={styles.retryButton}
            >
              Reintentar
            </Button>
          </View>
        ) : isLoading ? (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
            <Text style={styles.loadingText}>Cargando historial...</Text>
          </View>
        ) : (
          <FlatList
            data={historyData || []}
            renderItem={renderHistoryItem}
            keyExtractor={(item) => item.id.toString()}
            contentContainerStyle={styles.listContent}
            ListEmptyComponent={renderEmpty}
            showsVerticalScrollIndicator={false}
          />
        )}
      </View>
    </View>
  );
};

================
File: app/package.json
================
{
  "name": "cloudbite",
  "version": "1.0.0",
  "main": "index.ts",
  "scripts": {
    "start": "expo start",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web",
    "test": "jest --watchAll",
    "test:ci": "jest",
    "lint": "eslint . --ext .js,.jsx,.ts,.tsx --fix",
    "format": "prettier --write . --ignore-path .gitignore",
    "compile": "tsc --noEmit --skipLibCheck",
    "compile:check": "./compile-check.sh",
    "build:ios:sim": "eas build --platform ios --profile development --local",
    "build:android:sim": "eas build --platform android --profile development --local",
    "build:ios:dev": "eas build --platform ios --profile preview --local",
    "build:android:dev": "eas build --platform android --profile preview --local",
    "build:android:prod": "eas build --platform android --profile production --local",
    "build:android:prod-apk": "eas build --platform android --profile production-apk --local",
    "build:prod": "eas build --platform android --profile production",
    "submit:prod": "eas submit --platform android --profile production",
    "release:prod": "npm run build:prod && npm run submit:prod",
    "release:prod:auto": "eas build --platform android --profile production --auto-submit",
    "release:playstore": "./scripts/release-to-playstore.sh",
    "postinstall": "patch-package"
  },
  "dependencies": {
    "@expo/config-plugins": "~10.0.0",
    "@expo/metro-config": "~0.20.0",
    "@expo/metro-runtime": "~5.0.4",
    "@expo/prebuild-config": "~9.0.0",
    "@expo/vector-icons": "^14.0.4",
    "@hookform/resolvers": "^5.2.0",
    "@react-native-community/datetimepicker": "^8.4.2",
    "@react-native-community/netinfo": "11.3.1",
    "@react-navigation/drawer": "^7.3.8",
    "@react-navigation/native": "^7.1.5",
    "@react-navigation/native-stack": "^7.3.9",
    "@shopify/flash-list": "1.7.6",
    "@tanstack/react-query": "^5.72.1",
    "@types/eventemitter3": "^1.2.0",
    "apisauce": "^3.1.1",
    "axios": "^1.8.4",
    "axios-retry": "^4.5.0",
    "babel-plugin-module-resolver": "^5.0.2",
    "date-fns": "^4.1.0",
    "eventemitter3": "^5.0.1",
    "expo": "53.0.20",
    "expo-audio": "~0.4.7",
    "expo-build-properties": "^0.14.8",
    "expo-crypto": "~14.1.5",
    "expo-dev-client": "~5.2.4",
    "expo-file-system": "~18.1.10",
    "expo-image": "~2.3.0",
    "expo-image-picker": "~16.1.4",
    "expo-screen-orientation": "^8.1.7",
    "expo-secure-store": "~14.2.3",
    "expo-speech-recognition": "^0.3.2",
    "lodash.debounce": "^4.0.8",
    "react": "19.0.0",
    "react-dom": "19.0.0",
    "react-hook-form": "^7.55.0",
    "react-native": "0.79.4",
    "react-native-gesture-handler": "~2.24.0",
    "react-native-paper": "^5.13.1",
    "react-native-paper-dates": "^0.22.46",
    "react-native-reanimated": "~3.17.4",
    "react-native-safe-area-context": "5.4.0",
    "react-native-screens": "~4.11.1",
    "react-native-web": "^0.20.0",
    "react-native-webview": "^13.15.0",
    "zod": "^3.24.2",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@types/lodash": "^4.17.16",
    "@types/lodash.debounce": "^4.0.9",
    "@typescript-eslint/eslint-plugin": "^7.13.1",
    "@typescript-eslint/parser": "^7.13.1",
    "eslint": "^8.57.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.1.3",
    "eslint-plugin-react": "^7.34.3",
    "eslint-plugin-react-hooks": "^4.6.2",
    "eslint-plugin-react-native": "^4.1.0",
    "http-proxy-middleware": "^3.0.5",
    "patch-package": "^8.0.0",
    "typescript": "^5.5.4"
  },
  "private": true,
  "expo": {
    "doctor": {
      "reactNativeDirectoryCheck": {
        "exclude": [
          "@hookform/resolvers",
          "dotenv"
        ],
        "listUnknownPackages": false
      }
    }
  }
}

================
File: app/src/app/components/common/AdaptiveModal.tsx
================
import { ReactNode, useMemo } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  Dimensions,
  KeyboardAvoidingView,
  Platform,
  type ViewStyle,
} from 'react-native';
import { Modal, Portal } from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';

interface AdaptiveModalProps {
  visible: boolean;
  onDismiss: () => void;
  children: ReactNode;
  contentContainerStyle?: ViewStyle;
  maxWidth?: number | string;
  minHeight?: number;
  maxHeight?: string | number;
  dismissable?: boolean;
  dismissableBackButton?: boolean;
  scrollable?: boolean;
  footer?: ReactNode;
  stickyFooter?: boolean;
}

export const AdaptiveModal = ({
  visible,
  onDismiss,
  children,
  contentContainerStyle,
  maxWidth,
  minHeight = 200,
  maxHeight = '90%',
  dismissable = true,
  dismissableBackButton = true,
  scrollable = true,
  footer,
  stickyFooter = true,
}: AdaptiveModalProps) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const screenHeight = Dimensions.get('window').height;

  const maxHeightPixels = useMemo(() => {
    if (typeof maxHeight === 'string' && maxHeight.endsWith('%')) {
      const percentage = parseInt(maxHeight) / 100;
      return screenHeight * percentage;
    }
    return typeof maxHeight === 'number' ? maxHeight : screenHeight * 0.9;
  }, [maxHeight, screenHeight]);

  const styles = useMemo(
    () =>
      StyleSheet.create({
        modalContainer: {
          backgroundColor: theme.colors.surface,
          borderRadius: theme.roundness * 2,
          width: '90%',
          maxWidth: (maxWidth || (responsive.isTablet ? 600 : 500)) as any,
          minHeight: minHeight,
          maxHeight: maxHeightPixels,
          alignSelf: 'center',
          overflow: 'hidden',
          elevation: 24,
          shadowColor: '#000',
          shadowOffset: { width: 0, height: 12 },
          shadowOpacity: 0.58,
          shadowRadius: 16.0,
        },
        scrollView: {
          maxHeight: maxHeightPixels - (footer ? 100 : 20),
        },
        scrollContent: {
          padding: responsive.isTablet
            ? responsive.spacing(4)
            : responsive.spacing(3),
        },
        contentPadding: {
          padding: responsive.isTablet
            ? responsive.spacing(4)
            : responsive.spacing(3),
          flex: 1,
        },
        footer: {
          borderTopWidth: 1,
          borderTopColor: theme.colors.surfaceVariant,
          padding: responsive.spacing(3),
          backgroundColor: theme.colors.surface,
        },
        modalContentContainer: {
          justifyContent: 'center',
          alignItems: 'center',
          flex: 1,
        },
      }),
    [theme, responsive, minHeight, maxHeightPixels, maxWidth, footer],
  );

  const modalContent = (
    <View style={styles.modalContainer}>
      {scrollable ? (
        <>
          <ScrollView
            style={styles.scrollView}
            contentContainerStyle={[
              styles.scrollContent,
              contentContainerStyle,
            ]}
            showsVerticalScrollIndicator={false}
            keyboardShouldPersistTaps="handled"
          >
            {children}
          </ScrollView>
          {stickyFooter && footer && (
            <View style={styles.footer}>{footer}</View>
          )}
        </>
      ) : (
        <>
          <View style={[styles.contentPadding, contentContainerStyle]}>
            {children}
          </View>
          {footer && <View style={styles.footer}>{footer}</View>}
        </>
      )}
    </View>
  );

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        dismissable={dismissable}
        dismissableBackButton={dismissableBackButton}
        contentContainerStyle={styles.modalContentContainer}
      >
        {Platform.OS === 'ios' ? (
          <KeyboardAvoidingView behavior="position" keyboardVerticalOffset={20}>
            {modalContent}
          </KeyboardAvoidingView>
        ) : (
          modalContent
        )}
      </Modal>
    </Portal>
  );
};

export default AdaptiveModal;

================
File: app/src/app/lib/imageCache.ts
================
import * as FileSystem from 'expo-file-system';
import * as Crypto from 'expo-crypto';
import { Platform } from 'react-native';
import { API_PATHS } from '@/app/constants/apiPaths';

const CACHE_DIR = `${FileSystem.cacheDirectory}image-cache/`;
const MAX_CACHE_SIZE_MB = 500;
const MAX_CACHE_AGE_DAYS = 7;
const MAX_RETRIES = 3;
const BASE_RETRY_DELAY = 1000; // 1 segundo

// Funcin para realizar descargas con retry y backoff exponencial
async function downloadWithRetry(
  remoteUrl: string,
  localUri: string,
  maxRetries: number = MAX_RETRIES,
  baseDelay: number = BASE_RETRY_DELAY,
): Promise<string | null> {
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      const { uri: downloadedUri } = await FileSystem.downloadAsync(
        remoteUrl,
        localUri,
      );

      return downloadedUri;
    } catch (error) {
      if (attempt === maxRetries) {
        break;
      }

      const delay = baseDelay * Math.pow(2, attempt);
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
  }

  return null;
}

async function ensureCacheDirExists() {
  if (Platform.OS === 'web') return;

  const dirInfo = await FileSystem.getInfoAsync(CACHE_DIR);
  if (!dirInfo.exists) {
    await FileSystem.makeDirectoryAsync(CACHE_DIR, { intermediates: true });
  }
}

async function getCacheFilename(remoteUrl: string): Promise<string> {
  let urlToHash = remoteUrl;

  // Incluir el host en el hash para URLs de nuestra API
  if (remoteUrl.includes(API_PATHS.FILES_CHECK)) {
    try {
      const parsedUrl = new URL(remoteUrl);
      urlToHash = `${parsedUrl.host}${parsedUrl.pathname}`;
    } catch {
      urlToHash = remoteUrl;
    }
  }

  const digest = await Crypto.digestStringAsync(
    Crypto.CryptoDigestAlgorithm.SHA256,
    urlToHash,
    { encoding: Crypto.CryptoEncoding.HEX },
  );
  const extensionMatch = remoteUrl.match(/\.([a-zA-Z0-9]+)(?:[?#]|$)/);
  const extension = extensionMatch ? extensionMatch[1] : 'jpg';
  return `${digest}.${extension}`;
}

interface ExistingFileInfo {
  uri: string;
  size: number;
  modificationTime: number;
  exists: true;
}

async function cleanCache() {
  await ensureCacheDirExists();

  try {
    const files = await FileSystem.readDirectoryAsync(CACHE_DIR);

    if (files.length === 0) {
      return;
    }

    const fileInfosPromises = files.map(
      async (
        file,
      ): Promise<ExistingFileInfo | { exists: false; uri: string }> => {
        const info = await FileSystem.getInfoAsync(`${CACHE_DIR}${file}`, {
          size: true,
        });
        if (info.exists) {
          return {
            uri: info.uri,
            size: info.size,
            modificationTime: info.modificationTime,
            exists: true,
          };
        } else {
          return {
            exists: false,
            uri: info.uri,
          };
        }
      },
    );

    const allFileInfos = await Promise.all(fileInfosPromises);
    const existingFileInfos: ExistingFileInfo[] = allFileInfos.filter(
      (f): f is ExistingFileInfo => f.exists,
    );

    let totalSize = existingFileInfos.reduce((sum, file) => sum + file.size, 0);

    const now = Date.now();
    const maxAgeMillis = MAX_CACHE_AGE_DAYS * 24 * 60 * 60 * 1000;
    const maxSizeInBytes = MAX_CACHE_SIZE_MB * 1024 * 1024;

    // Fase 1: Eliminar archivos por edad (ms eficiente)
    const filesToDeleteByAge = existingFileInfos.filter((file) => {
      const fileAgeMillis = now - Math.floor(file.modificationTime) * 1000;
      return fileAgeMillis > maxAgeMillis;
    });

    for (const file of filesToDeleteByAge) {
      try {
        await FileSystem.deleteAsync(file.uri, { idempotent: true });
        totalSize -= file.size;
      } catch {
        // Ignorar errores de archivos que no se pueden eliminar
      }
    }

    // Fase 2: Eliminar archivos por tamao si es necesario (LRU)
    if (totalSize > maxSizeInBytes) {
      const remainingFiles = existingFileInfos
        .filter((file) => {
          const fileAgeMillis = now - Math.floor(file.modificationTime) * 1000;
          return fileAgeMillis <= maxAgeMillis;
        })
        .sort((a, b) => {
          // Ordenar por tiempo de modificacin (ms antiguos primero)
          return a.modificationTime < b.modificationTime
            ? -1
            : a.modificationTime > b.modificationTime
              ? 1
              : 0;
        });

      // Eliminar archivos ms antiguos hasta llegar al lmite de tamao
      // Dejamos un margen del 10% para evitar limpiezas frecuentes
      const targetSize = maxSizeInBytes * 0.9;

      for (const file of remainingFiles) {
        if (totalSize <= targetSize) break;

        try {
          await FileSystem.deleteAsync(file.uri, { idempotent: true });
          totalSize -= file.size;
        } catch {
          // Ignorar errores de archivos que no se pueden eliminar
        }
      }
    }
  } catch (error) {
    // Silently ignore cache clean errors
  }
}

export async function getCachedImageUri(
  remoteUrl: string,
): Promise<string | null> {
  if (
    !remoteUrl ||
    typeof remoteUrl !== 'string' ||
    (!remoteUrl.startsWith('http://') && !remoteUrl.startsWith('https://'))
  ) {
    return remoteUrl;
  }

  // En web, no usar cache - devolver URL directamente
  if (Platform.OS === 'web') {
    return remoteUrl;
  }

  await ensureCacheDirExists();
  const filename = await getCacheFilename(remoteUrl);
  const localUri = `${CACHE_DIR}${filename}`;
  const fileInfo = await FileSystem.getInfoAsync(localUri);

  if (fileInfo.exists) {
    return localUri;
  } else {
    const downloadedUri = await downloadWithRetry(remoteUrl, localUri);

    if (downloadedUri) {
      return downloadedUri;
    } else {
      // Limpiar archivos parciales si los hay
      const partialFileInfo = await FileSystem.getInfoAsync(localUri);
      if (partialFileInfo.exists) {
        await FileSystem.deleteAsync(localUri, { idempotent: true });
      }

      return null;
    }
  }
}

export async function initImageCache() {
  // En web, no inicializar cache
  if (Platform.OS === 'web') {
    return;
  }

  await ensureCacheDirExists();

  cleanCache().catch(() => {
    // Silently ignore init errors
  });
}

export async function removeImageFromCache(remoteUrl: string) {
  if (!remoteUrl || typeof remoteUrl !== 'string') return;

  // En web, no hay cache que limpiar
  if (Platform.OS === 'web') {
    return;
  }

  try {
    const filename = await getCacheFilename(remoteUrl);
    const localUri = `${CACHE_DIR}${filename}`;
    await FileSystem.deleteAsync(localUri, { idempotent: true });
  } catch (error) {
    // Silently ignore removal errors
  }
}

export async function clearImageCache() {
  try {
    await FileSystem.deleteAsync(CACHE_DIR, { idempotent: true });
    await ensureCacheDirExists();
  } catch (error) {
    // Silently ignore clear errors
  }
}

// Prefetching inteligente para optimizar la carga de imgenes
export async function prefetchImages(
  imagePaths: string[],
  options: {
    maxConcurrent?: number;
    skipExisting?: boolean;
    onProgress?: (completed: number, total: number) => void;
  } = {},
) {
  const { maxConcurrent = 5, skipExisting = true, onProgress } = options;

  if (!imagePaths || imagePaths.length === 0) {
    return;
  }

  let completed = 0;
  let _failed = 0;

  const processSingleImage = async (imagePath: string) => {
    try {
      const { getImageUrlSync } = await import('./imageUtils');
      const { serverConnectionService } = await import(
        '@/services/serverConnectionService'
      );

      const serverUrl = serverConnectionService.getCurrentUrl();
      if (!serverUrl) {
        _failed++;
        return;
      }

      const fullUrl = getImageUrlSync(imagePath, serverUrl);
      if (!fullUrl) {
        _failed++;
        return;
      }

      if (skipExisting) {
        const filename = await getCacheFilename(fullUrl);
        const localUri = `${CACHE_DIR}${filename}`;
        const fileInfo = await FileSystem.getInfoAsync(localUri);

        if (fileInfo.exists) {
          return;
        }
      }

      const result = await getCachedImageUri(fullUrl);
      if (!result) {
        _failed++;
      }
    } catch (error) {
      _failed++;
    } finally {
      completed++;
      onProgress?.(completed, imagePaths.length);
    }
  };

  const batches = [];
  for (let i = 0; i < imagePaths.length; i += maxConcurrent) {
    const batch = imagePaths.slice(i, i + maxConcurrent);
    batches.push(batch);
  }

  for (const batch of batches) {
    await Promise.all(batch.map(processSingleImage));
  }

  // Silently ignore prefetch failures
}

export async function prefetchMenuImages(
  menuData: any[],
  options?: {
    maxConcurrent?: number;
    onProgress?: (completed: number, total: number) => void;
  },
) {
  const imagePaths: string[] = [];

  menuData.forEach((category: any) => {
    if (category.photo?.path) {
      imagePaths.push(category.photo.path);
    }

    if (category.subcategories) {
      category.subcategories.forEach((subcategory: any) => {
        if (subcategory.photo?.path) {
          imagePaths.push(subcategory.photo.path);
        }

        if (subcategory.products) {
          subcategory.products.forEach((product: any) => {
            if (product.photo?.path) {
              imagePaths.push(product.photo.path);
            }
          });
        }
      });
    }
  });

  if (imagePaths.length > 0) {
    await prefetchImages(imagePaths, {
      ...options,
      skipExisting: true,
    });
  }
}

================
File: app/src/app/navigation/AppDrawerNavigator.tsx
================
import React from 'react';
import {
  StyleSheet,
  StatusBar,
  TouchableOpacity,
  View,
  Text,
} from 'react-native';
import { createDrawerNavigator } from '@react-navigation/drawer';
import { MenuStackNavigator } from '../../modules/menu/navigation/MenuStackNavigator';
import ModifiersStackNavigator from '../../modules/modifiers/navigation/ModifiersStackNavigator';
import PreparationScreensStackNavigator from '../../modules/preparationScreens/navigation/PreparationScreensStackNavigator';
import AreasTablesStackNavigator from '../../modules/areasTables/navigation/AreasTablesStackNavigator';
import OrdersStackNavigator from './OrdersStackNavigator';
import PrintersStackNavigator from '../../modules/printers/navigation/PrintersStackNavigator';
import { ReceiptsStackNavigator } from '../../modules/receipts/navigation/ReceiptsStackNavigator';
import { AvailabilityScreen } from '../../modules/availability/screens/AvailabilityScreen';
import { OrderFinalizationStackNavigator } from '../../modules/orderFinalization/navigation/OrderFinalizationStackNavigator';
import { RestaurantConfigStackNavigator } from '../../modules/restaurantConfig/navigation/RestaurantConfigStackNavigator';
import { CustomersStackNavigator } from '../../modules/customers/navigation/CustomersStackNavigator';
import { PizzaCustomizationsStackNavigator } from '../../modules/pizzaCustomizations/navigation/PizzaCustomizationsStackNavigator';
import { SyncStackNavigator } from '../../modules/sync/navigation/SyncStackNavigator';
import { UsersListScreen } from '../../modules/users/screens/UsersListScreen';
import KitchenOrdersScreen from '../../modules/kitchen/screens/KitchenOrdersScreen';
import { ShiftAuditStackNavigator } from '../../modules/shiftAudit/navigation/ShiftAuditStackNavigator';
import { ServerSettingsScreen } from '../../modules/settings/screens/ServerSettingsScreen';

import { CustomDrawerContent } from './components/CustomDrawerContent';
import { useAppTheme } from '../styles/theme';
import { Icon, Surface, Checkbox, Text as PaperText } from 'react-native-paper';
import type { AppDrawerParamList } from './types';
import { useResponsive } from '../hooks/useResponsive';
import { ConnectionIndicator } from '../components/ConnectionIndicator';
import { ShiftIndicator } from '../components/ShiftIndicator';
import { useAuthStore } from '../store/authStore';
import { KitchenFilterButton } from '../../modules/kitchen/components/KitchenFilterButton';
import { useKitchenStore } from '../../modules/kitchen/store/kitchenStore';
import { OrderTypeEnum } from '../../modules/kitchen/schema/kitchen.schema';

const Drawer = createDrawerNavigator<AppDrawerParamList>();

export function AppDrawerNavigator() {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const user = useAuthStore((state) => state.user);
  const { filters, setFilters } = useKitchenStore();
  const kitchenScreenName =
    user?.preparationScreen?.name || 'Pantalla de Preparacin';

  // Obtener el texto del filtro activo
  const getFilterText = () => {
    switch (filters.orderType) {
      case OrderTypeEnum.DINE_IN:
        return '  Mesa';
      case OrderTypeEnum.TAKE_AWAY:
        return '  Llevar';
      case OrderTypeEnum.DELIVERY:
        return '  Domicilio';
      default:
        return '';
    }
  };

  // Ruta inicial por defecto (no-kitchen users)
  const initialRouteName = 'OrdersStack';

  const styles = React.useMemo(
    () =>
      StyleSheet.create({
        drawerButtonContainer: {
          width: 56,
          height: 56,
          justifyContent: 'center',
          alignItems: 'center',
          marginLeft: 0,
          borderRadius: 28,
        },
        headerStyle: {
          backgroundColor: theme.colors.primary,
          height: responsive.dimensions.headerHeight,
          elevation: 2,
        },
        headerTitleStyle: {
          ...theme.fonts.titleLarge,
          color: theme.colors.onPrimary,
          fontWeight: 'bold',
          fontSize: responsive.isTablet ? 20 : 22,
        },
        drawerStyle: {
          backgroundColor: theme.colors.surface,
          width: responsive.dimensions.drawerWidth,
          borderTopRightRadius: theme.roundness * 2,
          borderBottomRightRadius: theme.roundness * 2,
        },
        transparentSurface: {
          backgroundColor: 'transparent',
        },
        headerRightContainer: {
          flexDirection: 'row',
          alignItems: 'center',
        },
        preparedOrdersToggle: {
          flexDirection: 'row',
          alignItems: 'center',
          paddingHorizontal: 12,
          paddingVertical: 8,
          marginRight: 8,
          borderRadius: 20,
        },
        preparedOrdersText: {
          fontSize: 14,
          marginLeft: 4,
        },
        preparedOrdersTextBold: {
          fontSize: 14,
          marginLeft: 4,
          fontWeight: 'bold',
        },
        preparedOrdersTextNormal: {
          fontSize: 14,
          marginLeft: 4,
          fontWeight: 'normal',
        },
        preparedOrdersToggleActive: {
          backgroundColor: 'rgba(255,255,255,0.2)',
        },
        preparedOrdersToggleInactive: {
          backgroundColor: 'transparent',
        },
      }),
    [theme, responsive],
  );

  return (
    <>
      <StatusBar
        backgroundColor={theme.colors.primary}
        barStyle={theme.dark ? 'light-content' : 'dark-content'}
      />
      <Drawer.Navigator
        initialRouteName={initialRouteName}
        drawerContent={(props) => <CustomDrawerContent {...props} />}
        screenOptions={({ navigation, route }) => ({
          headerStyle: styles.headerStyle,
          headerTintColor: theme.colors.onPrimary,
          headerTitleStyle: styles.headerTitleStyle,
          drawerStyle: styles.drawerStyle,
          drawerActiveTintColor: theme.colors.primary,
          drawerInactiveTintColor: theme.colors.onSurfaceVariant,
          drawerLabelStyle: {
            ...theme.fonts.labelLarge,
            fontSize: responsive.fontSizePreset.m,
          },
          drawerItemStyle: {
            marginVertical: responsive.spacingPreset.xxs,
            borderRadius: theme.roundness * 2,
            paddingVertical: responsive.spacingPreset.xxs,
            paddingHorizontal: responsive.spacingPreset.xs,
          },
          headerShown: true,
          drawerType: 'front',
          drawerPosition: 'left',
          headerShadowVisible: false,
          swipeEdgeWidth: 100,
          headerLeft: () => (
            <TouchableOpacity
              style={styles.drawerButtonContainer}
              onPress={() => navigation.openDrawer()}
              hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
            >
              <Icon source="menu" size={32} color={theme.colors.onPrimary} />
            </TouchableOpacity>
          ),
          headerTitle: ({ children }) => {
            let title = '';
            switch (children) {
              case 'MenuStack':
                title = 'Men';
                break;
              case 'ModifiersStack':
                title = 'Modificadores';
                break;
              case 'PreparationScreensStack':
                title = 'Pantallas Preparacin';
                break;
              case 'AreasTablesStack':
                title = 'reas y Mesas';
                break;
              case 'OrdersStack':
                title = 'rdenes';
                break;
              case 'PrintersStack':
                title = 'Impresoras';
                break;
              case 'ReceiptsStack':
                title = 'Recibos';
                break;
              case 'AvailabilityScreen':
                title = 'Disponibilidad';
                break;
              case 'OrderFinalizationStack':
                title = 'Finalizacin';
                break;
              case 'RestaurantConfigStack':
                title = 'Configuracin';
                break;
              case 'CustomersStack':
                title = 'Clientes';
                break;
              case 'PizzaCustomizationsStack':
                title = 'Personalizaciones';
                break;
              case 'SyncStack':
                title = 'Sincronizacin';
                break;
              case 'UsersScreen':
                title = 'Usuarios';
                break;
              case 'KitchenScreen':
                title =
                  kitchenScreenName +
                  (filters.orderType ? getFilterText() : '');
                break;
              case 'ShiftAuditStack':
                title = 'Historial de Turnos';
                break;
              case 'ServerSettings':
                title = 'Configuracin del Servidor';
                break;
              default:
                title = children?.toString() || '';
            }
            return (
              <Surface elevation={0} style={styles.transparentSurface}>
                <Text style={styles.headerTitleStyle}>{title}</Text>
              </Surface>
            );
          },
          headerRight: () => {
            // Solo mostrar ShiftIndicator en las secciones de ventas
            const salesScreens = [
              'OrdersStack',
              'ReceiptsStack',
              'OrderFinalizationStack',
            ];
            const showShiftIndicator = salesScreens.includes(route.name);

            return (
              <View style={styles.headerRightContainer}>
                {showShiftIndicator && <ShiftIndicator />}
                <ConnectionIndicator />
              </View>
            );
          },
        })}
      >
        <Drawer.Screen
          name="OrdersStack"
          component={OrdersStackNavigator}
          options={{
            title: 'rdenes',
            drawerIcon: ({ color }) => (
              <Icon
                source="clipboard-list-outline"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="ReceiptsStack"
          component={ReceiptsStackNavigator}
          options={{
            title: 'Recibos',
            drawerIcon: ({ color }) => (
              <Icon
                source="receipt"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="OrderFinalizationStack"
          component={OrderFinalizationStackNavigator}
          options={{
            title: 'Finalizacin',
            drawerIcon: ({ color }) => (
              <Icon
                source="clipboard-check-outline"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="MenuStack"
          component={MenuStackNavigator}
          options={{
            title: 'Men',
            drawerIcon: ({ color }) => (
              <Icon
                source="menu"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="AvailabilityScreen"
          component={AvailabilityScreen}
          options={{
            title: 'Disponibilidad',
            drawerIcon: ({ color }) => (
              <Icon
                source="eye-off-outline"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="ModifiersStack"
          component={ModifiersStackNavigator}
          options={{
            title: 'Modificadores',
            drawerIcon: ({ color }) => (
              <Icon
                source="tune"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="PizzaCustomizationsStack"
          component={PizzaCustomizationsStackNavigator}
          options={{
            title: 'Gestin de Pizzas',
            drawerIcon: ({ color }) => (
              <Icon
                source="pizza"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="PreparationScreensStack"
          component={PreparationScreensStackNavigator}
          options={{
            title: 'Pantallas Preparacin',
            drawerIcon: ({ color }) => (
              <Icon
                source="monitor-dashboard"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="AreasTablesStack"
          component={AreasTablesStackNavigator}
          options={{
            title: 'reas y Mesas',
            drawerIcon: ({ color }) => (
              <Icon
                source="map-marker-radius-outline"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />

        <Drawer.Screen
          name="PrintersStack"
          component={PrintersStackNavigator}
          options={{
            title: 'Impresoras',
            drawerIcon: ({ color }) => (
              <Icon
                source="printer"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="RestaurantConfigStack"
          component={RestaurantConfigStackNavigator}
          options={{
            title: 'Configuracin',
            drawerIcon: ({ color }) => (
              <Icon
                source="cog-outline"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="CustomersStack"
          component={CustomersStackNavigator}
          options={{
            title: 'Clientes',
            drawerIcon: ({ color }) => (
              <Icon
                source="account-group-outline"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="SyncStack"
          component={SyncStackNavigator}
          options={{
            title: 'Sincronizacin',
            drawerIcon: ({ color }) => (
              <Icon
                source="sync"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="UsersScreen"
          component={UsersListScreen}
          options={{
            title: 'Usuarios',
            drawerIcon: ({ color }) => (
              <Icon
                source="account-multiple"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="ShiftAuditStack"
          component={ShiftAuditStackNavigator}
          options={{
            title: 'Historial de Turnos',
            drawerIcon: ({ color }) => (
              <Icon
                source="history"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
          }}
        />
        <Drawer.Screen
          name="KitchenScreen"
          component={KitchenOrdersScreen}
          options={{
            title: kitchenScreenName,
            drawerIcon: ({ color }) => (
              <Icon
                source="chef-hat"
                color={color}
                size={responsive.dimensions.iconSize.medium}
              />
            ),
            headerRight: () => (
              <View style={styles.headerRightContainer}>
                {/* Checkbox para mostrar/ocultar ordenes listas */}
                <TouchableOpacity
                  style={[
                    styles.preparedOrdersToggle,
                    filters.showPrepared
                      ? styles.preparedOrdersToggleActive
                      : styles.preparedOrdersToggleInactive,
                  ]}
                  onPress={() =>
                    setFilters({
                      ...filters,
                      showPrepared: !filters.showPrepared,
                    })
                  }
                >
                  <Checkbox
                    status={filters.showPrepared ? 'checked' : 'unchecked'}
                    onPress={() =>
                      setFilters({
                        ...filters,
                        showPrepared: !filters.showPrepared,
                      })
                    }
                    color={theme.colors.onPrimary}
                    uncheckedColor={theme.colors.onPrimary}
                  />
                  <PaperText
                    style={[
                      filters.showPrepared
                        ? styles.preparedOrdersTextBold
                        : styles.preparedOrdersTextNormal,
                      {
                        color: theme.colors.onPrimary,
                      },
                    ]}
                  >
                    Mostrar Listas
                  </PaperText>
                </TouchableOpacity>
                <KitchenFilterButton />
                <ConnectionIndicator />
              </View>
            ),
          }}
        />
        <Drawer.Screen
          name="ServerSettings"
          component={ServerSettingsScreen}
          options={{
            title: 'Configuracin del Servidor',
            drawerItemStyle: { display: 'none' }, // Oculto del drawer, solo accesible desde el botn
          }}
        />
      </Drawer.Navigator>
    </>
  );
}

================
File: app/src/modules/areasTables/services/areaService.ts
================
import apiClient from '../../../app/services/apiClient';
import { API_PATHS } from '../../../app/constants/apiPaths';
import { BaseListQuery } from '../../../app/types/query.types';
import {
  Area,
  CreateAreaDto,
  UpdateAreaDto,
  FindAllAreasDto,
} from '../schema/area.schema';

const getAreas = async (
  filterOptions: FindAllAreasDto = {},
  paginationOptions: BaseListQuery = { page: 1, limit: 10 },
): Promise<Area[]> => {
  const response = await apiClient.get<{
    items: Area[];
    total: number;
    page: number;
    limit: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  }>(API_PATHS.AREAS, {
    params: {
      ...filterOptions,
      page: paginationOptions.page,
      limit: paginationOptions.limit,
    },
  });

  return response.data.items;
};

const getAreaById = async (id: string): Promise<Area> => {
  const response = await apiClient.get<Area>(
    API_PATHS.AREAS_BY_ID.replace(':id', id),
  );

  return response.data;
};

const createArea = async (data: CreateAreaDto): Promise<Area> => {
  const response = await apiClient.post<Area>(API_PATHS.AREAS, data);

  return response.data;
};

const updateArea = async (id: string, data: UpdateAreaDto): Promise<Area> => {
  const response = await apiClient.patch<Area>(
    API_PATHS.AREAS_BY_ID.replace(':id', id),
    data,
  );

  return response.data;
};

const deleteArea = async (id: string): Promise<void> => {
  await apiClient.delete(API_PATHS.AREAS_BY_ID.replace(':id', id));
};

export const areaService = {
  getAreas,
  getAreaById,
  createArea,
  updateArea,
  deleteArea,
};

================
File: app/src/modules/orders/components/OrderDetailModal.tsx
================
import React, { useMemo } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  IconButton,
  Divider,
  Card,
  Chip,
  Surface,
} from 'react-native-paper';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import { useAppTheme } from '@/app/styles/theme';
import { MaterialCommunityIcons as Icon } from '@expo/vector-icons';
import { OrderStatusInfo, PreparationStatusInfo } from '../utils/formatters';

interface OrderDetailModalProps {
  visible: boolean;
  onDismiss: () => void;
  orderId: string | null;
  orderNumber?: number;
  orderData?: any; // Datos de la orden pasados como prop
}

// Componente interno para mostrar el contenido de detalles
export const OrderDetailContent: React.FC<{
  orderId: string | null;
  orderNumber?: number;
  orderData?: any; // Datos de la orden pasados como prop
}> = ({ orderData }) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);

  return (
    <ScrollView style={styles.content} showsVerticalScrollIndicator={false}>
      {!orderData ? (
        <View style={styles.errorContainer}>
          <Icon
            name="alert-circle-outline"
            size={48}
            color={theme.colors.error}
          />
          <Text style={styles.errorText}>
            No hay datos de la orden disponibles
          </Text>
        </View>
      ) : (
        <>
          {/* Informacin General - Simplificada */}
          <View style={styles.infoHeader}>
            <View style={styles.infoHeaderRow}>
              <Text style={styles.infoHeaderLabel}>Hora de creacin:</Text>
              <Text style={styles.infoHeaderValue}>
                {format(new Date(orderData.createdAt), 'HH:mm', { locale: es })}
              </Text>
            </View>
          </View>

          {/* Items de la Orden */}
          <Card style={styles.itemsCard}>
            <Card.Content style={styles.cardContentCompact}>
              <Text style={styles.sectionTitle}>
                Artculos ({orderData.orderItems?.length || 0})
              </Text>

              {orderData.orderItems?.map((item: any, index: number) => (
                <View key={item.id || index} style={styles.itemRow}>
                  <View style={styles.itemCompactRow}>
                    <View style={styles.itemMainInfo}>
                      <View style={styles.itemTitleRow}>
                        <Text style={styles.itemName}>
                          {item.product?.name || 'Producto desconocido'}
                          {item.productVariant &&
                            ` - ${item.productVariant.name}`}
                        </Text>
                        <Chip
                          mode="flat"
                          compact
                          style={[
                            styles.preparationChip,
                            {
                              backgroundColor:
                                PreparationStatusInfo.getColor(
                                  item.preparationStatus,
                                  theme,
                                ) + '20',
                            },
                          ]}
                          textStyle={[
                            styles.preparationChipText,
                            {
                              color: PreparationStatusInfo.getColor(
                                item.preparationStatus,
                                theme,
                              ),
                            },
                          ]}
                        >
                          {PreparationStatusInfo.getLabel(
                            item.preparationStatus,
                          )}
                        </Chip>
                      </View>
                      {item.preparationNotes && (
                        <Text style={styles.itemNotes}>
                           {item.preparationNotes}
                        </Text>
                      )}
                    </View>
                    {item.preparedAt && (
                      <Text style={styles.preparedTime}>
                        {format(new Date(item.preparedAt), 'HH:mm')}
                      </Text>
                    )}
                  </View>
                  {index < orderData.orderItems.length - 1 && (
                    <Divider style={styles.itemDivider} />
                  )}
                </View>
              ))}
            </Card.Content>
          </Card>
        </>
      )}
    </ScrollView>
  );
};

export const OrderDetailModal: React.FC<OrderDetailModalProps> = ({
  visible,
  onDismiss,
  orderId,
  orderNumber,
  orderData,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);

  if (!visible) return null;

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalContainer}
      >
        <Surface style={styles.surface} elevation={2}>
          {/* Header */}
          <View style={styles.header}>
            <View style={styles.headerContent}>
              <Text style={styles.title}>
                {orderNumber ? `Orden #${orderNumber}` : 'Detalles de la Orden'}
              </Text>
              {orderData && (
                <Chip
                  mode="flat"
                  style={[
                    styles.statusChip,
                    {
                      backgroundColor: OrderStatusInfo.getColor(
                        orderData.orderStatus,
                        theme,
                      ),
                    },
                  ]}
                  textStyle={styles.statusChipText}
                >
                  {OrderStatusInfo.getLabel(orderData.orderStatus)}
                </Chip>
              )}
            </View>
            <IconButton
              icon="close-circle"
              size={32}
              onPress={onDismiss}
              style={styles.closeButton}
              iconColor={theme.colors.error}
            />
          </View>

          <Divider />

          {/* Content */}
          <OrderDetailContent
            orderId={orderId}
            orderNumber={orderNumber}
            orderData={orderData}
          />
        </Surface>
      </Modal>
    </Portal>
  );
};

const createStyles = (theme: any) =>
  StyleSheet.create({
    modalContainer: {
      padding: 12,
      maxWidth: 600,
      width: '95%',
      alignSelf: 'center',
      maxHeight: '92%',
    },
    surface: {
      borderRadius: theme.roundness * 2,
      overflow: 'hidden',
    },
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: 12,
      paddingVertical: 8,
      minHeight: 56,
    },
    headerContent: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      gap: 12,
      marginRight: 8,
    },
    title: {
      fontSize: 20,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    statusChip: {
      minHeight: 28,
      height: 'auto',
      paddingVertical: 4,
    },
    statusChipText: {
      fontSize: 13,
      fontWeight: '600',
      color: 'white',
      lineHeight: 18,
      includeFontPadding: false,
      textAlignVertical: 'center',
    },
    closeButton: {
      margin: -4,
      backgroundColor: theme.colors.errorContainer,
      borderRadius: 20,
    },
    content: {
      maxHeight: 600,
    },
    loadingContainer: {
      padding: 40,
      alignItems: 'center',
    },
    loadingText: {
      marginTop: 16,
      color: theme.colors.onSurfaceVariant,
    },
    errorContainer: {
      padding: 40,
      alignItems: 'center',
    },
    errorText: {
      marginTop: 16,
      color: theme.colors.error,
    },
    infoHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      paddingHorizontal: 12,
      paddingVertical: 8,
      backgroundColor: theme.colors.surfaceVariant,
      marginBottom: 4,
    },
    infoHeaderRow: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    infoHeaderLabel: {
      fontSize: 13,
      color: theme.colors.onSurfaceVariant,
      marginRight: 8,
    },
    infoHeaderValue: {
      fontSize: 14,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    infoCard: {
      margin: 8,
      marginBottom: 4,
    },
    itemsCard: {
      marginHorizontal: 8,
      marginTop: 4,
      marginBottom: 8,
      flex: 1,
    },
    itemRow: {
      paddingVertical: 3,
    },
    itemCompactRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      gap: 8,
    },
    itemMainInfo: {
      flex: 1,
    },
    itemTitleRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 8,
      flexWrap: 'nowrap',
    },
    itemStatusInfo: {
      alignItems: 'flex-end',
      gap: 2,
    },
    itemContent: {
      flex: 1,
    },
    itemHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 2,
    },
    itemFooter: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginTop: 8,
    },
    itemDivider: {
      marginTop: 2,
      marginBottom: 1,
      backgroundColor: theme.colors.outlineVariant,
    },
    sectionTitle: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
      marginBottom: 12,
    },
    itemName: {
      fontWeight: '600',
      fontSize: 13,
      color: theme.colors.onSurface,
      flex: 1,
      flexShrink: 1,
    },
    itemVariant: {
      fontSize: 13,
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
    },
    itemNotes: {
      fontSize: 10,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      marginTop: 0,
    },
    preparationChip: {
      minHeight: 26,
      height: 'auto',
      paddingHorizontal: 10,
      paddingVertical: 4,
    },
    preparationChipText: {
      fontSize: 12,
      fontWeight: '600',
      lineHeight: 16,
      includeFontPadding: false,
      textAlignVertical: 'center',
    },
    preparedTime: {
      fontSize: 12,
      color: theme.colors.primary,
      fontWeight: '600',
      minWidth: 40,
      textAlign: 'right',
      alignSelf: 'center',
      lineHeight: 16,
    },
    itemTimesContainer: {
      flex: 1,
      alignItems: 'flex-end',
    },
    itemCreatedTime: {
      fontSize: 11,
      color: theme.colors.onSurfaceVariant,
    },
    preparedByText: {
      fontSize: 11,
      color: theme.colors.primary,
      fontWeight: '500',
      marginTop: 2,
    },
    notPrepared: {
      fontSize: 12,
      color: theme.colors.onSurfaceDisabled,
    },
    cardContentCompact: {
      paddingVertical: 6,
      paddingHorizontal: 10,
    },
  });

export default OrderDetailModal;

================
File: app/src/modules/sync/services/syncService.ts
================
import apiClient from '@/app/services/apiClient';
import { API_PATHS } from '@/app/constants/apiPaths';
import { SyncStatus, SyncActivity } from '../schema/sync.schema';

class SyncService {
  async getSyncStatus(): Promise<SyncStatus> {
    const response = await apiClient.get<SyncStatus>(API_PATHS.SYNC_STATUS);
    return response.data;
  }

  async getSyncActivity(limit: number = 20): Promise<SyncActivity[]> {
    const response = await apiClient.get<SyncActivity[]>(
      API_PATHS.SYNC_ACTIVITY,
      { params: { limit } },
    );
    return response.data;
  }

  async checkSyncAvailability(): Promise<boolean> {
    try {
      const status = await this.getSyncStatus();
      return status.enabled;
    } catch (error) {
      // Log silencioso para no mostrar errores en produccin
      if (__DEV__) {
        console.error(
          'Error verificando disponibilidad de sincronizacin:',
          error,
        );
      }
      return false;
    }
  }
}

export const syncService = new SyncService();

================
File: app/src/modules/users/components/UserDetailModal.tsx
================
import { useState } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Portal,
  Modal,
  Text,
  Surface,
  IconButton,
  Chip,
  Button,
  Dialog,
  TextInput,
  Icon,
} from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useResetPassword, useDeleteUser } from '../hooks';
import type { User } from '../schema/user.schema';

interface UserDetailModalProps {
  visible: boolean;
  onDismiss: () => void;
  user: User;
  onEdit: (user: User) => void;
}

export function UserDetailModal({
  visible,
  onDismiss,
  user,
  onEdit,
}: UserDetailModalProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = getStyles(theme, responsive);

  const [showPasswordDialog, setShowPasswordDialog] = useState(false);
  const [newPassword, setNewPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);

  const resetPasswordMutation = useResetPassword();
  const deleteUserMutation = useDeleteUser();

  const handleResetPassword = async () => {
    if (newPassword !== confirmPassword) {
      return;
    }
    if (newPassword.length < 6) {
      return;
    }

    try {
      await resetPasswordMutation.mutateAsync({
        id: user.id,
        password: newPassword,
      });
      setShowPasswordDialog(false);
      setNewPassword('');
      setConfirmPassword('');
    } catch (error) {
      // Error is handled by mutation
    }
  };

  const handleDeleteUser = async () => {
    try {
      await deleteUserMutation.mutateAsync(user.id);
      onDismiss();
    } catch (error) {
      // Error is handled by mutation
    }
  };

  const getGenderLabel = (gender?: string | null) => {
    switch (gender) {
      case 'male':
        return 'Masculino';
      case 'female':
        return 'Femenino';
      case 'other':
        return 'Otro';
      default:
        return 'No especificado';
    }
  };

  const getRoleInfo = (roleId?: number) => {
    switch (roleId) {
      case 1:
        return {
          label: 'Administrador',
          icon: 'shield-account',
          color: theme.colors.error,
        };
      case 2:
        return {
          label: 'Gerente',
          icon: 'account-tie',
          color: theme.colors.primary,
        };
      case 3:
        return {
          label: 'Cajero',
          icon: 'cash-register',
          color: theme.colors.tertiary,
        };
      case 4:
        return {
          label: 'Mesero',
          icon: 'room-service',
          color: theme.colors.secondary,
        };
      case 5:
        return { label: 'Cocina', icon: 'chef-hat', color: '#FF6B6B' };
      case 6:
        return { label: 'Repartidor', icon: 'moped', color: '#4ECDC4' };
      default:
        return {
          label: 'Sin rol',
          icon: 'account',
          color: theme.colors.onSurfaceVariant,
        };
    }
  };

  return (
    <>
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onDismiss}
          contentContainerStyle={styles.modalContainer}
        >
          <Surface style={styles.modalContent} elevation={3}>
            <View
              style={[
                styles.headerContainer,
                { backgroundColor: theme.colors.elevation.level2 },
              ]}
            >
              <View style={styles.headerContent}>
                <View style={styles.headerNameRow}>
                  <Text
                    style={[
                      styles.modalTitle,
                      { color: theme.colors.onSurface },
                    ]}
                    variant="titleMedium"
                  >
                    {`${user.firstName || ''} ${user.lastName || ''}`.trim() ||
                      user.username}
                  </Text>
                  <Chip
                    mode="flat"
                    icon={getRoleInfo(user.role?.id).icon}
                    style={[
                      styles.headerRoleChip,
                      { backgroundColor: theme.colors.surface },
                    ]}
                    textStyle={[
                      styles.headerRoleChipText,
                      { color: getRoleInfo(user.role?.id).color },
                    ]}
                    compact
                  >
                    {getRoleInfo(user.role?.id).label}
                  </Chip>
                </View>
                <Text
                  style={[
                    styles.modalSubtitle,
                    { color: theme.colors.onSurfaceVariant },
                  ]}
                  variant="bodySmall"
                >
                  {user.username}
                </Text>
              </View>
              <IconButton
                icon="close"
                size={20}
                onPress={onDismiss}
                iconColor={theme.colors.onSurfaceVariant}
              />
            </View>

            <ScrollView
              style={styles.contentContainer}
              showsVerticalScrollIndicator={false}
            >
              <View style={styles.infoSection}>
                <View style={styles.sectionHeader}>
                  <Icon
                    source="contacts"
                    size={20}
                    color={theme.colors.primary}
                  />
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Informacin de Contacto
                  </Text>
                </View>

                <View style={styles.compactRow}>
                  <Icon source="email" size={18} color={theme.colors.primary} />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Email
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.email || 'No especificado'}
                    </Text>
                  </View>
                </View>

                <View style={styles.compactRow}>
                  <Icon source="phone" size={18} color={theme.colors.primary} />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Telfono
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.phoneNumber || 'No especificado'}
                    </Text>
                  </View>
                </View>
              </View>

              <View style={styles.infoSection}>
                <View style={styles.sectionHeader}>
                  <Icon
                    source="account-details"
                    size={20}
                    color={theme.colors.primary}
                  />
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Informacin Personal
                  </Text>
                </View>

                <View style={styles.compactRow}>
                  <Icon
                    source="account"
                    size={18}
                    color={theme.colors.primary}
                  />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Nombre completo
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {`${user.firstName || 'No especificado'} ${user.lastName || 'No especificado'}`}
                    </Text>
                  </View>
                </View>

                <View style={styles.compactRow}>
                  <Icon
                    source="gender-transgender"
                    size={18}
                    color={theme.colors.primary}
                  />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Gnero
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {getGenderLabel(user.gender)}
                    </Text>
                  </View>
                </View>

                <View style={styles.compactRow}>
                  <Icon
                    source="cake-variant"
                    size={18}
                    color={theme.colors.primary}
                  />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Fecha de nacimiento
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.birthDate
                        ? new Date(user.birthDate).toLocaleDateString('es-MX', {
                            year: 'numeric',
                            month: 'long',
                            day: 'numeric',
                          })
                        : 'No especificado'}
                    </Text>
                  </View>
                </View>

                <View style={styles.compactRow}>
                  <Icon
                    source={
                      user.isActive
                        ? 'check-circle-outline'
                        : 'close-circle-outline'
                    }
                    size={18}
                    color={
                      user.isActive ? theme.colors.primary : theme.colors.error
                    }
                  />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Estado de la cuenta
                    </Text>
                    <Text
                      style={[
                        styles.compactValue,
                        {
                          color: user.isActive
                            ? theme.colors.primary
                            : theme.colors.error,
                        },
                      ]}
                      variant="bodySmall"
                    >
                      {user.isActive ? 'Activa' : 'Inactiva'}
                    </Text>
                  </View>
                </View>

                {user.role?.id === 5 && (
                  <View style={styles.compactRow}>
                    <Icon
                      source="monitor"
                      size={18}
                      color={theme.colors.primary}
                    />
                    <View style={styles.compactContent}>
                      <Text style={styles.compactLabel} variant="labelSmall">
                        Pantalla de Preparacin
                      </Text>
                      <Text style={styles.compactValue} variant="bodySmall">
                        {user.preparationScreen?.name || 'No asignada'}
                      </Text>
                    </View>
                  </View>
                )}
              </View>

              <View style={styles.infoSection}>
                <View style={styles.sectionHeader}>
                  <Icon
                    source="map-marker"
                    size={20}
                    color={theme.colors.primary}
                  />
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Direccin
                  </Text>
                </View>

                <View style={styles.compactRow}>
                  <Icon source="home" size={18} color={theme.colors.primary} />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Direccin
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.address || 'No especificado'}
                    </Text>
                  </View>
                </View>

                <View style={styles.compactRow}>
                  <Icon source="city" size={18} color={theme.colors.primary} />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Ciudad
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.city || 'No especificado'}
                    </Text>
                  </View>
                </View>

                <View style={styles.compactRow}>
                  <Icon source="map" size={18} color={theme.colors.primary} />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Estado/Provincia
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.state || 'No especificado'}
                    </Text>
                  </View>
                </View>

                <View style={styles.compactRow}>
                  <Icon source="earth" size={18} color={theme.colors.primary} />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Pas
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.country || 'No especificado'}
                    </Text>
                  </View>
                </View>

                <View style={styles.compactRow}>
                  <Icon
                    source="mailbox"
                    size={18}
                    color={theme.colors.primary}
                  />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Cdigo Postal
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.zipCode || 'No especificado'}
                    </Text>
                  </View>
                </View>
              </View>

              <View style={styles.infoSection}>
                <View style={styles.sectionHeader}>
                  <Icon
                    source="alert-circle"
                    size={20}
                    color={theme.colors.error}
                  />
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Contacto de Emergencia
                  </Text>
                </View>

                <View style={styles.compactRow}>
                  <Icon
                    source="account-alert"
                    size={18}
                    color={theme.colors.primary}
                  />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Nombre
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.emergencyContact?.name || 'No especificado'}
                    </Text>
                  </View>
                </View>

                <View style={styles.compactRow}>
                  <Icon
                    source="phone-alert"
                    size={18}
                    color={theme.colors.primary}
                  />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Telfono
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.emergencyContact?.phone || 'No especificado'}
                    </Text>
                  </View>
                </View>

                <View style={styles.compactRow}>
                  <Icon
                    source="account-multiple"
                    size={18}
                    color={theme.colors.primary}
                  />
                  <View style={styles.compactContent}>
                    <Text style={styles.compactLabel} variant="labelSmall">
                      Relacin
                    </Text>
                    <Text style={styles.compactValue} variant="bodySmall">
                      {user.emergencyContact?.relationship || 'No especificado'}
                    </Text>
                  </View>
                </View>
              </View>

              <View style={styles.actionsContainer}>
                <Button
                  mode="contained-tonal"
                  onPress={() => onEdit(user)}
                  icon="pencil"
                  style={styles.actionButton}
                  contentStyle={styles.buttonContent}
                  labelStyle={styles.buttonLabel}
                  compact
                >
                  Editar Usuario
                </Button>

                <Button
                  mode="contained-tonal"
                  onPress={() => setShowPasswordDialog(true)}
                  icon="lock-reset"
                  style={styles.actionButton}
                  contentStyle={styles.buttonContent}
                  labelStyle={styles.buttonLabel}
                  buttonColor={theme.colors.secondaryContainer}
                  compact
                >
                  Cambiar Contrasea
                </Button>

                <Button
                  mode="outlined"
                  onPress={() => setShowDeleteDialog(true)}
                  icon="delete"
                  style={[styles.actionButton, styles.deleteButton]}
                  contentStyle={styles.buttonContent}
                  labelStyle={styles.buttonLabel}
                  textColor={theme.colors.error}
                  compact
                >
                  Eliminar Usuario
                </Button>
              </View>
            </ScrollView>
          </Surface>
        </Modal>
      </Portal>

      <Portal>
        <Dialog
          visible={showPasswordDialog}
          onDismiss={() => {
            setShowPasswordDialog(false);
            setNewPassword('');
            setConfirmPassword('');
            setShowPassword(false);
          }}
          style={styles.passwordDialog}
        >
          <View
            style={[
              styles.passwordDialogContainer,
              { borderColor: theme.colors.primary },
            ]}
          >
            <View style={styles.passwordDialogHeader}>
              <Icon
                source="lock-reset"
                size={40}
                color={theme.colors.primary}
              />
              <Dialog.Title style={styles.passwordDialogTitle}>
                Cambiar Contrasea
              </Dialog.Title>
              <View style={styles.passwordDialogUserInfo}>
                <Text
                  variant="bodyMedium"
                  style={styles.passwordDialogUserName}
                >
                  {`${user.firstName || ''} ${user.lastName || ''}`.trim() ||
                    user.username}
                </Text>
                <Text
                  variant="bodySmall"
                  style={styles.passwordDialogUserDetail}
                >
                  {user.email}
                </Text>
                <Text
                  variant="labelSmall"
                  style={styles.passwordDialogUserDetail}
                >
                  @{user.username}
                </Text>
              </View>
            </View>

            <Dialog.Content style={styles.passwordDialogContent}>
              <TextInput
                label="Nueva contrasea"
                value={newPassword}
                onChangeText={setNewPassword}
                mode="flat"
                secureTextEntry={!showPassword}
                autoCapitalize="none"
                autoCorrect={false}
                autoComplete="new-password"
                style={styles.passwordInput}
                contentStyle={styles.passwordInputContent}
                underlineColor={theme.colors.surfaceVariant}
                activeUnderlineColor={theme.colors.primary}
                right={
                  <TextInput.Icon
                    icon={showPassword ? 'eye-off' : 'eye'}
                    onPress={() => setShowPassword(!showPassword)}
                    size={20}
                    style={styles.passwordInputIcon}
                  />
                }
              />

              <TextInput
                label="Confirmar contrasea"
                value={confirmPassword}
                onChangeText={setConfirmPassword}
                mode="flat"
                secureTextEntry={!showPassword}
                autoCapitalize="none"
                autoCorrect={false}
                autoComplete="new-password"
                style={styles.passwordInput}
                contentStyle={styles.passwordInputContent}
                underlineColor={theme.colors.surfaceVariant}
                activeUnderlineColor={theme.colors.primary}
              />

              {(newPassword.length > 0 || confirmPassword.length > 0) && (
                <View style={styles.passwordValidation}>
                  <View style={styles.validationItem}>
                    <Icon
                      source={
                        newPassword.length >= 6
                          ? 'check-circle'
                          : 'circle-outline'
                      }
                      size={16}
                      color={
                        newPassword.length >= 6
                          ? theme.colors.primary
                          : theme.colors.onSurfaceVariant
                      }
                    />
                    <Text
                      variant="bodySmall"
                      style={[
                        styles.validationText,
                        {
                          color:
                            newPassword.length >= 6
                              ? theme.colors.primary
                              : theme.colors.onSurfaceVariant,
                        },
                      ]}
                    >
                      Mnimo 6 caracteres
                    </Text>
                  </View>

                  <View style={styles.validationItem}>
                    <Icon
                      source={
                        newPassword === confirmPassword &&
                        newPassword.length > 0
                          ? 'check-circle'
                          : 'circle-outline'
                      }
                      size={16}
                      color={
                        newPassword === confirmPassword &&
                        newPassword.length > 0
                          ? theme.colors.primary
                          : theme.colors.onSurfaceVariant
                      }
                    />
                    <Text
                      variant="bodySmall"
                      style={[
                        styles.validationText,
                        {
                          color:
                            newPassword === confirmPassword &&
                            newPassword.length > 0
                              ? theme.colors.primary
                              : theme.colors.onSurfaceVariant,
                        },
                      ]}
                    >
                      Las contraseas coinciden
                    </Text>
                  </View>
                </View>
              )}
            </Dialog.Content>

            <Dialog.Actions style={styles.passwordDialogActions}>
              <Button
                mode="text"
                onPress={() => {
                  setShowPasswordDialog(false);
                  setNewPassword('');
                  setConfirmPassword('');
                  setShowPassword(false);
                }}
                style={[
                  styles.passwordDialogButton,
                  styles.passwordDialogCancelButton,
                ]}
                labelStyle={styles.passwordDialogButtonLabel}
              >
                Cancelar
              </Button>
              <Button
                mode="contained"
                onPress={handleResetPassword}
                loading={resetPasswordMutation.isPending}
                disabled={
                  resetPasswordMutation.isPending ||
                  newPassword.length < 6 ||
                  newPassword !== confirmPassword
                }
                style={[
                  styles.passwordDialogButton,
                  styles.passwordDialogPrimaryButton,
                ]}
                labelStyle={styles.passwordDialogButtonLabel}
              >
                Cambiar
              </Button>
            </Dialog.Actions>
          </View>
        </Dialog>
      </Portal>

      <Portal>
        <Dialog
          visible={showDeleteDialog}
          onDismiss={() => setShowDeleteDialog(false)}
        >
          <Dialog.Icon icon="alert" color={theme.colors.error} />
          <Dialog.Title style={styles.dialogTitle}>
            Eliminar Usuario
          </Dialog.Title>
          <Dialog.Content>
            <Text variant="bodyMedium" style={styles.dialogText}>
              Ests seguro de que deseas eliminar al usuario{' '}
              <Text style={styles.boldText}>{user.username}</Text>?
            </Text>
            <Text
              variant="bodySmall"
              style={[
                styles.dialogText,
                {
                  marginTop: theme.spacing.s,
                  color: theme.colors.error,
                },
              ]}
            >
              Esta accin no se puede deshacer
            </Text>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setShowDeleteDialog(false)}>Cancelar</Button>
            <Button
              onPress={handleDeleteUser}
              loading={deleteUserMutation.isPending}
              disabled={deleteUserMutation.isPending}
              textColor={theme.colors.error}
            >
              Eliminar
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </>
  );
}

const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    passwordDialog: {
      backgroundColor: 'transparent',
    },
    passwordDialogContainer: {
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness * 4,
      borderWidth: 2,
      overflow: 'hidden',
    },
    passwordDialogHeader: {
      alignItems: 'center',
      paddingTop: theme.spacing.l,
      paddingBottom: theme.spacing.s,
      backgroundColor: theme.colors.elevation.level1,
    },
    passwordDialogTitle: {
      textAlign: 'center',
      fontSize: 20,
      fontWeight: '600',
      marginTop: theme.spacing.s,
      marginBottom: theme.spacing.s,
    },
    passwordDialogUserInfo: {
      alignItems: 'center',
      paddingHorizontal: theme.spacing.l,
      marginBottom: theme.spacing.xs,
    },
    passwordDialogUserName: {
      textAlign: 'center',
      fontWeight: '600',
      color: theme.colors.onSurface,
      marginBottom: theme.spacing.xs,
    },
    passwordDialogUserDetail: {
      textAlign: 'center',
      color: theme.colors.onSurfaceVariant,
      marginBottom: 2,
    },
    passwordDialogContent: {
      paddingTop: theme.spacing.m,
      paddingBottom: theme.spacing.s,
    },
    passwordInput: {
      backgroundColor: 'transparent',
      marginBottom: theme.spacing.m,
    },
    passwordInputContent: {
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: theme.roundness * 2,
      paddingHorizontal: theme.spacing.m,
      paddingRight: theme.spacing.m,
    },
    passwordInputIcon: {
      marginRight: -theme.spacing.xs,
    },
    passwordValidation: {
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: theme.roundness * 2,
      padding: theme.spacing.m,
      gap: theme.spacing.s,
    },
    validationItem: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
    },
    validationText: {
      fontSize: 12,
    },
    passwordDialogActions: {
      justifyContent: 'center',
      paddingBottom: theme.spacing.m,
      paddingHorizontal: theme.spacing.l,
      gap: theme.spacing.s,
    },
    passwordDialogButton: {
      minWidth: 100,
      borderRadius: theme.roundness * 3,
    },
    passwordDialogCancelButton: {
      marginRight: theme.spacing.s,
    },
    passwordDialogPrimaryButton: {
      elevation: 0,
    },
    passwordDialogButtonLabel: {
      fontSize: 14,
      fontWeight: '600',
      letterSpacing: 0.1,
    },
    modalContainer: {
      margin: responsive.isTablet ? theme.spacing.xl : theme.spacing.m,
      maxWidth: responsive.isTablet ? 700 : 420,
      alignSelf: 'center',
      width: responsive.isTablet ? '85%' : '92%',
      paddingHorizontal: 0,
      height: responsive.isTablet ? '80%' : '80%',
      maxHeight: responsive.isTablet ? '85%' : '92%',
      justifyContent: 'center',
    },
    modalContent: {
      borderRadius: theme.roundness * 3,
      backgroundColor: theme.colors.surface,
      height: '100%',
      flex: 1,
      overflow: 'hidden',
      elevation: 5,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
    },
    headerContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingHorizontal: responsive.isTablet
        ? theme.spacing.l
        : theme.spacing.m,
      paddingVertical: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
      borderTopLeftRadius: theme.roundness * 3,
      borderTopRightRadius: theme.roundness * 3,
    },
    headerContent: {
      flex: 1,
      flexDirection: 'column',
      justifyContent: 'center',
    },
    headerNameRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
    },
    modalTitle: {
      fontWeight: '600',
      marginRight: theme.spacing.xs,
      fontSize: responsive.isTablet ? 15 : 16,
    },
    modalSubtitle: {
      marginTop: 2,
      fontSize: responsive.isTablet ? 12 : 14,
    },
    headerRoleChip: {
      minHeight: responsive.isTablet ? 32 : 28,
      height: 'auto',
      borderRadius: theme.roundness * 2,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
      paddingHorizontal: theme.spacing.s,
      paddingVertical: 3,
      alignItems: 'center',
      justifyContent: 'center',
    },
    headerRoleChipText: {
      fontSize: 12,
      fontWeight: '600',
      lineHeight: 16,
      marginVertical: 0,
      paddingVertical: 0,
      includeFontPadding: false,
    },
    contentContainer: {
      flex: 1,
      paddingHorizontal: responsive.isTablet
        ? theme.spacing.l
        : theme.spacing.m,
      paddingTop: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
      paddingBottom: responsive.isTablet ? theme.spacing.l : theme.spacing.m,
    },
    infoSection: {
      borderRadius: theme.roundness * 2,
      padding: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
      marginBottom: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
      backgroundColor: theme.colors.elevation.level1,
      borderWidth: 0,
      elevation: 0,
    },
    sectionHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.isTablet ? theme.spacing.xs : theme.spacing.xs,
      marginBottom: responsive.isTablet ? theme.spacing.s : theme.spacing.xs,
    },
    sectionTitle: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: responsive.isTablet ? 14 : 14,
    },
    listItemTitle: {
      color: theme.colors.onSurface,
      fontWeight: '500',
      fontSize: 14,
    },
    listItemDescription: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 11,
    },
    actionsContainer: {
      gap: responsive.isTablet ? theme.spacing.s : theme.spacing.xs,
      marginBottom: responsive.isTablet ? theme.spacing.l : theme.spacing.m,
      marginTop: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
      paddingHorizontal: 0,
    },
    actionButton: {
      borderRadius: theme.roundness * 2,
      elevation: 0,
      height: responsive.isTablet ? 36 : 40,
    },
    buttonContent: {
      height: responsive.isTablet ? 36 : 40,
      paddingTop: 0,
      paddingBottom: 0,
    },
    buttonLabel: {
      fontSize: responsive.isTablet ? 13 : 14,
      lineHeight: responsive.isTablet ? 18 : 20,
      marginVertical: responsive.isTablet ? 6 : 8,
      includeFontPadding: false,
    },
    deleteButton: {
      borderColor: theme.colors.error,
      marginTop: theme.spacing.xs,
    },
    compactRow: {
      flexDirection: 'row',
      alignItems: 'flex-start',
      gap: responsive.isTablet ? theme.spacing.s : theme.spacing.s,
      paddingVertical: responsive.isTablet ? theme.spacing.s : theme.spacing.xs,
    },
    compactContent: {
      flex: 1,
    },
    compactLabel: {
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 11 : 11,
      lineHeight: responsive.isTablet ? 14 : 14,
    },
    compactValue: {
      color: theme.colors.onSurface,
      fontSize: responsive.isTablet ? 13 : 13,
      fontWeight: '500',
      lineHeight: responsive.isTablet ? 16 : 16,
    },
    dialogTitle: {
      textAlign: 'center',
    },
    dialogText: {
      textAlign: 'center',
    },
    boldText: {
      fontWeight: 'bold',
    },
  });

================
File: app/src/services/shifts.ts
================
import apiClient from '../app/services/apiClient';
import { API_PATHS } from '../app/constants/apiPaths';
import type { Order } from '../app/schemas/domain/order.schema';
import type { 
  Shift, 
  OpenShiftDto, 
  CloseShiftDto, 
  ShiftSummary, 
  ShiftOrder 
} from '../app/schemas/domain/shift.schema';

class ShiftsService {
  async getCurrentShift(): Promise<Shift | null> {
    try {
      const response = await apiClient.get(API_PATHS.SHIFTS_CURRENT);
      return response.data;
    } catch (error: any) {
      if (error.response?.status === 404) {
        return null;
      }
      throw error;
    }
  }

  async openShift(data: OpenShiftDto): Promise<Shift> {
    const response = await apiClient.post(API_PATHS.SHIFTS_OPEN, data);
    return response.data;
  }

  async closeShift(data: CloseShiftDto): Promise<Shift> {
    const response = await apiClient.post(API_PATHS.SHIFTS_CLOSE, data);
    return response.data;
  }

  async getHistory(params?: {
    startDate?: string;
    endDate?: string;
  }): Promise<Shift[]> {
    const queryParams = new URLSearchParams();

    if (params?.startDate) {
      queryParams.append('startDate', params.startDate);
    }
    if (params?.endDate) {
      queryParams.append('endDate', params.endDate);
    }

    const url = queryParams.toString()
      ? `${API_PATHS.SHIFTS_HISTORY}?${queryParams.toString()}`
      : API_PATHS.SHIFTS_HISTORY;

    const response = await apiClient.get(url);
    return response.data;
  }

  async getById(id: string): Promise<Shift> {
    const response = await apiClient.get(
      API_PATHS.SHIFTS_DETAIL.replace(':id', id),
    );
    return response.data;
  }

  async isShiftOpen(): Promise<boolean> {
    const currentShift = await this.getCurrentShift();
    return currentShift !== null && currentShift.status === 'OPEN';
  }

  async getOrdersByShift(shiftId: string): Promise<Order[]> {
    const url = API_PATHS.ORDERS_BY_SHIFT.replace(':shiftId', shiftId);
    const response = await apiClient.get<Order[]>(url);

    return Array.isArray(response.data) ? response.data : [];
  }

  calculateShiftSummary(shift: Shift, orders: Order[]): ShiftSummary {
    const paymentMethodsSummary = new Map<
      string,
      { count: number; total: number }
    >();
    const productsSummary = new Map<
      string,
      { quantity: number; total: number }
    >();

    if (!Array.isArray(orders)) {
      return {
        shift,
        ordersCount: 0,
        totalSales: 0,
        paymentMethodsSummary: [],
        productsSummary: [],
      };
    }

    orders.forEach((order) => {
      const orderTotal =
        typeof order.total === 'number'
          ? order.total
          : typeof order.total === 'string'
            ? parseFloat(order.total)
            : 0;

      let paymentMethod = 'Sin pagar';
      if (order.payments && order.payments.length > 0) {
        paymentMethod = order.payments[0].paymentMethod || 'Efectivo';
      }

      const current = paymentMethodsSummary.get(paymentMethod) || {
        count: 0,
        total: 0,
      };
      paymentMethodsSummary.set(paymentMethod, {
        count: current.count + 1,
        total: current.total + orderTotal,
      });

      order.orderItems?.forEach((item: any) => {
        const productName =
          item.product?.name || item.productName || 'Producto';
        const itemTotal = item.total || item.quantity * item.unitPrice || 0;
        const current = productsSummary.get(productName) || {
          quantity: 0,
          total: 0,
        };
        productsSummary.set(productName, {
          quantity: current.quantity + (item.quantity || 1),
          total: current.total + itemTotal,
        });
      });
    });

    const totalSales = orders.reduce((sum, order) => {
      const orderTotal =
        typeof order.total === 'number'
          ? order.total
          : typeof order.total === 'string'
            ? parseFloat(order.total)
            : 0;
      return sum + orderTotal;
    }, 0);

    return {
      shift,
      ordersCount: orders.length,
      totalSales: totalSales,
      paymentMethodsSummary: Array.from(paymentMethodsSummary.entries()).map(
        ([method, data]) => ({
          method,
          count: data.count,
          total: data.total,
        }),
      ),
      productsSummary: Array.from(productsSummary.entries())
        .map(([productName, data]) => ({
          productName,
          quantity: data.quantity,
          total: data.total,
        }))
        .sort((a, b) => b.total - a.total)
        .slice(0, 10),
    };
  }

  formatOrdersForDetail(orders: Order[]): ShiftOrder[] {
    if (!Array.isArray(orders)) {
      return [];
    }

    return orders.map((order) => {
      const total =
        typeof order.total === 'number'
          ? order.total
          : typeof order.total === 'string'
            ? parseFloat(order.total)
            : 0;

      let paymentMethod = 'Sin pagar';
      if (order.payments && order.payments.length > 0) {
        paymentMethod = order.payments[0].paymentMethod || 'Efectivo';
      }

      return {
        id: order.id,
        orderNumber:
          order.orderNumber || `#${order.shiftOrderNumber || order.id}`,
        total: total,
        status: order.orderStatus || 'COMPLETED',
        paymentMethod: paymentMethod,
        customerName: (order.deliveryInfo as any)?.customerName || null,
        createdAt:
          typeof order.createdAt === 'string'
            ? order.createdAt
            : order.createdAt.toISOString(),
        items:
          order.orderItems?.map((item: any) => ({
            id: item.id || String(Math.random()),
            productName: item.product?.name || item.productName || 'Producto',
            quantity: item.quantity || 1,
            unitPrice: item.unitPrice || 0,
            total: item.total || item.quantity * item.unitPrice || 0,
            modifiers:
              item.productModifiers?.map(
                (mod: any) => mod.modifierName || mod.name,
              ) || [],
          })) || [],
      };
    });
  }
}

export const shiftsService = new ShiftsService();

================
File: app/app.config.js
================
export default {
  expo: {
    name: 'CloudBite',
    slug: 'cloudbite',
    version: '1.0.0',
    orientation: 'default',
    icon: './assets/icon.png',
    userInterfaceStyle: 'automatic',
    splash: {
      image: './assets/splash.png',
      resizeMode: 'cover',
      backgroundColor: '#ffffff',
    },
    web: {
      favicon: './assets/favicon.png',
    },
    assetBundlePatterns: ['**/*'],
    extra: {
      eas: {
        projectId: '556b2536-af8e-4b1c-8013-20f9e876d57e',
      },
    },
    plugins: [
      'expo-speech-recognition',
      'expo-audio',
      [
        'expo-build-properties',
        {
          android: {
            compileSdkVersion: 35,
            targetSdkVersion: 34,
            buildToolsVersion: '35.0.0',
            usesCleartextTraffic:
              process.env.EAS_BUILD_PROFILE !== 'production',
            newArchEnabled: true,
          },
          ios: {
            newArchEnabled: true,
          },
        },
      ],
    ],
    android: {
      permissions: [
        'android.permission.INTERNET',
        'android.permission.ACCESS_NETWORK_STATE',
        'android.permission.ACCESS_WIFI_STATE',
        'android.permission.RECORD_AUDIO',
        'android.permission.MODIFY_AUDIO_SETTINGS',
      ],
      package: 'com.viefmoon.cloudbite',
      icon: './assets/icon.png',
      supportsTablet: true,
      googleServicesFile: process.env.GOOGLE_SERVICES_JSON
        ? './google-services.json'
        : undefined,
      networkSecurityConfig:
        './android/app/src/main/res/xml/network_security_config.xml',
    },
    ios: {
      infoPlist: {
        NSSpeechRecognitionUsageDescription:
          'Allow CloudBite to use speech recognition for voice orders.',
        NSMicrophoneUsageDescription:
          'Allow CloudBite to use the microphone for voice orders.',
      },
      bundleIdentifier: 'com.viefmoon.cloudbite',
      supportsTablet: true,
      icon: './assets/icon.png',
    },
    web: {
      favicon: './assets/favicon.png',
    },
    owner: 'viefmoon',
  },
};

================
File: app/src/app/services/apiClient.ts
================
import axios, {
  type AxiosError,
  type InternalAxiosRequestConfig,
  type AxiosResponse,
} from 'axios';
import EncryptedStorage from '@/app/services/secureStorageService';
import { useAuthStore } from '../store/authStore';
import { ApiError } from '../lib/errors';
import axiosRetry from 'axios-retry';
import { discoveryService } from './discoveryService';
import { useSnackbarStore } from '../store/snackbarStore';
import { API_PATHS } from '../constants/apiPaths';
import { certificateValidator } from './certificateValidator';

const REFRESH_TOKEN_KEY = 'refresh_token';

let isRefreshing = false;
let failedQueue: Array<{
  resolve: (token: string) => void;
  reject: (error: Error) => void;
}> = [];

const processQueue = (error: Error | null, token: string | null = null) => {
  failedQueue.forEach((prom) => {
    if (error) {
      prom.reject(error);
    } else {
      prom.resolve(token!);
    }
  });
  failedQueue = [];
};

async function refreshToken(baseURL: string): Promise<string> {
  try {
    const currentRefreshToken =
      await EncryptedStorage.getItem(REFRESH_TOKEN_KEY);
    if (!currentRefreshToken) {
      throw new Error('No refresh token available.');
    }

    const { data } = await axios.post<{ token: string; refreshToken?: string }>(
      `${baseURL}${API_PATHS.AUTH_REFRESH}`,
      {},
      { headers: { Authorization: `Bearer ${currentRefreshToken}` } },
    );

    const authStore = useAuthStore.getState();
    await authStore.setAccessToken(data.token);
    if (data.refreshToken && data.refreshToken !== currentRefreshToken) {
      await authStore.setRefreshToken(data.refreshToken);
    }

    return data.token;
  } catch (error: any) {
    if (error.response?.status === 401 || error.response?.status === 404) {
      await useAuthStore.getState().logout();
    }
    throw error;
  }
}

// Crear la instancia de Axios sin baseURL inicial
const apiClient = axios.create({
  headers: {
    'Cache-Control': 'no-cache',
    Accept: 'application/json',
    'Content-Type': 'application/json',
  },
  timeout: 5000,
});

// Configurar retry automtico
axiosRetry(apiClient, {
  retries: 1,
  retryDelay: () => 500,
  retryCondition: (error: AxiosError) => {
    if (error.code === 'ECONNABORTED' || error.code === 'ETIMEDOUT') {
      return false;
    }
    return (
      error.code === 'ENOTFOUND' ||
      error.code === 'ECONNREFUSED' ||
      error.code === 'ECONNRESET'
    );
  },
  shouldResetTimeout: false,
});

// Promesa de inicializacin para asegurar que la baseURL se configure antes de las peticiones
const initializationPromise = (async () => {
  try {
    const baseURL = await discoveryService.getApiUrl();
    if (!baseURL) {
      throw new Error('No se pudo obtener la URL del servidor');
    }
    certificateValidator.validateConnection(baseURL);
    apiClient.defaults.baseURL = baseURL;
    apiClient.defaults.httpsAgent =
      certificateValidator.getAxiosSecurityConfig().httpsAgent;
  } catch (error) {
    // Error al inicializar apiClient
  }
})();

// Interceptor de Peticiones
apiClient.interceptors.request.use(
  async (config: InternalAxiosRequestConfig) => {
    // Esperar a que la inicializacin se complete
    await initializationPromise;

    if (!config.baseURL) {
      throw new axios.Cancel('La URL del servidor no est configurada.');
    }

    const accessToken = useAuthStore.getState().accessToken;
    if (accessToken && config.url !== API_PATHS.AUTH_REFRESH) {
      config.headers['Authorization'] = `Bearer ${accessToken}`;
    }

    // Configurar timeouts especficos segn el tipo de operacin
    if (!config.timeout) {
      const timeouts = {
        get: 5000,
        post: config.url?.includes('/files/upload') ? 30000 : 5000,
        put: 5000,
        patch: 5000,
        delete: 5000,
      };

      config.timeout = timeouts[config.method as keyof typeof timeouts] || 5000;
    }

    return config;
  },
  (error: any) => Promise.reject(error),
);

// Interceptor de Respuestas
apiClient.interceptors.response.use(
  (response: AxiosResponse) => response,
  async (error: AxiosError) => {
    const originalRequest = error.config as InternalAxiosRequestConfig & {
      _retry?: boolean;
    };

    // Manejar errores de red sin respuesta del servidor
    if (!error.response) {
      let specificError: Error;
      const showSnackbar = useSnackbarStore.getState().showSnackbar;

      if (error.code === 'ECONNABORTED' || error.code === 'ETIMEDOUT') {
        specificError = new Error('El servidor no responde');
        (specificError as any).code = 'SERVER_TIMEOUT';
      } else if (error.code === 'ECONNREFUSED') {
        specificError = new Error('El servidor est apagado o no accesible');
        (specificError as any).code = 'SERVER_DOWN';
      } else if (
        error.message === 'Network Error' ||
        error.code === 'ENETUNREACH'
      ) {
        specificError = new Error('No se pudo encontrar el servidor CloudBite');
        (specificError as any).code = 'SERVER_NOT_FOUND';
      } else {
        specificError = new Error('Error de conexin de red');
        (specificError as any).code = 'NETWORK_ERROR';
      }

      // Mostrar mensaje de error segn el mtodo HTTP
      const method = originalRequest.method?.toLowerCase();
      let errorMessage = 'Sin conexin al servidor';

      if (method === 'post') {
        errorMessage = 'No se puede guardar sin conexin';
      } else if (method === 'put' || method === 'patch') {
        errorMessage = 'No se puede actualizar sin conexin';
      } else if (method === 'delete') {
        errorMessage = 'No se puede eliminar sin conexin';
      } else if (method === 'get') {
        errorMessage = 'No se pueden cargar los datos sin conexin';
      }

      setTimeout(() => {
        showSnackbar({
          message: errorMessage,
          type: 'error',
          duration: 5000,
        });
      }, 100);

      return Promise.reject(ApiError.fromAxiosError(error));
    }

    // Manejo de errores 401 para renovacin de token
    if (
      error.response?.status === 401 &&
      !originalRequest._retry &&
      originalRequest.url !== API_PATHS.AUTH_REFRESH
    ) {
      if (isRefreshing) {
        return new Promise((resolve, reject) => {
          failedQueue.push({
            resolve: (token) => {
              originalRequest.headers['Authorization'] = `Bearer ${token}`;
              resolve(apiClient(originalRequest));
            },
            reject: (err) => {
              reject(err);
            },
          });
        });
      }

      originalRequest._retry = true;
      isRefreshing = true;

      try {
        const baseURL = apiClient.defaults.baseURL!;
        const newAccessToken = await refreshToken(baseURL);
        processQueue(null, newAccessToken);
        originalRequest.headers['Authorization'] = `Bearer ${newAccessToken}`;
        return apiClient(originalRequest);
      } catch (refreshError: any) {
        processQueue(refreshError, null);
        return Promise.reject(ApiError.fromRefreshError(refreshError));
      } finally {
        isRefreshing = false;
      }
    }

    // Para todos los dems errores, los envolvemos en nuestra clase ApiError
    return Promise.reject(ApiError.fromAxiosError(error));
  },
);

export const reinitializeApiClient = async (url?: string) => {
  const baseURL = url || (await discoveryService.getApiUrl());
  if (baseURL) {
    apiClient.defaults.baseURL = baseURL;
  }
};

export default apiClient;

================
File: app/src/modules/auth/screens/LoginScreen.tsx
================
import React, { useState, useEffect } from 'react';
import {
  Image,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  StyleSheet,
  View,
  ActivityIndicator,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Text, IconButton, Surface, TouchableRipple } from 'react-native-paper';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import EncryptedStorage from '@/app/services/secureStorageService';
import { STORAGE_KEYS } from '@/app/constants/storageKeys';
import { useAppTheme } from '@/app/styles/theme';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { getApiErrorMessage } from '@/app/lib/errorMapping';
import { useThemeStore } from '@/app/store/themeStore';
import { useAuthStore } from '@/app/store/authStore';
import { LoginFormInputs, LoginResponseDto } from '../schema/auth.schema';
import { authService } from '../services/authService';
import LoginForm from '../components/LoginForm';
import { ConnectionIndicator } from '@/app/components/ConnectionIndicator';
import { useResponsive } from '@/app/hooks/useResponsive';
import { ConnectionErrorModal } from '@/app/components/ConnectionErrorModal';
import { RegisterModal } from '../components/RegisterForm';
import { OrientationTransition } from '@/app/components/OrientationTransition';
import * as ScreenOrientation from 'expo-screen-orientation';

const LoginScreen = () => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const queryClient = useQueryClient();
  const { showSnackbar } = useSnackbarStore();
  const { setThemePreference } = useThemeStore();
  const setTokens = useAuthStore((state) => state.setTokens);

  const [initialEmailOrUsername, setInitialEmailOrUsername] = useState<
    string | undefined
  >(undefined);
  const [initialPassword, setInitialPassword] = useState<string | undefined>(
    undefined,
  );
  const [initialRememberMe, setInitialRememberMe] = useState(false);
  const [isLoadingCredentials, setIsLoadingCredentials] = useState(true);
  const [showRegisterModal, setShowRegisterModal] = useState(false);

  type LoginMutationVariables = LoginFormInputs & { rememberMe: boolean };

  const loginMutation = useMutation<
    LoginResponseDto,
    Error,
    LoginMutationVariables
  >({
    mutationFn: (variables) =>
      authService.login({
        emailOrUsername: variables.emailOrUsername,
        password: variables.password,
      }),
    onSuccess: async (data, variables) => {
      try {
        // Verificar si el usuario est activo antes de guardar los tokens
        if (data.user && !data.user.isActive) {
          showSnackbar({
            message: 'Tu cuenta est inactiva. Contacta al administrador.',
            type: 'error',
          });
          return;
        }

        await setTokens(data.token, data.refreshToken, data.user ?? null);
        const { emailOrUsername, password, rememberMe } = variables;

        if (rememberMe) {
          const credentialsToSave = JSON.stringify({
            emailOrUsername,
            password,
          });
          await EncryptedStorage.setItem(
            STORAGE_KEYS.REMEMBERED_CREDENTIALS,
            credentialsToSave,
          );
          await EncryptedStorage.setItem(
            STORAGE_KEYS.REMEMBER_ME_ENABLED,
            'true',
          );
        } else {
          await EncryptedStorage.removeItem(
            STORAGE_KEYS.REMEMBERED_CREDENTIALS,
          );
          await EncryptedStorage.removeItem(STORAGE_KEYS.REMEMBER_ME_ENABLED);
        }

        showSnackbar({
          message: `Bienvenido!`,
          type: 'success',
        });
        queryClient.invalidateQueries({ queryKey: ['user', 'me'] });
      } catch (error: unknown) {
        const errorMessage =
          error instanceof Error ? error.message : 'Error desconocido';
        if (errorMessage === 'Usuario inactivo') {
          showSnackbar({
            message: 'Tu cuenta est inactiva. Contacta al administrador.',
            type: 'error',
          });
        }

        try {
          await EncryptedStorage.removeItem(
            STORAGE_KEYS.REMEMBERED_CREDENTIALS,
          );
          await EncryptedStorage.removeItem(STORAGE_KEYS.REMEMBER_ME_ENABLED);
        } catch (cleanupError) {}

        showSnackbar({
          message: 'Error procesando el inicio de sesin.',
          type: 'error',
        });
      }
    },
    onError: (error: unknown) => {
      const errorMessage = getApiErrorMessage(error);

      if (
        errorMessage.includes('credenciales') ||
        errorMessage.includes('contrasea') ||
        errorMessage.includes('usuario') ||
        (error instanceof Error &&
          'response' in error &&
          (error as any).response?.status === 401)
      ) {
        showSnackbar({
          message: errorMessage,
          type: 'error',
          duration: 5000,
        });
      }
    },
  });

  const handleLoginSubmit = (data: LoginFormInputs, rememberMe: boolean) => {
    loginMutation.mutate({ ...data, rememberMe });
  };

  useEffect(() => {
    const loadCredentials = async () => {
      setIsLoadingCredentials(true);
      try {
        const rememberEnabled = await EncryptedStorage.getItem(
          STORAGE_KEYS.REMEMBER_ME_ENABLED,
        );
        if (rememberEnabled === 'true') {
          const storedCredentialsJson = await EncryptedStorage.getItem(
            STORAGE_KEYS.REMEMBERED_CREDENTIALS,
          );
          if (storedCredentialsJson) {
            const storedCredentials = JSON.parse(storedCredentialsJson);
            setInitialEmailOrUsername(storedCredentials.emailOrUsername);
            setInitialPassword(storedCredentials.password);
            setInitialRememberMe(true);
          } else {
            setInitialRememberMe(false);
            setInitialEmailOrUsername('');
            setInitialPassword('');
            await EncryptedStorage.removeItem(STORAGE_KEYS.REMEMBER_ME_ENABLED);
          }
        } else {
          setInitialRememberMe(false);
          setInitialEmailOrUsername('');
          setInitialPassword('');
        }
      } catch (error) {
        setInitialRememberMe(false);
        setInitialEmailOrUsername('');
        setInitialPassword('');
        try {
          await EncryptedStorage.removeItem(
            STORAGE_KEYS.REMEMBERED_CREDENTIALS,
          );
          await EncryptedStorage.removeItem(STORAGE_KEYS.REMEMBER_ME_ENABLED);
        } catch (cleanupError) {}
      } finally {
        setIsLoadingCredentials(false);
      }
    };

    loadCredentials();
  }, []);

  const toggleTheme = () => {
    setThemePreference(theme.dark ? 'light' : 'dark');
  };

  const handleRegisterSuccess = (username: string, password: string) => {
    setInitialEmailOrUsername(username);
    setInitialPassword(password);
    setInitialRememberMe(false);
  };

  const isWeb = Platform.OS === 'web';
  const isDesktop = isWeb && responsive.width >= 1024;
  const isTablet = isWeb && responsive.width >= 768 && responsive.width < 1024;

  const styles = React.useMemo(
    () =>
      StyleSheet.create({
        safeArea: {
          flex: 1,
          backgroundColor: theme.colors.background,
        },
        scrollView: {
          flexGrow: 1,
        },
        webContainer: {
          flex: 1,
          flexDirection: isDesktop ? 'row' : 'column',
          minHeight: '100%',
          width: '100%',
        },
        webLeftPanel: {
          flex: isDesktop ? 1 : undefined,
          backgroundColor: theme.dark
            ? theme.colors.primaryContainer
            : theme.colors.primary,
          justifyContent: 'center',
          alignItems: 'center',
          padding: responsive.spacingPreset.xl,
          ...(isTablet && {
            paddingVertical: responsive.spacingPreset.xxl,
          }),
        },
        webRightPanel: {
          flex: isDesktop ? 1 : undefined,
          justifyContent: 'center',
          alignItems: 'center',
          padding: responsive.spacingPreset.xl,
          backgroundColor: theme.colors.background,
          minHeight: isDesktop ? '100%' : undefined,
          width: '100%',
        },
        webBrandingContainer: {
          alignItems: 'center',
          marginBottom: responsive.spacingPreset.xl,
        },
        webBrandingLogo: {
          width: isDesktop ? 200 : 150,
          height: isDesktop ? 200 : 150,
          marginBottom: responsive.spacingPreset.l,
          borderRadius: isDesktop ? 100 : 75,
          backgroundColor: theme.colors.surface,
          overflow: 'hidden',
          borderWidth: theme.dark ? 2 : 0,
          borderColor: theme.dark ? theme.colors.outline : 'transparent',
        },
        webBrandingTitle: {
          fontSize: isDesktop ? 48 : 36,
          fontWeight: 'bold',
          color: theme.dark
            ? theme.colors.onPrimaryContainer
            : theme.colors.onPrimary,
          marginBottom: responsive.spacingPreset.m,
          textAlign: 'center',
        },
        webBrandingSubtitle: {
          fontSize: isDesktop ? 20 : 18,
          color: theme.dark
            ? theme.colors.onPrimaryContainer
            : theme.colors.onPrimary,
          opacity: theme.dark ? 0.8 : 0.9,
          textAlign: 'center',
          maxWidth: 400,
          lineHeight: 28,
        },
        webFormWrapper: {
          width: '100%',
          maxWidth: isDesktop ? 450 : 400,
          alignItems: 'center',
        },
        container: {
          flex: 1,
          padding: responsive.spacingPreset.l,
          justifyContent: 'space-between',
        },
        logoContainer: {
          alignItems: 'center',
          marginTop: responsive.spacingPreset.xl,
          marginBottom: responsive.spacingPreset.m,
        },
        logo: {
          width: 160,
          height: 160,
          marginBottom: 16,
          borderRadius: 80,
          backgroundColor: 'transparent',
        },
        title: {
          fontSize: 32,
          fontWeight: 'bold',
          color: theme.colors.primary,
          marginBottom: 8,
          textAlign: 'center',
        },
        subtitle: {
          fontSize: responsive.fontSizePreset.m,
          color: theme.colors.onSurfaceVariant,
          marginBottom: responsive.spacingPreset.xl,
          textAlign: 'center',
          paddingHorizontal: responsive.spacingPreset.l,
        },
        formContainer: {
          backgroundColor: theme.colors.surface,
          borderRadius: 16,
          padding: responsive.spacingPreset.m,
          elevation: 2,
          marginBottom: responsive.spacingPreset.m,
          paddingVertical: responsive.spacingPreset.l,
          ...(isWeb && {
            width: '100%',
            shadowColor: theme.dark
              ? 'rgba(255,255,255,0.1)'
              : 'rgba(0,0,0,0.1)',
            shadowOffset: { width: 0, height: 2 },
            shadowOpacity: 1,
            shadowRadius: 8,
            borderWidth: theme.dark ? 1 : 0,
            borderColor: theme.dark
              ? theme.colors.surfaceVariant
              : 'transparent',
          }),
        },
        registerContainer: {
          flexDirection: 'row',
          justifyContent: 'center',
          alignItems: 'center',
          marginTop: responsive.spacingPreset.xl,
        },
        registerText: {
          color: theme.colors.onSurfaceVariant,
          marginRight: 8,
        },
        registerLink: {
          color: theme.colors.primary,
          fontWeight: 'bold',
        },
        bottomThemeToggleContainer: {
          alignItems: 'center',
          marginTop: 20,
          marginBottom: 16,
        },
        webThemeToggle: {
          position: 'absolute',
          top: responsive.spacingPreset.l,
          right: responsive.spacingPreset.l,
          zIndex: 10,
        },
        loadingContainer: {
          justifyContent: 'center',
          alignItems: 'center',
        },
        webMainContainer: {
          flex: 1,
          minHeight: '100%',
          backgroundColor: theme.colors.background,
        },
        webThemeTogglePosition: {
          position: 'absolute',
          top: 20,
          right: 20,
          zIndex: 10,
        },
        webScrollContainer: {
          flexGrow: 1,
          justifyContent: 'center',
          alignItems: 'center',
          padding: 20,
        },
        webFormContainer: {
          width: '100%',
          maxWidth: 380,
          alignItems: 'center',
        },
        webLogo: {
          width: 200,
          height: 200,
          borderRadius: 100,
          marginBottom: 30,
        },
        webCard: {
          width: '100%',
          backgroundColor: theme.colors.surface,
          borderRadius: 16,
          padding: 24,
          shadowColor: theme.dark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)',
          shadowOffset: { width: 0, height: 4 },
          shadowOpacity: 1,
          shadowRadius: 12,
          elevation: 4,
          borderWidth: theme.dark ? 1 : 0,
          borderColor: theme.dark ? 'rgba(255,255,255,0.1)' : 'transparent',
        },
        webCardTitle: {
          fontSize: 24,
          fontWeight: 'bold',
          color: theme.colors.onSurface,
          marginBottom: 8,
          textAlign: 'center',
        },
        webCardSubtitle: {
          fontSize: 14,
          color: theme.colors.onSurfaceVariant,
          marginBottom: 20,
          textAlign: 'center',
        },
        webRegisterContainer: {
          flexDirection: 'row',
          justifyContent: 'center',
          alignItems: 'center',
          marginTop: 16,
        },
        webRegisterText: {
          color: theme.colors.onSurfaceVariant,
          fontSize: 14,
        },
        webRegisterLink: {
          marginLeft: 5,
        },
        webRegisterLinkText: {
          color: theme.colors.primary,
          fontWeight: 'bold',
          fontSize: 14,
        },
        mobileThemeToggleContainer: {
          position: 'absolute',
          top: -responsive.spacingPreset.s,
          right: -responsive.spacingPreset.s,
          zIndex: 1,
        },
        keyboardContainer: {
          flex: 1,
        },
      }),
    [
      theme,
      isDesktop,
      isTablet,
      isWeb,
      responsive.spacingPreset.xl,
      responsive.spacingPreset.xxl,
      responsive.spacingPreset.m,
      responsive.spacingPreset.l,
      responsive.spacingPreset.s,
      responsive.fontSizePreset.m,
    ],
  );

  if (isLoadingCredentials) {
    return (
      <SafeAreaView style={[styles.safeArea, styles.loadingContainer]}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </SafeAreaView>
    );
  }

  const webContent = (
    <View style={styles.webMainContainer}>
      {/* Theme toggle button */}
      <View style={styles.webThemeTogglePosition}>
        <IconButton
          icon={theme.dark ? 'weather-night' : 'weather-sunny'}
          size={30}
          onPress={toggleTheme}
          iconColor={theme.colors.onSurfaceVariant}
        />
      </View>

      <ScrollView contentContainerStyle={styles.webScrollContainer}>
        <View style={styles.webFormContainer}>
          {/* Logo */}
          <Image
            source={require('../../../../assets/icon.png')}
            style={styles.webLogo}
            resizeMode="cover"
          />

          {/* Login form card */}
          <View style={styles.webCard}>
            <Text style={styles.webCardTitle}>Iniciar Sesin</Text>
            <Text style={styles.webCardSubtitle}>
              Ingresa tus credenciales para continuar
            </Text>

            <LoginForm
              onSubmit={handleLoginSubmit}
              isLoading={loginMutation.isPending}
              initialEmailOrUsername={initialEmailOrUsername}
              initialPassword={initialPassword}
              initialRememberMe={initialRememberMe}
            />

            <View style={styles.webRegisterContainer}>
              <Text style={styles.webRegisterText}>No tienes una cuenta?</Text>
              <TouchableRipple
                onPress={() => setShowRegisterModal(true)}
                style={styles.webRegisterLink}
              >
                <Text style={styles.webRegisterLinkText}>Regstrate</Text>
              </TouchableRipple>
            </View>
          </View>
        </View>
      </ScrollView>
    </View>
  );

  const mobileContent = (
    <SafeAreaView style={styles.safeArea}>
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.keyboardContainer}
      >
        <ScrollView
          contentContainerStyle={styles.scrollView}
          keyboardShouldPersistTaps="handled"
        >
          <View style={styles.container}>
            <View>
              <View style={styles.mobileThemeToggleContainer}>
                <ConnectionIndicator />
              </View>
              <View style={styles.logoContainer}>
                <Image
                  source={require('../../../../assets/icon.png')}
                  style={styles.logo}
                  resizeMode="cover"
                />
                <Text style={styles.title}>Bienvenido!</Text>
                <Text style={styles.subtitle}>
                  Inicia sesin para gestionar tus pedidos
                </Text>
              </View>

              <Surface style={styles.formContainer}>
                <LoginForm
                  onSubmit={handleLoginSubmit}
                  isLoading={loginMutation.isPending}
                  initialEmailOrUsername={initialEmailOrUsername}
                  initialPassword={initialPassword}
                  initialRememberMe={initialRememberMe}
                />
              </Surface>
            </View>

            <View>
              <View style={styles.registerContainer}>
                <Text style={styles.registerText}>No tienes una cuenta?</Text>
                <TouchableRipple onPress={() => setShowRegisterModal(true)}>
                  <Text style={styles.registerLink}>Regstrate</Text>
                </TouchableRipple>
              </View>
              <View style={styles.bottomThemeToggleContainer}>
                <IconButton
                  icon={theme.dark ? 'weather-night' : 'weather-sunny'}
                  size={responsive.dimensions.iconSize.large}
                  onPress={toggleTheme}
                  iconColor={theme.colors.onSurfaceVariant}
                />
              </View>
            </View>
          </View>
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );

  const content = isWeb ? webContent : mobileContent;

  return (
    <>
      <ConnectionErrorModal />
      <RegisterModal
        visible={showRegisterModal}
        onDismiss={() => setShowRegisterModal(false)}
        onRegisterSuccess={handleRegisterSuccess}
      />
      {Platform.OS === 'web' ? (
        content
      ) : (
        <OrientationTransition
          targetOrientation={ScreenOrientation.OrientationLock.PORTRAIT_UP}
        >
          {content}
        </OrientationTransition>
      )}
    </>
  );
};

export default LoginScreen;

================
File: app/src/modules/kitchen/screens/KitchenOrdersScreen.tsx
================
import { useEffect, useRef, useState, useMemo, useCallback } from 'react';
import { View, StyleSheet, ScrollView, Animated, Platform } from 'react-native';
import { Text, ActivityIndicator, Surface } from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import {
  useKitchenOrders,
  useStartOrderPreparation,
  useCancelOrderPreparation,
  useCompleteOrderPreparation,
} from '../hooks/useKitchenOrders';
import { useKitchenStore } from '../store/kitchenStore';
import { OrderCard } from '../components/OrderCard';
import * as ScreenOrientation from 'expo-screen-orientation';
import { MaterialCommunityIcons as Icon } from '@expo/vector-icons';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useKitchenContext } from '../context/KitchenContext';
import { OrderTypeEnum } from '../schema/kitchen.schema';

export default function KitchenOrdersScreen() {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const { filters } = useKitchenStore();
  const pulseAnim = useRef(new Animated.Value(1)).current;
  const [isSwipingCard, setIsSwipingCard] = useState(false);
  const { refetchRef } = useKitchenContext();

  const { data: orders, isLoading, refetch } = useKitchenOrders(filters);
  const startOrderPreparation = useStartOrderPreparation();
  const cancelOrderPreparation = useCancelOrderPreparation();
  const completeOrderPreparation = useCompleteOrderPreparation();

  useEffect(() => {
    refetchRef.current = refetch;
  }, [refetch, refetchRef]);

  const hasOrders = !!orders?.length;

  const styles = useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );

  const cardWidth = useMemo(() => {
    if (responsive.isDesktop) {
      // En desktop, las tarjetas son ms grandes
      return responsive.getResponsiveDimension(340, 380);
    }
    if (responsive.isWeb && responsive.isTablet) {
      // En web tablet, tamao intermedio
      return responsive.getResponsiveDimension(300, 340);
    }
    return responsive.isTablet
      ? responsive.getResponsiveDimension(280, 320)
      : responsive.getResponsiveDimension(240, 280);
  }, [responsive]);

  const handleStartPreparation = useCallback(
    (orderId: string) => {
      startOrderPreparation.mutate(orderId);
    },
    [startOrderPreparation],
  );

  const handleCancelPreparation = useCallback(
    (orderId: string) => {
      cancelOrderPreparation.mutate(orderId);
    },
    [cancelOrderPreparation],
  );

  const handleCompletePreparation = useCallback(
    (orderId: string) => {
      completeOrderPreparation.mutate(orderId);
    },
    [completeOrderPreparation],
  );

  useEffect(() => {
    if (Platform.OS !== 'web') {
      const setLandscape = async () => {
        await ScreenOrientation.lockAsync(
          ScreenOrientation.OrientationLock.LANDSCAPE,
        );
      };
      setLandscape();

      return () => {
        ScreenOrientation.unlockAsync();
      };
    }
  }, []);

  useEffect(() => {
    if (!hasOrders) {
      const animation = Animated.loop(
        Animated.sequence([
          Animated.timing(pulseAnim, {
            toValue: 1.2,
            duration: 1500,
            useNativeDriver: true,
          }),
          Animated.timing(pulseAnim, {
            toValue: 1,
            duration: 1500,
            useNativeDriver: true,
          }),
        ]),
      );
      animation.start();
      return () => animation.stop();
    }
  }, [hasOrders, pulseAnim]);

  const emptyMessage = useMemo(() => {
    const activeFilters = [];

    if (filters.orderType) {
      const typeLabels = {
        [OrderTypeEnum.DINE_IN]: 'Para Mesa',
        [OrderTypeEnum.TAKE_AWAY]: 'Para Llevar',
        [OrderTypeEnum.DELIVERY]: 'Delivery',
      };
      activeFilters.push(`Tipo: ${typeLabels[filters.orderType]}`);
    }

    if (filters.showPrepared) {
      activeFilters.push('Solo rdenes listas');
    }

    if (!filters.showAllProducts && filters.screenId) {
      activeFilters.push('Solo productos de esta pantalla');
    }

    if (activeFilters.length > 0) {
      return {
        title: 'No hay pedidos con los filtros activos',
        subtitle: `Filtros: ${activeFilters.join(', ')}`,
        hint: 'Ajusta los filtros o espera nuevos pedidos',
      };
    }

    return {
      title: 'No hay pedidos pendientes',
      subtitle: 'Los nuevos pedidos aparecern aqu automticamente',
      hint: 'Presiona el botn de recargar para verificar nuevos pedidos',
    };
  }, [filters]);

  const handleSwipeStart = useCallback(() => setIsSwipingCard(true), []);
  const handleSwipeEnd = useCallback(() => {
    setTimeout(() => setIsSwipingCard(false), 100);
  }, []);

  if (isLoading) {
    return (
      <View style={styles.centerContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
        <Text variant="bodyLarge" style={styles.loadingText}>
          Cargando pedidos...
        </Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      {hasOrders ? (
        <ScrollView
          horizontal={!responsive.isWeb || responsive.width < 1200}
          scrollEnabled={!isSwipingCard}
          showsHorizontalScrollIndicator={false}
          pagingEnabled={false}
          contentContainerStyle={[
            styles.horizontalListContainer,
            responsive.isWeb &&
              responsive.width >= 1200 &&
              styles.gridContainer,
          ]}
          snapToInterval={
            responsive.isWeb
              ? undefined
              : cardWidth + responsive.spacingPreset.m
          }
          decelerationRate="fast"
          snapToAlignment={responsive.isWeb ? undefined : 'start'}
        >
          {orders.map((item, index) => (
            <View
              key={item.id}
              style={[
                styles.cardContainer,
                { width: cardWidth },
                index === orders.length - 1
                  ? styles.lastCardContainer
                  : styles.cardContainerWithMargin,
                responsive.isWeb &&
                  responsive.width >= 1200 &&
                  styles.cardContainerWeb,
              ]}
            >
              <OrderCard
                order={item}
                onStartPreparation={handleStartPreparation}
                onCancelPreparation={handleCancelPreparation}
                onCompletePreparation={handleCompletePreparation}
                onSwipeStart={handleSwipeStart}
                onSwipeEnd={handleSwipeEnd}
              />
            </View>
          ))}
        </ScrollView>
      ) : (
        <View style={styles.emptyStateContainer}>
          <Surface style={styles.emptyCard} elevation={4}>
            <Animated.View
              style={[
                styles.emptyIconContainer,
                { transform: [{ scale: pulseAnim }] },
              ]}
            >
              <Icon
                name={
                  filters.orderType ||
                  filters.showPrepared ||
                  !filters.showAllProducts
                    ? 'filter-remove'
                    : 'chef-hat'
                }
                size={
                  responsive.isWeb
                    ? 64
                    : responsive.getResponsiveDimension(32, 40)
                }
                color={theme.colors.primary}
              />
            </Animated.View>
            <Text
              variant="titleMedium"
              style={[styles.emptyText, { color: theme.colors.onSurface }]}
              numberOfLines={2}
              adjustsFontSizeToFit
            >
              {emptyMessage.title}
            </Text>
            <Text
              variant="bodyMedium"
              style={[
                styles.emptySubtext,
                { color: theme.colors.onSurfaceVariant },
              ]}
              numberOfLines={2}
              adjustsFontSizeToFit
            >
              {emptyMessage.subtitle}
            </Text>
            <Text
              variant="bodySmall"
              style={[
                styles.emptyHint,
                { color: theme.colors.onSurfaceVariant },
              ]}
              numberOfLines={2}
              adjustsFontSizeToFit
            >
              {emptyMessage.hint}
            </Text>
          </Surface>
        </View>
      )}
    </View>
  );
}

const createStyles = (theme: any, responsive: any) =>
  StyleSheet.create({
    container: {
      flex: 1,
      position: 'relative',
      backgroundColor: theme.colors.background,
    },
    centerContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      backgroundColor: theme.colors.background,
    },
    horizontalListContainer: {
      paddingLeft: responsive.isWeb
        ? responsive.spacingPreset.m
        : responsive.spacingPreset.xxs,
      paddingRight: responsive.isWeb
        ? responsive.spacingPreset.m
        : responsive.spacingPreset.xs,
      paddingVertical: responsive.isWeb
        ? responsive.spacingPreset.s
        : responsive.spacingPreset.xxs,
      minHeight: '100%',
      alignItems:
        responsive.isWeb && responsive.width >= 1200 ? 'flex-start' : 'center',
    },
    gridContainer: {
      flexDirection: 'row',
      flexWrap: 'wrap',
      justifyContent: 'flex-start',
      alignItems: 'flex-start',
      paddingHorizontal: responsive.spacingPreset.l,
      paddingVertical: responsive.spacingPreset.m,
    },
    emptyStateContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      paddingHorizontal: responsive.spacingPreset.m,
      paddingVertical: responsive.spacingPreset.xs,
      backgroundColor: theme.colors.background,
    },
    emptyCard: {
      paddingHorizontal: responsive.isWeb
        ? responsive.spacingPreset.xl
        : responsive.spacingPreset.m,
      paddingVertical: responsive.isWeb
        ? responsive.spacingPreset.xl
        : responsive.spacingPreset.m,
      borderRadius: theme.roundness * 2,
      alignItems: 'center',
      maxHeight: '70%',
      width: responsive.isWeb
        ? responsive.getResponsiveDimension(400, 480)
        : responsive.getResponsiveDimension(280, 320),
      backgroundColor: theme.colors.surface,
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 2,
      },
      shadowOpacity: 0.1,
      shadowRadius: 4,
      elevation: 3,
    },
    emptyIconContainer: {
      marginBottom: responsive.spacingPreset.s,
      padding: responsive.spacingPreset.s,
      backgroundColor: theme.colors.primaryContainer,
      borderRadius: theme.roundness,
    },
    emptyText: {
      textAlign: 'center',
      marginBottom: responsive.spacingPreset.xs,
      fontWeight: '600',
      fontSize: responsive.fontSizePreset.s,
      paddingHorizontal: responsive.spacingPreset.xs,
      maxWidth: '100%',
      color: theme.colors.onSurface,
    },
    emptySubtext: {
      textAlign: 'center',
      lineHeight: responsive.getResponsiveDimension(16, 18),
      opacity: 0.7,
      marginBottom: responsive.spacingPreset.s,
      fontSize: responsive.fontSizePreset.xs,
      paddingHorizontal: responsive.spacingPreset.xs,
      maxWidth: '100%',
      fontWeight: '400',
      color: theme.colors.onSurfaceVariant,
    },
    emptyHint: {
      textAlign: 'center',
      opacity: 0.5,
      fontStyle: 'italic',
      fontSize: responsive.fontSizePreset.xs - 1,
      paddingHorizontal: responsive.spacingPreset.xs,
      maxWidth: '100%',
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      paddingTop: responsive.spacingPreset.s,
      marginTop: responsive.spacingPreset.xs,
      width: '80%',
      fontWeight: '400',
      color: theme.colors.onSurfaceVariant,
    },
    // Estilos adicionales para eliminar inline styles
    loadingText: {
      marginTop: theme.spacing.m,
      color: theme.colors.onBackground,
    },
    cardContainer: {
      height: '100%',
      paddingVertical: responsive.spacingPreset.xxxs,
    },
    cardContainerWeb: {
      marginRight: responsive.spacingPreset.s,
      marginBottom: responsive.spacingPreset.s,
      height: 'auto',
    },
    lastCardContainer: {
      marginRight: 0,
    },
    cardContainerWithMargin: {
      marginRight: responsive.spacingPreset.xxs,
    },
  });

================
File: app/src/modules/orders/screens/AddProductsToOrderScreen.tsx
================
import React, { useState, useMemo, useRef, useCallback } from 'react';
import { Portal } from 'react-native-paper';
import { useNavigation, useRoute } from '@react-navigation/native';

import { useGetOrderMenu } from '../hooks/useMenuQueries';
import { Product, Category, SubCategory } from '../schema/orders.schema';

import ProductCustomizationModal from '../components/ProductCustomizationModal';
import SimpleProductDescriptionModal from '../components/SimpleProductDescriptionModal';
import { AudioRecorderWidget } from '@/components/AudioRecorderWidget';
import { AudioOrderModal } from '@/components/AudioOrderModal';

import { CategoryGrid } from '../components/order-creation';
import { useOrderNavigation, useAudioOrder } from '../hooks/order-creation';

import { useSnackbarStore } from '@/app/store/snackbarStore';
import type { OrdersStackScreenProps } from '@/app/navigation/types';
import {
  CartItem,
  CartItemModifier,
  useOrderStore,
} from '../stores/useOrderStore';
import type { SelectedPizzaCustomization } from '@/app/schemas/domain/order.schema';

type AddProductsRouteProps = {
  orderId: string;
  orderNumber: number;
  onProductsAdded?: () => void;
};

const AddProductsToOrderScreen = () => {
  const navigation = useNavigation();
  const route =
    useRoute<OrdersStackScreenProps<'AddProductsToOrder'>['route']>();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const cartButtonRef = useRef<{ animate: () => void }>(null);

  const { orderNumber, onProductsAdded } =
    route.params as AddProductsRouteProps;

  // Conectar directamente al store
  const { items: storeItems, addItem: addItemToStore } = useOrderStore();

  // Estado local para productos siendo aadidos en esta sesin
  const [selectedProducts, setSelectedProducts] = useState<CartItem[]>([]);
  const [editingItem, setEditingItem] = useState<CartItem | null>(null);
  const [selectedProductForDescription, setSelectedProductForDescription] =
    useState<Product | null>(null);
  const [isDescriptionModalVisible, setIsDescriptionModalVisible] =
    useState(false);

  const {
    navigationLevel,
    selectedCategoryId,
    selectedSubcategoryId,
    selectedProduct,
    setSelectedProduct,
    handleCategorySelect,
    handleSubCategorySelect,
    handleGoBackInternal,
  } = useOrderNavigation();

  const { data: menu, isLoading } = useGetOrderMenu();

  const productNeedsCustomization = useCallback((product: Product): boolean => {
    if (!product) return false;
    const hasVariants =
      product.hasVariants &&
      product.variants &&
      Array.isArray(product.variants) &&
      product.variants.length > 0;
    const hasModifiers =
      product.modifierGroups &&
      Array.isArray(product.modifierGroups) &&
      product.modifierGroups.length > 0;
    return Boolean(hasVariants || hasModifiers);
  }, []);

  const addItemToSelection = useCallback(
    (
      product: Product,
      quantity: number,
      selectedVariantId?: string,
      selectedModifiers?: CartItemModifier[],
      preparationNotes?: string,
      selectedPizzaCustomizations?: SelectedPizzaCustomization[],
      pizzaExtraCost?: number,
    ) => {
      const selectedVariant = product.variants?.find(
        (v) => v.id === selectedVariantId,
      );
      const variantPrice = selectedVariant?.price ?? product.price ?? 0;
      const modifiersPrice =
        selectedModifiers?.reduce((sum, mod) => sum + (mod.price || 0), 0) || 0;
      const pizzaCost = pizzaExtraCost || 0;
      const unitPrice = variantPrice + modifiersPrice + pizzaCost;

      const existingIndex = selectedProducts.findIndex((item) => {
        if (item.productId !== product.id) return false;
        if (item.variantId !== selectedVariantId) return false;
        if (item.preparationNotes !== preparationNotes) return false;

        const itemModifierIds = item.modifiers
          .map((m) => m.id)
          .sort()
          .join(',');
        const newModifierIds = (selectedModifiers || [])
          .map((m) => m.id)
          .sort()
          .join(',');

        if (itemModifierIds !== newModifierIds) return false;

        const existingCustomizations = item.selectedPizzaCustomizations || [];
        const newCustomizations = selectedPizzaCustomizations || [];

        if (existingCustomizations.length !== newCustomizations.length)
          return false;

        const sortedExistingCustomizations = [...existingCustomizations].sort(
          (a, b) =>
            `${a.pizzaCustomizationId}-${a.half}-${a.action}`.localeCompare(
              `${b.pizzaCustomizationId}-${b.half}-${b.action}`,
            ),
        );
        const sortedNewCustomizations = [...newCustomizations].sort((a, b) =>
          `${a.pizzaCustomizationId}-${a.half}-${a.action}`.localeCompare(
            `${b.pizzaCustomizationId}-${b.half}-${b.action}`,
          ),
        );

        for (let i = 0; i < sortedExistingCustomizations.length; i++) {
          if (
            sortedExistingCustomizations[i].pizzaCustomizationId !==
              sortedNewCustomizations[i].pizzaCustomizationId ||
            sortedExistingCustomizations[i].half !==
              sortedNewCustomizations[i].half ||
            sortedExistingCustomizations[i].action !==
              sortedNewCustomizations[i].action
          ) {
            return false;
          }
        }

        return true;
      });

      if (existingIndex !== -1) {
        setSelectedProducts((prev) => {
          const updated = [...prev];
          const existingItem = updated[existingIndex];
          const newQuantity = existingItem.quantity + quantity;

          const modifiersTotal = existingItem.modifiers.reduce(
            (sum, mod) => sum + Number(mod.price || 0),
            0,
          );
          const pizzaCostTotal = existingItem.pizzaExtraCost || 0;
          const unitPriceWithModifiers =
            Number(existingItem.unitPrice || 0) +
            modifiersTotal +
            pizzaCostTotal;

          updated[existingIndex] = {
            ...existingItem,
            quantity: newQuantity,
            totalPrice: unitPriceWithModifiers * newQuantity,
          };
          return updated;
        });
      } else {
        const newItem: CartItem = {
          id: `temp-${Date.now()}-${Math.floor(Math.random() * 1000000)}`,
          productId: product.id,
          productName: product.name,
          quantity,
          unitPrice: variantPrice,
          totalPrice: unitPrice * quantity,
          modifiers: selectedModifiers || [],
          variantId: selectedVariantId,
          variantName: selectedVariant?.name,
          preparationNotes,
          selectedPizzaCustomizations,
          pizzaExtraCost,
        };

        setSelectedProducts((prev) => [...prev, newItem]);
      }

      cartButtonRef.current?.animate();

      showSnackbar({
        message: `${product.name} aadido`,
        type: 'success',
      });
    },
    [selectedProducts, showSnackbar],
  );

  const {
    showAudioModal,
    audioOrderData,
    isProcessingAudio,
    audioError,
    handleAudioRecordingComplete,
    handleAudioError,
    handleConfirmAudioOrder: handleConfirmAudioOrderBase,
    setShowAudioModal,
    setAudioOrderData,
    setAudioError,
  } = useAudioOrder({
    menu,
    handleAddItem: addItemToSelection,
    cartButtonRef,
  });

  const handleConfirmAudioOrder = useCallback(
    async (
      items: any[],
      _deliveryInfo?: any,
      _scheduledDelivery?: any,
      _orderType?: any,
    ) => {
      await handleConfirmAudioOrderBase(items);
    },
    [handleConfirmAudioOrderBase],
  );

  const totalItemsCount = useMemo(() => {
    const storeItemsCount = storeItems.reduce(
      (sum, item) => sum + item.quantity,
      0,
    );
    const newItemsCount = selectedProducts.reduce(
      (sum, item) => sum + item.quantity,
      0,
    );
    return storeItemsCount + newItemsCount;
  }, [storeItems, selectedProducts]);

  const handleProductSelect = useCallback(
    (product: Product) => {
      if (productNeedsCustomization(product)) {
        setSelectedProduct(product);
      } else {
        addItemToSelection(product, 1);
      }
    },
    [productNeedsCustomization, addItemToSelection, setSelectedProduct],
  );

  const handleCloseProductModal = useCallback(() => {
    setSelectedProduct(null);
    setEditingItem(null);
  }, [setSelectedProduct]);

  const handleConfirmSelection = () => {
    // Agregar todos los productos seleccionados al store
    selectedProducts.forEach((item) => {
      const product = {
        id: item.productId,
        name: item.productName,
        price: item.unitPrice,
      };
      addItemToStore(
        product as any,
        item.quantity,
        item.variantId,
        item.modifiers,
        item.preparationNotes,
        item.selectedPizzaCustomizations,
        item.pizzaExtraCost,
      );
    });

    // Notificar que se complet
    if (onProductsAdded) {
      onProductsAdded();
    }
    navigation.goBack();
  };

  const handleBack = () => {
    if (selectedProduct) {
      setSelectedProduct(null);
    } else if (navigationLevel === 'products') {
      handleGoBackInternal();
    } else if (navigationLevel === 'subcategories') {
      handleGoBackInternal();
    } else {
      // Si hay productos seleccionados, preguntar antes de salir
      if (selectedProducts.length > 0) {
        // Por ahora, simplemente salir sin guardar
        navigation.goBack();
      } else {
        navigation.goBack();
      }
    }
  };

  const selectedCategory = useMemo(
    () =>
      menu && Array.isArray(menu)
        ? menu.find((cat: Category) => cat.id === selectedCategoryId)
        : null,
    [menu, selectedCategoryId],
  );

  const selectedSubCategory = useMemo(
    () =>
      selectedCategory && Array.isArray(selectedCategory.subcategories)
        ? selectedCategory.subcategories.find(
            (sub: SubCategory) => sub.id === selectedSubcategoryId,
          )
        : null,
    [selectedCategory, selectedSubcategoryId],
  );

  const getItemsToDisplay = useCallback(() => {
    switch (navigationLevel) {
      case 'categories':
        return menu && Array.isArray(menu) ? menu : [];
      case 'subcategories':
        return selectedCategory?.subcategories || [];
      case 'products':
        return selectedSubCategory?.products || [];
      default:
        return [];
    }
  }, [navigationLevel, menu, selectedCategory, selectedSubCategory]);

  const getNavTitle = useCallback(() => {
    if (selectedProduct) {
      return selectedProduct.name;
    }
    switch (navigationLevel) {
      case 'categories':
        return `Aadir a Orden #${orderNumber}`;
      case 'subcategories':
        return selectedCategory?.name || 'Subcategoras';
      case 'products':
        return selectedSubCategory?.name || 'Productos';
      default:
        return 'Categoras';
    }
  }, [
    navigationLevel,
    selectedCategory,
    selectedSubCategory,
    selectedProduct,
    orderNumber,
  ]);

  const handleItemSelect = useCallback(
    (item: Category | SubCategory | Product) => {
      if (navigationLevel === 'categories') {
        handleCategorySelect(item.id);
      } else if (navigationLevel === 'subcategories') {
        handleSubCategorySelect(item.id);
      } else if ('price' in item) {
        handleProductSelect(item as Product);
      }
    },
    [
      navigationLevel,
      handleCategorySelect,
      handleSubCategorySelect,
      handleProductSelect,
    ],
  );

  const handleShowProductDescription = useCallback((product: Product) => {
    setSelectedProductForDescription(product);
    setIsDescriptionModalVisible(true);
  }, []);

  const handleCloseDescriptionModal = useCallback(() => {
    setIsDescriptionModalVisible(false);
    setSelectedProductForDescription(null);
  }, []);

  const updateItemInSelection = useCallback(
    (
      itemId: string,
      quantity: number,
      modifiers: CartItemModifier[],
      preparationNotes?: string,
      variantId?: string,
      variantName?: string,
      unitPrice?: number,
      selectedPizzaCustomizations?: SelectedPizzaCustomization[],
      pizzaExtraCost?: number,
    ) => {
      setSelectedProducts((prev) =>
        prev.map((item) => {
          if (item.id === itemId) {
            const modifiersPrice = modifiers.reduce(
              (sum, mod) => sum + Number(mod.price || 0),
              0,
            );
            const pizzaCost = pizzaExtraCost || 0;
            const finalUnitPrice =
              unitPrice !== undefined ? unitPrice : item.unitPrice;
            const newTotalPrice =
              (finalUnitPrice + modifiersPrice + pizzaCost) * quantity;

            return {
              ...item,
              quantity,
              modifiers,
              preparationNotes:
                preparationNotes !== undefined
                  ? preparationNotes
                  : item.preparationNotes,
              variantId: variantId !== undefined ? variantId : item.variantId,
              variantName:
                variantName !== undefined ? variantName : item.variantName,
              unitPrice: finalUnitPrice,
              totalPrice: newTotalPrice,
              selectedPizzaCustomizations:
                selectedPizzaCustomizations !== undefined
                  ? selectedPizzaCustomizations
                  : item.selectedPizzaCustomizations,
              pizzaExtraCost,
            };
          }
          return item;
        }),
      );
    },
    [],
  );

  const handleAddToCart = useCallback(
    (
      product: Product,
      quantity: number,
      selectedVariantId?: string,
      selectedModifiers?: CartItemModifier[],
      preparationNotes?: string,
      selectedPizzaCustomizations?: SelectedPizzaCustomization[],
      pizzaExtraCost?: number,
    ) => {
      if (editingItem) {
        updateItemInSelection(
          editingItem.id,
          quantity,
          selectedModifiers || [],
          preparationNotes,
          selectedVariantId,
          product.variants?.find((v) => v.id === selectedVariantId)?.name,
          selectedVariantId
            ? product.variants?.find((v) => v.id === selectedVariantId)?.price ?? 0
            : product.price ?? 0,
          selectedPizzaCustomizations,
          pizzaExtraCost,
        );
        setEditingItem(null);
      } else {
        addItemToSelection(
          product,
          quantity,
          selectedVariantId,
          selectedModifiers,
          preparationNotes,
          selectedPizzaCustomizations,
          pizzaExtraCost,
        );
      }
      setSelectedProduct(null);
    },
    [
      editingItem,
      addItemToSelection,
      updateItemInSelection,
      setSelectedProduct,
    ],
  );

  const itemsToDisplay = getItemsToDisplay();
  const showCartButton = !selectedProduct;

  return (
    <>
      <CategoryGrid
        isLoading={isLoading}
        navigationLevel={navigationLevel}
        items={itemsToDisplay}
        title={getNavTitle()}
        onItemSelect={handleItemSelect}
        onBack={handleBack}
        onProductInfo={handleShowProductDescription}
        showCartButton={showCartButton}
        cartButtonRef={cartButtonRef}
        totalItemsCount={totalItemsCount}
        onViewCart={handleConfirmSelection}
        cartItems={selectedProducts}
        categories={menu}
        selectedCategoryId={selectedCategoryId}
        onCategoryQuickSelect={handleCategorySelect}
      />

      <Portal>
        {selectedProduct && (
          <ProductCustomizationModal
            visible={true}
            product={selectedProduct}
            editingItem={editingItem}
            onDismiss={handleCloseProductModal}
            onAddToCart={handleAddToCart}
            onUpdateItem={(
              itemId,
              quantity,
              modifiers,
              notes,
              variantId,
              variantName,
              unitPrice,
              selectedPizzaCustomizations,
              pizzaExtraCost,
            ) => {
              updateItemInSelection(
                itemId,
                quantity,
                modifiers,
                notes,
                variantId,
                variantName,
                unitPrice,
                selectedPizzaCustomizations,
                pizzaExtraCost,
              );
              setEditingItem(null);
              setSelectedProduct(null);
            }}
          />
        )}

        {selectedProductForDescription && (
          <SimpleProductDescriptionModal
            visible={isDescriptionModalVisible}
            product={selectedProductForDescription}
            onDismiss={handleCloseDescriptionModal}
          />
        )}

        <AudioOrderModal
          visible={showAudioModal}
          onDismiss={() => {
            setShowAudioModal(false);
            setAudioOrderData(null);
            setAudioError(undefined);
          }}
          onConfirm={handleConfirmAudioOrder}
          isProcessing={isProcessingAudio}
          orderData={audioOrderData}
          error={audioError}
        />
      </Portal>

      {!selectedProduct && (
        <AudioRecorderWidget
          onRecordingComplete={handleAudioRecordingComplete}
          onError={handleAudioError}
        />
      )}
    </>
  );
};

export default AddProductsToOrderScreen;

================
File: app/src/modules/orders/screens/CreateOrderScreen.tsx
================
import React, { useMemo, useCallback } from 'react';
import { StyleSheet, View } from 'react-native';
import { Portal, Appbar } from 'react-native-paper';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useNavigation } from '@react-navigation/native';

import { useGetOrderMenu } from '../hooks/useMenuQueries';
import { useGlobalShift } from '@/app/hooks/useGlobalShift';
import {
  useOrderStore,
  useIsOrderEmpty,
  useOrderItemsCount,
} from '../stores/useOrderStore';
import { useAuthStore } from '@/app/store/authStore';

import { Product, Category, SubCategory } from '../schema/orders.schema';
import OrderCartDetail from '../components/OrderCartDetail';
import ProductCustomizationModal from '../components/ProductCustomizationModal';
import SimpleProductDescriptionModal from '../components/SimpleProductDescriptionModal';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
import { AudioRecorderWidget } from '@/components/AudioRecorderWidget';
import { AudioOrderModal } from '@/components/AudioOrderModal';

import { ShiftClosedView, CategoryGrid } from '../components/order-creation';
import {
  useOrderNavigation,
  useProductSelection,
  useAudioOrder,
  useOrderCreation,
} from '../hooks/order-creation';

import { canOpenShift } from '@/app/utils/roleUtils';
import { useAppTheme } from '@/app/styles/theme';

const CreateOrderScreen = () => {
  const theme = useAppTheme();
  const navigation = useNavigation();

  const {
    addItem: originalAddItem,
    updateItem,
    isCartVisible,
    showCart,
    hideCart,
    setOrderType,
    setDeliveryInfo,
    resetOrder,
  } = useOrderStore();

  const isCartEmpty = useIsOrderEmpty();
  const totalItemsCount = useOrderItemsCount();

  const user = useAuthStore((state) => state.user);
  const { data: shift, isLoading: shiftLoading } = useGlobalShift();
  const userCanOpenShift = canOpenShift(user);

  const { data: menu, isLoading } = useGetOrderMenu();

  const {
    navigationLevel,
    selectedCategoryId,
    selectedSubcategoryId,
    selectedProduct,
    setSelectedProduct,
    handleCategorySelect,
    handleSubCategorySelect,
    handleGoBackInternal,
  } = useOrderNavigation();

  const {
    editingItem,
    selectedProductForDescription,
    isDescriptionModalVisible,
    cartButtonRef,
    productNeedsCustomization,
    handleAddItem,
    handleProductSelect: handleProductSelectBase,
    handleCloseProductModal: handleCloseProductModalBase,
    handleEditItem: handleEditItemBase,
    handleShowProductDescription,
    handleCloseDescriptionModal,
  } = useProductSelection({
    menu,
    showCart,
    hideCart,
    isCartEmpty,
    addItem: originalAddItem,
    updateItem,
  });

  const {
    showAudioModal,
    audioOrderData,
    isProcessingAudio,
    audioError,
    handleAudioRecordingComplete,
    handleAudioError,
    handleConfirmAudioOrder,
    setShowAudioModal,
    setAudioOrderData,
    setAudioError,
  } = useAudioOrder({
    menu,
    handleAddItem,
    setDeliveryInfo,
    setOrderType,
    cartButtonRef,
  });

  const {
    showExitConfirmationModal,
    handleConfirmOrder,
    handleAttemptExit,
    handleConfirmExit,
    handleCancelExit,
  } = useOrderCreation({
    hideCart,
    resetOrder,
    isCartEmpty,
  });

  const handleProductSelect = useCallback(
    (product: Product) => {
      handleProductSelectBase(product, setSelectedProduct);
    },
    [handleProductSelectBase, setSelectedProduct],
  );

  const handleCloseProductModal = useCallback(() => {
    handleCloseProductModalBase(setSelectedProduct);
  }, [handleCloseProductModalBase, setSelectedProduct]);

  const handleEditItem = useCallback(
    (item: any) => {
      handleEditItemBase(item, setSelectedProduct);
    },
    [handleEditItemBase, setSelectedProduct],
  );

  const handleViewCart = useCallback(() => {
    showCart();
  }, [showCart]);

  const handleCloseCart = useCallback(() => {
    hideCart();
  }, [hideCart]);

  const selectedCategory = useMemo(
    () =>
      menu && Array.isArray(menu)
        ? menu.find((cat: Category) => cat.id === selectedCategoryId)
        : null,
    [menu, selectedCategoryId],
  );

  const selectedSubCategory = useMemo(
    () =>
      selectedCategory && Array.isArray(selectedCategory.subcategories)
        ? selectedCategory.subcategories.find(
            (sub: SubCategory) => sub.id === selectedSubcategoryId,
          )
        : null,
    [selectedCategory, selectedSubcategoryId],
  );

  const getItemsToDisplay = useCallback(() => {
    switch (navigationLevel) {
      case 'categories':
        return menu && Array.isArray(menu) ? menu : [];
      case 'subcategories':
        return selectedCategory?.subcategories || [];
      case 'products':
        return selectedSubCategory?.products || [];
      default:
        return [];
    }
  }, [navigationLevel, menu, selectedCategory, selectedSubCategory]);

  const getNavTitle = useCallback(() => {
    if (selectedProduct) {
      return selectedProduct.name;
    }
    switch (navigationLevel) {
      case 'categories':
        return 'Categoras';
      case 'subcategories':
        return selectedCategory?.name
          ? `Categora: ${selectedCategory.name}`
          : 'Subcategoras';
      case 'products':
        return selectedSubCategory?.name
          ? `Subcategora: ${selectedSubCategory.name}`
          : 'Productos';
      default:
        return 'Categoras';
    }
  }, [navigationLevel, selectedCategory, selectedSubCategory, selectedProduct]);

  const handleItemSelect = useCallback(
    (item: Category | SubCategory | Product) => {
      if (navigationLevel === 'categories') {
        handleCategorySelect(item.id);
      } else if (navigationLevel === 'subcategories') {
        handleSubCategorySelect(item.id);
      } else if ('price' in item) {
        handleProductSelect(item as Product);
      }
    },
    [
      navigationLevel,
      handleCategorySelect,
      handleSubCategorySelect,
      handleProductSelect,
    ],
  );

  const backAction = useMemo(
    () =>
      selectedProduct
        ? handleCloseProductModal
        : navigationLevel === 'categories'
          ? () => handleAttemptExit(() => navigation.goBack())
          : handleGoBackInternal,
    [
      selectedProduct,
      navigationLevel,
      handleCloseProductModal,
      handleAttemptExit,
      handleGoBackInternal,
      navigation,
    ],
  );

  const styles = useMemo(
    () =>
      StyleSheet.create({
        safeArea: {
          flex: 1,
          backgroundColor: theme.colors.background,
        },
        appBar: {
          backgroundColor: theme.colors.elevation.level2,
          alignItems: 'center',
        },
        appBarTitle: {
          ...theme.fonts.titleMedium,
          color: theme.colors.onSurface,
          fontWeight: 'bold',
          textAlign: 'center',
        },
        appBarContent: {},
        spacer: {
          width: 48,
        },
      }),
    [theme],
  );

  if (isCartVisible) {
    return (
      <SafeAreaView style={styles.safeArea} edges={['left', 'right', 'bottom']}>
        <Appbar.Header style={styles.appBar}>
          <Appbar.BackAction onPress={handleCloseCart} />
          <Appbar.Content
            title="Carrito de Compras"
            titleStyle={styles.appBarTitle}
            style={styles.appBarContent}
          />
          <View style={styles.spacer} />
        </Appbar.Header>
        <OrderCartDetail
          visible={isCartVisible}
          onClose={handleCloseCart}
          onConfirmOrder={handleConfirmOrder}
          onEditItem={handleEditItem}
          isEditMode={false}
        />
      </SafeAreaView>
    );
  }

  if (!shiftLoading && (!shift || shift.status !== 'OPEN')) {
    return (
      <ShiftClosedView
        onBack={() => navigation.goBack()}
        userCanOpenShift={userCanOpenShift}
      />
    );
  }

  const itemsToDisplay = getItemsToDisplay();
  const showCartButton = !isCartVisible && !selectedProduct;

  return (
    <>
      <CategoryGrid
        isLoading={isLoading}
        navigationLevel={navigationLevel}
        items={itemsToDisplay}
        title={getNavTitle()}
        onItemSelect={handleItemSelect}
        onBack={backAction}
        onProductInfo={handleShowProductDescription}
        showCartButton={showCartButton}
        cartButtonRef={cartButtonRef}
        totalItemsCount={totalItemsCount}
        onViewCart={handleViewCart}
        categories={menu}
        selectedCategoryId={selectedCategoryId}
        onCategoryQuickSelect={handleCategorySelect}
      />

      <ConfirmationModal
        visible={showExitConfirmationModal}
        title="Descartar Orden?"
        message="Tienes artculos en el carrito. Si sales, se perdern. Ests seguro?"
        confirmText="Salir y Descartar"
        cancelText="Cancelar"
        onConfirm={handleConfirmExit}
        onCancel={handleCancelExit}
      />

      <Portal>
        {selectedProduct && productNeedsCustomization(selectedProduct) && (
          <ProductCustomizationModal
            visible={true}
            product={selectedProduct}
            editingItem={editingItem}
            onAddToCart={handleAddItem}
            onUpdateItem={updateItem}
            onDismiss={handleCloseProductModal}
          />
        )}

        <SimpleProductDescriptionModal
          visible={isDescriptionModalVisible}
          product={selectedProductForDescription}
          onDismiss={handleCloseDescriptionModal}
        />

        <AudioOrderModal
          visible={showAudioModal}
          onDismiss={() => {
            setShowAudioModal(false);
            setAudioOrderData(null);
            setAudioError(undefined);
          }}
          onConfirm={handleConfirmAudioOrder}
          isProcessing={isProcessingAudio}
          orderData={audioOrderData}
          error={audioError}
        />
      </Portal>

      {!isCartVisible && !selectedProduct && (
        <AudioRecorderWidget
          onRecordingComplete={handleAudioRecordingComplete}
          onError={handleAudioError}
        />
      )}
    </>
  );
};

export default CreateOrderScreen;

================
File: app/src/modules/shiftAudit/components/ShiftOrdersModal.tsx
================
import React, { useState, useMemo } from 'react';
import {
  Modal,
  View,
  StyleSheet,
  RefreshControl,
  FlatList,
} from 'react-native';
import {
  Portal,
  Appbar,
  Searchbar,
  ActivityIndicator,
} from 'react-native-paper';
import OrderSummaryCard from '@/modules/shared/components/OrderSummaryCard';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useShiftOrders } from '../hooks/useShiftOrders';
import EmptyState from '@/app/components/common/EmptyState';
import type { Order } from '@/app/schemas/domain/order.schema';
import { receiptService } from '@/modules/receipts/services/receiptService';
import type { Receipt } from '@/modules/receipts/schema/receipt.schema';
import { OrderDetailsView } from './OrderDetailsView';
import { OrderHistoryView } from './OrderHistoryView';

interface ShiftOrdersModalProps {
  visible: boolean;
  onClose: () => void;
  shiftId: string;
}

export function ShiftOrdersModal({
  visible,
  onClose,
  shiftId,
}: ShiftOrdersModalProps) {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);

  const [searchQuery, setSearchQuery] = useState('');
  const [selectedReceipt, setSelectedReceipt] = useState<Receipt | null>(null);
  const [showReceiptDetails, setShowReceiptDetails] = useState(false);
  const [showOrderHistory, setShowOrderHistory] = useState(false);
  const [isRefreshing, setIsRefreshing] = useState(false);

  const {
    data: orders,
    isLoading,
    error,
    refetch,
    isRefetching,
  } = useShiftOrders(shiftId);

  const handleRefresh = async () => {
    setIsRefreshing(true);
    await refetch();
    setIsRefreshing(false);
  };

  const handleReceiptPress = async (order: Order) => {
    try {
      const fullOrder = await receiptService.getReceiptById(order.id);
      setSelectedReceipt(fullOrder);
      setShowReceiptDetails(true);
    } catch (error) {
      // Error al cargar detalles del recibo
    }
  };

  // Filtrar rdenes basado en bsqueda
  const filteredOrders = useMemo(() => {
    if (!orders) return [];
    if (!searchQuery.trim()) return orders;

    const search = searchQuery.toLowerCase().trim();
    return orders.filter((order) => {
      // Buscar por nmero de orden
      if (order.shiftOrderNumber?.toString().includes(search)) return true;
      if (order.orderNumber?.includes(search)) return true;

      // Buscar en informacin de entrega
      if (order.deliveryInfo) {
        // Campos alternativos que pueden venir del backend
        if (order.deliveryInfo.recipientName?.toLowerCase().includes(search))
          return true;
        if (order.deliveryInfo.recipientPhone?.includes(search)) return true;
        if (order.deliveryInfo.fullAddress?.toLowerCase().includes(search))
          return true;

        // Campos adicionales de direccin
        if (order.deliveryInfo.street?.toLowerCase().includes(search))
          return true;
        if (order.deliveryInfo.neighborhood?.toLowerCase().includes(search))
          return true;
        if (order.deliveryInfo.city?.toLowerCase().includes(search))
          return true;
      }

      // Buscar en mesa/rea para rdenes locales
      if (order.table) {
        if (order.table.name?.toLowerCase().includes(search)) return true;
        if (order.table.area?.name?.toLowerCase().includes(search)) return true;
      }

      // Buscar en notas
      if (order.notes?.toLowerCase().includes(search)) return true;

      // Buscar en user (campo alternativo)
      if (order.user) {
        if (order.user.firstName?.toLowerCase().includes(search)) return true;
        if (order.user.lastName?.toLowerCase().includes(search)) return true;
      }

      return false;
    });
  }, [orders, searchQuery]);

  // Funcin especfica para el color de estado en recibos
  const getReceiptStatusColor = (status: string) => {
    switch (status) {
      case 'COMPLETED':
        return theme.colors.primary;
      case 'CANCELLED':
        return theme.colors.error;
      case 'DELIVERED':
        return '#9333EA'; // Morado
      default:
        return theme.colors.onSurfaceDisabled;
    }
  };

  const getStatusLabel = (status: string) => {
    switch (status) {
      case 'COMPLETED':
        return 'Completada';
      case 'CANCELLED':
        return 'Cancelada';
      case 'DELIVERED':
        return 'Entregada';
      default:
        return status;
    }
  };

  // Renderizar item de recibo usando el componente compartido
  const renderReceiptItem = ({ item }: { item: Order }) => {
    // Convertir Order a OrderItemType para compatibilidad
    const orderItem = {
      id: item.id,
      shiftOrderNumber: item.shiftOrderNumber,
      orderNumber: item.orderNumber,
      orderType: item.orderType as any,
      orderStatus: item.orderStatus as string,
      createdAt: item.createdAt,
      total: item.total,
      table: item.table as any,
      deliveryInfo: item.deliveryInfo as any,
      notes: item.notes || undefined,
      payments: item.payments as any,
      isFromWhatsApp: item.isFromWhatsApp,
    };

    return (
      <OrderSummaryCard
        item={orderItem}
        onPress={() => handleReceiptPress(item)}
        getStatusColor={getReceiptStatusColor}
        getStatusLabel={getStatusLabel}
      />
    );
  };

  // Renderizar lista vaca
  const renderEmptyComponent = () => {
    if (isLoading) {
      return (
        <View style={styles.centerContainer}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
        </View>
      );
    }

    return (
      <EmptyState
        icon="receipt"
        title="No hay rdenes"
        message={
          searchQuery
            ? 'No se encontraron rdenes con los criterios de bsqueda'
            : 'Este turno no tiene rdenes registradas'
        }
      />
    );
  };

  return (
    <Portal>
      <Modal
        visible={visible}
        onRequestClose={onClose}
        animationType="slide"
        presentationStyle="formSheet"
      >
        <View style={styles.container}>
          {showOrderHistory && selectedReceipt ? (
            <OrderHistoryView
              orderId={String(selectedReceipt.id)}
              orderNumber={Number(selectedReceipt.shiftOrderNumber) || 0}
              onBack={() => {
                setShowOrderHistory(false);
                setShowReceiptDetails(true);
              }}
            />
          ) : showReceiptDetails && selectedReceipt ? (
            <OrderDetailsView
              order={selectedReceipt}
              onBack={() => {
                setShowReceiptDetails(false);
                setSelectedReceipt(null);
              }}
              onShowHistory={() => {
                setShowReceiptDetails(false);
                setShowOrderHistory(true);
              }}
            />
          ) : (
            <>
              <Appbar.Header style={styles.header}>
                <Appbar.BackAction onPress={onClose} />
                <Appbar.Content title="rdenes del Turno" />
                <Appbar.Action
                  icon="refresh"
                  onPress={handleRefresh}
                  disabled={isLoading || isRefreshing}
                />
              </Appbar.Header>

              {/* Bsqueda */}
              <View style={styles.searchContainer}>
                <Searchbar
                  placeholder="Buscar por nombre, telfono o direccin..."
                  onChangeText={setSearchQuery}
                  value={searchQuery}
                  style={styles.searchbar}
                  elevation={0}
                />
              </View>

              {/* Lista de rdenes */}
              {error ? (
                <EmptyState
                  icon="alert-circle"
                  title="Error al cargar"
                  message={error.message || 'No se pudieron cargar las rdenes'}
                  actionLabel="Reintentar"
                  onAction={refetch}
                />
              ) : (
                <FlatList
                  data={filteredOrders}
                  renderItem={renderReceiptItem}
                  keyExtractor={(item) => item.id}
                  contentContainerStyle={styles.listContent}
                  refreshControl={
                    <RefreshControl
                      refreshing={isRefetching}
                      onRefresh={refetch}
                      colors={[theme.colors.primary]}
                    />
                  }
                  ListEmptyComponent={renderEmptyComponent}
                />
              )}
            </>
          )}
        </View>
      </Modal>
    </Portal>
  );
}

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    header: {
      backgroundColor: theme.colors.surface,
      elevation: 2,
    },
    searchContainer: {
      paddingHorizontal: 16,
      paddingVertical: 12,
      backgroundColor: theme.colors.surface,
    },
    searchbar: {
      backgroundColor: theme.colors.background,
      elevation: 0,
    },
    listContent: {
      padding: theme.spacing.s,
      paddingBottom: theme.spacing.l * 2,
    },
    orderCard: {
      marginBottom: 8,
    },
    cardContent: {
      paddingBottom: 8,
    },
    mainContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
    },
    leftContainer: {
      flex: 1,
      paddingRight: 12,
      flexShrink: 1,
    },
    rightContainer: {
      alignItems: 'flex-end',
      justifyContent: 'space-between',
      minWidth: 120,
      gap: 8,
      flexShrink: 0,
    },
    orderNumber: {
      fontSize: 16,
      fontWeight: 'bold',
      lineHeight: 22,
      marginBottom: 4,
    },
    orderPrice: {
      fontSize: 15,
      fontWeight: '700',
    },
    orderTime: {
      fontSize: 16,
      fontWeight: '600',
    },
    timeAndPaymentRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 0,
    },
    statusChip: {
      minHeight: 24,
      alignSelf: 'flex-end',
      paddingVertical: 2,
    },
    statusChipText: {
      fontSize: 12,
      fontWeight: '600',
      color: 'white',
      lineHeight: 14,
      marginVertical: 0,
      paddingVertical: 0,
    },
    notesInline: {
      fontSize: 12,
      fontStyle: 'italic',
    },
    inlinePreparationBadge: {
      paddingHorizontal: 6,
      paddingVertical: 2,
      borderRadius: 10,
      borderWidth: 0.5,
    },
    inlinePreparationText: {
      fontSize: 10,
      fontWeight: '500',
    },
    centerContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: 32,
    },
    miniPaymentBadge: {
      width: 20,
      height: 20,
      borderRadius: 10,
      alignItems: 'center',
      justifyContent: 'center',
      marginLeft: 6,
    },
    miniPaymentText: {
      fontSize: 10,
      fontWeight: 'bold',
      color: '#FFFFFF',
    },
    createdByText: {
      fontSize: 10,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 4,
      textAlign: 'right',
    },
  });

================
File: app/src/modules/users/components/UserFormModal.tsx
================
import { useEffect, useState } from 'react';
import { View, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';
import {
  Portal,
  Modal,
  Text,
  TextInput,
  Button,
  Switch,
  HelperText,
  Surface,
  IconButton,
  Chip,
  Avatar,
  Divider,
  Icon,
} from 'react-native-paper';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { z } from 'zod';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useCreateUser, useUpdateUser } from '../hooks';
import type { User } from '../schema/user.schema';
import { GenderEnum } from '../schema/user.schema';

const createUserSchema = z.object({
  username: z
    .string()
    .min(3, 'El nombre de usuario debe tener al menos 3 caracteres')
    .max(20, 'El nombre de usuario no puede exceder 20 caracteres')
    .regex(/^[a-zA-Z0-9_]+$/, 'Solo se permiten letras, nmeros y guin bajo'),
  email: z
    .union([z.string().email('Email invlido'), z.literal('')])
    .optional(),
  password: z.string().min(6, 'La contrasea debe tener al menos 6 caracteres'),
  firstName: z
    .string()
    .min(2, 'El nombre debe tener al menos 2 caracteres')
    .max(50, 'El nombre no puede exceder 50 caracteres'),
  lastName: z
    .string()
    .min(2, 'El apellido debe tener al menos 2 caracteres')
    .max(50, 'El apellido no puede exceder 50 caracteres'),
  phoneNumber: z
    .union([
      z.string().regex(/^\+?[0-9\s-]+$/, 'Nmero de telfono invlido'),
      z.literal(''),
    ])
    .optional(),
  gender: z.nativeEnum(GenderEnum).nullable().optional(),
  address: z.string().optional(),
  city: z.string().optional(),
  state: z.string().optional(),
  country: z.string().optional(),
  zipCode: z.string().optional(),
  role: z.number(),
  isActive: z.boolean(),
});

const updateUserSchema = createUserSchema.omit({ password: true }).extend({
  password: z
    .union([
      z.string().min(6, 'La contrasea debe tener al menos 6 caracteres'),
      z.literal(''),
    ])
    .optional(),
});

type CreateUserFormInputs = z.infer<typeof createUserSchema>;
type UpdateUserFormInputs = z.infer<typeof updateUserSchema>;
type UserFormInputs = CreateUserFormInputs | UpdateUserFormInputs;

interface UserFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  user?: User | null;
}

export function UserFormModal({
  visible,
  onDismiss,
  user,
}: UserFormModalProps) {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = getStyles(theme, responsive);
  const [showPassword, setShowPassword] = useState(false);

  const createUserMutation = useCreateUser();
  const updateUserMutation = useUpdateUser();

  const {
    control,
    handleSubmit,
    formState: { errors },
    reset,
  } = useForm<UserFormInputs>({
    resolver: zodResolver(user ? updateUserSchema : createUserSchema),
    defaultValues: {
      username: '',
      email: '',
      password: '',
      firstName: '',
      lastName: '',
      phoneNumber: '',
      gender: null,
      address: '',
      city: '',
      state: '',
      country: '',
      zipCode: '',
      role: 2, // Default to MANAGER role
      isActive: true,
    },
  });

  useEffect(() => {
    if (user) {
      reset({
        username: user.username,
        email: user.email || '',
        password: '', // Never pre-fill password
        firstName: user.firstName || '',
        lastName: user.lastName || '',
        phoneNumber: user.phoneNumber || '',
        gender: user.gender || null,
        address: user.address || '',
        city: user.city || '',
        state: user.state || '',
        country: user.country || '',
        zipCode: user.zipCode || '',
        role: user.role?.id || 2,
        isActive: user.isActive,
      });
    } else {
      reset({
        username: '',
        email: '',
        password: '',
        firstName: '',
        lastName: '',
        phoneNumber: '',
        gender: null,
        address: '',
        city: '',
        state: '',
        country: '',
        zipCode: '',
        role: 2,
        isActive: true,
      });
    }
  }, [user, reset]);

  const onSubmit = async (
    data: CreateUserFormInputs | UpdateUserFormInputs,
  ) => {
    try {
      // Clean empty strings to undefined
      const cleanData = {
        username: data.username,
        email: data.email || undefined,
        password: data.password || undefined,
        firstName: data.firstName,
        lastName: data.lastName,
        phoneNumber: data.phoneNumber || undefined,
        gender: data.gender || null,
        address: data.address || undefined,
        city: data.city || undefined,
        state: data.state || undefined,
        country: data.country || undefined,
        zipCode: data.zipCode || undefined,
        role: { id: data.role },
        isActive: data.isActive,
      };

      if (user) {
        const { username, password, ...updateData } = cleanData;
        const finalUpdateData = password
          ? { ...updateData, password }
          : updateData;

        await updateUserMutation.mutateAsync({
          id: user.id,
          data: finalUpdateData,
        });
      } else {
        if (!data.password) {
          return;
        }
        const createData = {
          ...cleanData,
          password: data.password,
        };
        await createUserMutation.mutateAsync(createData);
      }
      onDismiss();
    } catch (error) {
      // Error is handled by mutation hooks
    }
  };

  const isSubmitting =
    createUserMutation.isPending || updateUserMutation.isPending;

  const genderOptions = [
    {
      value: GenderEnum.MALE,
      label: 'Masculino',
      icon: 'gender-male',
      color: '#3498db',
    },
    {
      value: GenderEnum.FEMALE,
      label: 'Femenino',
      icon: 'gender-female',
      color: '#e74c3c',
    },
    {
      value: GenderEnum.OTHER,
      label: 'Otro',
      icon: 'gender-transgender',
      color: '#9b59b6',
    },
  ];

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalContainer}
      >
        <Surface style={styles.modalContent} elevation={5}>
          <View
            style={[
              styles.headerContainer,
              { backgroundColor: theme.colors.primary },
            ]}
          >
            <View style={styles.headerLeft}>
              <Avatar.Icon
                size={32}
                icon={user ? 'account-edit' : 'account-plus'}
                style={[
                  styles.headerIcon,
                  { backgroundColor: theme.colors.onPrimary + '20' },
                ]}
                color={theme.colors.onPrimary}
              />
              <View style={styles.headerTextContainer}>
                <Text
                  style={[styles.modalTitle, { color: theme.colors.onPrimary }]}
                  variant="titleMedium"
                >
                  {user ? 'Editar Usuario' : 'Nuevo Usuario'}
                </Text>
              </View>
            </View>
            <IconButton
              icon="close"
              size={24}
              onPress={onDismiss}
              disabled={isSubmitting}
              iconColor={theme.colors.onPrimary}
            />
          </View>

          <ScrollView
            style={styles.formContainer}
            showsVerticalScrollIndicator={false}
            keyboardShouldPersistTaps="handled"
          >
            <View style={styles.sectionContainer}>
              <View style={styles.sectionHeader}>
                <Icon
                  source="account-key"
                  size={20}
                  color={theme.colors.primary}
                />
                <Text style={styles.sectionTitle} variant="titleMedium">
                  Informacin de Cuenta
                </Text>
                <Chip
                  mode="flat"
                  compact
                  icon="check"
                  style={styles.requiredChip}
                  textStyle={styles.requiredChipText}
                >
                  Requerido
                </Chip>
              </View>

              <Controller
                control={control}
                name="username"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Nombre de usuario"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.username}
                      mode="outlined"
                      placeholder="usuario123"
                      left={<TextInput.Icon icon="account" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                      disabled={!!user} // Username can't be changed
                    />
                    {errors.username && (
                      <HelperText type="error" visible={!!errors.username}>
                        {errors.username.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />

              <Controller
                control={control}
                name="email"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Email (opcional)"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.email}
                      mode="outlined"
                      placeholder="usuario@ejemplo.com"
                      keyboardType="email-address"
                      autoCapitalize="none"
                      left={<TextInput.Icon icon="email" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.email && (
                      <HelperText type="error" visible={!!errors.email}>
                        {errors.email.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />

              <Controller
                control={control}
                name="password"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label={
                        user
                          ? 'Nueva contrasea (dejar vaco para no cambiar)'
                          : 'Contrasea'
                      }
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.password}
                      mode="outlined"
                      placeholder=""
                      secureTextEntry={!showPassword}
                      left={<TextInput.Icon icon="lock" />}
                      right={
                        <TextInput.Icon
                          icon={showPassword ? 'eye-off' : 'eye'}
                          onPress={() => setShowPassword(!showPassword)}
                        />
                      }
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.password && (
                      <HelperText type="error" visible={!!errors.password}>
                        {errors.password.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />

              <Controller
                control={control}
                name="role"
                render={({ field: { onChange, value } }) => (
                  <View style={styles.inputContainer}>
                    <View style={styles.fieldLabelContainer}>
                      <Icon
                        source="badge-account"
                        size={20}
                        color={theme.colors.primary}
                      />
                      <Text style={styles.sectionTitle} variant="titleMedium">
                        Rol del usuario
                      </Text>
                    </View>
                    <ScrollView
                      horizontal
                      showsHorizontalScrollIndicator={false}
                      style={{ marginTop: theme.spacing.s }}
                    >
                      <View style={styles.rolesContainer}>
                        {[
                          {
                            value: 1,
                            label: 'Admin',
                            icon: 'shield-account',
                            description: 'Acceso completo',
                          },
                          {
                            value: 2,
                            label: 'Gerente',
                            icon: 'account-tie',
                            description: 'Gestin general',
                          },
                          {
                            value: 3,
                            label: 'Cajero',
                            icon: 'cash-register',
                            description: 'Ventas',
                          },
                          {
                            value: 4,
                            label: 'Mesero',
                            icon: 'room-service',
                            description: 'rdenes',
                          },
                          {
                            value: 5,
                            label: 'Cocina',
                            icon: 'chef-hat',
                            description: 'Preparacin',
                          },
                          {
                            value: 6,
                            label: 'Repartidor',
                            icon: 'moped',
                            description: 'Entregas',
                          },
                        ].map((role) => (
                          <Surface
                            key={role.value}
                            style={[
                              styles.roleCard,
                              value === role.value && styles.roleCardActive,
                            ]}
                            elevation={value === role.value ? 2 : 0}
                          >
                            <TouchableOpacity
                              onPress={() => onChange(role.value)}
                              style={styles.roleCardContent}
                            >
                              <Icon
                                source={role.icon}
                                size={24}
                                color={
                                  value === role.value
                                    ? theme.colors.primary
                                    : theme.colors.onSurfaceVariant
                                }
                              />
                              <Text
                                style={[
                                  styles.roleLabel,
                                  value === role.value &&
                                    styles.roleLabelActive,
                                ]}
                                variant="labelMedium"
                              >
                                {role.label}
                              </Text>
                              <Text
                                style={styles.roleDescription}
                                variant="bodySmall"
                                numberOfLines={1}
                              >
                                {role.description}
                              </Text>
                            </TouchableOpacity>
                          </Surface>
                        ))}
                      </View>
                    </ScrollView>
                  </View>
                )}
              />
            </View>

            <Divider style={styles.divider} />

            <View style={styles.sectionContainer}>
              <View style={styles.sectionHeader}>
                <Icon
                  source="account-circle"
                  size={20}
                  color={theme.colors.primary}
                />
                <Text style={styles.sectionTitle} variant="titleMedium">
                  Informacin Personal
                </Text>
                <Chip
                  mode="flat"
                  compact
                  icon="check"
                  style={styles.requiredChip}
                  textStyle={styles.requiredChipText}
                >
                  Requerido
                </Chip>
              </View>

              <Controller
                control={control}
                name="firstName"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Nombre"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.firstName}
                      mode="outlined"
                      placeholder="Juan"
                      left={<TextInput.Icon icon="account" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.firstName && (
                      <HelperText type="error" visible={!!errors.firstName}>
                        {errors.firstName.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />

              <Controller
                control={control}
                name="lastName"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Apellido"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.lastName}
                      mode="outlined"
                      placeholder="Prez"
                      left={<TextInput.Icon icon="account" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.lastName && (
                      <HelperText type="error" visible={!!errors.lastName}>
                        {errors.lastName.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />

              <Controller
                control={control}
                name="gender"
                render={({ field: { onChange, value } }) => (
                  <View style={styles.inputContainer}>
                    <View style={styles.fieldLabelContainer}>
                      <Icon
                        source="gender-transgender"
                        size={20}
                        color={theme.colors.primary}
                      />
                      <Text style={styles.sectionTitle} variant="titleMedium">
                        Gnero
                      </Text>
                    </View>
                    <View
                      style={[
                        styles.genderContainer,
                        { marginTop: theme.spacing.s },
                      ]}
                    >
                      {genderOptions.map((option) => (
                        <TouchableOpacity
                          key={option.value}
                          onPress={() => onChange(option.value)}
                          activeOpacity={0.7}
                        >
                          <Surface
                            style={[
                              styles.genderOption,
                              value === option.value &&
                                styles.genderOptionActive,
                            ]}
                            elevation={value === option.value ? 3 : 1}
                          >
                            <View
                              style={[
                                styles.genderIconContainer,
                                value === option.value && {
                                  backgroundColor: option.color + '20',
                                },
                              ]}
                            >
                              <Icon
                                source={option.icon}
                                size={20}
                                color={
                                  value === option.value
                                    ? option.color
                                    : theme.colors.onSurfaceVariant
                                }
                              />
                            </View>
                            <Text
                              style={[
                                styles.genderLabel,
                                value === option.value &&
                                  styles.genderLabelActive,
                              ]}
                              variant="labelMedium"
                            >
                              {option.label}
                            </Text>
                          </Surface>
                        </TouchableOpacity>
                      ))}
                    </View>
                  </View>
                )}
              />
            </View>

            <Divider style={styles.divider} />

            <View style={styles.sectionContainer}>
              <View style={styles.sectionHeader}>
                <Icon
                  source="phone-in-talk"
                  size={20}
                  color={theme.colors.primary}
                />
                <Text style={styles.sectionTitle} variant="titleMedium">
                  Informacin de Contacto
                </Text>
                <Chip
                  mode="flat"
                  compact
                  icon="information"
                  style={styles.optionalChip}
                  textStyle={styles.optionalChipText}
                >
                  Opcional
                </Chip>
              </View>

              <Controller
                control={control}
                name="phoneNumber"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Telfono"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      error={!!errors.phoneNumber}
                      mode="outlined"
                      placeholder="+52 55 1234 5678"
                      keyboardType="phone-pad"
                      left={<TextInput.Icon icon="phone" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                    {errors.phoneNumber && (
                      <HelperText type="error" visible={!!errors.phoneNumber}>
                        {errors.phoneNumber.message}
                      </HelperText>
                    )}
                  </View>
                )}
              />

              <Controller
                control={control}
                name="address"
                render={({ field: { onChange, onBlur, value } }) => (
                  <View style={styles.inputContainer}>
                    <TextInput
                      label="Direccin"
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      mode="outlined"
                      placeholder="Calle Principal #123"
                      left={<TextInput.Icon icon="map-marker" />}
                      outlineStyle={styles.inputOutline}
                      contentStyle={styles.inputContent}
                      style={styles.input}
                    />
                  </View>
                )}
              />

              <View style={styles.rowContainer}>
                <Controller
                  control={control}
                  name="city"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={[styles.inputContainer, styles.halfInput]}>
                      <TextInput
                        label="Ciudad"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        mode="outlined"
                        placeholder="Ciudad"
                        outlineStyle={styles.inputOutline}
                      />
                    </View>
                  )}
                />

                <Controller
                  control={control}
                  name="state"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={[styles.inputContainer, styles.halfInput]}>
                      <TextInput
                        label="Estado"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        mode="outlined"
                        placeholder="Estado"
                        outlineStyle={styles.inputOutline}
                      />
                    </View>
                  )}
                />
              </View>

              <View style={styles.rowContainer}>
                <Controller
                  control={control}
                  name="country"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={[styles.inputContainer, styles.halfInput]}>
                      <TextInput
                        label="Pas"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        mode="outlined"
                        placeholder="Mxico"
                        outlineStyle={styles.inputOutline}
                      />
                    </View>
                  )}
                />

                <Controller
                  control={control}
                  name="zipCode"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={[styles.inputContainer, styles.halfInput]}>
                      <TextInput
                        label="Cdigo Postal"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        mode="outlined"
                        placeholder="12345"
                        keyboardType="number-pad"
                        outlineStyle={styles.inputOutline}
                      />
                    </View>
                  )}
                />
              </View>
            </View>

            <Divider style={styles.divider} />

            <View style={styles.sectionContainer}>
              <View style={styles.sectionHeader}>
                <Icon
                  source="shield-check"
                  size={20}
                  color={theme.colors.primary}
                />
                <Text style={styles.sectionTitle} variant="titleMedium">
                  Estado de la cuenta
                </Text>
              </View>

              <Controller
                control={control}
                name="isActive"
                render={({ field: { onChange, value } }) => (
                  <Surface style={styles.switchContainer} elevation={1}>
                    <View style={styles.switchContent}>
                      <View style={styles.switchTextContainer}>
                        <Text style={styles.switchLabel} variant="bodyLarge">
                          Usuario activo
                        </Text>
                        <Text
                          style={styles.switchDescription}
                          variant="bodySmall"
                        >
                          Los usuarios inactivos no pueden iniciar sesin
                        </Text>
                      </View>
                      <Switch
                        value={value}
                        onValueChange={onChange}
                        color={theme.colors.primary}
                      />
                    </View>
                  </Surface>
                )}
              />
            </View>

            <View style={styles.scrollSpacer} />
          </ScrollView>

          <Surface style={styles.buttonContainer} elevation={2}>
            <Button
              onPress={onDismiss}
              disabled={isSubmitting}
              style={[styles.button, styles.cancelButton]}
              textColor={theme.colors.onSecondaryContainer}
            >
              Cancelar
            </Button>
            <Button
              mode="contained"
              onPress={handleSubmit(onSubmit)}
              disabled={isSubmitting}
              loading={isSubmitting}
              style={[styles.button, styles.confirmButton]}
              buttonColor={theme.colors.primary}
            >
              {user ? 'Guardar' : 'Crear'}
            </Button>
          </Surface>
        </Surface>
      </Modal>
    </Portal>
  );
}

const getStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    modalContainer: {
      margin: responsive.isTablet ? theme.spacing.xl : theme.spacing.m,
      maxWidth: responsive.isTablet ? 700 : 420,
      alignSelf: 'center',
      width: responsive.isTablet ? '85%' : '92%',
      paddingHorizontal: 0,
      height: responsive.isTablet ? '85%' : '80%',
      maxHeight: responsive.isTablet ? '90%' : '85%',
      justifyContent: 'center',
    },
    modalContent: {
      borderRadius: theme.roundness * 3,
      backgroundColor: theme.colors.surface,
      height: '100%',
      flex: 1,
      overflow: 'hidden',
      elevation: 5,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
    },
    headerContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingHorizontal: responsive.isTablet
        ? theme.spacing.l
        : theme.spacing.m,
      paddingVertical: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
      borderTopLeftRadius: theme.roundness * 3,
      borderTopRightRadius: theme.roundness * 3,
    },
    headerLeft: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
    },
    headerIcon: {
      marginRight: theme.spacing.s,
    },
    headerTextContainer: {
      flex: 1,
    },
    modalTitle: {
      fontWeight: '700',
    },
    formContainer: {
      flex: 1,
      paddingHorizontal: responsive.isTablet
        ? theme.spacing.l
        : theme.spacing.m,
      paddingTop: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
      paddingBottom: responsive.isTablet ? theme.spacing.l : theme.spacing.s,
    },
    sectionContainer: {
      marginBottom: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
    },
    sectionHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: theme.spacing.xs,
      gap: theme.spacing.xs,
    },
    sectionTitle: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: 14,
      flex: 1,
    },
    requiredChip: {
      backgroundColor: theme.colors.primary + '20',
      borderWidth: 1,
      borderColor: theme.colors.primary + '40',
    },
    requiredChipText: {
      color: theme.colors.primary,
      fontSize: 11,
      fontWeight: '600',
    },
    optionalChip: {
      backgroundColor: theme.colors.surfaceVariant,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
    },
    optionalChipText: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 11,
    },
    inputContainer: {
      marginBottom: theme.spacing.xs,
    },
    inputOutline: {
      borderRadius: theme.roundness * 2,
      borderWidth: 1,
    },
    input: {
      fontSize: 14,
      backgroundColor: theme.colors.surface,
      height: 48,
    },
    inputContent: {
      paddingVertical: 4,
      fontSize: 14,
      fontFamily: 'System',
    },
    fieldLabel: {
      color: theme.colors.onSurfaceVariant,
      marginBottom: theme.spacing.xs,
      fontWeight: '600',
      fontSize: 12,
      letterSpacing: 0.4,
      textTransform: 'uppercase',
      fontFamily: 'System',
    },
    fieldLabelContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.xs,
      marginBottom: theme.spacing.s,
    },
    segmentedButtons: {
      marginTop: theme.spacing.xs,
    },
    genderContainer: {
      flexDirection: 'row',
      gap: theme.spacing.s,
      flexWrap: 'wrap',
    },
    genderOption: {
      borderRadius: theme.roundness * 2,
      padding: theme.spacing.s,
      alignItems: 'center',
      backgroundColor: theme.colors.surface,
      minWidth: 85,
      borderWidth: 1.5,
      borderColor: theme.colors.outlineVariant,
    },
    genderOptionActive: {
      backgroundColor: theme.colors.primaryContainer,
      borderColor: theme.colors.primary,
    },
    genderIconContainer: {
      width: 36,
      height: 36,
      borderRadius: 18,
      alignItems: 'center',
      justifyContent: 'center',
      marginBottom: theme.spacing.xs,
    },
    genderLabel: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 11,
      textAlign: 'center',
    },
    genderLabelActive: {
      color: theme.colors.onPrimaryContainer,
      fontWeight: '600',
    },
    rowContainer: {
      flexDirection: 'row',
      gap: theme.spacing.s,
    },
    halfInput: {
      flex: 1,
    },
    switchContainer: {
      borderRadius: theme.roundness * 2,
      padding: theme.spacing.s,
      backgroundColor: theme.colors.primaryContainer + '20',
      borderWidth: 1,
      borderColor: theme.colors.primary + '30',
    },
    switchContent: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    switchTextContainer: {
      flex: 1,
      marginRight: theme.spacing.m,
    },
    switchLabel: {
      color: theme.colors.onSurface,
      fontWeight: '500',
    },
    switchDescription: {
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
    },
    divider: {
      marginVertical: theme.spacing.s,
      marginHorizontal: -theme.spacing.m,
    },
    buttonContainer: {
      flexDirection: 'row',
      justifyContent: 'center',
      padding: responsive.isTablet ? theme.spacing.m : theme.spacing.s,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      gap: theme.spacing.s,
    },
    button: {
      flex: 1,
      maxWidth: responsive.isTablet ? 180 : 150,
    },
    cancelButton: {
      backgroundColor: theme.colors.secondaryContainer,
    },
    confirmButton: {},
    rolesContainer: {
      flexDirection: 'row',
      gap: theme.spacing.s,
      paddingVertical: theme.spacing.xs,
    },
    roleCard: {
      borderRadius: theme.roundness * 2,
      padding: theme.spacing.s,
      backgroundColor: theme.colors.surface,
      marginRight: theme.spacing.xs,
      minWidth: 90,
      borderWidth: 1.5,
      borderColor: theme.colors.outlineVariant,
      elevation: 1,
    },
    roleCardActive: {
      backgroundColor: theme.colors.primaryContainer,
      borderColor: theme.colors.primary,
      elevation: 3,
    },
    roleCardContent: {
      alignItems: 'center',
    },
    roleLabel: {
      color: theme.colors.onSurfaceVariant,
      marginTop: theme.spacing.xs,
      fontWeight: '500',
    },
    roleLabelActive: {
      color: theme.colors.onPrimaryContainer,
      fontWeight: '700',
    },
    roleDescription: {
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
      fontSize: 10,
      textAlign: 'center',
    },
    scrollSpacer: {
      height: 10,
    },
  });

================
File: app/src/app/components/ConnectionErrorModal.tsx
================
import { useEffect, useState, useRef } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  Dimensions,
  Platform,
} from 'react-native';
import {
  Text,
  Modal,
  Portal,
  Surface,
  Icon,
  IconButton,
  useTheme,
  ProgressBar,
  Button,
} from 'react-native-paper';
import { ServerConfigModal } from './ServerConfigModal';
import {
  autoReconnectService,
  ReconnectState,
} from '@/services/autoReconnectService';
import { useServerConnection } from '../hooks/useServerConnection';
import { useAuthStore } from '../store/authStore';

const { width: screenWidth, height: screenHeight } = Dimensions.get('window');

export function ConnectionErrorModal() {
  const theme = useTheme();
  const { isConnected } = useServerConnection();
  const isLoggedIn = useAuthStore((state) => !!state.user);
  const [visible, setVisible] = useState(false);
  const [reconnectState, setReconnectState] = useState<ReconnectState>(
    autoReconnectService.getState(),
  );
  const [isPaused, setIsPaused] = useState(false);
  const [pausedLogs, setPausedLogs] = useState<string[]>([]);
  const scrollViewRef = useRef<ScrollView>(null);
  const [showConfigModal, setShowConfigModal] = useState(false);

  useEffect(() => {
    // En web, mostrar directamente el modal de configuracin
    if (Platform.OS === 'web' && !isConnected && !isLoggedIn) {
      setVisible(true);
      return;
    }

    const unsubscribe = autoReconnectService.subscribe((state) => {
      setReconnectState(state);

      if (!isLoggedIn && state.isReconnecting) {
        setVisible(true);
      }

      if (state.status === 'connected') {
        setVisible(false);
      }
    });

    return () => {
      unsubscribe();
    };
  }, [isLoggedIn, isConnected]);

  useEffect(() => {
    if (Platform.OS === 'web' && isConnected && visible) {
      setVisible(false);
      setShowConfigModal(false);
    }
  }, [isConnected, visible]);

  useEffect(() => {
    if (isPaused && pausedLogs.length === 0) {
      setPausedLogs([...reconnectState.logs]);
    } else if (!isPaused) {
      setPausedLogs([]);
    }
  }, [isPaused, pausedLogs.length, reconnectState.logs]);

  useEffect(() => {
    if (Platform.OS === 'web') {
      return;
    }

    if (!isConnected && !autoReconnectService.getState().isReconnecting) {
      setTimeout(() => {
        if (!isConnected) {
          autoReconnectService.startAutoReconnect();
        }
      }, 500);
    }
  }, [isConnected]);

  const getStatusInfo = () => {
    switch (reconnectState.status) {
      case 'checking-network':
        return {
          icon: 'wifi',
          title: 'Verificando red...',
          color: theme.colors.primary,
        };
      case 'checking-health':
        return {
          icon: 'server-network',
          title: 'Verificando servidor...',
          color: theme.colors.primary,
        };
      case 'running-discovery':
        return {
          icon: 'magnify-scan',
          title: 'Buscando servidor en la red...',
          color: theme.colors.tertiary,
        };
      case 'no-wifi':
        return {
          icon: 'wifi-off',
          title: 'Sin conexin WiFi',
          color: theme.colors.error,
        };
      case 'failed':
        return {
          icon: 'server-off',
          title: 'No se puede conectar',
          color: theme.colors.error,
        };
      case 'connected':
        return {
          icon: 'check-circle',
          title: 'Conexin establecida!',
          color: theme.colors.primary,
        };
      default:
        return {
          icon: 'alert-circle',
          title: 'Conectando...',
          color: theme.colors.tertiary,
        };
    }
  };

  const statusInfo = getStatusInfo();

  const styles = StyleSheet.create({
    modal: {
      justifyContent: 'center',
      alignItems: 'center',
      margin: 20,
    },
    container: {
      width: screenWidth - 40,
      minHeight: 400,
      maxHeight: screenHeight * 0.85,
      backgroundColor: theme.colors.surface,
      borderRadius: 24,
      overflow: 'hidden',
      elevation: 8,
    },
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: 20,
      paddingVertical: 16,
      backgroundColor: theme.colors.elevation.level2,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    headerTitle: {
      fontSize: 18,
      fontWeight: '600',
      color: theme.colors.onSurface,
      flex: 1,
      marginLeft: 12,
    },
    statusSection: {
      paddingTop: 12,
      paddingBottom: 8,
      paddingHorizontal: 16,
      alignItems: 'center',
    },
    title: {
      fontSize: 18,
      fontWeight: '600',
      color: theme.colors.onSurface,
      textAlign: 'center',
      marginBottom: 6,
    },
    subtitle: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
    },
    attemptBadge: {
      backgroundColor: theme.colors.primaryContainer,
      paddingHorizontal: 12,
      paddingVertical: 6,
      borderRadius: 16,
      marginTop: 8,
    },
    attemptText: {
      fontSize: 13,
      fontWeight: '500',
      color: theme.colors.onPrimaryContainer,
    },
    logsContainer: {
      backgroundColor: theme.colors.surfaceVariant,
      marginHorizontal: 16,
      marginBottom: 16,
      borderRadius: 16,
      overflow: 'hidden',
      minHeight: 200,
      maxHeight: 350,
    },
    logsHeader: {
      backgroundColor: theme.colors.elevation.level1,
      paddingHorizontal: 16,
      paddingVertical: 12,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    logsTitle: {
      fontSize: 12,
      fontWeight: '600',
      color: theme.colors.onSurfaceVariant,
      letterSpacing: 1,
      textTransform: 'uppercase',
    },
    logsList: {
      padding: 16,
    },
    logEntry: {
      fontSize: 13,
      lineHeight: 20,
      color: theme.colors.onSurface,
      marginBottom: 6,
      fontFamily: 'monospace',
    },
    logInfo: {
      color: theme.colors.onSurface,
    },
    logError: {
      color: theme.colors.error,
      fontWeight: '600',
    },
    logSuccess: {
      color: theme.colors.primary,
      fontWeight: '600',
    },
    progressContainer: {
      paddingHorizontal: 24,
      paddingBottom: 12,
    },
    actionContainer: {
      paddingHorizontal: 16,
      paddingBottom: 16,
      paddingTop: 8,
    },
    actionButton: {
      marginTop: 8,
    },
    iconContainer: {
      marginBottom: 16,
    },
    progressBar: {
      height: 4,
      borderRadius: 2,
    },
    logsHeaderRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    pauseButton: {
      margin: -4,
    },
    logsSpacer: {
      height: 10,
    },
  });

  if (!visible) return null;

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={() => {
          if (
            Platform.OS === 'web' ||
            reconnectState.status === 'connected' ||
            reconnectState.status === 'no-wifi'
          ) {
            setVisible(false);
          }
        }}
        contentContainerStyle={styles.modal}
        dismissable={
          Platform.OS === 'web' ||
          reconnectState.status === 'connected' ||
          reconnectState.status === 'no-wifi'
        }
      >
        <Surface style={styles.container}>
          <View style={styles.header}>
            <Icon source="wifi-sync" size={24} color={theme.colors.primary} />
            <Text style={styles.headerTitle}>Estado de Conexin</Text>
            {(Platform.OS === 'web' ||
              reconnectState.status === 'connected' ||
              reconnectState.status === 'no-wifi') && (
              <IconButton
                icon="close"
                size={24}
                onPress={() => setVisible(false)}
                iconColor={theme.colors.onSurfaceVariant}
              />
            )}
          </View>

          <View style={styles.statusSection}>
            {Platform.OS === 'web' ? (
              <>
                <View style={styles.iconContainer}>
                  <Icon
                    source="server-network"
                    size={64}
                    color={theme.colors.tertiary}
                  />
                </View>
                <Text style={styles.title}>Configuracin Requerida</Text>
                <Text style={styles.subtitle}>
                  En la versin web, debes configurar manualmente la URL del
                  servidor
                </Text>
              </>
            ) : (
              <>
                <Text style={styles.title}>{statusInfo.title}</Text>
                {reconnectState.lastError &&
                  reconnectState.status !== 'connected' && (
                    <Text style={styles.subtitle}>
                      {reconnectState.lastError}
                    </Text>
                  )}
              </>
            )}

            {reconnectState.attempts > 0 &&
              reconnectState.status !== 'connected' &&
              Platform.OS !== 'web' && (
                <View style={styles.attemptBadge}>
                  <Text style={styles.attemptText}>
                    Intento #{reconnectState.attempts}
                  </Text>
                </View>
              )}
          </View>

          {reconnectState.isReconnecting &&
            reconnectState.status !== 'connected' &&
            Platform.OS !== 'web' && (
              <View style={styles.progressContainer}>
                <ProgressBar
                  indeterminate
                  color={statusInfo.color}
                  style={styles.progressBar}
                />
              </View>
            )}

          {reconnectState.logs.length > 0 && Platform.OS !== 'web' && (
            <View style={styles.logsContainer}>
              <View style={styles.logsHeader}>
                <View style={styles.logsHeaderRow}>
                  <Text style={styles.logsTitle}>
                    DETALLES DEL PROCESO {isPaused ? '(PAUSADO)' : ''}
                  </Text>
                  <IconButton
                    icon={isPaused ? 'play' : 'pause'}
                    size={32}
                    onPress={() => setIsPaused(!isPaused)}
                    iconColor={theme.colors.primary}
                    style={styles.pauseButton}
                  />
                </View>
              </View>
              <ScrollView
                ref={scrollViewRef}
                style={styles.logsList}
                showsVerticalScrollIndicator={true}
                nestedScrollEnabled={true}
              >
                {(isPaused ? pausedLogs : reconnectState.logs).map(
                  (log, index) => {
                    let logStyle = [styles.logEntry, styles.logInfo];

                    if (
                      log.includes('ERROR:') ||
                      log.includes('') ||
                      log.includes('')
                    ) {
                      logStyle = [styles.logEntry, styles.logError];
                    } else if (
                      log.includes('SUCCESS:') ||
                      log.includes('') ||
                      log.includes('') ||
                      log.includes('')
                    ) {
                      logStyle = [styles.logEntry, styles.logSuccess];
                    }

                    return (
                      <Text key={index} style={logStyle}>
                        {log}
                      </Text>
                    );
                  },
                )}
                <View style={styles.logsSpacer} />
              </ScrollView>
            </View>
          )}

          {Platform.OS === 'web' ||
          reconnectState.status === 'failed' ||
          reconnectState.status === 'no-wifi' ||
          (reconnectState.attempts > 2 &&
            reconnectState.status !== 'connected') ? (
            <View style={styles.actionContainer}>
              <Button
                mode="contained"
                onPress={() => {
                  setShowConfigModal(true);
                }}
                icon="server-network"
                style={styles.actionButton}
              >
                Configurar Servidor Manualmente
              </Button>
            </View>
          ) : null}
        </Surface>
      </Modal>

      <ServerConfigModal
        visible={showConfigModal}
        onDismiss={() => setShowConfigModal(false)}
        onSuccess={() => {
          setShowConfigModal(false);
          if (Platform.OS === 'web') {
            setVisible(false);
          } else {
            setTimeout(() => {
              autoReconnectService.startAutoReconnect();
            }, 1000);
          }
        }}
      />
    </Portal>
  );
}

================
File: app/src/modules/customers/components/AddressFormModal.tsx
================
import React, { useState, useEffect, useRef } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  TextInput,
  Button,
  Switch,
  HelperText,
  Surface,
  Chip,
  Avatar,
  IconButton,
  Icon,
  ActivityIndicator,
} from 'react-native-paper';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@/app/lib/zodResolver';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import {
  Address,
  addressSchema,
  AddressFormInputs,
} from '../schema/customer.schema';
import { WebView } from 'react-native-webview';
import { GOOGLE_MAPS_CONFIG } from '../constants/maps.config';
import { useGoogleMapsConfig } from '@/hooks/useGoogleMapsConfig';
import { useSnackbarStore } from '@/app/store/snackbarStore';

interface AddressFormModalProps {
  visible: boolean;
  onDismiss: () => void;
  onSubmit: (data: AddressFormInputs) => Promise<void>;
  editingItem: Address | null;
  isSubmitting: boolean;
  customerId?: string;
}

export default function AddressFormModal({
  visible,
  onDismiss,
  onSubmit,
  editingItem,
  isSubmitting,
  customerId: _customerId,
}: AddressFormModalProps) {
  const theme = useAppTheme();
  const styles = getStyles(theme);
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const { config: mapsConfig, loading: isLoadingApiKey } =
    useGoogleMapsConfig();
  const apiKey = mapsConfig?.apiKey;
  const [mapReady, setMapReady] = useState(false);
  const [isMapLoading, setIsMapLoading] = useState(true);
  const [isMapFullscreen, setIsMapFullscreen] = useState(false);
  const webViewRef = useRef<WebView>(null);
  const scrollViewRef = useRef<ScrollView>(null);

  const {
    control,
    handleSubmit,
    formState: { errors },
    reset,
    setValue,
    watch,
    trigger,
  } = useForm<AddressFormInputs>({
    resolver: zodResolver(addressSchema),
    defaultValues: {
      name: '',
      street: '',
      number: '',
      interiorNumber: '',
      neighborhood: '',
      city: '',
      state: '',
      zipCode: '',
      country: 'Mxico',
      deliveryInstructions: '',
      isDefault: false,
    },
  });

  const latitude = watch('latitude');
  const longitude = watch('longitude');

  useEffect(() => {
    if (editingItem) {
      reset({
        name: editingItem.name,
        street: editingItem.street,
        number: editingItem.number,
        interiorNumber: editingItem.interiorNumber || '',
        neighborhood: editingItem.neighborhood,
        city: editingItem.city,
        state: editingItem.state,
        zipCode: editingItem.zipCode,
        country: editingItem.country || 'Mxico',
        deliveryInstructions: editingItem.deliveryInstructions || '',
        latitude: editingItem.latitude
          ? Number(editingItem.latitude)
          : undefined,
        longitude: editingItem.longitude
          ? Number(editingItem.longitude)
          : undefined,
        isDefault: editingItem.isDefault,
      });
    } else {
      reset({
        name: '',
        street: '',
        number: '',
        interiorNumber: '',
        neighborhood: '',
        city: '',
        state: '',
        zipCode: '',
        country: 'Mxico',
        deliveryInstructions: '',
        isDefault: false,
      });
    }
  }, [editingItem, reset]);

  const mapHtml = React.useMemo(
    () =>
      apiKey
        ? `
<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes" />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      height: 100%;
      width: 100%;
      overflow: hidden;
      touch-action: manipulation;
    }
    #map {
      height: 100%;
      width: 100%;
      touch-action: manipulation;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <script>
    let map;
    let marker;
    let currentLocation = null;

    function initMap() {
      const initialLocation = ${
        latitude && longitude
          ? `{ lat: ${latitude}, lng: ${longitude} }`
          : 'null'
      };
      const mapCenter = initialLocation || { lat: ${GOOGLE_MAPS_CONFIG.defaultCenter.lat}, lng: ${GOOGLE_MAPS_CONFIG.defaultCenter.lng} };
      
      map = new google.maps.Map(document.getElementById('map'), {
        center: mapCenter,
        zoom: initialLocation ? ${GOOGLE_MAPS_CONFIG.locationZoom} : ${GOOGLE_MAPS_CONFIG.defaultZoom},
        ...${JSON.stringify(GOOGLE_MAPS_CONFIG.mapOptions)},
        gestureHandling: ${isMapFullscreen ? "'greedy'" : "'cooperative'"}
      });

      if (initialLocation) {
        marker = new google.maps.Marker({
          position: initialLocation,
          map: map,
          draggable: true,
          animation: google.maps.Animation.DROP,
          title: "Ubicacin de la direccin"
        });
        
        currentLocation = initialLocation;
        
        marker.addListener('dragend', function() {
          currentLocation = {
            lat: marker.getPosition().lat(),
            lng: marker.getPosition().lng()
          };
          sendMessage('locationUpdated', {
            latitude: currentLocation.lat,
            longitude: currentLocation.lng
          });
        });
      }

      map.addListener('click', function(event) {
        if (!marker) {
          marker = new google.maps.Marker({
            position: event.latLng,
            map: map,
            draggable: true,
            animation: google.maps.Animation.DROP,
            title: "Ubicacin de la direccin"
          });
          
          marker.addListener('dragend', function() {
            currentLocation = {
              lat: marker.getPosition().lat(),
              lng: marker.getPosition().lng()
            };
            sendMessage('locationUpdated', {
              latitude: currentLocation.lat,
              longitude: currentLocation.lng
            });
          });
        } else {
          marker.setPosition(event.latLng);
        }
        
        currentLocation = {
          lat: event.latLng.lat(),
          lng: event.latLng.lng()
        };
        sendMessage('locationUpdated', {
          latitude: currentLocation.lat,
          longitude: currentLocation.lng
        });
      });

      window.addEventListener('message', handleMessage);
      sendMessage('mapReady', {});
    }

    function handleMessage(event) {
      try {
        const data = JSON.parse(event.data);
        
        switch(data.type) {
          case 'setLocation':
            setLocation(data.latitude, data.longitude);
            break;
          case 'centerOnLocation':
            centerOnLocation();
            break;
        }
      } catch (e) {
      }
    }

    function setLocation(lat, lng) {
      const position = new google.maps.LatLng(lat, lng);
      
      if (!marker) {
        marker = new google.maps.Marker({
          position: position,
          map: map,
          draggable: true,
          animation: google.maps.Animation.DROP,
          title: "Ubicacin de la direccin"
        });
        
        marker.addListener('dragend', function() {
          currentLocation = {
            lat: marker.getPosition().lat(),
            lng: marker.getPosition().lng()
          };
          sendMessage('locationUpdated', {
            latitude: currentLocation.lat,
            longitude: currentLocation.lng
          });
        });
      } else {
        marker.setPosition(position);
      }
      
      map.setCenter(position);
      currentLocation = { lat, lng };
    }

    function centerOnLocation() {
      if (currentLocation) {
        map.setCenter(currentLocation);
        map.setZoom(16);
      }
    }

    function sendMessage(type, data) {
      try {
        if (window.ReactNativeWebView) {
          window.ReactNativeWebView.postMessage(JSON.stringify({
            type: type,
            ...data
          }));
        }
      } catch (e) {
      }
    }
  </script>
  <script async defer
    src="https://maps.googleapis.com/maps/api/js?key=${apiKey}&callback=initMap">
  </script>
</body>
</html>
  `
        : '',
    [latitude, longitude, isMapFullscreen, apiKey],
  );

  const handleWebViewMessage = React.useCallback(
    (event: any) => {
      try {
        const data = JSON.parse(event.nativeEvent.data);

        switch (data.type) {
          case 'mapReady':
            setMapReady(true);
            setIsMapLoading(false);
            break;
          case 'locationUpdated':
            setValue('latitude', Number(data.latitude));
            setValue('longitude', Number(data.longitude));
            break;
        }
      } catch (e) {}
    },
    [setValue],
  );

  const sendMessageToWebView = React.useCallback((type: string, data: any) => {
    if (webViewRef.current) {
      const message = JSON.stringify({ type, ...data });
      webViewRef.current.postMessage(message);
    }
  }, []);

  useEffect(() => {
    if (mapReady && latitude !== undefined && longitude !== undefined) {
      sendMessageToWebView('setLocation', {
        latitude,
        longitude,
      });
    }
  }, [latitude, longitude, mapReady, sendMessageToWebView]);

  useEffect(() => {
    if (visible) {
      setIsMapLoading(true);
      setMapReady(false);
    }
  }, [visible]);

  const handleFormSubmit = React.useCallback(
    async (data: AddressFormInputs) => {
      const formattedData: AddressFormInputs = {
        name: data.name,
        street: data.street,
        number: data.number,
        interiorNumber: data.interiorNumber || undefined,
        neighborhood: data.neighborhood,
        city: data.city,
        state: data.state,
        zipCode: data.zipCode,
        country: data.country,
        deliveryInstructions: data.deliveryInstructions || undefined,
        latitude: data.latitude !== undefined ? data.latitude : undefined,
        longitude: data.longitude !== undefined ? data.longitude : undefined,
        isDefault: data.isDefault || false,
      };
      await onSubmit(formattedData);
    },
    [onSubmit],
  );

  const hasValidCoordinates = React.useMemo(() => {
    return (
      latitude !== undefined &&
      longitude !== undefined &&
      !isNaN(Number(latitude)) &&
      !isNaN(Number(longitude)) &&
      Number(latitude) !== 0 &&
      Number(longitude) !== 0
    );
  }, [latitude, longitude]);

  return (
    <>
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onDismiss}
          contentContainerStyle={styles.modalContainer}
        >
          <Surface style={styles.modalContent} elevation={5}>
            <View
              style={[
                styles.headerContainer,
                { backgroundColor: theme.colors.primary },
              ]}
            >
              <View style={styles.headerLeft}>
                <Avatar.Icon
                  size={28}
                  icon={editingItem ? 'map-marker-radius' : 'map-marker-plus'}
                  style={[
                    styles.headerIcon,
                    { backgroundColor: theme.colors.onPrimary + '20' },
                  ]}
                  color={theme.colors.onPrimary}
                />
                <View style={styles.headerTextContainer}>
                  <Text
                    style={[
                      styles.modalTitle,
                      { color: theme.colors.onPrimary },
                    ]}
                    variant="titleMedium"
                  >
                    {editingItem ? 'Editar Direccin' : 'Nueva Direccin'}
                  </Text>
                </View>
              </View>
              <IconButton
                icon="close"
                size={24}
                onPress={onDismiss}
                disabled={isSubmitting}
                iconColor={theme.colors.onPrimary}
              />
            </View>

            <ScrollView
              ref={scrollViewRef}
              style={styles.formContainer}
              showsVerticalScrollIndicator={false}
              keyboardShouldPersistTaps="handled"
            >
              <Controller
                control={control}
                name="isDefault"
                render={({ field: { onChange, value } }) => (
                  <Surface
                    style={[
                      styles.switchContainer,
                      { marginBottom: theme.spacing.m },
                    ]}
                    elevation={1}
                  >
                    <View style={styles.switchContent}>
                      <View style={styles.switchTextContainer}>
                        <Text style={styles.switchLabel} variant="bodyLarge">
                          Direccin predeterminada
                        </Text>
                        <Text
                          style={styles.switchDescription}
                          variant="bodySmall"
                        >
                          Esta ser la direccin principal para los pedidos
                        </Text>
                      </View>
                      <Switch
                        value={value}
                        onValueChange={onChange}
                        color={theme.colors.primary}
                      />
                    </View>
                  </Surface>
                )}
              />

              <View style={styles.sectionContainer}>
                <View style={styles.sectionHeader}>
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Informacin de la Direccin
                  </Text>
                  <Chip
                    mode="flat"
                    compact
                    style={styles.requiredChip}
                    textStyle={styles.requiredChipText}
                  >
                    Requerido
                  </Chip>
                </View>

                <Controller
                  control={control}
                  name="name"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="Nombre de la direccin"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.name}
                        mode="outlined"
                        placeholder="Ej: Casa, Oficina, Casa de mam"
                        left={<TextInput.Icon icon="tag" />}
                        outlineStyle={styles.inputOutline}
                      />
                      {errors.name && (
                        <HelperText type="error" visible={!!errors.name}>
                          {errors.name.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />

                <Controller
                  control={control}
                  name="street"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="Calle"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.street}
                        mode="outlined"
                        placeholder="Ej: Av. Insurgentes"
                        left={<TextInput.Icon icon="road" />}
                        outlineStyle={styles.inputOutline}
                      />
                      {errors.street && (
                        <HelperText type="error" visible={!!errors.street}>
                          {errors.street.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />

                <View style={styles.row}>
                  <View style={styles.halfInput}>
                    <Controller
                      control={control}
                      name="number"
                      render={({ field: { onChange, onBlur, value } }) => (
                        <View style={styles.inputContainer}>
                          <TextInput
                            label="Nmero"
                            value={value}
                            onChangeText={onChange}
                            onBlur={onBlur}
                            error={!!errors.number}
                            mode="outlined"
                            placeholder="123"
                            left={<TextInput.Icon icon="numeric" />}
                            outlineStyle={styles.inputOutline}
                          />
                          {errors.number && (
                            <HelperText type="error" visible={!!errors.number}>
                              {errors.number.message}
                            </HelperText>
                          )}
                        </View>
                      )}
                    />
                  </View>

                  <View style={styles.halfInput}>
                    <Controller
                      control={control}
                      name="interiorNumber"
                      render={({ field: { onChange, onBlur, value } }) => (
                        <View style={styles.inputContainer}>
                          <TextInput
                            label="Interior"
                            value={value}
                            onChangeText={onChange}
                            onBlur={onBlur}
                            mode="outlined"
                            placeholder="Depto 4B"
                            left={<TextInput.Icon icon="home-variant" />}
                            outlineStyle={styles.inputOutline}
                          />
                        </View>
                      )}
                    />
                  </View>
                </View>

                <Controller
                  control={control}
                  name="neighborhood"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="Colonia"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.neighborhood}
                        mode="outlined"
                        placeholder="Ej: Roma Norte"
                        left={<TextInput.Icon icon="map" />}
                        outlineStyle={styles.inputOutline}
                      />
                      {errors.neighborhood && (
                        <HelperText
                          type="error"
                          visible={!!errors.neighborhood}
                        >
                          {errors.neighborhood.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />

                <Controller
                  control={control}
                  name="city"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="Ciudad"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.city}
                        mode="outlined"
                        placeholder="Ej: Ciudad de Mxico"
                        left={<TextInput.Icon icon="city" />}
                        outlineStyle={styles.inputOutline}
                      />
                      {errors.city && (
                        <HelperText type="error" visible={!!errors.city}>
                          {errors.city.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />

                <View style={styles.row}>
                  <View style={styles.halfInput}>
                    <Controller
                      control={control}
                      name="state"
                      render={({ field: { onChange, onBlur, value } }) => (
                        <View style={styles.inputContainer}>
                          <TextInput
                            label="Estado"
                            value={value}
                            onChangeText={onChange}
                            onBlur={onBlur}
                            error={!!errors.state}
                            mode="outlined"
                            placeholder="Ej: CDMX"
                            left={<TextInput.Icon icon="map-marker" />}
                            outlineStyle={styles.inputOutline}
                          />
                          {errors.state && (
                            <HelperText type="error" visible={!!errors.state}>
                              {errors.state.message}
                            </HelperText>
                          )}
                        </View>
                      )}
                    />
                  </View>

                  <View style={styles.halfInput}>
                    <Controller
                      control={control}
                      name="zipCode"
                      render={({ field: { onChange, onBlur, value } }) => (
                        <View style={styles.inputContainer}>
                          <TextInput
                            label="C.P."
                            value={value}
                            onChangeText={onChange}
                            onBlur={onBlur}
                            error={!!errors.zipCode}
                            mode="outlined"
                            placeholder="06700"
                            keyboardType="numeric"
                            maxLength={5}
                            left={<TextInput.Icon icon="mailbox" />}
                            outlineStyle={styles.inputOutline}
                          />
                          {errors.zipCode && (
                            <HelperText type="error" visible={!!errors.zipCode}>
                              {errors.zipCode.message}
                            </HelperText>
                          )}
                        </View>
                      )}
                    />
                  </View>
                </View>

                <Controller
                  control={control}
                  name="country"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="Pas"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        error={!!errors.country}
                        mode="outlined"
                        placeholder="Mxico"
                        left={<TextInput.Icon icon="earth" />}
                        outlineStyle={styles.inputOutline}
                      />
                      {errors.country && (
                        <HelperText type="error" visible={!!errors.country}>
                          {errors.country.message}
                        </HelperText>
                      )}
                    </View>
                  )}
                />
              </View>

              <View style={styles.sectionContainer}>
                <View style={styles.sectionHeader}>
                  <Text style={styles.sectionTitle} variant="titleMedium">
                    Informacin Adicional
                  </Text>
                  <Chip
                    mode="flat"
                    compact
                    style={styles.optionalChip}
                    textStyle={styles.optionalChipText}
                  >
                    Opcional
                  </Chip>
                </View>

                <Controller
                  control={control}
                  name="deliveryInstructions"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <View style={styles.inputContainer}>
                      <TextInput
                        label="Instrucciones de entrega"
                        value={value}
                        onChangeText={onChange}
                        onBlur={onBlur}
                        mode="outlined"
                        placeholder="Entre calles, color de fachada, etc."
                        multiline
                        numberOfLines={2}
                        left={<TextInput.Icon icon="sign-direction" />}
                        outlineStyle={styles.inputOutline}
                      />
                    </View>
                  )}
                />

                <View style={styles.locationWrapper}>
                  <View style={styles.locationHeader}>
                    <Text style={styles.locationLabel} variant="bodyMedium">
                      Ubicacin en el mapa
                    </Text>
                    {hasValidCoordinates && (
                      <Button
                        mode="text"
                        onPress={() => {
                          setValue('latitude', undefined);
                          setValue('longitude', undefined);
                          trigger(['latitude', 'longitude']);
                        }}
                        icon="close"
                        compact
                        style={styles.clearLocationBtn}
                      >
                        Limpiar
                      </Button>
                    )}
                  </View>

                  <Surface style={styles.mapContainer} elevation={1}>
                    <View style={styles.mapInstructions}>
                      <Icon
                        source="gesture-two-double-tap"
                        size={20}
                        color={theme.colors.primary}
                      />
                      <Text
                        style={styles.mapInstructionText}
                        variant="bodySmall"
                      >
                        Usa dos dedos para mover el mapa  Toca para marcar
                        ubicacin
                      </Text>
                    </View>

                    <View style={styles.mapView}>
                      {isLoadingApiKey || !mapHtml ? (
                        <View style={[styles.map, styles.mapLoadingContainer]}>
                          <ActivityIndicator
                            size="large"
                            color={theme.colors.primary}
                          />
                          <Text style={styles.mapLoadingText}>
                            Cargando mapa...
                          </Text>
                        </View>
                      ) : (
                        <WebView
                          ref={webViewRef}
                          source={{ html: mapHtml }}
                          style={styles.map}
                          onMessage={handleWebViewMessage}
                          onError={(_error) => {}}
                          javaScriptEnabled={true}
                          domStorageEnabled={true}
                          startInLoadingState={true}
                          mixedContentMode="compatibility"
                          allowsInlineMediaPlayback={true}
                          originWhitelist={['*']}
                          scalesPageToFit={false}
                          bounces={false}
                          scrollEnabled={false}
                          nestedScrollEnabled={false}
                        />
                      )}

                      {isMapLoading && (
                        <View style={styles.mapLoadingContainer}>
                          <Surface style={styles.mapLoadingCard} elevation={3}>
                            <ActivityIndicator
                              size="large"
                              color={theme.colors.primary}
                            />
                            <Text style={styles.mapLoadingText}>
                              Cargando mapa...
                            </Text>
                          </Surface>
                        </View>
                      )}

                      {mapReady && (
                        <>
                          <View style={styles.expandButtonContainer}>
                            <Button
                              mode="contained"
                              icon={
                                isMapFullscreen
                                  ? 'fullscreen-exit'
                                  : 'fullscreen'
                              }
                              onPress={() =>
                                setIsMapFullscreen(!isMapFullscreen)
                              }
                              style={styles.expandButton}
                              labelStyle={styles.expandButtonLabel}
                            >
                              {isMapFullscreen ? 'Cerrar' : 'Expandir mapa'}
                            </Button>
                          </View>

                          {hasValidCoordinates && (
                            <View style={styles.centerButtonContainer}>
                              <IconButton
                                icon="crosshairs-gps"
                                mode="contained"
                                containerColor={theme.colors.primaryContainer}
                                iconColor={theme.colors.onPrimaryContainer}
                                size={20}
                                onPress={() =>
                                  sendMessageToWebView('centerOnLocation', {})
                                }
                                style={styles.floatingButton}
                              />
                            </View>
                          )}
                        </>
                      )}
                    </View>

                    {hasValidCoordinates && (
                      <View style={styles.coordinatesContainer}>
                        <Text
                          variant="labelSmall"
                          style={styles.coordinatesLabel}
                        >
                          Coordenadas:
                        </Text>
                        <Text
                          variant="bodySmall"
                          style={styles.coordinatesText}
                        >
                          {Number(latitude).toFixed(6)},{' '}
                          {Number(longitude).toFixed(6)}
                        </Text>
                      </View>
                    )}
                  </Surface>
                </View>
              </View>

              <View style={styles.scrollSpacer} />
            </ScrollView>

            <Surface style={styles.buttonContainer} elevation={2}>
              <Button
                onPress={onDismiss}
                disabled={isSubmitting}
                style={[styles.button, styles.cancelButton]}
                textColor={theme.colors.onSecondaryContainer}
              >
                Cancelar
              </Button>
              <Button
                mode="contained"
                onPress={() => {
                  handleSubmit(handleFormSubmit, (validationErrors) => {
                    const errorMessages = Object.entries(validationErrors)
                      .map(([field, error]) => {
                        if (error && 'message' in error) {
                          const fieldNames: Record<string, string> = {
                            name: 'Nombre de la direccin',
                            street: 'Calle',
                            number: 'Nmero',
                            neighborhood: 'Colonia',
                            city: 'Ciudad',
                            state: 'Estado',
                            zipCode: 'Cdigo postal',
                            country: 'Pas',
                          };
                          const fieldName = fieldNames[field] || field;
                          return `${fieldName}: ${error.message}`;
                        }
                        return null;
                      })
                      .filter(Boolean);

                    if (errorMessages.length > 0) {
                      showSnackbar({
                        message: errorMessages[0] || 'Error de validacin',
                        type: 'error',
                      });

                      scrollViewRef.current?.scrollTo({
                        x: 0,
                        y: 0,
                        animated: true,
                      });
                    }
                  })();
                }}
                disabled={isSubmitting}
                loading={isSubmitting}
                style={[styles.button, styles.confirmButton]}
                buttonColor={theme.colors.primary}
              >
                {editingItem ? 'Guardar' : 'Crear'}
              </Button>
            </Surface>
          </Surface>
        </Modal>
      </Portal>

      <Portal>
        <Modal
          visible={isMapFullscreen}
          onDismiss={() => setIsMapFullscreen(false)}
          contentContainerStyle={styles.fullscreenModalContainer}
        >
          <Surface style={styles.fullscreenModalContent} elevation={5}>
            <View style={styles.fullscreenHeader}>
              <Text variant="titleLarge" style={styles.fullscreenTitle}>
                Ubicacin
              </Text>
              <IconButton
                icon="close"
                size={28}
                onPress={() => setIsMapFullscreen(false)}
                style={styles.fullscreenCloseButton}
              />
            </View>

            <View style={styles.fullscreenMapContainer}>
              <WebView
                source={{ html: mapHtml }}
                style={styles.map}
                onMessage={handleWebViewMessage}
                javaScriptEnabled={true}
                domStorageEnabled={true}
                startInLoadingState={false}
                mixedContentMode="compatibility"
                allowsInlineMediaPlayback={true}
                originWhitelist={['*']}
                scalesPageToFit={false}
              />

              {hasValidCoordinates && (
                <View style={styles.fullscreenCoordinates}>
                  <Surface style={styles.coordinatesBadge} elevation={3}>
                    <Icon
                      source="map-marker"
                      size={20}
                      color={theme.colors.primary}
                    />
                    <Text variant="bodyLarge" style={styles.coordinatesText}>
                      {Number(latitude).toFixed(6)},{' '}
                      {Number(longitude).toFixed(6)}
                    </Text>
                  </Surface>
                </View>
              )}
            </View>
          </Surface>
        </Modal>
      </Portal>
    </>
  );
}

const getStyles = (theme: AppTheme) =>
  StyleSheet.create({
    modalContainer: {
      margin: 10,
      justifyContent: 'center',
    },
    modalContent: {
      borderRadius: theme.roundness * 3,
      backgroundColor: theme.colors.surface,
      maxHeight: '95%',
      minHeight: '80%',
      overflow: 'hidden',
    },
    headerContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.xs,
      borderTopLeftRadius: theme.roundness * 3,
      borderTopRightRadius: theme.roundness * 3,
    },
    headerLeft: {
      flexDirection: 'row',
      alignItems: 'center',
      flex: 1,
    },
    headerIcon: {
      marginRight: theme.spacing.s,
    },
    headerTextContainer: {
      flex: 1,
    },
    modalTitle: {
      fontWeight: '700',
    },
    formContainer: {
      flex: 1,
      paddingHorizontal: theme.spacing.m,
      paddingTop: theme.spacing.xs,
    },
    sectionContainer: {
      marginBottom: theme.spacing.s,
    },
    sectionHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.xs,
    },
    sectionTitle: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      fontSize: 14,
    },
    requiredChip: {
      backgroundColor: theme.colors.errorContainer,
    },
    requiredChipText: {
      color: theme.colors.onErrorContainer,
      fontSize: 11,
    },
    optionalChip: {
      backgroundColor: theme.colors.surfaceVariant,
    },
    optionalChipText: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 11,
    },
    inputContainer: {
      marginBottom: theme.spacing.xs,
    },
    inputOutline: {
      borderRadius: theme.roundness * 2,
    },
    row: {
      flexDirection: 'row',
      gap: theme.spacing.s,
    },
    halfInput: {
      flex: 1,
    },
    locationWrapper: {
      marginTop: theme.spacing.m,
    },
    locationHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.s,
    },
    locationLabel: {
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    clearLocationBtn: {
      marginRight: -theme.spacing.s,
    },
    mapContainer: {
      borderRadius: theme.roundness * 2,
      overflow: 'hidden',
      backgroundColor: theme.colors.surface,
    },
    mapInstructions: {
      flexDirection: 'row',
      alignItems: 'center',
      padding: theme.spacing.s,
      backgroundColor: theme.colors.primaryContainer,
      gap: theme.spacing.s,
    },
    mapInstructionText: {
      flex: 1,
      color: theme.colors.onPrimaryContainer,
    },
    mapView: {
      height: 300,
      position: 'relative',
    },
    map: {
      ...StyleSheet.absoluteFillObject,
    },
    mapLoadingContainer: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      justifyContent: 'center',
      alignItems: 'center',
      backgroundColor: 'rgba(0, 0, 0, 0.3)',
    },
    mapLoadingCard: {
      padding: theme.spacing.xl,
      borderRadius: 16,
      alignItems: 'center',
      backgroundColor: theme.colors.surface,
    },
    mapLoadingText: {
      marginTop: theme.spacing.m,
      fontSize: 14,
      color: theme.colors.onSurface,
      fontWeight: '500',
    },
    expandButtonContainer: {
      position: 'absolute',
      top: theme.spacing.s,
      right: theme.spacing.s,
      zIndex: 10,
    },
    expandButton: {
      elevation: 4,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
    },
    expandButtonLabel: {
      fontSize: 14,
      fontWeight: '600',
    },
    centerButtonContainer: {
      position: 'absolute',
      bottom: theme.spacing.s,
      right: theme.spacing.s,
    },
    floatingButton: {
      elevation: 4,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
    },
    coordinatesContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      padding: theme.spacing.s,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      gap: theme.spacing.xs,
    },
    coordinatesLabel: {
      color: theme.colors.onSurfaceVariant,
    },
    coordinatesText: {
      fontWeight: '500',
      color: theme.colors.onSurface,
      fontFamily: 'monospace',
    },
    switchContainer: {
      borderRadius: theme.roundness * 2,
      padding: theme.spacing.xs,
      marginTop: theme.spacing.xs,
    },
    switchContent: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    switchTextContainer: {
      flex: 1,
      marginRight: theme.spacing.m,
    },
    switchLabel: {
      color: theme.colors.onSurface,
      fontWeight: '500',
    },
    switchDescription: {
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
      fontSize: 12,
    },
    buttonContainer: {
      flexDirection: 'row',
      justifyContent: 'center',
      padding: theme.spacing.s,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      gap: theme.spacing.s,
    },
    button: {
      flex: 1,
      maxWidth: 150,
    },
    cancelButton: {
      backgroundColor: theme.colors.secondaryContainer,
    },
    confirmButton: {},
    fullscreenModalContainer: {
      flex: 1,
      margin: 0,
    },
    fullscreenModalContent: {
      flex: 1,
      backgroundColor: theme.colors.surface,
    },
    fullscreenHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingLeft: theme.spacing.l,
      paddingRight: theme.spacing.s,
      paddingVertical: theme.spacing.s,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
      height: 56,
    },
    fullscreenTitle: {
      fontWeight: '600',
      color: theme.colors.onSurface,
      flex: 1,
    },
    fullscreenCloseButton: {
      margin: 0,
    },
    fullscreenMapContainer: {
      flex: 1,
      position: 'relative',
    },
    fullscreenCoordinates: {
      position: 'absolute',
      bottom: theme.spacing.m,
      left: theme.spacing.m,
    },
    coordinatesBadge: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.s,
      borderRadius: theme.roundness * 2,
      backgroundColor: theme.colors.surface,
      gap: theme.spacing.s,
    },
    scrollSpacer: {
      height: 10,
    },
  });

================
File: app/src/modules/kitchen/components/OrderCard.tsx
================
import React, { useRef, useState, useEffect } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  Animated,
  Pressable,
  Vibration,
} from 'react-native';
import { Text, Divider, Surface, IconButton } from 'react-native-paper';
import { MaterialCommunityIcons as Icon } from '@expo/vector-icons';
import { useAppTheme } from '@/app/styles/theme';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import {
  KitchenOrder,
  OrderTypeEnum,
  PreparationStatus,
  PreparationScreenStatus,
} from '../schema/kitchen.schema';
import { OrderItemRow } from './OrderItemRow';
import { useResponsive } from '@/app/hooks/useResponsive';
import { Swipeable } from 'react-native-gesture-handler';
import { OrderHistoryModal } from '@/modules/shared/components/OrderHistoryModal';
import { useMarkItemPrepared } from '../hooks/useKitchenOrders';

interface OrderCardProps {
  order: KitchenOrder;
  onStartPreparation?: (orderId: string) => void;
  onCancelPreparation?: (orderId: string) => void;
  onCompletePreparation?: (orderId: string) => void;
  onSwipeStart?: () => void;
  onSwipeEnd?: () => void;
}

export const OrderCard: React.FC<OrderCardProps> = ({
  order,
  onStartPreparation,
  onCancelPreparation,
  onCompletePreparation,
  onSwipeStart,
  onSwipeEnd,
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = createStyles(responsive, theme);
  const [isSwipeable, setIsSwipeable] = React.useState(false);
  const [showHistory, setShowHistory] = useState(false);
  const swipeableRef = useRef<Swipeable>(null);
  const [isPressing, setIsPressing] = useState(false);
  const longPressTimer = useRef<NodeJS.Timeout | null>(null);
  const animatedValue = useRef(new Animated.Value(0)).current;
  const markItemPrepared = useMarkItemPrepared();

  const getOrderTypeColor = () => {
    switch (order.orderType) {
      case OrderTypeEnum.DELIVERY:
        return theme.colors.error;
      case OrderTypeEnum.TAKE_AWAY:
        return '#00ACC1'; // Cyan/Turquesa
      case OrderTypeEnum.DINE_IN:
        return theme.colors.primary;
      default:
        return theme.colors.surface;
    }
  };

  const getOrderTypeLabel = () => {
    switch (order.orderType) {
      case OrderTypeEnum.DELIVERY:
        return 'DOMICILIO';
      case OrderTypeEnum.TAKE_AWAY:
        return 'PARA LLEVAR';
      case OrderTypeEnum.DINE_IN:
        return 'MESA';
      default:
        return '';
    }
  };

  const getOrderTypeBackgroundColor = () => {
    switch (order.orderType) {
      case OrderTypeEnum.DELIVERY:
        return '#FFEBEE'; // Rojo muy claro
      case OrderTypeEnum.TAKE_AWAY:
        return '#E0F2F1'; // Cyan/Turquesa muy claro
      case OrderTypeEnum.DINE_IN:
        return '#E3F2FD'; // Azul muy claro
      default:
        return theme.colors.surfaceVariant;
    }
  };

  const getOrderTypeTextColor = () => {
    switch (order.orderType) {
      case OrderTypeEnum.DELIVERY:
        return '#C62828';
      case OrderTypeEnum.TAKE_AWAY:
        return '#00838F';
      case OrderTypeEnum.DINE_IN:
        return '#1565C0';
      default:
        return theme.colors.onSurfaceVariant;
    }
  };

  const getOrderTypeIcon = () => {
    switch (order.orderType) {
      case OrderTypeEnum.DELIVERY:
        return 'moped';
      case OrderTypeEnum.TAKE_AWAY:
        return 'shopping-outline';
      case OrderTypeEnum.DINE_IN:
        return 'silverware-fork-knife';
      default:
        return 'help-circle-outline';
    }
  };

  // Calcular el estado de preparacin basado en myScreenStatus
  const getOrderPreparationStatus = () => {
    // Primero verificar si hay items
    if (!order.items || order.items.length === 0) {
      return {
        label: 'Sin items',
        color: '#E0E0E0',
        textColor: '#424242',
        borderColor: '#BDBDBD',
      };
    }

    const myItems = order.items.filter((item) => item.belongsToMyScreen);
    if (myItems.length === 0) {
      return {
        label: 'Sin items asignados',
        color: '#E0E0E0',
        textColor: '#424242',
        borderColor: '#BDBDBD',
      };
    }

    // Usar el estado de mi pantalla especfica
    switch (order.myScreenStatus) {
      case PreparationScreenStatus.READY:
        return {
          label: 'Lista',
          color: '#4CAF50',
          textColor: '#FFFFFF',
          borderColor: null,
        };

      case PreparationScreenStatus.IN_PREPARATION:
        return {
          label: 'En preparacin',
          color: '#FF6B35',
          textColor: '#FFFFFF',
          borderColor: null,
        };

      case PreparationScreenStatus.PENDING:
      default:
        return {
          label: 'Pendiente',
          color: '#9C27B0',
          textColor: '#FFFFFF',
          borderColor: null,
        };
    }
  };

  const hasOrderDetails = () => {
    switch (order.orderType) {
      case OrderTypeEnum.DELIVERY:
        return !!order.deliveryAddress;
      case OrderTypeEnum.TAKE_AWAY:
        return !!order.receiptName;
      case OrderTypeEnum.DINE_IN:
        return !!(order.areaName || order.tableName);
      default:
        return false;
    }
  };

  const orderStatus = getOrderPreparationStatus();

  // Verificar si mi pantalla est en preparacin
  const isOrderInPreparation =
    order.myScreenStatus === PreparationScreenStatus.IN_PREPARATION;

  const handleToggleItemPrepared = (itemId: string, currentStatus: boolean) => {
    markItemPrepared.mutate({
      itemId,
      isPrepared: !currentStatus,
    });
  };

  // Determinar qu acciones de swipe estn disponibles basado en myScreenStatus
  const getSwipeActions = () => {
    const rightAction = (() => {
      // Solo permitir iniciar preparacin si mi pantalla est PENDING
      if (order.myScreenStatus === PreparationScreenStatus.PENDING) {
        return {
          type: 'start',
          color: '#FF6B35',
          textColor: '#FFFFFF',
          icon: 'chef-hat',
          text: 'En Preparacin',
        };
      }
      return null;
    })();

    const leftAction = (() => {
      // Permitir regresar si mi pantalla est en preparacin o lista
      if (
        order.myScreenStatus === PreparationScreenStatus.IN_PREPARATION ||
        order.myScreenStatus === PreparationScreenStatus.READY
      ) {
        return {
          type: 'cancel',
          color: '#9C27B0',
          textColor: '#FFFFFF',
          icon: 'arrow-left',
          text: 'Regresar',
        };
      }
      return null;
    })();

    return { rightAction, leftAction };
  };

  const swipeActions = getSwipeActions();

  // Verificar si la orden puede hacer swipe
  React.useEffect(() => {
    setIsSwipeable(!!swipeActions.rightAction || !!swipeActions.leftAction);
  }, [swipeActions.rightAction, swipeActions.leftAction]);

  // Renderizar las acciones del swipe hacia la derecha (lo que aparece detrs)
  const renderRightActions = () => {
    if (!swipeActions.rightAction) return null;

    return (
      <View
        style={[
          styles.swipeAction,
          { backgroundColor: swipeActions.rightAction.color },
        ]}
      >
        <Icon
          name={swipeActions.rightAction.icon as any}
          size={24}
          color={swipeActions.rightAction.textColor}
        />
        <Text
          style={[
            styles.swipeText,
            { color: swipeActions.rightAction.textColor },
          ]}
        >
          {swipeActions.rightAction.text}
        </Text>
      </View>
    );
  };

  // Renderizar las acciones del swipe hacia la izquierda
  const renderLeftActions = () => {
    if (!swipeActions.leftAction) return null;

    return (
      <View
        style={[
          styles.swipeAction,
          { backgroundColor: swipeActions.leftAction.color },
        ]}
      >
        <Text
          style={[
            styles.swipeText,
            { color: swipeActions.leftAction.textColor },
          ]}
        >
          {swipeActions.leftAction.text}
        </Text>
        <Icon
          name={swipeActions.leftAction.icon as any}
          size={24}
          color={swipeActions.leftAction.textColor}
        />
      </View>
    );
  };

  // Verificar si la orden puede ser marcada como lista con long press
  const canMarkAsReady = () => {
    // Solo se puede marcar como lista si mi pantalla est en preparacin
    return (
      order.myScreenStatus === PreparationScreenStatus.IN_PREPARATION &&
      onCompletePreparation
    );
  };

  // Verificar si la orden puede regresar a en preparacin con long press
  const canReturnToInProgress = () => {
    // Solo permitir long press para regresar si mi pantalla est EN PREPARACIN (no READY)
    // Si est READY, debe usar el swipe
    return (
      order.myScreenStatus === PreparationScreenStatus.IN_PREPARATION &&
      onCancelPreparation
    );
  };

  // Manejar el inicio del long press
  const handlePressIn = () => {
    const canComplete = canMarkAsReady();
    const canReturn = canReturnToInProgress();

    if (!canComplete && !canReturn) return;

    if (longPressTimer.current) {
      clearTimeout(longPressTimer.current);
      if ((longPressTimer.current as any).interval) {
        clearInterval((longPressTimer.current as any).interval);
      }
      longPressTimer.current = null;
    }

    animatedValue.stopAnimation();
    animatedValue.setValue(0);

    Vibration.vibrate(10);

    setIsPressing(true);
    Animated.timing(animatedValue, {
      toValue: 1,
      duration: 2000,
      useNativeDriver: false,
    }).start();

    longPressTimer.current = setTimeout(() => {
      Vibration.vibrate([0, 50, 100, 50]);

      if (canComplete && onCompletePreparation) {
        onCompletePreparation(order.id);
      } else if (canReturn && onCancelPreparation) {
        onCancelPreparation(order.id);
      }

      setIsPressing(false);
      Animated.timing(animatedValue, {
        toValue: 0,
        duration: 200,
        useNativeDriver: false,
      }).start();
    }, 2000);
  };

  // Manejar cuando se suelta la presin
  const handlePressOut = () => {
    if (longPressTimer.current) {
      clearTimeout(longPressTimer.current);
      longPressTimer.current = null;
    }

    setIsPressing(false);

    animatedValue.stopAnimation();
    animatedValue.setValue(0);
  };

  useEffect(() => {
    return () => {
      if (longPressTimer.current) {
        clearTimeout(longPressTimer.current);
      }
    };
  }, []);

  // Manejar cuando se completa el swipe hacia la derecha
  const handleRightSwipeComplete = () => {
    if (!swipeActions.rightAction) return;

    switch (swipeActions.rightAction.type) {
      case 'start':
        if (onStartPreparation) onStartPreparation(order.id);
        break;
    }

    swipeableRef.current?.close();
  };

  // Manejar cuando se completa el swipe hacia la izquierda
  const handleLeftSwipeComplete = () => {
    if (!swipeActions.leftAction) return;

    if (swipeActions.leftAction.type === 'cancel') {
      if (onCancelPreparation) onCancelPreparation(order.id);
    }

    swipeableRef.current?.close();
  };

  return (
    <Surface
      style={[styles.card, { backgroundColor: theme.colors.surface }]}
      elevation={1}
    >
      <View style={styles.cardContent}>
        {isSwipeable ? (
          <Swipeable
            ref={swipeableRef}
            renderRightActions={renderRightActions}
            renderLeftActions={renderLeftActions}
            onSwipeableOpen={() => onSwipeStart && onSwipeStart()}
            onSwipeableClose={() => onSwipeEnd && onSwipeEnd()}
            onSwipeableRightOpen={handleRightSwipeComplete}
            onSwipeableLeftOpen={handleLeftSwipeComplete}
            overshootRight={false}
            overshootLeft={false}
            friction={1.2}
            rightThreshold={50}
            leftThreshold={50}
          >
            <Pressable
              onPressIn={handlePressIn}
              onPressOut={handlePressOut}
              delayLongPress={0}
            >
              <View
                style={[
                  styles.header,
                  styles.headerSwipeable,
                  { backgroundColor: getOrderTypeColor() },
                ]}
              >
                <View style={styles.headerLeft}>
                  <Text style={[styles.orderNumber, styles.headerText]}>
                    #{order.shiftOrderNumber}
                  </Text>
                  {hasOrderDetails() && (
                    <Text
                      style={[styles.headerDetails, styles.headerText]}
                      numberOfLines={2}
                    >
                      {(() => {
                        switch (order.orderType) {
                          case OrderTypeEnum.DELIVERY:
                            return ` ${order.deliveryAddress}${order.deliveryPhone ? `\n ${order.deliveryPhone}` : ''}`;
                          case OrderTypeEnum.TAKE_AWAY:
                            return ` ${order.receiptName}${order.customerPhone ? `\n ${order.customerPhone}` : ''}`;
                          case OrderTypeEnum.DINE_IN:
                            return ` ${order.areaName} - ${order.tableName}`;
                          default:
                            return '';
                        }
                      })()}
                    </Text>
                  )}

                  {/* Badge de WhatsApp */}
                  {order.isFromWhatsApp && (
                    <View style={styles.whatsappBadgeContainer}>
                      <View style={styles.whatsappBadge}>
                        <Icon
                          name="whatsapp"
                          size={12}
                          color={theme.colors.surface}
                        />
                      </View>
                    </View>
                  )}
                </View>
                <View style={[styles.headerRight, styles.headerRightSwipeable]}>
                  <View style={[styles.typeChip, styles.typeChipSwipeable]}>
                    <Icon
                      name={getOrderTypeIcon()}
                      size={responsive.isWeb ? 18 : 14}
                      color={theme.colors.surface}
                      style={styles.typeChipIcon}
                    />
                    <Text style={[styles.typeChipText, styles.headerText]}>
                      {getOrderTypeLabel()}
                    </Text>
                  </View>
                  <View
                    style={[
                      styles.statusChip,
                      styles.statusChipSwipeable,
                      { backgroundColor: orderStatus.color },
                      orderStatus.label === 'En progreso'
                        ? styles.statusChipWithBorder
                        : null,
                    ]}
                  >
                    <Text
                      style={[
                        styles.statusChipText,
                        {
                          color:
                            orderStatus.label === 'En progreso'
                              ? theme.colors.onSurface
                              : theme.colors.surface,
                        },
                      ]}
                    >
                      {orderStatus.label}
                    </Text>
                  </View>
                  <Text style={[styles.headerTime, styles.headerText]}>
                    {format(new Date(order.createdAt), 'HH:mm', { locale: es })}
                  </Text>
                </View>
              </View>
              {isPressing && (canMarkAsReady() || canReturnToInProgress()) && (
                <View style={styles.progressBarContainer}>
                  <Animated.View
                    style={[
                      styles.progressBar,
                      canMarkAsReady()
                        ? styles.progressBarReady
                        : styles.progressBarInProgress,
                      {
                        width: animatedValue.interpolate({
                          inputRange: [0, 1],
                          outputRange: ['0%', '100%'],
                        }),
                      },
                    ]}
                  />
                </View>
              )}
            </Pressable>
          </Swipeable>
        ) : (
          <View
            style={[
              styles.header,
              styles.headerSwipeable,
              { backgroundColor: getOrderTypeColor() },
            ]}
          >
            <View style={styles.headerLeft}>
              <Text style={[styles.orderNumber, styles.headerText]}>
                #{order.shiftOrderNumber}
              </Text>
              {hasOrderDetails() && (
                <Text
                  style={[styles.headerDetails, styles.headerText]}
                  numberOfLines={2}
                >
                  {(() => {
                    switch (order.orderType) {
                      case OrderTypeEnum.DELIVERY:
                        return ` ${order.deliveryAddress}${order.deliveryPhone ? `\n ${order.deliveryPhone}` : ''}`;
                      case OrderTypeEnum.TAKE_AWAY:
                        return ` ${order.receiptName}${order.customerPhone ? `\n ${order.customerPhone}` : ''}`;
                      case OrderTypeEnum.DINE_IN:
                        return ` ${order.areaName} - ${order.tableName}`;
                      default:
                        return '';
                    }
                  })()}
                </Text>
              )}
            </View>
            <View style={[styles.headerRight, styles.headerRightNormal]}>
              <View
                style={[
                  styles.typeChip,
                  styles.typeChipNormal,
                  { backgroundColor: getOrderTypeBackgroundColor() },
                ]}
              >
                <Icon
                  name={getOrderTypeIcon()}
                  size={responsive.isTablet ? 13 : 14}
                  color={getOrderTypeTextColor()}
                  style={styles.typeChipIcon}
                />
                <Text
                  style={[
                    styles.typeChipText,
                    { color: getOrderTypeTextColor() },
                  ]}
                >
                  {getOrderTypeLabel()}
                </Text>
              </View>
              <View
                style={[
                  styles.statusChip,
                  styles.statusChipNormal,
                  { backgroundColor: orderStatus.color },
                  orderStatus.borderColor
                    ? [
                        styles.statusChipWithBorderColor,
                        { borderColor: orderStatus.borderColor },
                      ]
                    : null,
                ]}
              >
                <Text
                  style={[
                    styles.statusChipText,
                    { color: orderStatus.textColor },
                  ]}
                >
                  {orderStatus.label}
                </Text>
              </View>
              <Text
                style={[styles.headerTime, { color: theme.colors.surface }]}
              >
                {format(new Date(order.createdAt), 'HH:mm', { locale: es })}
              </Text>
            </View>
          </View>
        )}

        {order.orderNotes && (
          <>
            <View
              style={[
                styles.details,
                { backgroundColor: theme.colors.errorContainer },
              ]}
            >
              <Text
                variant="bodyMedium"
                style={[styles.notes, { color: theme.colors.onErrorContainer }]}
              >
                 {order.orderNotes}
              </Text>
            </View>
            <Divider style={styles.divider} />
          </>
        )}

        {order.screenStatuses && order.screenStatuses.length > 1 && (
          <>
            <View
              style={[
                styles.screenStatusContainer,
                styles.screenStatusContainerWithBackground,
              ]}
            >
              <ScrollView horizontal showsHorizontalScrollIndicator={false}>
                <View
                  style={[
                    styles.screenStatusList,
                    styles.screenStatusListWithGap,
                  ]}
                >
                  {order.screenStatuses.map((screenStatus) => (
                    <View
                      key={screenStatus.screenId}
                      style={[
                        styles.screenStatusItem,
                        {
                          backgroundColor: (() => {
                            switch (screenStatus.status) {
                              case PreparationScreenStatus.READY:
                                return '#4CAF50';
                              case PreparationScreenStatus.IN_PREPARATION:
                                return '#FF6B35';
                              default:
                                return '#9C27B0';
                            }
                          })(),
                        },
                      ]}
                    >
                      <Text style={styles.screenStatusText}>
                        {screenStatus.screenName}
                      </Text>
                    </View>
                  ))}
                </View>
              </ScrollView>
            </View>
            <Divider style={styles.divider} />
          </>
        )}

        <View style={styles.itemsWrapper}>
          {order.items && order.items.length > 0 ? (
            <ScrollView
              style={styles.itemsContainer}
              showsVerticalScrollIndicator={true}
              nestedScrollEnabled={true}
            >
              {(() => {
                const myScreenItems = order.items
                  .map((item, originalIndex) => ({ item, originalIndex }))
                  .filter(({ item }) => item.belongsToMyScreen);

                const otherScreenItems = order.items
                  .map((item, originalIndex) => ({ item, originalIndex }))
                  .filter(({ item }) => !item.belongsToMyScreen);

                const sortedMyScreenItems = myScreenItems.sort((a, b) => {
                  const aIsPrepared =
                    a.item.preparationStatus === PreparationStatus.READY;
                  const bIsPrepared =
                    b.item.preparationStatus === PreparationStatus.READY;

                  if (aIsPrepared === bIsPrepared) {
                    return a.originalIndex - b.originalIndex;
                  }

                  return a.originalIndex - b.originalIndex;
                });

                const sortedOtherScreenItems = otherScreenItems;

                return [...sortedMyScreenItems, ...sortedOtherScreenItems];
              })().map(({ item }, index) => (
                <OrderItemRow
                  key={`${item.id}-${index}`}
                  item={item}
                  onTogglePrepared={handleToggleItemPrepared}
                  isOrderInPreparation={isOrderInPreparation}
                />
              ))}
            </ScrollView>
          ) : (
            <View style={styles.emptyItemsContainer}>
              <Text variant="bodyLarge" style={styles.emptyItemsText}>
                No hay productos para mostrar
              </Text>
            </View>
          )}
        </View>

        <View style={styles.floatingButtonContainer}>
          <IconButton
            icon="file-document-multiple-outline"
            size={responsive.isWeb ? 32 : 28}
            iconColor={theme.colors.surface}
            style={[
              styles.floatingButton,
              styles.floatingButtonBackground,
              responsive.isWeb
                ? styles.floatingButtonWeb
                : styles.floatingButtonMobile,
            ]}
            onPress={() => setShowHistory(true)}
          />
        </View>
      </View>

      <OrderHistoryModal
        visible={showHistory}
        onDismiss={() => setShowHistory(false)}
        orderId={order.id}
        orderNumber={order.shiftOrderNumber}
      />
    </Surface>
  );
};

const createStyles = (responsive: any, theme: any) =>
  StyleSheet.create({
    card: {
      width: '100%',
      height: '100%',
      maxHeight:
        responsive.height -
        responsive.dimensions.headerHeight -
        responsive.spacingPreset.s,
      borderRadius: theme.roundness / 2,
      borderWidth: 0.5,
      borderColor: 'rgba(0,0,0,0.05)',
    },
    cardContent: {
      flex: 1,
      display: 'flex',
      flexDirection: 'column',
      position: 'relative',
    },
    header: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
      paddingHorizontal: responsive.isWeb
        ? responsive.spacingPreset.l
        : responsive.spacingPreset.m,
      paddingVertical: responsive.isWeb
        ? responsive.spacingPreset.m
        : responsive.spacingPreset.s,
      borderTopLeftRadius: theme.roundness,
      borderTopRightRadius: theme.roundness,
      minHeight: responsive.isWeb
        ? 80
        : responsive.getResponsiveDimension(50, 60),
    },
    headerLeft: {
      flex: 1,
      flexDirection: 'column',
      gap: responsive.spacingPreset.xxxs,
    },
    headerTopRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.spacingPreset.xs,
    },
    headerDetails: {
      fontSize: responsive.isWeb ? 16 : responsive.isTablet ? 12 : 13,
      lineHeight: responsive.isWeb ? 22 : responsive.isTablet ? 16 : 18,
      opacity: 0.95,
      marginTop: responsive.spacingPreset.xxxs,
      fontWeight: '500',
    },
    headerRight: {
      alignItems: 'flex-end',
      gap: responsive.spacingPreset.xs,
      marginLeft: responsive.spacingPreset.xs,
    },
    orderNumber: {
      fontWeight: 'bold',
      fontSize: responsive.isWeb ? 24 : responsive.isTablet ? 18 : 20,
      lineHeight: responsive.isWeb ? 32 : responsive.isTablet ? 24 : 28,
    },
    typeChip: {
      paddingHorizontal: responsive.isWeb
        ? responsive.spacingPreset.m
        : responsive.spacingPreset.s,
      paddingVertical: responsive.isWeb ? 6 : 4,
      minHeight: responsive.isWeb ? 36 : 28,
      borderRadius: theme.roundness / 2,
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      alignSelf: 'flex-end',
      marginBottom: responsive.spacingPreset.xxxs,
    },
    typeChipText: {
      fontSize: responsive.isWeb ? 14 : responsive.isTablet ? 11 : 12,
      fontWeight: '700',
      letterSpacing: 0.4,
      textAlign: 'center',
      textAlignVertical: 'center',
      lineHeight: responsive.isTablet ? 16 : 18,
      includeFontPadding: false,
    },
    headerTime: {
      fontWeight: '500',
      fontSize: responsive.isWeb ? 16 : responsive.isTablet ? 12 : 13,
    },
    statusChip: {
      paddingHorizontal: responsive.isWeb
        ? responsive.spacingPreset.m
        : responsive.spacingPreset.xs,
      paddingVertical: responsive.isWeb ? 6 : 4,
      minHeight: responsive.isWeb ? 36 : 28,
      borderRadius: theme.roundness / 2,
      alignItems: 'center',
      justifyContent: 'center',
      alignSelf: 'flex-end',
      marginBottom: responsive.spacingPreset.xxxs,
    },
    statusChipText: {
      fontSize: responsive.isWeb ? 15 : responsive.isTablet ? 12 : 13,
      fontWeight: '600',
      letterSpacing: 0.3,
      textAlign: 'center',
      textAlignVertical: 'center',
      lineHeight: responsive.isWeb ? 22 : responsive.isTablet ? 18 : 20,
      includeFontPadding: false,
    },
    details: {
      paddingHorizontal: responsive.isWeb
        ? responsive.spacingPreset.m
        : responsive.spacingPreset.s,
      paddingVertical: responsive.isWeb
        ? responsive.spacingPreset.s
        : responsive.spacingPreset.xs,
    },
    detailText: {
      marginBottom: 0,
      fontSize: responsive.isWeb ? 15 : responsive.isTablet ? 11 : 12,
      lineHeight: responsive.isWeb ? 20 : responsive.isTablet ? 16 : 14,
    },
    notesContainer: {
      marginTop: responsive.spacingPreset.xxs,
      padding: responsive.spacingPreset.xxs,
      borderRadius: theme.roundness / 2,
    },
    notes: {
      fontStyle: 'italic',
      fontSize: responsive.isTablet ? 11 : 12,
      lineHeight: responsive.isTablet ? 16 : 14,
    },
    itemsWrapper: {
      flex: 1,
      minHeight: responsive.isTablet ? 100 : 60,
    },
    itemsContainer: {
      flex: 1,
    },
    emptyItemsContainer: {
      padding: responsive.spacingPreset.s,
      alignItems: 'center',
      justifyContent: 'center',
      minHeight: responsive.getResponsiveDimension(60, 80),
    },
    swipeAction: {
      width: 120,
      height: '100%',
      justifyContent: 'center',
      alignItems: 'center',
      flexDirection: 'row',
      gap: responsive.spacingPreset.xs,
      paddingHorizontal: responsive.spacingPreset.s,
    },
    swipeText: {
      fontWeight: 'bold',
      fontSize: responsive.fontSizePreset.s,
    },
    screenStatusContainer: {
      paddingVertical: responsive.spacingPreset.s,
      paddingHorizontal: responsive.spacingPreset.s,
      paddingRight: responsive.spacingPreset.m,
    },
    screenStatusList: {
      flexDirection: 'row',
      gap: responsive.spacingPreset.s,
      paddingHorizontal: responsive.spacingPreset.xs,
    },
    screenStatusItem: {
      paddingHorizontal: responsive.spacingPreset.s,
      paddingVertical: responsive.spacingPreset.xs,
      borderRadius: theme.roundness / 2,
      minHeight: 24,
      justifyContent: 'center',
    },
    screenStatusText: {
      fontSize: responsive.fontSizePreset.xs,
      fontWeight: '600',
      color: '#FFFFFF',
    },
    whatsappBadgeContainer: {
      marginTop: 4,
      alignItems: 'flex-start',
    },
    whatsappBadge: {
      width: 24,
      height: 24,
      borderRadius: 12,
      alignItems: 'center',
      justifyContent: 'center',
      elevation: 2,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 1 },
      shadowOpacity: 0.2,
      shadowRadius: 2,
      backgroundColor: '#25D366',
    },
    headerText: {
      color: theme.colors.surface,
    },
    headerSwipeable: {
      paddingHorizontal: responsive.spacingPreset.s,
    },
    headerRightSwipeable: {
      marginLeft: responsive.spacingPreset.xs,
    },
    headerRightNormal: {
      marginLeft: responsive.spacingPreset.m,
    },
    typeChipSwipeable: {
      backgroundColor: 'rgba(255, 255, 255, 0.2)',
      marginTop: 2,
      marginBottom: 3,
    },
    typeChipNormal: {
      marginTop: 2,
      marginBottom: 3,
    },
    typeChipIcon: {
      marginRight: 4,
    },
    statusChipSwipeable: {
      marginBottom: 2,
    },
    statusChipNormal: {
      marginBottom: 2,
    },
    progressBarContainer: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      height: 20,
      backgroundColor: 'rgba(0, 0, 0, 0.2)',
      overflow: 'hidden',
    },
    progressBar: {
      height: '100%',
    },
    notesContainerAlt: {
      backgroundColor: theme.colors.errorContainer,
    },
    notesText: {
      color: theme.colors.onErrorContainer,
    },
    divider: {
      backgroundColor: theme.colors.outlineVariant,
      height: 0.5,
    },
    screenStatusContainerStyle: {
      backgroundColor: theme.colors.surfaceVariant,
      paddingVertical: responsive.spacingPreset.s,
      paddingHorizontal: responsive.spacingPreset.s,
    },
    emptyItemsText: {
      color: theme.colors.onSurfaceVariant,
      opacity: 0.6,
    },
    floatingButtonContainer: {
      position: 'absolute',
      bottom: 10,
      right: 10,
      width: 48,
      height: 48,
    },
    floatingButton: {
      elevation: 6,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 3 },
      shadowOpacity: 0.3,
      shadowRadius: 4.65,
      margin: 0,
      opacity: 0.7,
    },
    statusChipWithBorder: {
      borderWidth: 1,
      borderColor: theme.colors.outline,
    },
    progressBarReady: {
      backgroundColor: theme.colors.success,
    },
    progressBarInProgress: {
      backgroundColor: '#FF6B35',
    },
    screenStatusContainerWithBackground: {
      backgroundColor: theme.colors.surfaceVariant,
      paddingVertical: 8,
      paddingHorizontal: 8,
    },
    screenStatusListWithGap: {
      gap: 8,
    },
    floatingButtonBackground: {
      backgroundColor: theme.colors.primary,
    },
    floatingButtonWeb: {
      width: 56,
      height: 56,
      borderRadius: 28,
    },
    floatingButtonMobile: {
      width: 48,
      height: 48,
      borderRadius: 24,
    },
    statusChipWithBorderColor: {
      borderWidth: 1,
    },
  });

================
File: app/src/modules/orders/components/PaymentModal.tsx
================
import React, { useState, useEffect, useMemo, useRef } from 'react';
import {
  View,
  ScrollView,
  StyleSheet,
  TouchableOpacity,
  Keyboard,
} from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  RadioButton,
  TextInput,
  HelperText,
  Divider,
  IconButton,
  Chip,
  ActivityIndicator,
  Surface,
} from 'react-native-paper';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import {
  PaymentMethodEnum,
  PaymentStatusEnum,
  type PaymentMethod,
} from '../schema/payment.schema';
import {
  useGetPaymentsByOrderIdQuery,
  useCreatePaymentMutation,
  useDeletePaymentMutation,
} from '../hooks/usePaymentQueries';
import { useCompleteOrderMutation } from '../hooks/useOrdersQueries';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
import ChangeCalculatorModal from './ChangeCalculatorModal';
import { prepaymentService } from '@/modules/payments/services/prepaymentService';
import { OrderStatusInfo, formatPaymentMethod } from '../utils/formatters';

interface PaymentModalProps {
  visible: boolean;
  onDismiss: () => void;
  orderId?: string; // Opcional para modo pre-pago
  orderTotal: number;
  orderNumber?: number;
  orderStatus?: string; // Estado de la orden
  onOrderCompleted?: () => void; // Callback cuando se completa la orden
  mode?: 'payment' | 'prepayment'; // Modo del modal
  onPrepaymentCreated?: (
    prepaymentId: string,
    amount: number,
    method: PaymentMethod,
  ) => void; // Callback para pre-pago
  existingPrepaymentId?: string; // ID del pre-pago existente para edicin
  onPrepaymentDeleted?: () => void; // Callback para eliminar pre-pago
}

// Mtodos de pago deshabilitados temporalmente
const DISABLED_METHODS: PaymentMethod[] = ['CARD', 'TRANSFER'];

export const PaymentModal: React.FC<PaymentModalProps> = ({
  visible,
  onDismiss,
  orderId,
  orderTotal,
  orderNumber,
  orderStatus,
  onOrderCompleted,
  mode = 'payment',
  onPrepaymentCreated,
  existingPrepaymentId,
  onPrepaymentDeleted,
}) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const scrollViewRef = useRef<ScrollView>(null);
  const amountInputRef = useRef<View>(null);

  // Estado del formulario
  const [selectedMethod, setSelectedMethod] = useState<PaymentMethod>(
    PaymentMethodEnum.CASH,
  );
  const [amount, setAmount] = useState('');
  const [showChangeCalculator, setShowChangeCalculator] = useState(false);
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
  const [paymentToDelete, setPaymentToDelete] = useState<string | null>(null);
  const [keyboardVisible, setKeyboardVisible] = useState(false);
  const [showFinalizeConfirm, setShowFinalizeConfirm] = useState(false);
  const [isCreatingPrepayment, setIsCreatingPrepayment] = useState(false);
  const [showDeletePrepaymentConfirm, setShowDeletePrepaymentConfirm] =
    useState(false);

  // Queries y mutations (solo para modo payment)
  const { data: payments = [], isLoading: isLoadingPayments } =
    useGetPaymentsByOrderIdQuery(orderId || '', {
      enabled: mode === 'payment' && !!orderId,
    });
  const createPaymentMutation = useCreatePaymentMutation();
  const deletePaymentMutation = useDeletePaymentMutation();
  const completeOrderMutation = useCompleteOrderMutation();

  // Calcular totales
  const totalPaid = useMemo(() => {
    if (mode === 'prepayment') {
      return 0; // En modo pre-pago, no hay pagos previos
    }
    return (payments || [])
      .filter((p) => p.paymentStatus === PaymentStatusEnum.COMPLETED)
      .reduce((sum, payment) => sum + (Number(payment.amount) || 0), 0);
  }, [payments, mode]);

  const pendingAmount = orderTotal - totalPaid;
  const isFullyPaid = pendingAmount <= 0;

  // Resetear formulario cuando se abre el modal
  useEffect(() => {
    if (visible) {
      if (mode === 'prepayment') {
        setAmount(orderTotal.toFixed(2));
      } else {
        setAmount(pendingAmount > 0 ? pendingAmount.toFixed(2) : '');
      }
      setShowChangeCalculator(false);
      setSelectedMethod(PaymentMethodEnum.CASH);
    }
  }, [visible, pendingAmount, orderTotal, mode]);

  // Manejar el teclado
  useEffect(() => {
    const keyboardDidShowListener = Keyboard.addListener(
      'keyboardDidShow',
      () => {
        setKeyboardVisible(true);
        // Pequeo delay para asegurar que el layout est actualizado
        setTimeout(() => {
          if (amountInputRef.current && scrollViewRef.current) {
            amountInputRef.current.measureLayout(
              scrollViewRef.current as any,
              (_, y) => {
                scrollViewRef.current?.scrollTo({ y: y - 50, animated: true });
              },
              () => {},
            );
          }
        }, 100);
      },
    );

    const keyboardDidHideListener = Keyboard.addListener(
      'keyboardDidHide',
      () => {
        setKeyboardVisible(false);
      },
    );

    return () => {
      keyboardDidShowListener.remove();
      keyboardDidHideListener.remove();
    };
  }, []);

  const handleSubmit = async () => {
    const parsedAmount = parseFloat(amount);

    if (isNaN(parsedAmount) || parsedAmount <= 0) {
      return;
    }

    // Si es efectivo, mostrar calculadora de cambio
    if (selectedMethod === PaymentMethodEnum.CASH) {
      setShowChangeCalculator(true);
      return;
    }

    // Para otros mtodos de pago, procesar directamente
    await processPayment();
  };

  const processPayment = async () => {
    const parsedAmount = parseFloat(amount);

    try {
      if (mode === 'prepayment') {
        // Crear pre-pago
        setIsCreatingPrepayment(true);
        const prepayment = await prepaymentService.createPrepayment({
          paymentMethod: selectedMethod,
          amount: parsedAmount,
        });

        // Notificar al componente padre
        onPrepaymentCreated?.(prepayment.id, parsedAmount, selectedMethod);

        // Cerrar el modal
        onDismiss();
      } else {
        // Crear pago normal
        await createPaymentMutation.mutateAsync({
          orderId: orderId!,
          paymentMethod: selectedMethod,
          amount: parsedAmount,
        });

        // Resetear formulario
        setAmount('');
        setShowChangeCalculator(false);

        // Si ya est totalmente pagado, cerrar el modal
        if (pendingAmount - parsedAmount <= 0) {
          onDismiss();
        }
      }
    } catch (error) {
      // Error ya manejado por el mutation hook
    } finally {
      setIsCreatingPrepayment(false);
    }
  };

  const handleDeletePayment = async () => {
    if (!paymentToDelete) return;

    try {
      await deletePaymentMutation.mutateAsync(paymentToDelete);
      setShowDeleteConfirm(false);
      setPaymentToDelete(null);
    } catch (error) {}
  };

  const handleFinalizeOrder = async () => {
    try {
      await completeOrderMutation.mutateAsync(orderId);
      setShowFinalizeConfirm(false);

      // Llamar al callback si existe
      if (onOrderCompleted) {
        onOrderCompleted();
      } else {
        // Si no hay callback, solo cerrar el modal
        onDismiss();
      }
    } catch (error) {}
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case PaymentStatusEnum.COMPLETED:
        return '#4CAF50';
      case PaymentStatusEnum.PENDING:
        return theme.colors.primary;
      case PaymentStatusEnum.CANCELLED:
        return theme.colors.error;
      case PaymentStatusEnum.FAILED:
        return theme.colors.error;
      case PaymentStatusEnum.REFUNDED:
        return '#FF9800';
      default:
        return theme.colors.onSurfaceVariant;
    }
  };

  const getStatusText = (status: string) => {
    switch (status) {
      case PaymentStatusEnum.COMPLETED:
        return 'Completado';
      case PaymentStatusEnum.PENDING:
        return 'Pendiente';
      case PaymentStatusEnum.CANCELLED:
        return 'Cancelado';
      case PaymentStatusEnum.FAILED:
        return 'Fallido';
      case PaymentStatusEnum.REFUNDED:
        return 'Reembolsado';
      default:
        return status;
    }
  };

  const handleDeletePrepayment = async () => {
    if (!existingPrepaymentId) return;

    try {
      setIsCreatingPrepayment(true);
      await prepaymentService.deletePrepayment(existingPrepaymentId);
      onPrepaymentDeleted?.();
      setShowDeletePrepaymentConfirm(false);
      onDismiss();
    } catch (error) {
      // Error manejado en el servicio
    } finally {
      setIsCreatingPrepayment(false);
    }
  };

  return (
    <Portal>
      <Modal
        visible={visible && !showChangeCalculator}
        onDismiss={onDismiss}
        contentContainerStyle={styles.modalContainer}
      >
        <View style={styles.modalWrapper}>
          <Surface style={styles.modalContent} elevation={3}>
            {/* Header */}
            <View style={styles.header}>
              <View style={styles.headerTextContainer}>
                <Text style={styles.title}>
                  {mode === 'prepayment' ? 'Registrar Pago' : 'Pagos'}
                </Text>
                {orderNumber && mode !== 'prepayment' && (
                  <Text style={styles.orderNumber}>Orden #{orderNumber}</Text>
                )}
                {mode === 'prepayment' && (
                  <Text style={styles.orderNumber}>Pago anticipado</Text>
                )}
              </View>
              <IconButton icon="close" size={24} onPress={onDismiss} />
            </View>

            <Divider />

            <ScrollView
              ref={scrollViewRef}
              style={[
                styles.scrollView,
                keyboardVisible && styles.scrollViewWithKeyboard,
              ]}
              contentContainerStyle={styles.scrollViewContent}
              showsVerticalScrollIndicator={true}
              keyboardShouldPersistTaps="handled"
              bounces={true}
              nestedScrollEnabled={true}
            >
              {/* Resumen de pagos */}
              <View style={styles.summaryContainer}>
                <View style={styles.summaryItem}>
                  <Text style={styles.summaryLabel}>Total</Text>
                  <Text style={styles.summaryAmount}>
                    ${orderTotal.toFixed(2)}
                  </Text>
                </View>
                {mode !== 'prepayment' && (
                  <>
                    <View style={styles.summaryDividerVertical} />
                    <View style={styles.summaryItem}>
                      <Text style={styles.summaryLabel}>Pagado</Text>
                      <Text
                        style={[styles.summaryAmount, styles.summaryAmountPaid]}
                      >
                        ${totalPaid.toFixed(2)}
                      </Text>
                    </View>
                    <View style={styles.summaryDividerVertical} />
                    <View style={styles.summaryItem}>
                      <Text
                        style={[
                          styles.summaryLabel,
                          styles.summaryLabelPending,
                        ]}
                      >
                        Pendiente
                      </Text>
                      <Text
                        style={[
                          styles.summaryAmount,
                          styles.summaryAmountPendingBold,
                          pendingAmount > 0
                            ? styles.summaryAmountError
                            : styles.summaryAmountPaid,
                        ]}
                      >
                        ${pendingAmount.toFixed(2)}
                      </Text>
                    </View>
                  </>
                )}
              </View>

              {/* Lista de pagos existentes - Solo mostrar en modo payment */}
              {mode === 'payment' && (
                <>
                  {isLoadingPayments ? (
                    <ActivityIndicator style={styles.loader} />
                  ) : (payments || []).length > 0 ? (
                    <View style={styles.paymentsSection}>
                      <Text style={styles.sectionTitle}>Pagos registrados</Text>
                      {(payments || []).map((payment) => (
                        <View key={payment.id} style={styles.paymentItem}>
                          <View style={styles.paymentLeftInfo}>
                            <View style={styles.paymentMethodRow}>
                              <Text style={styles.paymentMethodCompact}>
                                {formatPaymentMethod(payment.paymentMethod)}
                              </Text>
                            </View>
                            <Text style={styles.paymentDateCompact}>
                              {new Date(payment.createdAt).toLocaleTimeString(
                                'es-MX',
                                {
                                  hour: '2-digit',
                                  minute: '2-digit',
                                },
                              )}
                            </Text>
                          </View>

                          <View style={styles.paymentRightInfo}>
                            <Text style={styles.paymentAmountCompact}>
                              ${(Number(payment.amount) || 0).toFixed(2)}
                            </Text>

                            <Chip
                              mode="flat"
                              style={[
                                styles.statusChipCompact,
                                {
                                  backgroundColor: getStatusColor(
                                    payment.paymentStatus,
                                  ),
                                },
                              ]}
                              textStyle={styles.statusChipTextCompact}
                            >
                              {getStatusText(payment.paymentStatus)}
                            </Chip>

                            <IconButton
                              icon="delete"
                              size={20}
                              iconColor={theme.colors.error}
                              onPress={() => {
                                setPaymentToDelete(payment.id);
                                setShowDeleteConfirm(true);
                              }}
                              disabled={deletePaymentMutation.isPending}
                              style={styles.deleteIconButton}
                            />
                          </View>
                        </View>
                      ))}
                    </View>
                  ) : null}
                </>
              )}

              {/* Formulario para nuevo pago */}
              {(mode === 'prepayment' || !isFullyPaid) && (
                <View style={styles.formSection}>
                  <Text style={styles.sectionTitle}>
                    {mode === 'prepayment'
                      ? 'Configurar pago'
                      : 'Registrar nuevo pago'}
                  </Text>

                  {/* Mtodos de pago */}
                  <View style={styles.methodsContainer}>
                    {Object.entries(PaymentMethodEnum).map(([key, value]) => {
                      const isDisabled = DISABLED_METHODS.includes(
                        value as PaymentMethod,
                      );
                      return (
                        <TouchableOpacity
                          key={key}
                          style={[
                            styles.methodCard,
                            selectedMethod === value &&
                              styles.methodCardSelected,
                            isDisabled && styles.methodCardDisabled,
                          ]}
                          onPress={() =>
                            !isDisabled && setSelectedMethod(value)
                          }
                          disabled={isDisabled}
                        >
                          <RadioButton
                            value={value}
                            status={
                              selectedMethod === value ? 'checked' : 'unchecked'
                            }
                            onPress={() =>
                              !isDisabled && setSelectedMethod(value)
                            }
                            disabled={isDisabled}
                          />
                          <View style={styles.methodLabelContainer}>
                            <Text
                              style={[
                                styles.methodText,
                                selectedMethod === value &&
                                  styles.methodTextSelected,
                                isDisabled && styles.methodTextDisabled,
                              ]}
                            >
                              {formatPaymentMethod(value)}
                            </Text>
                            {isDisabled && (
                              <Text style={styles.comingSoonText}>
                                Prximamente
                              </Text>
                            )}
                          </View>
                        </TouchableOpacity>
                      );
                    })}
                  </View>

                  {/* Campo de monto */}
                  <View style={styles.amountContainer} ref={amountInputRef}>
                    <View style={styles.amountRow}>
                      <TextInput
                        label="Monto a pagar"
                        value={amount}
                        onChangeText={setAmount}
                        keyboardType="decimal-pad"
                        mode="outlined"
                        left={<TextInput.Affix text="$" />}
                        style={styles.amountInput}
                        error={
                          amount !== '' &&
                          (isNaN(parseFloat(amount)) || parseFloat(amount) <= 0)
                        }
                      />
                      <Button
                        mode="outlined"
                        onPress={() => setAmount(pendingAmount.toFixed(2))}
                        style={styles.totalPendingButton}
                        labelStyle={styles.totalPendingButtonLabel}
                        contentStyle={styles.totalPendingButtonContent}
                        compact
                      >
                        Total a pagar
                      </Button>
                    </View>
                    <HelperText
                      type="error"
                      visible={
                        amount !== '' &&
                        (isNaN(parseFloat(amount)) || parseFloat(amount) <= 0)
                      }
                    >
                      Ingrese un monto vlido
                    </HelperText>
                  </View>
                </View>
              )}
            </ScrollView>

            {/* Botones de accin */}
            <View style={styles.footer}>
              <Button
                mode="outlined"
                onPress={onDismiss}
                style={[styles.footerButton, styles.cancelButton]}
                contentStyle={styles.footerButtonContent}
              >
                Cerrar
              </Button>
              {mode === 'prepayment' && existingPrepaymentId && (
                <Button
                  mode="outlined"
                  onPress={() => setShowDeletePrepaymentConfirm(true)}
                  style={[styles.footerButton, styles.deleteButton]}
                  contentStyle={styles.footerButtonContent}
                  textColor={theme.colors.error}
                  icon="delete"
                >
                  Eliminar
                </Button>
              )}
              {(mode === 'prepayment' || !isFullyPaid) && (
                <Button
                  mode="contained"
                  onPress={handleSubmit}
                  disabled={
                    !amount ||
                    isNaN(parseFloat(amount)) ||
                    parseFloat(amount) <= 0 ||
                    createPaymentMutation.isPending ||
                    isCreatingPrepayment
                  }
                  loading={
                    createPaymentMutation.isPending || isCreatingPrepayment
                  }
                  style={styles.footerButton}
                  contentStyle={styles.footerButtonContent}
                >
                  {mode === 'prepayment'
                    ? 'Registrar Pre-pago'
                    : 'Registrar Pago'}
                </Button>
              )}
              {isFullyPaid && mode !== 'prepayment' && (
                <Button
                  mode="contained"
                  onPress={() => setShowFinalizeConfirm(true)}
                  disabled={completeOrderMutation.isPending}
                  loading={completeOrderMutation.isPending}
                  style={[styles.footerButton, styles.finalizeButton]}
                  contentStyle={styles.footerButtonContent}
                  icon="check-circle"
                >
                  Finalizar Orden
                </Button>
              )}
            </View>
          </Surface>
        </View>
      </Modal>

      {/* Modal de confirmacin para eliminar */}
      <ConfirmationModal
        visible={showDeleteConfirm}
        onDismiss={() => {
          setShowDeleteConfirm(false);
          setPaymentToDelete(null);
        }}
        onCancel={() => {
          setShowDeleteConfirm(false);
          setPaymentToDelete(null);
        }}
        onConfirm={handleDeletePayment}
        title="Eliminar pago"
        message="Est seguro de que desea eliminar este pago? Esta accin no se puede deshacer."
        confirmText="S, eliminar"
        cancelText="No, cancelar"
        confirmButtonColor={theme.colors.error}
      />

      {/* Modal de clculo de cambio */}
      <ChangeCalculatorModal
        visible={showChangeCalculator}
        onDismiss={() => {
          setShowChangeCalculator(false);
        }}
        onConfirm={() => {
          setShowChangeCalculator(false);
          processPayment();
        }}
        amountToPay={parseFloat(amount) || 0}
      />

      {/* Modal de confirmacin para finalizar orden */}
      <ConfirmationModal
        visible={showFinalizeConfirm}
        onDismiss={() => setShowFinalizeConfirm(false)}
        onCancel={() => setShowFinalizeConfirm(false)}
        onConfirm={handleFinalizeOrder}
        title="Finalizar orden"
        message={
          orderStatus && orderStatus !== 'READY'
            ? ` ADVERTENCIA: Esta orden est en estado "${OrderStatusInfo.getLabel(orderStatus)}" y no "Lista".\n\nEst seguro de que desea finalizar la orden #${orderNumber}? La orden se marcar como completada.`
            : `Est seguro de que desea finalizar la orden #${orderNumber}? La orden se marcar como completada.`
        }
        confirmText={
          orderStatus && orderStatus !== 'READY'
            ? 'Finalizar igual'
            : 'S, finalizar'
        }
        cancelText="No, cancelar"
        confirmButtonColor={
          orderStatus && orderStatus !== 'READY'
            ? theme.colors.error
            : '#10B981'
        }
      />

      {/* Modal de confirmacin para eliminar pre-pago */}
      <ConfirmationModal
        visible={showDeletePrepaymentConfirm}
        onDismiss={() => setShowDeletePrepaymentConfirm(false)}
        onCancel={() => setShowDeletePrepaymentConfirm(false)}
        onConfirm={handleDeletePrepayment}
        title="Eliminar pago"
        message="Est seguro de que desea eliminar este pago registrado? Esta accin no se puede deshacer."
        confirmText="S, eliminar"
        cancelText="Cancelar"
        confirmButtonColor={theme.colors.error}
      />
    </Portal>
  );
};

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    modalContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.spacingPreset.m,
    },
    modalWrapper: {
      width: '100%',
      maxWidth: responsive.isTablet ? 700 : 600,
      maxHeight: responsive.isTablet ? '90%' : '85%',
    },
    modalContent: {
      borderRadius: theme.roundness * 2,
      backgroundColor: theme.colors.surface,
      width: '100%',
      maxHeight: '100%',
      minHeight: responsive.isTablet ? 550 : undefined,
      overflow: 'hidden',
      borderWidth: 2,
      borderColor: theme.colors.outline,
    },
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: responsive.spacingPreset.m,
      paddingVertical: responsive.spacingPreset.xs,
    },
    headerTextContainer: {
      flex: 1,
    },
    title: {
      ...theme.fonts.headlineSmall,
      fontSize: responsive.fontSize(theme.fonts.headlineSmall.fontSize),
      color: theme.colors.onSurface,
      fontWeight: 'bold',
    },
    orderNumber: {
      ...theme.fonts.bodyMedium,
      fontSize: responsive.fontSize(theme.fonts.bodyMedium.fontSize),
      color: theme.colors.onSurfaceVariant,
    },
    scrollView: {
      maxHeight: responsive.isTablet ? 600 : 500,
    },
    scrollViewContent: {
      paddingBottom: responsive.spacingPreset.m,
    },
    scrollViewWithKeyboard: {
      maxHeight: responsive.isTablet ? 350 : 250,
    },
    summaryContainer: {
      flexDirection: 'row',
      justifyContent: 'space-around',
      alignItems: 'center',
      backgroundColor: theme.colors.primaryContainer,
      paddingVertical: responsive.spacingPreset.s,
      paddingHorizontal: responsive.spacingPreset.m,
      marginHorizontal: responsive.spacingPreset.m,
      marginTop: responsive.spacingPreset.s,
      marginBottom: responsive.spacingPreset.m,
      borderRadius: theme.roundness,
    },
    summaryItem: {
      flex: 1,
      alignItems: 'center',
    },
    summaryLabel: {
      ...theme.fonts.bodySmall,
      fontSize: responsive.fontSize(theme.fonts.bodySmall.fontSize),
      color: theme.colors.onPrimaryContainer,
      opacity: 0.8,
      marginBottom: 2,
    },
    summaryAmount: {
      ...theme.fonts.titleSmall,
      fontSize: responsive.fontSize(theme.fonts.titleSmall.fontSize),
      fontWeight: 'bold',
      color: theme.colors.onPrimaryContainer,
    },
    summaryDividerVertical: {
      width: 1,
      height: '80%',
      backgroundColor: theme.colors.onPrimaryContainer,
      opacity: 0.2,
      marginHorizontal: responsive.spacingPreset.xs,
    },
    loader: {
      marginVertical: responsive.spacingPreset.xl,
    },
    paymentsSection: {
      paddingHorizontal: responsive.spacingPreset.m,
      paddingBottom: responsive.spacingPreset.s,
    },
    sectionTitle: {
      ...theme.fonts.titleSmall,
      fontSize: responsive.fontSize(theme.fonts.titleSmall.fontSize),
      color: theme.colors.onSurface,
      marginBottom: responsive.spacingPreset.xs,
      fontWeight: '600',
    },
    paymentItem: {
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: theme.roundness,
      padding: responsive.spacingPreset.xs,
      marginBottom: responsive.spacingPreset.xs,
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    paymentLeftInfo: {
      flex: 1,
    },
    paymentRightInfo: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.spacingPreset.xs,
    },
    paymentMethodRow: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    paymentMethodCompact: {
      ...theme.fonts.bodyMedium,
      fontSize: responsive.fontSize(theme.fonts.bodyMedium.fontSize),
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    paymentAmountCompact: {
      ...theme.fonts.bodyMedium,
      fontSize: responsive.fontSize(theme.fonts.bodyMedium.fontSize),
      fontWeight: 'bold',
      color: theme.colors.primary,
      minWidth: responsive.isTablet ? 60 : 70,
      textAlign: 'right',
    },
    paymentDateCompact: {
      ...theme.fonts.bodySmall,
      fontSize: responsive.fontSize(theme.fonts.bodySmall.fontSize),
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
    },
    statusChipCompact: {
      height: responsive.isTablet ? 24 : 26,
      minWidth: responsive.isTablet ? 80 : 90,
    },
    statusChipTextCompact: {
      fontSize: responsive.fontSize(11),
      fontWeight: '600',
      color: 'white',
      lineHeight: responsive.isTablet ? 12 : 14,
    },
    deleteIconButton: {
      margin: 0,
      width: responsive.isTablet ? 32 : 36,
      height: responsive.isTablet ? 32 : 36,
    },
    formSection: {
      paddingHorizontal: responsive.spacingPreset.m,
      paddingBottom: responsive.spacingPreset.xs,
    },
    methodsContainer: {
      marginBottom: responsive.spacingPreset.s,
    },
    methodCard: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingVertical: responsive.spacingPreset.xs,
      paddingHorizontal: responsive.spacingPreset.s,
      marginBottom: responsive.spacingPreset.xs,
      borderRadius: theme.roundness,
      borderWidth: 1,
      borderColor: theme.colors.outline,
      backgroundColor: theme.colors.surface,
    },
    methodCardSelected: {
      borderColor: theme.colors.primary,
      backgroundColor: theme.colors.primaryContainer,
    },
    methodText: {
      ...theme.fonts.bodyLarge,
      fontSize: responsive.fontSize(theme.fonts.bodyLarge.fontSize),
      color: theme.colors.onSurface,
      marginLeft: responsive.spacingPreset.xs,
    },
    methodTextSelected: {
      color: theme.colors.onPrimaryContainer,
      fontWeight: '500',
    },
    methodCardDisabled: {
      opacity: 0.5,
      borderColor: theme.colors.outlineVariant,
    },
    methodLabelContainer: {
      flex: 1,
      marginLeft: responsive.spacingPreset.xs,
    },
    methodTextDisabled: {
      color: theme.colors.onSurfaceDisabled,
    },
    comingSoonText: {
      ...theme.fonts.bodySmall,
      fontSize: responsive.fontSize(theme.fonts.bodySmall.fontSize),
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      marginTop: 2,
    },
    amountContainer: {
      marginTop: responsive.spacingPreset.s,
    },
    amountRow: {
      flexDirection: 'row',
      gap: responsive.spacingPreset.xs,
      alignItems: 'flex-start',
    },
    amountInput: {
      backgroundColor: theme.colors.surface,
      flex: 1,
    },
    totalPendingButton: {
      marginTop: 4, // Alinear con el input que tiene un label
      height: responsive.isTablet ? 48 : 56, // Misma altura que el TextInput con outlined
      borderColor: theme.colors.primary,
      justifyContent: 'center',
    },
    totalPendingButtonContent: {
      height: '100%',
      paddingVertical: 0,
      paddingHorizontal: responsive.spacingPreset.s,
    },
    totalPendingButtonLabel: {
      fontSize: responsive.fontSize(13),
      lineHeight: responsive.isTablet ? 18 : 20,
      textAlignVertical: 'center',
    },
    footer: {
      flexDirection: 'row',
      justifyContent: 'center',
      alignItems: 'center',
      gap: responsive.spacingPreset.m,
      paddingHorizontal: responsive.spacingPreset.m,
      paddingVertical: responsive.spacingPreset.m,
      paddingTop: responsive.spacingPreset.s,
      backgroundColor: theme.colors.surface,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
    },
    footerButton: {
      minWidth: responsive.isTablet ? 110 : 120,
    },
    footerButtonContent: {
      height: responsive.isTablet ? 36 : 40,
    },
    cancelButton: {
      borderColor: theme.colors.outline,
    },
    summaryAmountPaid: {
      color: '#4CAF50',
    },
    summaryLabelPending: {
      fontWeight: 'bold',
    },
    summaryAmountPendingBold: {
      fontWeight: 'bold',
    },
    summaryAmountError: {
      color: theme.colors.error,
    },
    finalizeButton: {
      backgroundColor: '#10B981',
    },
    deleteButton: {
      borderColor: theme.colors.error,
    },
  });

export default PaymentModal;

================
File: app/src/modules/restaurantConfig/screens/RestaurantConfigScreen.tsx
================
import React, { useState } from 'react';
import { Portal } from 'react-native-paper';
import {
  View,
  StyleSheet,
  useWindowDimensions,
  BackHandler,
  Pressable,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import {
  Text,
  Switch,
  TextInput,
  Button,
  ActivityIndicator,
  Dialog,
  Surface,
  Chip,
  Icon,
} from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { useRestaurantConfigQueries } from '../hooks/useRestaurantConfigQueries';
import {
  UpdateRestaurantConfigDto,
  CreateBusinessHoursDto,
} from '../schema/restaurantConfig.schema';
import BusinessHoursForm from '../components/BusinessHoursForm';
import TimeZoneSelector from '../components/TimeZoneSelector';
import { WebViewDeliveryCoverageMap } from '../components/WebViewDeliveryCoverageMap';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
import { useNavigation } from '@react-navigation/native';
import { useFocusEffect } from '@react-navigation/native';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';

type TabType = 'basic' | 'operation' | 'schedule';

const RestaurantConfigScreen: React.FC = () => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const { width, height } = useWindowDimensions();
  const navigation = useNavigation();
  const styles = React.useMemo(
    () => createStyles(theme, responsive, width, height),
    [theme, responsive, width, height],
  );

  const { useGetConfig, useUpdateConfig } = useRestaurantConfigQueries();
  const { data: config, isLoading, error } = useGetConfig();
  const updateConfigMutation = useUpdateConfig();
  const updateDeliveryAreaMutation = useUpdateConfig({
    successMessage: 'rea de cobertura actualizada exitosamente',
  });

  const [activeTab, setActiveTab] = useState<TabType>('basic');
  const [pendingTab, setPendingTab] = useState<TabType | null>(null);
  const [formData, setFormData] = useState<UpdateRestaurantConfigDto>({});
  const [isEditing, setIsEditing] = useState(false);
  const [showDiscardDialog, setShowDiscardDialog] = useState(false);
  const [showDeliveryModal, setShowDeliveryModal] = useState(false);
  const [isEditingDelivery, setIsEditingDelivery] = useState(false);
  const [isNavigatingAway, setIsNavigatingAway] = useState(false);
  const [businessHoursModified, setBusinessHoursModified] = useState(false);
  const [originalDeliveryArea, setOriginalDeliveryArea] = useState<any>(null);
  const [showAreaValidationModal, setShowAreaValidationModal] = useState(false);
  const [showScheduleConflictModal, setShowScheduleConflictModal] =
    useState(false);

  // Refrescar configuracin cuando la pantalla recibe foco
  useRefreshModuleOnFocus('restaurantConfig');

  // Funcin para validar conflictos de horarios
  const hasScheduleConflicts = React.useCallback(() => {
    if (!formData.businessHours) return false;

    for (let i = 0; i < formData.businessHours.length; i++) {
      const currentDay = formData.businessHours[i];
      if (currentDay.isClosed || !currentDay.openingTime) continue;

      // Verificar si el da anterior cierra despus de medianoche
      const previousDayIndex = i === 0 ? 6 : i - 1;
      const previousDay = formData.businessHours.find(
        (h) => h.dayOfWeek === previousDayIndex,
      );

      if (
        !previousDay ||
        previousDay.isClosed ||
        !previousDay.closesNextDay ||
        !previousDay.closingTime
      ) {
        continue;
      }

      // Comparar horarios
      const [currentOpenHour, currentOpenMin] = currentDay.openingTime
        .split(':')
        .map(Number);
      const [prevCloseHour, prevCloseMin] = previousDay.closingTime
        .split(':')
        .map(Number);

      const currentOpenMinutes = currentOpenHour * 60 + currentOpenMin;
      const prevCloseMinutes = prevCloseHour * 60 + prevCloseMin;

      // Si el da actual abre antes o exactamente cuando cierre el da anterior
      if (currentOpenMinutes <= prevCloseMinutes) {
        return true;
      }
    }

    return false;
  }, [formData.businessHours]);

  // Funcin para verificar si hay cambios sin guardar
  const hasChanges = React.useCallback(() => {
    if (!config) return false;

    // Comparacin simple de campos individuales
    const simpleFieldsChanged =
      formData.restaurantName !== config.restaurantName ||
      formData.phoneMain !== config.phoneMain ||
      formData.phoneSecondary !== config.phoneSecondary ||
      formData.address !== config.address ||
      formData.city !== config.city ||
      formData.state !== config.state ||
      formData.postalCode !== config.postalCode ||
      formData.country !== config.country ||
      formData.acceptingOrders !== config.acceptingOrders ||
      formData.estimatedPickupTime !== config.estimatedPickupTime ||
      formData.estimatedDeliveryTime !== config.estimatedDeliveryTime ||
      formData.estimatedDineInTime !== config.estimatedDineInTime ||
      formData.openingGracePeriod !== config.openingGracePeriod ||
      formData.closingGracePeriod !== config.closingGracePeriod ||
      formData.timeZone !== config.timeZone ||
      formData.scheduledOrdersLeadTime !== config.scheduledOrdersLeadTime ||
      formData.minimumOrderValueForDelivery !==
        config.minimumOrderValueForDelivery;

    // Comparar rea de cobertura
    const deliveryAreaChanged =
      JSON.stringify(formData.deliveryCoverageArea) !==
      JSON.stringify(config.deliveryCoverageArea);

    return simpleFieldsChanged || deliveryAreaChanged || businessHoursModified;
  }, [config, formData, businessHoursModified]);

  // Interceptar navegacin cuando hay cambios sin guardar
  useFocusEffect(
    React.useCallback(() => {
      const unsubscribe = navigation.addListener('beforeRemove', (e) => {
        if (!isEditing || !hasChanges()) {
          // Si no est editando o no hay cambios, permitir navegacin
          return;
        }

        // Prevenir la navegacin por defecto
        e.preventDefault();

        // Mostrar el dilogo de confirmacin
        setIsNavigatingAway(true);
        setShowDiscardDialog(true);
      });

      return unsubscribe;
    }, [navigation, isEditing, hasChanges]),
  );

  // Manejar botn de retroceso de Android
  useFocusEffect(
    React.useCallback(() => {
      const onBackPress = () => {
        if (isEditing && hasChanges()) {
          setIsNavigatingAway(true);
          setShowDiscardDialog(true);
          return true; // Prevenir el comportamiento por defecto
        }
        return false;
      };

      const subscription = BackHandler.addEventListener(
        'hardwareBackPress',
        onBackPress,
      );

      return () => subscription.remove();
    }, [isEditing, hasChanges]),
  );

  React.useEffect(() => {
    if (config && !isEditing) {
      // Solo actualizar formData si no estamos editando
      // Si no hay businessHours, inicializar con valores por defecto
      const initialBusinessHours =
        config.businessHours && config.businessHours.length > 0
          ? config.businessHours.map((hour) => ({
              ...hour,
              // Normalizar el formato de tiempo a HH:MM
              openingTime: hour.openingTime
                ? hour.openingTime.substring(0, 5)
                : null,
              closingTime: hour.closingTime
                ? hour.closingTime.substring(0, 5)
                : null,
            }))
          : [0, 1, 2, 3, 4, 5, 6].map((dayOfWeek) => ({
              dayOfWeek,
              openingTime: '09:00',
              closingTime: '22:00',
              isClosed: false,
            }));

      setFormData({
        // Informacin bsica
        restaurantName: config.restaurantName,
        phoneMain: config.phoneMain,
        phoneSecondary: config.phoneSecondary,
        address: config.address,
        city: config.city,
        state: config.state,
        postalCode: config.postalCode,
        country: config.country,
        // Configuracin de operacin
        acceptingOrders: config.acceptingOrders,
        estimatedPickupTime: config.estimatedPickupTime,
        estimatedDeliveryTime: config.estimatedDeliveryTime,
        estimatedDineInTime: config.estimatedDineInTime,
        openingGracePeriod: config.openingGracePeriod,
        closingGracePeriod: config.closingGracePeriod,
        timeZone: config.timeZone || 'America/Mexico_City',
        scheduledOrdersLeadTime: config.scheduledOrdersLeadTime,
        // Configuracin de delivery
        deliveryCoverageArea: config.deliveryCoverageArea,
        minimumOrderValueForDelivery:
          typeof config.minimumOrderValueForDelivery === 'string'
            ? parseFloat(config.minimumOrderValueForDelivery)
            : config.minimumOrderValueForDelivery,
        // Horarios
        businessHours: initialBusinessHours,
      });
    }
  }, [config, isEditing]);

  const handleSubmit = async () => {
    // Validar conflictos de horarios antes de guardar
    if (hasScheduleConflicts()) {
      setShowScheduleConflictModal(true);
      return;
    }

    try {
      // Formatear los datos antes de enviarlos
      const dataToSubmit = {
        ...formData,
        // Formatear businessHours para quitar los segundos
        businessHours: formData.businessHours?.map((hour) => ({
          ...hour,
          openingTime: hour.openingTime
            ? hour.openingTime.substring(0, 5)
            : null,
          closingTime: hour.closingTime
            ? hour.closingTime.substring(0, 5)
            : null,
        })),
        // deliveryCoverageArea se enva tal como est (array de coordenadas)
      };

      await updateConfigMutation.mutateAsync(dataToSubmit);
      setIsEditing(false);
      setBusinessHoursModified(false);
    } catch (error) {
      // Error handling is done in the mutation hook
    }
  };

  const handleSaveDeliveryArea = async () => {
    try {
      // Guardar solo el rea de cobertura
      await updateDeliveryAreaMutation.mutateAsync({
        deliveryCoverageArea: formData.deliveryCoverageArea,
      });

      // Actualizar el estado del config con la nueva rea
      if (config) {
        // Esto asegura que el estado local se mantenga sincronizado
        setFormData((prev) => ({
          ...prev,
          deliveryCoverageArea: formData.deliveryCoverageArea,
        }));
      }
    } catch (error) {
      // Error handling is done in the mutation hook
    }
  };

  const handleCancel = () => {
    if (hasChanges()) {
      setShowDiscardDialog(true);
    } else {
      resetForm();
    }
  };

  const resetForm = () => {
    if (config) {
      // Usar la misma lgica de inicializacin que en useEffect
      const initialBusinessHours =
        config.businessHours && config.businessHours.length > 0
          ? config.businessHours.map((hour) => ({
              ...hour,
              // Normalizar el formato de tiempo a HH:MM
              openingTime: hour.openingTime
                ? hour.openingTime.substring(0, 5)
                : null,
              closingTime: hour.closingTime
                ? hour.closingTime.substring(0, 5)
                : null,
            }))
          : [0, 1, 2, 3, 4, 5, 6].map((dayOfWeek) => ({
              dayOfWeek,
              openingTime: '09:00',
              closingTime: '22:00',
              isClosed: false,
            }));

      setFormData({
        restaurantName: config.restaurantName,
        phoneMain: config.phoneMain,
        phoneSecondary: config.phoneSecondary,
        address: config.address,
        city: config.city,
        state: config.state,
        postalCode: config.postalCode,
        country: config.country,
        acceptingOrders: config.acceptingOrders,
        estimatedPickupTime: config.estimatedPickupTime,
        estimatedDeliveryTime: config.estimatedDeliveryTime,
        estimatedDineInTime: config.estimatedDineInTime,
        openingGracePeriod: config.openingGracePeriod,
        closingGracePeriod: config.closingGracePeriod,
        timeZone: config.timeZone || 'America/Mexico_City',
        scheduledOrdersLeadTime: config.scheduledOrdersLeadTime,
        deliveryCoverageArea: config.deliveryCoverageArea,
        minimumOrderValueForDelivery:
          typeof config.minimumOrderValueForDelivery === 'string'
            ? parseFloat(config.minimumOrderValueForDelivery)
            : config.minimumOrderValueForDelivery,
        businessHours: initialBusinessHours,
      });
    }
    setIsEditing(false);
    setBusinessHoursModified(false);
  };

  const confirmDiscard = () => {
    resetForm();
    setShowDiscardDialog(false);

    // Si estaba navegando fuera de la pantalla
    if (isNavigatingAway) {
      setIsNavigatingAway(false);
      navigation.goBack();
      return;
    }

    // Si hay una pestaa pendiente, cambiar a ella
    if (pendingTab) {
      setActiveTab(pendingTab);
      setPendingTab(null);
    }
  };

  const handleTabChange = (newTab: TabType) => {
    // Permitir cambio libre de tabs, sin importar si est editando
    setActiveTab(newTab);
  };

  const renderBasicInfo = () => (
    <View style={styles.tabContent}>
      <Surface style={styles.section} elevation={1}>
        <View style={styles.sectionHeader}>
          <MaterialCommunityIcons
            name="store-outline"
            size={24}
            color={theme.colors.primary}
          />
          <Text style={styles.sectionTitle}>Informacin del Restaurante</Text>
        </View>

        <View style={styles.sectionContent}>
          <TextInput
            label="Nombre del restaurante"
            value={formData.restaurantName || ''}
            onChangeText={(text) =>
              setFormData({ ...formData, restaurantName: text })
            }
            mode="outlined"
            disabled={!isEditing}
            style={styles.input}
            outlineStyle={styles.inputOutline}
          />

          <TextInput
            label="Telfono principal"
            value={formData.phoneMain || ''}
            onChangeText={(text) =>
              setFormData({ ...formData, phoneMain: text })
            }
            mode="outlined"
            disabled={!isEditing}
            style={styles.input}
            outlineStyle={styles.inputOutline}
            keyboardType="phone-pad"
            left={<TextInput.Icon icon="phone" />}
          />

          <TextInput
            label="Telfono secundario"
            value={formData.phoneSecondary || ''}
            onChangeText={(text) =>
              setFormData({ ...formData, phoneSecondary: text })
            }
            mode="outlined"
            disabled={!isEditing}
            style={styles.input}
            outlineStyle={styles.inputOutline}
            keyboardType="phone-pad"
            left={<TextInput.Icon icon="cellphone" />}
          />

          <TextInput
            label="Direccin"
            value={formData.address || ''}
            onChangeText={(text) => setFormData({ ...formData, address: text })}
            mode="outlined"
            disabled={!isEditing}
            style={styles.input}
            outlineStyle={styles.inputOutline}
            multiline
            numberOfLines={2}
            left={<TextInput.Icon icon="map-marker" />}
          />

          <View style={styles.row}>
            <TextInput
              label="Ciudad"
              value={formData.city || ''}
              onChangeText={(text) => setFormData({ ...formData, city: text })}
              mode="outlined"
              disabled={!isEditing}
              style={[styles.input, styles.halfInput]}
              outlineStyle={styles.inputOutline}
            />
            <TextInput
              label="Estado"
              value={formData.state || ''}
              onChangeText={(text) => setFormData({ ...formData, state: text })}
              mode="outlined"
              disabled={!isEditing}
              style={[styles.input, styles.halfInput]}
              outlineStyle={styles.inputOutline}
            />
          </View>

          <View style={styles.row}>
            <TextInput
              label="Cdigo postal"
              value={formData.postalCode || ''}
              onChangeText={(text) =>
                setFormData({ ...formData, postalCode: text })
              }
              mode="outlined"
              disabled={!isEditing}
              style={[styles.input, styles.halfInput]}
              outlineStyle={styles.inputOutline}
              keyboardType="numeric"
            />
            <TextInput
              label="Pas"
              value={formData.country || ''}
              onChangeText={(text) =>
                setFormData({ ...formData, country: text })
              }
              mode="outlined"
              disabled={!isEditing}
              style={[styles.input, styles.halfInput]}
              outlineStyle={styles.inputOutline}
            />
          </View>

          {/* Botn para rea de cobertura */}
          <View style={styles.deliveryButtonContainer}>
            <Button
              mode="contained-tonal"
              onPress={() => setShowDeliveryModal(true)}
              icon="map-marker-radius"
              style={styles.deliveryButton}
              contentStyle={styles.deliveryButtonContent}
              labelStyle={styles.deliveryButtonLabel}
            >
              rea de Cobertura
            </Button>
            {formData.deliveryCoverageArea &&
            formData.deliveryCoverageArea.length > 0 ? (
              <Text style={styles.deliveryStatusText}>
                rea de cobertura definida
              </Text>
            ) : (
              <Text
                style={[
                  styles.deliveryStatusText,
                  styles.deliveryStatusWarning,
                ]}
              >
                Sin rea de cobertura definida
              </Text>
            )}
          </View>
        </View>
      </Surface>
    </View>
  );

  const renderOperationConfig = () => (
    <View style={styles.tabContent}>
      {/* Service Status Card */}
      <Surface style={styles.section} elevation={1}>
        <View style={styles.sectionHeader}>
          <MaterialCommunityIcons
            name="store-check"
            size={24}
            color={theme.colors.primary}
          />
          <Text style={styles.sectionTitle}>Estado del Servicio</Text>
        </View>

        <View style={styles.sectionContent}>
          <View style={styles.statusRow}>
            <View style={styles.statusInfo}>
              <Text style={styles.statusLabel}>Recepcin de rdenes</Text>
              <Text style={styles.statusDescription}>
                {formData.acceptingOrders
                  ? 'Las rdenes estn siendo aceptadas'
                  : 'No se estn aceptando rdenes nuevas'}
              </Text>
            </View>
            <Switch
              value={formData.acceptingOrders}
              onValueChange={(value) =>
                setFormData({ ...formData, acceptingOrders: value })
              }
              disabled={!isEditing}
              color={theme.colors.primary}
            />
          </View>
        </View>
      </Surface>

      {/* Delivery Times Card */}
      <Surface style={styles.section} elevation={1}>
        <View style={styles.sectionHeader}>
          <MaterialCommunityIcons
            name="clock-time-four"
            size={24}
            color={theme.colors.primary}
          />
          <Text style={styles.sectionTitle}>Tiempos de Servicio</Text>
        </View>

        <View style={styles.sectionContent}>
          <View style={styles.timeInputContainer}>
            <View style={styles.timeIconWrapper}>
              <MaterialCommunityIcons
                name="walk"
                size={20}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <TextInput
              label="Para recoger en tienda"
              value={formData.estimatedPickupTime?.toString() || ''}
              onChangeText={(text) =>
                setFormData({
                  ...formData,
                  estimatedPickupTime: parseInt(text) || 0,
                })
              }
              keyboardType="numeric"
              mode="outlined"
              disabled={!isEditing}
              style={styles.timeInput}
              right={<TextInput.Affix text="min" />}
              outlineStyle={styles.inputOutline}
            />
          </View>

          <View style={styles.timeInputContainer}>
            <View style={styles.timeIconWrapper}>
              <MaterialCommunityIcons
                name="moped"
                size={20}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <TextInput
              label="Entrega a domicilio"
              value={formData.estimatedDeliveryTime?.toString() || ''}
              onChangeText={(text) =>
                setFormData({
                  ...formData,
                  estimatedDeliveryTime: parseInt(text) || 0,
                })
              }
              keyboardType="numeric"
              mode="outlined"
              disabled={!isEditing}
              style={styles.timeInput}
              right={<TextInput.Affix text="min" />}
              outlineStyle={styles.inputOutline}
            />
          </View>

          <View style={styles.timeInputContainer}>
            <View style={styles.timeIconWrapper}>
              <MaterialCommunityIcons
                name="currency-usd"
                size={20}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <TextInput
              label="Valor mnimo para delivery"
              value={formData.minimumOrderValueForDelivery?.toString() || ''}
              onChangeText={(text) => {
                const value = parseFloat(text);
                setFormData({
                  ...formData,
                  minimumOrderValueForDelivery: isNaN(value) ? 0 : value,
                });
              }}
              keyboardType="numeric"
              mode="outlined"
              disabled={!isEditing}
              style={styles.timeInput}
              right={<TextInput.Affix text="$" />}
              outlineStyle={styles.inputOutline}
            />
          </View>

          <View style={styles.timeInputContainer}>
            <View style={styles.timeIconWrapper}>
              <MaterialCommunityIcons
                name="silverware-fork-knife"
                size={20}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <TextInput
              label="Para comer en el local"
              value={formData.estimatedDineInTime?.toString() || ''}
              onChangeText={(text) =>
                setFormData({
                  ...formData,
                  estimatedDineInTime: parseInt(text) || 0,
                })
              }
              keyboardType="numeric"
              mode="outlined"
              disabled={!isEditing}
              style={styles.timeInput}
              right={<TextInput.Affix text="min" />}
              outlineStyle={styles.inputOutline}
            />
          </View>

          <View style={styles.timeInputContainer}>
            <View style={styles.timeIconWrapper}>
              <MaterialCommunityIcons
                name="timer"
                size={20}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <TextInput
              label="Periodo de gracia al abrir"
              value={formData.openingGracePeriod?.toString() || ''}
              onChangeText={(text) =>
                setFormData({
                  ...formData,
                  openingGracePeriod: parseInt(text) || 0,
                })
              }
              keyboardType="numeric"
              mode="outlined"
              disabled={!isEditing}
              style={styles.timeInput}
              right={<TextInput.Affix text="min" />}
              outlineStyle={styles.inputOutline}
            />
          </View>

          <View style={styles.timeInputContainer}>
            <View style={styles.timeIconWrapper}>
              <MaterialCommunityIcons
                name="timer-off-outline"
                size={20}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <TextInput
              label="Periodo de gracia al cerrar"
              value={formData.closingGracePeriod?.toString() || ''}
              onChangeText={(text) =>
                setFormData({
                  ...formData,
                  closingGracePeriod: parseInt(text) || 0,
                })
              }
              keyboardType="numeric"
              mode="outlined"
              disabled={!isEditing}
              style={styles.timeInput}
              right={<TextInput.Affix text="min" />}
              outlineStyle={styles.inputOutline}
            />
          </View>

          <View style={styles.timeInputContainer}>
            <View style={styles.timeIconWrapper}>
              <MaterialCommunityIcons
                name="calendar-clock"
                size={20}
                color={theme.colors.onSurfaceVariant}
              />
            </View>
            <TextInput
              label="Anticipacin rdenes programadas"
              value={formData.scheduledOrdersLeadTime?.toString() || ''}
              onChangeText={(text) =>
                setFormData({
                  ...formData,
                  scheduledOrdersLeadTime: parseInt(text) || 0,
                })
              }
              keyboardType="numeric"
              mode="outlined"
              disabled={!isEditing}
              style={styles.timeInput}
              right={<TextInput.Affix text="min" />}
              outlineStyle={styles.inputOutline}
            />
          </View>

          <View style={styles.infoChip}>
            <Chip
              icon="information"
              mode="flat"
              style={styles.chip}
              textStyle={styles.chipText}
            >
              Los tiempos son estimados y pueden variar
            </Chip>
          </View>
        </View>
      </Surface>

      {/* Time Zone */}
      <Surface style={styles.section} elevation={1}>
        <View style={styles.sectionHeader}>
          <MaterialCommunityIcons
            name="earth"
            size={24}
            color={theme.colors.primary}
          />
          <Text style={styles.sectionTitle}>Zona Horaria</Text>
        </View>

        <View style={styles.sectionContent}>
          <TimeZoneSelector
            value={formData.timeZone || 'America/Mexico_City'}
            onChange={(timezone) => {
              setFormData({ ...formData, timeZone: timezone });
            }}
            disabled={!isEditing}
          />
        </View>
      </Surface>
    </View>
  );

  const renderSchedule = () => (
    <View style={styles.tabContent}>
      <Surface style={styles.section} elevation={1}>
        <View style={styles.sectionHeader}>
          <MaterialCommunityIcons
            name="calendar-clock"
            size={24}
            color={theme.colors.primary}
          />
          <Text style={styles.sectionTitle}>Horario de Operacin</Text>
        </View>

        <View style={styles.sectionContent}>
          <BusinessHoursForm
            businessHours={formData.businessHours || []}
            isEditing={isEditing}
            onChange={(hours: CreateBusinessHoursDto[]) => {
              setFormData((prev) => ({ ...prev, businessHours: hours }));
              setBusinessHoursModified(true);
            }}
          />
        </View>
      </Surface>
    </View>
  );

  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </View>
    );
  }

  if (error) {
    return (
      <View style={styles.errorContainer}>
        <Text style={styles.errorText}>Error al cargar la configuracin</Text>
      </View>
    );
  }

  return (
    <SafeAreaView style={styles.container} edges={['bottom']}>
      {/* Tabs */}
      <View style={styles.header}>
        <View style={styles.tabsContainer}>
          <Pressable
            style={[styles.tab, activeTab === 'basic' && styles.tabActive]}
            onPress={() => handleTabChange('basic')}
          >
            <Icon
              source="store"
              size={20}
              color={
                activeTab === 'basic'
                  ? theme.colors.primary
                  : theme.colors.onSurfaceVariant
              }
            />
            <Text
              style={[
                styles.tabText,
                activeTab === 'basic' && styles.tabTextActive,
              ]}
            >
              Informacin
            </Text>
          </Pressable>

          <Pressable
            style={[styles.tab, activeTab === 'operation' && styles.tabActive]}
            onPress={() => handleTabChange('operation')}
          >
            <Icon
              source="cog"
              size={20}
              color={
                activeTab === 'operation'
                  ? theme.colors.primary
                  : theme.colors.onSurfaceVariant
              }
            />
            <Text
              style={[
                styles.tabText,
                activeTab === 'operation' && styles.tabTextActive,
              ]}
            >
              Operacin
            </Text>
          </Pressable>

          <Pressable
            style={[styles.tab, activeTab === 'schedule' && styles.tabActive]}
            onPress={() => handleTabChange('schedule')}
          >
            <Icon
              source="calendar"
              size={20}
              color={
                activeTab === 'schedule'
                  ? theme.colors.primary
                  : theme.colors.onSurfaceVariant
              }
            />
            <Text
              style={[
                styles.tabText,
                activeTab === 'schedule' && styles.tabTextActive,
              ]}
            >
              Horarios
            </Text>
          </Pressable>
        </View>
      </View>

      {/* Content */}
      <KeyboardAvoidingView
        style={styles.keyboardAvoidingView}
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        keyboardVerticalOffset={Platform.OS === 'ios' ? 64 : 0}
      >
        <ScrollView
          contentContainerStyle={styles.scrollContent}
          showsVerticalScrollIndicator={false}
          keyboardShouldPersistTaps="handled"
        >
          {activeTab === 'basic' && renderBasicInfo()}
          {activeTab === 'operation' && renderOperationConfig()}
          {activeTab === 'schedule' && renderSchedule()}
        </ScrollView>
      </KeyboardAvoidingView>

      {/* Action Buttons */}
      <View style={styles.actionContainer}>
        {!isEditing ? (
          <Button
            mode="contained"
            onPress={() => {
              setIsEditing(true);
              setBusinessHoursModified(false);
            }}
            style={[
              styles.editButton,
              { backgroundColor: theme.colors.tertiary },
            ]}
            contentStyle={styles.editButtonContent}
            labelStyle={styles.editButtonLabel}
            icon="pencil"
            textColor={theme.colors.onTertiary}
          >
            Editar Configuracin
          </Button>
        ) : (
          <View style={styles.editActions}>
            <Button
              mode="outlined"
              onPress={handleCancel}
              style={styles.cancelButton}
              contentStyle={styles.buttonContent}
            >
              Cancelar
            </Button>
            <Button
              mode="contained"
              onPress={handleSubmit}
              loading={updateConfigMutation.isPending}
              disabled={updateConfigMutation.isPending}
              style={styles.saveButton}
              contentStyle={styles.buttonContent}
              icon="check"
            >
              Guardar
            </Button>
          </View>
        )}
      </View>

      {/* System Info Card */}
      {config && (
        <Surface style={styles.infoCard} elevation={1}>
          <View style={styles.infoContent}>
            <MaterialCommunityIcons
              name="information-outline"
              size={20}
              color={theme.colors.onSurfaceVariant}
            />
            <View style={styles.infoTextContainer}>
              <Text style={styles.infoTitle}>ltima actualizacin</Text>
              <Text style={styles.infoText}>
                {new Date(config.updatedAt).toLocaleString('es-MX', {
                  dateStyle: 'medium',
                  timeStyle: 'short',
                  timeZone: config.timeZone || 'America/Mexico_City',
                })}
              </Text>
            </View>
          </View>
        </Surface>
      )}

      <ConfirmationModal
        visible={showDiscardDialog}
        title="Descartar cambios"
        message="Ests seguro de que deseas descartar los cambios realizados?"
        onConfirm={confirmDiscard}
        onCancel={() => {
          setShowDiscardDialog(false);
          setIsNavigatingAway(false);
          setPendingTab(null);
        }}
        onDismiss={() => {
          setShowDiscardDialog(false);
          setIsNavigatingAway(false);
          setPendingTab(null);
        }}
        confirmText="Descartar"
        cancelText="Continuar editando"
        confirmButtonColor={theme.colors.error}
      />

      {/* Modal de rea de Cobertura */}
      <Portal>
        <Dialog
          visible={showDeliveryModal}
          onDismiss={() => {
            if (!updateDeliveryAreaMutation.isPending) {
              if (isEditingDelivery) {
                setFormData({
                  ...formData,
                  deliveryCoverageArea: originalDeliveryArea,
                });
              }
              setShowDeliveryModal(false);
              setIsEditingDelivery(false);
            }
          }}
          style={styles.deliveryDialog}
        >
          <Dialog.Content style={styles.deliveryDialogContent}>
            <Surface style={styles.deliveryMapWrapper} elevation={1}>
              <View style={styles.deliveryMapContainer}>
                <WebViewDeliveryCoverageMap
                  key={`coverage-map-${isEditingDelivery}`}
                  initialPolygon={formData.deliveryCoverageArea}
                  isEditing={isEditingDelivery}
                  onChange={(polygon) =>
                    setFormData({ ...formData, deliveryCoverageArea: polygon })
                  }
                  restaurantLocation={{
                    latitude: 20.5425,
                    longitude: -102.7935,
                  }}
                />
              </View>
            </Surface>
          </Dialog.Content>
          <View style={styles.deliveryDialogActions}>
            <View style={styles.deliveryDialogButtonsContainer}>
              {!isEditingDelivery ? (
                <>
                  <Button
                    onPress={() => setShowDeliveryModal(false)}
                    mode="outlined"
                    style={styles.deliveryDialogButton}
                    contentStyle={styles.deliveryButtonContent}
                    labelStyle={styles.cancelButtonLabel}
                  >
                    Cerrar
                  </Button>
                  <Button
                    onPress={() => {
                      setOriginalDeliveryArea(formData.deliveryCoverageArea);
                      setIsEditingDelivery(true);
                    }}
                    icon="pencil"
                    mode="contained"
                    style={styles.deliveryDialogButton}
                    contentStyle={styles.deliveryButtonContent}
                    labelStyle={styles.deliveryButtonLabel}
                  >
                    Editar
                  </Button>
                </>
              ) : (
                <>
                  <Button
                    onPress={() => {
                      setFormData({
                        ...formData,
                        deliveryCoverageArea: originalDeliveryArea,
                      });
                      setIsEditingDelivery(false);
                    }}
                    mode="outlined"
                    style={styles.deliveryDialogButton}
                    contentStyle={styles.deliveryButtonContent}
                    labelStyle={styles.cancelButtonLabel}
                    disabled={updateDeliveryAreaMutation.isPending}
                  >
                    Cancelar
                  </Button>
                  <Button
                    onPress={async () => {
                      // Validar que haya al menos 3 puntos
                      if (
                        !formData.deliveryCoverageArea ||
                        formData.deliveryCoverageArea.length < 3
                      ) {
                        setShowAreaValidationModal(true);
                        return;
                      }

                      setIsEditingDelivery(false);
                      // Guardar el rea de cobertura inmediatamente
                      await handleSaveDeliveryArea();
                      setShowDeliveryModal(false);
                    }}
                    mode="contained"
                    icon="check"
                    style={styles.deliveryDialogButton}
                    contentStyle={styles.deliveryButtonContent}
                    labelStyle={styles.deliveryButtonLabel}
                    loading={updateDeliveryAreaMutation.isPending}
                    disabled={updateDeliveryAreaMutation.isPending}
                  >
                    Guardar
                  </Button>
                </>
              )}
            </View>
          </View>
        </Dialog>
      </Portal>

      {/* Modal de validacin de rea */}
      <Portal>
        <Dialog
          visible={showAreaValidationModal}
          onDismiss={() => setShowAreaValidationModal(false)}
          style={styles.validationDialog}
        >
          <View style={styles.validationIconContainer}>
            <Surface style={styles.validationIconWrapper} elevation={0}>
              <MaterialCommunityIcons
                name="map-marker-alert"
                size={36}
                color={theme.colors.error}
              />
            </Surface>
          </View>
          <Dialog.Title style={styles.validationTitle}>
            rea incompleta
          </Dialog.Title>
          <Dialog.Content>
            <Text style={styles.validationMessage}>
              Se requieren al menos 3 puntos para definir un rea de cobertura
              vlida.
            </Text>
            <Text style={styles.validationHint}>
              Haz clic en el mapa para agregar ms puntos o usa el botn de
              dibujar.
            </Text>
          </Dialog.Content>
          <Dialog.Actions style={styles.validationActions}>
            <Button
              onPress={() => setShowAreaValidationModal(false)}
              mode="contained"
              style={styles.validationButton}
              contentStyle={styles.validationButtonContent}
              labelStyle={styles.validationButtonLabel}
            >
              Entendido
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>

      {/* Modal de conflicto de horarios */}
      <Portal>
        <Dialog
          visible={showScheduleConflictModal}
          onDismiss={() => setShowScheduleConflictModal(false)}
          style={styles.validationDialog}
        >
          <View style={styles.validationIconContainer}>
            <Surface style={styles.validationIconWrapper} elevation={0}>
              <MaterialCommunityIcons
                name="clock-alert"
                size={36}
                color={theme.colors.error}
              />
            </Surface>
          </View>
          <Dialog.Title style={styles.validationTitle}>
            Conflicto de horarios
          </Dialog.Title>
          <Dialog.Content>
            <Text style={styles.validationMessage}>
              Hay conflictos en los horarios de operacin. Un da no puede abrir
              antes o al mismo tiempo que cierre el da anterior.
            </Text>
            <Text style={styles.validationHint}>
              Debe haber al menos 1 minuto de diferencia entre el cierre y la
              siguiente apertura. Revisa los horarios marcados con advertencia.
            </Text>
          </Dialog.Content>
          <Dialog.Actions style={styles.validationActions}>
            <Button
              onPress={() => setShowScheduleConflictModal(false)}
              mode="contained"
              style={styles.validationButton}
              contentStyle={styles.validationButtonContent}
              labelStyle={styles.validationButtonLabel}
            >
              Revisar horarios
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </SafeAreaView>
  );
};

const createStyles = (
  theme: AppTheme,
  responsive: any,
  width: number,
  height: number,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    keyboardAvoidingView: {
      flex: 1,
    },
    scrollContent: {
      paddingBottom: responsive.spacing(theme.spacing.xl),
    },
    deliveryContent: {
      flex: 1,
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.m),
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
    errorContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.spacing(theme.spacing.xl),
    },
    errorText: {
      fontSize: responsive.fontSize(16),
      color: theme.colors.error,
      textAlign: 'center',
    },
    // Header y Tabs
    header: {
      backgroundColor: theme.colors.elevation.level2,
      elevation: 0,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
    },
    tabsContainer: {
      flexDirection: 'row',
      height: responsive.scaleHeight(48),
    },
    tab: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      gap: responsive.spacing(theme.spacing.xs),
    },
    tabActive: {
      borderBottomWidth: 2,
      borderBottomColor: theme.colors.primary,
    },
    tabText: {
      fontSize: responsive.fontSize(14),
      fontWeight: '500',
      color: theme.colors.onSurfaceVariant,
    },
    tabTextActive: {
      color: theme.colors.primary,
      fontWeight: '600',
    },
    tabContent: {
      padding: responsive.spacing(theme.spacing.m),
      gap: responsive.spacing(theme.spacing.m),
    },
    // Section styles
    section: {
      borderRadius: 16,
      padding: responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surface,
    },
    sectionHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: responsive.spacing(theme.spacing.m),
    },
    sectionTitle: {
      fontSize: responsive.fontSize(18),
      fontWeight: '600',
      color: theme.colors.onSurface,
      marginLeft: responsive.spacing(theme.spacing.s),
    },
    sectionContent: {
      gap: responsive.spacing(theme.spacing.m),
    },
    // Input styles
    input: {
      backgroundColor: theme.colors.surface,
    },
    inputOutline: {
      borderRadius: 12,
    },
    row: {
      flexDirection: 'row',
      gap: responsive.spacing(theme.spacing.s),
    },
    halfInput: {
      flex: 1,
    },
    // Status styles
    statusRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    statusInfo: {
      flex: 1,
      marginRight: responsive.spacing(theme.spacing.m),
    },
    statusLabel: {
      fontSize: responsive.fontSize(16),
      fontWeight: '500',
      color: theme.colors.onSurface,
      marginBottom: responsive.spacing(theme.spacing.xs),
    },
    statusDescription: {
      fontSize: responsive.fontSize(14),
      color: theme.colors.onSurfaceVariant,
    },
    // Time input styles
    timeInputContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.spacing(theme.spacing.s),
    },
    timeIconWrapper: {
      width: responsive.scaleWidth(40),
      height: responsive.scaleWidth(40),
      borderRadius: responsive.scaleWidth(20),
      backgroundColor: theme.colors.surfaceVariant,
      justifyContent: 'center',
      alignItems: 'center',
    },
    timeInput: {
      flex: 1,
      backgroundColor: theme.colors.surface,
    },
    infoChip: {
      marginTop: responsive.spacing(theme.spacing.xs),
    },
    chip: {
      backgroundColor: theme.colors.secondaryContainer,
    },
    chipText: {
      fontSize: responsive.fontSize(12),
    },
    // Action styles
    actionContainer: {
      marginHorizontal: responsive.spacing(theme.spacing.m),
      marginTop: responsive.spacing(theme.spacing.l),
      alignItems: 'center',
    },
    editButton: {
      borderRadius: 12,
      elevation: 2,
      alignSelf: 'stretch',
    },
    editButtonContent: {
      paddingVertical: responsive.spacing(theme.spacing.xs),
    },
    editButtonLabel: {
      fontSize: responsive.fontSize(16),
      fontWeight: '600',
    },
    editActions: {
      flexDirection: 'row',
      gap: responsive.spacing(theme.spacing.l),
      width: '100%',
      justifyContent: 'center',
      paddingHorizontal: responsive.spacing(theme.spacing.m),
    },
    cancelButton: {
      flex: 1,
      borderRadius: 12,
    },
    saveButton: {
      flex: 1,
      borderRadius: 12,
      elevation: 2,
    },
    buttonContent: {
      paddingVertical: responsive.spacing(theme.spacing.xs),
    },
    // Info Card styles
    infoCard: {
      marginHorizontal: responsive.spacing(theme.spacing.m),
      marginTop: responsive.spacing(theme.spacing.m),
      borderRadius: 12,
      padding: responsive.spacing(theme.spacing.m),
      backgroundColor: theme.colors.surfaceVariant,
    },
    infoContent: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: responsive.spacing(theme.spacing.s),
    },
    infoTextContainer: {
      flex: 1,
    },
    infoTitle: {
      fontSize: responsive.fontSize(12),
      color: theme.colors.onSurfaceVariant,
      opacity: 0.7,
    },
    infoText: {
      fontSize: responsive.fontSize(14),
      fontWeight: '500',
      color: theme.colors.onSurfaceVariant,
    },
    // Estilos para el botn de rea de cobertura
    deliveryButtonContainer: {
      marginTop: responsive.spacing(theme.spacing.l),
      alignItems: 'center',
    },
    deliveryButton: {
      borderRadius: 12,
      width: '100%',
    },
    deliveryButtonContent: {
      paddingVertical: responsive.spacing(theme.spacing.s),
    },
    deliveryButtonLabel: {
      fontSize: responsive.fontSize(16),
      fontWeight: '500',
    },
    deliveryStatusText: {
      fontSize: responsive.fontSize(12),
      color: theme.colors.onSurfaceVariant,
      marginTop: responsive.spacing(theme.spacing.xs),
      fontStyle: 'italic',
    },
    deliveryStatusWarning: {
      color: theme.colors.error,
    },
    // Estilos para el modal
    deliveryDialog: {
      maxWidth: width * 0.95,
      width: width * 0.95,
      maxHeight: height * 0.9,
      alignSelf: 'center',
      borderRadius: 20,
      backgroundColor: theme.colors.surface,
      borderWidth: 1,
      borderColor: theme.colors.outlineVariant,
      elevation: 8,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 4 },
      shadowOpacity: 0.15,
      shadowRadius: 12,
    },
    deliveryDialogContent: {
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.m),
      paddingBottom: responsive.spacing(theme.spacing.m),
    },
    deliveryMapWrapper: {
      borderRadius: 12,
      padding: responsive.spacing(theme.spacing.xs),
      backgroundColor: theme.colors.surfaceVariant,
    },
    deliveryMapContainer: {
      height: height * 0.65,
      width: '100%',
      borderRadius: 8,
      overflow: 'hidden',
    },
    deliveryDialogActions: {
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingVertical: responsive.spacing(theme.spacing.m),
      paddingBottom: responsive.spacing(theme.spacing.l),
    },
    deliveryDialogButtonsContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      gap: responsive.spacing(theme.spacing.m),
    },
    deliveryDialogButton: {
      flex: 1,
      borderRadius: 12,
    },
    cancelButtonLabel: {
      fontSize: responsive.fontSize(16),
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    // Estilos para el modal de validacin
    validationDialog: {
      borderRadius: 24,
      backgroundColor: theme.colors.surface,
      maxWidth: 340,
      width: '85%',
      alignSelf: 'center',
      paddingVertical: 0,
    },
    validationIconContainer: {
      alignItems: 'center',
      marginTop: responsive.spacing(theme.spacing.m),
      marginBottom: responsive.spacing(theme.spacing.s),
    },
    validationIconWrapper: {
      width: responsive.scaleWidth(64),
      height: responsive.scaleWidth(64),
      borderRadius: responsive.scaleWidth(32),
      backgroundColor: theme.colors.errorContainer,
      justifyContent: 'center',
      alignItems: 'center',
    },
    validationTitle: {
      textAlign: 'center',
      fontSize: responsive.fontSize(18),
      fontWeight: '600',
      color: theme.colors.onSurface,
      marginBottom: responsive.spacing(theme.spacing.xs),
      paddingHorizontal: responsive.spacing(theme.spacing.m),
    },
    validationMessage: {
      textAlign: 'center',
      fontSize: responsive.fontSize(15),
      color: theme.colors.onSurface,
      marginBottom: responsive.spacing(theme.spacing.s),
      lineHeight: responsive.fontSize(21),
      paddingHorizontal: responsive.spacing(theme.spacing.s),
    },
    validationHint: {
      textAlign: 'center',
      fontSize: responsive.fontSize(13),
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
      lineHeight: responsive.fontSize(18),
      paddingHorizontal: responsive.spacing(theme.spacing.s),
    },
    validationActions: {
      paddingBottom: responsive.spacing(theme.spacing.m),
      paddingHorizontal: responsive.spacing(theme.spacing.m),
      paddingTop: responsive.spacing(theme.spacing.xs),
    },
    validationButton: {
      borderRadius: 12,
      minWidth: 120,
    },
    validationButtonContent: {
      paddingVertical: responsive.spacing(theme.spacing.s),
    },
    validationButtonLabel: {
      fontSize: responsive.fontSize(16),
      fontWeight: '600',
    },
  });

export default RestaurantConfigScreen;

================
File: app/src/app/navigation/KitchenOnlyNavigator.tsx
================
import { useEffect, useMemo } from 'react';
import {
  BackHandler,
  StatusBar,
  StyleSheet,
  Platform,
} from 'react-native';
import { createDrawerNavigator } from '@react-navigation/drawer';
import KitchenOrdersScreen from '../../modules/kitchen/screens/KitchenOrdersScreen';
import { CustomDrawerContent } from './components/CustomDrawerContent';
import { ServerSettingsScreen } from '../../modules/settings/screens/ServerSettingsScreen';
import { useAppTheme } from '../styles/theme';
import { Icon } from 'react-native-paper';
import { useResponsive } from '../hooks/useResponsive';
import { KitchenProvider } from '../../modules/kitchen/context/KitchenContext';
import { useKitchenHeader } from './components/KitchenHeader';

const Drawer = createDrawerNavigator();

function KitchenOnlyNavigatorContent() {
  const theme = useAppTheme();

  // Prevenir navegacin hacia atrs en Android (no aplicar en web)
  useEffect(() => {
    if (Platform.OS !== 'web') {
      const backHandler = BackHandler.addEventListener(
        'hardwareBackPress',
        () => {
          // Retornar true previene el comportamiento por defecto
          return true;
        },
      );

      return () => backHandler.remove();
    }
  }, []);

  const responsive = useResponsive();

  const styles = useMemo(
    () =>
      StyleSheet.create({
        headerStyle: {
          backgroundColor: theme.colors.primary,
          height: responsive.isWeb ? 80 : responsive.dimensions.headerHeight,
          elevation: 2,
        },
        headerTitleStyle: {
          ...theme.fonts.titleLarge,
          color: theme.colors.onPrimary,
          fontWeight: 'bold',
          fontSize: responsive.isWeb ? 26 : responsive.isTablet ? 20 : 22,
        },
        drawerStyle: {
          backgroundColor: theme.colors.surface,
          width: responsive.isWeb ? 320 : responsive.dimensions.drawerWidth,
          borderTopRightRadius: responsive.isWeb ? 0 : theme.roundness * 2,
          borderBottomRightRadius: responsive.isWeb ? 0 : theme.roundness * 2,
          borderRightWidth: 0,
          borderRightColor: theme.colors.outlineVariant,
          elevation: 2,
          shadowColor: '#000',
          shadowOffset: { width: 0, height: 0 },
          shadowOpacity: 0,
          shadowRadius: 0,
        },
      }),
    [theme, responsive],
  );

  return (
    <>
      <StatusBar
        backgroundColor={theme.colors.primary}
        barStyle={theme.dark ? 'light-content' : 'dark-content'}
      />
      <Drawer.Navigator
        initialRouteName="Kitchen"
        drawerContent={(props) => <CustomDrawerContent {...props} />}
        defaultStatus="closed"
        screenOptions={({ navigation }) => {
          const kitchenHeader = useKitchenHeader({
            onMenuPress: () => navigation.openDrawer(),
          });

          return {
            headerStyle: styles.headerStyle,
            headerTintColor: theme.colors.onPrimary,
            headerTitleStyle: styles.headerTitleStyle,
            drawerStyle: styles.drawerStyle,
            drawerActiveTintColor: theme.colors.primary,
            drawerInactiveTintColor: theme.colors.onSurfaceVariant,
            drawerLabelStyle: {
              ...theme.fonts.labelLarge,
              fontSize: responsive.fontSizePreset.m,
            },
            drawerItemStyle: {
              marginVertical: responsive.spacingPreset.xxs,
              borderRadius: theme.roundness * 2,
              paddingVertical: responsive.spacingPreset.xxs,
              paddingHorizontal: responsive.spacingPreset.xs,
            },
            headerShown: true,
            drawerType: 'slide',
            drawerPosition: 'left',
            headerShadowVisible: false,
            swipeEdgeWidth: 0,
            swipeEnabled: false,
            drawerHideStatusBarOnOpen: false,
            headerLeft: kitchenHeader.MenuButton,
            headerTitle: kitchenHeader.Title,
            headerRight: kitchenHeader.RightActions,
          };
        }}
      >
        <Drawer.Screen
          name="Kitchen"
          options={({ navigation }) => {
            const kitchenHeader = useKitchenHeader({
              onMenuPress: () => navigation.openDrawer(),
            });
            return {
              title: kitchenHeader.screenName,
              drawerIcon: ({ color, size }) => (
                <Icon source="chef-hat" color={color} size={size} />
              ),
            };
          }}
        >
          {() => <KitchenOrdersScreen />}
        </Drawer.Screen>

        <Drawer.Screen
          name="ServerSettings"
          component={ServerSettingsScreen}
          options={{
            title: 'Configuracin del Servidor',
            drawerIcon: ({ color, size }) => (
              <Icon source="server-network" color={color} size={size} />
            ),
            headerShown: true,
            headerStyle: styles.headerStyle,
            headerTintColor: theme.colors.onPrimary,
            headerTitleStyle: styles.headerTitleStyle,
          }}
        />
      </Drawer.Navigator>
    </>
  );
}

export function KitchenOnlyNavigator() {
  // Usar navegador web personalizado en plataforma web
  if (Platform.OS === 'web') {
    // Importacin dinmica para evitar problemas de bundling
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const { KitchenWebNavigator } = require('./KitchenWebNavigator') as {
      KitchenWebNavigator: React.ComponentType;
    };
    return <KitchenWebNavigator />;
  }

  // Usar navegador nativo para otras plataformas
  return (
    <KitchenProvider>
      <KitchenOnlyNavigatorContent />
    </KitchenProvider>
  );
}

================
File: app/src/modules/orderFinalization/components/OrderCard.tsx
================
import React from 'react';
import { View, StyleSheet, TouchableOpacity } from 'react-native';
import {
  Card,
  Text,
  Checkbox,
  Chip,
  IconButton,
  Icon,
} from 'react-native-paper';
import { OrderForFinalizationList } from '../schema/orderFinalization.schema';
import { useAppTheme } from '@/app/styles/theme';
import { useResponsive } from '@/app/hooks/useResponsive';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import {
  formatOrderTypeShort,
  OrderStatusInfo,
  getPaymentStatus,
} from '@/modules/orders/utils/formatters';

interface OrderCardProps {
  order: OrderForFinalizationList;
  isSelected: boolean;
  onToggleSelection: (orderId: string) => void;
  onShowDetails: (order: OrderForFinalizationList) => void;
  onPrintPress?: (order: OrderForFinalizationList) => void;
}

export const OrderCard = React.memo<OrderCardProps>(
  ({ order, isSelected, onToggleSelection, onShowDetails, onPrintPress }) => {
    const theme = useAppTheme();
    const responsive = useResponsive();
    const styles = React.useMemo(
      () => createStyles(responsive, theme),
      [responsive, theme],
    );

    let orderTitle = `#${order.shiftOrderNumber}  ${formatOrderTypeShort(order.orderType)}`;

    if (order.orderType === 'DINE_IN' && order.table) {
      const tableDisplay = order.table.isTemporary
        ? order.table.name
        : `Mesa ${order.table.name || order.table.number || 'N/A'}`;
      orderTitle += `  ${order.table.area?.name || 'Sin rea'}  ${tableDisplay}`;
    } else if (order.orderType === 'TAKE_AWAY') {
      if (order.deliveryInfo?.recipientName) {
        orderTitle += `  ${order.deliveryInfo.recipientName}`;
      }
      if (order.deliveryInfo?.recipientPhone) {
        orderTitle += `  ${order.deliveryInfo.recipientPhone}`;
      }
    } else if (order.orderType === 'DELIVERY') {
      if (order.deliveryInfo?.fullAddress) {
        orderTitle += `  ${order.deliveryInfo.fullAddress}`;
      }
      if (order.deliveryInfo?.recipientPhone) {
        orderTitle += `  ${order.deliveryInfo.recipientPhone}`;
      }
    }

    const totalAmount =
      typeof order.total === 'string' ? parseFloat(order.total) : order.total;
    const totalPaid = order.paymentsSummary?.totalPaid || 0;
    const pendingAmount = totalAmount - totalPaid;

    const paymentStatus = getPaymentStatus(order);

    return (
      <TouchableOpacity
        activeOpacity={0.95}
        onPress={() => onShowDetails(order)}
      >
        <Card
          style={[
            styles.orderCard,
            isSelected ? styles.selectedCard : styles.unselectedCard,
          ]}
          mode="elevated"
        >
          <Card.Content style={styles.cardContent}>
            <View style={styles.mainContainer}>
              <View style={styles.leftContainer}>
                <Text
                  style={[
                    styles.orderNumber,
                    {
                      color: isSelected
                        ? theme.colors.onPrimaryContainer
                        : theme.colors.onSurface,
                    },
                  ]}
                >
                  {orderTitle}
                  <Text
                    style={[
                      styles.orderPrice,
                      pendingAmount > 0 ? styles.unpaidPrice : styles.paidPrice,
                    ]}
                  >
                    {'  '}
                    {pendingAmount > 0
                      ? `Por pagar: $${pendingAmount.toFixed(2)}`
                      : `Pagado: $${totalAmount.toFixed(2)}`}
                  </Text>
                  {order.notes && (
                    <Text
                      style={[
                        styles.notesInline,
                        {
                          color: isSelected
                            ? theme.colors.onPrimaryContainer
                            : theme.colors.onSurfaceVariant,
                        },
                      ]}
                      numberOfLines={1}
                    >
                      {'  '}
                      {order.notes}
                    </Text>
                  )}
                </Text>
                <View style={styles.timeAndPaymentRow}>
                  <Text
                    style={[
                      styles.orderTime,
                      {
                        color: isSelected
                          ? theme.colors.primary
                          : theme.colors.primary,
                      },
                    ]}
                  >
                    {format(new Date(order.createdAt), 'p', { locale: es })}
                  </Text>
                  {(() => {
                    const color =
                      paymentStatus.status === 'paid'
                        ? '#10B981'
                        : paymentStatus.status === 'partial'
                          ? '#F59E0B'
                          : '#EF4444';
                    const icon =
                      paymentStatus.status === 'paid'
                        ? ''
                        : paymentStatus.status === 'partial'
                          ? ''
                          : '';
                    return (
                      <View
                        style={[
                          styles.miniPaymentBadge,
                          { backgroundColor: color },
                        ]}
                      >
                        <Text style={styles.miniPaymentText}>{icon}</Text>
                      </View>
                    );
                  })()}

                  {/* Badge de WhatsApp */}
                  {order.isFromWhatsApp && (
                    <View
                      style={[
                        styles.inlinePreparationBadge,
                        styles.whatsappBadge,
                      ]}
                    >
                      <Icon source="whatsapp" size={12} color="#FFFFFF" />
                    </View>
                  )}

                  {order.preparationScreenStatuses &&
                    order.preparationScreenStatuses.length > 0 && (
                      <>
                        {order.preparationScreenStatuses.map(
                          (screen, index) => {
                            const backgroundColor =
                              screen.status === 'READY'
                                ? '#4CAF50'
                                : screen.status === 'IN_PROGRESS'
                                  ? '#FFA000'
                                  : isSelected
                                    ? theme.colors.primaryContainer
                                    : theme.colors.surfaceVariant;

                            const textColor =
                              screen.status === 'READY' ||
                              screen.status === 'IN_PROGRESS'
                                ? '#FFFFFF'
                                : isSelected
                                  ? theme.colors.onPrimaryContainer
                                  : theme.colors.onSurfaceVariant;

                            return (
                              <View
                                key={`${order.id}-screen-${index}`}
                                style={[
                                  styles.inlinePreparationBadge,
                                  {
                                    backgroundColor,
                                    borderColor:
                                      backgroundColor ===
                                      theme.colors.surfaceVariant
                                        ? theme.colors.outline
                                        : backgroundColor,
                                  },
                                ]}
                              >
                                <Text
                                  style={[
                                    styles.inlinePreparationText,
                                    { color: textColor },
                                  ]}
                                >
                                  {screen.status === 'READY'
                                    ? ' '
                                    : screen.status === 'IN_PROGRESS'
                                      ? ' '
                                      : ''}
                                   {screen.name}
                                </Text>
                              </View>
                            );
                          },
                        )}
                      </>
                    )}
                </View>
              </View>

              <View style={styles.rightContainer}>
                {order.createdBy && (
                  <Text
                    style={[
                      styles.createdByText,
                      {
                        color: isSelected
                          ? theme.colors.onPrimaryContainer
                          : theme.colors.onSurfaceVariant,
                      },
                    ]}
                    numberOfLines={1}
                  >
                    {order.createdBy.firstName && order.createdBy.lastName
                      ? `${order.createdBy.firstName} ${order.createdBy.lastName}`
                      : order.createdBy.username}
                  </Text>
                )}
                <Chip
                  mode="flat"
                  compact
                  style={[
                    styles.statusChip,
                    {
                      backgroundColor: OrderStatusInfo.getColor(
                        order.orderStatus,
                        theme,
                      ),
                    },
                  ]}
                  textStyle={styles.statusChipText}
                >
                  {OrderStatusInfo.getLabel(order.orderStatus)}
                </Chip>
                <View style={styles.actionsContainer}>
                  {onPrintPress && (
                    <TouchableOpacity
                      style={styles.printContainer}
                      onPress={() => onPrintPress(order)}
                      activeOpacity={0.7}
                    >
                      <IconButton
                        icon="printer"
                        size={32}
                        style={styles.printButton}
                        disabled
                      />
                      {(order.ticketImpressionCount ?? 0) > 0 && (
                        <View style={styles.printCountBadge}>
                          <Text style={styles.printCountText}>
                            {order.ticketImpressionCount}
                          </Text>
                        </View>
                      )}
                    </TouchableOpacity>
                  )}
                  <View style={[styles.checkboxContainer, styles.checkbox]}>
                    <Checkbox
                      status={isSelected ? 'checked' : 'unchecked'}
                      onPress={() => {
                        onToggleSelection(order.id);
                      }}
                      color={theme.colors.primary}
                    />
                  </View>
                </View>
              </View>
            </View>
          </Card.Content>
        </Card>
      </TouchableOpacity>
    );
  },
);

OrderCard.displayName = 'OrderCard';

const createStyles = (
  responsive: ReturnType<typeof useResponsive>,
  theme: ReturnType<typeof useAppTheme>,
) =>
  StyleSheet.create({
    orderCard: {
      marginBottom: responsive.isTablet ? 6 : 8,
    },
    cardContent: {
      paddingBottom: responsive.isTablet ? 6 : 8,
      paddingTop: responsive.isTablet ? 8 : 12,
      paddingHorizontal: responsive.isTablet ? 12 : 16,
    },
    mainContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
    },
    leftContainer: {
      flex: 1,
      paddingRight: 8,
    },
    rightContainer: {
      alignItems: 'flex-end',
      justifyContent: 'space-between',
      minWidth: responsive.isTablet ? 120 : 140,
      gap: responsive.isTablet ? 4 : 8,
    },
    actionsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'flex-end',
      gap: 4,
    },
    orderNumber: {
      fontSize: responsive.isTablet ? 14 : 16,
      fontWeight: 'bold',
      lineHeight: responsive.isTablet ? 18 : 22,
      marginBottom: responsive.isTablet ? 2 : 4,
    },
    orderPrice: {
      fontSize: responsive.isTablet ? 13 : 15,
      fontWeight: '700',
    },
    statusChip: {
      minHeight: 24,
      alignSelf: 'flex-end',
      paddingVertical: 2,
    },
    statusChipText: {
      fontSize: responsive.isTablet ? 10 : 12,
      fontWeight: '600',
      color: 'white',
      lineHeight: responsive.isTablet ? 12 : 14,
      marginVertical: 0,
      paddingVertical: 0,
    },
    orderTime: {
      fontSize: responsive.isTablet ? 13 : 16,
      fontWeight: '600',
    },
    timeAndPaymentRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 0,
    },
    checkboxContainer: {
      padding: 8,
      marginLeft: -8,
      marginRight: -12,
    },
    checkbox: {
      margin: 0,
      transform: [{ scale: 1.5 }],
    },
    notesInline: {
      fontSize: 12,
      fontStyle: 'italic',
    },
    inlinePreparationBadge: {
      paddingHorizontal: 6,
      paddingVertical: 2,
      borderRadius: 10,
      borderWidth: 0.5,
      marginLeft: 4,
    },
    inlinePreparationText: {
      fontSize: 10,
      fontWeight: '500',
    },
    miniPaymentBadge: {
      width: 20,
      height: 20,
      borderRadius: 10,
      alignItems: 'center',
      justifyContent: 'center',
      marginLeft: 6,
    },
    miniPaymentText: {
      fontSize: 10,
      fontWeight: 'bold',
      color: '#FFFFFF',
    },
    createdByText: {
      fontSize: 10,
      marginBottom: 4,
      textAlign: 'right',
    },
    printButton: {
      margin: -4,
    },
    printContainer: {
      position: 'relative',
      alignItems: 'center',
      justifyContent: 'center',
    },
    printCountBadge: {
      position: 'absolute',
      top: 0,
      right: 0,
      backgroundColor: '#3B82F6',
      borderRadius: 10,
      minWidth: 20,
      height: 20,
      paddingHorizontal: 4,
      alignItems: 'center',
      justifyContent: 'center',
    },
    printCountText: {
      color: '#FFFFFF',
      fontSize: 10,
      fontWeight: 'bold',
    },
    selectedCard: {
      backgroundColor: theme.colors.primaryContainer,
      borderColor: theme.colors.primary,
      borderWidth: 2,
    },
    unselectedCard: {
      backgroundColor: theme.colors.surface,
      borderColor: 'transparent',
      borderWidth: 0,
    },
    paidPrice: {
      color: '#10B981',
    },
    unpaidPrice: {
      color: theme.colors.error,
    },
    whatsappBadge: {
      backgroundColor: '#25D366',
      borderColor: '#25D366',
    },
  });

================
File: app/src/components/AudioOrderModal.tsx
================
import React, { useState, useEffect, useCallback, useMemo } from 'react';
import {
  View,
  ScrollView,
  StyleSheet,
  ActivityIndicator,
  TouchableOpacity,
  Animated,
} from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  Divider,
  Surface,
  IconButton,
} from 'react-native-paper';
import { MaterialIcons } from '@expo/vector-icons';
import { useAppTheme } from '../app/styles/theme';
import { useGetOrderMenu } from '@/modules/orders/hooks/useMenuQueries';
import type {
  AIOrderItem,
  DeliveryInfoData,
  ScheduledDeliveryData,
} from '@/services/audioOrderService';
import ProductCustomizationModal from '@/modules/orders/components/ProductCustomizationModal';
import type { FullMenuProduct as Product } from '@/modules/orders/schema/orders.schema';
import type {
  CartItem,
  CartItemModifier,
} from '@/modules/orders/stores/useOrderStore';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import type { SelectedPizzaCustomization } from '@/app/schemas/domain/order.schema';
import { Swipeable } from 'react-native-gesture-handler';
import {
  OrderTypeEnum,
  type OrderType,
} from '@/modules/orders/schema/orders.schema';
import SpeechRecognitionInput from '@/app/components/common/SpeechRecognitionInput';
import { useGetAreas } from '@/modules/areasTables/hooks/useAreasQueries';
import { useGetTablesByAreaId } from '@/modules/areasTables/hooks/useTablesQueries';
import type { Area } from '@/modules/areasTables/schema/area.schema';
import type { Table } from '@/modules/areasTables/schema/table.schema';
import AnimatedLabelSelector from '@/app/components/common/AnimatedLabelSelector';
import { Menu, Checkbox, HelperText } from 'react-native-paper';
import type { DeliveryInfo } from '@/app/schemas/domain/delivery-info.schema';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';

interface AudioOrderModalProps {
  visible: boolean;
  onDismiss: () => void;
  onConfirm: (
    items: AIOrderItem[],
    deliveryInfo?: DeliveryInfoData,
    scheduledDelivery?: ScheduledDeliveryData,
    orderType?: OrderType,
  ) => void;
  isProcessing: boolean;
  orderData?: {
    orderItems?: AIOrderItem[];
    deliveryInfo?: DeliveryInfoData;
    scheduledDelivery?: ScheduledDeliveryData;
    orderType?: OrderType;
    warnings?: string;
    processingTime?: number;
  };
  error?: string;
}

export const AudioOrderModal: React.FC<AudioOrderModalProps> = ({
  visible,
  onDismiss,
  onConfirm,
  isProcessing,
  orderData,
  error,
}) => {
  const theme = useAppTheme();
  const { colors } = theme;
  const [editableDeliveryInfo, setEditableDeliveryInfo] =
    useState<DeliveryInfo>({});
  const [editableItems, setEditableItems] = useState<AIOrderItem[]>([]);
  const [editableOrderType, setEditableOrderType] = useState<OrderType>(
    OrderTypeEnum.DINE_IN,
  );
  const [editableSelectedAreaId, setEditableSelectedAreaId] = useState<
    string | null
  >(null);
  const [editableSelectedTableId, setEditableSelectedTableId] = useState<
    string | null
  >(null);
  const [editableIsTemporaryTable, setEditableIsTemporaryTable] =
    useState<boolean>(false);
  const [editableTemporaryTableName, setEditableTemporaryTableName] =
    useState<string>('');
  const [editingItem, setEditingItem] = useState<CartItem | null>(null);
  const [editingProduct, setEditingProduct] = useState<Product | null>(null);
  const [showCustomizationModal, setShowCustomizationModal] = useState(false);

  // Estados para validacin de productos
  const [itemsWithErrors, setItemsWithErrors] = useState<Set<number>>(
    new Set(),
  );
  const [itemValidationErrors, setItemValidationErrors] = useState<
    Record<number, string[]>
  >({});

  // Estados de error
  const [areaError, setAreaError] = useState<string | null>(null);
  const [tableError, setTableError] = useState<string | null>(null);
  const [recipientNameError, setRecipientNameError] = useState<string | null>(
    null,
  );
  const [recipientPhoneError, setRecipientPhoneError] = useState<string | null>(
    null,
  );
  const [addressError, setAddressError] = useState<string | null>(null);

  // Estado para modal de confirmacin de salida
  const [showExitConfirmationModal, setShowExitConfirmationModal] =
    useState(false);

  // Estados de mens
  const [areaMenuVisible, setAreaMenuVisible] = useState(false);
  const [tableMenuVisible, setTableMenuVisible] = useState(false);

  const { data: menu } = useGetOrderMenu();

  // Queries para reas y mesas
  const {
    data: areasData,
    isLoading: isLoadingAreas,
    error: errorAreas,
  } = useGetAreas();
  const {
    data: tablesData,
    isLoading: isLoadingTables,
    error: errorTables,
  } = useGetTablesByAreaId(editableSelectedAreaId, {});
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  // Nombres computed para rea y mesa
  const selectedAreaName = useMemo(
    () => areasData?.find((a: Area) => a.id === editableSelectedAreaId)?.name,
    [areasData, editableSelectedAreaId],
  );
  const selectedTableName = useMemo(() => {
    return tablesData?.find((t) => t.id === editableSelectedTableId)?.name;
  }, [tablesData, editableSelectedTableId]);

  // Funcin para validar un producto segn las reglas del ProductCustomizationModal
  const validateProductItem = useCallback(
    (item: AIOrderItem, product?: Product) => {
      if (!menu || !product) return [];

      const errors: string[] = [];

      // 1. Validar variante requerida
      if (
        product.hasVariants &&
        product.variants &&
        product.variants.length > 0
      ) {
        if (!item.variantId) {
          errors.push('Variante requerida');
        }
      }

      // 2. Validar modificadores requeridos
      if (product.modifierGroups && product.modifierGroups.length > 0) {
        for (const group of product.modifierGroups) {
          const selectedModifiersInGroup = (item.modifiers || []).filter(
            (modName) => {
              // Buscar si este modificador pertenece a este grupo
              return group.productModifiers?.some((pm) => pm.name === modName);
            },
          );

          const selectedCount = selectedModifiersInGroup.length;
          const minRequired = Math.max(
            group.minSelections || 0,
            group.isRequired ? 1 : 0,
          );

          if (selectedCount < minRequired) {
            if (group.isRequired && minRequired === 1) {
              errors.push(`${group.name}: Requerido`);
            } else {
              errors.push(`${group.name}: Mnimo ${minRequired}`);
            }
          }

          // Validar mximo
          if (group.maxSelections && selectedCount > group.maxSelections) {
            errors.push(`${group.name}: Mximo ${group.maxSelections}`);
          }
        }
      }

      // 3. Validar personalizaciones de pizza
      if (product.isPizza && item.pizzaCustomizations) {
        // Las pizzas necesitan al menos una personalizacin vlida
        const validCustomizations = item.pizzaCustomizations.filter(
          (custom) => custom.customizationId && custom.action,
        );

        if (validCustomizations.length === 0) {
          errors.push('Pizza requiere personalizaciones');
        }
      }

      return errors;
    },
    [menu],
  );

  // Funcin para encontrar el producto completo en el men
  const findProductInMenu = useCallback(
    (productId: string): Product | undefined => {
      if (!menu) return undefined;

      for (const category of (menu as any[]) || []) {
        for (const subcategory of category.subcategories || []) {
          for (const product of subcategory.products || []) {
            if (product.id === productId) {
              return product;
            }
          }
        }
      }
      return undefined;
    },
    [menu],
  );

  // Validar todos los productos cuando cambien
  useEffect(() => {
    if (!editableItems || editableItems.length === 0) {
      setItemsWithErrors(new Set());
      setItemValidationErrors({});
      return;
    }

    const newItemsWithErrors = new Set<number>();
    const newValidationErrors: Record<number, string[]> = {};

    editableItems.forEach((item, index) => {
      const product = findProductInMenu(item.productId);
      const errors = validateProductItem(item, product);

      if (errors.length > 0) {
        newItemsWithErrors.add(index);
        newValidationErrors[index] = errors;
      }
    });

    setItemsWithErrors(newItemsWithErrors);
    setItemValidationErrors(newValidationErrors);
  }, [editableItems, findProductInMenu, validateProductItem]);

  // Verificar si hay productos con errores que bloqueen el guardado
  const hasValidationErrors = useMemo(() => {
    return itemsWithErrors.size > 0;
  }, [itemsWithErrors]);

  // Verificar si hay datos modificados que se perderan al salir
  const hasUnsavedChanges = useMemo(() => {
    // Si hay productos procesados o datos editados, hay cambios sin guardar
    return (
      editableItems.length > 0 ||
      editableDeliveryInfo.recipientName?.trim() ||
      editableDeliveryInfo.recipientPhone?.trim() ||
      editableDeliveryInfo.fullAddress?.trim() ||
      editableSelectedAreaId ||
      editableSelectedTableId ||
      editableTemporaryTableName?.trim()
    );
  }, [
    editableItems.length,
    editableDeliveryInfo.recipientName,
    editableDeliveryInfo.recipientPhone,
    editableDeliveryInfo.fullAddress,
    editableSelectedAreaId,
    editableSelectedTableId,
    editableTemporaryTableName,
  ]);

  // Sincronizar la informacin cuando cambie orderData
  useEffect(() => {
    if (orderData?.deliveryInfo) {
      setEditableDeliveryInfo(orderData.deliveryInfo as DeliveryInfo);
    }
    if (orderData?.orderItems) {
      setEditableItems(orderData.orderItems);
    }
    // Si orderType viene del backend, usarlo; si es undefined, usar DELIVERY como defecto
    if (orderData?.orderType !== undefined) {
      setEditableOrderType(orderData.orderType);
    } else if (orderData) {
      // Solo cambiar a DELIVERY si hay datos de la orden pero orderType es undefined
      setEditableOrderType(OrderTypeEnum.DELIVERY);
    }
  }, [orderData]);

  // Limpiar errores cuando cambie el tipo de orden
  useEffect(() => {
    setAreaError(null);
    setTableError(null);
    setRecipientNameError(null);
    setRecipientPhoneError(null);
    setAddressError(null);
  }, [editableOrderType]);

  const handleConfirm = () => {
    // Resetear errores
    setAreaError(null);
    setTableError(null);
    setRecipientNameError(null);
    setRecipientPhoneError(null);
    setAddressError(null);

    if (editableItems && editableItems.length > 0) {
      // Solo verificar errores de validacin de productos
      if (hasValidationErrors) {
        showSnackbar({
          message:
            'Hay productos con errores que deben corregirse antes de continuar',
          type: 'error',
        });
        return;
      }

      // Crear deliveryInfo adaptada
      const adaptedDeliveryInfo: DeliveryInfoData = {
        recipientName: editableDeliveryInfo.recipientName,
        recipientPhone: editableDeliveryInfo.recipientPhone,
        fullAddress: editableDeliveryInfo.fullAddress,
      };

      onConfirm(
        editableItems,
        adaptedDeliveryInfo,
        orderData?.scheduledDelivery,
        editableOrderType,
      );
    }
  };

  // Funcin para actualizar la cantidad de un item
  const updateItemQuantity = useCallback(
    (_itemId: string, index: number, newQuantity: number) => {
      if (newQuantity < 1) {
        return; // No permitir cantidad menor a 1 con los botones
      }

      setEditableItems((prev) =>
        prev.map((item, i) => {
          if (i === index) {
            return { ...item, quantity: newQuantity };
          }
          return item;
        }),
      );
    },
    [],
  );

  // Funcin para eliminar un item
  const removeItem = useCallback(
    (index: number) => {
      setEditableItems((prev) => prev.filter((_, i) => i !== index));
      showSnackbar({
        message: 'Producto eliminado',
        type: 'info',
      });
    },
    [showSnackbar],
  );

  // Funcin para manejar la edicin de un item
  const handleEditItem = useCallback(
    (item: AIOrderItem, index: number) => {
      if (!menu) {
        showSnackbar({
          message: 'El men no est disponible',
          type: 'error',
        });
        return;
      }

      // Buscar el producto en el men
      let foundProduct: Product | null = null;
      outer: for (const category of (menu as any[]) || []) {
        for (const subcategory of category.subcategories || []) {
          for (const product of subcategory.products || []) {
            if (product.id === item.productId) {
              foundProduct = product;
              break outer;
            }
          }
        }
      }

      if (!foundProduct) {
        showSnackbar({
          message: 'Producto no encontrado en el men',
          type: 'error',
        });
        return;
      }

      // Convertir AIOrderItem a CartItem para el modal
      const cartItem: CartItem = {
        id: `${item.productId}-${index}`,
        productId: item.productId,
        productName: foundProduct.name,
        quantity: item.quantity,
        unitPrice:
          foundProduct.variants?.find((v) => v.id === item.variantId)?.price ||
          foundProduct.price ||
          0,
        totalPrice: 0, // Se calcular en el modal
        modifiers:
          item.modifiers?.map((modName) => {
            // Buscar el modificador en el producto
            for (const modGroup of foundProduct.modifierGroups || []) {
              const modifier = modGroup.productModifiers?.find(
                (m) => m.name === modName,
              );
              if (modifier) {
                return {
                  id: modifier.id,
                  modifierGroupId: modGroup.id,
                  name: modifier.name,
                  price: modifier.price || 0,
                };
              }
            }
            return {
              id: modName,
              modifierGroupId: '',
              name: modName,
              price: 0,
            };
          }) || [],
        variantId: item.variantId,
        variantName: foundProduct.variants?.find((v) => v.id === item.variantId)
          ?.name,
        selectedPizzaCustomizations: item.pizzaCustomizations?.map((pc) => ({
          pizzaCustomizationId: pc.customizationId,
          half: pc.half as any,
          action: pc.action as any,
        })),
      };

      setEditingItem(cartItem);
      setEditingProduct(foundProduct);
      setShowCustomizationModal(true);
    },
    [menu, showSnackbar],
  );

  // Funcin para manejar la actualizacin desde el modal
  const handleUpdateEditedItem = useCallback(
    (
      itemId: string,
      quantity: number,
      modifiers: CartItemModifier[],
      _preparationNotes?: string,
      variantId?: string,
      _variantName?: string,
      _unitPrice?: number,
      selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    ) => {
      const index = parseInt(itemId.split('-').pop() || '0');

      setEditableItems((prev) =>
        prev.map((item, i) => {
          if (i === index) {
            return {
              ...item,
              quantity,
              variantId,
              modifiers: modifiers.map((m) => m.name),
              pizzaCustomizations: selectedPizzaCustomizations?.map((pc) => ({
                customizationId: pc.pizzaCustomizationId,
                half: pc.half,
                action: pc.action,
              })),
            };
          }
          return item;
        }),
      );

      setShowCustomizationModal(false);
      setEditingItem(null);
      setEditingProduct(null);

      showSnackbar({
        message: 'Producto actualizado',
        type: 'success',
      });
    },
    [showSnackbar],
  );

  // Funciones para manejo de confirmacin de salida
  const handleAttemptExit = useCallback(() => {
    if (!hasUnsavedChanges) {
      onDismiss();
    } else {
      setShowExitConfirmationModal(true);
    }
  }, [hasUnsavedChanges, onDismiss]);

  const handleConfirmExit = useCallback(() => {
    setShowExitConfirmationModal(false);
    onDismiss();
  }, [onDismiss]);

  const handleCancelExit = useCallback(() => {
    setShowExitConfirmationModal(false);
  }, []);

  // Funcin para obtener el nombre del producto desde el men
  const getProductDetails = (productId: string, variantId?: string) => {
    if (!menu)
      return {
        productName: `Producto ${productId.slice(-4)}`,
        variantName: undefined,
      };

    for (const category of (menu as any[]) || []) {
      for (const subcategory of category.subcategories || []) {
        for (const product of subcategory.products || []) {
          if (product.id === productId) {
            const variant = variantId
              ? product.variants?.find((v: any) => v.id === variantId)
              : undefined;
            return {
              productName: product.name,
              variantName: variant?.name,
            };
          }
        }
      }
    }
    return {
      productName: `Producto ${productId.slice(-4)}`,
      variantName: undefined,
    };
  };

  // Funcin para formatear personalizaciones de pizza
  const formatPizzaCustomizations = (
    customizations?: AIOrderItem['pizzaCustomizations'],
  ) => {
    if (!customizations || customizations.length === 0) return '';

    const groupedByHalf = customizations.reduce(
      (acc, curr) => {
        const half = curr.half || 'FULL';
        if (!acc[half]) {
          acc[half] = { ingredients: [] };
        }

        let name = curr.customizationName;
        if (!name && menu) {
          // Buscar el nombre en el men
          outer: for (const category of (menu as any[]) || []) {
            for (const subcategory of category.subcategories || []) {
              for (const product of subcategory.products || []) {
                if (product.pizzaCustomizations) {
                  const customization = product.pizzaCustomizations.find(
                    (pc: any) => pc.id === curr.customizationId,
                  );
                  if (customization) {
                    name = customization.name;
                    break outer;
                  }
                }
              }
            }
          }
        }

        if (!name) {
          name = curr.customizationId.slice(-4);
        }

        const prefix = curr.action === 'ADD' ? '+ ' : '- ';
        acc[half].ingredients.push(prefix + name);

        return acc;
      },
      {} as Record<string, { ingredients: string[] }>,
    );

    if (groupedByHalf.FULL) {
      return groupedByHalf.FULL.ingredients.join(', ');
    } else if (groupedByHalf.HALF_1 || groupedByHalf.HALF_2) {
      const half1 = groupedByHalf.HALF_1
        ? `Mitad 1: ${groupedByHalf.HALF_1.ingredients.join(', ')}`
        : '';
      const half2 = groupedByHalf.HALF_2
        ? `Mitad 2: ${groupedByHalf.HALF_2.ingredients.join(', ')}`
        : '';
      return [half1, half2].filter(Boolean).join(' / ');
    }

    return '';
  };

  const renderProcessingState = () => (
    <View style={styles.processingContainer}>
      <View style={styles.processingContent}>
        <MaterialIcons
          name="mic"
          size={80}
          color={colors.primary}
          style={styles.processingIcon}
        />
        <ActivityIndicator
          size="large"
          color={colors.primary}
          style={styles.processingSpinner}
        />
        <Text style={[styles.processingTitle, { color: colors.onSurface }]}>
          Analizando tu solicitud
        </Text>
        <Text
          style={[styles.processingSubtext, { color: colors.onSurfaceVariant }]}
        >
          Extrayendo productos y detalles de tu pedido por voz...
        </Text>
        <View style={styles.processingSteps}>
          <View style={styles.processingStep}>
            <MaterialIcons name="hearing" size={24} color={colors.primary} />
            <Text style={[styles.stepText, { color: colors.onSurfaceVariant }]}>
              Transcribiendo audio
            </Text>
          </View>
          <View style={styles.processingStep}>
            <MaterialIcons name="psychology" size={24} color={colors.primary} />
            <Text style={[styles.stepText, { color: colors.onSurfaceVariant }]}>
              Analizando productos
            </Text>
          </View>
          <View style={styles.processingStep}>
            <MaterialIcons name="list-alt" size={24} color={colors.primary} />
            <Text style={[styles.stepText, { color: colors.onSurfaceVariant }]}>
              Generando orden
            </Text>
          </View>
        </View>
        <Text
          style={[styles.processingFooter, { color: colors.onSurfaceVariant }]}
        >
           Esto puede tomar unos segundos
        </Text>
      </View>
    </View>
  );

  const renderErrorState = () => (
    <View style={styles.errorContainer}>
      <View style={styles.errorContent}>
        <MaterialIcons name="error-outline" size={80} color={colors.error} />
        <Text style={[styles.errorTitle, { color: colors.error }]}>
          No se pudo procesar tu solicitud
        </Text>
        <Text style={[styles.errorMessage, { color: colors.onSurfaceVariant }]}>
          {error}
        </Text>
        <View style={styles.errorActions}>
          <Button
            mode="outlined"
            onPress={onDismiss}
            style={styles.errorButton}
            icon="refresh"
          >
            Intentar de nuevo
          </Button>
          <Button
            mode="contained"
            onPress={handleAttemptExit}
            style={styles.errorButton}
            icon="close"
          >
            Cerrar
          </Button>
        </View>
        <Text style={[styles.errorFooter, { color: colors.onSurfaceVariant }]}>
           Asegrate de hablar claramente y mencionar los productos que deseas
        </Text>
      </View>
    </View>
  );

  const renderOrderSummary = () => {
    if (!orderData) return null;

    const { scheduledDelivery, warnings } = orderData;

    return (
      <ScrollView
        style={styles.scrollView}
        showsVerticalScrollIndicator={false}
      >
        <View style={styles.orderTypeSection}>
          <View style={styles.compactSectionHeader}>
            <MaterialIcons name="restaurant" size={20} color={colors.primary} />
            <Text
              style={[styles.compactSectionTitle, { color: colors.onSurface }]}
            >
              Tipo de Orden
            </Text>
          </View>

          <View style={styles.orderTypeButtons}>
            <TouchableOpacity
              style={[
                styles.orderTypeButton,
                editableOrderType === OrderTypeEnum.DINE_IN &&
                  styles.orderTypeButtonActive,
                {
                  backgroundColor:
                    editableOrderType === OrderTypeEnum.DINE_IN
                      ? colors.primaryContainer
                      : colors.surface,
                },
              ]}
              onPress={() => setEditableOrderType(OrderTypeEnum.DINE_IN)}
            >
              <MaterialIcons
                name="restaurant"
                size={16}
                color={
                  editableOrderType === OrderTypeEnum.DINE_IN
                    ? colors.primary
                    : colors.onSurfaceVariant
                }
              />
              <Text
                style={[
                  styles.orderTypeButtonText,
                  {
                    color:
                      editableOrderType === OrderTypeEnum.DINE_IN
                        ? colors.primary
                        : colors.onSurfaceVariant,
                  },
                ]}
              >
                Comer aqu
              </Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[
                styles.orderTypeButton,
                editableOrderType === OrderTypeEnum.TAKE_AWAY &&
                  styles.orderTypeButtonActive,
                {
                  backgroundColor:
                    editableOrderType === OrderTypeEnum.TAKE_AWAY
                      ? colors.primaryContainer
                      : colors.surface,
                },
              ]}
              onPress={() => setEditableOrderType(OrderTypeEnum.TAKE_AWAY)}
            >
              <MaterialIcons
                name="shopping-bag"
                size={16}
                color={
                  editableOrderType === OrderTypeEnum.TAKE_AWAY
                    ? colors.primary
                    : colors.onSurfaceVariant
                }
              />
              <Text
                style={[
                  styles.orderTypeButtonText,
                  {
                    color:
                      editableOrderType === OrderTypeEnum.TAKE_AWAY
                        ? colors.primary
                        : colors.onSurfaceVariant,
                  },
                ]}
              >
                Para llevar
              </Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[
                styles.orderTypeButton,
                editableOrderType === OrderTypeEnum.DELIVERY &&
                  styles.orderTypeButtonActive,
                {
                  backgroundColor:
                    editableOrderType === OrderTypeEnum.DELIVERY
                      ? colors.primaryContainer
                      : colors.surface,
                },
              ]}
              onPress={() => setEditableOrderType(OrderTypeEnum.DELIVERY)}
            >
              <MaterialIcons
                name="moped"
                size={16}
                color={
                  editableOrderType === OrderTypeEnum.DELIVERY
                    ? colors.primary
                    : colors.onSurfaceVariant
                }
              />
              <Text
                style={[
                  styles.orderTypeButtonText,
                  {
                    color:
                      editableOrderType === OrderTypeEnum.DELIVERY
                        ? colors.primary
                        : colors.onSurfaceVariant,
                  },
                ]}
              >
                Domicilio
              </Text>
            </TouchableOpacity>
          </View>
        </View>

        {editableOrderType === OrderTypeEnum.DINE_IN && (
          <View style={styles.compactSectionContainer}>
            <View style={styles.compactSectionHeader}>
              <MaterialIcons
                name="restaurant"
                size={20}
                color={colors.primary}
              />
              <Text
                style={[
                  styles.compactSectionTitle,
                  { color: colors.onSurface },
                ]}
              >
                Mesa y rea
              </Text>
            </View>

            <View style={styles.compactDeliveryContainer}>
              <View style={styles.dineInSelectorsRow}>
                <View style={styles.dineInSelectorContainer}>
                  <Menu
                    visible={areaMenuVisible}
                    onDismiss={() => setAreaMenuVisible(false)}
                    anchor={
                      <AnimatedLabelSelector
                        label="rea *"
                        value={selectedAreaName}
                        onPress={() => setAreaMenuVisible(true)}
                        isLoading={isLoadingAreas}
                        error={!!areaError || !!errorAreas}
                        disabled={isLoadingAreas}
                      />
                    }
                  >
                    {areasData?.map((area: Area) => (
                      <Menu.Item
                        key={area.id}
                        onPress={() => {
                          setEditableSelectedAreaId(area.id);
                          setEditableSelectedTableId(null);
                          setAreaMenuVisible(false);
                          setAreaError(null);
                        }}
                        title={area.name}
                      />
                    ))}
                    {errorAreas && (
                      <Menu.Item title="Error al cargar reas" disabled />
                    )}
                  </Menu>
                  {areaError && !errorAreas && (
                    <HelperText
                      type="error"
                      visible={true}
                      style={styles.helperTextFix}
                    >
                      {areaError}
                    </HelperText>
                  )}
                  {errorAreas && (
                    <HelperText
                      type="error"
                      visible={true}
                      style={styles.helperTextFix}
                    >
                      Error al cargar reas
                    </HelperText>
                  )}
                </View>

                <View style={styles.dineInSelectorContainer}>
                  <Menu
                    visible={tableMenuVisible}
                    onDismiss={() => setTableMenuVisible(false)}
                    anchor={
                      <AnimatedLabelSelector
                        label="Mesa *"
                        value={selectedTableName}
                        onPress={() => setTableMenuVisible(true)}
                        isLoading={isLoadingTables}
                        error={!!tableError || !!errorTables}
                        disabled={
                          !editableSelectedAreaId ||
                          isLoadingTables ||
                          isLoadingAreas ||
                          editableIsTemporaryTable
                        }
                      />
                    }
                  >
                    {tablesData?.map((table: Table) => (
                      <Menu.Item
                        key={table.id}
                        onPress={() => {
                          if (table.isAvailable) {
                            setEditableSelectedTableId(table.id);
                            setTableMenuVisible(false);
                            setTableError(null);
                          }
                        }}
                        title={`${table.name}${!table.isAvailable ? ' (Ocupada)' : ''}`}
                        disabled={!table.isAvailable}
                        titleStyle={
                          !table.isAvailable
                            ? { color: colors.error }
                            : undefined
                        }
                      />
                    ))}
                    {editableSelectedAreaId &&
                      tablesData?.length === 0 &&
                      !isLoadingTables &&
                      !errorTables && (
                        <Menu.Item title="No hay mesas" disabled />
                      )}
                    {errorTables && (
                      <Menu.Item title="Error al cargar mesas" disabled />
                    )}
                  </Menu>
                  {tableError && !errorTables && !editableIsTemporaryTable && (
                    <HelperText
                      type="error"
                      visible={true}
                      style={styles.helperTextFix}
                    >
                      {tableError}
                    </HelperText>
                  )}
                  {errorTables && (
                    <HelperText
                      type="error"
                      visible={true}
                      style={styles.helperTextFix}
                    >
                      Error al cargar mesas
                    </HelperText>
                  )}
                </View>
              </View>

              <TouchableOpacity
                onPress={() => {
                  setEditableIsTemporaryTable(!editableIsTemporaryTable);
                  if (!editableIsTemporaryTable) {
                    setEditableSelectedTableId(null);
                    setTableError(null);
                  } else {
                    setEditableTemporaryTableName('');
                  }
                }}
                style={styles.checkboxContainer}
              >
                <Checkbox.Android
                  status={editableIsTemporaryTable ? 'checked' : 'unchecked'}
                  onPress={() => {
                    setEditableIsTemporaryTable(!editableIsTemporaryTable);
                    if (!editableIsTemporaryTable) {
                      setEditableSelectedTableId(null);
                      setTableError(null);
                    } else {
                      setEditableTemporaryTableName('');
                    }
                  }}
                  color={colors.primary}
                />
                <Text style={styles.checkboxLabel}>Crear mesa temporal</Text>
              </TouchableOpacity>

              {editableIsTemporaryTable && (
                <View style={styles.temporaryTableInputContainer}>
                  <SpeechRecognitionInput
                    label="Nombre de la Mesa Temporal *"
                    value={editableTemporaryTableName}
                    onChangeText={(text) => {
                      setEditableTemporaryTableName(text);
                      if (tableError) setTableError(null);
                    }}
                    error={!!tableError && editableIsTemporaryTable}
                    speechLang="es-MX"
                    autoCapitalize="words"
                    autoCorrect={false}
                    placeholder="Ej: Mesa Terraza 1"
                    style={styles.compactTextInput}
                  />
                  {tableError && editableIsTemporaryTable && (
                    <HelperText
                      type="error"
                      visible={true}
                      style={styles.helperTextFix}
                    >
                      {tableError}
                    </HelperText>
                  )}
                </View>
              )}
            </View>
          </View>
        )}

        {editableOrderType === OrderTypeEnum.TAKE_AWAY && (
          <View style={styles.compactSectionContainer}>
            <View style={styles.compactSectionHeader}>
              <MaterialIcons name="person" size={20} color={colors.primary} />
              <Text
                style={[
                  styles.compactSectionTitle,
                  { color: colors.onSurface },
                ]}
              >
                Informacin del Cliente
              </Text>
            </View>

            <View style={styles.compactDeliveryContainer}>
              <SpeechRecognitionInput
                label="Nombre del Cliente *"
                value={editableDeliveryInfo.recipientName || ''}
                onChangeText={(text) => {
                  setEditableDeliveryInfo((prev) => ({
                    ...prev,
                    recipientName: text,
                  }));
                  if (recipientNameError) setRecipientNameError(null);
                }}
                error={!!recipientNameError}
                speechLang="es-MX"
                autoCapitalize="words"
                autoCorrect={false}
                style={styles.compactTextInput}
              />
              {recipientNameError && (
                <HelperText
                  type="error"
                  visible={true}
                  style={styles.helperTextFix}
                >
                  {recipientNameError}
                </HelperText>
              )}

              <SpeechRecognitionInput
                label="Telfono (Opcional)"
                value={editableDeliveryInfo.recipientPhone || ''}
                onChangeText={(text) => {
                  setEditableDeliveryInfo((prev) => ({
                    ...prev,
                    recipientPhone: text,
                  }));
                  if (recipientPhoneError) setRecipientPhoneError(null);
                }}
                error={!!recipientPhoneError}
                speechLang="es-MX"
                keyboardType="phone-pad"
                style={styles.compactTextInput}
              />
              {recipientPhoneError && (
                <HelperText
                  type="error"
                  visible={true}
                  style={styles.helperTextFix}
                >
                  {recipientPhoneError}
                </HelperText>
              )}
            </View>
          </View>
        )}

        {editableOrderType === OrderTypeEnum.DELIVERY && (
          <View style={styles.compactSectionContainer}>
            <View style={styles.compactSectionHeader}>
              <MaterialIcons
                name="local-shipping"
                size={20}
                color={colors.primary}
              />
              <Text
                style={[
                  styles.compactSectionTitle,
                  { color: colors.onSurface },
                ]}
              >
                Informacin de Entrega
              </Text>
            </View>

            <View style={styles.compactDeliveryContainer}>
              <SpeechRecognitionInput
                label="Direccin completa *"
                value={editableDeliveryInfo.fullAddress || ''}
                onChangeText={(text) => {
                  setEditableDeliveryInfo((prev) => ({
                    ...prev,
                    fullAddress: text,
                  }));
                  if (addressError) setAddressError(null);
                }}
                error={!!addressError}
                speechLang="es-MX"
                multiline
                numberOfLines={2}
                style={styles.compactTextInput}
              />
              {addressError && (
                <HelperText
                  type="error"
                  visible={true}
                  style={styles.helperTextFix}
                >
                  {addressError}
                </HelperText>
              )}

              <SpeechRecognitionInput
                label="Telfono *"
                value={editableDeliveryInfo.recipientPhone || ''}
                onChangeText={(text) => {
                  setEditableDeliveryInfo((prev) => ({
                    ...prev,
                    recipientPhone: text,
                  }));
                  if (recipientPhoneError) setRecipientPhoneError(null);
                }}
                error={!!recipientPhoneError}
                speechLang="es-MX"
                keyboardType="phone-pad"
                style={styles.compactTextInput}
              />
              {recipientPhoneError && (
                <HelperText
                  type="error"
                  visible={true}
                  style={styles.helperTextFix}
                >
                  {recipientPhoneError}
                </HelperText>
              )}
            </View>
          </View>
        )}

        {warnings && (
          <Surface
            style={[
              styles.warningContainer,
              { backgroundColor: colors.tertiaryContainer },
            ]}
          >
            <MaterialIcons name="warning" size={20} color={colors.tertiary} />
            <Text
              style={[
                styles.warningText,
                { color: colors.onTertiaryContainer },
              ]}
            >
              {warnings}
            </Text>
          </Surface>
        )}

        <View
          style={[
            styles.compactSectionContainer,
            styles.compactSectionContainerBordered,
            { borderTopColor: colors.primary + '40' },
          ]}
        >
          <View style={styles.compactSectionHeader}>
            <MaterialIcons
              name="restaurant-menu"
              size={20}
              color={colors.primary}
            />
            <Text
              style={[styles.compactSectionTitle, { color: colors.onSurface }]}
            >
              Productos ({editableItems.length})
            </Text>
          </View>

          {editableItems.length === 0 ? (
            <View style={styles.emptyContainerCompact}>
              <MaterialIcons
                name="mic-off"
                size={32}
                color={colors.onSurfaceVariant}
              />
              <Text
                style={[
                  styles.emptyTextCompact,
                  { color: colors.onSurfaceVariant },
                ]}
              >
                No se detectaron productos
              </Text>
            </View>
          ) : (
            <View style={styles.compactItemsList}>
              {editableItems.map((item, index) => {
                const itemKey = `${item.productId}-${index}`;
                const { productName, variantName } = getProductDetails(
                  item.productId,
                  item.variantId,
                );
                const pizzaCustomizationsText = formatPizzaCustomizations(
                  item.pizzaCustomizations,
                );

                // Funcin para renderizar acciones de deslizar
                const renderRightActions = (
                  _progressAnimatedValue: any,
                  dragAnimatedValue: any,
                ) => {
                  const translateX = dragAnimatedValue.interpolate({
                    inputRange: [-100, 0],
                    outputRange: [0, 100],
                    extrapolate: 'clamp',
                  });

                  const scale = dragAnimatedValue.interpolate({
                    inputRange: [-100, -50, 0],
                    outputRange: [1, 0.8, 0.5],
                    extrapolate: 'clamp',
                  });

                  const opacity = dragAnimatedValue.interpolate({
                    inputRange: [-100, -20, 0],
                    outputRange: [1, 0.5, 0],
                    extrapolate: 'clamp',
                  });

                  return (
                    <Animated.View
                      style={[
                        styles.deleteActionContainer,
                        {
                          opacity,
                          transform: [{ translateX }],
                        },
                      ]}
                    >
                      <Animated.View
                        style={[
                          styles.deleteAction,
                          {
                            backgroundColor: colors.error,
                            transform: [{ scale }],
                          },
                        ]}
                      >
                        <View style={styles.deleteIconContainer}>
                          <IconButton
                            icon="delete-sweep"
                            size={28}
                            iconColor="white"
                            style={styles.deleteIcon}
                          />
                        </View>
                        <Text style={styles.deleteActionText}>ELIMINAR</Text>
                      </Animated.View>
                    </Animated.View>
                  );
                };

                return (
                  <View key={itemKey}>
                    <Swipeable
                      renderRightActions={renderRightActions}
                      overshootRight={false}
                      friction={2}
                      rightThreshold={90}
                      leftThreshold={100}
                      onSwipeableOpen={(direction) => {
                        if (direction === 'right') {
                          setTimeout(() => {
                            removeItem(index);
                          }, 150);
                        }
                      }}
                    >
                      <TouchableOpacity
                        onPress={() => handleEditItem(item, index)}
                        activeOpacity={0.7}
                        style={[
                          styles.compactItemContainer,
                          itemsWithErrors.has(index) && [
                            styles.compactItemContainerError,
                            {
                              borderColor: colors.error,
                              backgroundColor: colors.errorContainer + '20',
                            },
                          ],
                        ]}
                      >
                        <View style={styles.compactItemContent}>
                          <View style={styles.compactItemLeft}>
                            <Text
                              style={[
                                styles.compactItemTitle,
                                { color: colors.onSurface },
                              ]}
                            >
                              {`${item.quantity}x ${variantName || productName}`}
                            </Text>

                            {itemValidationErrors[index] && (
                              <View style={styles.validationErrorsContainer}>
                                {itemValidationErrors[index].map(
                                  (error, errorIdx) => (
                                    <Text
                                      key={errorIdx}
                                      style={[
                                        styles.validationErrorText,
                                        { color: colors.error },
                                      ]}
                                    >
                                       {error}
                                    </Text>
                                  ),
                                )}
                              </View>
                            )}

                            {pizzaCustomizationsText && (
                              <Text
                                style={[
                                  styles.compactItemSubtitle,
                                  { color: colors.onSurfaceVariant },
                                ]}
                              >
                                {pizzaCustomizationsText}
                              </Text>
                            )}

                            {item.modifiers &&
                              item.modifiers.length > 0 &&
                              item.modifiers.map((mod, idx) => (
                                <Text
                                  key={idx}
                                  style={[
                                    styles.compactItemSubtitle,
                                    { color: colors.onSurfaceVariant },
                                  ]}
                                >
                                   {mod}
                                </Text>
                              ))}
                          </View>

                          <View style={styles.compactItemRight}>
                            <View style={styles.compactQuantityActions}>
                              <IconButton
                                icon="minus-circle-outline"
                                size={18}
                                onPress={() =>
                                  updateItemQuantity(
                                    item.productId,
                                    index,
                                    item.quantity - 1,
                                  )
                                }
                                style={styles.compactQuantityButton}
                                disabled={item.quantity <= 1}
                              />
                              <Text
                                style={[
                                  styles.compactQuantityText,
                                  { color: colors.onSurface },
                                ]}
                              >
                                {item.quantity}
                              </Text>
                              <IconButton
                                icon="plus-circle-outline"
                                size={18}
                                onPress={() =>
                                  updateItemQuantity(
                                    item.productId,
                                    index,
                                    item.quantity + 1,
                                  )
                                }
                                style={styles.compactQuantityButton}
                              />
                            </View>
                            <IconButton
                              icon="pencil"
                              size={16}
                              onPress={() => handleEditItem(item, index)}
                              style={styles.compactEditButton}
                            />
                          </View>
                        </View>
                      </TouchableOpacity>
                    </Swipeable>

                    {index < editableItems.length - 1 && (
                      <Divider style={styles.compactItemDivider} />
                    )}
                  </View>
                );
              })}
            </View>
          )}
        </View>

        {scheduledDelivery?.time && (
          <View style={styles.compactSectionContainer}>
            <View style={styles.compactSectionHeader}>
              <MaterialIcons name="schedule" size={20} color={colors.primary} />
              <Text
                style={[
                  styles.compactSectionTitle,
                  { color: colors.onSurface },
                ]}
              >
                Entrega Programada
              </Text>
            </View>
            <Text
              style={[styles.compactScheduledTime, { color: colors.onSurface }]}
            >
              {scheduledDelivery.time}
            </Text>
          </View>
        )}
      </ScrollView>
    );
  };

  return (
    <>
      {visible && (
        <Portal>
          <Modal
            visible={visible}
            onDismiss={onDismiss}
            contentContainerStyle={[
              styles.modalContainer,
              styles.modalContainerStyle,
              {
                backgroundColor: colors.surface,
                borderColor: colors.primary,
                shadowColor: colors.primary,
              },
            ]}
          >
            <View style={styles.header}>
              <Text style={[styles.title, { color: colors.onSurface }]}>
                {isProcessing && ' Procesando orden por voz...'}
                {error && ' Error en el procesamiento'}
                {!isProcessing &&
                  !error &&
                  hasValidationErrors &&
                  ' Revisa los productos'}
                {!isProcessing &&
                  !error &&
                  !hasValidationErrors &&
                  'Agregar a tu orden '}
              </Text>
              <IconButton
                icon="close"
                size={24}
                onPress={handleAttemptExit}
                style={styles.closeButton}
              />
            </View>

            {!isProcessing && !error && (
              <Divider style={{ backgroundColor: colors.outlineVariant }} />
            )}

            {isProcessing && renderProcessingState()}
            {error && renderErrorState()}
            {!isProcessing && !error && orderData && renderOrderSummary()}

            {!isProcessing && !error && orderData && (
              <>
                <Divider style={{ backgroundColor: colors.outlineVariant }} />
                <View style={styles.footer}>
                  {editableItems && editableItems.length > 0 ? (
                    <>
                      <Button
                        mode="outlined"
                        onPress={handleAttemptExit}
                        style={styles.footerButton}
                      >
                        Cancelar
                      </Button>
                      <Button
                        mode="contained"
                        onPress={handleConfirm}
                        style={[
                          styles.footerButton,
                          hasValidationErrors && {
                            backgroundColor: colors.error,
                          },
                        ]}
                        icon={hasValidationErrors ? 'alert-circle' : 'plus'}
                        buttonColor={
                          hasValidationErrors ? colors.error : undefined
                        }
                      >
                        {hasValidationErrors ? 'Hay errores' : 'Agregar'}
                      </Button>
                    </>
                  ) : (
                    <Button
                      mode="contained"
                      onPress={handleAttemptExit}
                      style={[styles.footerButton, styles.footerButtonFull]}
                    >
                      Cerrar
                    </Button>
                  )}
                </View>
              </>
            )}
          </Modal>

          {showCustomizationModal && editingProduct && editingItem && (
            <ProductCustomizationModal
              visible={showCustomizationModal}
              product={editingProduct}
              editingItem={editingItem}
              onDismiss={() => {
                setShowCustomizationModal(false);
                setEditingItem(null);
                setEditingProduct(null);
              }}
              onAddToCart={() => {}}
              onUpdateItem={handleUpdateEditedItem}
            />
          )}
        </Portal>
      )}

      <ConfirmationModal
        visible={showExitConfirmationModal}
        title="Descartar datos?"
        message="Tienes datos sin guardar. Si sales, se perdern los productos y la informacin que has modificado. Ests seguro?"
        confirmText="Salir y Descartar"
        cancelText="Cancelar"
        onConfirm={handleConfirmExit}
        onCancel={handleCancelExit}
        onDismiss={handleCancelExit}
        confirmButtonColor={colors.error}
      />
    </>
  );
};

const styles = StyleSheet.create({
  modalContainer: {
    borderRadius: 16,
    alignSelf: 'center',
    flex: 1,
    marginVertical: 16,
    marginHorizontal: 12,
    // Sombra base adicional en negro para mayor contraste
    shadowColor: '#000000',
    shadowOffset: {
      width: 0,
      height: 8,
    },
    shadowOpacity: 0.3,
    shadowRadius: 20,
    elevation: 24,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingVertical: 12,
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  closeButton: {
    margin: 0,
  },
  scrollView: {
    flex: 1,
  },
  processingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 32,
    paddingVertical: 40,
  },
  processingContent: {
    alignItems: 'center',
    maxWidth: 400,
    width: '100%',
  },
  processingIcon: {
    marginBottom: 16,
    opacity: 0.8,
  },
  processingSpinner: {
    marginBottom: 24,
  },
  processingTitle: {
    fontSize: 24,
    fontWeight: '700',
    marginBottom: 12,
    textAlign: 'center',
  },
  processingSubtext: {
    fontSize: 16,
    marginBottom: 32,
    textAlign: 'center',
    lineHeight: 22,
  },
  processingSteps: {
    width: '100%',
    marginBottom: 32,
    gap: 16,
  },
  processingStep: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
    paddingHorizontal: 16,
  },
  stepText: {
    fontSize: 14,
    flex: 1,
  },
  processingFooter: {
    fontSize: 14,
    textAlign: 'center',
    fontStyle: 'italic',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 32,
    paddingVertical: 40,
  },
  errorContent: {
    alignItems: 'center',
    maxWidth: 400,
    width: '100%',
  },
  errorTitle: {
    fontSize: 24,
    fontWeight: '700',
    marginTop: 16,
    marginBottom: 12,
    textAlign: 'center',
  },
  errorMessage: {
    fontSize: 16,
    marginBottom: 32,
    textAlign: 'center',
    lineHeight: 22,
  },
  errorActions: {
    flexDirection: 'row',
    gap: 12,
    marginBottom: 24,
    width: '100%',
  },
  errorButton: {
    flex: 1,
  },
  errorFooter: {
    fontSize: 14,
    textAlign: 'center',
    fontStyle: 'italic',
    lineHeight: 20,
  },
  // Estilos de processingTime removidos
  warningContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    margin: 16,
    borderRadius: 8,
    gap: 8,
  },
  warningText: {
    flex: 1,
    fontSize: 14,
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    padding: 16,
    gap: 12,
  },
  footerButton: {
    flex: 1,
  },
  deleteActionContainer: {
    position: 'absolute',
    right: 0,
    top: 0,
    bottom: 0,
    justifyContent: 'center',
    alignItems: 'flex-end',
  },
  deleteAction: {
    borderRadius: 8,
    paddingHorizontal: 20,
    paddingVertical: 8,
    marginRight: 16,
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  deleteIconContainer: {
    justifyContent: 'center',
    alignItems: 'center',
  },
  deleteIcon: {
    margin: 0,
  },
  deleteActionText: {
    color: 'white',
    fontWeight: '600',
    fontSize: 14,
  },
  // Nuevos estilos compactos
  compactSectionContainer: {
    margin: 16,
    marginBottom: 8,
  },
  compactSectionHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingBottom: 12,
    gap: 8,
  },
  compactSectionTitle: {
    fontSize: 16,
    fontWeight: '600',
  },
  emptyContainerCompact: {
    alignItems: 'center',
    paddingVertical: 24,
    gap: 12,
  },
  emptyTextCompact: {
    fontSize: 14,
    textAlign: 'center',
  },
  compactItemsList: {
    gap: 2,
  },
  compactItemContainer: {
    paddingVertical: 8,
    paddingHorizontal: 12,
  },
  compactItemContent: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  compactItemLeft: {
    flex: 1,
    paddingRight: 8,
  },
  compactItemTitle: {
    fontSize: 14,
    fontWeight: '500',
    marginBottom: 2,
  },
  compactItemSubtitle: {
    fontSize: 12,
    marginTop: 1,
    lineHeight: 16,
  },
  compactItemRight: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 4,
  },
  compactQuantityActions: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  compactQuantityButton: {
    margin: 0,
    width: 32,
    height: 32,
  },
  compactQuantityText: {
    fontSize: 13,
    fontWeight: '600',
    minWidth: 20,
    textAlign: 'center',
  },
  compactEditButton: {
    margin: 0,
    width: 28,
    height: 28,
    marginLeft: 4,
  },
  compactItemDivider: {
    marginVertical: 4,
    marginHorizontal: 12,
  },
  compactDeliveryContainer: {
    gap: 8,
  },
  compactTextInput: {
    backgroundColor: 'transparent',
  },
  compactScheduledTime: {
    fontSize: 14,
    fontWeight: '600',
    textAlign: 'center',
    paddingVertical: 8,
  },
  // Estilos para el tipo de orden editable
  orderTypeSection: {
    margin: 16,
    marginBottom: 8,
  },
  orderTypeButtons: {
    flexDirection: 'row',
    gap: 4,
  },
  orderTypeButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 8,
    gap: 6,
    elevation: 1,
  },
  orderTypeButtonActive: {
    elevation: 2,
  },
  orderTypeButtonText: {
    fontSize: 12,
    fontWeight: '500',
  },
  helperTextFix: {
    marginTop: 4,
  },
  checkboxContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginVertical: 8,
  },
  checkboxLabel: {
    marginLeft: 8,
    fontSize: 14,
  },
  temporaryTableInputContainer: {
    marginTop: 8,
  },
  dineInSelectorsRow: {
    flexDirection: 'row',
    gap: 8,
    marginBottom: 8,
  },
  dineInSelectorContainer: {
    flex: 1,
  },
  // Estilos para validacin de productos
  validationErrorsContainer: {
    marginTop: 4,
    gap: 2,
  },
  validationErrorText: {
    fontSize: 11,
    fontWeight: '500',
  },
  // Estilos para reemplazar inline styles
  compactSectionContainerBordered: {
    borderTopWidth: 1,
  },
  compactItemContainerError: {
    borderWidth: 1,
  },
  modalContainerStyle: {
    width: '95%',
    maxWidth: 500,
    maxHeight: '90%',
    height: '85%',
    borderWidth: 6,
    shadowOffset: { width: 0, height: 6 },
    shadowOpacity: 0.6,
    shadowRadius: 16,
    elevation: 20,
  },
  footerButtonFull: {
    flex: 1,
  },
});

================
File: app/src/app/services/discoveryService.ts
================
import NetInfo from '@react-native-community/netinfo';
import EncryptedStorage from '@/app/services/secureStorageService';
import { NETWORK_CONFIG } from '../constants/network';
import { API_PATHS } from '../constants/apiPaths';
import { Platform } from 'react-native';

const DISCOVERY_ENDPOINT = API_PATHS.DISCOVERY.substring(1); // Quitar / inicial
const STORAGE_KEY = 'last_known_api_url';

interface DiscoveryResponse {
  type: string;
  name: string;
  version: string;
  port: number;
  features: string[];
  timestamp: number;
  remoteUrl?: string;
  tunnelEnabled?: boolean;
}

export class DiscoveryService {
  private static instance: DiscoveryService;
  private cachedUrl: string | null = null;
  private discovering = false;
  private discoveryPromise: Promise<string | null> | null = null;
  private lastDiscoveryTime = 0;
  private logCallback: ((message: string) => void) | null = null;
  private manualUrl: string | null = null;
  private progressCallback:
    | ((progress: { current: number; total: number; message: string }) => void)
    | null = null;

  private constructor() {}

  /**
   * Establece un callback para logs
   */
  setLogCallback(callback: ((message: string) => void) | null) {
    this.logCallback = callback;
  }

  /**
   * Establece un callback para el progreso del discovery
   */
  setProgressCallback(
    callback:
      | ((progress: {
          current: number;
          total: number;
          message: string;
        }) => void)
      | null,
  ) {
    this.progressCallback = callback;
  }

  private log(message: string) {
    if (this.logCallback) {
      this.logCallback(message);
    }
  }

  private updateProgress(current: number, total: number, message: string) {
    if (this.progressCallback) {
      this.progressCallback({ current, total, message });
    }
  }

  static getInstance(): DiscoveryService {
    if (!DiscoveryService.instance) {
      DiscoveryService.instance = new DiscoveryService();
    }
    return DiscoveryService.instance;
  }

  /**
   * Obtiene la URL del API desde cache o almacenamiento
   * Solo verifica si la URL almacenada sigue funcionando
   * @returns string si encuentra una URL vlida, null si no encuentra ninguna
   */
  async getApiUrl(): Promise<string | null> {
    // Si hay URL manual configurada, usarla
    if (this.manualUrl) {
      return this.manualUrl;
    }

    // En web, intentar recuperar URL manual guardada
    if (Platform.OS === 'web') {
      try {
        const savedUrl = await EncryptedStorage.getItem('manual_server_url');
        if (savedUrl) {
          this.manualUrl = savedUrl;
          return savedUrl;
        }
      } catch {}
      return null;
    }

    // Si ya tenemos una URL en cache, devolverla sin verificar
    // La verificacin se hace en otros lugares (health monitoring)
    if (this.cachedUrl) {
      return this.cachedUrl;
    }

    // Intentar con la ltima URL conocida almacenada
    try {
      const lastKnown = await EncryptedStorage.getItem(STORAGE_KEY);
      if (lastKnown) {
        this.cachedUrl = lastKnown;
        return lastKnown;
      }
    } catch {}

    // Si no hay URL vlida, devolver null
    return null;
  }

  /**
   * Fuerza un nuevo descubrimiento del backend
   * IMPORTANTE: Solo debe llamarse despus de mltiples health checks fallidos
   */
  async forceRediscovery(): Promise<string> {
    // Si hay un descubrimiento en progreso, esperar a que termine
    if (this.discoveryPromise && this.discovering) {
      const result = await this.discoveryPromise;
      if (result) return result;
    }

    // FORZAR nueva bsqueda - limpiar cache SIEMPRE en forceRediscovery
    await this.clearCache();

    // Verificar que no se est llamando muy frecuentemente
    const timeSinceLastDiscovery = Date.now() - this.lastDiscoveryTime;
    if (timeSinceLastDiscovery < NETWORK_CONFIG.MIN_DISCOVERY_INTERVAL) {
      await new Promise((resolve) => setTimeout(resolve, 1000));
    }

    const discoveredUrl = await this.discoverBackend();
    if (!discoveredUrl) {
      throw new Error(
        'No se pudo encontrar el servidor CloudBite en la red local',
      );
    }

    return discoveredUrl;
  }

  async clearCache(): Promise<void> {
    this.cachedUrl = null;
    try {
      await EncryptedStorage.removeItem(STORAGE_KEY);
    } catch {}
  }

  /**
   * Obtiene la ltima URL conocida sin hacer discovery
   */
  async getLastKnownUrl(): Promise<string | null> {
    if (this.cachedUrl) {
      return this.cachedUrl;
    }

    try {
      const lastKnown = await EncryptedStorage.getItem(STORAGE_KEY);
      return lastKnown;
    } catch {
      return null;
    }
  }

  private async discoverBackend(): Promise<string | null> {
    // Si ya hay un descubrimiento en progreso, devolver la promesa existente
    if (this.discoveryPromise && this.discovering) {
      return this.discoveryPromise;
    }

    this.lastDiscoveryTime = Date.now();
    this.discovering = true;

    // Crear nueva promesa de descubrimiento
    this.discoveryPromise = this.performDiscovery()
      .then(async (result) => {
        if (result) {
          // Usar el mtodo unificado para guardar la URL descubierta
          await this.setServerUrl(result, false);
        }
        return result;
      })
      .finally(() => {
        this.discoveryPromise = null;
        this.discovering = false;
      });

    return this.discoveryPromise;
  }

  private async performDiscovery(): Promise<string | null> {
    try {
      // En web no podemos hacer descubrimiento
      if (Platform.OS === 'web') {
        this.log(' El descubrimiento automtico no est disponible en web');
        return null;
      }

      // Obtener informacin de red
      const netInfo = await NetInfo.fetch();

      if (!netInfo.isConnected) {
        throw new Error('No hay conexin de red disponible');
      }

      this.log(
        ` Buscando servidor en puerto ${NETWORK_CONFIG.DISCOVERY_PORT}`,
      );

      const subnets = this.detectCurrentSubnet();
      this.log(` Iniciando bsqueda en redes: ${subnets.join(', ')}`);

      // Calcular total de IPs a escanear
      const totalIps = subnets.length * 254; // IPs de .1 a .254 por subnet
      this.updateProgress(0, totalIps, 'Iniciando bsqueda...');

      let globalIpsScanned = 0;

      // Probar cada subnet hasta encontrar el servidor
      for (const subnet of subnets) {
        this.log(` Escaneando red ${subnet}.*`);
        this.updateProgress(
          globalIpsScanned,
          totalIps,
          `Escaneando red ${subnet}.*`,
        );

        const ips = this.generateIpRange(subnet);
        const chunks = this.chunkArray(
          ips,
          NETWORK_CONFIG.MAX_CONCURRENT_REQUESTS,
        );

        let totalIpsScanned = 0;

        for (let i = 0; i < chunks.length; i++) {
          const currentIps = chunks[i];

          const results = await Promise.allSettled(
            currentIps.map((ip) => this.probeServer(ip)),
          );

          totalIpsScanned += currentIps.length;
          globalIpsScanned += currentIps.length;

          // Actualizar progreso
          this.updateProgress(
            globalIpsScanned,
            totalIps,
            `Escaneando ${subnet}.* (${Math.round((globalIpsScanned / totalIps) * 100)}%)`,
          );

          // Buscar si alguna peticin fue exitosa
          for (let j = 0; j < results.length; j++) {
            const result = results[j];
            if (result.status === 'fulfilled' && result.value) {
              const foundIp = currentIps[j];
              this.log(` SERVIDOR ENCONTRADO EN ${foundIp}!`);
              this.updateProgress(
                globalIpsScanned,
                totalIps,
                `Servidor encontrado en ${foundIp}!`,
              );
              return result.value;
            }
          }

          // Mostrar progreso cada 10 IPs
          if (totalIpsScanned % 10 === 0) {
            const lastIp = currentIps[currentIps.length - 1];
            this.log(
              `   Escaneadas ${totalIpsScanned} IPs (ltima: ${lastIp})`,
            );
          }
        }

        this.log(`   No encontrado en ${subnet}.*`);
      }

      return null;
    } catch (error) {
      this.log(
        ` Error durante el descubrimiento: ${error instanceof Error ? error.message : 'Error desconocido'}`,
      );
      return null;
    }
  }

  /**
   * Prueba si una IP especfica tiene el servidor CloudBite
   */
  private async probeServer(ip: string): Promise<string | null> {
    const url = `http://${ip}:${NETWORK_CONFIG.DISCOVERY_PORT}`;
    const fullUrl = `http://${ip}:${NETWORK_CONFIG.DISCOVERY_PORT}${API_PATHS.DISCOVERY}`;

    // Crear AbortController para timeout real
    const controller = new AbortController();
    const timeoutId = setTimeout(() => {
      controller.abort();
    }, NETWORK_CONFIG.DISCOVERY_TIMEOUT);

    try {
      const response = await fetch(fullUrl, {
        method: 'GET',
        headers: {
          Accept: 'application/json',
        },
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      if (response.ok) {
        const text = await response.text();
        try {
          const data = JSON.parse(text);
          if (data.type === 'cloudbite-api') {
            this.log(` SERVIDOR ENCONTRADO!`);
            this.log(` IP: ${ip}`);
            this.log(` URL: ${url}`);
            return url;
          }
        } catch {
          // No es el servidor que buscamos
        }
      }
    } catch {
    } finally {
      clearTimeout(timeoutId);
    }

    return null;
  }

  private detectCurrentSubnet(): string[] {
    return [...NETWORK_CONFIG.COMMON_SUBNETS];
  }

  /**
   * Genera un rango de IPs para escanear
   */
  private generateIpRange(subnet: string): string[] {
    const ips: string[] = [];
    for (let i = 1; i <= 254; i++) {
      ips.push(`${subnet}.${i}`);
    }
    return ips;
  }

  /**
   * Divide un array en chunks ms pequeos
   */
  private chunkArray<T>(array: T[], size: number): T[][] {
    const chunks: T[][] = [];
    for (let i = 0; i < array.length; i += size) {
      chunks.push(array.slice(i, i + size));
    }
    return chunks;
  }

  /**
   * Guarda la URL en almacenamiento seguro
   */
  private async saveUrl(url: string): Promise<void> {
    try {
      await EncryptedStorage.setItem(STORAGE_KEY, url);
    } catch {}
  }

  /**
   * Establece la URL del servidor y la guarda
   * @param url - La URL del servidor (null para limpiar URL manual)
   * @param isManual - Si es true, se marca como configuracin manual
   */
  async setServerUrl(
    url: string | null,
    isManual: boolean = false,
  ): Promise<void> {
    if (url) {
      // Actualizar cache en memoria
      this.cachedUrl = url;

      // Si es manual, guardar referencia especial
      if (isManual) {
        this.manualUrl = url;
      }

      // Persistir en almacenamiento seguro
      await this.saveUrl(url);
    } else if (isManual) {
      // Solo limpiar manual URL si explcitamente se pide
      this.manualUrl = null;
    }
  }

  async discoverServer(): Promise<string | null> {
    return this.discoverBackend();
  }

  /**
   * Obtiene informacin del servidor incluyendo URL remota si est disponible
   */
  async getServerInfo(): Promise<DiscoveryResponse | null> {
    const url = await this.getApiUrl();
    if (!url) return null;

    try {
      const response = await fetch(`${url}${DISCOVERY_ENDPOINT}`, {
        method: 'GET',
        headers: {
          Accept: 'application/json',
        },
      });

      if (response.ok) {
        const data: DiscoveryResponse = await response.json();
        return data;
      }
    } catch (error) {
      // Error getting server info
    }

    return null;
  }
}

// Exportar instancia singleton
export const discoveryService = DiscoveryService.getInstance();

================
File: app/src/modules/orders/components/ProductCustomizationModal.tsx
================
import { useState, useEffect, useMemo, useCallback, memo } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import {
  Modal,
  Portal,
  Text,
  Button,
  RadioButton,
  Divider,
  Appbar, // Importar Appbar
  TouchableRipple,
  IconButton,
  Card,
  Chip,
  Surface,
} from 'react-native-paper';
import { useForm, Controller, FieldValues } from 'react-hook-form';
import { useAppTheme } from '@/app/styles/theme';
import SpeechRecognitionInput from '@/app/components/common/SpeechRecognitionInput'; // Importar SpeechRecognitionInput
import {
  FullMenuProduct as Product,
  ProductVariant,
  Modifier,
  FullMenuModifierGroup,
} from '../schema/orders.schema';
import { CartItemModifier, CartItem } from '../stores/useOrderStore';
import { AppTheme } from '@/app/styles/theme';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
import type { SelectedPizzaCustomization } from '@/app/schemas/domain/order.schema';
import type { PizzaCustomization } from '@/modules/pizzaCustomizations/schema/pizzaCustomization.schema';
import type { PizzaConfiguration } from '@/modules/pizzaCustomizations/schema/pizzaConfiguration.schema';
import {
  PizzaHalfEnum,
  CustomizationActionEnum,
  CustomizationTypeEnum,
} from '@/modules/pizzaCustomizations/schema/pizzaCustomization.schema';
import PizzaCustomizationSection from './PizzaCustomizationSection';
import { useProductValidation } from '../hooks/useProductValidation';

interface ProductCustomizationModalProps {
  visible: boolean;
  onDismiss: () => void;
  product: Product;
  editingItem?: CartItem | null;
  onAddToCart: (
    product: Product,
    quantity: number,
    variantId?: string,
    modifiers?: CartItemModifier[],
    preparationNotes?: string,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost?: number,
  ) => void;
  onUpdateItem?: (
    itemId: string,
    quantity: number,
    modifiers: CartItemModifier[],
    preparationNotes?: string,
    variantId?: string,
    variantName?: string,
    unitPrice?: number,
    selectedPizzaCustomizations?: SelectedPizzaCustomization[],
    pizzaExtraCost?: number,
  ) => void;
}

interface NotesFormData extends FieldValues {
  preparationNotes: string;
}

const ProductCustomizationModal = memo<ProductCustomizationModalProps>(
  ({ visible, onDismiss, product, editingItem, onAddToCart, onUpdateItem }) => {
    const theme = useAppTheme();
    const styles = useMemo(() => createStyles(theme), [theme]);
    const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

    const { control, reset, watch } = useForm<NotesFormData>({
      defaultValues: { preparationNotes: '' },
    });
    const watchedPreparationNotes = watch('preparationNotes');

    const [selectedVariantId, setSelectedVariantId] = useState<
      string | undefined
    >(
      product &&
        product.variants &&
        Array.isArray(product.variants) &&
        product.variants.length > 0
        ? product.variants[0].id
        : undefined,
    );
    const [selectedModifiersByGroup, setSelectedModifiersByGroup] = useState<
      Record<string, CartItemModifier[]>
    >({});

    const selectedModifiers = useMemo(() => {
      return Object.values(selectedModifiersByGroup).flat();
    }, [selectedModifiersByGroup]);

    // Pre-calcular si el producto tiene variantes o modificadores
    const hasVariants = useMemo(
      () =>
        product?.variants &&
        Array.isArray(product.variants) &&
        product.variants.length > 0,
      [product?.variants],
    );

    const [quantity, setQuantity] = useState(1);
    const [showExitConfirmation, setShowExitConfirmation] = useState(false);
    const [hasChanges, setHasChanges] = useState(false);

    // Estados para pizzas
    const [pizzaCustomizations, setPizzaCustomizations] = useState<
      PizzaCustomization[]
    >([]);
    const [pizzaConfiguration, setPizzaConfiguration] =
      useState<PizzaConfiguration | null>(null);
    const [selectedPizzaCustomizations, setSelectedPizzaCustomizations] =
      useState<SelectedPizzaCustomization[]>([]);

    // Hook de validacin
    const { isValid, getFieldError, getGroupError } = useProductValidation({
      product,
      selectedVariantId,
      selectedModifiersByGroup,
      selectedPizzaCustomizations,
      pizzaCustomizations,
      pizzaConfiguration,
    });

    // Funcin para calcular el precio extra de las pizzas
    const calculatePizzaExtraCost = useCallback(() => {
      if (!product.isPizza || !pizzaConfiguration) return 0;

      let totalToppingValue = 0;

      // Solo contar customizaciones con action = ADD
      const addedCustomizations = selectedPizzaCustomizations.filter(
        (c) => c.action === CustomizationActionEnum.ADD,
      );

      for (const selected of addedCustomizations) {
        const customization = pizzaCustomizations.find(
          (c) => c.id === selected.pizzaCustomizationId,
        );
        if (!customization) continue;

        if (selected.half === PizzaHalfEnum.FULL) {
          // Pizza completa suma el toppingValue completo
          totalToppingValue += customization.toppingValue;
        } else {
          // Media pizza suma la mitad del toppingValue
          totalToppingValue += customization.toppingValue / 2;
        }
      }

      // Solo cobrar por toppings que excedan los incluidos
      if (totalToppingValue > pizzaConfiguration.includedToppings) {
        const extraToppings =
          totalToppingValue - pizzaConfiguration.includedToppings;
        return extraToppings * Number(pizzaConfiguration.extraToppingCost);
      }

      return 0;
    }, [
      product.isPizza,
      pizzaConfiguration,
      selectedPizzaCustomizations,
      pizzaCustomizations,
    ]);

    // Funcin para verificar si hay cambios
    const checkForChanges = useCallback(() => {
      if (!editingItem) return false;

      // Comparar cantidad
      if (quantity !== editingItem.quantity) return true;

      // Comparar variante
      if (selectedVariantId !== editingItem.variantId) return true;

      // Comparar notas
      if (watchedPreparationNotes !== (editingItem.preparationNotes || ''))
        return true;

      // Comparar modificadores
      const currentModifierIds = selectedModifiers.map((m) => m.id).sort();
      const originalModifierIds = editingItem.modifiers.map((m) => m.id).sort();

      if (currentModifierIds.length !== originalModifierIds.length) return true;

      for (let i = 0; i < currentModifierIds.length; i++) {
        if (currentModifierIds[i] !== originalModifierIds[i]) return true;
      }

      return false;
    }, [
      editingItem,
      quantity,
      selectedVariantId,
      watchedPreparationNotes,
      selectedModifiers,
    ]);

    useEffect(() => {
      if (!product) return;

      if (editingItem) {
        // Si estamos editando, usar los valores del item
        setSelectedVariantId(editingItem.variantId);
        setQuantity(editingItem.quantity);
        reset({ preparationNotes: editingItem.preparationNotes || '' });

        // Reconstruir los modificadores por grupo
        const modifiersByGroup: Record<string, CartItemModifier[]> = {};
        if (editingItem.modifiers && product.modifierGroups) {
          editingItem.modifiers.forEach((mod) => {
            // Encontrar a qu grupo pertenece este modificador
            const group = product.modifierGroups?.find((g) =>
              g.productModifiers?.some((pm) => pm.id === mod.id),
            );
            if (group) {
              if (!modifiersByGroup[group.id]) {
                modifiersByGroup[group.id] = [];
              }
              modifiersByGroup[group.id].push(mod);
            }
          });
        }
        setSelectedModifiersByGroup(modifiersByGroup);
      } else {
        // Si es un nuevo item, valores por defecto
        if (
          product.variants &&
          Array.isArray(product.variants) &&
          product.variants.length > 0
        ) {
          setSelectedVariantId(product.variants[0].id);
        } else {
          setSelectedVariantId(undefined);
        }

        // Aplicar modificadores por defecto
        const defaultModifiersByGroup: Record<string, CartItemModifier[]> = {};

        if (product.modifierGroups) {
          product.modifierGroups.forEach((group) => {
            const defaultModifiers: CartItemModifier[] = [];

            if (group.productModifiers) {
              group.productModifiers.forEach((modifier) => {
                if (modifier.isDefault && modifier.isActive) {
                  defaultModifiers.push({
                    id: modifier.id,
                    modifierGroupId: group.id,
                    name: modifier.name,
                    price: Number(modifier.price) || 0,
                  });
                }
              });
            }

            if (defaultModifiers.length > 0) {
              // Respetar el lmite mximo de selecciones
              const maxSelections =
                group.maxSelections || defaultModifiers.length;
              defaultModifiersByGroup[group.id] = defaultModifiers.slice(
                0,
                maxSelections,
              );
            }
          });
        }

        setSelectedModifiersByGroup(defaultModifiersByGroup);
        setQuantity(1);
        reset({ preparationNotes: '' });
      }
    }, [product, editingItem, reset]);

    // Usar datos de pizza que ya vienen con el producto
    useEffect(() => {
      if (!product || !visible) return;

      // Si es una pizza, usar los datos que ya vienen con el producto
      if (product.isPizza) {
        if (product.pizzaConfiguration) {
          setPizzaConfiguration(product.pizzaConfiguration);
        }
        if (product.pizzaCustomizations) {
          setPizzaCustomizations(product.pizzaCustomizations);
        }

        // Si estamos editando, cargar las personalizaciones seleccionadas
        if (editingItem && editingItem.selectedPizzaCustomizations) {
          setSelectedPizzaCustomizations(
            editingItem.selectedPizzaCustomizations,
          );
        }
      }
    }, [product, visible, editingItem]);

    // Detectar cambios
    useEffect(() => {
      if (editingItem) {
        setHasChanges(checkForChanges());
      }
    }, [editingItem, checkForChanges]);

    const handleVariantSelect = useCallback((variantId: string) => {
      setSelectedVariantId(variantId);
    }, []);

    const handleModifierToggle = (
      modifier: Modifier,
      group: FullMenuModifierGroup,
    ) => {
      const currentGroupModifiers = selectedModifiersByGroup[group.id] || [];
      const isSelected = currentGroupModifiers.some(
        (mod) => mod.id === modifier.id,
      );

      const updatedModifiersByGroup = { ...selectedModifiersByGroup };

      if (isSelected) {
        // Verificar si al deseleccionar quedaramos por debajo del mnimo
        const newCount = currentGroupModifiers.length - 1;
        const minRequired = Math.max(
          group.minSelections || 0,
          group.isRequired ? 1 : 0,
        );

        if (newCount < minRequired) {
          showSnackbar({
            message: `No puedes deseleccionar. "${group.name}" requiere al menos ${minRequired} ${minRequired === 1 ? 'opcin seleccionada' : 'opciones seleccionadas'}.`,
            type: 'warning',
          });
          return;
        }

        updatedModifiersByGroup[group.id] = currentGroupModifiers.filter(
          (mod) => mod.id !== modifier.id,
        );
      } else {
        const newModifier: CartItemModifier = {
          id: modifier.id,
          modifierGroupId: group.id,
          name: modifier.name,
          price: Number(modifier.price) || 0,
        };

        if (!group.allowMultipleSelections) {
          updatedModifiersByGroup[group.id] = [newModifier];
        } else {
          if (currentGroupModifiers.length < (group.maxSelections || 0)) {
            updatedModifiersByGroup[group.id] = [
              ...currentGroupModifiers,
              newModifier,
            ];
          } else {
            showSnackbar({
              message: `Solo puedes seleccionar hasta ${group.maxSelections || 0} opciones en ${group.name}`,
              type: 'warning',
            });
            return;
          }
        }
      }

      setSelectedModifiersByGroup(updatedModifiersByGroup);
    };

    const handleAddToCart = () => {
      // Validar variantes requeridas
      if (hasVariants && !selectedVariantId) {
        showSnackbar({
          message: 'Debes seleccionar una variante',
          type: 'error',
        });
        return;
      }

      // Validar pizzas - cada mitad debe tener al menos un elemento (sabor o ingrediente)
      if (product.isPizza && pizzaConfiguration) {
        const addedCustomizations = selectedPizzaCustomizations.filter(
          (sc) => sc.action === CustomizationActionEnum.ADD,
        );

        // Verificar elementos en cada mitad
        const fullPizzaElements = addedCustomizations.filter(
          (sc) => sc.half === PizzaHalfEnum.FULL,
        );
        
        const half1Elements = addedCustomizations.filter(
          (sc) => sc.half === PizzaHalfEnum.HALF_1,
        );
        
        const half2Elements = addedCustomizations.filter(
          (sc) => sc.half === PizzaHalfEnum.HALF_2,
        );

        // Si hay elementos en pizza completa, es vlido
        if (fullPizzaElements.length > 0) {
          // La pizza completa cubre ambas mitades
        } else {
          // Si no hay elementos en pizza completa, verificar que ambas mitades tengan al menos un elemento
          if (half1Elements.length === 0) {
            showSnackbar({
              message: 'La primera mitad de la pizza debe tener al menos un sabor o ingrediente',
              type: 'error',
            });
            return;
          }
          
          if (half2Elements.length === 0) {
            showSnackbar({
              message: 'La segunda mitad de la pizza debe tener al menos un sabor o ingrediente',
              type: 'error',
            });
            return;
          }
        }

        // Verificar que al menos hay un elemento en total
        if (addedCustomizations.length === 0) {
          showSnackbar({
            message: 'La pizza debe tener al menos un sabor o ingrediente',
            type: 'error',
          });
          return;
        }
      }

      // Validar grupos requeridos y lmites de seleccin
      if (product.modifierGroups) {
        for (const group of product.modifierGroups) {
          const selectedInGroup = selectedModifiersByGroup[group.id] || [];
          const selectedCount = selectedInGroup.length;

          // Validar grupos requeridos y mnimo de selecciones
          if (
            group.isRequired ||
            (group.minSelections && group.minSelections > 0)
          ) {
            const minRequired = Math.max(
              group.minSelections || 0,
              group.isRequired ? 1 : 0,
            );

            if (selectedCount < minRequired) {
              let message = '';
              if (group.isRequired && minRequired === 1) {
                message = `"${group.name}" es requerido. Debes seleccionar al menos una opcin.`;
              } else if (minRequired > 1) {
                message = `Debes seleccionar al menos ${minRequired} ${minRequired === 1 ? 'opcin' : 'opciones'} en "${group.name}"`;
              } else {
                message = `Debes seleccionar al menos una opcin en "${group.name}"`;
              }

              showSnackbar({
                message,
                type: 'error',
              });
              return;
            }
          }

          // Validar mximo de selecciones (esto ya se valida en handleModifierToggle, pero por si acaso)
          if (group.maxSelections && selectedCount > group.maxSelections) {
            showSnackbar({
              message: `No puedes seleccionar ms de ${group.maxSelections} ${group.maxSelections === 1 ? 'opcin' : 'opciones'} en "${group.name}"`,
              type: 'error',
            });
            return;
          }
        }
      }

      if (editingItem && onUpdateItem) {
        // Si estamos editando, actualizar el item existente
        const variant = product.variants?.find(
          (v) => v.id === selectedVariantId,
        );
        const unitPrice = variant
          ? Number(variant.price)
          : Number(product.price) || 0;

        onUpdateItem(
          editingItem.id,
          quantity,
          selectedModifiers,
          watchedPreparationNotes,
          selectedVariantId,
          variant?.name,
          unitPrice,
          selectedPizzaCustomizations,
          pizzaExtraCost,
        );
      } else {
        // Si es un nuevo item, agregarlo al carrito
        onAddToCart(
          product,
          quantity,
          selectedVariantId,
          selectedModifiers,
          watchedPreparationNotes,
          selectedPizzaCustomizations,
          pizzaExtraCost,
        );
      }
      onDismiss();
    };

    const increaseQuantity = useCallback(
      () => setQuantity((prev) => prev + 1),
      [],
    );
    const decreaseQuantity = useCallback(
      () => setQuantity((prev) => (prev > 1 ? prev - 1 : 1)),
      [],
    );

    const handleDismiss = useCallback(() => {
      if (editingItem && hasChanges) {
        setShowExitConfirmation(true);
      } else {
        onDismiss();
      }
    }, [editingItem, hasChanges, onDismiss]);

    const handleConfirmExit = useCallback(() => {
      setShowExitConfirmation(false);
      onDismiss();
    }, [onDismiss]);

    const handleCancelExit = useCallback(() => {
      setShowExitConfirmation(false);
    }, []);

    const selectedVariant = useMemo(
      () =>
        hasVariants && product && product.variants
          ? product.variants.find(
              (variant: ProductVariant) => variant.id === selectedVariantId,
            )
          : undefined,
      [hasVariants, product, selectedVariantId],
    );

    if (!product || !visible) {
      return null;
    }

    const basePrice = selectedVariant
      ? Number(selectedVariant.price)
      : Number(product.price) || 0;
    const modifiersPrice = selectedModifiers.reduce(
      (sum, mod) => sum + Number(mod.price || 0),
      0,
    );
    const pizzaExtraCost = calculatePizzaExtraCost();
    const totalPrice = (basePrice + modifiersPrice + pizzaExtraCost) * quantity;

    if (!visible) {
      return null;
    }

    return (
      <>
        <Portal>
          <Modal
            visible={visible}
            onDismiss={handleDismiss}
            contentContainerStyle={styles.modalContent}
          >
            {/* Encabezado Refactorizado con Appbar */}
            <Appbar.Header style={styles.appBar} elevated>
              <Appbar.BackAction
                onPress={handleDismiss}
                color={theme.colors.onSurface}
              />
              <Appbar.Content
                title={product?.name || 'Producto'}
                titleStyle={styles.appBarTitle}
                style={styles.appBarContent}
              />
              {/* Espaciador si no hay accin a la derecha */}
              <View style={styles.appBarSpacer} />
            </Appbar.Header>

            <ScrollView
              style={styles.scrollView}
              contentContainerStyle={styles.scrollViewContent}
              showsVerticalScrollIndicator={true}
              keyboardShouldPersistTaps="handled"
              nestedScrollEnabled={true}
            >
              {product.hasVariants &&
                product.variants &&
                Array.isArray(product.variants) &&
                product.variants.length > 0 && (
                  <Card style={styles.sectionCard}>
                    <Card.Content>
                      <View style={styles.sectionHeader}>
                        <Text style={styles.sectionTitle}>Variantes</Text>
                        <View style={styles.chipContainer}>
                          {getFieldError('variant') && (
                            <Chip
                              mode="flat"
                              compact
                              style={styles.errorChip}
                              icon="alert-circle"
                              textStyle={styles.errorChipText}
                            >
                              {getFieldError('variant')}
                            </Chip>
                          )}
                          <Chip mode="flat" compact style={styles.requiredChip}>
                            Requerido
                          </Chip>
                        </View>
                      </View>
                      <RadioButton.Group
                        onValueChange={(value) => handleVariantSelect(value)}
                        value={selectedVariantId || ''}
                      >
                        {product.variants.map((variant: ProductVariant) => (
                          <Surface
                            key={variant.id}
                            style={[
                              styles.variantSurface,
                              selectedVariantId === variant.id &&
                                styles.variantSurfaceSelected,
                              !variant.isActive &&
                                styles.inactiveVariantSurface,
                            ]}
                            elevation={
                              selectedVariantId === variant.id &&
                              variant.isActive
                                ? 2
                                : 0
                            }
                          >
                            <TouchableRipple
                              onPress={() =>
                                variant.isActive &&
                                handleVariantSelect(variant.id)
                              }
                              disabled={!variant.isActive}
                              style={styles.variantTouchable}
                            >
                              <View style={styles.variantRow}>
                                <RadioButton
                                  value={variant.id}
                                  status={
                                    selectedVariantId === variant.id
                                      ? 'checked'
                                      : 'unchecked'
                                  }
                                  onPress={() =>
                                    variant.isActive &&
                                    handleVariantSelect(variant.id)
                                  }
                                  disabled={!variant.isActive}
                                />
                                <Text
                                  style={[
                                    styles.variantName,
                                    !variant.isActive && styles.inactiveText,
                                  ]}
                                >
                                  {variant.name}
                                  {!variant.isActive && ' (No disponible)'}
                                </Text>
                                <Text
                                  style={[
                                    styles.variantPrice,
                                    !variant.isActive && styles.inactiveText,
                                  ]}
                                >
                                  ${Number(variant.price).toFixed(2)}
                                </Text>
                              </View>
                            </TouchableRipple>
                          </Surface>
                        ))}
                      </RadioButton.Group>
                    </Card.Content>
                  </Card>
                )}

              {/* Seccin de Personalizacin de Pizza - Despus de variantes */}
              {product.isPizza && (
                <Card style={styles.sectionCard}>
                  <Card.Content>
                    {getFieldError('pizza') && (
                      <View style={styles.pizzaErrorContainer}>
                        <Chip
                          mode="flat"
                          compact
                          style={styles.errorChip}
                          icon="alert-circle"
                          textStyle={styles.errorChipText}
                        >
                          {getFieldError('pizza')}
                        </Chip>
                      </View>
                    )}
                    <PizzaCustomizationSection
                      pizzaCustomizations={pizzaCustomizations}
                      pizzaConfiguration={pizzaConfiguration}
                      selectedPizzaCustomizations={selectedPizzaCustomizations}
                      onCustomizationChange={setSelectedPizzaCustomizations}
                      loading={false}
                    />
                  </Card.Content>
                </Card>
              )}

              {product.modifierGroups &&
                Array.isArray(product.modifierGroups) &&
                product.modifierGroups.length > 0 &&
                product.modifierGroups.map((group: FullMenuModifierGroup) => (
                  <Card key={group.id} style={styles.sectionCard}>
                    <Card.Content>
                      <View style={styles.sectionHeader}>
                        <View style={styles.groupTitleContainer}>
                          <Text style={styles.groupTitle}>{group.name}</Text>
                          <View style={styles.selectionInfo}>
                            {group.minSelections !== undefined &&
                              group.maxSelections !== undefined && (
                                <Text style={styles.selectionRules}>
                                  {(group.minSelections || 0) === 0 &&
                                  group.maxSelections === 1
                                    ? 'Hasta 1 opcin'
                                    : (group.minSelections || 0) ===
                                        group.maxSelections
                                      ? `Elegir ${group.maxSelections}`
                                      : `${group.minSelections || 0}-${group.maxSelections} opciones`}
                                </Text>
                              )}
                            {group.allowMultipleSelections && (
                              <Text style={styles.selectedCount}>
                                (
                                {
                                  (selectedModifiersByGroup[group.id] || [])
                                    .length
                                }{' '}
                                seleccionadas)
                              </Text>
                            )}
                          </View>
                        </View>
                        <View style={styles.chipContainer}>
                          {getGroupError(group.id) && (
                            <Chip
                              mode="flat"
                              compact
                              style={styles.errorChip}
                              icon="alert-circle"
                              textStyle={styles.errorChipText}
                            >
                              {getGroupError(group.id)}
                            </Chip>
                          )}
                          <Chip
                            mode="flat"
                            compact
                            style={
                              group.isRequired
                                ? styles.requiredChip
                                : styles.optionalChip
                            }
                          >
                            {group.isRequired ? 'Requerido' : 'Opcional'}
                          </Chip>
                        </View>
                      </View>

                      {group.allowMultipleSelections ? (
                        <View style={styles.modifiersContainer}>
                          {Array.isArray(group.productModifiers) &&
                            group.productModifiers.map((modifier: Modifier) => {
                              const groupModifiers =
                                selectedModifiersByGroup[group.id] || [];
                              const isSelected = groupModifiers.some(
                                (mod) => mod.id === modifier.id,
                              );

                              return (
                                <Surface
                                  key={modifier.id}
                                  style={[
                                    styles.modifierSurface,
                                    isSelected &&
                                      styles.modifierSurfaceSelected,
                                    !modifier.isActive &&
                                      styles.inactiveModifierSurface,
                                  ]}
                                  elevation={
                                    isSelected && modifier.isActive ? 1 : 0
                                  }
                                >
                                  <TouchableRipple
                                    onPress={() =>
                                      modifier.isActive &&
                                      handleModifierToggle(modifier, group)
                                    }
                                    disabled={!modifier.isActive}
                                    style={styles.modifierTouchable}
                                  >
                                    <View style={styles.modifierRow}>
                                      <RadioButton
                                        value={modifier.id}
                                        status={
                                          isSelected ? 'checked' : 'unchecked'
                                        }
                                        disabled={!modifier.isActive}
                                        onPress={() =>
                                          modifier.isActive &&
                                          handleModifierToggle(modifier, group)
                                        }
                                      />
                                      <Text
                                        style={[
                                          styles.modifierName,
                                          !modifier.isActive &&
                                            styles.inactiveText,
                                        ]}
                                      >
                                        {modifier.name}
                                        {!modifier.isActive &&
                                          ' (No disponible)'}
                                      </Text>
                                      {Number(modifier.price) > 0 && (
                                        <Text
                                          style={[
                                            styles.modifierPrice,
                                            !modifier.isActive &&
                                              styles.inactiveText,
                                          ]}
                                        >
                                          +${Number(modifier.price).toFixed(2)}
                                        </Text>
                                      )}
                                    </View>
                                  </TouchableRipple>
                                </Surface>
                              );
                            })}
                        </View>
                      ) : (
                        <RadioButton.Group
                          onValueChange={(value) => {
                            const modifier = group.productModifiers?.find(
                              (m: Modifier) => m.id === value,
                            );
                            if (modifier) {
                              handleModifierToggle(modifier, group);
                            }
                          }}
                          value={
                            selectedModifiersByGroup[group.id]?.[0]?.id || ''
                          }
                        >
                          <View style={styles.modifiersContainer}>
                            {Array.isArray(group.productModifiers) &&
                              group.productModifiers.map(
                                (modifier: Modifier) => {
                                  const isSelected =
                                    selectedModifiersByGroup[group.id]?.[0]
                                      ?.id === modifier.id;

                                  return (
                                    <Surface
                                      key={modifier.id}
                                      style={[
                                        styles.modifierSurface,
                                        isSelected &&
                                          styles.modifierSurfaceSelected,
                                        !modifier.isActive &&
                                          styles.inactiveModifierSurface,
                                      ]}
                                      elevation={
                                        isSelected && modifier.isActive ? 1 : 0
                                      }
                                    >
                                      <TouchableRipple
                                        onPress={() =>
                                          modifier.isActive &&
                                          handleModifierToggle(modifier, group)
                                        }
                                        disabled={!modifier.isActive}
                                        style={styles.modifierTouchable}
                                      >
                                        <View style={styles.modifierRow}>
                                          <RadioButton
                                            value={modifier.id}
                                            status={
                                              isSelected
                                                ? 'checked'
                                                : 'unchecked'
                                            }
                                            disabled={!modifier.isActive}
                                            onPress={() =>
                                              modifier.isActive &&
                                              handleModifierToggle(
                                                modifier,
                                                group,
                                              )
                                            }
                                          />
                                          <Text
                                            style={[
                                              styles.modifierName,
                                              !modifier.isActive &&
                                                styles.inactiveText,
                                            ]}
                                          >
                                            {modifier.name}
                                            {!modifier.isActive &&
                                              ' (No disponible)'}
                                          </Text>
                                          {Number(modifier.price) > 0 && (
                                            <Text
                                              style={[
                                                styles.modifierPrice,
                                                !modifier.isActive &&
                                                  styles.inactiveText,
                                              ]}
                                            >
                                              +$
                                              {Number(modifier.price).toFixed(
                                                2,
                                              )}
                                            </Text>
                                          )}
                                        </View>
                                      </TouchableRipple>
                                    </Surface>
                                  );
                                },
                              )}
                          </View>
                        </RadioButton.Group>
                      )}
                    </Card.Content>
                  </Card>
                ))}

              {/* Seccin Cantidad - Mejorada */}
              <Card style={styles.sectionCard}>
                <Card.Content>
                  <Text style={styles.sectionTitle}>Cantidad</Text>
                  <View style={styles.quantityContainer}>
                    <IconButton
                      icon="minus-circle-outline"
                      size={36}
                      onPress={decreaseQuantity}
                      style={[
                        styles.quantityIconButton,
                        quantity <= 1 && styles.quantityIconButtonDisabled,
                      ]}
                      iconColor={
                        quantity <= 1
                          ? theme.colors.onSurfaceDisabled
                          : theme.colors.primary
                      }
                      disabled={quantity <= 1}
                    />
                    <Surface style={styles.quantityBadge} elevation={1}>
                      <Text style={styles.quantityText}>{quantity}</Text>
                    </Surface>
                    <IconButton
                      icon="plus-circle-outline"
                      size={36}
                      onPress={increaseQuantity}
                      style={styles.quantityIconButton}
                      iconColor={theme.colors.primary}
                    />
                  </View>
                </Card.Content>
              </Card>

              {/* Seccin Notas de Preparacin - Mejorada */}
              <Card style={styles.sectionCard}>
                <Card.Content>
                  <Controller
                    control={control}
                    name="preparationNotes"
                    render={({ field: { onChange, value } }) => (
                      <SpeechRecognitionInput
                        key="preparation-notes-input"
                        label="Notas de Preparacin"
                        value={value}
                        onChangeText={onChange}
                        multiline
                        numberOfLines={2}
                        style={styles.preparationInput}
                        speechLang="es-MX"
                      />
                    )}
                  />
                </Card.Content>
              </Card>

              {/* Seccin Resumen - Mejorada */}
              <Card style={[styles.sectionCard, styles.summaryCard]}>
                <Card.Content>
                  <Text style={styles.sectionTitle}>Resumen del pedido</Text>
                  <View style={styles.summaryContent}>
                    <View style={styles.summaryRow}>
                      <Text style={styles.summaryLabel}>Precio base:</Text>
                      <Text style={styles.summaryValue}>
                        ${basePrice.toFixed(2)}
                      </Text>
                    </View>
                    {selectedModifiers.length > 0 && (
                      <View style={styles.summaryRow}>
                        <Text style={styles.summaryLabel}>Adicionales:</Text>
                        <Text style={styles.summaryValue}>
                          +${modifiersPrice.toFixed(2)}
                        </Text>
                      </View>
                    )}
                    {pizzaExtraCost > 0 && (
                      <View style={styles.summaryRow}>
                        <Text style={styles.summaryLabel}>Toppings extra:</Text>
                        <Text style={styles.summaryValue}>
                          +${pizzaExtraCost.toFixed(2)}
                        </Text>
                      </View>
                    )}
                    <View style={styles.summaryRow}>
                      <Text style={styles.summaryLabel}>Cantidad:</Text>
                      <Text style={styles.summaryValue}>{quantity}</Text>
                    </View>
                    <Divider style={styles.summaryDivider} />
                    <View style={[styles.summaryRow, styles.totalRow]}>
                      <Text style={styles.totalLabel}>Total:</Text>
                      <Text style={styles.totalValue}>
                        ${totalPrice.toFixed(2)}
                      </Text>
                    </View>
                  </View>
                </Card.Content>
              </Card>
            </ScrollView>

            {/* Footer Button - Estilo OrderCartDetail */}
            <View style={styles.footer}>
              {!isValid && (
                <View style={styles.validationWarning}>
                  <IconButton
                    icon="alert-circle"
                    size={20}
                    iconColor={theme.colors.error}
                    style={styles.warningIcon}
                  />
                  <Text style={styles.validationWarningText}>
                    Completa los campos requeridos
                  </Text>
                </View>
              )}
              <Button
                mode="contained"
                onPress={handleAddToCart}
                style={[
                  styles.confirmButton,
                  !isValid && styles.confirmButtonDisabled,
                ]}
                disabled={!isValid}
                icon={editingItem ? 'cart-check' : 'cart-plus'}
              >
                {editingItem
                  ? `Actualizar Item - $${totalPrice.toFixed(2)}`
                  : `Agregar al Carrito - $${totalPrice.toFixed(2)}`}
              </Button>
            </View>
          </Modal>
        </Portal>

        {/* ConfirmationModal fuera del Portal principal */}
        <Portal>
          <ConfirmationModal
            visible={showExitConfirmation}
            onDismiss={handleCancelExit}
            onConfirm={handleConfirmExit}
            title="Descartar cambios?"
            message="Tienes cambios sin guardar. Ests seguro de que quieres salir?"
            confirmText="Descartar"
            cancelText="Cancelar"
            confirmButtonColor={theme.colors.error}
          />
        </Portal>
      </>
    );
  },
);

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    modalContent: {
      backgroundColor: theme.colors.background,
      width: '100%',
      height: '100%',
      margin: 0,
      padding: 0,
      position: 'absolute',
      top: 0,
      left: 0,
    },
    // Estilos del Appbar
    appBar: {
      backgroundColor: theme.colors.elevation.level2, // Coincidir con OrderHeader
    },
    appBarTitle: {
      // Estilo para el TTULO dentro de Appbar.Content
      ...theme.fonts.titleMedium, // Fuente consistente con OrderHeader
      color: theme.colors.onSurface,
      fontWeight: 'bold', // Aadir negritas al ttulo
      // textAlign: 'center', // El centrado lo maneja appBarContent
      // flex: 1, // Quitar flex para permitir centrado vertical por appBarContent
    },
    appBarContent: {
      // Contenedor del ttulo
      flex: 1, // Ocupar espacio disponible para centrar
      justifyContent: 'center', // Centrar verticalmente el contenido (ttulo)
      alignItems: 'center', // Centrar horizontalmente el contenido (ttulo)
      // marginLeft: -48, // Compensar el botn de back si es necesario (ajustar)
    },
    appBarSpacer: {
      // Espaciador para equilibrar el botn de retroceso
      width: 48, // Ancho estndar de IconButton
    },
    // --- Fin estilos Appbar ---
    modifierGroup: {
      marginBottom: theme.spacing.s,
    },
    modifierGroupHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 2,
    },
    groupTitle: {
      fontSize: 16,
      fontWeight: 'bold',
      color: theme.colors.onSurface,
    },
    groupDescription: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    requiredText: {
      fontSize: 12,
      color: theme.colors.error,
      fontWeight: '500',
    },
    optionalText: {
      fontSize: 12,
      color: theme.colors.primary,
      fontWeight: '500',
    },
    selectionRules: {
      fontSize: 10,
      color: theme.colors.onSurfaceVariant,
      marginBottom: theme.spacing.xs,
      fontStyle: 'italic',
    },
    selectionInfo: {
      marginTop: 2,
    },
    selectedCount: {
      fontSize: 12,
      color: theme.colors.primary,
      fontWeight: '500',
      marginTop: 2,
    },
    productImage: {
      height: 150,
      borderRadius: theme.roundness,
      marginBottom: theme.spacing.m,
    },
    imagePlaceholder: {
      backgroundColor: theme.colors.surfaceVariant,
      justifyContent: 'center',
      alignItems: 'center',
    },
    placeholderText: {
      fontSize: 50,
      color: theme.colors.onSurfaceVariant,
    },
    scrollView: {
      flex: 1,
      padding: theme.spacing.m,
    },
    section: {
      marginBottom: theme.spacing.s,
    },
    sectionTitle: {
      fontSize: 16,
      fontWeight: 'bold',
      marginBottom: theme.spacing.xs,
      color: theme.colors.onSurface,
    },
    // Nuevos estilos para Cards
    sectionCard: {
      marginBottom: theme.spacing.m,
      borderRadius: theme.roundness * 2,
    },
    sectionHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: theme.spacing.m,
    },
    groupTitleContainer: {
      flex: 1,
    },
    requiredChip: {
      backgroundColor: theme.colors.errorContainer,
      marginLeft: theme.spacing.s,
    },
    optionalChip: {
      backgroundColor: theme.colors.secondaryContainer,
      marginLeft: theme.spacing.s,
    },
    chipContainer: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    errorChip: {
      backgroundColor: theme.colors.errorContainer,
      marginRight: theme.spacing.xs,
    },
    // Estilos para variantes
    variantSurface: {
      marginBottom: theme.spacing.xs,
      borderRadius: theme.roundness,
      backgroundColor: theme.colors.surface,
      borderWidth: 1,
      borderColor: theme.colors.surfaceVariant,
    },
    variantSurfaceSelected: {
      borderColor: theme.colors.primary,
      backgroundColor: theme.colors.primaryContainer,
    },
    variantTouchable: {
      padding: 0,
    },
    variantRow: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingVertical: theme.spacing.s,
      paddingHorizontal: theme.spacing.xs,
    },
    variantName: {
      flex: 1,
      fontSize: 16,
      marginLeft: theme.spacing.xs,
      color: theme.colors.onSurface,
    },
    // Estilos para modificadores
    modifiersContainer: {
      marginTop: theme.spacing.xs,
    },
    modifierSurface: {
      marginBottom: theme.spacing.xs,
      borderRadius: theme.roundness,
      backgroundColor: theme.colors.surface,
      borderWidth: 1,
      borderColor: theme.colors.surfaceVariant,
    },
    modifierSurfaceSelected: {
      borderColor: theme.colors.primary,
      backgroundColor: theme.colors.primaryContainer,
    },
    modifierTouchable: {
      padding: 0,
    },
    modifierRow: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingVertical: theme.spacing.s,
      paddingHorizontal: theme.spacing.xs,
    },
    modifierName: {
      flex: 1,
      fontSize: 15,
      marginLeft: theme.spacing.xs,
      color: theme.colors.onSurface,
    },
    // Estilos de cantidad mejorados
    quantityBadge: {
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.xs,
      borderRadius: theme.roundness,
      backgroundColor: theme.colors.primaryContainer,
    },
    quantityIconButtonDisabled: {
      opacity: 0.5,
    },
    // Estilos de resumen mejorados
    summaryCard: {
      backgroundColor: theme.dark
        ? theme.colors.elevation.level3
        : theme.colors.secondaryContainer,
      borderWidth: theme.dark ? 1 : 0,
      borderColor: theme.dark ? theme.colors.outlineVariant : undefined,
    },
    summaryContent: {
      marginTop: theme.spacing.xs,
    },
    summaryLabel: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    summaryValue: {
      fontSize: 14,
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    summaryDivider: {
      marginVertical: theme.spacing.xs,
      backgroundColor: theme.colors.onSurfaceVariant,
      opacity: 0.3,
    },
    optionContainer: {
      marginBottom: 2,
    },
    optionTouchable: {
      paddingVertical: 4,
    },
    optionRow: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingHorizontal: 8,
      paddingVertical: 8,
    },
    optionContent: {
      // Contenedor solo para el ttulo del modificador (Checkbox)
      flex: 1, // Ocupa el espacio restante
      justifyContent: 'center', // Centra verticalmente el texto si es necesario
      // Quitar justifyContent: 'space-between'
      // alignItems: "center", // Ya est en optionRow
      // paddingRight: 8, // No necesario si el precio est fuera
    },
    checkbox: {
      marginRight: 8,
    },
    optionDivider: {
      height: 1,
      backgroundColor: theme.colors.outlineVariant,
    },
    radioItem: {
      flex: 1,
      paddingVertical: 4,
    },
    modifierTitle: {
      fontSize: 16,
      fontWeight: '500',
      color: theme.colors.onSurface, // Color estndar para texto
    },
    variantPrice: {
      // Estilo especfico para precio de variante
      fontSize: 14,
      fontWeight: 'bold',
      color: theme.colors.onSurfaceVariant, // Color secundario consistente
      marginLeft: 'auto',
      marginRight: 8,
    },
    inactiveVariantSurface: {
      opacity: 0.6,
      backgroundColor: theme.colors.surfaceDisabled,
    },
    inactiveModifierSurface: {
      opacity: 0.6,
      backgroundColor: theme.colors.surfaceDisabled,
    },
    inactiveText: {
      color: theme.colors.onSurfaceDisabled,
      textDecorationLine: 'line-through',
    },
    modifierPrice: {
      // Estilo para precio de modificador (Checkbox y Radio)
      fontSize: 14,
      fontWeight: 'bold',
      color: theme.colors.onSurfaceVariant, // Color secundario consistente
      marginLeft: 'auto', // Empujar a la derecha
      paddingHorizontal: 8, // Aadir padding similar a variantPrice
    },
    quantityContainer: {
      flexDirection: 'row',
      justifyContent: 'center',
      alignItems: 'center',
      marginVertical: theme.spacing.s,
    },
    quantityIconButton: {
      margin: 0,
      borderRadius: 18,
    },
    quantityText: {
      fontSize: 18,
      fontWeight: 'bold',
      minWidth: 40,
      textAlign: 'center',
      marginHorizontal: theme.spacing.s,
      color: theme.colors.onSurface,
    },
    summaryRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      paddingVertical: theme.spacing.xs,
      paddingHorizontal: theme.spacing.xs, // Aadir padding horizontal
    },
    totalRow: {
      // Estilo adicional para la fila del total
      marginTop: theme.spacing.s,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      paddingTop: theme.spacing.s,
    },
    totalLabel: {
      // Estilo consistente con OrderCartDetail
      fontWeight: 'bold',
      fontSize: 18,
      color: theme.colors.onSurface,
    },
    totalValue: {
      // Estilo consistente con OrderCartDetail para el TOTAL FINAL
      fontWeight: 'bold',
      fontSize: 18,
      color: theme.colors.primary, // Color primario para el total final
    },
    // Estilos de Footer y Botn - Consistentes con OrderCartDetail
    footer: {
      padding: theme.spacing.m,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface, // Fondo consistente
    },
    confirmButton: {
      // Reemplaza addButton
      paddingVertical: theme.spacing.s, // Padding consistente
      // width: "100%", // Ya es el comportamiento por defecto del botn en un View
    },
    confirmButtonDisabled: {
      opacity: 0.6,
    },
    // Estilo para SpeechRecognitionInput (una sola lnea)
    preparationInput: {
      // backgroundColor: theme.colors.surfaceVariant, // Opcional: mantener fondo
      marginVertical: theme.spacing.xs,
      textAlignVertical: 'center', // Intentar centrar verticalmente el placeholder/texto
      // minHeight: 80, // Eliminar altura mnima, ya no es multilnea
    },
    validationWarning: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      paddingVertical: theme.spacing.s,
      backgroundColor: theme.colors.errorContainer,
      borderRadius: theme.roundness,
      marginBottom: theme.spacing.s,
    },
    validationWarningText: {
      color: theme.colors.onErrorContainer,
      fontSize: 14,
      fontWeight: '500',
      marginLeft: theme.spacing.xs,
    },
    pizzaErrorContainer: {
      marginBottom: theme.spacing.m,
    },
    // Eliminar estilos no usados
    // sectionTitleContainer: { ... },
    // sectionTitleOptional: { ... },
    divider: {
      // Estilo de Divider si se usa
      marginVertical: theme.spacing.s,
      backgroundColor: theme.colors.outlineVariant,
    },
    warningIcon: {
      margin: 0,
    },
    scrollViewContent: {
      paddingBottom: 20,
    },
    errorChipText: {
      fontSize: 12,
    },
  });

ProductCustomizationModal.displayName = 'ProductCustomizationModal';

export default ProductCustomizationModal;

================
File: app/src/modules/receipts/screens/ReceiptsScreen.tsx
================
import React, { useState, useCallback, useMemo } from 'react';
import {
  View,
  FlatList,
  RefreshControl,
  StyleSheet,
  TouchableOpacity,
} from 'react-native';
import {
  Text,
  Searchbar,
  Chip,
  Surface,
  ActivityIndicator,
  Menu,
  IconButton,
  Divider,
  Badge,
  Icon,
} from 'react-native-paper';
import OrderSummaryCard from '@/modules/shared/components/OrderSummaryCard';
import { useAppTheme, AppTheme } from '@/app/styles/theme';
import { useReceipts, useRecoverOrder } from '../hooks/useReceiptsQueries';
import type { Receipt, ReceiptList } from '../schema/receipt.schema';
import { receiptService } from '../services/receiptService';
import { useRefreshModuleOnFocus } from '@/app/hooks/useRefreshOnFocus';
import EmptyState from '@/app/components/common/EmptyState';
import { ReceiptDetailsModal } from '../components/ReceiptDetailsModal';
import ConfirmationModal from '@/app/components/common/ConfirmationModal';
import { format } from 'date-fns';
import { DatePickerModal } from 'react-native-paper-dates';

type StatusFilter = 'all' | 'COMPLETED' | 'CANCELLED';

export const ReceiptsScreen: React.FC = () => {
  const theme = useAppTheme();
  const styles = React.useMemo(() => createStyles(theme), [theme]);

  const [searchQuery, setSearchQuery] = useState('');
  const [statusFilter, setStatusFilter] = useState<StatusFilter>('all');
  const [startDate, setStartDate] = useState<Date | undefined>(undefined);
  const [endDate, setEndDate] = useState<Date | undefined>(undefined);
  const [showDateRangePicker, setShowDateRangePicker] = useState(false);
  const [showFilterMenu, setShowFilterMenu] = useState(false);

  const [selectedReceipt, setSelectedReceipt] = useState<Receipt | null>(null);
  const [showDetailModal, setShowDetailModal] = useState(false);

  const [orderToRecover, setOrderToRecover] = useState<Receipt | null>(null);
  const [showRecoverConfirm, setShowRecoverConfirm] = useState(false);

  const recoverOrderMutation = useRecoverOrder();

  const filters = useMemo(() => {
    const baseFilters: {
      startDate?: string;
      endDate?: string;
    } = {};

    if (startDate) {
      baseFilters.startDate = startDate.toISOString();
    }

    if (endDate) {
      baseFilters.endDate = endDate.toISOString();
    }

    return baseFilters;
  }, [startDate, endDate]);

  const {
    data: allReceipts,
    isLoading,
    refetch,
    isRefetching,
  } = useReceipts(filters);

  useRefreshModuleOnFocus('receipts');

  const receipts = useMemo(() => {
    if (!allReceipts || !Array.isArray(allReceipts)) return [];

    let filtered = [...allReceipts];

    if (statusFilter !== 'all') {
      filtered = filtered.filter(
        (receipt) => receipt.orderStatus === statusFilter,
      );
    }

    if (searchQuery.trim()) {
      const search = searchQuery.toLowerCase().trim();
      filtered = filtered.filter((receipt) => {
        if (receipt.shiftOrderNumber.toString().includes(search)) return true;

        if (receipt.deliveryInfo) {
          const { recipientName, recipientPhone, fullAddress } =
            receipt.deliveryInfo;
          if (recipientName?.toLowerCase().includes(search)) return true;
          if (recipientPhone?.includes(search)) return true;
          if (fullAddress?.toLowerCase().includes(search)) return true;
        }

        if (receipt.notes?.toLowerCase().includes(search)) return true;

        return false;
      });
    }

    return filtered;
  }, [allReceipts, statusFilter, searchQuery]);

  const handleReceiptPress = useCallback((receipt: ReceiptList) => {
    receiptService.getReceiptById(receipt.id).then((fullOrder) => {
      setSelectedReceipt(fullOrder);
      setShowDetailModal(true);
    });
  }, []);

  const handleClearFilters = useCallback(() => {
    setSearchQuery('');
    setStatusFilter('all');
    setStartDate(undefined);
    setEndDate(undefined);
  }, []);

  const handleRecoverPress = useCallback((receipt: ReceiptList) => {
    receiptService.getReceiptById(receipt.id).then((fullOrder) => {
      setOrderToRecover(fullOrder);
      setShowRecoverConfirm(true);
    });
  }, []);

  const handleConfirmRecover = useCallback(async () => {
    if (!orderToRecover) return;

    try {
      await recoverOrderMutation.mutateAsync(orderToRecover.id);
      setShowRecoverConfirm(false);
      setOrderToRecover(null);
    } catch (error) {}
  }, [orderToRecover, recoverOrderMutation]);

  const getReceiptStatusColor = (status: string) => {
    switch (status) {
      case 'COMPLETED':
        return theme.colors.primary;
      case 'CANCELLED':
        return theme.colors.error;
      default:
        return theme.colors.onSurfaceDisabled;
    }
  };

  const getStatusLabel = (status: string) => {
    switch (status) {
      case 'COMPLETED':
        return 'Completada';
      case 'CANCELLED':
        return 'Cancelada';
      default:
        return status;
    }
  };

  const hasActiveFilters = statusFilter !== 'all' || startDate || endDate;

  const renderRestoreAction = (item: ReceiptList) => (
    <TouchableOpacity
      style={styles.restoreContainer}
      onPress={() => handleRecoverPress(item)}
      activeOpacity={0.7}
    >
      <Surface style={styles.restoreButtonSurface} elevation={2}>
        <IconButton
          icon="restore"
          size={36}
          iconColor={theme.colors.primary}
          style={styles.restoreButton}
        />
      </Surface>
    </TouchableOpacity>
  );

  const renderReceiptItem = ({ item }: { item: ReceiptList }) => (
    <OrderSummaryCard
      item={item}
      onPress={() => handleReceiptPress(item)}
      renderActions={renderRestoreAction}
      getStatusColor={getReceiptStatusColor}
      getStatusLabel={getStatusLabel}
    />
  );

  const renderEmptyComponent = () => {
    if (isLoading) {
      return (
        <View style={styles.centerContainer}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
        </View>
      );
    }

    return (
      <EmptyState
        icon="receipt"
        title="No hay recibos"
        message={
          hasActiveFilters
            ? 'No se encontraron recibos con los filtros seleccionados'
            : 'Los recibos de rdenes completadas o canceladas aparecern aqu'
        }
        actionLabel={hasActiveFilters ? 'Limpiar filtros' : undefined}
        onAction={hasActiveFilters ? handleClearFilters : undefined}
      />
    );
  };

  return (
    <View style={styles.container}>
      <Surface style={styles.header} elevation={2}>
        <Surface style={styles.shiftIndicator} elevation={1}>
          <Icon source="cash-register" size={20} color={theme.colors.primary} />
          <Text style={styles.shiftText}>Recibos del turno actual</Text>
          <View style={styles.shiftBadge}>
            <Text style={styles.shiftBadgeText}>ACTIVO</Text>
          </View>
        </Surface>
        <View style={styles.searchContainer}>
          <Searchbar
            placeholder="Buscar por nombre, telfono o direccin..."
            onChangeText={setSearchQuery}
            value={searchQuery}
            style={styles.searchbar}
            elevation={0}
          />
          <View style={styles.filterButton}>
            <Menu
              visible={showFilterMenu}
              onDismiss={() => setShowFilterMenu(false)}
              anchor={
                <IconButton
                  icon="filter-variant"
                  onPress={() => setShowFilterMenu(true)}
                  style={[
                    styles.filterIconButton,
                    hasActiveFilters && styles.filterIconButtonActive,
                  ]}
                />
              }
            >
              <Menu.Item
                title="Todos los estados"
                onPress={() => {
                  setStatusFilter('all');
                  setShowFilterMenu(false);
                }}
                leadingIcon={statusFilter === 'all' ? 'check' : undefined}
              />
              <Menu.Item
                title="Completadas"
                onPress={() => {
                  setStatusFilter('COMPLETED');
                  setShowFilterMenu(false);
                }}
                leadingIcon={statusFilter === 'COMPLETED' ? 'check' : undefined}
              />
              <Menu.Item
                title="Canceladas"
                onPress={() => {
                  setStatusFilter('CANCELLED');
                  setShowFilterMenu(false);
                }}
                leadingIcon={statusFilter === 'CANCELLED' ? 'check' : undefined}
              />
              <Divider />
              <Menu.Item
                title={
                  startDate && endDate
                    ? `${format(startDate, 'd/M/yyyy')} - ${format(endDate, 'd/M/yyyy')}`
                    : 'Seleccionar rango de fechas'
                }
                onPress={() => {
                  setShowDateRangePicker(true);
                  setShowFilterMenu(false);
                }}
                leadingIcon="calendar-range"
              />
              {hasActiveFilters && (
                <>
                  <Divider />
                  <Menu.Item
                    title="Limpiar filtros"
                    onPress={() => {
                      handleClearFilters();
                      setShowFilterMenu(false);
                    }}
                    leadingIcon="filter-remove"
                  />
                </>
              )}
            </Menu>
            {hasActiveFilters && <Badge size={8} style={styles.filterBadge} />}
          </View>
        </View>

        {hasActiveFilters && (
          <View style={styles.activeFilters}>
            {statusFilter !== 'all' && (
              <Chip
                mode="outlined"
                compact
                onClose={() => setStatusFilter('all')}
                style={styles.filterChip}
              >
                {statusFilter === 'COMPLETED' ? 'Completadas' : 'Canceladas'}
              </Chip>
            )}
            {startDate && (
              <Chip
                mode="outlined"
                compact
                onClose={() => setStartDate(undefined)}
                style={styles.filterChip}
              >
                Desde: {format(startDate, 'd/M')}
              </Chip>
            )}
            {endDate && (
              <Chip
                mode="outlined"
                compact
                onClose={() => setEndDate(undefined)}
                style={styles.filterChip}
              >
                Hasta: {format(endDate, 'd/M')}
              </Chip>
            )}
          </View>
        )}
      </Surface>

      <FlatList
        data={receipts}
        renderItem={renderReceiptItem}
        keyExtractor={(item) => item.id}
        contentContainerStyle={styles.listContent}
        refreshControl={
          <RefreshControl
            refreshing={isRefetching}
            onRefresh={refetch}
            colors={[theme.colors.primary]}
          />
        }
        ListEmptyComponent={renderEmptyComponent}
      />

      <ReceiptDetailsModal
        visible={showDetailModal}
        onDismiss={() => {
          setShowDetailModal(false);
          setSelectedReceipt(null);
        }}
        receipt={selectedReceipt}
      />

      <ConfirmationModal
        visible={showRecoverConfirm}
        title="Recuperar Orden"
        message={`Ests seguro de que deseas recuperar la orden #${orderToRecover?.shiftOrderNumber}?\n\nLa orden se marcar como entregada y volver a estar visible en las rdenes activas.`}
        onConfirm={handleConfirmRecover}
        onCancel={() => {
          setShowRecoverConfirm(false);
          setOrderToRecover(null);
        }}
        confirmText="Confirmar"
        cancelText="Cancelar"
      />

      <DatePickerModal
        visible={showDateRangePicker}
        mode="range"
        onDismiss={() => setShowDateRangePicker(false)}
        startDate={startDate}
        endDate={endDate}
        onConfirm={(params) => {
          setStartDate(params.startDate);
          setEndDate(params.endDate);
          setShowDateRangePicker(false);
        }}
        validRange={{
          endDate: new Date(),
        }}
        locale="es"
        saveLabel="Confirmar"
        startLabel="Desde"
        endLabel="Hasta"
        label="Seleccionar rango de fechas"
      />
    </View>
  );
};

const createStyles = (theme: AppTheme) =>
  StyleSheet.create({
    container: {
      flex: 1,
    },
    header: {
      paddingHorizontal: 16,
      paddingVertical: 12,
    },
    searchContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 8,
    },
    searchbar: {
      flex: 1,
    },
    filterButton: {
      position: 'relative',
    },
    filterIconButton: {
      margin: 0,
    },
    filterIconButtonActive: {
      backgroundColor: 'rgba(0, 0, 0, 0.08)',
    },
    filterBadge: {
      position: 'absolute',
      top: 8,
      right: 8,
    },
    activeFilters: {
      flexDirection: 'row',
      flexWrap: 'wrap',
      gap: 8,
      marginTop: 12,
    },
    filterChip: {
      height: 32,
    },
    listContent: {
      padding: theme.spacing.s,
      paddingBottom: theme.spacing.l * 2,
      flexGrow: 1,
    },
    orderCard: {
      marginBottom: 8,
    },
    cardContent: {
      paddingBottom: 8,
    },
    mainContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
    },
    leftContainer: {
      flex: 1,
      paddingRight: 12,
      flexShrink: 1,
    },
    rightContainer: {
      alignItems: 'flex-end',
      justifyContent: 'space-between',
      minWidth: 120,
      gap: 8,
      flexShrink: 0,
    },
    orderNumber: {
      fontSize: 16,
      fontWeight: 'bold',
      lineHeight: 22,
      marginBottom: 4,
    },
    orderPrice: {
      fontSize: 15,
      fontWeight: '700',
    },
    orderTime: {
      fontSize: 16,
      fontWeight: '600',
    },
    estimatedTime: {
      fontSize: 14,
      marginLeft: 4,
    },
    timeAndPaymentRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 0,
    },
    paymentBadge: {
      paddingHorizontal: 8,
      paddingVertical: 2,
      borderRadius: 12,
      alignItems: 'center',
      justifyContent: 'center',
    },
    paymentBadgeText: {
      fontSize: 11,
      fontWeight: '600',
      lineHeight: 14,
    },
    statusChip: {
      minHeight: 24,
      alignSelf: 'flex-end',
      paddingVertical: 2,
    },
    statusChipText: {
      fontSize: 12,
      fontWeight: '600',
      color: 'white',
      lineHeight: 14,
      marginVertical: 0,
      paddingVertical: 0,
    },
    actionsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'flex-end',
      gap: 8,
      marginTop: 4,
    },
    restoreContainer: {
      position: 'relative',
      alignItems: 'center',
      justifyContent: 'center',
    },
    restoreButtonSurface: {
      borderRadius: 20,
      backgroundColor: theme.colors.primaryContainer,
      overflow: 'hidden',
    },
    restoreButton: {
      margin: 0,
      width: 44,
      height: 44,
    },
    notesInline: {
      fontSize: 12,
      fontStyle: 'italic',
    },
    inlinePreparationBadge: {
      paddingHorizontal: 6,
      paddingVertical: 2,
      borderRadius: 10,
      borderWidth: 0.5,
    },
    inlinePreparationText: {
      fontSize: 10,
      fontWeight: '500',
    },
    centerContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: 32,
    },
    shiftIndicator: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      gap: 8,
      paddingVertical: 8,
      paddingHorizontal: 16,
      marginBottom: 8,
      borderRadius: 20,
      backgroundColor: theme.colors.primaryContainer,
    },
    shiftText: {
      ...theme.fonts.bodyMedium,
      color: theme.colors.onPrimaryContainer,
      fontWeight: '600',
    },
    shiftBadge: {
      backgroundColor: theme.colors.primary,
      paddingHorizontal: 8,
      paddingVertical: 2,
      borderRadius: 10,
    },
    shiftBadgeText: {
      fontSize: 10,
      fontWeight: 'bold',
      color: theme.colors.onPrimary,
    },
    miniPaymentBadge: {
      width: 20,
      height: 20,
      borderRadius: 10,
      alignItems: 'center',
      justifyContent: 'center',
      marginLeft: 6,
    },
    miniPaymentText: {
      fontSize: 10,
      fontWeight: 'bold',
      color: '#FFFFFF',
    },
    miniPreparationBadge: {
      width: 20,
      height: 20,
      borderRadius: 10,
      alignItems: 'center',
      justifyContent: 'center',
      marginLeft: 4,
    },
    miniPreparationText: {
      fontSize: 10,
      fontWeight: '600',
      color: '#FFFFFF',
    },
    moreIndicator: {
      fontSize: 10,
      color: theme.colors.onSurfaceVariant,
      marginLeft: 4,
    },
    createdByText: {
      fontSize: 10,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 4,
      textAlign: 'right',
    },
  });

================
File: app/src/modules/orders/screens/OpenOrdersScreen.tsx
================
import React, { useCallback, useEffect, useState } from 'react';
import { StyleSheet, View, Pressable, TouchableOpacity } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { FlashList } from '@shopify/flash-list';
import {
  Text,
  ActivityIndicator,
  Appbar,
  IconButton,
  Portal,
  Card,
  Chip,
  Icon,
  Surface,
  Button,
} from 'react-native-paper';
import { useAppTheme, AppTheme } from '../../../app/styles/theme';
import { useResponsive } from '../../../app/hooks/useResponsive';
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import type { OrdersStackParamList } from '../../../app/navigation/types';
import { useAuthStore } from '../../../app/store/authStore';
import { canOpenShift } from '../../../app/utils/roleUtils';
import { useGlobalShift } from '../../../app/hooks/useGlobalShift';
import { useSnackbarStore } from '../../../app/store/snackbarStore';
import { NAVIGATION_PATHS } from '@/app/constants/navigationPaths';
import {
  useGetOpenOrdersListQuery,
  useUpdateOrderMutation,
  useCancelOrderMutation,
} from '../hooks/useOrdersQueries';
import {
  OrderOpenList,
  OrderType,
  OrderTypeEnum,
  OrderStatusEnum,
} from '../schema/orders.schema';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import { PrintTicketModal } from '@/modules/shared/components/PrintTicketModal';
import { orderPrintService } from '../services/orderPrintService';
import OrderCartDetail from '../components/OrderCartDetail';
import { useListState } from '../../../app/hooks/useListState';
import {
  OrderStatusInfo,
  formatOrderTypeShort,
  getPaymentStatus,
  getStatusColor,
  formatOrderType,
} from '../utils/formatters';

type OpenOrdersScreenProps = NativeStackScreenProps<
  OrdersStackParamList,
  'OpenOrders'
>;

const OpenOrdersScreen: React.FC<OpenOrdersScreenProps> = ({ navigation }) => {
  const theme = useAppTheme();
  const responsive = useResponsive();
  const styles = React.useMemo(
    () => createStyles(theme, responsive),
    [theme, responsive],
  );
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);
  const [isPrintModalVisible, setIsPrintModalVisible] = useState(false);
  const [orderToPrint, setOrderToPrint] = useState<OrderOpenList | null>(null);
  const [acceptingOrderId, setAcceptingOrderId] = useState<string | null>(null);

  const user = useAuthStore((state) => state.user);
  const { data: shift, isLoading: shiftLoading } = useGlobalShift();
  const userCanOpenShift = canOpenShift(user);

  const [isEditModalVisible, setIsEditModalVisible] = useState(false);
  const [editingOrderId, setEditingOrderId] = useState<string | null>(null);

  const [selectedOrderType, setSelectedOrderType] = useState<
    OrderType | 'ALL' | 'WHATSAPP'
  >('ALL');

  const updateOrderMutation = useUpdateOrderMutation();
  const cancelOrderMutation = useCancelOrderMutation();

  const {
    data: ordersData,
    isLoading,
    isError,
    refetch,
    isFetching,
  } = useGetOpenOrdersListQuery();
  const filteredOrders = React.useMemo(() => {
    if (!ordersData) return [];

    if (selectedOrderType === 'ALL') {
      // En ALL, excluir pedidos de WhatsApp pendientes
      return ordersData.filter(
        (order) =>
          !(
            order.isFromWhatsApp &&
            order.orderStatus === OrderStatusEnum.PENDING
          ),
      );
    }

    if (selectedOrderType === 'WHATSAPP') {
      // Filtrar solo pedidos de WhatsApp con estado PENDING
      return ordersData.filter(
        (order) =>
          order.isFromWhatsApp && order.orderStatus === OrderStatusEnum.PENDING,
      );
    }

    // Para otros filtros (DINE_IN, TAKE_AWAY, DELIVERY), excluir pedidos de WhatsApp pendientes
    return ordersData.filter(
      (order) =>
        order.orderType === selectedOrderType &&
        !(
          order.isFromWhatsApp && order.orderStatus === OrderStatusEnum.PENDING
        ),
    );
  }, [ordersData, selectedOrderType]);

  const handleRefresh = useCallback(() => {
    refetch();
  }, [refetch]);

  // Funcin para abrir el modal de impresin
  const handleOpenPrintModal = useCallback((order: OrderOpenList) => {
    setOrderToPrint(order);
    setIsPrintModalVisible(true);
  }, []);

  const handleOrderItemPress = useCallback(async (order: OrderOpenList) => {
    // Cargar la orden en el store antes de abrir el modal
    setEditingOrderId(order.id);
    setIsEditModalVisible(true);
  }, []);

  const renderOrderItem = useCallback(
    ({ item: order }: { item: OrderOpenList }) => {
      // Construir el ttulo segn el tipo de orden
      let orderTitle = `#${order.shiftOrderNumber}  ${formatOrderTypeShort(order.orderType)}`;

      if (order.orderType === OrderTypeEnum.DINE_IN && order.table) {
        // Para mesas temporales, mostrar solo el nombre sin prefijo "Mesa"
        const tableDisplay = order.table.isTemporary
          ? order.table.name
          : `Mesa ${order.table.name || order.table.number || 'N/A'}`;
        orderTitle += `  ${order.table.area?.name || 'Sin rea'}  ${tableDisplay}`;
      } else if (order.orderType === OrderTypeEnum.TAKE_AWAY) {
        if (order.deliveryInfo?.recipientName) {
          orderTitle += `  ${order.deliveryInfo.recipientName}`;
        }
        if (order.deliveryInfo?.recipientPhone) {
          orderTitle += `  ${order.deliveryInfo.recipientPhone}`;
        }
      } else if (order.orderType === OrderTypeEnum.DELIVERY) {
        if (order.deliveryInfo?.fullAddress) {
          orderTitle += `  ${order.deliveryInfo.fullAddress}`;
        }
        if (order.deliveryInfo?.recipientPhone) {
          orderTitle += `  ${order.deliveryInfo.recipientPhone}`;
        }
      }

      const totalAmount =
        typeof order.total === 'string' ? parseFloat(order.total) : order.total;
      const totalPaid = order.paymentsSummary?.totalPaid || 0;
      const pendingAmount = totalAmount - totalPaid;

      return (
        <TouchableOpacity
          activeOpacity={0.95}
          onPress={() => handleOrderItemPress(order)}
        >
          <Card
            style={[
              styles.orderCard,
              {
                backgroundColor: theme.colors.surface,
              },
            ]}
            mode="elevated"
          >
            <Card.Content style={styles.cardContent}>
              <View style={styles.mainContainer}>
                <View style={styles.leftContainer}>
                  <Text
                    style={[
                      styles.orderNumber,
                      { color: theme.colors.onSurface },
                    ]}
                  >
                    {orderTitle}
                    <Text
                      style={[
                        styles.orderPrice,
                        pendingAmount > 0
                          ? styles.orderPricePending
                          : styles.orderPricePaid,
                      ]}
                    >
                      {'  '}
                      {pendingAmount > 0
                        ? `Por pagar: $${pendingAmount.toFixed(2)}`
                        : `Pagado: $${totalAmount.toFixed(2)}`}
                    </Text>
                    {order.notes && (
                      <Text
                        style={[
                          styles.notesInline,
                          { color: theme.colors.onSurfaceVariant },
                        ]}
                        numberOfLines={1}
                      >
                        {'  '}
                        {order.notes}
                      </Text>
                    )}
                  </Text>
                  <View style={styles.timeAndPaymentRow}>
                    <Text
                      style={[
                        styles.orderTime,
                        { color: theme.colors.primary },
                      ]}
                    >
                      {format(new Date(order.createdAt), 'p', { locale: es })}
                    </Text>
                    {(() => {
                      const paymentStatus = getPaymentStatus(order);
                      const color =
                        paymentStatus === 'paid'
                          ? '#10B981'
                          : paymentStatus === 'partial'
                            ? '#F59E0B'
                            : '#EF4444';
                      const icon =
                        paymentStatus === 'paid'
                          ? ''
                          : paymentStatus === 'partial'
                            ? ''
                            : '';
                      return (
                        <View
                          style={[
                            styles.miniPaymentBadge,
                            { backgroundColor: color },
                          ]}
                        >
                          <Text style={styles.miniPaymentText}>{icon}</Text>
                        </View>
                      );
                    })()}

                    {/* Badge de WhatsApp */}
                    {order.isFromWhatsApp && (
                      <View
                        style={[
                          styles.inlinePreparationBadge,
                          styles.whatsappButton,
                        ]}
                      >
                        <Icon source="whatsapp" size={12} color="#FFFFFF" />
                      </View>
                    )}

                    {order.preparationScreenStatuses &&
                      order.preparationScreenStatuses.length > 0 && (
                        <>
                          {order.preparationScreenStatuses.map(
                            (screen, index) => {
                              const backgroundColor =
                                screen.status === 'READY'
                                  ? '#4CAF50'
                                  : screen.status === 'IN_PROGRESS'
                                    ? '#FFA000'
                                    : theme.colors.surfaceVariant;

                              const textColor =
                                screen.status === 'READY' ||
                                screen.status === 'IN_PROGRESS'
                                  ? '#FFFFFF'
                                  : theme.colors.onSurfaceVariant;

                              return (
                                <View
                                  key={`${order.id}-screen-${index}`}
                                  style={[
                                    styles.inlinePreparationBadge,
                                    {
                                      backgroundColor,
                                      borderColor:
                                        backgroundColor ===
                                        theme.colors.surfaceVariant
                                          ? theme.colors.outline
                                          : backgroundColor,
                                    },
                                  ]}
                                >
                                  <Text
                                    style={[
                                      styles.inlinePreparationText,
                                      { color: textColor },
                                    ]}
                                  >
                                    {screen.status === 'READY'
                                      ? ' '
                                      : screen.status === 'IN_PROGRESS'
                                        ? ' '
                                        : ''}
                                     {screen.name}
                                  </Text>
                                </View>
                              );
                            },
                          )}
                        </>
                      )}
                  </View>
                </View>

                <View style={styles.rightContainer}>
                  {order.createdBy && (
                    <Text style={styles.createdByText} numberOfLines={1}>
                      {order.createdBy.firstName && order.createdBy.lastName
                        ? `${order.createdBy.firstName} ${order.createdBy.lastName}`
                        : order.createdBy.username}
                    </Text>
                  )}
                  <Chip
                    mode="flat"
                    compact
                    style={[
                      styles.statusChip,
                      {
                        backgroundColor: getStatusColor(
                          order.orderStatus,
                          theme,
                        ),
                      },
                    ]}
                    textStyle={styles.statusChipText}
                  >
                    {OrderStatusInfo.getLabel(order.orderStatus)}
                  </Chip>
                  <View style={styles.actionsContainer}>
                    {selectedOrderType === 'WHATSAPP' &&
                    order.orderStatus === OrderStatusEnum.PENDING ? (
                      <Button
                        mode="contained"
                        icon="check"
                        onPress={() => handleAcceptWhatsAppOrder(order.id)}
                        disabled={acceptingOrderId === order.id}
                        loading={acceptingOrderId === order.id}
                        compact
                      >
                        Aceptar
                      </Button>
                    ) : (
                      <TouchableOpacity
                        style={styles.printContainer}
                        onPress={() => handleOpenPrintModal(order)}
                        activeOpacity={0.7}
                      >
                        <IconButton
                          icon="printer"
                          size={32}
                          style={styles.printButton}
                          disabled
                        />
                        {(order.ticketImpressionCount ?? 0) > 0 && (
                          <View style={styles.printCountBadge}>
                            <Text style={styles.printCountText}>
                              {order.ticketImpressionCount}
                            </Text>
                          </View>
                        )}
                      </TouchableOpacity>
                    )}
                  </View>
                </View>
              </View>
            </Card.Content>
          </Card>
        </TouchableOpacity>
      );
    },
    [
      handleOrderItemPress,
      handleOpenPrintModal,
      handleAcceptWhatsAppOrder,
      selectedOrderType,
      acceptingOrderId,
      theme,
      styles,
    ],
  );

  const { ListEmptyComponent } = useListState({
    isLoading,
    isError,
    data: filteredOrders,
    emptyConfig: {
      title:
        selectedOrderType === 'ALL'
          ? 'No hay rdenes abiertas'
          : selectedOrderType === 'WHATSAPP'
            ? 'No hay pedidos de WhatsApp pendientes'
            : `No hay rdenes de tipo ${formatOrderType(
                selectedOrderType as OrderType,
              )
                .replace(/[\u{1F37D}]|[\u{FE0F}]|[\u{1F961}]|[\u{1F69A}]/gu, '')
                .trim()}`,
      message:
        selectedOrderType === 'ALL'
          ? 'No hay rdenes abiertas en este momento.'
          : selectedOrderType === 'WHATSAPP'
            ? 'No hay pedidos de WhatsApp esperando aceptacin.'
            : `No hay rdenes de este tipo en este momento.`,
      icon:
        selectedOrderType === 'WHATSAPP'
          ? 'whatsapp'
          : 'clipboard-text-outline',
    },
    errorConfig: {
      title: 'Error al cargar rdenes',
      message: 'No se pudieron cargar las rdenes. Verifica tu conexin.',
      icon: 'wifi-off',
      actionLabel: 'Reintentar',
      onAction: () => refetch(),
    },
  });

  // Efecto para configurar el botn de refrescar en el header
  useEffect(() => {
    navigation.setOptions({
      headerRight: () => (
        <Appbar.Action
          icon="refresh"
          iconColor={theme.colors.onPrimary}
          size={28}
          onPress={handleRefresh}
          disabled={isFetching} // Deshabilitar mientras se refresca
          style={styles.headerRefreshButton} // Agregar margen para mejor accesibilidad
        />
      ),
    });
  }, [
    navigation,
    handleRefresh,
    isFetching,
    theme.colors.onPrimary,
    styles.headerRefreshButton,
  ]); // Aadir dependencias

  // Funcin para manejar la impresin del ticket
  const handlePrint = useCallback(
    async (printerId: string, ticketType: 'GENERAL' | 'BILLING') => {
      if (!orderToPrint) return;

      try {
        await orderPrintService.printTicket(orderToPrint.id, {
          printerId,
          ticketType,
        });

        showSnackbar({
          message: 'Ticket impreso exitosamente',
          type: 'success',
        });

        // Refrescar la lista
        refetch();

        // Limpiar estado
        setOrderToPrint(null);
      } catch (error) {
        showSnackbar({
          message: 'Error al imprimir el ticket',
          type: 'error',
        });
      }
    },
    [orderToPrint, refetch, showSnackbar],
  );

  // Funcin para aceptar un pedido de WhatsApp
  const handleAcceptWhatsAppOrder = useCallback(
    async (orderId: string) => {
      if (acceptingOrderId !== null) return;

      setAcceptingOrderId(orderId);

      try {
        await updateOrderMutation.mutateAsync({
          orderId,
          payload: {
            orderStatus: OrderStatusEnum.IN_PROGRESS,
          },
        });

        showSnackbar({
          message: 'Pedido aceptado exitosamente',
          type: 'success',
        });

        refetch();
      } catch (error) {
        showSnackbar({
          message: 'Error al aceptar el pedido',
          type: 'error',
        });
      } finally {
        setAcceptingOrderId(null);
      }
    },
    [acceptingOrderId, updateOrderMutation, refetch, showSnackbar],
  );

  // Funcin para manejar la cancelacin de una orden
  const handleCancelOrder = useCallback(
    async (orderId: string) => {
      try {
        await cancelOrderMutation.mutateAsync(orderId);
        // Cerrar el modal despus de cancelar exitosamente
        setIsEditModalVisible(false);
        setEditingOrderId(null);
      } catch (error) {
        // El error se muestra a travs del hook useCancelOrderMutation
      }
    },
    [cancelOrderMutation],
  );

  return (
    <SafeAreaView style={styles.container} edges={['bottom', 'left', 'right']}>
      {!shiftLoading && (!shift || shift.status !== 'OPEN') ? (
        <View style={styles.container}>
          <View style={styles.emptyStateContainer}>
            <Icon
              source="store-alert"
              size={64}
              color={theme.colors.onSurfaceVariant}
            />
            <Text variant="headlineSmall" style={styles.emptyStateTitle}>
              Turno Cerrado
            </Text>
            <Text variant="bodyLarge" style={styles.emptyStateText}>
              {userCanOpenShift
                ? 'Para ver las rdenes abiertas, primero debes abrir el turno usando el indicador en la barra superior.'
                : 'El turno debe estar abierto para ver las rdenes. Contacta a un administrador.'}
            </Text>
          </View>
        </View>
      ) : isLoading && !ordersData ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
          <Text style={styles.loadingText}>Cargando rdenes...</Text>
        </View>
      ) : (
        <>
          {/* Filtros de tipo de orden con el mismo diseo que finalizacin */}
          <Surface style={styles.header}>
            <View style={styles.headerContent}>
              <View style={styles.filterContainer}>
                <Pressable
                  style={[
                    styles.filterButton,
                    selectedOrderType === 'ALL' && styles.filterButtonActive,
                    {
                      backgroundColor:
                        selectedOrderType === 'ALL'
                          ? theme.colors.primaryContainer
                          : theme.colors.surface,
                    },
                  ]}
                  onPress={() => setSelectedOrderType('ALL')}
                >
                  <Icon
                    source="view-grid"
                    size={26}
                    color={
                      selectedOrderType === 'ALL'
                        ? theme.colors.primary
                        : theme.colors.onSurfaceVariant
                    }
                  />
                  {ordersData &&
                    ordersData.filter(
                      (o) =>
                        !(
                          o.isFromWhatsApp &&
                          o.orderStatus === OrderStatusEnum.PENDING
                        ),
                    ).length > 0 && (
                      <View
                        style={[
                          styles.countBadge,
                          {
                            backgroundColor:
                              selectedOrderType === 'ALL'
                                ? theme.colors.error
                                : theme.colors.errorContainer,
                            borderColor:
                              selectedOrderType === 'ALL'
                                ? theme.colors.error
                                : theme.colors.outline,
                          },
                        ]}
                      >
                        <Text
                          style={[
                            styles.countBadgeText,
                            {
                              color:
                                selectedOrderType === 'ALL'
                                  ? theme.colors.onError
                                  : theme.colors.onErrorContainer,
                            },
                          ]}
                        >
                          {
                            ordersData.filter(
                              (o) =>
                                !(
                                  o.isFromWhatsApp &&
                                  o.orderStatus === OrderStatusEnum.PENDING
                                ),
                            ).length
                          }
                        </Text>
                      </View>
                    )}
                </Pressable>
                <Pressable
                  style={[
                    styles.filterButton,
                    selectedOrderType === OrderTypeEnum.DINE_IN &&
                      styles.filterButtonActive,
                    {
                      backgroundColor:
                        selectedOrderType === OrderTypeEnum.DINE_IN
                          ? theme.colors.primaryContainer
                          : theme.colors.surface,
                    },
                  ]}
                  onPress={() => setSelectedOrderType(OrderTypeEnum.DINE_IN)}
                >
                  <Icon
                    source="silverware-fork-knife"
                    size={26}
                    color={
                      selectedOrderType === OrderTypeEnum.DINE_IN
                        ? theme.colors.primary
                        : theme.colors.onSurfaceVariant
                    }
                  />
                  {ordersData &&
                    ordersData.filter(
                      (o) =>
                        o.orderType === OrderTypeEnum.DINE_IN &&
                        !(
                          o.isFromWhatsApp &&
                          o.orderStatus === OrderStatusEnum.PENDING
                        ),
                    ).length > 0 && (
                      <View
                        style={[
                          styles.countBadge,
                          {
                            backgroundColor:
                              selectedOrderType === OrderTypeEnum.DINE_IN
                                ? theme.colors.error
                                : theme.colors.errorContainer,
                            borderColor:
                              selectedOrderType === OrderTypeEnum.DINE_IN
                                ? theme.colors.error
                                : theme.colors.outline,
                          },
                        ]}
                      >
                        <Text
                          style={[
                            styles.countBadgeText,
                            {
                              color:
                                selectedOrderType === OrderTypeEnum.DINE_IN
                                  ? theme.colors.onError
                                  : theme.colors.onErrorContainer,
                            },
                          ]}
                        >
                          {
                            ordersData.filter(
                              (o) =>
                                o.orderType === OrderTypeEnum.DINE_IN &&
                                !(
                                  o.isFromWhatsApp &&
                                  o.orderStatus === OrderStatusEnum.PENDING
                                ),
                            ).length
                          }
                        </Text>
                      </View>
                    )}
                </Pressable>
                <Pressable
                  style={[
                    styles.filterButton,
                    selectedOrderType === OrderTypeEnum.TAKE_AWAY &&
                      styles.filterButtonActive,
                    {
                      backgroundColor:
                        selectedOrderType === OrderTypeEnum.TAKE_AWAY
                          ? theme.colors.primaryContainer
                          : theme.colors.surface,
                    },
                  ]}
                  onPress={() => setSelectedOrderType(OrderTypeEnum.TAKE_AWAY)}
                >
                  <Icon
                    source="bag-personal"
                    size={26}
                    color={
                      selectedOrderType === OrderTypeEnum.TAKE_AWAY
                        ? theme.colors.primary
                        : theme.colors.onSurfaceVariant
                    }
                  />
                  {ordersData &&
                    ordersData.filter(
                      (o) =>
                        o.orderType === OrderTypeEnum.TAKE_AWAY &&
                        !(
                          o.isFromWhatsApp &&
                          o.orderStatus === OrderStatusEnum.PENDING
                        ),
                    ).length > 0 && (
                      <View
                        style={[
                          styles.countBadge,
                          {
                            backgroundColor:
                              selectedOrderType === OrderTypeEnum.TAKE_AWAY
                                ? theme.colors.error
                                : theme.colors.errorContainer,
                            borderColor:
                              selectedOrderType === OrderTypeEnum.TAKE_AWAY
                                ? theme.colors.error
                                : theme.colors.outline,
                          },
                        ]}
                      >
                        <Text
                          style={[
                            styles.countBadgeText,
                            {
                              color:
                                selectedOrderType === OrderTypeEnum.TAKE_AWAY
                                  ? theme.colors.onError
                                  : theme.colors.onErrorContainer,
                            },
                          ]}
                        >
                          {
                            ordersData.filter(
                              (o) =>
                                o.orderType === OrderTypeEnum.TAKE_AWAY &&
                                !(
                                  o.isFromWhatsApp &&
                                  o.orderStatus === OrderStatusEnum.PENDING
                                ),
                            ).length
                          }
                        </Text>
                      </View>
                    )}
                </Pressable>
                <Pressable
                  style={[
                    styles.filterButton,
                    selectedOrderType === OrderTypeEnum.DELIVERY &&
                      styles.filterButtonActive,
                    {
                      backgroundColor:
                        selectedOrderType === OrderTypeEnum.DELIVERY
                          ? theme.colors.primaryContainer
                          : theme.colors.surface,
                    },
                  ]}
                  onPress={() => setSelectedOrderType(OrderTypeEnum.DELIVERY)}
                >
                  <Icon
                    source="moped"
                    size={26}
                    color={
                      selectedOrderType === OrderTypeEnum.DELIVERY
                        ? theme.colors.primary
                        : theme.colors.onSurfaceVariant
                    }
                  />
                  {ordersData &&
                    ordersData.filter(
                      (o) =>
                        o.orderType === OrderTypeEnum.DELIVERY &&
                        !(
                          o.isFromWhatsApp &&
                          o.orderStatus === OrderStatusEnum.PENDING
                        ),
                    ).length > 0 && (
                      <View
                        style={[
                          styles.countBadge,
                          {
                            backgroundColor:
                              selectedOrderType === OrderTypeEnum.DELIVERY
                                ? theme.colors.error
                                : theme.colors.errorContainer,
                            borderColor:
                              selectedOrderType === OrderTypeEnum.DELIVERY
                                ? theme.colors.error
                                : theme.colors.outline,
                          },
                        ]}
                      >
                        <Text
                          style={[
                            styles.countBadgeText,
                            {
                              color:
                                selectedOrderType === OrderTypeEnum.DELIVERY
                                  ? theme.colors.onError
                                  : theme.colors.onErrorContainer,
                            },
                          ]}
                        >
                          {
                            ordersData.filter(
                              (o) =>
                                o.orderType === OrderTypeEnum.DELIVERY &&
                                !(
                                  o.isFromWhatsApp &&
                                  o.orderStatus === OrderStatusEnum.PENDING
                                ),
                            ).length
                          }
                        </Text>
                      </View>
                    )}
                </Pressable>
                <Pressable
                  style={[
                    styles.filterButton,
                    selectedOrderType === 'WHATSAPP' &&
                      styles.filterButtonActive,
                    {
                      backgroundColor:
                        selectedOrderType === 'WHATSAPP'
                          ? theme.colors.primaryContainer
                          : theme.colors.surface,
                    },
                  ]}
                  onPress={() => setSelectedOrderType('WHATSAPP')}
                >
                  <Icon
                    source="whatsapp"
                    size={26}
                    color={
                      selectedOrderType === 'WHATSAPP'
                        ? theme.colors.primary
                        : theme.colors.onSurfaceVariant
                    }
                  />
                  {ordersData &&
                    ordersData.filter(
                      (o) =>
                        o.isFromWhatsApp &&
                        o.orderStatus === OrderStatusEnum.PENDING,
                    ).length > 0 && (
                      <View
                        style={[
                          styles.countBadge,
                          {
                            backgroundColor:
                              selectedOrderType === 'WHATSAPP'
                                ? theme.colors.error
                                : theme.colors.errorContainer,
                            borderColor:
                              selectedOrderType === 'WHATSAPP'
                                ? theme.colors.error
                                : theme.colors.outline,
                          },
                        ]}
                      >
                        <Text
                          style={[
                            styles.countBadgeText,
                            {
                              color:
                                selectedOrderType === 'WHATSAPP'
                                  ? theme.colors.onError
                                  : theme.colors.onErrorContainer,
                            },
                          ]}
                        >
                          {
                            ordersData.filter(
                              (o) =>
                                o.isFromWhatsApp &&
                                o.orderStatus === OrderStatusEnum.PENDING,
                            ).length
                          }
                        </Text>
                      </View>
                    )}
                </Pressable>
              </View>
            </View>
          </Surface>

          {/* Lista de rdenes */}
          <View style={styles.listContainer}>
            <FlashList
              data={filteredOrders}
              keyExtractor={(item) => item.id}
              renderItem={renderOrderItem}
              refreshing={isFetching}
              onRefresh={handleRefresh}
              contentContainerStyle={styles.listContentContainer}
              ListEmptyComponent={ListEmptyComponent}
              estimatedItemSize={120}
              removeClippedSubviews={true}
            />
          </View>
        </>
      )}
      {/* Modal de Impresin de Ticket */}
      <Portal>
        <PrintTicketModal
          visible={isPrintModalVisible}
          onDismiss={() => {
            setIsPrintModalVisible(false);
            setOrderToPrint(null);
          }}
          order={orderToPrint}
          onPrint={handlePrint}
        />
        {/* Modal de Edicin de Orden usando OrderCartDetail */}
        {editingOrderId && (
          <OrderCartDetail
            visible={isEditModalVisible}
            isEditMode={true}
            orderId={editingOrderId}
            orderNumber={
              ordersData?.find((o) => o.id === editingOrderId)?.shiftOrderNumber
            }
            orderDate={
              ordersData?.find((o) => o.id === editingOrderId)?.createdAt
                ? new Date(
                    ordersData.find((o) => o.id === editingOrderId)!.createdAt,
                  )
                : undefined
            }
            navigation={navigation}
            onClose={() => {
              setIsEditModalVisible(false);
              setEditingOrderId(null);
            }}
            onAddProducts={() => {
              // El store ya tiene la orden cargada, simplemente navegar
              setIsEditModalVisible(false);

              const orderNumber = ordersData?.find(
                (o) => o.id === editingOrderId,
              )?.shiftOrderNumber;

              // Navegar a aadir productos
              setTimeout(() => {
                navigation.navigate(NAVIGATION_PATHS.ADD_PRODUCTS_TO_ORDER, {
                  orderId: editingOrderId!,
                  orderNumber: orderNumber!,
                  onProductsAdded: () => {
                    // Reabrir el modal cuando regresemos
                    setIsEditModalVisible(true);
                  },
                });
              }, 100);
            }}
            onConfirmOrder={async (details) => {
              // Adaptar el formato de OrderDetailsForBackend a UpdateOrderPayload
              const payload = {
                orderType: details.orderType,
                items: details.items, // Enviar items para actualizar
                tableId: details.tableId || null,
                isTemporaryTable: details.isTemporaryTable || false,
                temporaryTableName: details.temporaryTableName || null,
                temporaryTableAreaId: details.temporaryTableAreaId || null,
                scheduledAt: details.scheduledAt || null,
                // Enviar null cuando deliveryInfo est vaco para indicar limpieza
                deliveryInfo: (() => {
                  if (!details.deliveryInfo) return null;

                  // Filtrar solo las propiedades que tienen valores reales (no undefined)
                  const filteredDeliveryInfo = Object.entries(
                    details.deliveryInfo,
                  )
                    .filter(([_, value]) => value !== undefined)
                    .reduce(
                      (acc, [key, value]) => ({ ...acc, [key]: value }),
                      {},
                    );

                  // Si no quedan propiedades con valores, enviar null
                  return Object.keys(filteredDeliveryInfo).length > 0
                    ? filteredDeliveryInfo
                    : null;
                })(),
                notes: details.notes || null,
                total: details.total,
                subtotal: details.subtotal,
                adjustments: details.adjustments || [], // Incluir ajustes en el payload
              };

              try {
                // Actualizar la orden (ahora incluye los ajustes)
                await updateOrderMutation.mutateAsync({
                  orderId: editingOrderId,
                  payload,
                });

                setIsEditModalVisible(false);
                setEditingOrderId(null);
              } catch (error) {
                // No cerrar el modal en caso de error para que el usuario pueda reintentar
              }
            }}
            onCancelOrder={() => {
              if (editingOrderId) {
                handleCancelOrder(editingOrderId);
              }
            }}
          />
        )}
      </Portal>
    </SafeAreaView>
  );
};

const createStyles = (
  theme: AppTheme,
  responsive: ReturnType<typeof useResponsive>,
) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
    loadingText: {
      marginTop: responsive.isTablet ? theme.spacing.s : theme.spacing.m,
      color: theme.colors.onSurfaceVariant,
      fontSize: responsive.isTablet ? 14 : 16,
    },
    header: {
      paddingHorizontal: 0,
      paddingVertical: 0,
      backgroundColor: 'transparent',
      elevation: 0,
    },
    headerContent: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 0,
    },
    filterContainer: {
      flex: 1,
      flexDirection: 'row',
      gap: 0,
    },
    filterButton: {
      flex: 1,
      height: responsive.isTablet ? 44 : 52,
      justifyContent: 'center',
      alignItems: 'center',
      borderRadius: 0,
      elevation: 1,
      position: 'relative',
    },
    filterButtonActive: {
      elevation: 3,
    },
    countBadge: {
      position: 'absolute',
      top: responsive.isTablet ? 3 : 6,
      right: responsive.isTablet ? 3 : 6,
      minWidth: responsive.isTablet ? 18 : 22,
      height: responsive.isTablet ? 18 : 22,
      borderRadius: responsive.isTablet ? 9 : 11,
      justifyContent: 'center',
      alignItems: 'center',
      paddingHorizontal: responsive.isTablet ? 4 : 6,
      borderWidth: 1,
      elevation: 2,
    },
    countBadgeText: {
      fontSize: responsive.isTablet ? 10 : 12,
      fontWeight: '700',
    },
    listContainer: {
      flex: 1,
    },
    listContentContainer: {
      padding: responsive.isTablet ? theme.spacing.xs : theme.spacing.s,
      paddingBottom: responsive.isTablet
        ? theme.spacing.l
        : theme.spacing.l * 2,
    },
    orderCard: {
      marginBottom: responsive.isTablet ? 6 : 8,
    },
    cardContent: {
      paddingBottom: responsive.isTablet ? 6 : 8,
      paddingHorizontal: responsive.isTablet ? 12 : 16,
      paddingTop: responsive.isTablet ? 12 : 16,
    },
    mainContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
    },
    leftContainer: {
      flex: 1,
      paddingRight: responsive.isTablet ? 6 : 8,
    },
    rightContainer: {
      alignItems: 'flex-end',
      justifyContent: 'space-between',
      minWidth: responsive.isTablet ? 120 : 140,
      gap: responsive.isTablet ? 6 : 8,
    },
    actionsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'flex-end',
      gap: responsive.isTablet ? 2 : 4,
    },
    orderNumber: {
      fontSize: responsive.isTablet ? 14 : 16,
      fontWeight: 'bold',
      lineHeight: responsive.isTablet ? 20 : 22,
      marginBottom: responsive.isTablet ? 2 : 4,
    },
    orderPrice: {
      fontSize: responsive.isTablet ? 13 : 15,
      fontWeight: '700',
    },
    orderPricePending: {
      color: theme.colors.error,
    },
    orderPricePaid: {
      color: '#10B981',
    },
    statusChip: {
      minHeight: responsive.isTablet ? 22 : 24,
      alignSelf: 'flex-end',
      paddingVertical: responsive.isTablet ? 1 : 2,
    },
    statusChipText: {
      fontSize: responsive.isTablet ? 11 : 12,
      fontWeight: '600',
      color: 'white',
      lineHeight: responsive.isTablet ? 13 : 14,
      marginVertical: 0,
      paddingVertical: 0,
    },
    paidChip: {
      height: responsive.isTablet ? 24 : 28,
      minHeight: responsive.isTablet ? 24 : 28,
      marginBottom: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    paidChipText: {
      fontSize: responsive.isTablet ? 11 : 12,
      fontWeight: '600',
      color: 'white',
      lineHeight: responsive.isTablet ? 14 : 16,
    },
    orderTime: {
      fontSize: responsive.isTablet ? 14 : 16,
      fontWeight: '600',
    },
    estimatedTime: {
      fontSize: responsive.isTablet ? 12 : 14,
      marginLeft: responsive.isTablet ? 3 : 4,
    },
    timeAndPaymentRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 0,
    },
    paymentBadge: {
      paddingHorizontal: responsive.isTablet ? 6 : 8,
      paddingVertical: responsive.isTablet ? 1 : 2,
      borderRadius: responsive.isTablet ? 10 : 12,
      alignItems: 'center',
      justifyContent: 'center',
    },
    paymentBadgeText: {
      fontSize: responsive.isTablet ? 10 : 11,
      fontWeight: '600',
      lineHeight: responsive.isTablet ? 12 : 14,
    },
    printButton: {
      margin: responsive.isTablet ? -6 : -4,
    },
    printContainer: {
      position: 'relative',
      alignItems: 'center',
      justifyContent: 'center',
    },
    printCountBadge: {
      position: 'absolute',
      top: 0,
      right: 0,
      backgroundColor: '#3B82F6',
      borderRadius: responsive.isTablet ? 8 : 10,
      minWidth: responsive.isTablet ? 18 : 20,
      height: responsive.isTablet ? 18 : 20,
      paddingHorizontal: responsive.isTablet ? 3 : 4,
      alignItems: 'center',
      justifyContent: 'center',
    },
    printCountText: {
      color: '#FFFFFF',
      fontSize: responsive.isTablet ? 9 : 10,
      fontWeight: 'bold',
    },
    customerInfo: {
      ...theme.fonts.bodyMedium,
      fontSize: responsive.isTablet ? 13 : 14,
      color: theme.colors.onSurfaceVariant,
      marginBottom: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    phoneInfo: {
      ...theme.fonts.bodySmall,
      fontSize: responsive.isTablet ? 11 : 12,
      color: theme.colors.onSurfaceVariant,
      marginBottom: responsive.isTablet
        ? theme.spacing.xs * 0.7
        : theme.spacing.xs,
    },
    notesInline: {
      fontSize: responsive.isTablet ? 11 : 12,
      fontStyle: 'italic',
    },
    inlinePreparationBadge: {
      paddingHorizontal: responsive.isTablet ? 4 : 6,
      paddingVertical: responsive.isTablet ? 1 : 2,
      borderRadius: responsive.isTablet ? 8 : 10,
      borderWidth: 0.5,
      marginLeft: responsive.isTablet ? 3 : 4,
    },
    inlinePreparationText: {
      fontSize: responsive.isTablet ? 9 : 10,
      fontWeight: '500',
    },
    miniPaymentBadge: {
      width: responsive.isTablet ? 18 : 20,
      height: responsive.isTablet ? 18 : 20,
      borderRadius: responsive.isTablet ? 9 : 10,
      alignItems: 'center',
      justifyContent: 'center',
      marginLeft: responsive.isTablet ? 4 : 6,
    },
    miniPaymentText: {
      fontSize: responsive.isTablet ? 9 : 10,
      fontWeight: 'bold',
      color: '#FFFFFF',
    },
    miniPreparationBadge: {
      width: responsive.isTablet ? 18 : 20,
      height: responsive.isTablet ? 18 : 20,
      borderRadius: responsive.isTablet ? 9 : 10,
      alignItems: 'center',
      justifyContent: 'center',
      marginLeft: responsive.isTablet ? 3 : 4,
    },
    miniPreparationText: {
      fontSize: responsive.isTablet ? 9 : 10,
      fontWeight: '600',
      color: '#FFFFFF',
    },
    moreIndicator: {
      fontSize: responsive.isTablet ? 9 : 10,
      color: theme.colors.onSurfaceVariant,
      marginLeft: responsive.isTablet ? 3 : 4,
    },
    createdByText: {
      fontSize: responsive.isTablet ? 9 : 10,
      color: theme.colors.onSurfaceVariant,
      marginBottom: responsive.isTablet ? 3 : 4,
      textAlign: 'right',
    },
    emptyStateContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      padding: responsive.isTablet ? theme.spacing.m : theme.spacing.l,
    },
    emptyStateTitle: {
      marginTop: responsive.isTablet ? theme.spacing.m : theme.spacing.l,
      marginBottom: responsive.isTablet ? theme.spacing.s : theme.spacing.m,
      textAlign: 'center',
      color: theme.colors.onSurface,
      fontWeight: '600',
      fontSize: responsive.isTablet ? 20 : 24,
    },
    emptyStateText: {
      textAlign: 'center',
      color: theme.colors.onSurfaceVariant,
      maxWidth: responsive.isTablet ? 280 : 320,
      lineHeight: responsive.isTablet ? 20 : 24,
      fontSize: responsive.isTablet ? 14 : 16,
    },
    // Estilo adicional para eliminar inline style
    headerRefreshButton: {
      marginRight: 8,
    },
    whatsappButton: {
      backgroundColor: '#25D366',
      borderColor: '#25D366',
    },
  });

export default OpenOrdersScreen;

================
File: app/src/modules/orders/components/OrderCartDetail.tsx
================
import React, {
  useMemo,
  useEffect,
  useCallback,
  useState,
  useRef,
} from 'react';
import { Portal } from 'react-native-paper';
import {
  View,
  ScrollView,
  StyleSheet,
  ActivityIndicator,
  TouchableWithoutFeedback,
  Keyboard,
} from 'react-native';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import {
  Text,
  Divider,
  Button,
  Menu,
  IconButton,
  Modal,
} from 'react-native-paper';
import { useAppTheme } from '@/app/styles/theme';
import { OrderTypeEnum } from '../schema/orders.schema';
import type { OrderAdjustment } from '../schema/adjustments.schema';
import { OrderStatusInfo, PreparationStatusInfo } from '../utils/formatters';
import OrderHeader from './OrderHeader';
import { canRegisterPayments as checkCanRegisterPayments } from '@/app/utils/roleUtils';
import {
  useOrderStore,
  CartItem,
  CartItemModifier,
  useOrderSubtotal,
  useOrderTotal,
  useOrderItemsCount,
  OrderDetailsForBackend,
} from '../stores/useOrderStore';
import { useAuthStore } from '@/app/store/authStore';
import { useSnackbarStore } from '@/app/store/snackbarStore';
import { useGetOrderByIdQuery } from '../hooks/useOrdersQueries';
import { FAB } from 'react-native-paper';
import { useGetPaymentsByOrderIdQuery } from '../hooks/usePaymentQueries';
import type { SelectedPizzaCustomization } from '@/app/schemas/domain/order.schema';

import {
  OrderTypeSelector,
  DineInForm,
  DineInFormRef,
  TakeAwayForm,
  TakeAwayFormRef,
  DeliveryForm,
  DeliveryFormRef,
  OrderItemsList,
  OrderAdjustments,
  PrepaymentSection,
  ModalsContainer,
} from './order-cart';
import { modalHelpers } from '../stores/useModalStore';

interface OrderCartDetailProps {
  visible: boolean;
  onConfirmOrder: (details: OrderDetailsForBackend) => Promise<void>;
  onClose?: () => void;
  onEditItem?: (item: CartItem) => void;
  isEditMode?: boolean;
  orderId?: string | null;
  orderNumber?: number;
  orderDate?: Date;
  onCancelOrder?: () => void;
  navigation?: any;
  onAddProducts?: () => void;
}

const OrderCartDetail: React.FC<OrderCartDetailProps> = ({
  visible,
  onConfirmOrder,
  onClose,
  onEditItem,
  isEditMode = false,
  orderId,
  orderNumber,
  orderDate,
  onCancelOrder,
  navigation,
  onAddProducts,
}) => {
  const theme = useAppTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);

  // Referencias a los formularios
  const dineInFormRef = useRef<DineInFormRef>(null);
  const takeAwayFormRef = useRef<TakeAwayFormRef>(null);
  const deliveryFormRef = useRef<DeliveryFormRef>(null);

  const {
    items,
    orderType,
    scheduledTime,
    adjustments,
    prepaymentId,
    prepaymentAmount: paymentAmount,
    prepaymentMethod: paymentMethod,
    isCartVisible,
    hasUnsavedChanges,
    isConfirming,
    setOrderType,
    setScheduledTime,
    setPrepaymentId,
    setPrepaymentAmount,
    setPrepaymentMethod,
    removeItem: removeCartItem,
    updateItemQuantity: updateCartItemQuantity,
    updateItem: updateCartItem,
    addItem,
    addAdjustment,
    updateAdjustment,
    removeAdjustment,
    confirmOrder,
  } = useOrderStore();

  const subtotal = useOrderSubtotal();
  const total = useOrderTotal();
  const totalItemsCount = useOrderItemsCount();

  const {
    data: orderData,
    isLoading: isLoadingOrder,
    isError: isErrorOrder,
  } = useGetOrderByIdQuery(orderId, {
    enabled: isEditMode && !!orderId && visible,
  });

  const { data: payments = [] } = useGetPaymentsByOrderIdQuery(orderId || '', {
    enabled: isEditMode && !!orderId && visible,
  });

  const validateOrder = () => {
    let isValid = true;

    switch (orderType) {
      case OrderTypeEnum.DINE_IN:
        if (dineInFormRef.current) {
          const dineInValid = dineInFormRef.current.validate();
          isValid = isValid && dineInValid;
        }
        break;

      case OrderTypeEnum.TAKE_AWAY:
        if (takeAwayFormRef.current) {
          const takeAwayValid = takeAwayFormRef.current.validate();
          isValid = isValid && takeAwayValid;
        }
        break;

      case OrderTypeEnum.DELIVERY:
        if (deliveryFormRef.current) {
          const deliveryValid = deliveryFormRef.current.validate();
          isValid = isValid && deliveryValid;
        }
        break;
    }

    return isValid;
  };

  const [editingProduct, setEditingProduct] = useState<any>(null);
  const [showOptionsMenu, setShowOptionsMenu] = useState(false);
  const [isModalReady, setIsModalReady] = useState(false);

  // Calcular totales
  const totalAdjustments = useMemo(() => {
    return adjustments.reduce((sum, adj) => sum + (adj.amount || 0), 0);
  }, [adjustments]);

  const totalPaid = useMemo(() => {
    if (!isEditMode || !payments) return 0;
    return payments.reduce(
      (sum, payment) => sum + payment.amount,
      0,
    );
  }, [payments, isEditMode]);

  const pendingAmount = useMemo(() => {
    return total - totalPaid;
  }, [total, totalPaid]);

  const showTimePicker = () => {
    modalHelpers.showTimePicker({
      scheduledTime,
      orderType,
      onTimeConfirm: handleTimeConfirm,
      hideTimePicker: modalHelpers.hideModal,
    });
  };

  const handleEditCartItem = (item: CartItem) => {
    if (onEditItem) {
      onEditItem(item);
    } else {
      // Si no hay onEditItem, mostrar modal de personalizacin directamente
      modalHelpers.showProductCustomization({
        editingProduct: editingProduct,
        editingItemFromList: item,
        clearEditingState,
        handleUpdateEditedItem,
      });
    }
  };

  const clearEditingState = useCallback(() => {
    setEditingProduct(null);
  }, []);

  const handlePrepaymentCreated = useCallback(
    (id: string, amount: number, method: 'CASH' | 'CARD' | 'TRANSFER') => {
      if (!isEditMode) {
        setPrepaymentId(id);
        setPrepaymentAmount(amount.toString());
        setPrepaymentMethod(method);
      }
    },
    [isEditMode, setPrepaymentId, setPrepaymentAmount, setPrepaymentMethod],
  );

  const handlePrepaymentDeleted = useCallback(() => {
    if (!isEditMode) {
      setPrepaymentId(null);
      setPrepaymentAmount('');
      setPrepaymentMethod(null);
    }
  }, [isEditMode, setPrepaymentId, setPrepaymentAmount, setPrepaymentMethod]);

  const handleDeletePrepayment = () => {
    modalHelpers.showDeletePrepaymentConfirm({
      confirmDeletePrepayment: async () => {
        handlePrepaymentDeleted();
      },
    });
  };

  const { user } = useAuthStore();
  const showSnackbar = useSnackbarStore((state) => state.showSnackbar);

  const removeItem = useCallback(
    (itemId: string) => {
      if (isEditMode) {
        const item = items.find((i) => i.id === itemId);
        if (!item) return;

        if (
          item.preparationStatus === 'READY' ||
          item.preparationStatus === 'DELIVERED'
        ) {
          showSnackbar({
            message: `No se puede eliminar un producto ${PreparationStatusInfo.getLabel(item.preparationStatus || '').toLowerCase()}`,
            type: 'error',
          });
          return;
        }

        if (item.preparationStatus === 'IN_PROGRESS') {
          modalHelpers.showModifyInProgressConfirmation({
            modifyingItemName: item.productName,
            pendingModifyAction: () => removeCartItem(itemId),
            setPendingModifyAction: () => {},
            setModifyingItemName: () => {},
          });
        } else {
          removeCartItem(itemId);
        }
      } else {
        removeCartItem(itemId);
      }
    },
    [isEditMode, items, showSnackbar, removeCartItem],
  );

  const updateItemQuantity = useCallback(
    (itemId: string, quantity: number) => {
      if (isEditMode) {
        if (quantity <= 0) {
          removeItem(itemId);
          return;
        }

        const item = items.find((i) => i.id === itemId);
        if (!item) return;

        if (
          item.preparationStatus === 'READY' ||
          item.preparationStatus === 'DELIVERED'
        ) {
          showSnackbar({
            message: `No se puede modificar un producto ${PreparationStatusInfo.getLabel(item.preparationStatus || '').toLowerCase()}`,
            type: 'error',
          });
          return;
        }

        const updateQuantity = () => {
          updateCartItemQuantity(itemId, quantity);
        };

        if (item.preparationStatus === 'IN_PROGRESS') {
          modalHelpers.showModifyInProgressConfirmation({
            modifyingItemName: item.productName,
            pendingModifyAction: updateQuantity,
            setPendingModifyAction: () => {},
            setModifyingItemName: () => {},
          });
        } else {
          updateQuantity();
        }
      } else {
        updateCartItemQuantity(itemId, quantity);
      }
    },
    [isEditMode, items, removeItem, showSnackbar, updateCartItemQuantity],
  );

  const canRegisterPayments = useMemo(() => {
    return checkCanRegisterPayments(user);
  }, [user]);


  useEffect(() => {
    if (!visible && isEditMode) {
      clearEditingState();
    }
  }, [visible, isEditMode, clearEditingState]);

  useEffect(() => {
    if (visible && !isModalReady) {
      const timer = setTimeout(() => {
        setIsModalReady(true);
      }, 100);
      return () => clearTimeout(timer);
    }
  }, [visible, isModalReady]);

  const handleAddAdjustment = useCallback(
    (adjustment: OrderAdjustment) => {
      if (isEditMode) {
        addAdjustment(adjustment);
      }
    },
    [isEditMode, addAdjustment],
  );

  const handleUpdateAdjustment = useCallback(
    (id: string, updatedAdjustment: OrderAdjustment) => {
      if (isEditMode) {
        updateAdjustment(id, updatedAdjustment);
      }
    },
    [isEditMode, updateAdjustment],
  );

  const handleRemoveAdjustment = useCallback(
    (id: string) => {
      if (isEditMode) {
        removeAdjustment(id);
      }
    },
    [isEditMode, removeAdjustment],
  );

  const handleConfirm = async () => {
    if (!user?.id) {
      showSnackbar({
        message: 'Error: No se pudo identificar el usuario',
        type: 'error',
      });
      return;
    }

    if (!validateOrder()) {
      return;
    }

    try {
      await confirmOrder(user.id, onConfirmOrder);

      if (isEditMode) {
        showSnackbar({
          message: 'Cambios guardados exitosamente',
          type: 'success',
        });
        onClose?.();
      }
    } catch (error) {
      showSnackbar({
        message:
          error instanceof Error ? error.message : 'Error al procesar la orden',
        type: 'error',
      });
    }
  };

  const handleTimeConfirm = (date: Date) => {
    const now = new Date();
    now.setSeconds(0, 0);

    if (date < now) {
      modalHelpers.hideModal();
      modalHelpers.showTimeAlert();
    } else {
      setScheduledTime(date);
      modalHelpers.hideModal();
    }
  };

  const handleUpdateEditedItem = useCallback(
    (
      itemId: string,
      quantity: number,
      modifiers: CartItemModifier[],
      preparationNotes?: string,
      variantId?: string,
      variantName?: string,
      unitPrice?: number,
      selectedPizzaCustomizations?: SelectedPizzaCustomization[],
      pizzaExtraCost?: number,
    ) => {
      if (!isEditMode) return;

      updateCartItem(
        itemId,
        quantity,
        modifiers,
        preparationNotes,
        variantId,
        variantName,
        unitPrice,
        selectedPizzaCustomizations,
        pizzaExtraCost,
      );

      clearEditingState();
    },
    [isEditMode, updateCartItem, clearEditingState],
  );

  const renderFields = () => {
    switch (orderType) {
      case OrderTypeEnum.DINE_IN:
        return (
          <DineInForm
            ref={dineInFormRef}
            onScheduleTimePress={showTimePicker}
          />
        );
      case OrderTypeEnum.TAKE_AWAY:
        return (
          <TakeAwayForm
            ref={takeAwayFormRef}
            onScheduleTimePress={showTimePicker}
          />
        );
      case OrderTypeEnum.DELIVERY:
        return (
          <DeliveryForm
            ref={deliveryFormRef}
            onScheduleTimePress={showTimePicker}
          />
        );
      default:
        return null;
    }
  };

  if (isEditMode && isLoadingOrder) {
    return (
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onClose}
          contentContainerStyle={styles.modalContent}
        >
          <View style={[styles.container, styles.loadingContainer]}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
            <Text style={styles.loadingText}>Cargando orden...</Text>
          </View>
        </Modal>
      </Portal>
    );
  }

  if (isEditMode && isErrorOrder) {
    return (
      <Portal>
        <Modal
          visible={visible}
          onDismiss={onClose}
          contentContainerStyle={styles.errorModalContent}
        >
          <View style={styles.errorModalContainer}>
            <View
              style={[
                styles.errorIconContainer,
                { backgroundColor: theme.colors.errorContainer },
              ]}
            >
              <IconButton
                icon="alert-circle-outline"
                size={48}
                iconColor={theme.colors.error}
                style={styles.iconButtonNoMargin}
              />
            </View>

            <Text
              style={[
                styles.errorModalTitle,
                { color: theme.colors.onSurface },
              ]}
            >
              No se pudo cargar la orden
            </Text>

            <Text
              style={[
                styles.errorModalMessage,
                { color: theme.colors.onSurfaceVariant },
              ]}
            >
              Ha ocurrido un error al intentar cargar los datos de la orden. Por
              favor, intenta nuevamente ms tarde.
            </Text>

            <Button
              mode="contained"
              onPress={onClose}
              style={styles.errorModalButton}
              contentStyle={styles.errorModalButtonContent}
              labelStyle={styles.errorModalButtonLabel}
            >
              Entendido
            </Button>
          </View>
        </Modal>
      </Portal>
    );
  }

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={() => {
          if (isEditMode && hasUnsavedChanges) {
            modalHelpers.showExitConfirmation({
              onClose,
            });
          } else {
            onClose?.();
          }
        }}
        contentContainerStyle={styles.modalContent}
        dismissable={true}
        dismissableBackButton={false}
      >
        <GestureHandlerRootView style={styles.container}>
          <TouchableWithoutFeedback
            onPress={Keyboard.dismiss}
            accessible={false}
          >
            <View>
              {isEditMode ? (
                <View style={styles.customHeader}>
                  <IconButton
                    icon="arrow-left"
                    size={24}
                    onPress={() => {
                      if (hasUnsavedChanges) {
                        modalHelpers.showExitConfirmation({
                          onClose,
                        });
                      } else {
                        onClose?.();
                      }
                    }}
                    iconColor={theme.colors.onSurface}
                  />

                  <View style={styles.headerTitleContainer}>
                    <Text style={styles.headerTitle}>
                      {orderNumber && orderDate
                        ? `Editar Orden #${orderNumber}`
                        : orderNumber
                          ? `Editando Orden #${orderNumber}`
                          : 'Editar Orden'}
                    </Text>
                    {orderData?.orderStatus && (
                      <View
                        style={[
                          styles.orderStatusBadge,
                          {
                            backgroundColor: OrderStatusInfo.getColor(
                              orderData.orderStatus,
                              theme,
                            ),
                          },
                        ]}
                      >
                        <Text style={styles.orderStatusText}>
                          {OrderStatusInfo.getLabel(orderData.orderStatus)}
                        </Text>
                      </View>
                    )}
                  </View>

                  <Menu
                    visible={showOptionsMenu}
                    onDismiss={() => setShowOptionsMenu(false)}
                    anchor={
                      <IconButton
                        icon="dots-vertical"
                        size={24}
                        onPress={() => setShowOptionsMenu(true)}
                        iconColor={theme.colors.onSurface}
                      />
                    }
                  >
                    <Menu.Item
                      onPress={() => {
                        setShowOptionsMenu(false);
                        modalHelpers.showOrderDetail({
                          orderId,
                          orderNumber,
                          orderData,
                        });
                      }}
                      title="Ver Detalles"
                      leadingIcon="file-document-outline"
                    />
                    <Menu.Item
                      onPress={() => {
                        setShowOptionsMenu(false);
                        modalHelpers.showOrderHistory({
                          orderId,
                          orderNumber,
                        });
                      }}
                      title="Ver Historial"
                      leadingIcon="history"
                    />
                    <Menu.Item
                      onPress={() => {
                        setShowOptionsMenu(false);
                        modalHelpers.showCancelConfirmation({
                          orderNumber,
                          onCancelOrder,
                        });
                      }}
                      title="Cancelar Orden"
                      leadingIcon="cancel"
                    />
                  </Menu>
                </View>
              ) : (
                <OrderHeader
                  title={
                    orderNumber ? `Orden #${orderNumber}` : 'Resumen de Orden'
                  }
                  onBackPress={() => {
                    if (!isEditMode && hasUnsavedChanges) {
                      modalHelpers.showExitConfirmation({
                        onClose,
                      });
                    } else {
                      onClose?.();
                    }
                  }}
                  itemCount={totalItemsCount}
                  onCartPress={() => {}}
                  isCartVisible={isCartVisible}
                />
              )}
            </View>
          </TouchableWithoutFeedback>

          <ScrollView
            style={styles.scrollView}
            keyboardShouldPersistTaps="handled"
            keyboardDismissMode="on-drag"
          >
            <OrderTypeSelector
              value={orderType}
              onValueChange={setOrderType}
              disabled={false}
            />

            {renderFields()}

            <Divider style={styles.divider} />

            <OrderItemsList
              items={items}
              isEditMode={isEditMode}
              onEditItem={handleEditCartItem}
              onRemoveItem={removeItem}
              onUpdateQuantity={updateItemQuantity}
            />

            {isEditMode && (
              <Button
                onPress={() => {
                  if (onAddProducts) {
                    onAddProducts();
                  } else if (navigation && orderId && orderNumber) {
                    try {
                      navigation.navigate('AddProductsToOrder', {
                        orderId,
                        orderNumber,
                        existingOrderItemsCount: items
                          .filter((item) => !item.id.startsWith('new-'))
                          .reduce((sum, item) => sum + item.quantity, 0),
                        onProductsAdded: (newProducts: CartItem[]) => {
                          const newProductsWithStatus = newProducts.map(
                            (item) => ({
                              ...item,
                              preparationStatus: 'NEW' as const,
                              id: `new-${Date.now()}-${Math.floor(Math.random() * 1000000)}`,
                            }),
                          );

                          newProductsWithStatus.forEach((item) => {
                            addItem(
                              {
                                id: item.productId,
                                name: item.productName,
                                price: item.unitPrice,
                              } as any,
                              item.quantity,
                              item.variantId,
                              item.modifiers,
                              item.preparationNotes,
                              item.selectedPizzaCustomizations,
                              item.pizzaExtraCost,
                            );
                          });

                          showSnackbar({
                            message: `${newProducts.length} producto${newProducts.length > 1 ? 's' : ''} aadido${newProducts.length > 1 ? 's' : ''}`,
                            type: 'success',
                          });
                        },
                      });
                    } catch (error) {}
                  }
                }}
                mode="outlined"
                style={styles.addProductsButton}
                icon="plus-circle-outline"
              >
                Aadir Productos
              </Button>
            )}

            <Divider style={styles.divider} />

            {/* Seccin de ajustes */}
            {isEditMode && (
              <OrderAdjustments
                adjustments={adjustments}
                subtotal={subtotal}
                onAddAdjustment={() =>
                  modalHelpers.showAdjustment({
                    adjustmentToEdit: null,
                    setAdjustmentToEdit: () => {},
                    handleAddAdjustment,
                    handleUpdateAdjustment,
                    subtotal,
                  })
                }
                onEditAdjustment={(adjustment) => {
                  modalHelpers.showAdjustment({
                    adjustmentToEdit: adjustment,
                    setAdjustmentToEdit: () => {},
                    handleAddAdjustment,
                    handleUpdateAdjustment,
                    subtotal,
                  });
                }}
                onRemoveAdjustment={handleRemoveAdjustment}
                disabled={false}
                canManageAdjustments={true}
              />
            )}

            {/* Resumen de totales */}
            <View style={styles.totalsSection}>
              <View style={styles.totalsContainer}>
                <Text style={styles.totalsText}>Subtotal:</Text>
                <Text style={styles.totalsValue}>${subtotal.toFixed(2)}</Text>
              </View>
              {totalAdjustments > 0 && (
                <View style={styles.totalsContainer}>
                  <Text style={styles.totalsText}>Descuentos:</Text>
                  <Text style={[styles.totalsValue, styles.discountText]}>
                    -${totalAdjustments.toFixed(2)}
                  </Text>
                </View>
              )}
              <Divider style={styles.totalDivider} />
              <View style={styles.totalsContainer}>
                <Text style={styles.totalLabel}>Total:</Text>
                <Text style={styles.totalValue}>${total.toFixed(2)}</Text>
              </View>
            </View>

            <PrepaymentSection
              isEditMode={isEditMode}
              prepaymentId={prepaymentId}
              paymentAmount={paymentAmount}
              paymentMethod={paymentMethod}
              total={total}
              totalPaid={totalPaid}
              pendingAmount={pendingAmount}
              canRegisterPayments={canRegisterPayments}
              onShowPrepaymentModal={() =>
                modalHelpers.showPrepayment({
                  orderTotal: total,
                  prepaymentId,
                  handlePrepaymentCreated,
                  handlePrepaymentDeleted,
                })
              }
              onDeletePrepayment={handleDeletePrepayment}
            />
          </ScrollView>

          <View style={styles.footer}>
            <Button
              mode="contained"
              onPress={handleConfirm}
              disabled={
                isConfirming ||
                items.length === 0 ||
                (isEditMode && !hasUnsavedChanges)
              }
              style={[
                styles.confirmButton,
                isEditMode && hasUnsavedChanges && styles.cancelButton,
              ]}
              loading={isConfirming}
            >
              {isConfirming
                ? isEditMode
                  ? 'Guardando...'
                  : 'Enviando...'
                : isEditMode
                  ? hasUnsavedChanges
                    ? ' Guardar Cambios'
                    : 'Guardar Cambios'
                  : 'Enviar Orden'}
            </Button>
          </View>

          {isEditMode && orderId && visible && (
            <FAB
              icon="cash-multiple"
              style={[
                styles.paymentFab,
                hasUnsavedChanges
                  ? styles.paymentFabUnsaved
                  : pendingAmount <= 0
                    ? styles.paymentFabCompleted
                    : { backgroundColor: theme.colors.primary },
              ]}
              color="white"
              onPress={() => {
                if (hasUnsavedChanges) {
                  showSnackbar({
                    message:
                      'Debes guardar los cambios antes de registrar pagos',
                    type: 'warning',
                  });
                } else {
                  modalHelpers.showPayment({
                    orderId,
                    orderTotal: total,
                    orderNumber,
                    orderStatus: orderData?.orderStatus,
                    onOrderCompleted: () => {
                      onClose?.();
                    },
                  });
                }
              }}
              visible={true}
            />
          )}

          <ModalsContainer />
        </GestureHandlerRootView>
      </Modal>
    </Portal>
  );
};

const createStyles = (theme: ReturnType<typeof useAppTheme>) =>
  StyleSheet.create({
    modalContent: {
      backgroundColor: theme.colors.background,
      width: '100%',
      height: '100%',
      margin: 0,
      padding: 0,
      position: 'absolute',
      top: 0,
      left: 0,
    },
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    scrollView: {
      flex: 1,
      paddingHorizontal: theme.spacing.s,
    },
    divider: {
      marginVertical: theme.spacing.s,
    },
    listItem: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingVertical: theme.spacing.s,
      paddingHorizontal: theme.spacing.s,
      backgroundColor: theme.colors.surface,
      minHeight: 80,
    },

    itemTextContainer: {
      flex: 3,
      marginRight: theme.spacing.xs,
      justifyContent: 'center',
    },
    itemTitleText: {
      fontSize: 15,
      fontWeight: '500',
      color: theme.colors.onSurface,
      flexWrap: 'wrap',
      lineHeight: 20,
    },
    itemDescription: {
      fontSize: 13,
      color: theme.colors.onSurfaceVariant,
      marginTop: 2,
      flexWrap: 'wrap',
      lineHeight: 18,
    },
    itemActionsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'flex-end',
      flexShrink: 0,
    },
    quantityActions: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    quantityButton: {
      marginHorizontal: -4,
      padding: 0,
    },
    quantityText: {
      fontSize: 14,
      fontWeight: 'bold',
      minWidth: 20,
      textAlign: 'center',
      marginHorizontal: 2,
    },
    itemPrice: {
      alignSelf: 'center',
      marginRight: theme.spacing.xs,
      color: theme.colors.onSurfaceVariant,
      fontSize: 15,
      fontWeight: 'bold',
      minWidth: 55,
      textAlign: 'right',
    },
    priceContainer: {
      flexDirection: 'column',
      alignItems: 'flex-end',
      marginRight: theme.spacing.xs,
    },
    unitPriceText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
    },
    deleteActionContainer: {
      width: 120,
      height: '100%',
      justifyContent: 'center',
      alignItems: 'flex-end',
      paddingRight: theme.spacing.m,
    },
    deleteAction: {
      backgroundColor: theme.colors.error,
      justifyContent: 'center',
      alignItems: 'center',
      width: 90,
      height: '90%',
      borderRadius: theme.roundness * 2,
      flexDirection: 'column',
      shadowColor: theme.colors.error,
      shadowOffset: {
        width: 0,
        height: 2,
      },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
      elevation: 5,
    },
    deleteIconContainer: {
      width: 50,
      height: 50,
      borderRadius: 25,
      backgroundColor: 'rgba(255, 255, 255, 0.2)',
      justifyContent: 'center',
      alignItems: 'center',
      marginBottom: 4,
    },
    deleteIcon: {
      margin: 0,
      padding: 0,
    },
    deleteActionText: {
      color: 'white',
      fontSize: 11,
      fontWeight: '700',
      letterSpacing: 1,
      textTransform: 'uppercase',
    },
    totalsContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      marginBottom: theme.spacing.xs,
      paddingHorizontal: theme.spacing.xs,
    },
    totalsText: {
      fontSize: 16,
    },
    totalsValue: {
      fontSize: 16,
      fontWeight: 'bold',
    },
    totalLabel: {
      fontWeight: 'bold',
      fontSize: 18,
    },
    totalValue: {
      fontSize: 18,
      color: theme.colors.primary,
    },
    totalsSection: {
      paddingHorizontal: theme.spacing.m,
      paddingVertical: theme.spacing.s,
    },
    discountText: {
      color: theme.colors.primary,
    },
    totalDivider: {
      marginVertical: theme.spacing.s,
    },
    section: {
      marginBottom: theme.spacing.m,
      marginTop: theme.spacing.s,
    },
    sectionCompact: {
      marginBottom: 0,
      paddingBottom: 0,
    },
    dineInSelectorsRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      marginBottom: 0,
      gap: theme.spacing.s,
      marginTop: theme.spacing.s,
    },
    dineInSelectorContainer: {
      flex: 1,
    },
    selectorLoader: {},
    sectionTitleContainer: {
      flexDirection: 'row',
      alignItems: 'baseline',
      marginBottom: theme.spacing.xs,
    },
    sectionTitle: {
      fontSize: 16,
      fontWeight: 'bold',
      marginBottom: theme.spacing.xs,
    },
    sectionTitleOptional: {
      ...theme.fonts.bodySmall,
      color: theme.colors.onSurfaceVariant,
      marginLeft: theme.spacing.xs,
    },
    radioGroupHorizontal: {
      flexDirection: 'row',
      justifyContent: 'space-around',
      alignItems: 'center',
      width: '100%',
      paddingVertical: theme.spacing.xs,
    },
    radioLabel: {
      marginLeft: 0,
      fontSize: 11,
      textTransform: 'uppercase',
      textAlign: 'center',
    },
    radioButtonItem: {
      paddingHorizontal: 0,
      paddingVertical: 4,
      flexShrink: 1,
      flex: 1,
      marginHorizontal: 2,
    },
    dropdownAnchor: {},
    dropdownContent: {},
    dropdownLabel: {},
    helperTextFix: {
      marginTop: -6,
      marginBottom: 0,
      paddingHorizontal: 12,
    },
    footer: {
      padding: theme.spacing.m,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
      backgroundColor: theme.colors.surface,
    },
    confirmButton: {
      paddingVertical: theme.spacing.xs,
    },
    input: {},
    fieldContainer: {
      marginTop: theme.spacing.s,
    },
    loadingContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
    loadingText: {
      marginTop: theme.spacing.m,
      color: theme.colors.onSurfaceVariant,
    },
    errorContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
    errorText: {
      color: theme.colors.error,
      marginBottom: theme.spacing.m,
    },
    phoneHelperContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
      marginTop: 2,
      paddingHorizontal: 12,
      minHeight: 20,
    },
    digitCounter: {
      fontSize: 10,
      color: theme.colors.onSurfaceVariant,
      opacity: 0.6,
      marginLeft: theme.spacing.xs,
      marginTop: 2,
    },
    phoneInputWrapper: {
      position: 'relative',
    },
    digitCounterAbsolute: {
      position: 'absolute',
      right: 50,
      top: 10,
      fontSize: 10,
      color: theme.colors.onSurfaceVariant,
      opacity: 0.7,
      backgroundColor: theme.colors.background,
      paddingHorizontal: 8,
      paddingVertical: 3,
      borderRadius: 12,
      zIndex: 1,
    },
    notesText: {
      fontStyle: 'italic',
      marginTop: 4,
      paddingTop: 4,
      borderTopWidth: 1,
      borderTopColor: theme.colors.outlineVariant,
    },
    customHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: 4,
      paddingVertical: 8,
      backgroundColor: theme.colors.elevation.level2,
    },
    headerTitleContainer: {
      flex: 1,
      alignItems: 'center',
      gap: 4,
    },
    headerTitle: {
      ...theme.fonts.titleMedium,
      color: theme.colors.onSurface,
      fontWeight: 'bold',
      textAlign: 'center',
    },
    orderStatusBadge: {
      paddingHorizontal: 12,
      paddingVertical: 4,
      borderRadius: 12,
    },
    orderStatusText: {
      ...theme.fonts.labelSmall,
      color: 'white',
      fontWeight: '600',
      fontSize: 11,
    },
    statusContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      marginTop: 2,
      justifyContent: 'flex-start',
    },
    statusBadge: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingHorizontal: theme.spacing.s,
      paddingVertical: 2,
      borderRadius: 12,
      gap: 4,
    },
    statusDot: {
      width: 6,
      height: 6,
      borderRadius: 3,
    },
    statusText: {
      fontSize: 11,
      fontWeight: '600',
      textTransform: 'uppercase',
      letterSpacing: 0.5,
    },
    paymentFab: {
      position: 'absolute',
      margin: 16,
      right: 0,
      bottom: 140,
      zIndex: 1000,
      elevation: 6,
      width: 56,
      height: 56,
      justifyContent: 'center',
      alignItems: 'center',
    },
    paymentConfigButton: {
      marginTop: theme.spacing.s,
    },
    paymentValueContainer: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    editPaymentButton: {
      margin: 0,
      marginLeft: theme.spacing.xs,
      width: 28,
      height: 28,
    },
    checkboxContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      marginTop: theme.spacing.s,
      marginBottom: theme.spacing.xs,
    },
    checkboxLabel: {
      fontSize: 16,
      marginLeft: theme.spacing.xs,
      color: theme.colors.onSurface,
    },
    temporaryTableInputContainer: {
      marginTop: theme.spacing.xs,
      marginBottom: theme.spacing.s,
    },
    errorModalContent: {
      backgroundColor: 'transparent',
      justifyContent: 'center',
      alignItems: 'center',
      padding: theme.spacing.m,
    },
    errorModalContainer: {
      backgroundColor: theme.colors.surface,
      borderRadius: theme.roundness * 3,
      padding: theme.spacing.xl,
      alignItems: 'center',
      width: '90%',
      maxWidth: 400,
      elevation: 5,
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 2,
      },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
    },
    errorIconContainer: {
      width: 80,
      height: 80,
      borderRadius: 40,
      justifyContent: 'center',
      alignItems: 'center',
      marginBottom: theme.spacing.m,
    },
    errorModalTitle: {
      fontSize: 20,
      fontWeight: 'bold',
      marginBottom: theme.spacing.s,
      textAlign: 'center',
    },
    errorModalMessage: {
      fontSize: 16,
      textAlign: 'center',
      marginBottom: theme.spacing.l,
      lineHeight: 22,
    },
    errorModalButton: {
      marginTop: theme.spacing.m,
      minWidth: 120,
    },
    errorModalButtonContent: {
      paddingHorizontal: theme.spacing.l,
    },
    errorModalButtonLabel: {
      fontSize: 16,
    },
    adjustmentButton: {
      marginTop: theme.spacing.m,
      marginBottom: theme.spacing.s,
    },
    addProductsButton: {
      marginTop: theme.spacing.m,
      marginBottom: theme.spacing.m,
    },
    iconButtonNoMargin: {
      margin: 0,
    },
    cancelButton: {
      backgroundColor: '#FF6B35',
    },
    paymentFabUnsaved: {
      backgroundColor: '#9CA3AF',
    },
    paymentFabCompleted: {
      backgroundColor: '#4CAF50',
    },
  });
export default OrderCartDetail;




================================================================
End of Codebase
================================================================
